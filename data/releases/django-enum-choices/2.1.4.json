{
  "info": {
    "author": "Vasil Slavov",
    "author_email": "vasil.slavov@hacksoft.io",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "Framework :: Django :: 1.11",
      "Framework :: Django :: 2.1",
      "Framework :: Django :: 2.2",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Software Development :: Libraries"
    ],
    "description": "\n# django-enum-choices (DEPRECATED)\n\nA custom Django choice field to use with [Python enums.](https://docs.python.org/3/library/enum.html)\n\n[![PyPI version](https://badge.fury.io/py/django-enum-choices.svg)](https://badge.fury.io/py/django-enum-choices)\n\n## ⚠️ Disclaimer ⚠️\n\nStarting with version 3.0, Django started supporting [Enumerations for model field choices](https://docs.djangoproject.com/en/dev/releases/3.0/#enumerations-for-model-field-choices) and we recommend using this as a native Django feature, instead of `django-enum-choices`\n\n**If you are using `django-enum-choices` and you want to upgrade your project to Django >= `3.0` you can refer to the guide in the wiki: [Migrating to Django 3](https://github.com/HackSoftware/django-enum-choices/wiki/Migrating-to-Django-3)**\n\n## Table of Contents\n\n- [django-enum-choices](#django-enum-choices)\n  - [Table of Contents](#table-of-contents)\n  - [Installation](#installation)\n  - [Basic Usage](#basic-usage)\n  - [Choice builders](#choice-builders)\n  - [Changing/Removing options from enumerations](#changingremoving-options-from-enumerations)\n    - [Changing options](#changing-options)\n    - [Removing options](#removing-options)\n  - [Usage inside the admin panel](#usage-in-the-admin-panel)\n  - [Usage with forms](#usage-with-forms)\n    - [Usage with `django.forms.ModelForm`](#usage-with-djangoformsmodelform)\n    - [Usage with `django.forms.Form`](#usage-with-djangoformsform)\n  - [Usage with `django-filter`](#usage-with-django-filter)\n    - [By using a `Meta` inner class and inheriting from `EnumChoiceFilterMixin`](#by-using-a-meta-inner-class-and-inheriting-from-enumchoicefiltermixin)\n    - [By declaring the field explicitly on the `FilterSet`](#by-declaring-the-field-explicitly-on-the-filterset)\n  - [Postgres ArrayField Usage](#postgres-arrayfield-usage)\n  - [Usage with Django Rest Framework](#usage-with-django-rest-framework)\n    - [Using `serializers.ModelSerializer` with `EnumChoiceModelSerializerMixin`](#using-serializersmodelserializer-with-enumchoicemodelserializermixin)\n    - [Using `serializers.ModelSerializer` without `EnumChoiceModelSerializerMixin`](#using-serializersmodelserializer-without-enumchoicemodelserializermixin)\n    - [Using a subclass of `serializers.Serializer`](#using-a-subclass-of-serializersserializer)\n    - [Serializing PostgreSQL ArrayField](#serializing-postgresql-arrayfield)\n  - [Implementation details](#implementation-details)\n  - [Using Python's `enum.auto`](#using-pythons-enumauto)\n  - [Development](#development)\n\n## Installation\n\n```bash\npip install django-enum-choices\n```\n\n## Basic Usage\n\n```python\nfrom enum import Enum\n\nfrom django.db import models\n\nfrom django_enum_choices.fields import EnumChoiceField\n\n\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\n\nclass MyModel(models.Model):\n    enumerated_field = EnumChoiceField(MyEnum)\n```\n\n**Model creation**\n\n```python\ninstance = MyModel.objects.create(enumerated_field=MyEnum.A)\n```\n\n**Changing enum values**\n\n```python\ninstance.enumerated_field = MyEnum.B\ninstance.save()\n```\n\n**Filtering**\n\n```python\nMyModel.objects.filter(enumerated_field=MyEnum.A)\n```\n\n## Choice builders\n\n`EnumChoiceField` extends `CharField` and generates choices internally. Each choice is generated using something, called a `choice_builder`.\n\nA choice builder function looks like that:\n\n```python\ndef choice_builder(enum: Enum) -> Tuple[str, str]:\n    # Some implementation\n```\n\nIf a `choice_builder` argument is passed to a model's `EnumChoiceField`, `django_enum_choices` will use it to generate the choices.\nThe `choice_builder` must be a callable that accepts an enumeration choice and returns a tuple,\ncontaining the value to be saved and the readable value.\n\nBy default `django_enum_choices` uses one of the four choice builders defined in `django_enum_choices.choice_builders`, named `value_value`.\n\nIt returns a tuple containing the enumeration's value twice:\n\n```python\nfrom django_enum_choices.choice_builders import value_value\n\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\nprint(value_value(MyEnum.A))  # ('a', 'a')\n```\n\nYou can use one of the four default ones that fits your needs:\n\n* `value_value`\n* `attribute_value`\n* `value_attribute`\n* `attribute_attribute`\n\nFor example:\n\n```python\nfrom django_enum_choices.choice_builders import attribute_value\n\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\nclass CustomReadableValueEnumModel(models.Model):\n    enumerated_field = EnumChoiceField(\n        MyEnum,\n        choice_builder=attribute_value\n    )\n```\n\nThe resulting choices for `enumerated_field` will be `(('A', 'a'), ('B', 'b'))`\n\nYou can also define your own choice builder:\n\n```python\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\ndef choice_builder(choice: Enum) -> Tuple[str, str]:\n    return choice.value, choice.value.upper() + choice.value\n\nclass CustomReadableValueEnumModel(models.Model):\n    enumerated_field = EnumChoiceField(\n        MyEnum,\n        choice_builder=choice_builder\n    )\n```\n\nWhich will result in the following choices `(('a', 'Aa'), ('b', 'Bb'))`\n\nThe values in the returned from `choice_builder` tuple will be cast to strings before being used.\n\n## Changing/Removing options from enumerations\nAt any given point of time all instances of a model that has `EnumChoiceField` must have a value that is currently present in the enumeration.\nWhen changing or removing an option from the enumeration, a custom database migration must be made prior to the enumeration change.\n\n### Changing options\nWhen chaging options we'll need several operations:\n\n1. Inserting a new option with the new value that we want\n2. Migrating all instances from the old option to the new one\n3. Removing the old option and renaming the old one\n4. Removing the custom data migration code, so migrations can be run on a clean database without an `AttributeError` ocurring\n\nExample:\n\nInitial setup:\n\n```python\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\n# Desired change:\n# A = 'a_updated'\n\nclass MyModel(models.Model):\n    enumerated_field = EnumChoiceField(MyEnum)\n```\n\n1. Insert a new option with the desired new value:\n```python\nclass MyEnum:\n    A_UPDATED = 'a_updated'\n    A = 'a'\n    B = 'b'\n```\n```bash\npython manage.py makemigrations\n```\n\n2. Migrate model instances\n```bash\npython manage.py makemigrations app_label --empty\n```\n```python\n# migration_name.py\n\ndef forwards(apps, schema_editor):\n    MyModel = apps.get_model('app_label', 'MyModel')\n\n    MyModel.objects.filter(enumerated_field=MyEnum.A).update(enumerated_field=MyEnum.A_UPDATED)\n\nclass Migration(migrations.Migration):\n    ...\n\n    operations = [\n        migrations.RunPython(forwards),\n    ]\n```\n```bash\npython manage.py migrate\n```\n\n3. Remove old option and rename new one\n```python\nclass MyEnum:\n    A = 'a_updated'\n    B = 'b'\n```\n```bash\npython manage.py makemigrations\npython manage.py migrate\n```\n\n4. Remove custom data migration code\n```python\n# migration_name.py\n\ndef forwards(apps, schema_editor):\n\tpass\n\nclass Migration(migrations.Migration):\n    ...\n\n    operations = [\n        migrations.RunPython(forwards),\n    ]\n```\n\n### Removing options\nRemoving options from the enumeration includes several operations as well:\n\n1. Optional: Making the field nullable (if we want our existing instances' values to be `None`)\n2. Migrating all instances to a new option (or None)\n3. Removing the option from the enumeration\n4. Removing the custom data migration code, so migrations can be run on a clean database without an `AttributeError` ocurring\n\nExample:\n\nInitial setup:\n\n```python\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\n# Desired change:\n# class MyEnum(Enum):\n#     A = 'a'\n\nclass MyModel(models.Model):\n    enumerated_field = EnumChoiceField(MyEnum)\n```\n\n1. Optional: Make the field nullable (if you want your existing instances to have a `None` value)\n```python\nclass MyModel(models.Model):\n    enumerated_field = EnumChoiceField(MyEnum, blank=True, null=True)\n```\n```bash\npython manage.py makemigrations\n```\n\n2. Migrate model instances\n```bash\npython manage.py makemigrations app_label --empty\n```\n```python\n# migration_name.py\n\ndef forwards(apps, schema_editor):\n    MyModel = apps.get_model('app_label', 'MyModel')\n\n    MyModel.objects.filter(enumerated_field=MyEnum.B).update(enumerated_field=MyEnum.A)\n\t# OR MyModel.objects.filter(enumerated_field=MyEnum.B).update(enumerated_field=None)\n\nclass Migration(migrations.Migration):\n    ...\n\n    operations = [\n        migrations.RunPython(forwards),\n    ]\n```\n```bash\npython manage.py migrate\n```\n\n3. Remove old option\n```python\nclass MyEnum:\n    A = 'a\n```\n```bash\npython manage.py makemigrations\npython manage.py migrate\n```\n\n4. Remove custom data migration code\n```python\n# migration_name.py\n\ndef forwards(apps, schema_editor):\n\tpass\n\nclass Migration(migrations.Migration):\n    ...\n\n    operations = [\n        migrations.RunPython(forwards),\n    ]\n```\n\n\n## Usage in the admin panel\n\nModel fields, defined as `EnumChoiceField` can be used with almost all of the admin panel's\nstandard functionallities.\n\nOne exception from this their usage in `list_filter`.\n\nIf you need an `EnumChoiceField` inside a `ModelAdmin`'s `list_filter`, you can use the following\noptions:\n\n* Define the entry insite the list filter as a tuple, containing the field's name and `django_enum_choices.admin.EnumChoiceListFilter`\n\n```python\nfrom django.contrib import admin\n\nfrom django_enum_choices.admin import EnumChoiceListFilter\n\nfrom .models import MyModel\n\n@admin.register(MyModel)\nclass MyModelAdmin(admin.ModelAdmin):\n    list_filter = [('enumerated_field', EnumChoiceListFilter)]\n```\n\n* Set `DJANGO_ENUM_CHOICES_REGISTER_LIST_FILTER` inside your settings to `True`, which will automatically set the `EnumChoiceListFilter` class to all\n`list_filter` fields that are instances of `EnumChoiceField`. This way, they can be declared directly in the `list_filter` iterable:\n\n```python\nfrom django.contrib import admin\n\nfrom .models import MyModel\n\n@admin.register(MyModel)\nclass MyModelAdmin(admin.ModelAdmin):\n    list_filter = ('enumerated_field', )\n```\n\n\n## Usage with forms\n\nThere are 2 rules of thumb:\n\n1. If you use a `ModelForm`, everything will be taken care of automatically.\n2. If you use a `Form`, you need to take into account what `Enum` and `choice_builder` you are using.\n\n\n### Usage with `django.forms.ModelForm`\n\n```python\nfrom .models import MyModel\n\nclass ModelEnumForm(forms.ModelForm):\n    class Meta:\n        model = MyModel\n        fields = ['enumerated_field']\n\nform = ModelEnumForm({\n    'enumerated_field': 'a'\n})\n\nform.is_valid()\n\nprint(form.save(commit=True))  # <MyModel: MyModel object (12)>\n```\n\n### Usage with `django.forms.Form`\n\nIf you are using the default `value_value` choice builder, you can just do that:\n\n```python\nfrom django_enum_choices.forms import EnumChoiceField\n\nfrom .enumerations import MyEnum\n\nclass StandardEnumForm(forms.Form):\n    enumerated_field = EnumChoiceField(MyEnum)\n\nform = StandardEnumForm({\n    'enumerated_field': 'a'\n})\nform.is_valid()\n\nprint(form.cleaned_data)  # {'enumerated_field': <MyEnum.A: 'a'>}\n```\n\nIf you are passing a different choice builder, you have to also pass it to the form field:\n\n```python\nfrom .enumerations import MyEnum\n\ndef custom_choice_builder(choice):\n    return 'Custom_' + choice.value, choice.value\n\nclass CustomChoiceBuilderEnumForm(forms.Form):\n    enumerated_field = EnumChoiceField(\n        MyEnum,\n        choice_builder=custom_choice_builder\n    )\n\nform = CustomChoiceBuilderEnumForm({\n    'enumerated_field': 'Custom_a'\n})\n\nform.is_valid()\n\nprint(form.cleaned_data)  # {'enumerated_field': <MyEnum.A: 'a'>}\n```\n\n## Usage with `django-filter`\n\nAs with forms, there are 2 general rules of thumb:\n\n1. If you have declared an `EnumChoiceField` in the `Meta.fields` for a given `Meta.model`, you need to inherit `EnumChoiceFilterMixin` in your filter class & everything will be taken care of automatically.\n2. If you are declaring an explicit field, without a model, you need to specify the `Enum` class & the `choice_builder`, if a custom one is used.\n\n### By using a `Meta` inner class and inheriting from `EnumChoiceFilterMixin`\n\n```python\nimport django_filters as filters\n\nfrom django_enum_choices.filters import EnumChoiceFilterMixin\n\nclass ImplicitFilterSet(EnumChoiceFilterSetMixin, filters.FilterSet):\n    class Meta:\n        model = MyModel\n        fields = ['enumerated_field']\n\nfilters = {\n    'enumerated_field': 'a'\n}\nfilterset = ImplicitFilterSet(filters)\n\nprint(filterset.qs.values_list('enumerated_field', flat=True))\n# <QuerySet [<MyEnum.A: 'a'>, <MyEnum.A: 'a'>, <MyEnum.A: 'a'>]>\n```\n\nThe `choice_builder` argument can be passed to `django_enum_choices.filters.EnumChoiceFilter` as well when using the field explicitly. When using `EnumChoiceFilterSetMixin`, the `choice_builder` is determined from the model field, for the fields defined inside the `Meta` inner class.\n\n```python\nimport django_filters as filters\n\nfrom django_enum_choices.filters import EnumChoiceFilter\n\ndef custom_choice_builder(choice):\n    return 'Custom_' + choice.value, choice.value\n\nclass ExplicitCustomChoiceBuilderFilterSet(filters.FilterSet):\n    enumerated_field = EnumChoiceFilter(\n        MyEnum,\n        choice_builder=custom_choice_builder\n    )\n\nfilters = {\n    'enumerated_field': 'Custom_a'\n}\nfilterset = ExplicitCustomChoiceBuilderFilterSet(filters, MyModel.objects.all())\n\nprint(filterset.qs.values_list('enumerated_field', flat=True))  # <QuerySet [<MyEnum.A: 'a'>, <MyEnum.A: 'a'>, <MyEnum.A: 'a'>]>\n```\n\n\n### By declaring the field explicitly on the `FilterSet`\n\n```python\nimport django_filters as filters\n\nfrom django_enum_choices.filters import EnumChoiceFilter\n\nclass ExplicitFilterSet(filters.FilterSet):\n    enumerated_field = EnumChoiceFilter(MyEnum)\n\n\nfilters = {\n    'enumerated_field': 'a'\n}\nfilterset = ExplicitFilterSet(filters, MyModel.objects.all())\n\nprint(filterset.qs.values_list('enumerated_field', flat=True))  # <QuerySet [<MyEnum.A: 'a'>, <MyEnum.A: 'a'>, <MyEnum.A: 'a'>]>\n```\n\n## Postgres ArrayField Usage\n\nYou can use `EnumChoiceField` as a child field of an Postgres `ArrayField`.\n\n```python\nfrom django.db import models\nfrom django.contrib.postgres.fields import ArrayField\n\nfrom django_enum_choices.fields import EnumChoiceField\n\nfrom enum import Enum\n\nclass MyEnum(Enum):\n    A = 'a'\n    B = 'b'\n\nclass MyModelMultiple(models.Model):\n    enumerated_field = ArrayField(\n        base_field=EnumChoiceField(MyEnum)\n    )\n```\n\n**Model Creation**\n\n```python\ninstance = MyModelMultiple.objects.create(enumerated_field=[MyEnum.A, MyEnum.B])\n```\n\n**Changing enum values**\n\n```python\ninstance.enumerated_field = [MyEnum.B]\ninstance.save()\n```\n\n## Usage with Django Rest Framework\n\nAs with forms & filters, there are 2 general rules of thumb:\n\n1. If you are using a `ModelSerializer` and you inherit `EnumChoiceModelSerializerMixin`, everything will be taken care of automatically.\n2. If you are using a `Serializer`, you need to take the `Enum` class & `choice_builder` into acount.\n\n### Using `serializers.ModelSerializer` with `EnumChoiceModelSerializerMixin`\n\n```python\nfrom rest_framework import serializers\n\nfrom django_enum_choices.serializers import EnumChoiceModelSerializerMixin\n\nclass ImplicitMyModelSerializer(\n    EnumChoiceModelSerializerMixin,\n    serializers.ModelSerializer\n):\n    class Meta:\n        model = MyModel\n        fields = ('enumerated_field', )\n```\n\nBy default `ModelSerializer.build_standard_field` coerces any field that has a model field with choices to `ChoiceField` which returns the value directly.\n\nSince enum values resemble `EnumClass.ENUM_INSTANCE` they won't be able to be encoded by the `JSONEncoder` when being passed to a `Response`.\n\nThat's why we need the mixin.\n\nWhen using the `EnumChoiceModelSerializerMixin` with DRF's `serializers.ModelSerializer`, the `choice_builder` is automatically passed from the model field to the serializer field.\n\n### Using `serializers.ModelSerializer` without `EnumChoiceModelSerializerMixin`\n\n```python\nfrom rest_framework import serializers\n\nfrom django_enum_choices.serializers import EnumChoiceField\n\nclass MyModelSerializer(serializers.ModelSerializer):\n    enumerated_field = EnumChoiceField(MyEnum)\n\n    class Meta:\n        model = MyModel\n        fields = ('enumerated_field', )\n\n# Serialization:\ninstance = MyModel.objects.create(enumerated_field=MyEnum.A)\nserializer = MyModelSerializer(instance)\ndata = serializer.data  # {'enumerated_field': 'a'}\n\n# Saving:\nserializer = MyModelSerializer(data={\n    'enumerated_field': 'a'\n})\nserializer.is_valid()\nserializer.save()\n```\n\nIf you are using a custom `choice_builder`, you need to pass that too.\n\n```python\ndef custom_choice_builder(choice):\n    return 'Custom_' + choice.value, choice.value\n\nclass CustomChoiceBuilderSerializer(serializers.Serializer):\n    enumerted_field = EnumChoiceField(\n        MyEnum,\n        choice_builder=custom_choice_builder\n    )\n\nserializer = CustomChoiceBuilderSerializer({\n    'enumerated_field': MyEnum.A\n})\n\ndata = serializer.data # {'enumerated_field': 'Custom_a'}\n```\n\n### Using a subclass of `serializers.Serializer`\n\n```python\nfrom rest_framework import serializers\n\nfrom django_enum_choices.serializers import EnumChoiceField\n\nclass MySerializer(serializers.Serializer):\n    enumerated_field = EnumChoiceField(MyEnum)\n\n# Serialization:\nserializer = MySerializer({\n    'enumerated_field': MyEnum.A\n})\ndata = serializer.data  # {'enumerated_field': 'a'}\n\n# Deserialization:\nserializer = MySerializer(data={\n    'enumerated_field': 'a'\n})\nserializer.is_valid()\ndata = serializer.validated_data  # OrderedDict([('enumerated_field', <MyEnum.A: 'a'>)])\n```\n\nIf you are using a custom `choice_builder`, you need to pass that too.\n\n### Serializing PostgreSQL ArrayField\n\n`django-enum-choices` exposes a `MultipleEnumChoiceField` that can be used for serializing arrays of enumerations.\n\n**Using a subclass of `serializers.Serializer`**\n\n```python\nfrom rest_framework import serializers\n\nfrom django_enum_choices.serializers import MultipleEnumChoiceField\n\nclass MultipleMySerializer(serializers.Serializer):\n    enumerated_field = MultipleEnumChoiceField(MyEnum)\n\n# Serialization:\nserializer = MultipleMySerializer({\n    'enumerated_field': [MyEnum.A, MyEnum.B]\n})\ndata = serializer.data  # {'enumerated_field': ['a', 'b']}\n\n# Deserialization:\nserializer = MultipleMySerializer(data={\n    'enumerated_field': ['a', 'b']\n})\nserializer.is_valid()\ndata = serializer.validated_data  # OrderedDict([('enumerated_field', [<MyEnum.A: 'a'>, <MyEnum.B: 'b'>])])\n```\n\n**Using a subclass of `serializers.ModelSerializer`**\n\n```python\nclass ImplicitMultipleMyModelSerializer(\n    EnumChoiceModelSerializerMixin,\n    serializers.ModelSerializer\n):\n    class Meta:\n        model = MyModelMultiple\n        fields = ('enumerated_field', )\n\n# Serialization:\ninstance = MyModelMultiple.objects.create(enumerated_field=[MyEnum.A, MyEnum.B])\nserializer = ImplicitMultipleMyModelSerializer(instance)\ndata = serializer.data  # {'enumerated_field': ['a', 'b']}\n\n# Saving:\nserializer = ImplicitMultipleMyModelSerializer(data={\n    'enumerated_field': ['a', 'b']\n})\nserializer.is_valid()\nserializer.save()\n```\n\nThe `EnumChoiceModelSerializerMixin` does not need to be used if `enumerated_field` is defined on the serializer class explicitly.\n\n## Implementation details\n\n* `EnumChoiceField` is a subclass of `CharField`.\n* Only subclasses of `Enum` are valid arguments for `EnumChoiceField`.\n* `max_length`, if passed, is ignored. `max_length` is automatically calculated from the longest choice.\n* `choices` are generated using a special `choice_builder` function, which accepts an enumeration and returns a tuple of 2 items.\n  * Four choice builder functions are defined inside `django_enum_choices.choice_builders`\n  * By default the `value_value` choice builder is used. It produces the choices from the values in the enumeration class, like `(enumeration.value, enumeration.value)`\n  * `choice_builder` can be overriden by passing a callable to the `choice_builder` keyword argument of `EnumChoiceField`.\n  * All values returned from the choice builder **will be cast to strings** when generating choices.\n\nFor example, lets have the following case:\n\n```python\nclass Value:\n    def __init__(self, value):\n        self.value = value\n\n    def __str__(self):\n        return self.value\n\n\nclass CustomObjectEnum(Enum):\n    A = Value(1)\n    B = Value('B')\n\n\t# The default choice builder `value_value` is being used\n\nclass SomeModel(models.Model):\n    enumerated_field = EnumChoiceField(CustomObjectEnum)\n```\n\nWe'll have the following:\n\n* `SomeModel.enumerated_field.choices == (('1', '1'), ('B', 'B'))`\n* `SomeModel.enumerated_field.max_length == 3`\n\n## Using Python's `enum.auto`\n\n`enum.auto` can be used for shorthand enumeration definitions:\n\n```python\nfrom enum import Enum, auto\n\nclass AutoEnum(Enum):\n    A = auto()  # 1\n    B = auto()  # 2\n\nclass SomeModel(models.Model):\n    enumerated_field = EnumChoiceField(Enum)\n```\n\nThis will result in the following:\n* `SomeModel.enumerated_field.choices == (('1', '1'), ('2', '2'))`\n\n**Overridinng `auto` behaviour**\nCustom values for enumerations, created by `auto`, can be defined by\nsubclassing an `Enum` that defines `_generate_next_value_`:\n\n```python\nclass CustomAutoEnumValueGenerator(Enum):\n    def _generate_next_value_(name, start, count, last_values):\n        return {\n            'A': 'foo',\n            'B': 'bar'\n        }[name]\n\n\nclass CustomAutoEnum(CustomAutoEnumValueGenerator):\n    A = auto()\n    B = auto()\n```\n\nThe above will assign the values mapped in the dictionary as values to attributes in `CustomAutoEnum`.\n\n## Development\n\n**Prerequisites**\n* SQLite3\n* PostgreSQL server\n* Python >= 3.5 virtual environment\n\n**Fork the repository**\n```bash\ngit clone https://github.com/your-user-name/django-enum-choices.git django-enum-choices-yourname\ncd django-enum-choices-yourname\ngit remote add upstream https://github.com/HackSoftware/django-enum-choices.git\n```\n\nInstall the requirements:\n```bash\npip install -e .[dev]\n```\n\nLinting and running the tests:\n```bash\ntox\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/HackSoftware/django-enum-choices",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-enum-choices",
    "package_url": "https://pypi.org/project/django-enum-choices/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-enum-choices/",
    "project_urls": {
      "Homepage": "https://github.com/HackSoftware/django-enum-choices"
    },
    "release_url": "https://pypi.org/project/django-enum-choices/2.1.4/",
    "requires_dist": [
      "Django (>=1.11)",
      "Django (==2.2.3) ; extra == 'dev'",
      "djangorestframework (==3.9.4) ; extra == 'dev'",
      "psycopg2 (==2.8.3) ; extra == 'dev'",
      "flake8 (==3.7.7) ; extra == 'dev'",
      "pytest (==4.6.3) ; extra == 'dev'",
      "pytest-django (==3.5.0) ; extra == 'dev'",
      "pytest-pythonpath (==0.7.3) ; extra == 'dev'",
      "django-environ (==0.4.5) ; extra == 'dev'",
      "tox (==3.13.2) ; extra == 'dev'",
      "bumpversion (==0.5.3) ; extra == 'dev'",
      "tox-pyenv (==1.1.0) ; extra == 'dev'",
      "django-filter (==2.2.0) ; extra == 'dev'"
    ],
    "requires_python": ">=3.5.0",
    "summary": "A custom Django field able to use subclasses of Python's internal `Enum` class as choices",
    "version": "2.1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13709273,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4bedd342844875efb04098ca14d5e80e8c6348d0b9c7a7f73fc20ed81b9c1fbc",
        "md5": "3666db2573d309a3b72d16f63db68d21",
        "sha256": "ba0368280fcd5237db9b7d03edcaea8bee8afa30ffd8f2c8b47d3ae93d7fce09"
      },
      "downloads": -1,
      "filename": "django_enum_choices-2.1.4-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "3666db2573d309a3b72d16f63db68d21",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": ">=3.5.0",
      "size": 35914,
      "upload_time": "2022-05-04T12:17:39",
      "upload_time_iso_8601": "2022-05-04T12:17:39.418927Z",
      "url": "https://files.pythonhosted.org/packages/4b/ed/d342844875efb04098ca14d5e80e8c6348d0b9c7a7f73fc20ed81b9c1fbc/django_enum_choices-2.1.4-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b22cc1d3fd4469cdc81775f4d466147df6f4e99bc3fa9be24abec1fe1f156b5e",
        "md5": "241acb0b42fb565c5c6a8e83922ebb3b",
        "sha256": "1aabfe271aa40d39506ed4294e1c464c0278d1fbf4ecd4973da8f3cf78f3eee0"
      },
      "downloads": -1,
      "filename": "django_enum_choices-2.1.4.tar.gz",
      "has_sig": false,
      "md5_digest": "241acb0b42fb565c5c6a8e83922ebb3b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5.0",
      "size": 35467,
      "upload_time": "2022-05-04T12:17:42",
      "upload_time_iso_8601": "2022-05-04T12:17:42.749760Z",
      "url": "https://files.pythonhosted.org/packages/b2/2c/c1d3fd4469cdc81775f4d466147df6f4e99bc3fa9be24abec1fe1f156b5e/django_enum_choices-2.1.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}