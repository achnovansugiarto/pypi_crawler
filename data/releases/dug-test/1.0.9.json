{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "\n# Dug: digging up dark data\n\nDug applies semantic web and knowledge graph methods to improve the [FAIR](https://www.go-fair.org/fair-principles/)-ness of research data.\n\nAs an example, [dbGaP](https://www.ncbi.nlm.nih.gov/gap/) is a rich source of metadata about biomedical knowledge derived from clinical research like the underutilized [TOPMed](https://www.nhlbiwgs.org/) data sets. A key obstacle to leveraging this knowledge is the lack of researcher tools to navigate from a set of concepts of interest towards relevant study variables. In a word, **search**. \n\nWhile other approaches to searching this data exist, our focus is semantic search: For us, \"relevant\" is defined as having a basis in curated, peer reviewed ontologically represented biomedical knowledge. Given a search term, Dug returns results that are related based on connections in ontological biomedical knowledge graphs.\n\nTo achieve this, we annotate study metadata with terms from [biomedical ontologies](http://www.obofoundry.org/), contextualize them within a unifying [upper ontology](https://biolink.github.io/biolink-model/) allowing study data to be federated with [larger knowledge graphs](https://researchsoftwareinstitute.github.io/data-translator/), and create a full text search index based on those knowledge graphs.\n\n## The Dug Framework\n\nDug's **ingest** uses the [Biolink](https://biolink.github.io/biolink-model/) upper ontology to annotate knowledge graphs and structure queries used to drive full text indexing and search. It uses Monarch Initiative APIs to perform named entity recognition on natural language prose to extract ontology identifiers. It also uses Translator normalization services to find preferred identifiers and Biolink types for each extracted identifier. The final step of ingest is to represent the annotated data in a Neo4J graph database.\n\nDug's **integration** phase uses Translator's Plater and Automat to generate a Reasoner Standard API compliant service and integrates that service into TranQL. This enables queries that span TOPMed, ROBOKOP, and other reasoners.\n\nDug's **indexing & search** phase query the graph infrastructure and analyze the resulting graphs. These are used to create documents associating natural language terms with annotations and the annotated variables and studies.\n![image](https://user-images.githubusercontent.com/306971/94348055-4eb22180-0007-11eb-8093-4e321735ebaf.png)\n\n\nDug will then generate Translator knowledge sources for the annotated variables and present them for query via TranQL.\n\n## Knowledge Graphs\n\nDug's core data structure is the knowledge graph. Here's a query of a COPDGene knowledge graph created by Dug from harmonized TOPMed variables.\n\n![image](https://user-images.githubusercontent.com/306971/77009445-513c0c00-693e-11ea-83ed-722ec896d3e9.png)\n**Figure 1**: A Biolink knowledge graph of COPDGene metadata. It shows the relationship between the biological process \"Sleep\" and a meta variable. The highlighted node is aTOPMed meta variable or harmonized variable. It is in turn associated with variables connected to two studies in the data set. By linking additional ontological terms to the biological process sleep, we will be able to provde progressively more helpful search results rooted in curated biomedical knowledge.\n\nAnd one more example to illustrate the knowledge model we use to inform the search index:\n![image](https://user-images.githubusercontent.com/306971/77230029-b9ba0180-6b67-11ea-9ccf-748955aa1931.png)\n**Figure 2**: The TOPMed harmonized variable is highlighted, showing its relationships with the ontology term for Heart Failure and the Heart Failure and with a specific study variable. Several similar disease, harmonized variable, variable, study relationships are also shown.\n\nThese graphs are used to create the document's well add to the search index to power full text search.\n\nIn phase 1, we use Neo4J to build queries. In subsequent phases, we integrate other semantic services using TranQL.\n\n![image](https://user-images.githubusercontent.com/306971/77681466-bcec2d80-6f6b-11ea-93c5-87eee57d4b66.png)\n**Figure 3**: A TranQL knowledge graph query response. Integrating TOPMed harmonized variables as a Translator service called by TranQL allows us to query the federation of Translator ontological connections as a precursor to indexing. This includes chemical, phenotypic, disease, cell type, genetic, and other ontologies from sources like [ROBOKOP](https://researchsoftwareinstitute.github.io/data-translator/apps/robokop) as well as clinical aggregate data from sources like [ICEES](https://researchsoftwareinstitute.github.io/data-translator/apps/icees). The image above shows a query linking cholesterol to \"LDL in Blood\" a harmonized TOPMed variable. That variable is, in turn, linked to source variables and each of those is linked to its source study.\n\n## Elasticsearch Logic\n\nElasticsearch contains the indexed knowledge graphs against which we perform full-text queries.  Our query currently supports conditionals (AND, OR, NOT) as well as exact matching on quoted terms.  Because we don't specify an analyzer in our query or when we index documents, we default to the [standard analyzer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html), which is recommended for full-text search.  The standard analyzer performs grammar-based tokenization (e.g., splitting up an input string into tokens by several separators including whitespace, commas, hyphens), defined by the [Unicode Standard Annex #29](http://unicode.org/reports/tr29/).\n\n### Example Documents and Query Behavior\n\nTwo toy examples of indexed documents, `blood_color` and `blood_shape`, are shown below to demonstrate query behavior.\n\n![image](https://user-images.githubusercontent.com/63300314/85741468-7627e400-b6d0-11ea-849c-7b6da8b630b3.png)\n\n#### Query\nThe query searches the fields in all indexed documents to return a matching subset of documents.\n\n```\nquery = {\n            'query_string': {\n                'query' : query,\n                'fuzziness' : fuzziness,\n                'fields': ['name', 'description', 'instructions', 'nodes.name', 'nodes.synonyms'],\n                'quote_field_suffix': \".exact\"\n            }\n        }\n````\n\n#### Tests\n\n| Query|Behavior|\n| :--- |  :---- |\n| **blood** | This returns both documents (`blood_color` and `blood_shape`). |\n| **blood AND magenta**  | This returns only `blood_color`. |\n| **magenta AND cerulean** | This returns `blood_color` even though this might be unexpected.  The words 'magenta' and 'cerulean' appear in the same document in the searched fields, even though they appear in different fields, so the document is still returned. |\n| **blue AND square** | No documents are returned. |\n| **blue and square** | This returns both documents because the 'and' term is treated as just another term instead of an operator because it is not capitalized.  The actual search resolves to **blue OR and OR square** |\n| **\"round blood\"** | No documents are returned. |\n| **\"blood, round\"** | This returns `blood_shape`|\n| **\"blood round\"** | The document `blood_shape` is returned - the standard analyzer performs tokenization based on grammar separators, including commas in this case. |\n\n\n## Approach\n\nThe methodology, from start to finish, reads raw data, annotates it with ontological terms, normalizes those terms, inserts them into a queryable knowledge graph, queries that graph along pre-configured lines, turns the resulting knowledge graphs into documents, and indexes those documents in a full text search engine.\n\n### Link\n\nLink ingests raw dbGaP study metadata and performs semantic annotation by\n* Parsing a TOPMed data dictionary XML file to extract variables.\n* Using the Monarch SciGraph named entity recognizer to identify ontology terms.\n* Using the Translator SRI identifier normalization service to\n  * Select a preferred identifier for the entity\n  * Determine the BioLink types applying to each entity\n* Writing each variable with its annotations as a JSON object to a file.\n\n### Load\n\n* Converts the annotation format written in the steps above to a KGX graph\n* Inserts that graph into a Neo4J database.\n\nIn phase-1, we query Neo4J to create knowledge graphs. In phase-2 we'll use the Neo4J to create a Translator Knowledge Provider API. That API will be integrated using TranQL with other Translator reasoners like ROBOKOP. This will allow us to build more sophisticated graphs spanning federated ontological knowledge.\n\n### Crawl\n\n* Runs those graph queries and caches knowledge graph responses.\n\n### Index\n\n* Consumes knowledge graphs produced by the crawl.\n* Uses connections in the graph to create documents including both full text of variable descriptions and ontology terms.\n* Produces a queryable full text index of the variable set.\n\n### Search API\n\n* Presents an OpenAPI compliant REST interface\n* Provides a scalable microservice suitable as an Internet endpoint. \n\n## The Dug Data Development Kit (DDK)\n\nDug provides a tool chain for the ingest, annotation, knowledge graph representation, query, crawling, indexing, and search of datasets with metadata. The following sections provide an overview of the relevant components.\n\n### Ingest\n\nData formats for harmonized variables appear to be in flux, hence the multiple approaches. More on this soon.\n\n| Command           | Description                                         | Example                  |\n| ----------------- | --------------------------------------------------- | ------------------------ |\n| bin/dug link      | Use NLP, etc to add ontology identifiers and types. | bin/dug link {input}     |\n| bin/dug load      | Create a knowledge graph database.                  | bin/dug load {input}     |\n\nThere are three sets of example metadata files in the repo.\n* A COPDGene dbGaP metadata file is at `data/dd.xml`\n* A harmonized variable metadata CSV is at `data/harmonized_variable_DD.csv`\n* Files with names starting with: `data/topmed_*`\n\nThis last format seems to be the go-forward TOPMed harmonized variable form.\n\nThese can be run with \n```\nbin/dug link data/dd.xml\nbin/dug load data/dd_tagged.json\n```\nor \n```\nbin/dug link data/harmonized_variable_DD.csv\nbin/dug load data/harmoinzed_variable_DD_tagged.json\n```\nor\n```\nbin/dug link data/topmed_variables_v1.0.csv [--index x]\n```\nThe first two formats will likely go away.\nThe last format\n* Consists of two sets of files following that naming convention.\n* Combines the link and load phases into link.\n* Optionally allows the --index <arg> flag. This will run graph queries and index data in Elasticsearch.\n\n### Crawl & Index\n\n| Command        | Description                                                       | Example              |\n| -------------- | ----------------------------------------------------------------- | -------------------- |\n| bin/dug crawl  | Execute graph queries and accumulate knowledge graphs in response.| bin/dug crawl        |\n| bin/dug index  | Analyze crawled knowledge graphs and create search engine indices.| bin/dug index        |\n| bin/dug query  | Test the index by querying the search engine from Python.         | bin/dug query {text} |\n\n### Search API\n\nExposing the Elasticsearch interface to the internet is strongly discouraged for security reasons. Instead, we have a REST API. We'll use this as a place to enforce a schema and validate requests so that the search engine's network endpoint is strictly internal.\n| Command        | Description           | Example                              |\n| -------------- | --------------------- | ------------------------------------ |\n| bin/dug api    | Run the REST API.     | bin/dug api [--debug] [--port={int}] |\n\nTo call the API endpoint using curl:\n| Command             | Description           | Example                   |\n| ------------------- | --------------------- | ------------------------- |\n| bin/dug query_api   | Call the REST API.    | bin/dug query_api {query} |\n\n## Development\n\nA docker-compose is provided that runs four services:\n* Redis\n* Neo4J\n* Elasticsearch\n* The Dug search OpenAPI\n\nThis system can be started with the following command:\n\n| Command             | Description                | Example          |\n| ------------------- | -------------------------- | ---------------- |\n| bin/dug stack       | Runs all services          | bin/dug stack    |\n\n**Developers:** Internal to bin/dug, an environment file is automatically created. That file is in `docker/.env`.\nIf you are running in development, and are not using a public IP address and hostname, you'll want to create a separate .env file to allow programs to connect to the docker containers as services. This matters if, for example, you want to run bin/test, as the clients in that test need to know how to connect to each of the services they call. Copy the generated docker/.env to docker/.env.dev. Change all hostnames to `localhost`. That should do it. Be sure to keep the generated passwords from the generated .env the same. \n\n## Testing\n\nDug's automated functional tests:\n* Delete the test index\n* Execute the link and load phases for the dbGaP data dictionary and harmonized variables.\n* Execute the crawl and index phases.\n* Execute a number of searches over the generated search index.\n\n| Command             | Description                    | Example      |\n| ------------------- | ------------------------------ | ------------ |\n| bin/dug test        | Run automated functional tests | bin/dug test |\n\nOnce the test is complete, a command line search shows the contents of the index:\n![image](https://user-images.githubusercontent.com/306971/77009780-e939f580-693e-11ea-8a02-ca2fd59d4366.png)\n**Figure 4**: A command line query using the Dug Search OpenAPI to query the Elasticsearch index for a term.\n\n## Data Formats\n\nUntil data formats stabilize, the best approach is to have a look at the raw data [here](https://github.com/helxplatform/dug/tree/master/data).\n\n## Next Steps\n\nThese things need attention:\n* [x] Develop Kubernetes artifacts to move from development to a public API.\n* [ ] Add automated unit tests and a Travis build.\n* [x] Apply Plater & Automat to serve the Neo4J as our TOPMed metadata API.\n* [x] Demonstrate a TranQL query incorporating this data with ROBOKOP\n* [ ] Use TranQL queries to populate Elasticsearch (as shown elsewhere in this repo).\n* [ ] Several identifiers returned by the Monarch NLP are not found by the SRI normalizer. The good news is, several of these missing identifiers are quite important (BMI, etc) so once we get them included in normalization, our annotation should be improved.\n  * Error logs from data dictionary annotation are [here](https://github.com/helxplatform/dug/blob/master/dug/log/dd_norm_fail.log).\n  * Logs from harmonized variable annotation are [here](https://github.com/helxplatform/dug/blob/master/dug/log/harm_norm_fail.log).\n* [x] The input here is a TOPMed DD. Investigate starting the pipeline from harmonized variables.\n  * We now have the ability to (roughly) parse harmonized variables from their standard CSV format.\n  * Several issues arose around formatting, the need for a study id, and a few other things. \n  * But the overall approach seems feasible.\n* [x] Document the crawl, index, and search (API) components of Dug here.\n\n## Future\n* [ ] Refine knowledge graph queries and indexing analytics to improve result relevance.\n* [ ] Incorporate synonyms and additional NLP approaches.\n* [ ] Parallelize steps with Spark.\n* [ ] Develop a frictionless KGX interface to Spark.\n* [ ] Use Morpheus Cypher for query.\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/helxplatform/dug.git",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dug-test",
    "package_url": "https://pypi.org/project/dug-test/",
    "platform": "",
    "project_url": "https://pypi.org/project/dug-test/",
    "project_urls": {
      "Homepage": "https://github.com/helxplatform/dug.git"
    },
    "release_url": "https://pypi.org/project/dug-test/1.0.9/",
    "requires_dist": [
      "alabaster (==0.7.12)",
      "aniso8601 (==8.0.0)",
      "antlr4-python3-runtime (==4.9)",
      "appnope (==0.1.0)",
      "attrs (==19.3.0)",
      "Babel (==2.8.0)",
      "backcall (==0.1.0)",
      "biolinkml (==1.4.9)",
      "bleach (==3.1.1)",
      "cachetools (==4.0.0)",
      "certifi (==2019.11.28)",
      "CFGraph (==0.2.1)",
      "chardet (==3.0.4)",
      "click (==7.1.1)",
      "decorator (==4.4.2)",
      "defusedxml (==0.6.0)",
      "docutils (==0.16)",
      "elasticsearch (==7.5.1)",
      "elasticsearch-dsl (==7.1.0)",
      "entrypoints (==0.3)",
      "flasgger (==0.9.4)",
      "Flask (==1.1.1)",
      "Flask-Cors (==3.0.8)",
      "Flask-RESTful (==0.3.8)",
      "graphviz (==0.13.2)",
      "gunicorn (==20.0.4)",
      "idna (==2.8)",
      "imagesize (==1.2.0)",
      "importlib-metadata (==1.5.0)",
      "incremental (==17.5.0)",
      "ipykernel (==5.1.4)",
      "ipython (==7.13.0)",
      "ipython-genutils (==0.2.0)",
      "ipywidgets (==7.5.1)",
      "isodate (==0.6.0)",
      "itsdangerous (==1.1.0)",
      "jedi (==0.16.0)",
      "Jinja2 (==2.11.1)",
      "jsonasobj (==1.2.1)",
      "jsonschema (==3.2.0)",
      "jupyter (==1.0.0)",
      "jupyter-client (==6.0.0)",
      "jupyter-console (==6.1.0)",
      "jupyter-core (==4.6.3)",
      "MarkupSafe (==1.1.1)",
      "mistune (==0.8.4)",
      "more-itertools (==8.2.0)",
      "mypy (==0.770)",
      "mypy-extensions (==0.4.3)",
      "nbconvert (==5.6.1)",
      "nbformat (==5.0.4)",
      "neo4j (==1.7.6)",
      "neo4jrestclient (==2.1.1)",
      "neobolt (==1.7.16)",
      "neotime (==1.7.4)",
      "networkx (==2.4)",
      "notebook (==6.0.3)",
      "numpy (==1.18.1)",
      "ordered-set (==4.0.2)",
      "packaging (==20.3)",
      "pandas (==1.0.1)",
      "pandocfilters (==1.4.2)",
      "parso (==0.6.2)",
      "pbr (==5.4.4)",
      "pexpect (==4.8.0)",
      "pickleshare (==0.7.5)",
      "pip-check-reqs (==2.0.3)",
      "pluggy (==0.13.1)",
      "prefixcommons (==0.1.9)",
      "prologterms (==0.0.6)",
      "prometheus-client (==0.7.1)",
      "prompt-toolkit (==3.0.4)",
      "ptyprocess (==0.6.0)",
      "py (==1.8.1)",
      "Pygments (==2.6.1)",
      "PyJSG (==0.11.6)",
      "pyparsing (==2.4.6)",
      "pyrsistent (==0.15.7)",
      "PyShEx (==0.7.14)",
      "PyShExC (==0.8.2)",
      "pystache (==0.5.4)",
      "pytest (==5.4.0)",
      "python-dateutil (==2.8.1)",
      "python-Levenshtein (==0.12.0)",
      "pytz (==2019.3)",
      "PyYAML (==5.3)",
      "pyzmq (==19.0.0)",
      "qtconsole (==4.7.1)",
      "QtPy (==1.9.0)",
      "rdflib (==5.0.0)",
      "rdflib-jsonld (==0.5.0)",
      "redis (==3.4.1)",
      "requests (==2.22.0)",
      "requests-cache (==0.5.2)",
      "Send2Trash (==1.5.0)",
      "ShExJSG (==0.7.1)",
      "six (==1.14.0)",
      "snowballstemmer (==2.0.0)",
      "sparql-slurper (==0.3.3)",
      "SPARQLWrapper (==1.8.5)",
      "Sphinx (==2.4.4)",
      "sphinx-click (==2.3.1)",
      "sphinx-rtd-theme (==0.4.3)",
      "sphinxcontrib-applehelp (==1.0.2)",
      "sphinxcontrib-devhelp (==1.0.2)",
      "sphinxcontrib-htmlhelp (==1.0.3)",
      "sphinxcontrib-jsmath (==1.0.1)",
      "sphinxcontrib-qthelp (==1.0.3)",
      "sphinxcontrib-serializinghtml (==1.1.4)",
      "stringcase (==1.2.0)",
      "terminado (==0.8.3)",
      "terminaltables (==3.1.0)",
      "testpath (==0.4.4)",
      "tornado (==6.0.4)",
      "traitlets (==4.3.3)",
      "typed-ast (==1.4.1)",
      "typing-extensions (==3.7.4.1)",
      "urllib3 (==1.25.7)",
      "validators (==0.14.2)",
      "wcwidth (==0.1.8)",
      "webencodings (==0.5.1)",
      "Werkzeug (==1.0.0)",
      "widgetsnbextension (==3.5.1)",
      "zipp (==3.1.0)",
      "jsonlines (>=1.2.0)"
    ],
    "requires_python": ">=3.7",
    "summary": "Dug is a semantic searching and indexing software.",
    "version": "1.0.9",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9878121,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d74640436877a71caf24ee5bfb7feeed42d70309d0cde9801ccb80333b47d6ea",
        "md5": "09f5ac296fcb805f749dd03d4371a9a1",
        "sha256": "b07094ecf6941f485db959b57df8f09d619ffc19920c06052a31cb85ee506498"
      },
      "downloads": -1,
      "filename": "dug_test-1.0.9-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "09f5ac296fcb805f749dd03d4371a9a1",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": ">=3.7",
      "size": 31949,
      "upload_time": "2021-03-19T16:20:27",
      "upload_time_iso_8601": "2021-03-19T16:20:27.106018Z",
      "url": "https://files.pythonhosted.org/packages/d7/46/40436877a71caf24ee5bfb7feeed42d70309d0cde9801ccb80333b47d6ea/dug_test-1.0.9-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6d5b862112c4ec908e2c49f381860c1b226e28c2827f66d37f986eaedc790b7f",
        "md5": "0dce78c6aa5ddfbc376dd3e8c712112d",
        "sha256": "ecb28d5ba9eda82b029d54a1418f8b985a3ed46bef0d645e83b66dd93da63fc0"
      },
      "downloads": -1,
      "filename": "dug-test-1.0.9.tar.gz",
      "has_sig": false,
      "md5_digest": "0dce78c6aa5ddfbc376dd3e8c712112d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 35727,
      "upload_time": "2021-03-19T16:20:29",
      "upload_time_iso_8601": "2021-03-19T16:20:29.238849Z",
      "url": "https://files.pythonhosted.org/packages/6d/5b/862112c4ec908e2c49f381860c1b226e28c2827f66d37f986eaedc790b7f/dug-test-1.0.9.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}