{
  "info": {
    "author": "",
    "author_email": "BeardedManZhao <liming7887@qq.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# ![image](https://user-images.githubusercontent.com/113756063/203919312-dcec4a61-2136-4af2-a361-66b2ed4e6a54.png) mathematical-expression\r\n\r\n- 切换至 [中文文档](https://github.com/BeardedManZhao/mathematical-expression-py/blob/main/README-Chinese.md)\r\n\r\n## introduce\r\n\r\nThis framework is an effective tool for mathematical formula analysis. It can analyze mathematical formulas including\r\nnested functions, including functions, and step accumulation of series. The return value is a numerical result object.\r\nAt the same time, it can also be used for comparison operations. When comparing again, the return value is a Boolean\r\nresult object.\r\n\r\n- pip Get Command\r\n\r\n```shell\r\npip install mathematical_expression_py\r\n```\r\n\r\n## Framework\r\n\r\n### Calculation Manager\r\n\r\n- Full class name：mathematical_expression/core/manager/CalculationManagement.py\r\n- introduce：\r\n\r\n  The manager is a component designed to use both singletons and dynamic objects. The existence of the manager enables\r\n  each component to be obtained by name. Components with the same name have the same storage address in memory, avoiding\r\n  the use of redundant components. At the same time, for components that need to use dynamic members, a new component\r\n  can also be obtained by a new name.\r\n- API Usage Example\r\n\r\n```python\r\nfrom mathematical_expression.core.calculation.number import bracketsCalculation2, functionFormulaCalculation\r\nfrom mathematical_expression.core.manager import CalculationManagement\r\n\r\n# Create two parenthesis expression parsing components and a function expression parsing component\r\nbr1 = bracketsCalculation2.get_instance(\"br1\")\r\nbr2 = bracketsCalculation2.get_instance(\"br2\")\r\nfu1 = functionFormulaCalculation.get_instance(\"fu1\")\r\n# Get the components with these three names from the manager\r\nm_br1 = CalculationManagement.get_calculation_by_name(\"br1\")\r\nm_br2 = CalculationManagement.get_calculation_by_name(\"br2\")\r\nm_fu1 = CalculationManagement.get_calculation_by_name(\"fu1\")\r\n# Through get_ Instance and the manager extract the components obtained by these two methods. In the case of the same name, the two are one object\r\nprint(br1 == m_br1)\r\nprint(br2 == m_br2)\r\nprint(fu1 == m_fu1)\r\nprint(br1 == br2)\r\n```\r\n\r\n- Running results\r\n\r\n  The last three lines are the comparison of memory data. The instantiated components are the same as the components in\r\n  the manager, but the components with different names are different.\r\n\r\n```\r\nINFO:root:+============================== Welcome to [mathematical expression] ==============================+\r\nINFO:root:+ \tStart time 2022-11-16 16:29:07.660044\r\nINFO:root:+ \tCalculation component manager initialized successfully\r\nINFO:root:+ \tFor more information, see: https://github.com/BeardedManZhao/mathematical-expression-py\r\nINFO:root:+--------------------------------------------------------------------------------------------------+\r\nINFO:root:A computing component is registered PrefixExpressionOperation\r\nINFO:root:A computing component is registered BracketsCalculation2\r\nINFO:root:A computing component is registered br1\r\nINFO:root:A computing component is registered br2\r\nINFO:root:A computing component is registered fu1\r\nTrue\r\nTrue\r\nTrue\r\nFalse\r\n```\r\n\r\n### Operational rule redefinition\r\n\r\n- Full class name：mathematical_expression/core/manager/ConstantRegion.py\r\n- introduce：\r\n\r\n  There is a constant pool in the framework that stores data that needs to be reused frequently. This data can be\r\n  modified in the python version of the framework. Modifying this data can often add more flexibility, but it is\r\n  important to note that the modification here may also cause some strange exceptions, so it is up to you to decide if\r\n  you want to use redefinition technology.\r\n\r\n  Next, see an example of using redefinition\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.number import bracketsCalculation2\r\nfrom mathematical_expression.core.calculation.number.bracketsCalculation2 import BracketsCalculation2\r\nfrom mathematical_expression.core.container.CalculationNumberResults import CalculationNumberResults\r\nfrom mathematical_expression.core.manager import ConstantRegion\r\n\r\n# Redefine the sign of the plus sign\r\nConstantRegion.PLUS_SIGN = '$'\r\n# Redefine the sign of the multiplication sign\r\nConstantRegion.MULTIPLICATION_SIGN = '@'\r\n# Refresh constant area configuration\r\nConstantRegion.re_fresh()\r\n\r\n# Get a calculation component that evaluates nested parenthesis expressions\r\nbracketsCalculation2: BracketsCalculation2 = bracketsCalculation2.get_instance(\"BracketsCalculation\")\r\n# Create an expression\r\n# s: str = \"1 + 2 + 4 * (10 - 3)\" \r\n# TODO The plus sign and multiplication sign here are redefined and can be replaced by new characters\r\ns: str = \"1 $ 2 $ 4 @ (10 - 3)\"\r\n# Check the expression for errors\r\nbracketsCalculation2.check(s)\r\n# Start calculating results\r\ncalculation: CalculationNumberResults = bracketsCalculation2.calculation(s)\r\n# Print result value\r\nprint(\"计算层数：\" + str(calculation.get_result_layers()) + \"\\n计算结果：\" + str(calculation.get_result()) +\r\n      \"\\n计算来源：\" + calculation.get_calculation_source_name())\r\n\r\n```\r\n\r\n- Running results\r\n\r\n  It can be seen that the operation here is smooth. In the formula, the symbol is redefined\r\n\r\n```\r\n计算层数：2\r\n计算结果：31.0\r\n计算来源：BracketsCalculation\r\n```\r\n\r\n## Calculation component introduce\r\n\r\n### Bracketed expression\r\n\r\n- Full class name：mathematical_expression/core/calculation/number/prefixExpressionOperation.py\r\n- introduce\r\n\r\n  This component is designed for a mathematical expression without parentheses, but with operations such as addition,\r\n  subtraction, multiplication, division and remainder. This component can realize the function with priority\r\n  calculation, in which the prefix expression is used to parse and calculate, and the operand and operator are stored on\r\n  the stack together with the calculation priority comparison If the current priority is low, first operate the previous\r\n  operand and operator with the current operand to form a new value, and then put it on the stack.\r\n- API Usage Example\r\n\r\n  The operators supported by this component are： a+b a-b a*b a/b a%b\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.number import prefixExpressionOperation\r\nfrom mathematical_expression.core.calculation.number.prefixExpressionOperation import PrefixExpressionOperation\r\nfrom mathematical_expression.core.container.CalculationNumberResults import CalculationNumberResults\r\n\r\n# Gets the calculation component of a function that evaluates an expression without parentheses\r\nprefixExpressionOperation: PrefixExpressionOperation = prefixExpressionOperation.get_instance(\"p\")\r\n# Create an expression\r\ns: str = \"1 + 2 + 4 * 10 - 3\"\r\n# Check the expression for errors\r\nprefixExpressionOperation.check(s)\r\n# Start calculating results\r\ncalculation: CalculationNumberResults = prefixExpressionOperation.calculation(s)\r\n# Print result value\r\nprint(\"计算层数：\" + str(calculation.get_result_layers()) + \"\\n计算结果：\" + str(calculation.get_result()) +\r\n      \"\\n计算来源：\" + calculation.get_calculation_source_name())\r\n```\r\n\r\n- Running results\r\n\r\n  In the API call, the Running results of the function are printed. It can be seen that the returned value calculated by\r\n  the component is a result set object, in which a lot of information about the calculation results is stored.\r\n\r\n```\r\n计算层数：2\r\n计算结果：40.0\r\n计算来源：p\r\n```\r\n\r\n### Nested parenthesis expression\r\n\r\n- Full class name：core/calculation/number/bracketsCalculation2.py\r\n- introduce：\r\n\r\n  Nested parenthesis expression parsing component, which can parse and calculate the results of mathematical expressions\r\n  with multiple parentheses, and parse and calculate the priority of nested parentheses. This component relies on \"core.\r\n  calculation. number. PrefixExpressionOperation\", and uses recursion to parse parentheses in this component, Then\r\n  provide the innermost expression to \"core. calculation. number. PrefixExpressionOperation\" for calculation.\r\n\r\n- API Usage Example\r\n\r\n  The operators supported by this component are： a+b a-b a*b a/b a%b ( )\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.number import bracketsCalculation2\r\nfrom mathematical_expression.core.calculation.number.bracketsCalculation2 import BracketsCalculation2\r\nfrom mathematical_expression.core.container.CalculationNumberResults import CalculationNumberResults\r\n\r\n# Get a calculation component that evaluates nested parenthesis expressions\r\nbracketsCalculation2: BracketsCalculation2 = bracketsCalculation2.get_instance(\"BracketsCalculation\")\r\n# Create an expression\r\ns: str = \"1 + 2 + 4 * (10 - 3)\"\r\n# Check the expression for errors\r\nbracketsCalculation2.check(s)\r\n# Start calculating results\r\ncalculation: CalculationNumberResults = bracketsCalculation2.calculation(s)\r\n# Print result value\r\nprint(\"计算层数：\" + str(calculation.get_result_layers()) + \"\\n计算结果：\" + str(calculation.get_result()) +\r\n      \"\\n计算来源：\" + calculation.get_calculation_source_name())\r\n```\r\n\r\n- Running results\r\n\r\n  In the API call, the calculation result of the expression is printed. It can be seen that the return value of the\r\n  component calculation is a numerical result object, in which a lot of information about the calculation result is\r\n  stored.\r\n\r\n```\r\n计算层数：2\r\n计算结果：31.0\r\n计算来源：BracketsCalculation\r\n```\r\n\r\n### Mathematical comparison expression\r\n\r\n- Full class name：core/calculation/bool/booleanCalculation2.py\r\n- introduce\r\n\r\n  A component that uses the comparison operator to determine whether two parenthesis expressions are mutually valid. The\r\n  return value is a Boolean result object. This component can compare the size of two numeric values, or the\r\n  relationship between two expressions, depending on the component \"core. calculation. bool. BooleanCalculation2\"\r\n- API Usage Example\r\n\r\n  The operators supported by this component are shown in the API\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.bool import booleanCalculation2\r\nfrom mathematical_expression.core.calculation.bool.booleanCalculation2 import BooleanCalculation2\r\nfrom mathematical_expression.core.container.CalculationBooleanResults import CalculationBooleanResults\r\n\r\n\r\ndef extracted(boolean_calculation2: BooleanCalculation2, s: str):\r\n    # Check the expression for errors\r\n    boolean_calculation2.check(s)\r\n    # Start calculating results\r\n    calculation: CalculationBooleanResults = boolean_calculation2.calculation(s)\r\n    # Print result value\r\n    print(\r\n        f\"计算层数：{calculation.get_result_layers()}\"\r\n        f\"\\t计算结果：{calculation.get_result()}\"\r\n        f\"\\t计算来源：{calculation.get_calculation_source_name()}\"\r\n    )\r\n\r\n\r\n# Get a component that calculates mathematical comparison expressions\r\nbooleanCalculation2: BooleanCalculation2 = booleanCalculation2.get_instance(\"Bool\")\r\n# Create 3 expressions\r\ns1 = \"1 + 2 + 4 * (10 - 3)\"\r\ns2 = \"2 + 30 + (2 * 3) - 1\"\r\ns3 = \"1 + 3 * 10\"\r\nextracted(booleanCalculation2, s1 + \" > \" + s2)  # false\r\nextracted(booleanCalculation2, s1 + \" < \" + s2)  # true\r\nextracted(booleanCalculation2, s1 + \" = \" + s3)  # true\r\nextracted(booleanCalculation2, s1 + \" == \" + s3)  # true\r\nextracted(booleanCalculation2, s1 + \" != \" + s3)  # false\r\nextracted(booleanCalculation2, s1 + \" <> \" + s3)  # false\r\nextracted(booleanCalculation2, s1 + \" <= \" + s3)  # true\r\nextracted(booleanCalculation2, s1 + \" >= \" + s3)  # true\r\nextracted(booleanCalculation2, s1 + \" != \" + s2)  # true\r\nextracted(booleanCalculation2, s1 + \" <> \" + s2)  # true\r\n```\r\n\r\n- Running results\r\n\r\n```\r\n计算层数：4\t计算结果：False\t计算来源：Bool\r\n计算层数：4\t计算结果：True\t计算来源：Bool\r\n计算层数：3\t计算结果：True\t计算来源：Bool\r\n计算层数：3\t计算结果：True\t计算来源：Bool\r\n计算层数：3\t计算结果：False\t计算来源：Bool\r\n计算层数：3\t计算结果：False\t计算来源：Bool\r\n计算层数：3\t计算结果：True\t计算来源：Bool\r\n计算层数：3\t计算结果：True\t计算来源：Bool\r\n计算层数：4\t计算结果：True\t计算来源：Bool\r\n计算层数：4\t计算结果：True\t计算来源：Bool\r\n```\r\n\r\n### Interval accumulation expression\r\n\r\n- Full class name：core/calculation/number/cumulativeCalculation.py\r\n\r\n- introduce\r\n\r\nIn mathematical expressions, there is often such a formula. The content of the formula is shown in the following\r\n\r\nfigure. You can see the number sequence operations that need to be accumulated.\r\n\r\nThen, you can use the Full class name above to achieve the purpose you need.\r\n\r\n![img_1](https://user-images.githubusercontent.com/113756063/201575828-5b76af88-6040-430d-a54c-61faf5905594.png)\r\n\r\n- API Usage Example\r\n\r\nThe syntax level is almost the same as that of other components. The calculation example of the mathematical\r\n\r\nexpression written in the component is shown below. What is shown here is the calculation of an accumulative\r\n\r\nmathematical formula.\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.number import cumulativeCalculation\r\n\r\n# Get the calculation component of the accumulation formula\r\ncumulativeCalculation = cumulativeCalculation.get_instance(\"cumulative\")\r\n# Construct a mathematical expression. Here, \"n [1,10,1]\" is similar to the accumulation symbol in mathematics. N\r\n# will increase continuously in this interval. Every increase will be brought into the formula for calculation\r\n# Wherein, the last 1 in [1,10,1] represents the increase step, which can realize the accumulation of different equal\r\n# difference values in the interval\r\ns = \"n[1,10,1] 2 * (n + 1)\"\r\n# Check mathematical expressions\r\ncumulativeCalculation.check(s)\r\n# Calculation results\r\ncalculation = cumulativeCalculation.calculation(s)\r\n# Print result value\r\nprint(\r\n    f\"计算层数：{calculation.get_result_layers()}\"\r\n    f\"\\t计算结果：{calculation.get_result()}\"\r\n    f\"\\t计算来源：{calculation.get_calculation_source_name()}\"\r\n)\r\n```\r\n\r\n- Running results\r\n\r\n```\r\n计算层数：21\t计算结果：130.0\t计算来源：cumulative\r\n```\r\n\r\n### Function operation expression\r\n\r\n- Full class name:core/calculation/number/functionFormulaCalculation.py\r\n\r\n- introduce\r\n\r\n  The framework also supports the operation of some functions. You can use the above classes to write mathematical\r\n  expressions that require functions. It should be noted that all functions used in expressions need to be logically\r\n  registered in \"Calculation Management\" so that functions can be accessed during calculation\r\n- API Usage Example\r\n\r\n```python\r\n# This is a sample Python script.\r\nfrom mathematical_expression.core.calculation.function.Function import Function\r\nfrom mathematical_expression.core.calculation.number import functionFormulaCalculation\r\nfrom mathematical_expression.core.manager import CalculationManagement\r\n\r\n\r\n# 实现一个函数\r\nclass Function1(Function):\r\n    def run(self, *floats: float):\r\n        return floats[0] * 2\r\n\r\n\r\n# Register the implemented function to the manager\r\nCalculationManagement.register_function(Function1(\"DoubleValue\"))\r\n# Get the function calculation component\r\nfunctionFormulaCalculation = functionFormulaCalculation.get_instance(\"zhao\")\r\n# Build an expression\r\ns = \"2 * DoubleValue(2 + 3) + 1\"\r\n# Check expression format\r\nfunctionFormulaCalculation.check(s)\r\n# Start evaluating expression\r\nresult = functionFormulaCalculation.calculation(s)\r\nprint(\r\n    f\"计算层数：{result.get_result_layers()}\"\r\n    f\"\\t计算结果：{result.get_result()}\"\r\n    f\"\\t计算来源：{result.get_calculation_source_name()}\"\r\n)\r\n```\r\n\r\n- Running results\r\n\r\n```\r\nINFO:root:Find and prepare the startup function: DoubleValue\r\n计算层数：1\t计算结果：21.0\t计算来源：BracketsCalculation2\r\n```\r\n\r\n### Multi parameter function operation expression\r\n\r\n- Full class name: mathematical_expression/core/calculation/number/functionFormulaCalculation2.py\r\n- introduce\r\n\r\n  For some expression calculations that use functions in expressions, the above class can be used for operations. It is\r\n  an upgraded version of the \"core. calculation. number. FunctionFormulaCalculation\" class, which has appeared since\r\n  version 1.1, is also an extended implementation of its subclass.\r\n\r\n  Compared with the parent class, this component makes up for the deficiency that the parent class can only parse the\r\n  function expression with one parameter. In this component, you can use many real parameters for function operations,\r\n  such as sum (1,2,3)\r\n\r\n  This type of function is a multiparameter function. Next, let's look at the API usage example, in which the\r\n  calculation and results of the multiparameter function expression are shown.\r\n\r\n```python\r\nfrom mathematical_expression.core.calculation.function.Function import Function\r\nfrom mathematical_expression.core.calculation.number import functionFormulaCalculation2\r\nfrom mathematical_expression.core.manager import CalculationManagement\r\n\r\n\r\n# Implement a function\r\nclass Sum(Function):\r\n    def run(self, floats: list):\r\n        res = 0\r\n        for d in floats:\r\n            res += d\r\n        return res\r\n\r\n\r\n# Start to create the function and register it with the manager\r\nCalculationManagement.register_function(Sum(\"sum\"))\r\n# Get the calculation component that can parse the mathematical expression of multi parameter function\r\nfunctionFormulaCalculation2 = functionFormulaCalculation2.get_instance(\"zhao\")\r\n# Enable shared pool\r\nfunctionFormulaCalculation2.startSharedPool = True\r\n# Build the mathematical expression to be calculated \r\n# TODO More than one function parameter is used in the following mathematical expression\r\ns = \"2 * (200 - sum(1 + 10.1, 2, 3)) + sum(10, 20)\"\r\n# Check the mathematical expression for errors\r\nfunctionFormulaCalculation2.check(s)\r\n# Calculate the expression and get the result\r\nresult = functionFormulaCalculation2.calculation(s)\r\nprint(\r\n    f\"计算层数：{result.get_result_layers()}\"\r\n    f\"\\t计算结果：{result.get_result()}\"\r\n    f\"\\t计算来源：{result.get_calculation_source_name()}\"\r\n)\r\n```\r\n\r\n- Running results\r\n\r\n```\r\n计算层数：2\t计算结果：397.8\t计算来源：BracketsCalculation2\r\n```\r\n\r\n### Fast interval sum calculation component (based on parenthesis expression)\r\n\r\n- Full class name：mathematical_expression/core/calculation/number/fastSumOfIntervalsBrackets.py\r\n- introduce\r\n\r\n  The new product of version 1.15, the interval fast sum component, is a fast component that sums all elements of an\r\n  interval with an equal difference of n. It logically simulates an interval into a mathematical sequence and quickly\r\n  sums it through the sum formula.\r\n\r\n  This component implements the shared pool computing function. It will check, calculate, and record the results of the\r\n  last time, which can speed up computing. The specific API calls are shown below.\r\n\r\n```python\r\nfrom mathematical_expression.core.calculation.number import fastSumOfIntervalsBrackets\r\n\r\n# Get the quick sum calculation component of the interval\r\nfastSumOfIntervalsBrackets = fastSumOfIntervalsBrackets.get_instance(\"fastSumOfIntervalsBrackets\")\r\n# Build the interval expression we need to calculate. \r\n# The expression is composed of the left and right boundaries of the interval. \r\n# The double formulas are separated by commas\r\ns = \"1 + 10, 20 - (5 + 2)\"\r\n# Check the expression. The shared pool has been enabled by default since version 1.2! No need to set manually\r\n# fastSumOfIntervalsBrackets.set_start_shared_pool(True)\r\nfastSumOfIntervalsBrackets.check(s)\r\n# The step size of each element in the interval can be set after version 1.15\r\nfastSumOfIntervalsBrackets.step = 2\r\n# Calculation result value\r\ncalculation = fastSumOfIntervalsBrackets.calculation(s)\r\n# Print result value\r\nprint(\"计算层数：\" + str(calculation.get_result_layers()) + \"\\n计算结果：\" + str(calculation.get_result()) +\r\n      \"\\n计算来源：\" + calculation.get_calculation_source_name())\r\n```\r\n\r\n- Running results\r\n\r\n  From the above code, we can see that the formula for quick interval summation is composed of two parenthesis\r\n  expressions separated by commas\r\n\r\n```\r\n计算层数：3\r\n计算结果：36.0\r\n计算来源：fastSumOfIntervalsBrackets\r\n```\r\n\r\n### Fast interval cumulative calculation component (based on parenthesis expression)\r\n\r\n- Full class name: mathematical_expression/core/calculation/number/fastSumOfIntervalsBrackets.py\r\n\r\n- Introduction\r\n\r\n  A new product of version 1.1.5, the interval fast accumulation component, is a fast component that accumulates all\r\n  elements of an interval with an equal difference of n. It logically simulates an interval into a mathematical sequence\r\n  and performs fast accumulation through the sum formula.\r\n\r\n  This component implements the shared pool computing function. It will check, calculate, and record the results of the\r\n  last time, which can speed up computing. The specific API calls are shown below.\r\n\r\n```python\r\nfrom mathematical_expression.core.calculation.number import fastMultiplyOfIntervalsBrackets\r\n\r\n# Get interval fast cumulative calculation component\r\nfastMultiplyOfIntervalsBrackets = fastMultiplyOfIntervalsBrackets.get_instance(\"fastMultiplyOfIntervalsBrackets\")\r\n# Build the interval expression we need to calculate. The expression is composed of the left and right boundaries of the interval. The double formulas are separated by commas\r\ns = \"1 + 10, 20 - (5 + 2)\"\r\n# Check the expression. The shared pool has been enabled by default since version 1.15! No need to set manually\r\n# fastSumOfIntervalsBrackets.set_start_shared_pool(True)\r\nfastMultiplyOfIntervalsBrackets.check(s)\r\n# The step size of each element in the interval can be set after version 1.15\r\nfastMultiplyOfIntervalsBrackets.step = 2\r\n# Calculation result value\r\ncalculation = fastMultiplyOfIntervalsBrackets.calculation(s)\r\n# Print result value\r\nprint(\"计算层数：\" + str(calculation.get_result_layers()) + \"\\n计算结果：\" + str(calculation.get_result()) +\r\n      \"\\n计算来源：\" + calculation.get_calculation_source_name())\r\n```\r\n\r\n- Running results\r\n\r\n  From the above code, we can see that the formula for quick interval summation is composed of two parenthesis\r\n  expressions separated by commas\r\n\r\n```\r\n计算层数：3\r\n计算结果：143.0\r\n计算来源：fastMultiplyOfIntervalsBrackets\r\n```\r\n\r\n<hr>\r\n\r\nMore information\r\n\r\n- date: 2022-11-14\r\n- 切换至 [中文文档](https://github.com/BeardedManZhao/mathematical-expression-py/blob/main/README-Chinese.md)\r\n- [mathematical-expression-Java](https://github.com/BeardedManZhao/mathematical-expression)\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mathematical-expression-py",
    "package_url": "https://pypi.org/project/mathematical-expression-py/",
    "platform": null,
    "project_url": "https://pypi.org/project/mathematical-expression-py/",
    "project_urls": {
      "Bug Tracker": "https://github.com/BeardedManZhao/mathematical-expression-py/issues",
      "Homepage": "https://github.com/BeardedManZhao/mathematical-expression-py"
    },
    "release_url": "https://pypi.org/project/mathematical-expression-py/1.1.5/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Python API concise framework for parsing string mathematical expressions",
    "version": "1.1.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17025075,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "508e7d8ecc3db9e983b2db76e06c0e6219928406d4bc6d70a62f139af9624a9b",
        "md5": "7776b0798ddef67cfffe60ed1c8ee68a",
        "sha256": "a75951d455934835b8652e63e1c45faeeb632ffa962d2f7f5e246120be71fe97"
      },
      "downloads": -1,
      "filename": "mathematical_expression_py-1.1.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7776b0798ddef67cfffe60ed1c8ee68a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 49029,
      "upload_time": "2022-12-24T07:27:28",
      "upload_time_iso_8601": "2022-12-24T07:27:28.543217Z",
      "url": "https://files.pythonhosted.org/packages/50/8e/7d8ecc3db9e983b2db76e06c0e6219928406d4bc6d70a62f139af9624a9b/mathematical_expression_py-1.1.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "937189089a267c99248d9e905db9c9eae7617379a04581bff37bed06f601617c",
        "md5": "510da11f866f8ede7152257d830b4cdf",
        "sha256": "793d1d0ec1ff685ecded4944f7efff053e07b95ddef7300113ec8989bf7bb1e0"
      },
      "downloads": -1,
      "filename": "mathematical-expression-py-1.1.5.tar.gz",
      "has_sig": false,
      "md5_digest": "510da11f866f8ede7152257d830b4cdf",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 34831,
      "upload_time": "2022-12-24T07:27:30",
      "upload_time_iso_8601": "2022-12-24T07:27:30.700315Z",
      "url": "https://files.pythonhosted.org/packages/93/71/89089a267c99248d9e905db9c9eae7617379a04581bff37bed06f601617c/mathematical-expression-py-1.1.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}