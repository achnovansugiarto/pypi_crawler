{
  "info": {
    "author": "Sabricot",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Framework :: Django",
      "Framework :: Django :: 1.10",
      "Framework :: Django :: 1.11",
      "Framework :: Django :: 2.0",
      "Framework :: Django :: 2.1",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Natural Language :: English",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "========================\nDjango Elasticsearch DSL\n========================\n\n.. image:: https://travis-ci.org/sabricot/django-elasticsearch-dsl.png?branch=master\n    :target: https://travis-ci.org/sabricot/django-elasticsearch-dsl\n.. image:: https://codecov.io/gh/sabricot/django-elasticsearch-dsl/coverage.svg?branch=master\n    :target: https://codecov.io/gh/sabricot/django-elasticsearch-dsl\n.. image:: https://badge.fury.io/py/django-elasticsearch-dsl.svg\n    :target: https://pypi.python.org/pypi/django-elasticsearch-dsl\n\nThis is a package that allows indexing of django models in elasticsearch. It is\nbuilt as a thin wrapper around elasticsearch-dsl-py_ so you can use all the features developed\nby the elasticsearch-dsl-py team.\n\n.. _elasticsearch-dsl-py: https://github.com/elastic/elasticsearch-dsl-py\n\nFeatures\n--------\n\n- Based on elasticsearch-dsl-py_ so you can make queries with the Search_ class.\n- Django signal receivers on save and delete for keeping Elasticsearch in sync.\n- Management commands for creating, deleting, rebuilding and populating indices.\n- Elasticsearch auto mapping from django models fields.\n- Complex field type support (ObjectField, NestedField).\n- Requirements\n\n   - Django >= 1.10\n   - Python 2.7, 3.5, 3.6, 3.7\n\n**Elasticsearch Compatibility:**\nThe library is compatible with all Elasticsearch versions since 5.x **but you have to use a matching major version:**\n\n- For Elasticsearch 7.0 and later, use the major version 7 (7.x.y) of the library.\n\n- For Elasticsearch 6.0 and later, use the major version 6 (6.x.y) of the library.\n\n- For Elasticsearch 5.0 and later, use the major version 0.5 (0.5.x) of the library.\n\n.. code-block:: python\n\n    # Elasticsearch 7.x\n    elasticsearch-dsl>=7.0.0,<8.0.0\n\n    # Elasticsearch 6.x\n    elasticsearch-dsl>=6.0.0,<7.0.0\n\n    # Elasticsearch 5.x\n    elasticsearch-dsl>=0.5.1,<6.0.0\n\n.. _Search: http://elasticsearch-dsl.readthedocs.io/en/stable/search_dsl.html\n\nQuickstart\n----------\n\nInstall Django Elasticsearch DSL::\n\n    pip install django-elasticsearch-dsl\n\n\n\nThen add ``django_elasticsearch_dsl`` to the INSTALLED_APPS\n\nYou must define ``ELASTICSEARCH_DSL`` in your django settings.\n\nFor example:\n\n.. code-block:: python\n\n    ELASTICSEARCH_DSL={\n        'default': {\n            'hosts': 'localhost:9200'\n        },\n    }\n\n``ELASTICSEARCH_DSL`` is then passed to ``elasticsearch-dsl-py.connections.configure`` (see here_).\n\n.. _here: http://elasticsearch-dsl.readthedocs.io/en/stable/configuration.html#multiple-clusters\n\nThen for a model:\n\n.. code-block:: python\n\n    # models.py\n\n    class Car(models.Model):\n        name = models.CharField()\n        color = models.CharField()\n        description = models.TextField()\n        type = models.IntegerField(choices=[\n            (1, \"Sedan\"),\n            (2, \"Truck\"),\n            (4, \"SUV\"),\n        ])\n\nTo make this model work with Elasticsearch, create a subclass of ``django_elasticsearch_dsl.Document``,\ncreate a ``class Index`` inside the ``Document`` class\nto define your Elasticsearch indices, names, settings etc and at last register the class using\n``registry.register_document`` decorator.\nIt required to defined ``Document`` class in  ``documents.py`` in your app directory.\n\n.. code-block:: python\n\n    # documents.py\n\n    from django_elasticsearch_dsl import Document\n    from django_elasticsearch_dsl.registries import registry\n    from .models import Car\n\n\n    @registry.register_document\n    class CarDocument(Document):\n        class Index:\n            # Name of the Elasticsearch index\n            name = 'cars'\n            # See Elasticsearch Indices API reference for available settings\n            settings = {'number_of_shards': 1,\n                        'number_of_replicas': 0}\n\n        class Django:\n            model = Car # The model associated with this Document\n\n            # The fields of the model you want to be indexed in Elasticsearch\n            fields = [\n                'name',\n                'color',\n                'description',\n                'type',\n            ]\n\n            # Ignore auto updating of Elasticsearch when a model is saved\n            # or deleted:\n            # ignore_signals = True\n            # Don't perform an index refresh after every update (overrides global setting):\n            # auto_refresh = False\n            # Paginate the django queryset used to populate the index with the specified size\n            # (by default there is no pagination)\n            # queryset_pagination = 5000\n\n\nTo create and populate the Elasticsearch index and mapping use the search_index command::\n\n    $ ./manage.py search_index --rebuild\n\nNow, when you do something like:\n\n.. code-block:: python\n\n    car = Car(\n        name=\"Car one\",\n        color=\"red\",\n        type=1,\n        description=\"A beautiful car\"\n    )\n    car.save()\n\nThe object will be saved in Elasticsearch too (using a signal handler). To get an\nelasticsearch-dsl-py Search_ instance, use:\n\n.. code-block:: python\n\n    s = CarDocument.search().filter(\"term\", color=\"red\")\n\n    # or\n\n    s = CarDocument.search().query(\"match\", description=\"beautiful\")\n\n    for hit in s:\n        print(\n            \"Car name : {}, description {}\".format(hit.name, hit.description)\n        )\n\nThe previous example returns a result specific to elasticsearch_dsl_, but it is also\npossible to convert the elastisearch result into a real django queryset, just be aware\nthat this costs a sql request to retrieve the model instances with the ids returned by\nthe elastisearch query.\n\n.. _elasticsearch_dsl: http://elasticsearch-dsl.readthedocs.io/en/latest/search_dsl.html#response\n\n.. code-block:: python\n\n    s = CarDocument.search().filter(\"term\", color=\"blue\")[:30]\n    qs = s.to_queryset()\n    # qs is just a django queryset and it is called with order_by to keep\n    # the same order as the elasticsearch result.\n    for car in qs:\n        print(car.name)\n\nFields\n------\n\nOnce again the ``django_elasticsearch_dsl.fields`` are subclasses of elasticsearch-dsl-py\nfields_. They just add support for retrieving data from django models.\n\n\n.. _fields: http://elasticsearch-dsl.readthedocs.io/en/stable/persistence.html#mappings\n\nUsing Different Attributes for Model Fields\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLet's say you don't want to store the type of the car as an integer, but as the\ncorresponding string instead. You need some way to convert the type field on\nthe model to a string, so we'll just add a method for it:\n\n.. code-block:: python\n\n    # models.py\n\n    class Car(models.Model):\n        # ... #\n        def type_to_string(self):\n            \"\"\"Convert the type field to its string representation\n            (the boneheaded way).\n            \"\"\"\n            if self.type == 1:\n                return \"Sedan\"\n            elif self.type == 2:\n                return \"Truck\"\n            else:\n                return \"SUV\"\n\nNow we need to tell our ``Document`` subclass to use that method instead of just\naccessing the ``type`` field on the model directly. Change the CarDocument to look\nlike this:\n\n.. code-block:: python\n\n    # documents.py\n\n    from django_elasticsearch_dsl import Document, fields\n\n    # ... #\n\n    @registry.register_document\n    class CarDocument(Document):\n        # add a string field to the Elasticsearch mapping called type, the\n        # value of which is derived from the model's type_to_string attribute\n        type = fields.TextField(attr=\"type_to_string\")\n\n        class Django:\n            model = Car\n            # we removed the type field from here\n            fields = [\n                'name',\n                'color',\n                'description',\n            ]\n\nAfter a change like this we need to rebuild the index with::\n\n    $ ./manage.py search_index --rebuild\n\nUsing prepare_field\n~~~~~~~~~~~~~~~~~~~\n\nSometimes, you need to do some extra prepping before a field should be saved to\nElasticsearch. You can add a ``prepare_foo(self, instance)`` method to a Document\n(where foo is the name of the field), and that will be called when the field\nneeds to be saved.\n\n.. code-block:: python\n\n    # documents.py\n\n    # ... #\n\n    class CarDocument(Document):\n        # ... #\n\n        foo = TextField()\n\n        def prepare_foo(self, instance):\n            return \" \".join(instance.foos)\n\nHandle relationship with NestedField/ObjectField\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor example for a model with ForeignKey relationships.\n\n.. code-block:: python\n\n    # models.py\n\n    class Car(models.Model):\n        name = models.CharField()\n        color = models.CharField()\n        manufacturer = models.ForeignKey('Manufacturer')\n\n    class Manufacturer(models.Model):\n        name = models.CharField()\n        country_code = models.CharField(max_length=2)\n        created = models.DateField()\n\n    class Ad(models.Model):\n        title = models.CharField()\n        description = models.TextField()\n        created = models.DateField(auto_now_add=True)\n        modified = models.DateField(auto_now=True)\n        url = models.URLField()\n        car = models.ForeignKey('Car', related_name='ads')\n\n\nYou can use an ObjectField or a NestedField.\n\n.. code-block:: python\n\n    # documents.py\n\n    from django_elasticsearch_dsl import Document, fields\n    from .models import Car, Manufacturer, Ad\n\n    @registry.register_document\n    class CarDocument(Document):\n        manufacturer = fields.ObjectField(properties={\n            'name': fields.TextField(),\n            'country_code': fields.TextField(),\n        })\n        ads = fields.NestedField(properties={\n            'description': fields.TextField(analyzer=html_strip),\n            'title': fields.TextField(),\n            'pk': fields.IntegerField(),\n        })\n\n        class Index:\n            name = 'cars'\n\n        class Django:\n            model = Car\n            fields = [\n                'name',\n                'color',\n            ]\n            related_models = [Manufacturer, Ad]  # Optional: to ensure the Car will be re-saved when Manufacturer or Ad is updated\n\n        def get_queryset(self):\n            \"\"\"Not mandatory but to improve performance we can select related in one sql request\"\"\"\n            return super(CarDocument, self).get_queryset().select_related(\n                'manufacturer'\n            )\n\n        def get_instances_from_related(self, related_instance):\n            \"\"\"If related_models is set, define how to retrieve the Car instance(s) from the related model.\n            The related_models option should be used with caution because it can lead in the index\n            to the updating of a lot of items.\n            \"\"\"\n            if isinstance(related_instance, Manufacturer):\n                return related_instance.car_set.all()\n            elif isinstance(related_instance, Ad):\n                return related_instance.car\n\n\nField Classes\n~~~~~~~~~~~~~\nMost Elasticsearch field types_ are supported. The ``attr`` argument is a dotted\n\"attribute path\" which will be looked up on the model using Django template\nsemantics (dict lookup, attribute lookup, list index lookup). By default the attr\nargument is set to the field name.\n\nFor the rest, the field properties are the same as elasticsearch-dsl\nfields_.\n\nSo for example you can use a custom analyzer_:\n\n.. _analyzer: http://elasticsearch-dsl.readthedocs.io/en/stable/persistence.html#analysis\n.. _types: https://www.elastic.co/guide/en/elasticsearch/reference/5.4/mapping-types.html\n\n.. code-block:: python\n\n    # documents.py\n\n    # ... #\n\n    html_strip = analyzer(\n        'html_strip',\n        tokenizer=\"standard\",\n        filter=[\"lowercase\", \"stop\", \"snowball\"],\n        char_filter=[\"html_strip\"]\n    )\n\n    @registry.register_document\n    class CarDocument(Document):\n        description = fields.TextField(\n            analyzer=html_strip,\n            fields={'raw': fields.KeywordField()}\n        )\n\n        class Django:\n            model = Car\n            fields = [\n                'name',\n                'color',\n            ]\n\n\nAvailable Fields\n~~~~~~~~~~~~~~~~\n\n- Simple Fields\n\n  - BooleanField(attr=None, \\*\\*elasticsearch_properties)\n  - ByteField(attr=None, \\*\\*elasticsearch_properties)\n  - CompletionField(attr=None, \\*\\*elasticsearch_properties)\n  - DateField(attr=None, \\*\\*elasticsearch_properties)\n  - DoubleField(attr=None, \\*\\*elasticsearch_properties)\n  - FileField(attr=None, \\*\\*elasticsearch_properties)\n  - FloatField(attr=None, \\*\\*elasticsearch_properties)\n  - IntegerField(attr=None, \\*\\*elasticsearch_properties)\n  - IpField(attr=None, \\*\\*elasticsearch_properties)\n  - GeoPointField(attr=None, \\*\\*elasticsearch_properties)\n  - GeoShapField(attr=None, \\*\\*elasticsearch_properties)\n  - ShortField(attr=None, \\*\\*elasticsearch_properties)\n  - StringField(attr=None, \\*\\*elasticsearch_properties)\n\n- Complex Fields\n\n  - ObjectField(properties, attr=None, \\*\\*elasticsearch_properties)\n  - NestedField(properties, attr=None, \\*\\*elasticsearch_properties)\n\n- Elasticsearch >=5 Fields\n\n  - TextField(attr=None, \\*\\*elasticsearch_properties)\n  - KeywordField(attr=None, \\*\\*elasticsearch_properties)\n\n``properties`` is a dict where the key is a field name, and the value is a field\ninstance.\n\n\nIndex\n-----\nIn typical scenario using `class Index` on a `Document` class is sufficient to perform any action.\nIn a few cases though it can be useful to manipulate an Index object directly.\nTo define an Elasticsearch index you must instantiate a ``elasticsearch_dsl.Index`` class and set the name\nand settings of the index.\nAfter you instantiate your class, you need to associate it with the Document you\nwant to put in this Elasticsearch index and also add the `registry.register_document` decorator.\n\n\n.. code-block:: python\n\n    # documents.py\n    from elasticsearch_dsl import Index\n    from django_elasticsearch_dsl import Document\n    from .models import Car, Manufacturer\n\n    # The name of your index\n    car = Index('cars')\n    # See Elasticsearch Indices API reference for available settings\n    car.settings(\n        number_of_shards=1,\n        number_of_replicas=0\n    )\n\n    @registry.register_document\n    @car.document\n    class CarDocument(Document):\n        class Django:\n            model = Car\n            fields = [\n                'name',\n                'color',\n            ]\n\n    @registry.register_document\n    class ManufacturerDocument(Document):\n        class Index:\n            name = 'manufacture'\n            settings = {'number_of_shards': 1,\n                        'number_of_replicas': 0}\n\n        class Django:\n            model = Car\n            fields = [\n                'name',\n                'country_code',\n            ]\n\nWhen you execute the command::\n\n    $ ./manage.py search_index --rebuild\n\nThis will create two index named ``cars`` and ``manufacture`` in Elasticsearch with appropriate mapping.\n\n\nManagement Commands\n-------------------\n\nDelete all indices in Elasticsearch or only the indices associate with a model (--models):\n\n::\n\n    $ search_index --delete [-f] [--models [app[.model] app[.model] ...]]\n\n\nCreate the indices and their mapping in Elasticsearch:\n\n::\n\n    $ search_index --create [--models [app[.model] app[.model] ...]]\n\nPopulate the Elasticsearch mappings with the django models data (index need to be existing):\n\n::\n\n    $ search_index --populate [--models [app[.model] app[.model] ...]]\n\nRecreate and repopulate the indices:\n\n::\n\n    $ search_index --rebuild [-f] [--models [app[.model] app[.model] ...]]\n\n\nSettings\n--------\n\nELASTICSEARCH_DSL_AUTOSYNC\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``True``\n\nSet to ``False`` to globally disable auto-syncing.\n\nELASTICSEARCH_DSL_INDEX_SETTINGS\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``{}``\n\nAdditional options passed to the elasticsearch-dsl Index settings (like ``number_of_replicas`` or ``number_of_shards``).\n\nELASTICSEARCH_DSL_AUTO_REFRESH\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``True``\n\nSet to ``False`` not force an [index refresh](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html) with every save.\n\nELASTICSEARCH_DSL_SIGNAL_PROCESSOR\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis (optional) setting controls what SignalProcessor class is used to handle\nDjango's signals and keep the search index up-to-date.\n\nAn example:\n\n.. code-block:: python\n\n    ELASTICSEARCH_DSL_SIGNAL_PROCESSOR = 'django_elasticsearch_dsl.signals.RealTimeSignalProcessor'\n\nDefaults to ``django_elasticsearch_dsl.signals.RealTimeSignalProcessor``.\n\nYou could, for instance, make a ``CelerySignalProcessor`` which would add\nupdate jobs to the queue to for delayed processing.\n\nTesting\n-------\n\nYou can run the tests by creating a Python virtual environment, installing\nthe requirements from ``requirements_test.txt`` (``pip install -r requirements_test``)::\n\n    $ python runtests.py\n\nOr::\n\n    $ make test\n\n    $ make test-all # for tox testing\n\nFor integration testing with a running Elasticsearch server::\n\n    $ python runtests.py --elasticsearch [localhost:9200]\n\n\nTODO\n----\n\n- Add support for --using (use another Elasticsearch cluster) in management commands.\n- Add management commands for mapping level operations (like update_mapping....).\n- Dedicated documentation.\n- Generate ObjectField/NestField properties from a Document class.\n- More examples.\n- Better ``ESTestCase`` and documentation for testing\n\n\n\n\nHistory\n-------\n\n0.5.1 (2018-11-07)\n~~~~~~~~~~~~~~~~~~\n* Limit elastsearch-dsl to supported versions\n\n0.5.0 (2018-04-22)\n~~~~~~~~~~~~~~~~~~\n* Add Support for Elasticsearch 6 thanks to HansAdema\n\nBreaking Change:\n~~~~~~~~~~~~~~~~\nDjango string fields now point to ES text field by default.\nNothing should change for ES 2.X but if you are using ES 5.X,\nyou may need to rebuild and/or update some of your documents.\n\n\n0.4.5 (2018-04-22)\n~~~~~~~~~~~~~~~~~~\n* Fix prepare with related models when deleted (See PR #99)\n* Fix unwanted calls to get_instances_from_related\n* Fix for empty ArrayField (CBinyenya)\n* Fix nested OneToOneField when related object doesn't exist (CBinyenya)\n* Update elasticsearch-dsl minimal version\n\n0.4.4 (2017-12-13)\n~~~~~~~~~~~~~~~~~~\n* Fix to_queryset with es 5.0/5.1\n\n0.4.3 (2017-12-12)\n~~~~~~~~~~~~~~~~~~\n* Fix syncing of related objects when deleted\n* Add django 2.0 support\n\n0.4.2 (2017-11-27)\n~~~~~~~~~~~~~~~~~~\n* Convert lazy string to string before serialization\n* Readme update (arielpontes)\n\n0.4.1 (2017-10-17)\n~~~~~~~~~~~~~~~~~~\n* Update example app with get_instances_from_related\n* Typo/grammar fixes\n\n0.4.0 (2017-10-07)\n~~~~~~~~~~~~~~~~~~\n* Add a method on the Search class to return a django queryset from an es result\n* Add a queryset_pagination option to DocType.Meta for allow the pagination of\n  big django querysets during the index populating\n* Remove the call to iterator method for the django queryset\n* Fix DocType inheritance. The DocType is store in the registry as a class and not anymore as an instance\n\n\n0.3.0 (2017-10-01)\n~~~~~~~~~~~~~~~~~~\n* Add support for resynching ES documents if related models are updated (HansAdema)\n* Better management for django FileField and ImageField\n* Fix some errors in the doc (barseghyanartur, diwu1989)\n\n0.2.0 (2017-07-02)\n~~~~~~~~~~~~~~~~~~\n* Replace simple model signals with easier to customise signal processors (barseghyanartur)\n* Add options to disable automatic index refreshes (HansAdema)\n* Support defining DocType indexes through Meta class (HansAdema)\n* Add option to set default Index settings through Django config (HansAdema)\n\n0.1.0 (2017-05-26)\n~~~~~~~~~~~~~~~~~~\n* First release on PyPI.\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/sabricot/django-elasticsearch-dsl",
    "keywords": "django elasticsearch elasticsearch-dsl",
    "license": "Apache Software License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-elasticsearch-dsl",
    "package_url": "https://pypi.org/project/django-elasticsearch-dsl/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-elasticsearch-dsl/",
    "project_urls": {
      "Homepage": "https://github.com/sabricot/django-elasticsearch-dsl"
    },
    "release_url": "https://pypi.org/project/django-elasticsearch-dsl/7.0.0/",
    "requires_dist": [
      "elasticsearch-dsl (>=7.0.0<8.0.0)"
    ],
    "requires_python": "",
    "summary": "Wrapper around elasticsearch-dsl-py for django models",
    "version": "7.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16680945,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9c3ad2108a11a37907d16323a21778f27fca44cfaa77c66e5cbf6f9ed60e9c40",
        "md5": "86a5b814b2c043a812db242ff0485e63",
        "sha256": "9285d0ff8ad266a9fed60b570f683de98d2a1fdffe2ea24e1efe3325a13586b8"
      },
      "downloads": -1,
      "filename": "django_elasticsearch_dsl-7.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "86a5b814b2c043a812db242ff0485e63",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 20137,
      "upload_time": "2019-08-10T20:18:11",
      "upload_time_iso_8601": "2019-08-10T20:18:11.020945Z",
      "url": "https://files.pythonhosted.org/packages/9c/3a/d2108a11a37907d16323a21778f27fca44cfaa77c66e5cbf6f9ed60e9c40/django_elasticsearch_dsl-7.0.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9c9d7926288f83e55c3f11f94dabaf26bfceb6fa39ac8e86ea77b6ec8cb4a9d2",
        "md5": "7951fb8003c6dbdaacc276ace3a63cbf",
        "sha256": "7ef03bfc1a2162c0626c8059a16dbfcbb1d69dfc4680ea96a0747f7c6eb6ae3c"
      },
      "downloads": -1,
      "filename": "django-elasticsearch-dsl-7.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "7951fb8003c6dbdaacc276ace3a63cbf",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 24472,
      "upload_time": "2019-08-10T20:18:13",
      "upload_time_iso_8601": "2019-08-10T20:18:13.709506Z",
      "url": "https://files.pythonhosted.org/packages/9c/9d/7926288f83e55c3f11f94dabaf26bfceb6fa39ac8e86ea77b6ec8cb4a9d2/django-elasticsearch-dsl-7.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}