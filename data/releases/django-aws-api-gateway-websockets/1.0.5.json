{
  "info": {
    "author": "Steven Mapes",
    "author_email": "steve@stevenmapes.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Framework :: Django",
      "Framework :: Django :: 3.2",
      "Framework :: Django :: 4.0",
      "Framework :: Django :: 4.1",
      "Intended Audience :: Developers",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Database"
    ],
    "description": "[![Read The Docs](https://img.shields.io/readthedocs/django-mysql?style=for-the-badge)](https://django-aws-api-gateway-websockets.readthedocs.io/)\n[![CI Build Status](https://img.shields.io/github/workflow/status/StevenMapes/django-aws-api-gateway-websockets/CI/main?style=for-the-badge)](https://github.com/StevenMapes/django-aws-api-gateway-websockets/actions)\n[![Coverage](https://img.shields.io/codecov/c/github/StevenMapes/django-aws-api-gateway-websockets/main?style=for-the-badge)](https://codecov.io/github/StevenMapes/django-aws-api-gateway-websockets/)\n![Code Style](https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge)\n![Pre-Commit Enabled](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white&style=for-the-badge)\n\n\n# Django AWS API Gateway Websockets\nIt is the aim of this project to create a uniform way to record websocket connections, associate the Django user who established the connection and then retrieve that user within each request.\n\nThis project is designed to work exclusively with AWS API Gateway.\n\nIt is not intended to be a replacement of [Django Channels](https://github.com/django/channels) instead this project allows you to add [WebSockets](https://en.wikipedia.org/wiki/WebSocket) support into your project by writing normal HTTP request-response views whilst allowing [AWS API Gateway](https://aws.amazon.com/api-gateway/) to worry about the WebSocket connection.\n\nThis project introduced a new [Class-Based-View](https://docs.djangoproject.com/en/dev/topics/class-based-views/) to handle connections, disconnections, routing, basic security checks and ensuring that the User object is available within every request.\n\nThe project will keep track of which users created which WebSockets, which ones are active and will allow you to send messages back down the socket to the client via Boto3.\n\nPlease refer to the installation notes and Getting Start Guides.\n\n# Security Concerns\n**IMPORTANT:**: In order to work the dispatch method requires the ```csrf_exempt``` decorator to be added. This has\nalready been added as a class decorator on the base view but if you overload the dispatch method you will need to add\nit back to avoid receiving CSRF Token failures.\n\n# Python and Django Support\nThis project officially supports Python 3.8+ and Django 3.2+.\n\n| **Python/Django** | **3.2** | **4.0** | **4.1** | **4.2** |\n|-------------------|---------|---------|---------|---------|\n| 3.8               | Y       | Y       | Y       | N/A     |\n| 3.9               | Y       | Y       | Y       | N/A     |\n| 3.10              | Y       | Y       | Y       | N/A     |\n\n# Installation\nYou can install this package from pip using\n```\npip install django-aws-api-gateway-websockets\n```\n\n## settings.py\nAdd ```django_aws_api_gateway_websockets``` into ```INSTALLED_APPS``` \n\n### IMPORTANT\nIf your site is **not** already running cross-origin you will need to update some settings and flush the sessions to ensure the primary domain and subdomain will work.\n\nBecause the API Gateway will run from a subdomain you need ensure the cookies are setup to allow subdomains to read them.\nAssuming your site runs from www.example.com and you wanted to use ws.www.example.com for websockets you would need to \nset the below CSRF and COOKIE settings\n```\n# CSRF\nCSRF_COOKIE_SAMESITE=Lax\nCSRF_TRUSTED_ORIGINS=www.example.com,ws.example.com\nCSRF_COOKIE_DOMAIN='.www.example.com'\n\n# Sessions\nSESSION_COOKIE_SAMESITE='Lax'\nSESSION_COOKIE_NAME='mysessionid'\nSESSION_COOKIE_DOMAIN='.www.example.com'\n```\n\n**NOTE:** You need to rename the SESSION cookie. In the example I have renamed if from ```sessionid``` to ```mysessionid```. This will ensure that any old cookies are ignored.\n\n### Flushing Sessions\nBecause you are changing the session cookie you will also need to flush any cached sessions using ```python manage.py clearsessions```.\n\n## Clearing Stale Websocket connections\nThe websocket connections will become stale over time and some housekeeping is required.  To help there is a management\ncommand clearWebSocketSessions that can be run to delete the closed connections from the database.  Simply run\n```python manage.py clearWebSocketSessions```. I recommend setting this as a scheduled task.\n\n# AWS Setup\nIn order for this package to create the API Gateway, it's routes, integration, custom domain and to publish messages\nyou will need to assign the correct permission to the IAM User/Role following best practices of restrictive permission.\n\nIf you are using a EC2/ECS then you should be using an IAM Role otherwise use a user.\n\nThis package **does not** include creating an AWS Certificate as you may already have one. You should create that \nyourself.  If you do not know how then see the [Appendix](#Appendix) section at the end of this file.\n\n## IAM Policy\nYou'll need to grant the IAM permission to allow this project to create the API Gateway, create the domain mappings and\nto execute the API to send messages from the server to the client(s).\n\nI'm still reviewing the \"minimum required permissions\" but this project has been tested with the \nfollowing IAM policy which you can copy and paste into the JSON editor within the AWS console:\n\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"DjangoApiGatewayPolicy01\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"apigateway:GET\",\n                \"apigateway:PATCH\",\n                \"apigateway:POST\",\n                \"apigateway:PUT\",\n                \"execute-api:*\",\n                \"iam:CreateServiceLinkedRole\"\n            ],\n            \"Resource\": [\n                \"arn:aws:apigateway:*::/apis\",\n                \"arn:aws:apigateway:*::/apis/*\",\n                \"arn:aws:apigateway:*::/apis/*/authorizers\",\n                \"arn:aws:apigateway:*::/apis/*/authorizers/*\",\n                \"arn:aws:apigateway:*::/apis/*/cors\",\n                \"arn:aws:apigateway:*::/apis/*/deployments\",\n                \"arn:aws:apigateway:*::/apis/*/deployments/*\",\n                \"arn:aws:apigateway:*::/apis/*/exports/*\",\n                \"arn:aws:apigateway:*::/apis/*/integrations\",\n                \"arn:aws:apigateway:*::/apis/*/integrations/*\",\n                \"arn:aws:apigateway:*::/apis/*/integrations/*/integrationresponses\",\n                \"arn:aws:apigateway:*::/apis/*/integrations/*/integrationresponses/*\",\n                \"arn:aws:apigateway:*::/apis/*/models\",\n                \"arn:aws:apigateway:*::/apis/*/models/*\",\n                \"arn:aws:apigateway:*::/apis/*/models/*/template\",\n                \"arn:aws:apigateway:*::/apis/*/routes\",\n                \"arn:aws:apigateway:*::/apis/*/routes/*\",\n                \"arn:aws:apigateway:*::/apis/*/routes/*/requestparameters/*\",\n                \"arn:aws:apigateway:*::/apis/*/routes/*/routeresponses\",\n                \"arn:aws:apigateway:*::/apis/*/routes/*/routeresponses/*\",\n                \"arn:aws:apigateway:*::/apis/*/stages\",\n                \"arn:aws:apigateway:*::/apis/*/stages/*\",\n                \"arn:aws:apigateway:*::/apis/*/stages/*/accesslogsettings\",\n                \"arn:aws:apigateway:*::/apis/*/stages/*/cache/authorizers\",\n                \"arn:aws:apigateway:*::/apis/*/stages/*/routesettings/*\",\n                \"arn:aws:apigateway:{AWS-REGION-NAME}::/domainnames\",\n                \"arn:aws:apigateway:{AWS-REGION-NAME}::/domainnames/*/apimappings\",\n                \"arn:aws:apigateway:{AWS-REGION-NAME}::/domainnames/*/apimappings/*\",\n                \"arn:aws:execute-api:{AWS-REGION-NAME}:{AWS-ACCOUNT-NUMBER}:*/*/*/*\",\n                \"arn:aws:iam::{AWS-ACCOUNT-NUMBER}:role/aws-service-role/ops.apigateway.amazonaws.com/AWSServiceRoleForAPIGateway\"\n            ]\n        }\n    ]\n}\n```\n\nYou will need to edit the permissio and replace the following: \n1. ```{AWS-REGION-NANE}``` with the correct AWS region you are using, E.G ```eu-west-1```. If you wish to grant access to all regions then replace this placeholder with an ```*```\n2. ```{AWS-ACCOUNT-NUMBER}``` with your account number E.G: 123456789101 \n\nThis policy grants permissions to ensure the API Gateway(s) will be created, the custom domain name mapped to the \ngateway and that you can send messages from the server to clients.  The AWS Service role is required as it's used when \nyou create a custom domain name for API Gateway. If you do this via the console it will create the role for you so we\nneed to ensure the IAM user has the permission in order to replicate this.\n\nOnce you have created your API Gateway(s) you may wish to follow AWS best practice and restrict of revoke the \npermissions to the API Gateway(s) you have created.  Because I do not know what you will name your gateway, the \npermissions above will allow you to add/edit and API gateway on your account.\n\n# Getting Started\n\nThe core files within this project are:\n\n1. ```django_aws_api_gateway_websockets.views.WebSocketView``` - The base class-based view from which you should extend\n2. ```django_aws_api_gateway_websockets.models.ApiGateway``` - A model for managing the API Gateway. A Django Admin \npage is included along with custom actions to create the API Gateway and configure a Custom Domain.  For those with\nprojects not using Django Admin there are two management commands that perform the same actions. \n3. ```django_aws_api_gateway_websockets.models.WebSocketSession``` - The websocket session store. Every connection \nwrites to this model which contains a method to send a message to the connection.  The QuerySet of the objects model \nmanager has been extended to include a method to send messages to all records included within a queryset.  \n\n## Django\n### URLS.py\nEdit your urls.py file and add an entry for the URL you wish API Gateway to call. **IMPORTANT** The slug parameter \nmust be called \"route\". This will be populated by API Gateway with the route it uses E.G. $connect, $default or \n$disconnect\n\nE.G. \n```\npath(\"ws/<slug:route>\", ExampleWebSocketView.as_view(), name=\"example_websocket\")\n```\n\n### Creating the Views\nSubclass the ```WebSocketView``` and implement methods where the name of the method is the name of the route the \nAPI Gateway has been setup to use. There are already methods for $connect and $disconnect you just need to implement\na method for ```default``` along with any other custom routes you have created.  The methods are selected dynamically\nvia the ```dispatch``` method with any leading dollar sign being remove.\n\nThe methods take the ```request``` parameter and only needs to return a response if you wish to return a negative HTTP\nresponse such as a HttpResponseBadRequest otherwise there is no need to return anything.\n\n```\nfrom django_aws_api_gateway_websockets.views import WebSocketView\n\nclass ExampleWebSocketView(WebSocketView):\n    \"\"\"Custom Websocket view.\"\"\"\n\n    def default(self, request, *args, **kwargs) -> JsonResponse:\n        \"\"\"Add the logic you wish to make here when you receive a message.\n         create your JSON response that you will handle within the Javascript\n         \"\"\"\n        logger.debug(f\"body {self.body}\")\n\n```\n\nIf you want to send a response to the websocket that made the request then you need to call the ```send_message()``` on\nthe WebSocketSession that is being used. See the example below\n\n```\nfrom django_aws_api_gateway_websockets.views import WebSocketView\n\nclass ExampleWebSocketView(WebSocketView):\n    \"\"\"Custom Websocket view.\"\"\"\n\n    def default(self, request, *args, **kwargs) -> JsonResponse:\n        # Do stuff \n        ...        \n        \n        # Send a message back to the client - i.e unicast\n        self.websocket_session.send_message({\"key1\": \"value1\", \"key2\": \"value2\"})\n\n```\n\nIf you are using the \"channels\" to group WebSocket connections together for multicasting, that is one-to-many \ncommunication then you can use the following example\n\n```\nfrom django_aws_api_gateway_websockets.models import WebSocketSession\nfrom django_aws_api_gateway_websockets.views import WebSocketView\n\n\nclass ExampleWebSocketView(WebSocketView):\n    \"\"\"Custom Websocket view.\"\"\"\n\n    def default(self, request, *args, **kwargs) -> JsonResponse:\n        # Do stuff \n        ...        \n        \n        # Multicast a message to ALL CONNECTED clients on the same \"channel\"\n        WebSocketSession.objects.filter(\n            channel_name=self.websocket_session.channel_name, connected=True\n        ).send_message({\"key\": \"value})\n\n```\n\n#### Using the Route Selection Key value to call specific methods\nAPI Gateway works by routing messages based on the \"Route Selection Key\". This project sets you up with a default route\nso that you have a catch-all route but the Route Selection Key is preserved and is used by the dispatch method when \nselecting the method to use to handle the request.  This means that you can write individual methods to handle each \nroute individually for cleaner, more testable code.\n\nIn the example that follows the default Route Selection Key of **action** is being used. \nAssume that two series of sends are made to the WebSocket. The first with the payload: \n```{\"action\": \"test\", \"value\": \"hello world\"}``` and the second ```{\"action\": \"help\", \"value\": \"Help Me\"}```. You can\neither handle these within the catch-all ```default``` method or you can write individual methods for each action\n\n```\nfrom django_aws_api_gateway_websockets.models import WebSocketSession\nfrom django_aws_api_gateway_websockets.views import WebSocketView\n\n\nclass ExampleWebSocketView(WebSocketView):\n    \"\"\"Custom Websocket view.\"\"\"\n\n    def test(self, request, *args, **kwargs) -> JsonResponse:\n        print(self.body.get(\"value\")\n        # Prints \"hello world\" \n\n    def help(self, request, *args, **kwargs) -> JsonResponse:\n        print(self.body.get(\"value\")\n        # Prints \"Help Me\" \n```\n\n**Remember**: The \"action\" key is the default ```route_selection_key```, if you chose to use a different one when \nsetting uip the websocket make sure to update the ```route_selection_key``` class property to use the same value\n\n\n### Debugging the View\nSometimes you the view may return a HTTP400 that you wish to debug further. In order to help with this you can pass\n```debug=True``` into the ```as_view()``` method. The class will then call the private method ```_debug(msg)``` passing\nin a string. By default this method will update a list property called ```debug_log``` with the message string but \nyou may wish to simply overload the method and call your logger.\n\nE.G.\n```\ndef _debug(self, msg: str):\n    if self.debug:\n        logger.debug(msg)\n```\n\nThis can help track the issue which may be as simply as sending a message from the client that is missing the \n```route_select_key```.\n\n## Example of sending a message from the server to the client\nTo send a message to a specific connection simple load its ```WebSocketSession``` record and then call the \n```send_message``` method passing in a JSON compatible dictionary of the payload you wish to send to the client.\n\n### Sending a message to one connection\n```python\nfrom django_aws_api_gateway_websockets.models import WebSocketSession\n\nobj = WebSocketSession.objects.get(pk=1)\nobj.send_message({\"type\": \"example\", \"msg\": \"This is a message\"})\n```\n\n### Sending a message to ALL active connections associated with the same channel \n```python\nfrom django_aws_api_gateway_websockets.models import WebSocketSession\n\nWebSocketSession.objects.filter(channel_name=\"Chatroom 1\").send_message(\n    {\"msg\": \"This is a a sample message\"}\n)\n```\n\nThe ```WebSocketSessionQuerySet.send_message``` method automatically adds a filter of ```connected=True``` \n\n## Django Admin\nTwo Django Admin pages will be added to your project under the app _Django AWS APIGateway WebSockets_. Those pages \nallow you to view and manage the two base models.\n\n### Creating an API Gateway Endpoint\n**Important** This section assumes that you are using an IAM account with the permissions listed earlier.\n\nUsing the Django Admin page create a new API Gateway record using the following for reference:\n\n1. **API Name** - The human friendly API Name\n2. **API Description** - Optional\n3. **Default channel name** - Fill this in if you want all connections to this Websocket to also be associated with \nthe same \"channel\" otherwise leave it blank. \"Channels\" are groups of web socket connections and nothing more.\n4. **Target base Endpoint** - This is the full URL path to the view you wish to use to handle the requests **excluding**\nthe ```route``` slug portion that will be automatically appended.\n5. **Certificate ARN** - You'll need to manually create certificate within AWS. Once you have, copy the ARN into this field\n6. **Hosted Zone ID** - If you use Route53 then you'll need to enter the Hosted Zone ID here if you wish to use a custom\ndomain name with the API Gateway Endpoint\n7. **API Key Selection Expression** - In most cases leave this as the default value. See the AWS docs for more\n8. **Route selection expression** - As per the above. This is the field that maps the \"action\" key within the payload \nas being the key to determine the route to take.  If you change this then you must overload the \n```route_selection_key``` of the view\n9. **Route key** - This is the default root key. In most cases you will not need to change this.\n10. **Stage Name** - The name you wish to give to the staging. Currently this package does not support multiple stages.\nIf you leave it blank it will default to \"production\"\n11. **Stage description\" - Optional\n12. **Tags** - Currently not implement but these will be used to create the tags with AWS\n13. **API ID** - This will be populated when the API is created.\n14. **API Endpoint** - This will be populated when the API is created.\n15. **API Gateway Domain Name** - This will be populated when you run the Custom Domain setup. The value that appears \nhere is the value to which you should your DNS CNAME entry should point. \n16. **API Mapping ID** - This will be populated when the API is created.\n\nOnce you have created the record within the database simply select it from the Django Admin list view, choose \n**Create API Gateway** action from the actions list and click Go.  The API Gateway record will be created within your\naccount. When it's ready the \"API Created\" column will show as True.\n\nOnce the API has been created you can now add a custom domain name mapping by choosing the row again and this time \nselecting the **Create Custom Domain record for the API**. This will create the Custom Domain record and will associate\nit with the stage name you entered earlier. Once it's completed the **Custom Domain Created** flag will be set as True.\n\nAt this point you can open the record where you'll find that the ```API Gateway Domain Name``` has been populated.\n\n## Django Management Commands\nIf you are not using Django Admin then you can populate the apigateway database table manually using the same list \nas shown above.\n\nOnce you've populated those fields you an then run the two actions as management commands rather than via Django Admin.\n\n```python manage.py createApiGateway --pk=1```\n\n```python manage.py createCustomDomain --pk=1```\n\nThe same actions will run as above.\n\n## Gotchas and debugging\n### Failure to connect to websockets\n#### Differing required headers\nThe most common reasons for the websocket failing to connect is due to different required headers. The base view is \nset-up with two lists of expected headers. ```required_headers``` and ```additional_required_headers```. If you are \ndeploying to an EC2 server then you shouldn't have to change these but if you are deploying else where or are testing\nlocally you may find that you need to change some of these. During development of this library I was using an\n[NGROK](https://ngrok.com/) network edge tunnel and found that the \"X-Real-Ip\" and \"Connection\" headers were being lost\nduring which is why they were moved to the additional_required_headers. If you find this is the case for you then simply\noverload the class property and set it to an empty list.\n\n\n# Client Side Integration (Javascript)\nThis section will guide you through two common ways of connecting to and using this project from a webpage.\n\n### Basic Integration\nBelow is a very basic integration using the WebSockets API built into browsers. It does not handle reconnecting dropped\nwebsockets, see the next section for that.\n\n**WARNING**: This method will create a WebSocket that will timeout after around 10 minutes. \n\nThe below example assumes you created the API Gateway to work on the custom domain name ws.example.com\n```javascript\nlet wss_url = 'wss://ws.example.com';\nlet regDeskWSocket = new WebSocket(wss_url);\nregDeskWSocket.onmessage = function(event) {\n    // Take your action here to handle messages being received\n    console.log(event);\n    let msg = JSON.parse(event.data);\n    console.log(msg);\n};\n```\n\nYou can set the channel by using the **channel** querystring parameter during the connection \n\n```javascript\nlet wss_url = 'wss://ws.example.com?channel=my+example+channel';\nlet exampleWS = new WebSocket(wss_url);\nexampleWS.onmessage = function(event) {\n    // Take your action here to handle messages being received\n    console.log(event);\n    let msg = JSON.parse(event.data);\n    console.log(msg);\n};\n```\n\n### Reconnecting WebSockets\nWebsockets can disconnect due top a variety of reasons to work around this here are some links to libraries of proposed\nsolutions\n\n1. [Stack Overflow- WebSocket: How to automatically reconnect after it dies](https://stackoverflow.com/questions/22431751/websocket-how-to-automatically-reconnect-after-it-dies)\n2. [JS library - reconnecting-websocket](https://github.com/joewalnes/reconnecting-websocket)\n\nThe below example is using the JS library. Note you just include the lib and then use the \n```ReconnectingWebSocket``` class rather than ```WebSocket```:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/reconnecting-websocket/1.0.0/reconnecting-websocket.min.js\" integrity=\"sha512-B4skI5FiLurS86aioJx9VfozI1wjqrn6aTdJH+YQUmCZum/ZibPBTX55k5d9XM6EsKePDInkLVrN7vPmJxc1qA==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n<script>\nlet wss_url = 'wss://ws.example.com';\nlet exampleWS = new ReconnectingWebSocket(wss_url);\nexampleWS.onmessage = function(event) {\n    // Take your action here to handle messages being received\n    console.log(event);\n    let msg = JSON.parse(event.data);\n    console.log(msg);\n};\n</script>\n```\n\n### Sending a message from the client to the server\nBoth the example above use the same method.\n\n```javascript\nlet wss_url = 'wss://ws.example.com?channel=my+example+channel';\nlet exampleWS = new WebSocket(wss_url);  // Or use ReconnectingWebSocket it does not matter\n\n// Send a message\nexampleWS.send(JSON.stringify({\"action\": \"custom\", \"message\": \"What is this\"}))\n```\n\n**IMPORTANT** The value of ```action``` determines the route that is used by **API Gateway**. By default, the only \nroutes that are set-up are ```$connect```, ```$disconnect``` and ```default```. Any messages sent to unknown routes on \nthe API Gateway are delivered to the ```default``` route.  So if you created a custom route called ```bob``` and then \nsent the following message from the client:\n\n```\nexampleWS.send(JSON.stringify({\"action\": \"bob\", \"message\": \"What is this\"}))\n```\n\nAPI Gateway will route this to the endpoint set for the \"bob\" route. This will be calling your view with the route slugs\nvalue being assigned to **bob**. The ```dispatch``` method of the view will then look for a method on the class called\n```bob```. If one is found then it will be invoked otherwise the ```default``` method will be called.\n\n# Appendix\n\n## Creating an SSL Certificate within AWS Certificate Manager\nPlease refer to the [official AWS documentation](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html)\n\n# Found a Bug?\nIssues are tracked via GitHub issues at the [project issue page](https://github.com/StevenMapes/django-aws-api-gateway-websockets/issues)\n\n# Have A Feature Request?\nFeature requests can be raised by creating an issue within the [project issue page](https://github.com/StevenMapes/django-aws-api-gateway-websockets/issues), but please create the issue with \"Feature Request -\" at the start of the issue\n\n# Testing\nTo run the tests use\n\n```\ncoverage erase && \\\npython -W error::DeprecationWarning -W error::PendingDeprecationWarning -m coverage run --parallel -m pytest --ds tests.settings && \\\ncoverage combine && \\\ncoverage report\n```\n\n# Compiling Requirements\nRun ```pip install pip-tools``` then run ```python requirements/compile.py``` to generate the various requirements files\nAlso require ```pytest-django``` for testing\n\n# pip-tools\n\n# tox\n\n# Contributing\n- [Check for open issues](https://github.com/StevenMapes/django-aws-api-gateway-websockets/issues) at the project issue page or open a new issue to start a discussion about a feature or bug.\n- Fork the [repository on GitHub](https://github.com/StevenMapes/django-aws-api-gateway-websockets) to start making changes.\n- Clone the repository\n- Initialise pre-commit by running ```pre-commit install```\n- Install requirements from one of the requirement files depending on the versions of Python and Django you wish to use.\n- Add a test case to show that the bug is fixed or the feature is implemented correctly.\n- Test using ```python -W error::DeprecationWarning -W error::PendingDeprecationWarning -m coverage run --parallel -m pytest --ds tests.settings```\n- Create a pull request, tagging the issue, bug me until I can merge your pull request. Also, don't forget to add yourself to AUTHORS.\n\n# TO DO\n1. Example of a \"chat\" implementation I.E. a view that receives a message and published the same message to all sessions \nwithin the same channel\n2. Example of setting the channel within the default handler\n3. Example of creating a custom route\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/StevenMapes/django-aws-api-gateway-websockets",
    "keywords": "Django,WebSockets,AWS,API Gateway,Amazon WebServices",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-aws-api-gateway-websockets",
    "package_url": "https://pypi.org/project/django-aws-api-gateway-websockets/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-aws-api-gateway-websockets/",
    "project_urls": {
      "Changelog": "https://github.com/StevenMapes/django-aws-api-gateway-websockets/blob/main/CHANGELOG.md",
      "Documentation": "https://django-aws-api-gateway-websockets.readthedocs.io/",
      "Homepage": "https://github.com/StevenMapes/django-aws-api-gateway-websockets",
      "Twitter": "https://twitter.com/stevenamapes"
    },
    "release_url": "https://pypi.org/project/django-aws-api-gateway-websockets/1.0.5/",
    "requires_dist": null,
    "requires_python": ">=3.8",
    "summary": "Created to allow Django projects to be used as a HTTP backend for AWS API Gateway websockets",
    "version": "1.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16476278,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c524ec40a7c1831429ab80bba25e05519d468d81b4ef09d807decc49083ffc56",
        "md5": "1d2c0f10c7feeecf1a39ae20cc2176b9",
        "sha256": "bc731e9bf9eceb99691cf348220b9ec7ce68e889f7d12a5c5c9baac2196f43b5"
      },
      "downloads": -1,
      "filename": "django-aws-api-gateway-websockets-1.0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "1d2c0f10c7feeecf1a39ae20cc2176b9",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 29817,
      "upload_time": "2022-12-08T19:38:14",
      "upload_time_iso_8601": "2022-12-08T19:38:14.933182Z",
      "url": "https://files.pythonhosted.org/packages/c5/24/ec40a7c1831429ab80bba25e05519d468d81b4ef09d807decc49083ffc56/django-aws-api-gateway-websockets-1.0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}