{
  "info": {
    "author": "John W Kerns",
    "author_email": "jkerns@packetsar.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Console",
      "Intended Audience :: Information Technology",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: MacOS",
      "Operating System :: Microsoft",
      "Operating System :: OS Independent",
      "Operating System :: POSIX",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Internet",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: System",
      "Topic :: System :: Networking",
      "Topic :: Utilities"
    ],
    "description": "# Meraki-CLI <img align=\"right\" width=\"200\" height=\"200\" src=\"icon.png\">\n\n\n[![Build Status](https://github.com/PackeTsar/meraki-cli/actions/workflows/python-package.yml/badge.svg)](https://github.com/PackeTsar/meraki-cli/actions/workflows/python-package.yml)\n[![Coverage](https://codecov.io/gh/PackeTsar/meraki-cli/branch/master/graph/badge.svg)](https://codecov.io/gh/PackeTsar/meraki-cli)\n[![PyPI](https://img.shields.io/pypi/v/meraki-cli.svg)](https://pypi.python.org/pypi/meraki-cli)\n[![Python Versions](https://img.shields.io/pypi/pyversions/meraki-cli.svg)](https://pypi.python.org/pypi/meraki-cli)\n[![Cisco DevNet](https://static.production.devnetcloud.com/codeexchange/assets/images/devnet-published.svg)](https://developer.cisco.com/codeexchange/github/repo/PackeTsar/meraki-cli)\n\nA simple CLI tool to automate and control your Cisco Meraki Dashboard!\n\nQuick Install: `pip3 install meraki-cli`\n\nQuick Command Cheat Sheet: **[Meraki-CLI Cheat Sheet](CHEATSHEET.md)**\n\nFull Command Guide: **[Meraki-CLI Command Guide](COMMAND_GUIDE.md)**\n\n\n-----------------------------------------\n## VERSION\nThe version of Meraki-CLI documented here is: **1.4.1**\n\nVersion History: **[Change Log](CHANGELOG.md)**\n\n\n-----------------------------------------\n## ABOUT\nMeraki-CLI is a wrapper around the official [Meraki Dashboard API Python SDK](https://github.com/meraki/dashboard-api-python). It takes all published functions in the library and makes them available to the user as a standard command-line tool with `-h` help options, commands, switches, arguments, and tab autocompletion. It also supports classic Linux-style pipelining, allowing the output of one instance of the program to be piped to the input of another.\n\n### Examples\n\n- List your associated organizations: `meraki organizations getOrganizations`\n- List the Meraki networks within an organization: `meraki organizations getOrganizationNetworks --organizationId 123456`\n- List the MX VLANs on a network: `meraki appliance getNetworkApplianceVlans --networkId N_12345`\n- Add a new MX VLAN to a network: `meraki appliance createNetworkApplianceVlan --networkId N_12345 --id 100 --name \"My New VLAN\" --applianceIp \"10.0.0.1\" --subnet \"10.0.0.0/24\"`\n\n### Capabilities\n\nSince the Meraki-CLI tool builds its arguments directly off of Meraki's SDK, it's capabilities exactly match those of the SDK and are updated automatically when Meraki adds new API capabilities. For a list of available commands from the last build of the Meraki-CLI, check out the **[Meraki-CLI Command Guide](COMMAND_GUIDE.md)**.\n\n### Screenshot\n[![screenshot](screenshot.png)](screenshot.png)\n\n-----------------------------------------\n## TABLE OF CONTENTS\n1. [Getting Started](#getting-started)\n    - [Prepare your OS](#prepare-your-os)\n    - [Install Meraki-CLI](#install-meraki-cli)\n        - [Upgrading](#upgrading)\n    - [Getting and Using your API Key](#getting-and-using-your-api-key)\n    - [A Few Starting Commands](#a-few-starting-commands)\n    - [Making Some Changes](#making-some-changes)\n2. [Tab Autocompletion](#tab-autocompletion)\n3. [Using a Config File](#using-a-config-file)\n4. [Debugging and Logging](#debugging-and-logging)\n5. [Filtering](#filtering)\n6. [Pipelining](#pipelining)\n    - [Overriding Values](#overriding-values)\n    - [Translations](#translations)\n    - [Outputting Commands](#outputting-commands)\n    - [How the Pipelining Works](#how-the-pipelining-works)\n7. [Advanced Usage](#advanced-usage)\n    - [Using --kwargs](#using---kwargs)\n        - [Dealing with --kwargs on Windows](#dealing-with---kwargs-on-windows)\n8. [Contributing](#contributing)\n\n\n-----------------------------------------\n## GETTING STARTED\n\n## Prepare your OS\n\n> **NOTE**: If you are installing on Windows 10 and want to use tab autocompletion of commands, you may want to review the [Windows 10](#windows-10) part of the \"Tab Autocompletion\" section first to see how to install Meraki-CLI on Windows 10 and be able to use autocompletion.\n\nIn order to use Meraki-CLI, you need to have Python 3 installed on your OS. If you do not yet have Python 3 installed, visit this [Python 3 Installation Instructions Page](https://github.com/PackeTsar/Install-Python) and install for your operating system.\n\n\n## Install Meraki-CLI\n\nThe easiest (and recommended) way to install Meraki-CLI is to use PIP.\n\nYou can use PIP to install Meraki-CLI with the command `pip3 install meraki-cli` or `python3 -m pip install meraki-cli`\n\nTo see if Meraki-CLI was successfully installed, run the `meraki` command and see if it displays the help menu.\n\n#### Upgrading\n\nIf you already have Meraki-CLi installed and want to upgrade to the latest release, use the command `pip3 install --upgrade --no-cache-dir meraki-cli` or `python3 -m pip install --upgrade --no-cache-dir meraki-cli`.\n\n\n## Getting and Using your API Key\n\nMeraki-CLI is command-line driven and once installed can be run with the command `meraki`. Once you have installed it, you can see the command guide by running the `meraki` command by itself.\n\nIn order to operate the CLI you need to input your Meraki API key using one of three methods:\n\n1. Saving your API key as an environment variable (recommended):\n    - **Windows**: `set MERAKI_DASHBOARD_API_KEY=6bec40cf957de430a6f1f2baa056b99a4fac9ea0`\n    - **MacOS/Linux**: `export MERAKI_DASHBOARD_API_KEY=6bec40cf957de430a6f1f2baa056b99a4fac9ea0`\n    - Once saved as an environment variable, you don't need to use the `-k` option when running commands\n2. Save your API key to a config file. See the \"[Using a Config File](#using-a-config-file)\" section for more info on how to do this.\n3. Use the `-k <api_key>` or `--apiKey <api_key>` argument at the top level of the command like `meraki -k <api_key>`\n\nYou can obtain a Meraki API key by:\n- Logging into the Meraki Dashboard\n- Clicking your user name in the top right corner\n- Browsing to **My profile**\n- View the 'API Access' section near the bottom of the page\n- Click on the '**Generate new API key**' button and copy down your new API key before saving. It will be a long hexadecimal string.\n\n> Note: The API key seen in the examples above is a public one Meraki provides for testing against their sandbox networks. Feel free to use it for testing things out, but sometimes it gets overused and is throttled by Meraki. Meraki also may change it in the future, so use your own if you can. All the output examples shown below use that key.\n\n\n## A Few Starting Commands\n\nOnce you have your new key saved, try listing out your organizations with the command `meraki -k API_KEY_HERE organizations getOrganizations`, substituting in your API key. This will print out a formatted table of your organizations. If you saved your API key as an environment variable, you can exclude the `-k` argument and simply issue `meraki organizations getOrganizations`.\n\nTake one of your organization ID numbers and look at the networks in it with `meraki organizations getOrganizationNetworks --organizationId 123456`\n\nYou can reformat any of this data into JSON output by adding the `-j` switch (before the command) to look something like `meraki -j organizations getOrganizations`\n\n> It is important to note that the columns included in a table often do not include all of the data returned from the API. If you need to see all the data returned, then use the `-j` switch and allow the tool to print out JSON data.\n\nYou can also change the table data which is output by filtering and ordering table columns. To do this, use the `-c` argument and provide a comma-seperated list of columns to display. Example: `meraki -c id,name,description`\n\nTo see any help menu, use the `-h` option at any command level:\n- `meraki -h` or just `meraki` will show you the top level options and arguments\n- `meraki appliance -h` or just `meraki appliance` will show you all the appliance-related commands\n- `meraki appliance createNetworkApplianceVlan -h` or just `meraki appliance createNetworkApplianceVlan` will show you an instruction page with all the arguments and options available for creating a new network appliance VLAN.\n\n\nIf you have any Meraki MS switches available, try viewing the port configurations with `meraki switch getDeviceSwitchPorts --serial 1234-ABCD-5678` or you can view the operational port stats by using `meraki switch getDeviceSwitchPortsStatuses --serial 1234-ABCD-5678`\n\n\n## Making Some Changes\n\nPushing changes into Meraki is done by running the correct command and passing in the necessary arguments.\n\nFor example, to rename a device, we just run the `devices updateDevice` command with the proper arguments included:\n\n`meraki devices updateDevice --serial 1234-ABCD-5678 --name NEW_DEVICE_NAME`\n\n```\n~$\n~$ meraki devices updateDevice --serial Q2HP-F5K5-R88R --name NEW_DEVICE_NAME\n┏━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ lat              ┃ lng               ┃ address ┃ serial         ┃ mac               ┃ lanIp         ┃ url              ┃ networkId            ┃ name            ┃ model    ┃ switchProfileId ┃ firmware       ┃ floorPlanId ┃\n┡━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ 37.4180951010362 │ -122.098531723022 │         │ Q2HP-F5K5-R88R │ 88:15:44:df:f3:af │ 10.10.10.131  │ https://n149.me… │ L_646829496481105433 │ NEW_DEVICE_NAME │ MS220-8P │ None            │ switch-11-31   │ None        │\n└──────────────────┴───────────────────┴─────────┴────────────────┴───────────────────┴───────────────┴──────────────────┴──────────────────────┴─────────────────┴──────────┴─────────────────┴────────────────┴─────────────┘\n~$\n~$\n```\n\nOr if we want to change the VLAN ID and name of a MS switch port, we can use:\n\n`meraki switch updateDeviceSwitchPort --serial 1234-ABCD-5678 --portId 1 --vlan 100 --name \"Data Port\"`\n\nIf the change succeeds, you will often see the newly updated item echoed back like this:\n\n```\n~$\n~$ meraki switch updateDeviceSwitchPort --serial Q2HP-F5K5-R88R --portId 1 --vlan 100 --name \"Data Port\"\n┏━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━┳━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┓\n┃ portId ┃ name      ┃ enabled ┃ poeEnabled ┃ type  ┃ vlan ┃ voiceVlan ┃ allowedVlans ┃ isolationEnabled ┃ rstpEnabled ┃ stpGuard ┃ linkNegotiation ┃ portScheduleId ┃ udld       ┃\n┡━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━╇━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━┩\n│ 1      │ Data Port │ True    │ True       │ trunk │ 100  │ None      │ all          │ False            │ True        │ disabled │ Auto negotiate  │ None           │ Alert only │\n└────────┴───────────┴─────────┴────────────┴───────┴──────┴───────────┴──────────────┴──────────────────┴─────────────┴──────────┴─────────────────┴────────────────┴────────────┘\n~$\n~$\n```\n\nMany commands which make changes to the dashboard (like `updateDeviceSwitchPort` above) have optional arguments (like `--vlan` and `--name`) which are used to send those changes. See the below help page for the `updateDeviceSwitchPort` command:\n\n```\n~$\n~$ meraki switch updateDeviceSwitchPort -h\nusage: meraki-cli.py switch updateDeviceSwitchPort [-h] --serial STRING --portId STRING [--kwargs JSON_STRING]\n\nUPDATE A SWITCH PORT\n\nhttps://developer.cisco.com/meraki/api-v1/#!update-device-switch-port\n\nAll Arguments:\n  --serial (string): (required)\n  --portId (string): (required)\n  --name (string): The name of the switch port\n  --tags (array): The list of tags of the switch port\n  --enabled (boolean): The status of the switch port\n  --type (string): The type of the switch port ('trunk' or 'access')\n  --vlan (integer): The VLAN of the switch port. A null value will clear the value set for trunk ports.\n  --voiceVlan (integer): The voice VLAN of the switch port. Only applicable to access ports.\n  --allowedVlans (string): The VLANs allowed on the switch port. Only applicable to trunk ports.\n  --poeEnabled (boolean): The PoE status of the switch port\n  --isolationEnabled (boolean): The isolation status of the switch port\n  --rstpEnabled (boolean): The rapid spanning tree protocol status\n  --stpGuard (string): The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard')\n  --linkNegotiation (string): The link speed for the switch port\n  --portScheduleId (string): The ID of the port schedule. A value of null will clear the port schedule.\n  --udld (string): The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.\n  --accessPolicyType (string): The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'\n  --accessPolicyNumber (integer): The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'\n  --macAllowList (array): Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'\n  --stickyMacAllowList (array): The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'\n  --stickyMacAllowListLimit (integer): The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'\n  --stormControlEnabled (boolean): The storm control status of the switch port\n  --flexibleStackingEnabled (boolean): For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.\n\nFunction Signature:\n  >>> def updateDeviceSwitchPort(serial: str, portId: str, **kwargs):\n\nRequired Arguments:\n  --serial STRING       (required)\n  --portId STRING       (required)\n\nMisc Arguments:\n  -h, --help            Show help for this command\n  --kwargs JSON_STRING  (Advanced Users) Optional arguments in JSON format\n~$\n~$\n```\n\nFor the `updateDeviceSwitchPort` command, you can see from the help page above that there are two required arguments: `--serial` and `--portId`. There are also many optional arguments like `--name`, `--tags`, `--enabled`, `--vlan`, etc. Each of the arguments has its value type listed in the help page.\n\nSimple value types like string, integer, and boolean are pretty straightforward. The can be provided like:\n- `--name \"Some Descriptive Name\"` (string)\n- `--vlan 100` (integer)\n- `--enabled true` (boolean)\n\nSometimes it is necessary to provide more complex values in certain arguments. An example from the `updateDeviceSwitchPort` command is the `--tags` argument. The `--tags` argument requires a list (array) of items. You can provide this list of items at the CLI using JSON formatting.\n\nThis will look like `--tags '[\"tag1\", \"tag2\"]'` on a Unix shell or `--tags \"[\"\"tag1\"\", \"\"tag2\"\"]\"` on Windows. This formatting provides a JSON-parsable structure to the CLI tool which is turned into native data and sent over the API to the dashboard. If you want to dive deeper into how to provide JSON data at the CLI, check out the [Using --kwargs](#using---kwargs) and [Dealing with --kwargs on Windows](#dealing-with---kwargs-on-windows) sections.\n\n> Note: Advanced users can use the `--kwargs` option to input all optional parameters as raw JSON data. Check out the [Using --kwargs](#using---kwargs) section for information on how to do that.\n\n\n## Tab Autocompletion\n\nMeraki-CLI v1.4.0 introduces tab autocompletion support on MacOS (zsh) and Linux (bash), and Windows 10 WSL using the Python [argcomplete](https://github.com/kislyuk/argcomplete) framework. Once you have installed Meraki-CLI, there are a few additional steps you need to take to enable autocompletion. See below for these steps.\n\nOnce tab autocompletion is functional, you will be able to hit the TAB key at any point in the command to see your options and/or complete a partial command. You are also able to set the `-h` switch at any point in the command and hit ENTER to see the help page for that specific command.\n\n### MacOS\n\nIf you are using the terminal on a modern version of MacOS, you are probably using zsh (\"z shell\") instead of bash, which is the standard for Linux distros. Use one of the two below options to enable autocompletion for your terminal:\n\n**Option 1 (Easy)**\n\n- Run the command `curl -fs https://raw.githubusercontent.com/PackeTsar/meraki-cli/master/.zprofile >> ~/.zprofile` to populate your zsh profile with the proper commands\n- Exit your terminal application and re-open it\n- Type `meraki` at the prompt and then hit the TAB key\n- You now should see all the arguments/switches/commands available to you\n\n**Option 2 (Manual)**\n\n- Open your zsh profile file with `nano ~/.zprofile`\n- Add the below text to the bottom of the file\n\n```\n# Tab Autocompletion for Meraki-CLI tool\nautoload bashcompinit\nbashcompinit\nautoload compinit\ncompinit -u\neval \"$(register-python-argcomplete meraki)\"\n# End of Meraki-CLI commands\n```\n\n- Once the text is added, press **CTRL-X**, hit the '**y**' key, and hit **ENTER** to save the changes to the file\n- Exit your terminal application and re-open it\n- Type `meraki` at the prompt and then hit the TAB key\n- You now should see all the arguments/switches/commands available to you\n\n### Linux\n\n- At your CLI terminal, run the command `activate-global-python-argcomplete`\n  - If you are using a Redhad distro like CentOS, also run the command `echo 'eval \"$(register-python-argcomplete meraki)\"' >> ~/.bash_profile`\n- Exit the terminal session and restart it (log out and back in if on SSH)\n- Type `meraki` at the prompt and then hit the TAB key\n- You now should see all the arguments/switches/commands available to you\n\n### Windows (10)\n\nA native installation of Meraki-CLI on Windows (where you use the Windows Command Prompt for the `meraki` commands) does not support tab autocompletion. There is, however, a workaround to this. If you're using a modern version of **Windows 10**, you can install the [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/about) (WSL) on your Windows 10 OS and then install Meraki-CLI on the WSL which will support tab autocompletion. This WSL installation is a native Windows feature and the process below should take you about 10 minutes.\n\n**NOTE**: Running WSL version 2 (which is now the default) requires virtualization features to be enabled in your PC's BIOS settings. The settings may be called VT-x, AMD-V, or SVM.\n\n- Open a Powershell window on your Windows 10 OS **as administrator** (right-click and then click \"Run as administrator\")\n- Run the command `wsl --install`\n- After installation you will be prompted to restart your OS, restart it\n- Once logged back in, you will see a window pop up saying it is installing\n- Once installation finishes, it will ask you for a user name and password. Go through these prompts to set up WSL\n- After setting it up, you will have a command prompt with something like `user@MYWIN10PC:~$`. Now we will perform a Linux Meraki-CLI installation\n- Run `sudo apt update` to pull the latest repository info\n- Run `sudo apt install python3-pip` to install the PIP Python package manager\n- Run `sudo pip3 install meraki-cli` to install the Meraki-CLI tool\n  - NOTE: We are running this as sudo on purpose. The autocomplete feature must be installed and activated at the global level\n- Once installation finishes, run the `meraki` command and make sure you see the help output\n- Exit the command window with `exit`\n- Reopen the WSL command window by finding the \"Ubuntu\" app in your start menu\n- Run the command `sudo activate-global-python-argcomplete` to activate the tab autocompletion feature\n  - Provide your WSL password when prompted\n  - You should just see the response \"Installing bash completion script /etc/bash_completion.d/python-argcomplete\"\n- Exit the command window with `exit` once again\n- Type `meraki` at the prompt and then hit the TAB key\n- You now should see all the arguments/switches/commands available to you\n\n**WSL Meraki-CLI Config File**\n\nIf you want to set up a config-file to store your Meraki dashboard API key, you will need to use the Linux file path by:\n\n- Creating the config file directory with `sudo mkdir /etc/meraki-cli`\n- Create the config file by opening the nano text editor with `sudo nano /etc/meraki-cli/meraki-cli.conf`\n- Drop in and modify the example config file text from the [Using a Config File](#using-a-config-file) section\n\n## Using a Config File\n\nIf you find yourself regularly entering the same arguments into the Meraki-CLI tool like your API key, debug level, logfile, etc, it might make sense to save those settings to a static config file in a permanent location.\n\nThe Meraki-CLI tool supports the use of a config file to provide any of its arguments. The config file should contain proper JSON syntax and should be a simple JS object (Python dictionary) in format. An example is shown below. If you want to use the arguments of a currently working command, set a maximum debug level of `-ddd` and copy/paste the JSON output under the \"Argument Settings\" log statement.\n\nThe config file can be obtained by the program by either explicitly defining its location using the `-c` option like `-c ~/meraki-cli.conf`, or by placing the file in a location searched by Meraki-CLI upon program start. The search locations are provided below and are sorted by common OS usage.\n\n- Windows OS\n  - `%APPDATA%\\meraki-cli\\meraki-cli.conf`\n    - The `%APPDATA%` is usually equal to `C:\\Users\\<username>\\AppData\\Roaming` by default\n    - Assuming the default, the config file location would be: `C:\\Users\\<username>\\AppData\\Roaming\\meraki-cli\\meraki-cli.conf`\n  - `%LOCALAPPDATA%\\meraki-cli\\meraki-cli.conf`\n    - The `%LOCALAPPDATA%` is usually equal to `C:\\Users\\<username>\\AppData\\Local` by default\n    - Assuming the default, the config file location would be: `C:\\Users\\<username>\\AppData\\Local\\meraki-cli\\meraki-cli.conf`\n- MacOS\n  - `~/.meraki-cli/meraki-cli.conf`\n    - The `~` directory is your local user directory. It is usually equal to `/Users/<username>/` by default\n    - Assuming the default, the config file location would be: `/Users/<username>/.meraki-cli/meraki-cli.conf`\n    - Note that the directory name has a leading dot, making it a hidden directory\n  - `~/Library/Application Support/meraki-cli/meraki-cli.conf`\n    - The `~` directory is your local user directory. It is usually equal to `/Users/<username>/` by default\n    - Assuming the default, the config file location would be: `/Users/<username>/Library/Application Support/meraki-cli/meraki-cli.conf`\n- Linux\n  - `/etc/meraki-cli/meraki-cli.conf`\n\n> Note: Any of the above locations except `/etc/meraki-cli/meraki-cli.conf` will work on any platform. The `APPDATA` and `LOCALAPPDATA` environment variables exist on Windows by default, but can be added to any machine. The two `~` (home) locations will resolve on both Windows or MacOS/Linux to a subdirectory inside the user's home directory.\n\n#### Example `meraki-cli.conf` Config File\n```\n{\n    \"apiKey\": \"6bec40cf957de430a6f1f2baa056b99a4fac9ea0\",\n    \"debug\": 1,\n    \"logfile\": \"meraki.log\"\n}\n```\n\n## Debugging and Logging\n\nIf you are having trouble figuring out why something is not working, you can set the debugging level to one of four levels:\n- Level 0 (default): Only warnings and errors will be displayed or logged\n- Level 1 (`-d`): General status and program progress will be reported\n- Level 2 (`-dd`): General program progress as well as Meraki API library debugging will be reported\n- Level 3 (`-ddd`): Program progress, Meraki API library debugging, and full data dumps will be reported\n\nIf you want to stow those logs away, you can define a log file using something like `-l logs.txt`. Only logs printed to the screen will be written to the file, so you also need to set a debugging level if you want to see anything other than just warnings and errors.\n\n\n## Filtering\n\nWhen multiple items are returned from your command, you can filter them by providing a column name (key) and a regular expression to use to match the item's columns value.\n\nFor example, you can view only enabled switch ports on a switch with:\n\n`meraki -f \"enabled:True\" switch getDeviceSwitchPortsStatuses --serial 1234-ABCD-5678`\n\nThe filter (`-f`) argument is reusable and you can use it multiple times to match based on more than one column. By default the filter uses \"OR\" logic when dealing with multiple filters. For example, the below command will show any enabled ports and any ports in VLAN 1000.\n\n`meraki -f \"enabled:True\" -f \"vlan:1000\" switch getDeviceSwitchPorts --serial 1234-ABCD-5678`\n\nIf you want to combine those filters so displayed items have to match both of them. Pass in the `-a` switch to change the filter logic to \"AND\" like:\n\n`meraki -f \"enabled:True\" -f \"vlan:1000\" -a switch getDeviceSwitchPorts --serial 1234-ABCD-5678`\n\n\n-----------------------------------------\n## Pipelining\n\nBeing able to manipulate the Meraki dashboard from the CLI can be quite useful, but its power grows exponentially when you are able to use pipelining. Pipelining allows you to pass the Meraki objects returned in one command into another and do something with them.\n\n> Note: When using pipelining, you will likely want to save your API key as an environment variable since it will need to be available to each instance of the program. Otherwise you would have to insert it multiple times like `meraki -k abcd1234 <commands> | meraki -k abcd1234 <commands>`.\n\nA simple example of this is to display the switch port statuses of the ports on all switches in a network. To do this use:\n\n`meraki networks getNetworkDevices --networkId N_12345 | meraki switch getDeviceSwitchPorts`\n\nThe above command can be interpreted the following way:\n- The first command (before the pipe) is retrieving and returning all network device objects in a network. Each device object will have a `serial` number attribute with it.\n- The pipe between the commands is sending the output of the first command into the input of the second.\n- The second command is taking each object in its input and retrieving that object's switch ports. Since the only argument required by the `getDeviceSwitchPorts` command is `--serial`, and the `serial` attribute is contained in each object coming from the first command, the second is able to use that information to loop through the input objects and execute the command on them.\n- This functionality should be recognizable to anybody familiar with common pipelining in Linux or PowerShell.\n\nIf you, for example, wanted to filter the output of the first command to only output MS250 model switches, you can use a filter in it like:\n\n`meraki -f 'model:MS250' networks getNetworkDevices --networkId N_12345 | meraki switch getDeviceSwitchPorts`\n\n\n### Overriding Values\n\nSometimes you want to use the output of one command to feed another, but you want to change something in the data before submitting it in that second command. You can do this by simply providing the changed argument in the command line of the second argument. For example:\n\n`meraki appliance getNetworkApplianceVlans --networkId N_11111 | meraki appliance createNetworkApplianceVlan --networkId N_22222`\n\nHere you are taking all of the configured appliance VLANs in network N_11111 and are pushing them into the `createNetworkApplianceVlan` to create new appliance VLANs. But first you are overriding the `--networkId` attribute of those VLAN objects so they are applied to a different network. You are effectively copying all appliance VLANs from one network to another.\n\n\n### Translations\n\nAt times the attribute names of objects output from one command do not exactly match the required input names of another, even though the actual data is the same. For example: the output of the `getNetworkApplianceVlans` command assigns VLAN ID numbers to the attribute name `id`, however the `deleteNetworkApplianceVlan` command requires the argument name `vlanId`. To deal with this we have to provide a translation using the `-t` argument. If you wanted to delete all the appliance VLANs configured on a network **NOT ADVISABLE**, you would need to provide a translation on the second instance like:\n\n`meraki appliance getNetworkApplianceVlans --networkId N_12345 | meraki -t \"vlanId=id\" appliance deleteNetworkApplianceVlan`\n\nThe `-t \"vlanId=id\"` argument is effectively telling the receiving program to use the `id` attributes of its input to fill the `vlanId` argument required by the `deleteNetworkApplianceVlan` command.\n\n\n### Outputting Commands\n\nIf you want to test out the power of pipelining, but don't necessarily want to have the commands executed automatically (in case you did something wrong), you can use the `-o` switch to output templatized commands instead. Using the `-o` switch in the receiving command will prevent actual execution, and instead will structure and display commands which will perform that execution; complete with arguments and values. The above command can be safely tested using the below:\n\n`meraki appliance getNetworkApplianceVlans --networkId N_12345 | meraki -o -t \"vlanId=id\" appliance deleteNetworkApplianceVlan`\n\n\n### How the Pipelining Works\n\nThe pipelining feature of the Meraki-CLI utility works by writing standard JSON data out to STDIN; the same data you see if you use the `-j` switch. All log messages are written to STDERR to prevent interference.\n\nWhen the program starts, it checks for a leading pipe (ie: `| meraki ...`): the existence of which would indicate that it needs to process STDIN data, which it then does.\n\nWhen the program processes results to be printed to the screen, it checks for a trailing pipe (ie: `meraki ... |`): the existence of which would indicate that its output will feed another program instance. When this is detected it automatically switches to JSON output and writes it to STDOUT.\n\n\n## ADVANCED USAGE\n\n\n### Using --kwargs\n\nSome Meraki-CLI commands require arguments to be provided which are not explicitly defined in the underlying function, but are documented in the command help page. An example of this is the `updateDeviceSwitchPort` command. You can see an example of this command's help page in the [Making Some Changes](#making-some-changes) section.\n\nIn the command help page you will see many argument options under the \"All Arguments\" section, but only two of them are listed in the \"Required Arguments\" section: `serial` and `portId`. Some of the other arguments in the documentation are things like `name`, `tags`, `enabled`, etc.\n\nWhen arguments are not listed in the \"Required Arguments\" or \"Misc Arguments\" sections of the command help page, they are considered to be Optional Arguments.\n\nOptional Arguments can be provided in one of two ways:\n1. Using regular CLI arguments like `--name \"Test Name\"` and `--vlan 100`\n2. Nested as JSON data inside the `--kwargs` argument like `--kwargs '{\"name\": \"Test Name\", \"vlan\": \"100\"}'`\n   - On Windows CLI, you have to use double-double quotes inside the data like `--kwargs \"{\"\"name\"\": \"\"Test Name\"\", \"\"vlan\"\": \"\"100\"\"}\"`\n\nWhen Optional Arguments are provided at the command-line (in either of the two ways), they are parsed into native data types and are included as `**kwargs` to the underlying target method when it is called.\n\nSome arguments cannot be simple data types, for example the `--tags` argument from the `updateDeviceSwitchPort` command. The `--tags` argument must be an array, not a simple string or integer. Again there are two ways you can provide this value:\n1. Use the `--tags` option and provide a JSON-parsable array like: `--tags '[\"first_tag\", \"second_tag\"]'`\n2. Use the `--kwargs` option to provide the nested JSON data like `--kwargs '{\"tags\": [\"first_tag\", \"second_tag\"]}'`\n\nBoth of these options will result in the same data being sent to the underlying target method.\n\n\n#### Dealing with --kwargs on Windows\n\nThe `--kwargs` data passed into Meraki-CLI is a JSON string and the JSON standard requires double-quotes in the data for quoting, it does not allow single-quotes. This becomes challenging on a standard Windows command prompt because Windows usually wants double-quotes used to encapsulate a string on the CLI.. So how do you use double quotes in the data and to encapsulate it?\n\nTo do this, use regular double-quotes in front of and behind the string to encapsulate it, and you use double-double-quotes in the actual data. That means replacing all uses of a double-quote characters in the data with two double-quotes. Your argument ends up looking like this: `--kwargs \"{\"\"name\"\": \"\"Data Port\"\", \"\"vlan\"\": \"\"100\"\"}\"`. It is probably easiest to use find/replace in a text editor to do this for you.\n\nYou can also structure the JSON data and your command a bit if you want to make your command more readable. In Windows, you can do this by ending each line with a carat (`^`) which will allow the command to continue on the next line. Your command in this example will look like:\n\n```\nmeraki switch updateDeviceSwitchPort --serial 1234-ABCD-5678 --portId 24 --kwargs ^\n\"{ ^\n    \"\"name\"\": \"\"Data Port\"\", ^\n    \"\"vlan\"\": \"\"100\"\", ^\n}\"\n```\n\n-----------------------------------------\n## CONTRIBUTING\n\nThis project is very new and has been created out of need. If you have a feature you would like to see built into it, please open up an issue in Github and describe your desired feature. Any accepted feature requests will be listed in the [Enhancement Requests and Known Bugs](https://github.com/PackeTsar/meraki-cli/issues/2) issue page.\n\nIf you find a need for a feature and you add it in yourself, or you fix a bug you found, please feel free to open up a merge request!\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/PackeTsar/meraki-cli",
    "keywords": "",
    "license": "GNU",
    "maintainer": "",
    "maintainer_email": "",
    "name": "meraki-cli",
    "package_url": "https://pypi.org/project/meraki-cli/",
    "platform": "",
    "project_url": "https://pypi.org/project/meraki-cli/",
    "project_urls": {
      "Homepage": "https://github.com/PackeTsar/meraki-cli"
    },
    "release_url": "https://pypi.org/project/meraki-cli/1.4.1/",
    "requires_dist": [
      "meraki (>=1.4.3)",
      "rich",
      "argcomplete",
      "jinja2",
      "jinja2 ; extra == 'dev'",
      "pytest ; extra == 'dev'",
      "coverage ; extra == 'dev'",
      "codecov ; extra == 'dev'",
      "pytest-flake8 ; extra == 'dev'",
      "requests-mock ; extra == 'dev'"
    ],
    "requires_python": "",
    "summary": "A Simple CLI tool to automate and control your Meraki Dashboard",
    "version": "1.4.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13029599,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a94660108d80c422c6a2f3d14f52ff5094234656ae2fcbe4761f982648bd86cb",
        "md5": "888773894de1ab75e09eeda6c06d83dc",
        "sha256": "fac885fbff83bc3fe632e5c0adfd324cd68522baf1d2df1cf6e17fee443c7867"
      },
      "downloads": -1,
      "filename": "meraki_cli-1.4.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "888773894de1ab75e09eeda6c06d83dc",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 47900,
      "upload_time": "2022-02-18T23:59:21",
      "upload_time_iso_8601": "2022-02-18T23:59:21.415994Z",
      "url": "https://files.pythonhosted.org/packages/a9/46/60108d80c422c6a2f3d14f52ff5094234656ae2fcbe4761f982648bd86cb/meraki_cli-1.4.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1bfe273e07ecfd9b4b9c95ca781d0d9a4c0d11ab4683012e55a6e701de65797c",
        "md5": "1f9c618d1074579a1e955af59e287909",
        "sha256": "53a6a29417a788ad53a690c36b978a2aadac27e055cf91c124f8334c01090055"
      },
      "downloads": -1,
      "filename": "meraki_cli-1.4.1.tar.gz",
      "has_sig": false,
      "md5_digest": "1f9c618d1074579a1e955af59e287909",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 59694,
      "upload_time": "2022-02-18T23:59:24",
      "upload_time_iso_8601": "2022-02-18T23:59:24.028700Z",
      "url": "https://files.pythonhosted.org/packages/1b/fe/273e07ecfd9b4b9c95ca781d0d9a4c0d11ab4683012e55a6e701de65797c/meraki_cli-1.4.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}