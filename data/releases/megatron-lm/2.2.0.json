{
  "info": {
    "author": "NVIDIA INC",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Environment :: Console",
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Scientific/Engineering :: Artificial Intelligence",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "[Megatron](https://arxiv.org/pdf/1909.08053.pdf) is a large, powerful transformer developed by the Applied Deep Learning Research team at NVIDIA. This repository is for ongoing research on training large transformer language models at scale. We developed efficient, model-parallel (tensor and pipeline), and multi-node pre-training of [GPT](https://arxiv.org/abs/2005.14165) and [BERT](https://arxiv.org/pdf/1810.04805.pdf) using mixed precision.\n\nBelow are some of the projects where we have directly used Megatron:\n* [BERT and GPT Studies Using Megatron](https://arxiv.org/pdf/1909.08053.pdf)\n* [BioMegatron: Larger Biomedical Domain Language Model](https://www.aclweb.org/anthology/2020.emnlp-main.379.pdf)\n* [End-to-End Training of Neural Retrievers for Open-Domain Question Answering](https://arxiv.org/abs/2101.00408)\n* [Large Scale Multi-Actor Generative Dialog Modeling](https://www.aclweb.org/anthology/2020.acl-main.8.pdf)\n* [Local Knowledge Powered Conversational Agents](https://arxiv.org/abs/2010.10150)\n* [MEGATRON-CNTRL: Controllable Story Generation with External Knowledge Using Large-Scale Language Models](https://www.aclweb.org/anthology/2020.emnlp-main.226.pdf)\n* [RACE Reading Comprehension Dataset Leaderboard](http://www.qizhexie.com/data/RACE_leaderboard.html)\n* [Training Question Answering Models From Synthetic Data](https://www.aclweb.org/anthology/2020.emnlp-main.468.pdf)\n\nOur codebase is capable of efficiently training very large (hundreds of billions of parameters) language models with both model and data parallelism. To demonstrate how the code scales with multiple GPUs and model sizes, we consider GPT models from 1 billion all the way to 1 trillion parameters. All models use a vocabulary size of 51,200 and a sequence length of 2048. We vary hidden size, number of attention heads, and number of layers to arrive at a specifc model size. As the model size increases, we also modestly increase the batch size. We leverage [NVIDIA's Selene supercomputer](https://www.top500.org/system/179842/) to perform scaling studies and use up to 3072 [A100](https://www.nvidia.com/en-us/data-center/a100/) GPUs for the largest model. The table below shows the model configurations along with the achieved FLOPs per second (both per GPU and aggregate over all GPUs). Note that the FLOPs are measured for end-to-end training, i.e., includes all operations including data loading, optimization, and even logging.\n\n![Cases](images/cases_jan2021.png)\n\nThe following figures show achieved percentage of theoretical peak FLOPs and achieved aggregate petaFLOPs per second as a function of number of GPUs. All the cases from 1 billion to 1 trillion achieve more than 41% half precision utilization, which is high for an end-to-end application. We observe that initially as the model parallel size increases, utilization slightly decreases; as hidden size increases for larger models, utilization starts increasing and reaches 49% for the largest model. We also note that achieved aggregate petaFLOPs per second across all GPUs increases almost linearly with number of GPUs, demonstrating good weak scaling.\n\n![Model Parallel Scaling](images/scaling.png)\n\n# Contents\n   * [Contents](#contents)\n   * [Setup](#setup)\n      * [Downloading Checkpoints](#downloading-checkpoints)\n   * [Usage](#usage)\n   * [Training](#training)\n      * [Data Preprocessing](#data-preprocessing)\n      * [BERT Pretraining](#bert-pretraining)\n      * [GPT Pretraining](#gpt-pretraining)\n      * [Distributed BERT or GPT Pretraining](#distributed-bert-or-gpt-pretraining)\n      * [GPT-3 Example](#gpt-3-example)\n   * [Evaluation and Tasks](#evaluation-and-tasks)\n      * [GPT Text Generation](#gpt-text-generation)\n      * [GPT Evaluation](#gpt-evaluation)\n         * [WikiText Perplexity Evaluation](#wikitext-perplexity-evaluation)\n         * [LAMBADA Cloze Accuracy](#lambada-cloze-accuracy)\n      * [BERT Task Evaluation](#bert-task-evaluation)\n         * [RACE Evaluation](#race-evaluation)\n         * [MNLI Evaluation](#mnli-evaluation)\n   * [Datasets](#datasets)\n      * [Collecting Wikipedia Training Data](#collecting-wikipedia-training-data)\n      * [Collecting GPT Webtext Data](#collecting-gpt-webtext-data)\n\n# Setup\nWe have tested Megatron with [NGC's PyTorch container](https://ngc.nvidia.com/catalog/containers/nvidia:pytorch) version 20.12, which uses python 3.8, pytorch 1.8, cuda 11.1, and nccl 2.8.3.\n\nTo use this repository, please install the latest supported versions of PyTorch with GPU support (python 3.8, pytorch 1.8, cuda 11.1, and nccl 2.8.3 and above) and NVIDIA [APEX](https://github.com/NVIDIA/apex#quick-start). We strongly recommend using one of [NGC's recent PyTorch containers](https://ngc.nvidia.com/catalog/containers/nvidia:pytorch) (the latest compatible version at time of publication can be pulled with `docker pull nvcr.io/nvidia/pytorch:20.12-py3`). Data preprocessing requires [NLTK](https://www.nltk.org/install.html), though this is not required for training, evaluation, or downstream tasks.\n\n<!--\nTo use megatron you can either clone the repo or install it via pip (make sure python3-dev is installed):\n<pre>\npip install megatron-lm\n</pre>\n-->\n\n## Downloading Checkpoints\nWe have provided pretrained [BERT-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_bert_345m) and [GPT-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_lm_345m) checkpoints for use to evaluate or finetuning downstream tasks. To access these checkpoints, first [sign up](https://ngc.nvidia.com/signup) for and [setup](https://ngc.nvidia.com/setup/installers/cli) the NVIDIA GPU Cloud (NGC) Registry CLI. Further documentation for downloading models can be found in the [NGC documentation](https://docs.nvidia.com/dgx/ngc-registry-cli-user-guide/index.html#topic_6_4_1).\n\nAlternatively, you can directly download the checkpoints using:\n\n<pre>\nBERT-345M-uncased: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_bert_345m/versions/v0.1_cased/zip -O megatron_bert_345m_v0.1_uncased.zip\nBERT-345M-cased: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_bert_345m/versions/v0.1_cased/zip -O megatron_bert_345m_v0.1_cased.zip\nGPT-345M: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_lm_345m/versions/v0.0/zip -O megatron_lm_345m_v0.0.zip\n</pre>\n\nThe models require vocabulary files to run. The BERT  WordPiece vocab file can be extracted from Google's pretrained BERT models: [uncased](https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt), [cased](https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt). The GPT [vocab file](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-vocab.json) and [merge table](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-merges.txt) can be downloaded directly. \n\n# Usage\n\nAfter installation, there are several possible workflows. The most comprehensive is:\n1. Data preprocessing\n2. Pretraining\n3. Finetuning (Optional for zero-shot tasks)\n4. Downstream task evaluation or text generation\n\nHowever, steps 1 and 2 can be replaced by using one of the pretrained models mentioned above.\n\nWe've provided several scripts for pretraining both BERT and GPT in [`examples`](./examples) directory, as well as scripts for both zero-shot and fine-tuned downstream tasks including MNLI, RACE, WikiText103, and LAMBADA evaluation. There is also a script for GPT interactive text generation.\n\n# Training\n## Data Preprocessing\nThe training data requires preprocessing. First, place your training data in a loose json format, with one json containing a text sample per line. For example:\n<pre>\n{\"src\": \"www.nvidia.com\", \"text\": \"The quick brown fox\", \"type\": \"Eng\", \"id\": \"0\", \"title\": \"First Part\"}\n{\"src\": \"The Internet\", \"text\": \"jumps over the lazy dog\", \"type\": \"Eng\", \"id\": \"42\", \"title\": \"Second Part\"}\n</pre>\n\nThe name of the `text` field of the json can be changed by using the `--json-key` flag in [`preprocess_data.py`](./tools/preprocess_data.py) The other metadata are optional and are not used in training.\n\nThe loose json is then processed into a binary format for training. To convert the json into mmap, cached index file, or the lazy loader format use `preprocess_data.py`. Set the `--dataset-impl` flag to `mmap`, `cached`, or `lazy`, respectively (default is `mmap`). An example script to prepare data for BERT training is:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-bert \\\n       --vocab bert-vocab.txt \\\n       --dataset-impl mmap \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --split-sentences\n</pre>\n\nThe output will be two files named, in this case, `my-bert_text_sentence.bin` and `my-bert_text_sentence.idx`. The `--data-path` specified in later BERT training is the full path and new filename, but without the file extension.\n\nSome minor modifications are required for GPT data preprocessing, namely, the addition of a merge table, an end-of-document token, removal of sentence splitting, and a change to the tokenizer type:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-gpt2 \\\n       --vocab gpt2-vocab.json \\\n       --dataset-impl mmap \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file gpt2-merges.txt \\\n       --append-eod\n</pre>\n\nHere the output files are named `my-gpt2_text_document.bin` and `my-gpt2_text_document.idx`. As before, in GPT training, use the longer name without the extension as `--data-path`.\n\nFurther command line arguments are described in the source file [`preprocess_data.py`](./tools/preprocess_data.py).\n\n## BERT Pretraining\n`bash examples/pretrain_bert.sh`\n\nThis script runs single GPU 345M parameter BERT pretraining. Debugging is the primary use for single GPU training, as the code base and command line arguments are optimized for highly distributed training. Most of the arguments are fairly self-explanatory. By default, the learning rate decays linearly over the training iterations starting at `--lr` to a minimum set by `--min-lr` over `--lr-decay-iters` iterations. The fraction of training iterations used for warmup is set by `--lr-warmup-fraction`. While this is single GPU training, the batch size specified by `--micro-batch-size` is a single forward-backward path batch-size and the code will perform gradient accumulation steps until it reaches `global-batch-size` whcih is the batch size per iteration. The data is partitioned into a 949:50:1 ratio for training/validation/test sets (default is 969:30:1). This partitioning happens on the fly, but is consistent across runs with the same random seed (1234 by default, or specified manually with `--seed`). We use `train-iters` as the training iterations requested. Alternatively, one can provide `--train-samples` which is total number of samples to train on. If this option is present, then instead of providing `--lr-decay-iters`, one will need to provide `--lr-decay-samples`.\n\nThe logging, checkpoint-saving, and evaluation intervals are specified. Checkpointing the activations facilitates the training of larger models and/or batches. Note that the `--data-path` now includes the additional `_text_sentence` suffix added in preprocessing, but does not include the file extensions.\n\n<pre>\nCHECKPOINT_PATH=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nDATA_PATH=my-bert_text_sentence\n\nBERT_ARGS=\"--num-layers 24 \\\n           --hidden-size 1024 \\\n           --num-attention-heads 16 \\\n           --seq-length 512 \\\n           --max-position-embeddings 512 \\\n           --lr 0.0001 \\\n           --lr-decay-iters 990000 \\\n           --train-iters 2000000 \\\n           --min-lr 0.00001 \\\n           --lr-warmup-fraction 0.01 \\\n\t   --micro-batch-size 4 \\\t   \n           --global-batch-size 8 \\\n           --vocab-file $VOCAB_FILE \\\n           --split 949,50,1 \\\n           --fp16\"\n\nOUTPUT_ARGS=\"--log-interval 10 \\\n             --save-interval 500 \\\n             --eval-interval 100 \\\n             --eval-iters 10 \\\n             --checkpoint-activations\"\n\npython pretrain_bert.py \\\n       $BERT_ARGS \\\n       $OUTPUT_ARGS \\\n       --save $CHECKPOINT_PATH \\\n       --load $CHECKPOINT_PATH \\\n       --data-path $DATA_PATH\n</pre>\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/arguments.py).\n\n\n## GPT Pretraining\n`bash examples/pretrain_gpt.sh`\n\nThis script runs single GPU 345M parameter GPT pretraining. As mentioned above, single GPU training is primarily intended for debugging purposes, as the code is optimized for distributed training.\n\nIt follows largely the same format as the previous BERT script with a few notable differences: the tokenization scheme used is BPE (which requires a merge table and a `json` vocabulary file) instead of WordPiece, the model architecture allows for longer sequences (note that the max position embedding must be greater than or equal to the maximum sequence length), and the `--lr-decay-style` has been set to cosine decay.  Note that the `--data-path` now includes the additional `_text_document` suffix added in preprocessing, but does not include the file extensions.\n\n<pre>\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nDATA_PATH=my-gpt2_text_document\n\nGPT_ARGS=\"--num-layers 24 \\\n          --hidden-size 1024 \\\n          --num-attention-heads 16 \\\n          --seq-length 1024 \\\n          --max-position-embeddings 1024 \\\n          --micro-batch-size 4 \\\n          --global-batch-size 8 \\\n          --lr 0.00015 \\\n          --train-iters 500000 \\\n          --lr-decay-iters 320000 \\\n          --lr-decay-style cosine \\\n          --vocab-file $VOCAB_FILE \\\n          --merge-file $MERGE_FILE \\\n          --lr-warmup-fraction .01 \\\n          --fp16\"\n\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython pretrain_gpt.py \\\n       $GPT_ARGS \\\n       $OUTPUT_ARGS \\\n       --save $CHECKPOINT_PATH \\\n       --load $CHECKPOINT_PATH \\\n       --data-path $DATA_PATH \\\n</pre>\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/arguments.py).\n\n## Distributed BERT or GPT Pretraining\n`bash examples/pretrain_bert_distributed.sh`\n\n`bash examples/pretrain_gpt_distributed.sh`\n\nThese scripts use the PyTorch distributed launcher for distributed training. As such, multi-node training can be achieved by properly setting environment variables and using `init_method='env://'` in the launcher. See the official PyTorch [documentation](https://pytorch.org/docs/stable/distributed.html#launch-utility) for further description of these [environment variables](https://pytorch.org/docs/stable/distributed.html#environment-variable-initialization). By default, multi-node training uses the [nccl](https://developer.nvidia.com/nccl) distributed backend. A simple set of additional arguments and the use of the PyTorch distributed module with the Python flag `-m torch.distributed.launch`, detailed below, are the only additional requirements to adopt distributed training.\n\nWe use two types of parallelism: data and model parallelism. We facilitate two distributed data parallel implementations: a simple one of our own that performs gradient all-reduce at the end of back propagation step, and Torch's distributed data parallel wrapper that overlaps gradient reduction with back propagation computation. To switch between these two options use `--DDP-impl local` or `--DDP-impl torch`, respectively. As expected, Torch distributed data parallelism is more efficient at larger model sizes. For example, for the 8.3 billion parameters model running on 512 GPUs, the scaling increases from 60% to 76% when Torch's distributed data parallel is used. However, the overlapping method requires more memory and for some configurations (e.g., 2.5 billion parameters using 2-way model parallel and 1.2 billion parameters with no model parallel) can make the overall training slower as a result. We empirically found that using a smaller model in those cases improves the training time.\n\nSecond, we developed a simple and efficient two-dimensional model-parallel approach. To use tensor model parallelism (splitting execution of a single transformer module over multiple GPUs), add the `--tensor-model-parallel-size` flag to specify the number of GPUs among which to split the model, along with the arguments passed to the distributed launcher as mentioned above. To use pipeline model parallelism (sharding the transformer modules into stages with an equal number of transformer modules on each stage, and then pipelining execution by breaking the batch into smaller microbatches), use the `--pipeline-model-parallel-size` flag to specify the number of stages to split the model into (e.g., splitting a model with 24 transformer layers across 4 stages would mean each stage gets 6 transformer layers each).\n\n<!-- The number of microbatches in a per-pipeline minibatch is controlled by the `--num-microbatches-in-minibatch` argument. With `WORLD_SIZE` GPUs, `TENSOR_MP_SIZE` tensor-model-parallel size, `PIPELINE_MP_SIZE` pipeline-model-parallel-size, `WORLD_SIZE`/(`TENSOR_MP_SIZE` * `PIPELINE_MP_SIZE`) GPUs will be used for data parallelism. The default values for `--tensor-model-parallel-size` and `--pipeline-model-parallel-size` is 1, which will not implement either form of model parallelism. -->\n\nWe have examples of how to use these two different forms of model parallelism in these scripts:\n\n`bash examples/pretrain_bert_distributed_with_mp.sh`\n\n`bash examples/pretrain_gpt_distributed_with_mp.sh`\n\nOther than these minor changes, the distributed training is identical to the training on a single GPU.\n\nDistributed BERT training:\n<pre>\nWORLD_SIZE=8\nMP_SIZE=2\n\nDISTRIBUTED_ARGS=\"--nproc_per_node $WORLD_SIZE \\\n                  --nnodes 1 \\\n                  --node_rank 0 \\\n                  --master_addr localhost \\\n                  --master_port 6000\"\n\nCHECKPOINT_PATH=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nDATA_PATH=my-bert_text_sentence\nBERT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython -m torch.distributed.launch $DISTRIBUTED_ARGS ./pretrain_bert.py \\\n                $BERT_ARGS \\\n                $OUTPUT_ARGS \\\n                --save $CHECKPOINT_PATH \\\n                --load $CHECKPOINT_PATH \\\n                --data-path $DATA_PATH \\\n                --tensor-model-parallel-size $MP_SIZE \\\n                --DDP-impl torch\n</pre>\n\nDistributed GPT training:\n<pre>\nWORLD_SIZE=8\nMP_SIZE=2\n\nDISTRIBUTED_ARGS=&#60;same as those directly above&#62;\n\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nDATA_PATH=my-gpt2_text_document\nGPT_ARGS=&#60;same as those in <a href=\"#gpt-pretraining\">GPT pretraining</a> above&#62;\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython -m torch.distributed.launch $DISTRIBUTED_ARGS ./pretrain_gpt.py \\\n                $GPT_ARGS \\\n                $OUTPUT_ARGS \\\n                --save $CHECKPOINT_PATH \\\n                --load $CHECKPOINT_PATH \\\n                --data-path $DATA_PATH \\\n                --tensor-model-parallel-size $MP_SIZE \\\n                --DDP-impl torch\n\n</pre>\n\n## GPT-3 Example\n`bash examples/pretrain_gpt3_175B.sh`\n\nWe have provided an example of how to configure Megatron to run [GPT-3](https://arxiv.org/abs/2005.14165) with 175 billion parameters on 1024 GPUs. The script is designed for [slurm](https://slurm.schedmd.com/documentation.html) with [pyxis](https://github.com/NVIDIA/pyxis) plugin but can be easily adopted to any other scheduler. It uses 8-way and 16-way tensor and pipeline parallelism, respectively. With options `global-batch-size 1536` and `rampup-batch-size 16 16 5859375`, the training will start with global batch size 16 and linearly increase the global batch size to 1536 over 5,859,375 samples with incrmeental steps 16. The training dataset can be either a single set or a multiple datasets combined with a set of weights.\n\nWith full global batch size of 1536 on 1024 A100 GPUs, each iteration takes around 32 seconds resulting in 138 teraFLOPs per GPU which is 44% of the theoretical peak FLOPs.\n\n\n<!--\n## REALM Pipeline\nWe are working on implementing the [REALM](https://arxiv.org/pdf/2002.08909.pdf) system. The following sections (will) reflect the three stages of training it. For now it's just the ICT code.\nLoosely, they are pretraining the retriever modules, then jointly training the language model and the retriever, and then finetuning a question answering head on the language model with fixed retriever.\n\n### Inverse Cloze Task (ICT) Pretraining\n1. Have a corpus in loose JSON format with the intention of creating a collection of fixed-size blocks of text as the fundamental units of data. For a corpus like Wikipedia, this will mean multiple sentences per block but also multiple blocks per document.\nRun `tools/preprocess_data.py` to construct one or more indexed datasets with the `--split-sentences` argument to make sentences the basic unit. For the original REALM system, we construct two datasets, one with the title of every document, and another with the body.\nRefer to the following script\n<pre>\npython preprocess_data.py \\\n    --input /path/to/corpus.json \\\n    --json-keys text title \\\n    --split-sentences \\\n    --tokenizer-type BertWordPieceLowerCase \\\n    --vocab-file /path/to/vocab.txt \\\n    --output-prefix corpus_indexed \\\n    --workers 5  # works well for 10 CPU cores. Scale up accordingly.\n</pre>\n\n2. Use a custom samples mapping function in place of `megatron/data/realm_dataset_utils.get_block_samples_mapping` if required. To do this, you will need to implement a new function in C++ inside of `megatron/data/helpers.cpp`. The samples mapping data structure is used to select the data that will constitute every training sample in advance of the training loop.\n The samples mapping is responsible for holding all of the required metadata needed to construct the sample from one or more indexed datasets. In REALM, the samples mapping contains the start and end sentence indices, as well as the document index (to find the correct title for a body) and a unique ID for every block.\n3. Pretrain a BERT language model using `pretrain_bert.py`, with the sequence length equal to the block size in token ids. This model should be trained on the same indexed dataset that is used to supply the blocks for the information retrieval task.\nIn REALM, this is an uncased bert base model trained with the standard hyperparameters.\n4. Use `pretrain_ict.py` to train an `ICTBertModel` which uses two BERT-based encoders to encode queries and blocks to perform retrieval with.\nThe script below trains the ICT model from REALM. It refrences a pretrained BERT model (step 3) in the `--bert-load` argument. The batch size used in the paper is 4096, so this would need to be run with data parallel world size 32.\n<pre>\npython pretrain_ict.py \\\n    --num-layers 12 \\\n    --num-attention-heads 12 \\\n    --hidden-size 768 \\\n    --batch-size 128 \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-head-size 128 \\\n    --train-iters 100000 \\\n    --checkpoint-activations \\\n    --bert-load /path/to/pretrained_bert \\\n    --load checkpoints \\\n    --save checkpoints \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --vocab-file /path/to/vocab.txt \\\n    --lr 0.0001 \\\n    --num-workers 2 \\\n    --lr-decay-style linear \\\n    --weight-decay 1e-2 \\\n    --clip-grad 1.0 \\\n    --lr-warmup-fraction .01 \\\n    --save-interval 3000 \\\n    --query-in-block-prob 0.1 \\\n    --fp16\n\n</pre>\n\n### Building an Index of Block Embeddings\nAfter having trained an ICT model, you can now embed an entire dataset of blocks by creating a `BlockData` structure. After that has been saved, you can load it\nand wrap it with a `FaissMIPSIndex` to do fast similarity search which is key in the learned information retrieval pipeline. The initial index can be built with the following script, meant to be run in an interactive session. It can leverage multiple GPUs on multiple nodes to index large datasets much more quickly.\n\n<pre>\npython tools/create_doc_index.py \\\n    --num-layers 12 \\\n    --hidden-size 768 \\\n    --ict-head-size 128 \\\n    --num-attention-heads 12 \\\n    --batch-size 128 \\\n    --checkpoint-activations \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-load /path/to/pretrained_ict \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --block-data-path embedded_blocks.pkl \\\n    --indexer-log-interval 1000 \\\n    --indexer-batch-size 128 \\\n    --vocab-file /path/to/vocab.txt \\\n    --num-workers 2 \\\n    --fp16\n</pre>\n\n-->\n\n# Evaluation and Tasks\n\nWe provide several command line arguments, detailed in the scripts listed below, to handle various zero-shot and fine-tuned downstream tasks. However, you can also finetune your model from a pretrained checkpoint on other corpora as desired. To do so, simply add the `--finetune` flag and adjust the input files and training parameters within the original training script. The iteration count will be reset to zero, and the optimizer and internal state will be reinitialized. If the fine-tuning is interrupted for any reason, be sure to remove the `--finetune` flag before continuing, otherwise the training will start again from the beginning.\n\n<!--\nBecause evaluation requires substantially less memory than training, it may be advantageous to merge a model trained in parallel for use on a single GPU in downstream tasks. The following script accomplishes this.\n\n<pre>\nTENSOR_MODEL_PARALLEL_SIZE=2\n\nVOCAB_FILE=bert-vocab.txt\nCHECKPOINT_PATH=checkpoints/bert_345m\n\nWORLD_SIZE=$TENSOR_MODEL_PARALLEL_SIZE python tools/merge_mp_partitions.py \\\n        --model-type BERT \\\n        --tensor-model-parallel-size $TENSOR_MODEL_PARALLEL_SIZE \\\n        --tokenizer-type BertWordPieceLowerCase \\\n        --vocab-file $VOCAB_FILE \\\n        --num-layers 24 \\\n        --hidden-size 1024 \\\n        --num-attention-heads 16 \\\n        --seq-length 512 \\\n        --max-position-embeddings 512 \\\n        --load $CHECKPOINT_PATH\n\n</pre>\n-->\nSeveral downstream tasks are described for both GPT and BERT models below. They can be run in distributed and model parallel modes with the same changes used in the training scripts.\n\n## GPT Text Generation\n`bash examples/generate_text.sh`\n\nWe generate text samples using largely the GPT pretraining script. Few changes need to make, such as we need to provide the path to the pretrained checkpoint, the length of the output samples, whether to generate texts unconditionally (`--num-samples` to denote how many samples to generate) or conditional (need to pass `--sample-input-file <filename>` where each line of the file will be used as the conditional texts). There are few optional parameters to play, e.g. `top-k`, `top-p`, or `greedy` (set top-k and top-p to 0) sampling..\n\n<pre>\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nGPT_ARGS=&#60;same as those in <a href=\"#gpt-pretraining\">GPT pretraining</a> above&#62;\n\nMAX_OUTPUT_SEQUENCE_LENGTH=1024\nTEMPERATURE=1.0\nTOP_P=0.9\nNUMBER_OF_SAMPLES=2\nOUTPUT_FILE=samples.json\n\npython tools/generate_samples_gpt.py \\\n       $GPT_ARGS \\\n       --load $CHECKPOINT_PATH \\\n       --out-seq-length $MAX_OUTPUT_SEQUENCE_LENGTH \\\n       --temperature $TEMPERATURE \\\n       --genfile $OUTPUT_FILE \\\n       --num-samples $NUMBER_OF_SAMPLES \\\n       --top_p $TOP_P \\\n       --recompute\n</pre>\n\n## GPT Evaluation\nWe include example scripts for GPT evaluation on WikiText perplexity evaluation and LAMBADA Cloze accuracy.\n\n### WikiText Perplexity Evaluation\nFor even comparison with prior works, we evaluate perplexity on the word-level [WikiText-103 test dataset](https://s3.amazonaws.com/research.metamind.io/wikitext/wikitext-103-v1.zip), and appropriately compute perplexity given the change in tokens when using our subword tokenizer.\n\nWe use the following command to run WikiText-103 evaluation on a 345M parameter model.\n<pre>\nTASK=\"WIKITEXT103\"\n\nVALID_DATA=&#60;wikitext path&#62;.txt\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\n\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 1024 \\\n                  --max-position-embeddings 1024 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --micro-batch-size 8 \\\n       --checkpoint-activations \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\n\n### LAMBADA Cloze Accuracy\nTo compute LAMBADA cloze accuracy (the accuracy of predicting the last token given the preceeding tokens) we utilize a detokenized, processed version of the [LAMBADA dataset](https://github.com/cybertronai/bflm/blob/master/lambada_test.jsonl).\n\nWe use the following command to run LAMBADA evaluation on a 345M parameter model. Note that the `--strict-lambada` flag should be used to require whole word matching. Make that `lambada` is part of the file path.\n\n<pre>\nTASK=\"LAMBADA\"\n\nVALID_DATA=&#60;lambada path&#62;.json\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#wikitext-perplexity-evaluation\">WikiText Perplexity Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --strict-lambada \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --micro-batch-size 8 \\\n       --checkpoint-activations \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\nFurther command line arguments are described in the source file [`main.py`](./tasks/main.py)\n\n## BERT Task Evaluation\n### RACE Evaluation\nThe following script finetunes the BERT model for evaluation on the [RACE dataset](http://www.cs.cmu.edu/~glai1/data/race/). The `TRAIN_DATA` and `VALID_DATA` directory contain the RACE dataset as separate `.txt` files. Note that for RACE, the batch size is the number of RACE query's to evaluate. Since each RACE query has four samples, the effective batch size passed through the model will be four times the batch size specified on the command line.\n\n<pre>\nTRAIN_DATA=\"data/RACE/train/middle\"\nVALID_DATA=\"data/RACE/dev/middle \\\n            data/RACE/dev/high\"\nVOCAB_FILE=bert-vocab.txt\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nCHECKPOINT_PATH=checkpoints/bert_345m_race\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 512 \\\n                  --max-position-embeddings 512 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\nCOMMON_TASK_ARGS_EXT=\"--train-data $TRAIN_DATA \\\n                      --valid-data $VALID_DATA \\\n                      --pretrained-checkpoint $PRETRAINED_CHECKPOINT \\\n                      --checkpoint-activations \\\n                      --save-interval 10000 \\\n                      --save $CHECKPOINT_PATH \\\n                      --log-interval 100 \\\n                      --eval-interval 1000 \\\n                      --eval-iters 10 \\\n                      --weight-decay 1.0e-1\"\n\npython tasks/main.py \\\n       --task RACE \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 3 \\\n       --micro-batch-size 4 \\\n       --lr 1.0e-5 \\\n       --lr-warmup-fraction 0.06\n</pre>\n\n### MNLI Evaluation\nThe following script finetunes the BERT model for evaluation with the [MultiNLI sentence pair corpus](https://www.nyu.edu/projects/bowman/multinli/). Because the matching tasks are quite similar, the script can be quickly tweaked to work with the [Quora Question Pairs](https://www.kaggle.com/quora/question-pairs-dataset) (QQP) dataset as well.\n\n<pre>\n\nTRAIN_DATA=\"data/glue_data/MNLI/train.tsv\"\nVALID_DATA=\"data/glue_data/MNLI/dev_matched.tsv \\\n            data/glue_data/MNLI/dev_mismatched.tsv\"\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nCHECKPOINT_PATH=checkpoints/bert_345m_mnli\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\nCOMMON_TASK_ARGS_EXT=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task MNLI \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 5 \\\n       --micro-batch-size 8 \\\n       --lr 5.0e-5 \\\n       --lr-warmup-fraction 0.065\n</pre>\n\n# Datasets\nWe do not host any datasets for GPT or BERT training, however, we detail their collection so that our results may be reproduced.\n\n## Collecting Wikipedia Training Data\nWe recommend following the Wikipedia data extraction process specified by Google research: \"the recommended pre-processing is to download [the latest dump](https://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles.xml.bz2), extract the text with [WikiExtractor.py](https://github.com/attardi/wikiextractor), and then apply any necessary cleanup to convert it into plain text.\"\n\nWe recommend using the `--json` argument when using WikiExtractor, which will dump the Wikipedia data into loose json format (one json per line), making it more manageable on the file system and also readily consumable by our codebase. We recommend further preprocessing this json dataset by nltk punctuation standardization. For BERT training, use the `--split-sentences` flag to `preprocess_data.py` as described [above](#data-preprocessing) to include sentence breaks in the produced index. If you'd like to use Wikipedia data for GPT training you should still clean it with nltk/spacy/ftfy, but do not use the `--split-sentences` flag.\n\n## Collecting GPT Webtext Data\nWe utilize the publicly available [OpenWebText](https://github.com/eukaryote31/openwebtext) library from [jcpeterson](https://github.com/jcpeterson/openwebtext) and [eukaryote31's](https://github.com/eukaryote31/openwebtext) work to download urls. We then filtered, cleaned, and deduplicated all downloaded content according to the procedure described in our [openwebtext](./tools/openwebtext) directory. For reddit URLs corresponding to content up to October 2018 we arrived at approximately 37GB of content.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/NVIDIA/Megatron-LM",
    "keywords": "deep learning,Megatron,gpu,NLP,nvidia,pytorch,torch,language",
    "license": "See https://github.com/NVIDIA/Megatron-LM/blob/master/LICENSE",
    "maintainer": "NVIDIA INC",
    "maintainer_email": "",
    "name": "megatron-lm",
    "package_url": "https://pypi.org/project/megatron-lm/",
    "platform": "",
    "project_url": "https://pypi.org/project/megatron-lm/",
    "project_urls": {
      "Homepage": "https://github.com/NVIDIA/Megatron-LM"
    },
    "release_url": "https://pypi.org/project/megatron-lm/2.2.0/",
    "requires_dist": [
      "pybind11",
      "torch",
      "six",
      "regex",
      "numpy"
    ],
    "requires_python": ">=3.6",
    "summary": "Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism.",
    "version": "2.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9848750,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bfe3a849a41c073bae8b14584be5b6a4ca1da95af2ad127ee089acc66ec78921",
        "md5": "3be2bddd81b71dfc5496bc46d0048510",
        "sha256": "3bf74cb0448099a06360cb339012ac3c304a391877980a87069a99b37e157457"
      },
      "downloads": -1,
      "filename": "megatron_lm-2.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "3be2bddd81b71dfc5496bc46d0048510",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 171139,
      "upload_time": "2021-03-22T21:41:23",
      "upload_time_iso_8601": "2021-03-22T21:41:23.142198Z",
      "url": "https://files.pythonhosted.org/packages/bf/e3/a849a41c073bae8b14584be5b6a4ca1da95af2ad127ee089acc66ec78921/megatron_lm-2.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3a1945d15d0e209d926c22f0d03547763f19f356bbaf6f6c1fa6e03f9e844391",
        "md5": "7785ee68c89dcd2eb67850ca0c18324d",
        "sha256": "470c78802bfe6fd5dcf0f590614a54992c00cceaa9a57cb9c8720f939926f63e"
      },
      "downloads": -1,
      "filename": "megatron-lm-2.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "7785ee68c89dcd2eb67850ca0c18324d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 141755,
      "upload_time": "2021-03-22T21:41:24",
      "upload_time_iso_8601": "2021-03-22T21:41:24.683806Z",
      "url": "https://files.pythonhosted.org/packages/3a/19/45d15d0e209d926c22f0d03547763f19f356bbaf6f6c1fa6e03f9e844391/megatron-lm-2.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}