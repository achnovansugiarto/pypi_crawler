{
  "info": {
    "author": "NVIDIA INC",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Environment :: Console",
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Scientific/Engineering :: Artificial Intelligence",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "[Megatron](https://arxiv.org/pdf/1909.08053.pdf) is a large, powerful transformer developed by the Applied Deep Learning Research team at NVIDIA. This repository is for ongoing research on training large transformer language models at scale. We developed efficient, model-parallel, and multinode training of [GPT-2](https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf) and [BERT](https://arxiv.org/pdf/1810.04805.pdf) using mixed precision.\n\nOur codebase is capable of efficiently training a 72-layer, 8.3 billion parameter GPT-2 language model with 8-way model and 64-way data parallelism across 512 GPUs. We sustain 15.1 PetaFLOPs across the entire application with 76% scaling efficiency when compared to a strong single GPU baseline that sustains 39 TeraFLOPs, which is 30% of peak theoritical FLOPs. Using our GPT-2 model we achieve SOTA results on the WikiText-103 (10.8 compared to SOTA perplexity of 15.8) and LAMBADA (66.5% compared to SOTA accuracy of 63.2%) datasets. \n\nFor BERT training, we swapped the position of the layer normalization and the residual connection in the model architecture (similar to GPT-2 architucture), which allowed the models to continue to improve as they were scaled up. Our BERT models with 3.9 billion parameters reaches a loss of 1.16, SQuAD 2.0 F1-score of 91.7, and RACE accuracy of 90.9%.\n\n<a id=\"contents\"></a>\n# Contents\n<!-- MarkdownTOC -->\n\n- [Setup](#setup)\n  - [Downloading Checkpoints](#downloading-checkpoints)\n- [Usage](#usage)\n- [Training](#training)\n  - [Data Preprocessing](#data-preprocessing)\n  - [BERT Pretraining](#bert-pretraining)\n  - [GPT-2 Pretraining](#gpt-2-pretraining)\n  - [Distributed BERT or GPT-2 Pretraining](#distributed-bert-or-gpt-2-pretraining)\n- [REALM Pipeline](#realm)\n- [Evaluation and Tasks](#evaluation-and-tasks)\n  - [GPT-2 Text Generation](#gpt-2-text-generation)\n  - [GPT-2 Evaluation](#gpt-2-evaluation)\n    - [WikiText Perplexity Evaluation](#wikitext-perplexity-evaluation)\n    - [LAMBADA Cloze Accuracy](#lambada-cloze-accuracy)\n  - [BERT Task Evaluation](#bert-task-evaluation)\n    - [RACE Evaluation](#race-evaluation)\n    - [MNLI Evaluation](#mnli-evaluation)\n- [Datasets](#datasets)\n  - [Collecting Wikipedia Training Data](#collecting-wikipedia-training-data)\n  - [Collecting GPT-2 Webtext Data](#collecting-gpt-2-webtext-data)\n\n<!-- /MarkdownTOC -->\n\n<a id=\"setup\"></a>\n# Setup\nWe officially support only python 3.6, pytorch 1.5, cuda 10, and nccl 2.6 versions and above.\n\nTo use this repo please install the latest supported versions of PyTorch with GPU support and NVIDIA [APEX](https://github.com/NVIDIA/apex#quick-start). We strongly recommend using one of [NGC's recent PyTorch containers](https://ngc.nvidia.com/catalog/containers/nvidia:pytorch) (the latest compatible version at time of publication can be pulled with `docker pull nvcr.io/nvidia/pytorch:20.03-py3`). Data preprocessing requires [NLTK](https://www.nltk.org/install.html), though this is not required for training, evaluation or downstream tasks.\n\nTo use megatron you can either clone the repo or install it via pip (make sure python3-dev is installed):\n<pre>\npip install megatron-lm\n</pre>\n\n<a id=\"downloading-checkpoints\"></a>\n## Downloading Checkpoints\nWe've provided two pretrained checkpoints for use to evaluate or finetuning downstream tasks. To access these checkpoints, first please [sign up](https://ngc.nvidia.com/signup) for and [setup](https://ngc.nvidia.com/setup/installers/cli) the NVIDIA GPU Cloud (NGC) Registry CLI.\n\nThe checkpoints can be downloaded with:\n<pre>\nngc registry model download-version --dest &#60;output_base_directory&#62; nvidia/&#60;model_name&#62;:&#60;version&#62;\n</pre>\n\nThe available models along with `<model_name>:<version>` are below:\n* [BERT-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_bert_345m): megatron\\_bert\\_345m:v0.0\n* [GPT-2-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_lm_345m): megatron\\_lm\\_345m:v0.0 \n\nThe models require vocabulary files to run. The BERT uncased WordPiece vocab file can be extracted from Google's [pretrained BERT models](https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt). The GPT-2 [vocab file](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-vocab.json) and [merge table](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-merges.txt) can be downloaded directly.\n\nFurther documentation for downloading models can be found in the [NGC documentation](https://docs.nvidia.com/dgx/ngc-registry-cli-user-guide/index.html#topic_6_4_1)\n\n<a id=\"usage\"></a>\n# Usage\n\nAfter installation, there are several possible workflows. The most comprehensive is:\n1. Data preprocessing\n2. Pretraining\n3. Finetuning (Optional for zero-shot tasks)\n4. Downstream task evaluation or text generation\n\nHowever, steps 1 and 2 can be replaced by using one of the pretrained models mentioned above.\n\nWe've provided several scripts for pretraining both BERT and GPT-2 in [`examples`](./examples) directory, as well as scripts for both zero-shot and fine-tuned downstream tasks including MNLI, RACE, WikiText103, and LAMBADA evaluation. There is also a script for GPT-2 interactive text generation.\n\n<a id=\"training\"></a>\n# Training\n<a id=\"data-preprocessing\"></a>\n## Data Preprocessing\nWe support three file formats for training, but all require preprocessing. First, place your training data in a loose json format, with one json containing a text sample per line. For example:\n<pre>\n{\"src\": \"www.nvidia.com\", \"text\": \"The quick brown fox\", \"type\": \"Eng\", \"id\": \"0\", \"title\": \"First Part\"}\n{\"src\": \"The Internet\", \"text\": \"jumps over the lazy dog\", \"type\": \"Eng\", \"id\": \"42\", \"title\": \"Second Part\"}\n</pre>\n\nThe name of the `text` field of the json can be changed by using the `--json-key` flag in [`preprocess_data.py`](./tools/preprocess_data.py) The other metadata are optional and are not used in training.\n\nThe loose json is then processed into a binary format for training. To convert the json into mmap, cached index file, or the lazy loader format use `preprocess_data.py`. Set the `--dataset-impl` flag to `mmap`, `cached`, or `lazy`, respectively (default is `mmap`). An example script to prepare data for BERT training is:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-bert \\\n       --vocab bert-vocab.txt \\\n       --dataset-impl mmap \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --split-sentences\n</pre>\n\nThe output will be two files named, in this case, `my-bert_text_sentence.bin` and `my-bert_text_sentence.idx`. The `--data-path` specified in later BERT training is the full path and new filename, but without the file extension.\n\nSome minor modifications are required for GPT-2 data preprocessing, namely, the addition of a merge table, an end-of-document token, removal of sentence splitting, and a change to the tokenizer type:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-gpt2 \\\n       --vocab gpt2-vocab.json \\\n       --dataset-impl mmap \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file gpt2-merges.txt \\\n       --append-eod\n</pre>\n\nHere the output files are named `my-gpt2_text_document.bin` and `my-gpt2_text_document.idx`. As before, in GPT-2 training, use the longer name without the extension as `--data-path`.\n\nFurther command line arguments are described in the source file [`preprocess_data.py`](./tools/preprocess_data.py).\n\n<a id=\"bert-pretraining\"></a>\n## BERT Pretraining\n`bash examples/pretrain_bert.sh`\n\nThis script runs single GPU 345M parameter BERT pretraining. Debugging is the primary use for single GPU training, as the code base and command line arguments are optimized for highly distributed training. Most of the arguments are fairly self-explanatory. By default, the learning rate decays linearly over the training iterations starting at `--lr` to a minimum set by `--min-lr` over `--lr-decay-iters` iterations. The fraction of training iterations used for warmup is set by `--warmup`. While this is single GPU training, the batch size specified by `--batch-size` is per GPU used for data parallelism. The data is partitioned into a 949:50:1 ratio for training/validation/test sets (default is 969:30:1). This partitioning happens on the fly, but is consistent across runs with the same random seed (1234 by default, or specified manually with `--seed`).\n\nThe logging, checkpoint-saving, and evaluation intervals are specified. Checkpointing the activations facilitates the training of larger models and/or batches. Note that the `--data-path` now includes the additional `_text_sentence` suffix added in preprocessing, but does not include the file extensions.\n\n<pre>\nCHECKPOINT_PATH=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nDATA_PATH=my-bert_text_sentence\n\nBERT_ARGS=\"--num-layers 24 \\\n           --hidden-size 1024 \\\n           --num-attention-heads 16 \\\n           --seq-length 512 \\\n           --max-position-embeddings 512 \\\n           --lr 0.0001 \\\n           --train-iters 2000000 \\\n           --min-lr 0.00001 \\\n           --lr-decay-iters 990000 \\\n           --warmup 0.01 \\\n           --batch-size 8 \\\n           --vocab-file $VOCAB_FILE \\\n           --split 949,50,1 \\\n           --fp16\"\n\nOUTPUT_ARGS=\"--log-interval 10 \\\n             --save-interval 500 \\\n             --eval-interval 100 \\\n             --eval-iters 10 \\\n             --checkpoint-activations\"\n\npython pretrain_bert.py \\\n       $BERT_ARGS \\\n       $OUTPUT_ARGS \\\n       --save $CHECKPOINT_PATH \\\n       --load $CHECKPOINT_PATH \\\n       --data-path $DATA_PATH\n</pre>\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/arguments.py).\n\n<a id=\"gpt-2-pretraining\"></a>\n## GPT-2 Pretraining\n`bash examples/pretrain_gpt2.sh`\n\nThis script runs single GPU 345M parameter GPT-2 pretraining. As mentioned above, single GPU training is primarily intended for debugging purposes, as the code is optimized for distributed training. \n\nIt follows largely the same format as the previous BERT script with a few notable differences: the tokenization scheme used is BPE (which requires a merge table and a `json` vocabulary file) instead of WordPiece, the model architecture allows for longer sequences (note that the max position embedding must be greater than or equal to the maximum sequence length), and the `--lr-decay-style` has been set to cosine decay.  Note that the `--data-path` now includes the additional `_text_document` suffix added in preprocessing, but does not include the file extensions.\n\n<pre>\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nDATA_PATH=my-gpt2_text_document\n\nGPT2_ARGS=\"--num-layers 24 \\\n           --hidden-size 1024 \\\n           --num-attention-heads 16 \\\n           --seq-length 1024 \\\n           --max-position-embeddings 1024 \\\n           --batch-size 4 \\\n           --lr 0.00015 \\\n           --train-iters 500000 \\\n           --lr-decay-iters 320000 \\\n           --lr-decay-style cosine \\\n           --vocab-file $VOCAB_FILE \\\n           --merge-file $MERGE_FILE \\\n           --warmup .01 \\\n           --fp16\"\n\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython pretrain_gpt2.py \\\n       $GPT2_ARGS \\\n       $OUTPUT_ARGS \\\n       --save $CHECKPOINT_PATH \\\n       --load $CHECKPOINT_PATH \\\n       --data-path $DATA_PATH \\\n</pre>\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/arguments.py).\n\n<a id=\"distributed-bert-or-gpt-2-pretraining\"></a>\n## Distributed BERT or GPT-2 Pretraining\n`bash examples/pretrain_bert_distributed.sh`\n\n`bash examples/pretrain_gpt2_distributed.sh`\n\nThese scripts use the PyTorch distributed launcher for distributed training. As such, multinode training can be achieved by properly setting environment variables and using `init_method='env://'` in the launcher. See the official PyTorch [documentation](https://pytorch.org/docs/stable/distributed.html#launch-utility) for further description of these [environment variables](https://pytorch.org/docs/stable/distributed.html#environment-variable-initialization). By default, multinode training uses the [nccl](https://developer.nvidia.com/nccl) distributed backend. A simple set of additional arguments and the use of the PyTorch distributed module with the Python flag `-m torch.distributed.launch`, detailed below, are the only additional requirements to adopt distributed training.\n\nThe two tiers of parallelism are data and model parallelism. First, we facilitate two distributed data parallel implementations: a simple one of our own that performs gradient all-reduce at the end of back propagation step, and Torch's distributed data parallel wrapper that overlaps gradient reduction with back propagation computation. To switch between these two options use `--DDP-impl local` or `--DDP-impl torch`, respectively. As expected, Torch distributed data parallelism is more efficient at larger model parallel sizes. For example, for the 8.3 billion parameters model running on 512 GPUs, the scaling increases from 60% to 76% when Torch's distributed data parallel is used. However, the overlapping method requires more memory and for some configurations (e.g., 2.5 billion parameters using 2-way model parallel and 1.2 billion parameters with no model parallel) can make the overall training slower as a result. We empirically found that using a smaller model in those cases improves the training time.\n\nSecond, we developed a simple and efficient intra-layer model parallel approach. To use model parallelism, add the `--model-parallel-size` flag to specify the number of GPUs among which to split the model, along with the arguments passed to the distributed launcher as mentioned above. With `WORLD_SIZE` GPUs and `MP_SIZE` model parallel size, `WORLD_SIZE`/`MP_SIZE` GPUs will be used for data parallelism. The default value for `--model-parallel-size` is 1, which will not implement model parallelism.\n\nOther than these minor changes, the distributed training is identical to the training on a single GPU.\n\nDistributed BERT training:\n<pre>\nWORLD_SIZE=8\nMP_SIZE=2\n\nDISTRIBUTED_ARGS=\"--nproc_per_node $WORLD_SIZE \\\n                  --nnodes 1 \\\n                  --node_rank 0 \\\n                  --master_addr localhost \\\n                  --master_port 6000\"\n\nCHECKPOINT_PATH=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nDATA_PATH=my-bert_text_sentence\nBERT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython -m torch.distributed.launch $DISTRIBUTED_ARGS ./pretrain_bert.py \\\n                $BERT_ARGS \\\n                $OUTPUT_ARGS \\\n                --save $CHECKPOINT_PATH \\\n                --load $CHECKPOINT_PATH \\\n                --data-path $DATA_PATH \\\n                --model-parallel-size $MP_SIZE \\\n                --DDP-impl torch\n</pre>\n\nDistributed GPT-2 training:\n<pre>\nWORLD_SIZE=8\nMP_SIZE=2\n\nDISTRIBUTED_ARGS=&#60;same as those directly above&#62;\n\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nDATA_PATH=my-gpt2_text_document\nGPT2_ARGS=&#60;same as those in <a href=\"#gpt-2-pretraining\">GPT-2 pretraining</a> above&#62;\nOUTPUT_ARGS=&#60;same as those in <a href=\"#bert-pretraining\">BERT pretraining</a> above&#62;\n\npython -m torch.distributed.launch $DISTRIBUTED_ARGS ./pretrain_gpt2.py \\\n                $GPT2_ARGS \\\n                $OUTPUT_ARGS \\\n                --save $CHECKPOINT_PATH \\\n                --load $CHECKPOINT_PATH \\\n                --data-path $DATA_PATH \\\n                --model-parallel-size $MP_SIZE \\\n                --DDP-impl torch\n\n</pre>\n\n<a id=\"realm\"></a>\n## REALM Pipeline\nThe following sections (will) reflect the three stages of training a REALM system. For now it's just the ICT code.\nLoosely, they are pretraining the retriever modules, then jointly training the language model and the retriever, and then finetuning a question answering head on the language model with fixed retriever.\n\n### Inverse Cloze Task (ICT) Pretraining\n1. Have a corpus in loose JSON format with the intention of creating a collection of fixed-size blocks of text as the fundamental units of data. For a corpus like Wikipedia, this will mean multiple sentences per block but also multiple blocks per document. \nRun `tools/preprocess_data.py` to construct one or more indexed datasets with the `--split-sentences` argument to make sentences the basic unit. For the original REALM system, we construct two datasets, one with the title of every document, and another with the body. \nRefer to the following script \n<pre>\npython preprocess_data.py \\\n    --input /path/to/corpus.json \\\n    --json-keys text title \\\n    --split-sentences \\\n    --tokenizer-type BertWordPieceLowerCase \\\n    --vocab-file /path/to/vocab.txt \\\n    --output-prefix corpus_indexed \\\n    --workers 5  # works well for 10 CPU cores. Scale up accordingly.\n</pre>\n\n2. Use a custom samples mapping function in place of `megatron/data/realm_dataset_utils.get_block_samples_mapping` if required. To do this, you will need to implement a new function in C++ inside of `megatron/data/helpers.cpp`. The samples mapping data structure is used to select the data that will constitute every training sample in advance of the training loop.\n The samples mapping is responsible for holding all of the required metadata needed to construct the sample from one or more indexed datasets. In REALM, the samples mapping contains the start and end sentence indices, as well as the document index (to find the correct title for a body) and a unique ID for every block. \n3. Pretrain a BERT language model using `pretrain_bert.py`, with the sequence length equal to the block size in token ids. This model should be trained on the same indexed dataset that is used to supply the blocks for the information retrieval task.\nIn REALM, this is an uncased bert base model trained with the standard hyperparameters.\n4. Use `pretrain_ict.py` to train an `ICTBertModel` which uses two BERT-based encoders to encode queries and blocks to perform retrieval with. \nThe script below trains the ICT model from REALM. It refrences a pretrained BERT model (step 3) in the `--bert-load` argument. The batch size used in the paper is 4096, so this would need to be run with data parallel world size 32. \n<pre>\npython pretrain_ict.py \\\n    --num-layers 12 \\\n    --num-attention-heads 12 \\\n    --hidden-size 768 \\\n    --batch-size 128 \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-head-size 128 \\\n    --train-iters 100000 \\\n    --checkpoint-activations \\\n    --bert-load /path/to/pretrained_bert \\\n    --load checkpoints \\\n    --save checkpoints \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --vocab-file /path/to/vocab.txt \\\n    --lr 0.0001 \\\n    --num-workers 2 \\\n    --lr-decay-style linear \\\n    --weight-decay 1e-2 \\\n    --clip-grad 1.0 \\\n    --warmup .01 \\\n    --save-interval 3000 \\\n    --query-in-block-prob 0.1 \\\n    --fp16\n\n</pre>\n\n### Building an Index of Block Embeddings\nAfter having trained an ICT model, you can now embed an entire dataset of blocks by creating a `BlockData` structure. After that has been saved, you can load it \nand wrap it with a `FaissMIPSIndex` to do fast similarity search which is key in the learned information retrieval pipeline. The initial index can be built with the following script, meant to be run in an interactive session. It can leverage multiple GPUs on multiple nodes to index large datasets much more quickly. \n\n<pre>\npython tools/create_doc_index.py \\\n    --num-layers 12 \\\n    --hidden-size 768 \\\n    --ict-head-size 128 \\\n    --num-attention-heads 12 \\\n    --batch-size 128 \\\n    --checkpoint-activations \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-load /path/to/pretrained_ict \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --block-data-path embedded_blocks.pkl \\\n    --indexer-log-interval 1000 \\\n    --indexer-batch-size 128 \\\n    --vocab-file /path/to/vocab.txt \\\n    --num-workers 2 \\\n    --fp16\n</pre>\n\n<a id=\"evaluation-and-tasks\"></a>\n# Evaluation and Tasks\n\nWe provide several command line arguments, detailed in the scripts listed below, to handle various zero-shot and fine-tuned downstream tasks. However, you can also finetune your model from a pretrained checkpoint on other corpora as desired. To do so, simply add the `--finetune` flag and adjust the input files and training parameters within the original training script. The iteration count will be reset to zero, and the optimizer and internal state will be reinitialized. If the fine-tuning is interrupted for any reason, be sure to remove the `--finetune` flag before continuing, otherwise the training will start again from the beginning.\n\nBecause evaluation requires substantially less memory than training, it may be advantageous to merge a model trained in parallel for use on a single GPU in downstream tasks. The following script accomplishes this.\n\n<pre>\nMODEL_PARALLEL_SIZE=2\n\nVOCAB_FILE=bert-vocab.txt\nCHECKPOINT_PATH=checkpoints/bert_345m\n\nWORLD_SIZE=$MODEL_PARALLEL_SIZE python tools/merge_mp_partitions.py \\\n        --model-type BERT \\\n        --model-parallel-size $MODEL_PARALLEL_SIZE \\\n        --tokenizer-type BertWordPieceLowerCase \\\n        --vocab-file $VOCAB_FILE \\\n        --num-layers 24 \\\n        --hidden-size 1024 \\\n        --num-attention-heads 16 \\\n        --seq-length 512 \\\n        --max-position-embeddings 512 \\\n        --load $CHECKPOINT_PATH\n\n</pre>\n\nSeveral downstream tasks are described for both GPT-2 and BERT models below. They can be run in distributed and model parallel modes with the same changes used in the training scripts.\n\n<a id=\"gpt-2-text-generation\"></a>\n## GPT-2 Text Generation\n`bash examples/generate_text.sh`\n\nWe generate text samples using largely the GPT-2 pretraining script. Few changes need to make, such as we need to provide the path to the pretrained checkpoint, the length of the output samples, whether to generate texts unconditionally (`--num-samples` to denote how many samples to generate) or conditional (need to pass `--sample-input-file <filename>` where each line of the file will be used as the conditional texts). There are few optional parameters to play, e.g. `top-k`, `top-p`, or `greedy` (set top-k and top-p to 0) sampling..\n\n<pre>\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nGPT2_ARGS=&#60;same as those in <a href=\"#gpt-2-pretraining\">GPT-2 pretraining</a> above&#62;\n\nMAX_OUTPUT_SEQUENCE_LENGTH=1024\nTEMPERATURE=1.0\nTOP_P=0.9\nNUMBER_OF_SAMPLES=2\nOUTPUT_FILE=samples.json\n\npython tools/generate_samples_gpt2.py \\\n       $GPT2_ARGS \\\n       --load $CHECKPOINT_PATH \\\n       --out-seq-length $MAX_OUTPUT_SEQUENCE_LENGTH \\\n       --temperature $TEMPERATURE \\\n       --genfile $OUTPUT_FILE \\\n       --num-samples $NUMBER_OF_SAMPLES \\\n       --top_p $TOP_P \\\n       --recompute\n</pre>\n\n<a id=\"gpt-2-evaluation\"></a>\n## GPT-2 Evaluation\nWe include example scripts for GPT-2 evaluation on WikiText perplexity evaluation and LAMBADA Cloze accuracy.\n\n<a id=\"wikitext-perplexity-evaluation\"></a>\n### WikiText Perplexity Evaluation\nFor even comparison with prior works, we evaluate perplexity on the word-level [WikiText-103 test dataset](https://s3.amazonaws.com/research.metamind.io/wikitext/wikitext-103-v1.zip), and appropriately compute perplexity given the change in tokens when using our subword tokenizer.\n\nWe use the following command to run WikiText-103 evaluation on a 345M parameter model.\n<pre>\nTASK=\"WIKITEXT103\"\n\nVALID_DATA=&#60;wikitext path&#62;.txt\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\n\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 1024 \\\n                  --max-position-embeddings 1024 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --batch-size 8 \\\n       --checkpoint-activations \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\n\n<a id=\"lambada-cloze-accuracy\"></a>\n### LAMBADA Cloze Accuracy\nTo compute LAMBADA cloze accuracy (the accuracy of predicting the last token given the preceeding tokens) we utilize a detokenized, processed version of the [LAMBADA dataset](https://github.com/cybertronai/bflm/blob/master/lambada_test.jsonl).\n\nWe use the following command to run LAMBADA evaluation on a 345M parameter model. Note that the `--strict-lambada` flag should be used to require whole word matching. Make that `lambada` is part of the file path.\n\n<pre>\nTASK=\"LAMBADA\"\n\nVALID_DATA=&#60;lambada path&#62;.json\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#wikitext-perplexity-evaluation\">WikiText Perplexity Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --strict-lambada \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --batch-size 8 \\\n       --checkpoint-activations \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\nFurther command line arguments are described in the source file [`main.py`](./tasks/main.py)\n\n<a id=\"bert-task-evaluation\"></a>\n## BERT Task Evaluation\n<a id=\"race-evaluation\"></a>\n### RACE Evaluation\nThe following script finetunes the BERT model for evaluation on the [RACE dataset](http://www.cs.cmu.edu/~glai1/data/race/). The `TRAIN_DATA` and `VALID_DATA` directory contain the RACE dataset as separate `.txt` files.\n\n<pre>\nTRAIN_DATA=\"data/RACE/train/middle\"\nVALID_DATA=\"data/RACE/dev/middle \\\n            data/RACE/dev/high\"\nVOCAB_FILE=bert-vocab.txt\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nCHECKPOINT_PATH=checkpoints/bert_345m_race\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 512 \\\n                  --max-position-embeddings 512 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\nCOMMON_TASK_ARGS_EXT=\"--train-data $TRAIN_DATA \\\n                      --valid-data $VALID_DATA \\\n                      --pretrained-checkpoint $PRETRAINED_CHECKPOINT \\\n                      --checkpoint-activations \\\n                      --save-interval 10000 \\\n                      --save $CHECKPOINT_PATH \\\n                      --log-interval 100 \\\n                      --eval-interval 1000 \\\n                      --eval-iters 10 \\\n                      --weight-decay 1.0e-1\"\n\npython tasks/main.py \\\n       --task RACE \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 3 \\\n       --batch-size 4 \\\n       --lr 1.0e-5 \\\n       --warmup 0.06\n</pre>\n\n<a id=\"mnli-evaluation\"></a>\n### MNLI Evaluation\nThe following script finetunes the BERT model for evaluation with the [MultiNLI sentence pair corpus](https://www.nyu.edu/projects/bowman/multinli/). Because the matching tasks are quite similar, the script can be quickly tweaked to work with the [Quora Question Pairs](https://www.kaggle.com/quora/question-pairs-dataset) (QQP) dataset as well.\n\n<pre>\n\nTRAIN_DATA=\"data/glue_data/MNLI/train.tsv\"\nVALID_DATA=\"data/glue_data/MNLI/dev_matched.tsv \\\n            data/glue_data/MNLI/dev_mismatched.tsv\"\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nCHECKPOINT_PATH=checkpoints/bert_345m_mnli\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\nCOMMON_TASK_ARGS_EXT=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task MNLI \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 5 \\\n       --batch-size 8 \\\n       --lr 5.0e-5 \\\n       --warmup 0.065\n</pre>\n\n<a id=\"datasets\"></a>\n# Datasets\nWe do not host any datasets for GPT-2 or BERT training, however, we detail their collection so that our results may be reproduced.\n\n<a id=\"collecting-wikipedia-training-data\"></a>\n## Collecting Wikipedia Training Data\nWe recommend following the Wikipedia data extraction process specified by Google research: \"the recommended pre-processing is to download [the latest dump](https://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles.xml.bz2), extract the text with [WikiExtractor.py](https://github.com/attardi/wikiextractor), and then apply any necessary cleanup to convert it into plain text.\" \n\nWe recommend using the `--json` argument when using WikiExtractor, which will dump the Wikipedia data into loose json format (one json per line), making it more manageable on the file system and also readily consumable by our codebase. We recommend further preprocessing this json dataset by nltk punctuation standardization. For BERT training, add newlines between sentences during data preprocessing. This is done with the `--split-sentences` flag in `preprocess_data.py` as described [above](#data-preprocessing). (Note that if you'd like to use Wikipedia data for GPT-2 training you should still clean it with nltk/spacy/ftfy, but do not split it into newline separated sentences.)\n\n<a id=\"collecting-gpt-2-webtext-data\"></a>\n## Collecting GPT-2 Webtext Data\nWe utilize the publicly available [OpenWebText](https://github.com/eukaryote31/openwebtext) library from [jcpeterson](https://github.com/jcpeterson/openwebtext) and [eukaryote31's](https://github.com/eukaryote31/openwebtext) work to download urls. We then filtered, cleaned, and deduplicated all downloaded content according to the procedure described in our [openwebtext](./tools/openwebtext) directory. For reddit URLs corresponding to content up to October 2018 we arrived at approximately 37GB of content.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/NVIDIA/Megatron-LM",
    "keywords": "deep learning,Megatron,gpu,NLP,nvidia,pytorch,torch,language",
    "license": "See https://github.com/NVIDIA/Megatron-LM/blob/master/LICENSE",
    "maintainer": "NVIDIA INC",
    "maintainer_email": "",
    "name": "megatron-lm",
    "package_url": "https://pypi.org/project/megatron-lm/",
    "platform": "",
    "project_url": "https://pypi.org/project/megatron-lm/",
    "project_urls": {
      "Homepage": "https://github.com/NVIDIA/Megatron-LM"
    },
    "release_url": "https://pypi.org/project/megatron-lm/1.1.1/",
    "requires_dist": [
      "pybind11",
      "torch",
      "six",
      "regex",
      "numpy"
    ],
    "requires_python": ">=3.6",
    "summary": "Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism.",
    "version": "1.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9848750,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "727cde298df1c779f5a0edac8eb3ca5c16e71842fa3a305328e6141912082f19",
        "md5": "7e85dc2d76819a0b6408d4608437a6e6",
        "sha256": "8c2d7a14b155c16154d955e513249ced127c8cb4e5e0e8e436e421779a59b2ba"
      },
      "downloads": -1,
      "filename": "megatron_lm-1.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7e85dc2d76819a0b6408d4608437a6e6",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 191306,
      "upload_time": "2020-08-02T18:05:10",
      "upload_time_iso_8601": "2020-08-02T18:05:10.819734Z",
      "url": "https://files.pythonhosted.org/packages/72/7c/de298df1c779f5a0edac8eb3ca5c16e71842fa3a305328e6141912082f19/megatron_lm-1.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3c982edf84acf030c1613e47e24d954b1f2bc19063fe1c62c4d60cd87ed44476",
        "md5": "fd81ffe9bf7d549da3b0aa8e19072bfa",
        "sha256": "e33daa569d8431f77d133162c87e777853d3812c3c7f30252df1a01b3278ee8b"
      },
      "downloads": -1,
      "filename": "megatron-lm-1.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "fd81ffe9bf7d549da3b0aa8e19072bfa",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 153376,
      "upload_time": "2020-08-02T18:05:12",
      "upload_time_iso_8601": "2020-08-02T18:05:12.256026Z",
      "url": "https://files.pythonhosted.org/packages/3c/98/2edf84acf030c1613e47e24d954b1f2bc19063fe1c62c4d60cd87ed44476/megatron-lm-1.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}