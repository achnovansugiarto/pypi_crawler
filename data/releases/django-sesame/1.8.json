{
  "info": {
    "author": "Aymeric Augustin",
    "author_email": "aymeric.augustin@m4x.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 2.2",
      "Framework :: Django :: 3.0",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": ".. image:: logo/horizontal.svg\n   :width: 400px\n   :alt: django-sesame\n\n`django-sesame`_ provides frictionless authentication with \"Magic Links\" for\nyour Django project.\n\n.. _django-sesame: https://github.com/aaugustin/django-sesame\n\nIt generates URLs containing authentication tokens such as:\nhttps://example.com/?url_auth_token=AAAAARchl18CIQUlImmbV9q7PZk%3A89AEU34b0JLSrkT8Ty2RPISio5\n\nThen it authenticates users based on tokens found in URLs.\n\nUse cases\n=========\n\nKnown use cases for django-sesame include:\n\n1. Login by email, an increasingly attractive option on mobile where\n   typing passwords is uncomfortable. This technique is prominently\n   deployed by Slack.\n\n   If you're doing this, you should define a small ``SESAME_MAX_AGE``, perhaps\n   10 minutes.\n\n2. Authenticated links, typically if you're generating a report offline, then\n   emailing a link to access it when it's ready. An authenticated link works\n   even if the user isn't logged in on the device where they're opening it.\n\n   Likewise, you should configure an appropriate ``SESAME_MAX_AGE``, probably\n   no more than a few days.\n\n   Since emails may be forwarded, authenticated links shouldn't log the user\n   in. They should only allow access to specific views, as described in\n   \"Per-view authentication\" below.\n\n3. Sharing links, which are a variant of authenticated links. When a user\n   shares content with a guest, you can create a phantom account for the guest\n   and generate an authenticated link tied to that account.\n\n   Email forwarding is even more likely in this context. If you're doing this,\n   make sure authenticated links don't log the user in.\n\n4. Non-critical private websites, for example for a family or club site,\n   where users don't expect to manage a personal account with a password.\n   Authorized users can bookmark personalized authenticated URLs.\n\n   Here you can rely on the default settings because that's the original —\n   and, admittedly, niche — use case for which django-sesame was built.\n\n(In)security\n============\n\n**Before using django-sesame in your project, please review the following\nadvice carefully.** (Also, please don't use security-sensitive libraries\npublished by strangers on the Internet without checking what they do.)\n\nThe major security weakness in django-sesame is a direct consequence of the\nfeature it implements: **whoever obtains an authentication token will be able\nto authenticate to your website.**\n\nURLs end up in countless insecure places: emails, referer headers, proxy logs,\nbrowser history, etc. You can't avoid that. At best you can mitigate it by\ncreating short-lived or single-use tokens, as described below.\n\nOtherwise, a reasonable attempt has been made to provide a secure solution.\ndjango-sesame uses Django's signing framework to create signed tokens. It\noffers configurable options for token expiration or invalidation.\n\nRequirements\n============\n\ndjango-sesame is tested with:\n\n- Django 2.2 (LTS) and 3.0;\n- all supported Python versions.\n\nIt builds upon ``django.contrib.auth``.\n\nIt supports custom user models, provided they have ``password`` and\n``last_login`` fields. Most custom user models inherit these fields from\n``AbstractBaseUser``.\n\ndjango-sesame is released under the BSD license, like Django itself.\n\nGetting started\n===============\n\n1. Install django-sesame and ua-parser::\n\n    $ pip install django-sesame\n    $ pip install ua-parser  # optional, see \"Safari issues\" below\n\n2. Add ``sesame.backends.ModelBackend`` to ``AUTHENTICATION_BACKENDS``::\n\n    AUTHENTICATION_BACKENDS += [\"sesame.backends.ModelBackend\"]\n\n3. Add ``sesame.middleware.AuthenticationMiddleware`` to ``MIDDLEWARE``::\n\n    MIDDLEWARE += [\"sesame.middleware.AuthenticationMiddleware\"]\n\n   The best position for ``sesame.middleware.AuthenticationMiddleware`` is\n   just after ``django.contrib.auth.middleware.AuthenticationMiddleware``.\n\n4. (Optional) For better security, set ``SESAME_SALT`` to a random string with\n   at least 16 bytes of entropy::\n\n    SESAME_SALT = \"...\"\n\n   You can generate such a random string in a Python shell with::\n\n    >>> from django.utils.crypto import get_random_string\n    >>> get_random_string(22)\n\n5. Generate authentication tokens with ``sesame.utils.get_query_string(user)``.\n\nThat's all!\n\nGenerating URLs\n===============\n\ndjango-sesame provides two functions to generate authenticated URLs.\n\n1. ``sesame.utils.get_query_string(user)`` returns a complete query string\n   that you can append to any URL to enable one-click login.\n\n2. ``sesame.utils.get_parameters(user)`` returns a dictionary of GET\n   parameters to add to the query string, if you're already building one.\n\nShare resulting URLs with your users while ensuring adequate confidentiality.\n\nBy default, the URL parameter is called ``url_auth_token``. You can set the\n``SESAME_TOKEN_NAME`` setting to a shorter name that doesn't conflict with\nquery string parameters used by your application.\n\nTokens lifecycle\n================\n\nBy default, tokens don't expire but are tied to the password of the user.\nChanging the password invalidates the token. When the authentication backend\nuses salted passwords — that's been the default in Django for a long time —\nthe token is invalidated even if the new password is identical to the old one.\n\nIf you want tokens to expire after a given amount of time, set the\n``SESAME_MAX_AGE`` setting to a duration in seconds. Then each token will\ncontain the time it was generated at and django-sesame will check if it's\nstill valid at each login attempt.\n\nIf you want tokens to be usable only once, set the ``SESAME_ONE_TIME`` setting\nto ``True``. In that case tokens are only valid if the last login date hasn't\nchanged since they were generated. Since logging in changes the last login\ndate, such tokens are usable at most once. If you're intending to send links\nby email, be aware that some email providers scan links for security reasons,\nwhich consumes single-use tokens prematurely. Tokens with a short expiry are\nmore reliable.\n\nIf you don't want tokens to be invalidated by password changes, set the\n``SESAME_INVALIDATE_ON_PASSWORD_CHANGE`` setting to ``False``. **This is\nstrongly discouraged because it becomes impossible to invalidate a token**\nshort of changing the ``SESAME_SALT`` setting and invalidating all tokens at\nonce. If you're doing it anyway, you should set ``SESAME_MAX_AGE`` to a short\nvalue to minimize risks. This option may be useful for generating tokens\nduring a signup process, when you don't know if the token will be used before\nor after initializing the password.\n\nFinally, if the ``is_active`` attribute of a user is set to ``False``,\ndjango-sesame rejects authentication tokens for this user.\n\nTokens must be verified with the same settings that were used for generating\nthem. Changing settings invalidates previously generated tokens. The only\nexception to this rule is ``SESAME_MAX_AGE``: as long as it isn't ``None``,\nyou can change its value and the new value will apply even to previously\ngenerated tokens.\n\nPer-view authentication\n=======================\n\nThe configuration described in the \"Getting started\" section enables a\nmiddleware that looks for a token in every request and, if there is a valid\ntoken, logs the user in. It's as if they had submitted their username and\npassword in a login form. This provides compatibility with APIs like the\n``login_required`` decorator and the ``LoginRequired`` mixin.\n\nSometimes this behavior is too blunt. For example, you may want to build a\nMagic Link that gives access to a specific view but doesn't log the user in\npermanently.\n\nTo achieve this, you can remove ``sesame.middleware.AuthenticationMiddleware``\nfrom the ``MIDDLEWARE`` setting and authenticate the user with django-sesame\nin a view as follows::\n\n    from django.core.exceptions import PermissionDenied\n    from django.http import HttpResponse\n\n    from sesame.utils import get_user\n\n    def hello(request):\n        user = get_user(request)\n        if user is None:\n            raise PermissionDenied\n        return HttpResponse(\"Hello {}!\".format(user))\n\nWhen ``get_user()`` returns ``None``, it means that the token was missing,\ninvalid, expired, or already used. Then you can show an appropriate error\nmessage or redirect to a login form.\n\nWhen ``SESAME_ONE_TIME`` is enabled, ``get_user()`` updates the user's last\nlogin date in order to invalidate the token. When ``SESAME_ONE_TIME`` isn't\nenabled, it doesn't, because making a database write for every call to\n``get_user()`` could degrade performance. You can override this behavior with\nthe ``update_last_login`` keyword argument::\n\n    get_user(request, update_last_login=True)   # always update last_login\n    get_user(request, update_last_login=False)  # never update last_login\n\n``get_user()`` is a thin wrapper around the low-level ``authenticate()``\nfunction from ``django.contrib.auth``. It's also possible to verify an\nauthentication token directly with  ``authenticate()``. To do so, the\n``sesame.backends.ModelBackend`` authentication backend expects an\n``url_auth_token`` argument::\n\n    from django.contrib.auth import authenticate\n\n    user = authenticate(url_auth_token=...)\n\nIf you decide to use ``authenticate()`` instead of ``get_user()``, you must\nupdate ``user.last_login`` to invalidate one-time tokens. Indeed, in\n``django.contrib.auth``, ``authenticate()`` is a low-level function. The\ncaller, usually the higher-level ``login()`` function, is responsible for\nupdating ``user.last_login``.\n\nSafari issues\n=============\n\nThe django-sesame middleware removes the token from the URL with a HTTP 302\nRedirect after authenticating a user successfully. Unfortunately, in some\nscenarios, this triggers Safari's \"Protection Against First Party Bounce\nTrackers\". In that case, Safari clears cookies and the user is logged out.\n\nTo avoid this problem, django-sesame doesn't perform the redirect when it\ndetects that the browser is Safari. This relies on the ua-parser package,\nwhich is an optional dependency. If it isn't installed, django-sesame always\nredirects.\n\nCustom primary keys\n===================\n\nWhen generating a token for a user, django-sesame stores the primary key of\nthat user in the token. In order to keep tokens short, django-sesame creates\ncompact binary representations of primary keys, according to their type.\n\nIf you're using integer or UUID primary keys, you're fine. If you're using\nanother type of primary key, for example a string created by a unique ID\ngeneration algorithm, the default representation may be suboptimal.\n\nFor example, let's say primary keys are strings containing 24 hexadecimal\ncharacters. The default packer represents them with 25 bytes. You can reduce\nthem to 12 bytes with this custom packer::\n\n    from sesame.packers import BasePacker\n\n    class Packer(BasePacker):\n\n        @staticmethod\n        def pack_pk(user_pk):\n            assert len(user_pk) == 24\n            return bytes.fromhex(user_pk)\n\n        @staticmethod\n        def unpack_pk(data):\n            return data[:12].hex(), data[12:]\n\nThen, set the ``SESAME_PACKER`` setting to the dotted Python path to your\ncustom packer class.\n\nFor details, read ``help(BasePacker)`` and look at built-in packers defined in\nthe ``sesame.packers`` module.\n\nTokens security\n===============\n\nAuthentication tokens generated by django-sesame contain:\n\n- The primary key of the user for which they were generated;\n- A revocation key which is used for invalidating tokens.\n\nThe revocation key includes:\n\n- The hashed password of the user, unless\n  ``SESAME_INVALIDATE_ON_PASSWORD_CHANGE`` is disabled;\n- The last login date of the user, if ``SESAME_ONE_TIME`` is enabled.\n\nPrimary keys are in clear text. If this is a concern, you can write a custom\npacker to encrypt them. See \"Custom primary keys\" above for details.\n\nRevocation keys are hashed in order to keep tokens short. Also, this avoids\nleaking the password hash and corresponding salt if a token is compromised.\n\nThe hashing algorithm is PBKDF2 with 10 000 iterations of MD5. It provides a\n16 bytes hash with better security than a single round of MD5. The digest\nalgorithm and number of iterations can be altered with the ``SESAME_DIGEST``\nand ``SESAME_ITERATIONS`` settings. The salt is taken from the ``SESAME_SALT``\nsetting.\n\nFinally, tokens are encoded with URL-safe Base64 and signed with Django's\nbuilt-in ``Signer`` or ``TimestampSigner``, depending on whether\n``SESAME_MAX_AGE`` is set, to prevent tampering. The signature algorithm\nfactors in the salt defined in the ``SESAME_SALT`` setting.\n\nStateless authentication\n========================\n\nTechnically, django-sesame can provide stateless authenticated navigation\nwithout ``django.contrib.sessions``, provided all internal links include the\nauthentication token, but that increases the security issues explained above.\n\nIf ``django.contrib.sessions.middleware.SessionMiddleware`` and\n``django.contrib.auth.middleware.AuthenticationMiddleware`` aren't enabled,\n``sesame.middleware.AuthenticationMiddleware`` sets ``request.user`` to the\ncurrently logged-in user or ``AnonymousUser()``.\n\nChangelog\n=========\n\n1.8\n---\n\n* Added compatibility with custom user models with most types of primary keys,\n  including ``BigAutoField``, ``SmallAutoField``, other integer fields,\n  ``CharField`` and ``BinaryField``.\n* Added the ability to customize how primary keys are stored in tokens.\n* Added compatibility with Django ≥ 3.0.\n\n1.7\n---\n\n* Fixed invalidation of one-time tokens in ``get_user()``.\n\n1.6\n---\n\n* Fixed detection of Safari on iOS.\n\n1.5\n---\n\n* Added support for single use tokens with the ``SESAME_ONE_TIME`` setting.\n* Added support for not invalidating tokens on password change with the\n  ``SESAME_INVALIDATE_ON_PASSWORD_CHANGE`` setting.\n* Added compatibility with custom user models where the primary key is a\n  ``UUIDField``.\n* Added the ``get_user()`` function to obtain a user instance from a request.\n* Improved error message for pre-existing tokens when changing the\n  ``SESAME_MAX_AGE`` setting.\n* Fixed authentication on Safari by disabling the redirect which triggers ITP.\n\n1.4\n---\n\n* Added a redirect to the same URL with the query string parameter removed.\n\n1.3\n---\n\n* Added compatibility with Django ≥ 2.0.\n\n1.2\n---\n\n* Added the ability to rename the query string parameter with the\n  ``SESAME_TOKEN_NAME`` setting.\n* Added compatibility with Django ≥ 1.8.\n\n1.1\n---\n\n* Added support for expiring tokens with the ``SESAME_MAX_AGE`` setting.\n\n1.0\n---\n\n* Initial release.\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/aaugustin/django-sesame",
    "keywords": "",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-sesame",
    "package_url": "https://pypi.org/project/django-sesame/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-sesame/",
    "project_urls": {
      "Homepage": "https://github.com/aaugustin/django-sesame"
    },
    "release_url": "https://pypi.org/project/django-sesame/1.8/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "URL-based authentication, an application that provides one-click login via specially crafted URLs",
    "version": "1.8",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14573471,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5c70cba3b8a103bc33d2935e1da7cc769ccf1fd273adca512b0897ad9e5990fc",
        "md5": "12f48f6f5c31134598509d101c883205",
        "sha256": "4f0a2a8b59a1fe40863d71ef576efa59379fc69e3ebe89171febb99b434d1634"
      },
      "downloads": -1,
      "filename": "django_sesame-1.8-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "12f48f6f5c31134598509d101c883205",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 20134,
      "upload_time": "2020-05-11T22:03:33",
      "upload_time_iso_8601": "2020-05-11T22:03:33.351195Z",
      "url": "https://files.pythonhosted.org/packages/5c/70/cba3b8a103bc33d2935e1da7cc769ccf1fd273adca512b0897ad9e5990fc/django_sesame-1.8-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "501ffe240ab069e2ede3b8a85854fbb93fc8498a4df00254128e7f0c7fe198eb",
        "md5": "b3dc61e57ece88ada7920d3b0ec0b9e0",
        "sha256": "2aaa56330bb668e625aaa5a016b2002a5630d57de261efc20e6dfc2b9f3edd53"
      },
      "downloads": -1,
      "filename": "django-sesame-1.8.tar.gz",
      "has_sig": false,
      "md5_digest": "b3dc61e57ece88ada7920d3b0ec0b9e0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 14763,
      "upload_time": "2020-05-11T21:56:14",
      "upload_time_iso_8601": "2020-05-11T21:56:14.088334Z",
      "url": "https://files.pythonhosted.org/packages/50/1f/fe240ab069e2ede3b8a85854fbb93fc8498a4df00254128e7f0c7fe198eb/django-sesame-1.8.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}