{
  "info": {
    "author": "Tozny, LLC",
    "author_email": "info@tozny.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# Introduction\n\nThe Tozny End-to-End Encrypted Database (E3DB) is a storage platform with powerful sharing and consent management features.\n[Read more on our blog.](https://tozny.com/blog/announcing-project-e3db-the-end-to-end-encrypted-database/)\n\nE3DB provides a familiar JSON-based NoSQL-style API for reading, writing, and querying data stored securely in the cloud.\n\n# Requirements\n\n* Python 3.4+ environment (Version 1.x of the E3DB SDK supports 2.7, but is no longer being supported except in the case of security updates)\n\n# Installation\n\n## With Pip (Preferred)\n\n`pip install e3db`\n\n## Local build\n\n### Build\n\nTo build the package locally:\n\n```bash\npython setup.py bdist_wheel\n```\n\n### Install\n\nThat produces a `.whl` file in the `dist` directory that you can install. This can be installed with:\n\n```bash\npip install --use-wheel --find-links=<path to dist dir> e3db\n```\n\n# Setup\n\n## Registering a client\n\nRegister an account with [Tozny](https://dashboard.tozny.com/login) to get started. From the Dashboard you can create clients directly (and grab their credentials from the console) or create registration tokens to dynamically create clients with `e3db.Client.register()`. Clients registered from within the console will automatically back their credentials up to your account. Clients created dynamically via the SDK can _optionally_ back their credentials up to your account.\n\nFor a more complete walkthrough, see [`/examples/registration.py`](https://github.com/tozny/e3db-python/blob/master/examples/registration.py).\n\n### Without Credential Backup\n\n```python\nimport e3db\n\ntoken = '...'\nclient_name = '...'\n\npublic_key, private_key = e3db.Client.generate_keypair()\n\nclient_info = e3db.Client.register(token, client_name, public_key)\n\n# Now run operations with the client's details in client_info\n```\n\nThe object returned from the server contains the client's UUID, API key, and API secret (as well as echos back the public key passed during registration). It's your responsibility to store this information locally as it _will not be recoverable_ without credential backup.\n\n### With Credential Backup\n\n```python\nimport e3db\n\ntoken = '...'\nclient_name = '...'\n\npublic_key, private_key = e3db.Client.generate_keypair()\n\nclient_info = e3db.Client.register(token, client_name, public_key, private_key=private_key, backup=True)\n\napi_key_id = client_info.api_key_id\napi_secret = client_info.api_secret\nclient_id = client_info.client_id\n\nconfig = e3db.Config(\n    client_id,\n    api_key_id,\n    api_secret,\n    public_key,\n    private_key,\n    public_signing_key,\n    private_signing_key\n)\n\n# Optionally, if you want to save this Configuration to disk, do the following:\nconfig.write()\n\n# Now run operations with the client's details by instantiating a e3db client.\nclient = e3db.Client(config())\n```\n\nThe private key must be passed to the registration handler when backing up credentials as it is used to cryptographically sign the encrypted backup file stored on the server. The private key never leaves the system, and the stored credentials will only be accessible to the newly-registered client itself or the account with which it is registered.\n\n## Loading configuration and creating a client\n\nConfiguration is managed at runtime by instantiating an `e3db.Config` object with your client's credentials.\n\n```python\nimport e3db\nimport os\n\n# Assuming your credentials are stored as defined constants in the\n# application, pass them each into the configuration constructor as\n# follows:\n\nconfig = e3db.Config(\n    os.environ[\"client_id\"],\n    os.environ[\"api_key_id\"],\n    os.environ[\"api_secret\"],\n    os.environ[\"public_key\"],\n    os.environ[\"private_key\"],\n    os.environ[\"public_signing_key\"],\n    os.environ[\"private_signing_key\"]\n)\n\n# Pass the configuration when building a new client instance.\n\nclient = e3db.Client(config())\n```\n\n### Options for Loading Credentials\n\nThere are a number of options for instantiating an `e3db.Config` object. Shown above is the manual creation of the config option, but there are some convenience methods that can make this process easier when dealing with multiple client profiles.\n\nLoading from `.tozny` profiles, takes advantage of the same profiles from the [e3db cli tool](https://github.com/tozny/e3db).\n\n```python\n# usage\nconfig = e3db.Config.load(profile_name)\n# path searched\npath = `~/.tozny/<profile_name>/e3db.json`\n\n# default path for no profile_name\nconfig = e3db.Config.load()\npath = `~/.tozny/e3db.json`\n\n# provided method to save credentials to disk\nconfig.write(profile_name)\n```\n\nLoading from an arbitrary file that matches the credentials format, but may have a custom path.\n\n```python\ncredentials_path = \"credentials.json\" # your e3db credentialss\nif os.path.exists(credentials_path):\n    client = e3db.Client(json.load(open(credentials_path)))\n    ...\n```\n\n# Usage\n\n## Writing a record\n\nTo write new records to the database, call the `e3db.Client.write` method with a string describing the type of data to be written, along with an dictionary containing the terms of the record. `e3db.Client.write` returns the newly created record.\n\n```python\nimport e3db\n\nclient = e3db.Client(\n  # config\n)\n\nrecord_type = 'contact'\ndata = {\n    'first_name': 'Jon',\n    'last_name': 'Snow',\n    'phone': '555-555-1212'\n}\n\nrecord = client.write(record_type, data)\nprint ('Wrote record ID {0}'.format(record.meta.record_id))\n\n# Read that record back from the server and print the name\nrecord2 = client.read(record.meta.record_id)\nprint ('Read name: {0}'.format(record2.data['first_name']))\n\n```\n\n## Searching records\n\nE3DB supports complex search options for finding records based on the terms stored in record metadata.\nThese terms include the properties in the [Meta class](e3db/types/meta.py):\n\n```\n - record_ids\n - writer_ids\n - user_ids\n - record_types\n - plain\n    - keys\n    - values\n```\n\nThe values in the plain meta dictionary are expanded into keys and values for two additional query terms:\n\n```\n - keys\n - values\n\nWHERE\n\n plain = {\"key1\":\"value1\", \"key2\":\"value2\"}\n keys = [\"key1\", \"key2\"]\n values = [\"value1\", \"value2\"]\n```\n\nA time range can be provided to limit search results based off one of these terms:\n\n```\n - created\n - last_modified\n```\n\n#### Search Results\n\nThe results of your search come back in a [SearchResult object](e3db/types/search_result.py):\n\n```python\n# This object contains your records,\n# and additional information about your search.\n\nquery = Search(include_data=True)\nresults = client.search(query)\n\n# Records found in your search\nresults.records\n\n# Number of records returned from search\nlen(results)\n\n# Number of records present in E3db that match your search.\n# If there are more records to be retrieved this number will be greater than len(results),\n# and next_token will not be 0\nresults.total_results\n\n# Token for paginating through queries,\n# this token will be 0 if there are no more records to be returned.\nresults.next_token\n\nresults.search_id # id for bulk searching of many records, currently not available\n```\n\n#### Examples\n\nTo list all records of type `contact` and print a simple report containing names and phone numbers:\n\n```python\n# setup\nimport e3db\nfrom e3db.types import Search\n\nconfig = e3db.Config(\n    os.environ[\"client_id\"],\n    os.environ[\"api_key_id\"],\n    os.environ[\"api_secret\"],\n    os.environ[\"public_key\"],\n    os.environ[\"private_key\"],\n    os.environ[\"public_signing_key\"],\n    os.environ[\"private_signing_key\"]\n)\n\nclient = e3db.Client(config())\n\nquery = Search(include_data=True).match(record_types=['contact'])\nresults = client.search(query)\n\nfor record in results:\n    full_name = \"{0} --- {1}\".format(record.data['first_name'], record.data['last_name'])\n    print \"{0} --- {1}\".format(full_name, record.data['phone'])\n```\n\nThe full list of parameters you can search for are under `e3db.types.Params`. Searching gives you access to chaining more powerful queries such as conditional operators, exclusions, and date filters.\n\nTo search for records of type `season` that have unencrypted metadata values of `summer` and `sunny`, create the following query:\n\n```python\n# e3db setup...\n\ndata = {\"temp\": \"secret_temp\"}\nplain = {\"name\":\"summer\", \"weather\":\"sunny\"}\nclient.write(\"season\", data, plain)\n\n# {key:values} in the plain JSON field are mapped to keys=[] and values=[] behind the scenes in E3DB.\nquery = Search().match(condition=\"AND\", record_types=[\"season\"], values=[\"summer\", \"sunny\"])\nresults = client.search(query)\n\n# searching on keys instead...\nquery = Search().match(condition=\"AND\", record_types=[\"season\"], keys=[\"name\", \"weather\"])\n```\n\nTo search for records of type `jam` with values of `apricot`, but excluding values of `strawberry`, create the following query:\n\n```python\n# e3db setup...\n\napricot_data = {\"recipe\": \"encrypted_secret_formula\"}\napricot_plain = {\"flavor\":\"apricot\"}\n\nclient.write(\"jam\", apricot_data, apricot_plain)\n\nstrawberry_data = {\"recipe\": \"encrypted_secret_formula\"}\nstrawberry_plain = {\"flavor\":\"strawberry\"}\nclient.write(\"jam\", strawberry_data, strawberry_plain )\n\nquery = Search().match(record_types=[\"jam\"], values=[\"apricot\"]).exclude(values=[\"strawberry\"])\nresults = client.search(query)\n```\n\n#### Time Filters\n\nThe Search method has the capability to filter by the time records were created or last modified, restricting search results to a specific timeframe. The most basic example, of searching for all records written by a writer in the last 24 hours, is shown below:\n\n```python\n# e3db setup...\nfrom e3db.types import Search\nfrom datetime import datetime, timedelta\nimport time\n\n# Using seconds from unix epoch\nnow = int(time.time())\nstart = now - (60 * 60 * 24) # 60 seconds, 60 minutes, 24 hours\nend = now\n\nwriter_id = \"some_writer_uuid\"\nquery = Search().match(writers=[writer_id])\\\n    .range(start=start, end=end) # Filters here\nresults = client.search(query)\n\n# using datetime\nnow = datetime.now().astimezone()\nstart = now - timedelta(days=1)\nend = now\n\nwriter_id = \"some_writer_uuid\"\nquery = Search().match(writers=[writer_id])\\\n    .range(start=start, end=end) # Filters here\nresults = client.search(query)\n```\n\nThe Range can be open ended if you want to, for example, see all records written before yesterday:\n\n```python\nnow = int(time.time())\nend = now - (60 * 60 * 24) # 60 seconds, 60 minutes, 24 hours == 1 day in seconds\n\nquery = Search().match()\\\n    .range(end=end)\nresults = client.search(query)\n```\n\nOr see all records written in the last week...\n\n```python\nnow = int(time.time())\nstart = now - (60 * 60 * 24 * 7) # 60 seconds, 60 minutes, 24 hours, 7 days == 1 week in seconds\n\nquery = Search().match()\\\n    .range(start=start)\nresults = client.search(query)\n```\n\nThe Search Range accepts Unix Epoch, datetime objects, and datetime timezone-unaware objects, for start and end times. In Python all datetime objects are `timezone naive` or `timezone-unaware` unless you are using a libary like pytz. So the Search Range will assume that you want a timezone of UTC unless otherwise specified.\n\nTo target a specific timezone you have a couple options:\n\n```python\n# 1. Go zone agnostic by providing a time based off of the Unix Epoch (recommended).\nunix_epoch = int(time.time()) # https://www.epochconverter.com/ for conversions\nquery = Search().match().range(start=unix_epoch-3600, end=unix_epoch) # This will always return the most recent hour of results\n\n# 2. Create timezone aware objects to pass into Search Range.\ntz_unaware = datetime.now()\ntz_aware = tz_unaware.astimezone() # sets timezone to match local machine\n\n# 3. Specify an approriate zone_offset. The hour offset from UTC as int or \"[+|-]HH:MM\" as str\ntz_unaware = datetime.now()\nquery = Search().match().range(start=tz_unaware, zone_offset=-7) # we append UTC-7 to the tz_unaware object\nquery = Search().match().range(start=tz_unaware, zone_offset=\"-07:00\") # we parse and append UTC-7 to the tz_unaware object\n\n# 4. Manually creating the proper time (not recommended).\ntz_unaware = datetime.now()\n# Assuming local tz of Pacific time, PT is UTC-7, and so we add 7 hours to get UTC.\nutc_tz_unaware = tz_unaware + timedelta(hours=7)\nquery = Search().match().range(start=utc_tz_unaware)\n```\n\nTake care when using the python datetime library function `astimezone()`, because it does an implicit conversion behind the scenes using the computer's local timezone if no tzinfo is provided as a parameter. To avoid this you can replace the tzinfo instead:\n\n```python\nunaware_day = datetime(year=2019, month=3, day=18, hour=0, minute=0, second=0)\nprint(unaware_day.isoformat(\"T\"))\n# Prints: 2019-03-18T00:00:00\n\n# using astimezone()\nas_timezone = unaware_day.astimezone(timezone(timedelta(hours=0))) # attempting to convert to UTC\nprint(as_timezone.isoformat(\"T\"))\n# Prints: 2019-03-18T07:00:00+00:00, which is 7 hours ahead of the anticipated time.\n\n# replacing tzinfo\naware_day = unaware_day.replace(tzinfo=timezone(timedelta(hours=0))) # attempting to convert to UTC\nprint(aware_day.isoformat(\"T\"))\n# Prints: 2019-03-18T00:00:00-07:00\n```\n\n#### Defaults\n\nThe Search method has a number of default parameters when searching, more detail can be found within the inline documentation.\n\nUnder Search there are these defaults:\n\n```python\n# Optional value that starts search from the first page of results, only required for paginated queries.\nnext_token = 0\n\n# Amount of records to be returned, limiting if more are available. Defaults to 50, and the maximum value allowed is 1000.\ncount = 50\n\n# Include only records written by the client (False), or search other writer ids (True)\ninclude_all_writers = False\n\n# Include data when returning records\ninclude_data = False\n```\n\nUnder Search Params there are these defaults:\n\n```python\n# Conditional OR when searching upon all terms within this clause (Param object)\ncondition = \"OR\" # options: \"OR\"|\"AND\"\n\n# Exactly matches the search terms provided\nstrategy = \"EXACT\" # options \"EXACT\"|\"FUZZY\"|\"WILDCARD\"|\"REGEXP\"\n```\n\nUnder Search Range there is this default:\n\n```python\n# Search records based on when they were created or last modified\nkey = \"CREATED\" # options: \"CREATED\"|\"MODIFIED\"\n\n# Zone offset is None by default, but if provided it will override provided datetime objects if they are timezone unaware\n# Accepts\n#   - int denoting hours offset from UTC\n#   - str in the format \"[+|-]HH:MM\" also denoting the time offset from UTC\n#       - for a more comprehensive list see https://en.wikipedia.org/wiki/List_of_UTC_time_offsets\nzone_offset = None\n```\n\nSince python datetime objects are zone agnostic, provide the proper timezone offset from UTC\nin zone_offset to search properly.\n\n### Boolean Searching\n\nWithin each match or exclude clause the internal search terms can either be joined with AND or OR.\n\nThe data for these examples can be found under [boolean_search](./examples/boolean_search.py)\n\n```python\n# The Search Method has two conditional options for constructing your queries: AND|OR\n# OR is used by default and does not have to be explicitly stated unlike below.\nserver_1_or_server_2 = Search().match(condition=\"OR\", strategy=\"WILDCARD\", plain={\"*server_1*\":\"*\", \"*server_2*\":\"*\"})\nresults = client.search(server_1_or_server_2)\nprint_results(\"getting records with server_1 or server_2 in meta with the plain field\", results)\n\nserver_1_and_server_2 = Search().match(condition=\"AND\", strategy=\"WILDCARD\", plain={\"*server_1*\":\"*\", \"*server_2*\":\"*\"})\nresults = client.search(server_1_and_server_2)\nprint_results(\"getting records with server_1 and server_2 in meta with the plain field (returns nothing)\", results)\n```\n\nSearch terms can be intermingled\n\n```python\n# AND is the logical operator and returns records that match all conditions within the match parameters.\nrecord_and_plain_search = Search().match(condition=\"AND\", strategy=\"WILDCARD\", record_types=[\"flora\"], plain={\"*test*\":\"*dand*\"})\nresults = client.search(record_and_plain_search)\n# The results we see here is all records of record_type `flora`, and key `*test*` and value `*dand*`\n# We get the single record with meta \"{'flora_test_12345':'dandelion'}\"\nprint_results(\"get records by record type 'flora' AND plain containing '*test*':'*dand*' \", results)\n```\n\nCombining match and exclude together will remove the terms in the exclude clause\n\n```python\n# This means records that equal the match clause AND do not equal the exclude clause are returned.\nmatch_and_exclude = Search().match(record_types=[\"flora\"]).exclude(strategy=\"WILDCARD\", keys=[\"*test*\"])\nresults = client.search(match_and_exclude)\nprint_results(\"get records of record type 'flora' and do not have keys `*test*`\", results)\n```\n\n**Chaining match clauses with matches, and exclude clauses with excludes are joined by the logical OR**. In general, the two basic tenants of chaining these clauses are as follows:\n\n1. more match clauses expands your search, adding terms that match your results\n1. more exclude clauses constricts your search, removing terms that match your results **excludes have priority over match clauses**\n\n```python\nchain_match = Search().match(condition=\"AND\", record_types=[\"flora\"]).match(condition=\"AND\", record_types=[\"fauna\"])\n# the above search is equivalent to below.\nequivalent_to_chain_match = Search().match(condition=\"OR\", record_types=[\"flora\", \"fauna\"])\n```\n\nBelow is some psuedocode to make the boolean logic above clearer.\n\n```psuedocode\n# (B1 OR B2) AND (NOT (B3 OR B4))\nquery = Search().match(B1).match(B2).exclude(B3).exclude(B4)\n\n\n# (B1 AND C1 AND C3) OR B2\nquery = Search().match(condition=\"AND\", B1, C1, C3).match(B2)\n\n\n# (B1 AND C1 AND C3) OR (B2 OR B3)\nquery = Search().match(condition=\"AND\", B1, C1, C3).match(condition=\"OR\", B2, B3)\n```\n\nNested chaining allows you to specify varying strategies for different terms\n\n```python\ndiffering_strategies = Search().match(strategy=\"EXACT\", record_types=[\"flora\"])\\\n                                .match(strategy=\"WILDCARD\", keys=[\"*12345\"])\\\n                                .exclude(strategy=\"REGEXP\", keys=[\".*test.*\"])\\\n                                .exclude(strategy=\"REGEXP\", keys=[\".*server_2.*\"])\n# results = (MATCH `flora` OR MATCH `*12345`) AND (EXCLUDE `.*test.*` OR EXCLUDE `.*server_2.*`)\nresults = client.search(differing_strategies)\nprint_results(\"Different matching strategies: this search will return an EXACT match to record_type `flora` OR WILDCARD match to keys `*12345`, and a REGEXP exclude to keys `.*test.*` OR REGEXP exclude to keys `.*server_2.*`\", results)\n```\n\nKeep in mind that this chaining means your previous search object gets altered each time.\n\n```python\noriginal_search = Search().exclude(record_types=[\"fauna\"])\nmodified_search = original_search.exclude(record_types=[\"flora\"])\nresults = client.search(modified_search)\nprint_results(\"modified_search and original_search will exclude both flora and fauna\", results)\n```\n\n### Advanced Matching Strategies\n\nSearch offers advanced queries that provide more flexibility than the default matching strategy of `EXACT`. These are the four options ordered from fastest to slowest: `EXACT`, `FUZZY`, `WILDCARD`, and `REGEXP`.\n\nTo mirror some of the above queries with these matching strategies we get:\n\n```python\n# e3db setup...\n\n# fuzzy\n# generates an edit distance and matches terms that are 1-2 edits away from the provided query.\n# summer is 1 edit s-> b away from bummer\nfuzz_query = Search().match(strategy=\"FUZZY\", record_types=[\"season\"], values=[\"bummer\"])\n\n# wildcard\n# supported wildcards are * and ?\n# * matches any character sequence, including the empty sequence.\n# ? matches any single character\nwild_query = Search().match(strategy=\"WILDCARD\", record_types=[\"season\"], values=[\"su??er\"])\n\n# regexp\n# some of the support operators are ^ $ . ? + * | { } [ ] ( ) \\\n# refer to the table below for more information\nregxp_query = Search().match(strategy=\"REGEXP\", record_types=[\"season\"], values=[\"sum.*\"])\n```\n\nGo to [Pattern Search Examples](./examples/pattern_search.py) for more examples.\n\n#### Regexp operators\n\n```\n^ anchors expression to the start of the matched strings\n$ anchors expression to the end of the matched strings\n. represents any single character\n? used to match the preceding shortest pattern zero or one times\n+ used to match the preceding shortest pattern one or more times\n* used to match the preceding shortest pattern zero or more times\n| acts as an OR operator, matches this OR that\n{ } used to specify the min and max nubmer of times the preceding pattern can repeat.\n    - {2} repeat twice, {2,} repeat at least twice, {2,3} repeat 2-3 times\n( ) used to group sub patterns\n    - (ab)+ repeat the value within parenthesis 'ab' one or more times\n[ ] used to specify a range of characters\n    - [abc] matches 'a' or 'b' or 'c'\n    - within the square brackets a ^ negates the class: [^abc] excludes characters 'a', 'b', and 'c'\n\\ is used to escape any of the previous special characters\n```\n\nFor more information look [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)\n\nSee [the integration tests](e3db/tests/test_search_integration.py) or [examples folder](examples/) for more examples.\n\n### Paging\n\nThe construction of the Search object offers a number of options for paging through your results: namely `next_token` and `count`.\n\nTo page through a large number of results, you can loop like this:\n\n```python\n# e3db setup...\n# limit number of results returned to 1000 at a time\nquery = Search(count=1000).match(record_types=[\"many_results\"])\nresults = client.search(query)\n\n# Number of results in e3db\ntotal_results = results.total_results\n# Process the first set of results\nif total_results > 0:\n    do_something(results) # process results\n# If there are more records to fetch, e.g. next_token != 0\n# make subsequent searches using the next token to grab the next set of results\nwhile results.next_token:\n    query.next_token = results.next_token\n    results = client.search(query)\n    do_something(results) # process results\n```\n\nThe `next_token` returned from a query will be 0 if there are no more records to return. `total_results` represents the total number of records in e3db that match the executed query.\n\nSee [pagination example](examples/simple_paginate_results.py) for full code example.\n\n#### Search Count Restraints\n\nYou aren't limited to a specific number of searches, however for a single search the maximum page size is 1000. Requesting for a larger page size than 1000 (`count=1001`) will result in a HTTP 400 Bad Request. The pagination example, shown above, can be used to grab more than 1000 records overall.\n\n```\nquery = Search(count=1000)\n```\n\nAdditionally, if your search is too broad you will only be able to retrieve 10,000 results. You can choose to narrow your query by constricting time ranges manually or programatically as shown here with this [sample script](examples/narrow_range_of_large_search.py).\n\n### Large Files\n\nWhen searching or querying for large files, even if you set `include_data=True`, the data field returned will be blank. Instead file meta will be returned under each record's meta `record.meta.file_meta`. To download the file you can use the `e3db.Client.read_file` method like this:\n\n```python\n# e3db setup...\n\n# record_id retrieved from search...\nquery = Search().match(record_types=[\"large_file\"])\nresults = client.search(query)\n\n# download large files\nfor i, r in enumerate(results):\n    record_id = r.meta.record_id\n    dest = \"./large_file_{0}.txt\".format(i)\n    FileMeta = client.read_file(record_id, dest)\n```\n\n## Querying records\n\nE3DB supports many options for querying records based on the terms stored in record metadata. Refer to the API documentation for the complete set of options that can be passed to `e3db.Client.query`.\n\nFor example, to list all records of type `contact` and print a simple report containing names and phone numbers:\n\n```python\nimport e3db\n\nclient = e3db.Client(' config ')\n\nrecord_type = 'contact'\n\nfor record in client.query(record=[record_type]):\n    full_name = \"{0} --- {1}\".format(record.data['first_name'], record.data['last_name'])\n    print \"{0} --- {1}\".format(full_name, record.data['phone'])\n```\n\nIn this example, the `e3db.Client.query` method returns an iterator that contains each record that matches the query.\n\n## Notes\n\nNotes provide a mechanism to transfer or save data encrypted for a single specified set of cryptographic keys. These keys may or may not belong to another client in the TozStore system. This is a one way transfer. The writer of a note can not read it. The reader of the note can read it, but can not update or delete it. The writer and reader keys on a note can be the same.\n\nAt this time Notes are partially implemented in this SDK. You can not delete or update a note at this time. You can not read by note name or send an anonymous note.\n\n```python\nimport e3db\nfrom uuid import uuid4\n\n# Load default config in ~/.tozny/e3db.json\nconf = e3db.Config.load()\n\n# Now create a client using that configuration.\nclient = e3db.Client(conf)\n\n# Create Note Options object - must have a unique id_string\nnote_options = NoteOptions(\n    note_writer_client_id=client.client_id,\n    max_views=1, # use -1 to save for an indefinite number of reads\n    id_string=f\"globally-unique-note-name-{uuid4()}\",\n    expiration=expirationDate,\n    expires=False, \n    type='',\n    plain={},\n    file_meta={}\n)\n\ndata = {'lyrics' : 'What a wonderful world'}\n\n# Write a note to myself, use public encryption and signing keys of the reader here\nwritten = client.write_note(data, client.encryption_keys.public_key,\n                            client.signing_keys.public_key, note_options)\n\n# The write_note method returns a unique note_id which can be used for lookup\nread_by_id = client.read_note(written.note_id)\n\n# prints out \"What a wonderful world\"\nprint(read_by_id.data['lyrics'])\n```\n\n## Identity\nCurrently the Python SDK has limited implementation of the Tozny Identity primatives. The functionality exists to login an existing Identity created in the Tozny Identity console. Login from the Python SDK can be performed by calling the static identity_login method in the Identity class. The method requires the user_name, password, realm name and app name. An instance of the Identity class is returned, which includes the OAuth tokens necessary to interact with the Tozny Identity service along with a Storage Client. \n\nCurrently the Python SDK does not support Multi Factor Authentication (MFA) or Brokered login. \n\nThe parameter app_name can be the default account or a valid TozID application that supports API style login.\n\n```python\nfrom e3db.identity import *\n\nadmin_identity = identity_login('my_user_name', 'mypasswordphrase', 'realm_name', 'account')\n\n```\n\n## More examples\n\nSee [the simple example code](https://github.com/tozny/e3db-python/blob/master/examples/simple.py) for runnable detailed examples.\n\n## Cipher Suite Selection\n\nThe Python SDK is capable of operating in two different modes - Sodium and NIST. The Sodium mode uses [Libsodium](https://download.libsodium.org/doc/) for all cryptographic primitives. The NIST mode uses NIST-approved primitives via OpenSSL for all cryptographic primitives.\n\nThe SDK will operate in Sodium mode by default. To switch operation to NIST mode, export an environment variable before running any reliant applications:\n\n```sh\nexport CRYPTO_SUITE=NIST\n```\n\nThe NIST mode of operations will leverage:\n\n* ECDH over curve P-384 for public/private key exchange\n* SHA384 for hashing\n* ECDSA over curve P-384 for cryptographic signatures\n* AES256GCM for symmetric encryption operations\n\n## Documentation\n\nGeneral E3DB documentation is [on our web site](https://tozny.com/documentation/e3db/).\n\n## Contributing\n\nBug reports and pull requests are welcome on GitHub at <https://github.com/tozny/e3db-python>.\n\n## License\n\nTozny dual licenses this product. For commercial use, please contact [info@tozny.com](mailto:info@tozny.com). For non-commercial use, this license permits use of the software only by government agencies, schools, universities, non-profit organizations or individuals on projects that do not receive external funding other than government research grants and contracts. Any other use requires a commercial license. For the full license, please see [LICENSE.md](https://github.com/tozny/e3db-python/blob/master/LICENSE.md), in this source repository.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/tozny/e3db-python/archive/2.3.0.tar.gz",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/tozny/e3db-python",
    "keywords": "e3db,encryption,encrypted-store,tozstore",
    "license": "TOZNY NON-COMMERCIAL LICENSE",
    "maintainer": "",
    "maintainer_email": "",
    "name": "e3db",
    "package_url": "https://pypi.org/project/e3db/",
    "platform": "",
    "project_url": "https://pypi.org/project/e3db/",
    "project_urls": {
      "Download": "https://github.com/tozny/e3db-python/archive/2.3.0.tar.gz",
      "Homepage": "https://github.com/tozny/e3db-python"
    },
    "release_url": "https://pypi.org/project/e3db/2.3.0/",
    "requires_dist": [
      "PyNaCl (<2,>=1.3.0)",
      "requests (<3,>=2.4.2)",
      "Cryptography (>=2.2)"
    ],
    "requires_python": "",
    "summary": "E3DB provides a familiar JSON-based NoSQL-style API for reading, writing, and querying end-to-end encrypted data in the cloud.",
    "version": "2.3.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13340319,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "64ff83560725e159a102405b8599ca6bef2a27f7d17503f76c26e0c941c8942f",
        "md5": "bd6c40327048e71264f90ea9c6d53007",
        "sha256": "226f198a864653753de6f32c20d30c061987b0aec5d5f33fa197e5b9fa969cf4"
      },
      "downloads": -1,
      "filename": "e3db-2.3.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "bd6c40327048e71264f90ea9c6d53007",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 87862,
      "upload_time": "2021-07-28T23:47:55",
      "upload_time_iso_8601": "2021-07-28T23:47:55.471616Z",
      "url": "https://files.pythonhosted.org/packages/64/ff/83560725e159a102405b8599ca6bef2a27f7d17503f76c26e0c941c8942f/e3db-2.3.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a35dda561add0ff5fd51b43d9fdc0dcd0d3be123644e8217b1eed6a203236adb",
        "md5": "c51e380abee8ae46d58d99eaef37322c",
        "sha256": "9c386975aab829b6787f5c9bb3b8c5e96183c37ed2ffcba6df5e34e1ae575558"
      },
      "downloads": -1,
      "filename": "e3db-2.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "c51e380abee8ae46d58d99eaef37322c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 88785,
      "upload_time": "2021-07-28T23:47:59",
      "upload_time_iso_8601": "2021-07-28T23:47:59.599475Z",
      "url": "https://files.pythonhosted.org/packages/a3/5d/da561add0ff5fd51b43d9fdc0dcd0d3be123644e8217b1eed6a203236adb/e3db-2.3.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}