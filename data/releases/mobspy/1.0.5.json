{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "![Alt text](/images/img.png \"MobsPy\")\n\n# MobsPy\n\nWelcome to the Meta-Species Oriented Biosystem Syntax in Python repository. Mobspy was invented to facilitate the design of complex Chemical Reaction Networks. In this repository, one can find the first implementation of this language and a simulation tool to simulate models generated by it. The simulation tool has both deterministic and stochastic compatibility.\n\n# Getting started \n\nTo get started, you only need to pip install:\n\n\tpip install mobspy \n\nAnd check out some example tutorial models in either the example_model folder or the notebook directory in this repository.\n\n# How it works\n\nMeta-Species are sets of species. Using them allows users to assign reactions to the entire set or a subset by querying. The Meta-Species are based around a reaction inheritance system and independent state spaces.\n\n## Basic syntax\n\nTo create species from scratch, use the BaseSpecies function that takes as an argument the number of species one wants to make. To assign rates, one can define reactions using the '>>' operator and the brackets '[]'. To assign counts, use the call operator. An elementary example is the following:\n\n\tA, B, C, D = BaseSpecies(4)\n\tA(200) + B(100) >> 2*C + D [420]\n\tMySim = Simulation(A | B | C | D)\n\tMySim.run()\n\n## Inheritance\n\nFor instance:\n\n\tMortal = BaseSpecies()\n\tMortal >> Zero [1]\n\nThe reaction above is a death reaction where the Meta-Species Mortal is dying. Zero is the MobsPy variable for representing nothing. We can design new Meta-Species from other Meta-Species using either the multiplication or the New() constructor. \n\n\tReplicator, Triplicator = New(Mortal, 2)\n\tReplicator >> 2*Replicator [1]\n\tTriplicator  >> 3*Triplicator [1]\n\tMultiplicator = Replicator*Triplicator \n\nIn the code above, one can visualize the inheritance mechanism. Here both Replicator and Triplicator inherit from Mortal. Therefore, they also receive a death reaction. Multiplicator inherits from Replicator and Triplicator, and therefore from Mortal too. So Multiplicator now has three reactions, the death reaction, the duplication reaction, and the triplication reaction. \n\n## Indepedent State Spaces\n\nEach Meta-Species has a set of states. One can add states to species by using the dot command ('.state') or by inheritance. A Meta-Species that inherits from another gains access to its states. \nFor instance:\n\n\tHorned, Color = BaseSpecies(2)\n\tHorned.small_horn >> Horned.big_horn [1]\n\tColor.white >> Color.rainbow [1]\n\tUnicorn = Horned*Color\n\tUnicorn.rainbow >> 2*Unicorn.white [1]\n\nUnicorn has the states of both Horned and color in the code above and their reactions. Unicorn species will be formed by the name followed by a dot and a state for each species inheritors for all possible combinations. So here we have the species - Unicorn.small_horn.white, Unicorn.big_horn.white, Unicorn.small_horn.rainbow, Unicorn.big_horn.rainbow. \n\nThe states can be used in the reactants to assign a reaction only to the correct subset. Here only the rainbow unicorns can duplicate. Finally, the states on the products refer to transformations of states that originate from the same Meta-Species. So here, all the rainbow Unicorns become white after multiplying since both states come from the Meta-Species color. \n\n# Simulation\n\nJust use the Simulation constructor and the run command to execute a simulation. The Simulation command must receive all the Meta-Species the user wants to simulate as an argument. For the unicorn example, one could code:\n\n\tMySim = Simulation(Unicorn)\n\tMySim.run()\n\n# Parameter definition\n\nThe parameters are defined using the dot notation on the simulation object. For standard parameters, use the dot notation directly, and for plotting parameters, use the '.plot.parameter' model.\nStandard parameters can also be configured using a JSON file with the .set_from_json method. As an example, we have the code below:\n\n\tMySim.save_data = False\n\tMySim.plot_data = False\n\tMySim.duration = 100\n\tMySim.repetitions = 10\n\tMySim.plot.xlim = [0,1]\n\tMySim.plot.ylim = [0, 1e3]\n\nFor a list of parameters, check the read_me in the parameter directory. The standard parameters can be found in the get_default_parameters() script in the default_reader() script.\n\n# Units\n\t\nThe variable u from the pint python module for unit handling is used to assign units to values in Mobspy. Just add 'u.name_of_the_unit', and MobsPy will handle it. As a code example, we have:\n\n\tA(100*u.molar)\n\tA >> Zero [10/u.nanosecond]\n\n# Compiling\n\nBefore simulating, you might want to use the compile method from the Simulation class. The compile function prints all the species, mappings (Meta-Species and species relation), parameters, and reactions. Thus, allowing one to check their model before simulation and executing. \n\n# Calculations\n\nMobsPy generates an SBML string for each model. The SBML string is passed to basiCO (COPASI in Python), and they handle the calculations. MobsPy returns the data to the user in the Simulation object and a JSON file.\n\nFor the rates, MobsPy considers mass action kinetics as default. For different, more complex rates, one can use strings.\n\n# Compatibility\n\nFor now MobsPy is not thread-safe and it's not compatible with numpy and deepcopy",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ROBACON/mobspy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mobspy",
    "package_url": "https://pypi.org/project/mobspy/",
    "platform": null,
    "project_url": "https://pypi.org/project/mobspy/",
    "project_urls": {
      "Homepage": "https://github.com/ROBACON/mobspy"
    },
    "release_url": "https://pypi.org/project/mobspy/1.0.5/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "A Query-Based Language for Chemical Reaction Networks",
    "version": "1.0.5",
    "yanked": true,
    "yanked_reason": "Born species bug"
  },
  "last_serial": 14701166,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fe59901ffe8a6d60395c24faa247183ecc54ebe5609824fe95184b21e6d8a197",
        "md5": "f56c97af7c2fecd087213409f800f3d1",
        "sha256": "70966232a8c5dee60081c2a9863b52b76d6d82d8c30b1f71fc81150c5e0b5f67"
      },
      "downloads": -1,
      "filename": "mobspy-1.0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "f56c97af7c2fecd087213409f800f3d1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 63322,
      "upload_time": "2022-05-08T13:28:04",
      "upload_time_iso_8601": "2022-05-08T13:28:04.379074Z",
      "url": "https://files.pythonhosted.org/packages/fe/59/901ffe8a6d60395c24faa247183ecc54ebe5609824fe95184b21e6d8a197/mobspy-1.0.5.tar.gz",
      "yanked": true,
      "yanked_reason": "Born species bug"
    }
  ],
  "vulnerabilities": []
}