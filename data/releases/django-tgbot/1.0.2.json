{
  "info": {
    "author": "Alireza Khoshghalb",
    "author_email": "alirezakhoshghalb@ymail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 3.0",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Internet :: WWW/HTTP",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content"
    ],
    "description": "# Telegram Bots in Django\n\nBot API version 4.6 ([Telegram bot API docs](https://core.telegram.org/bots/api))\n\n### Quick Setup\n\n1. Install package from pip:  \n    ```\n    pip install django-tgbot\n    ```\n\n2. Add `django_tgbot` to your Django project's `INSTALLED_APPS`\n\nThat's it :) You installed django-tgbot.\n\n<hr>\n\n### Create a new Telegram bot\n1. Create a bot in Telegram using [BotFather](https://t.me/BotFather) and receive your API token\n2. Open the Django project with `django-tgbot` installed in it\n3. Enter this command in the command line (terminal / cmd):\n    ```\n    python manage createtgbot\n    ```\n4. Enter your API token:\n    ```\n    > python manage.py createtgbot\n    Enter the bot token (retrieved from BotFather): <YOUR_TOKEN>\n    Setting up @BotDevTestBot ...\n    ```\n5. Enter the URL your Django project is deployed on. If your project is not deployed yet and is not accessible, press Enter to skip. (If you have not deployed yet and want to test your bot, you can use services like [Ngrok](http://ngrok.com) to do so)\n    ```\n    Enter the url of this project to set the webhook (Press Enter to skip): https://URL.com\n    Bot webhook will be set to https://URL.com/botdevtestbot/update/. Do you confirm? (Y/N): y\n    Webhook was successfully set.\n    ```\n\n6. A new app will be created in your Django project. Add this app to your `INSTALLED_APPS`\n7. Include this new app's urls in your project urls as described in the output of the above command\n8. Update the database:\n    ```\n    python manage.py migrate\n    ```\n\nYour bot is created! If you have set the webhook correctly you can now send messages to your bot and it responds all messages with `Hello!`.\n\n<b> Overview of the process: </b>\n\n```\n> python manage.py createtgbot\nEnter the bot token (retrieved from BotFather): 521093911:AAEe6X-KTJHO98tK2skJLsYJsE7NRpjL8Ic\nSetting up @BotDevTestBot ...\nEnter the url of this project to set the webhook (Press Enter to skip): https://URL.com\nBot webhook will be set to https://URL.com/botdevtestbot/update/. Do you confirm? (Y/N): y\nWebhook was successfully set.\nSuccessfully created bot Test Bot(@botdevtestbot).\nNext steps:\n\t1. Add 'botdevtestbot' to INSTALLED_APPS in project settings\n\t2. Add `from botdevtestbot import urls as botdevtestbot_urls` to project urls file\n\t3. Add `path('botdevtestbot/', include(botdevtestbot_urls))` to project urls' urlpatterns\n\t4. `python manage.py migrate`\nEnjoy!\n```\n\n<hr>\n\n### Definitions\n<b>It is important to understand these definitions in order to read the rest of the doc or to use the package. We encourage you to also read the \n<i>Definitions</i> section in the full documentations. You can find a link to the full documentations at the end of this document.</b>\n\nThis is an overview of the flow:\n\nBot receives a message/update --> Telegram sends an Update to your webhook --> Django receives this request and passes it to the app created for this bot (In steps above) --> `django_tgbot` creates an `Update` object from the HTTP request --> One or several `processor`s will be assigned to handle this `Update` --> All of these `processor`s will run and possibly make some calls to Telegram API.\n\n#### Types\nTelegram uses some methods and `Type`s (think of this types as classes) to handle everything. All of these types are implemented as Python classes and you can use them from `django_tgbot.types`. You can view a full list of all Telegram available types [here](https://core.telegram.org/bots/api#available-types) (The API version based on which this package is designed is written at the top of this document. With newer versions there might be new types not implemented in this package)\n\n#### Models\nEach new bot you create comes prepackaged with 3 models:\n* <b>TelegramUser</b>: represents a user in Telegram. Can be a person or a bot. Basically, it is an entity that can send messages.\n* <b>TelegramChat</b>: represents a chat in Telegram. Can be a private chat, a group, a supergroup or a channel. Basically, it is a place that messages can be sent from one or several parties.\n* <b>TelegramState</b>: From the bot's perspective, each user in a chat or a chat by itself or a user by itself, are in a state. This state is stored in `TelegramState` model. It holds the user (can be blank), the chat (can be blank), a memory and a name. This name helps the bot to easily determine what this state is and what needs to be done.\n\n#### Bot\nWhen you create a new bot, an app will be created which has a new class named `TelegramBot` and a bot instantiated from this class. This is your interface for working with the Telegram Bot API.\n\nFor every request it receives, it will do some preprocessing and then finds the `processor`s responsible for this request and runs all of them. Finally, it will do some post-processings.\n\nThe mentioned preprocessing and post-processings can be changed or removed from the Bot class in `bot.py` in your newly created app. By default, for all requests, the user's `id`, `first_name`, `last_name` and `username` and the chat's `id`, `title` and `type` will be stored in database in the preprocessing and nothing is done in the postprocessing.\n\n#### Processors\n\nThis is the core of your bot's functionality and for this you write most of your codes.\n\nSo far, we have seen every client of our bot (a user with/without a chat or a chat itself) has a state (i.e. is in a state). Processors take a client with its state and based on their state and the sent update, they will forward this client to another state.\n\nEach processor should declare the states from which clients can enter and the state to which clients should be sent in case processor ran successfully or in case it failed.\n\nProcessors are just Python functions that take the bot instance, the update received from Telegram and the state of the client as input.\n\n\n<hr>\n\n### Developing your bot\n\nWhen you create a new bot, a new app will be created in your Django project which will contain a file named `processors.py`. This module is where all your processors lie. You can also remove this file and instead, create a package with the same name in the same directory since the number of processors might get large and it's a good idea to keep them separated in different modules. If you do so, do not forget to import all of these modules in the `__init__.py` of `processors` package.  \nIf you replace `processors.py` with a `processors` package:\n\n```\nprocessors\n├── __init__.py\n├── greetings.py\n├── signup.py\n└── ...\n```\n\nWhere `__init__.py` contains:\n```\nfrom . import greetings, signup, ...\n```\n\nInitially, there is a `hello_world` processor available in `processors.py`. As you can see, all of your processors should get registered by `@processor` decorator in order to be recognized later by the bot. They should also take three named parameters (like the `hello_world` sample):\n* <b>bot</b>: An instance of the TelegramBot. Can be used to call Telegram API (sending messages, etc.)\n* <b>update</b>: The received update loaded into the `Update` type explained above.\n* <b>state</b>: The state of this client, a TelegramState instance. You can change their state or memory using this.\n\nAs said earlier, each processor should declare what states it accept to process and if processing was done successfully, what should the client's state become and what should it become if the processing fails.\n\nThese are declared above the function definition in the `@processor` arguments:\n* <b>from_states</b>: Name of the accepting states for this processor. It can be a <i>string</i>, a <i>list</i> or `state_types.All` which will accept all states. If you want to accept the empty (reset) state (the client's state is initially empty and it's a good idea to use empty string as a reset state), leave it blank or set it as `from_states = ''` or `from_states = state_types.Reset`.\n* <b>success</b>: The new state of the client, if processor runs successfully. \"successfully\" means being run without raising `ProcessFailure` exception.\n* <b>fail</b>: The new state of the client, if processor fails to run. If you want to fail the processor you should raise `ProcessFailure`. This exception can be imported from `django_tgbot.exceptions`.\n\nYou may use `state_types.Keep` as the value for `success` or `fail` to not change the state or use `state_types.Reset` to reset the state.\n\nAdditionally, you can define the update types and the message types you want this processor to handle. For example, you may want to have a processor that only handles requests regarding a message getting edited (which is a different update type than receiving a new message) or you may want to have a processor only handling requests of video messages (which is a different message type than text messages). To see a full list of different updates types and message types read Telegram Bot API docs. Parameters for `@processor`:\n* <b>message_types</b>: Can be a single value or a list of values. Leave unfilled to accept any message type. Use values from `message_types` module to fill in the parameter. For example you can say `message_types = message_types.Text` to only handle text messages or `message_types = [message_types.NewChatMembers, message_types.LeftChatMembers]` to handle updates about group members coming and going.\n* <b>exclude_message_types</b>: Works exactly like `message_types` except that values passed here will be excluded from the valid message types to handle.\n* <b>update_types</b>: Can be a single value or a list of values. Leave unfilled to accept any update type. Like the message_updates, available update_types are accessible from the `update_types` module. For example, `update_types = [update_types.ChannelPost, update_types.EditedMessage]` makes the processor handle only updates about a new post being sent to a channel or a message being edited.\n* <b>exclude_update_types</b>: Works exactly like `update_types` except that values passed here will be excluded from the acceptable update types to handle.\n\nPlease note that the first parameter for `@processor` should be always an state manager. An state manager is created automatically when you create a new bot and it's imported in the processors module. You can use that and give it to all of the processors. You may change this state manager to have different behaviors in your bot, which is not a common case and will be explained in advanced documentations.\n\nExample of a processor definition:\n```python\n@processor(state_manager, from_states='asked_for_name', success='got_their_name', fail=state_types.Keep, message_types=message_types.Text, update_types=update_types.Message)\ndef say_hello(bot, update, state):\n    bot.sendMessage(update.get_chat().get_id(), \"Hello {}!\".format(update.get_message().get_text()))\n```\n\nYou may also leave the `success` and `fail` arguments in order to not change the state automatically, if you want to change it yourself in the processor:\n\n```python\n@processor(state_manager, from_states='asked_for_name', message_types=message_types.Text, update_types=update_types.Message)\ndef say_hello(bot, update, state):\n\ttext = update.get_message().get_text()\n    if text == 'Alireza':\n   \t\tbot.sendMessage(update.get_chat().get_id(), \"Hello Alireza!\")\n        state.name = 'got_their_name'\n        state.save()\n    else:\n    \tbot.sendMessage(update.get_chat().get_id(), \"Nah\")\n        state.name = 'failed_to_give_name'\n        state.save()\n```\n\nPlease note that leaving the `success` and `fail` parameters without a value is NOT the same as setting them to `state_types.Keep`. Leaving them will not change them and allows you to set them in the processor's run time. However, setting them to `state_types.Keep` will force the state to be the same as what is was before entering the processor.\n\n### Using the API methods\n\nThe interface you can use for sending requests to the Bot API is the TelegramBot class and an instance of it will be created when you start a new bot.\n\nAll of the methods on Telegram API are implemented in this class. Furthermore, if you want to send any custom request or call any method, you can use the method `send_request` to do so.\n\nYou should have a look at the API documentations while calling methods as they might have certain requirements on some arguments. For example, `parse_mode` argument on some methods,\nonly accepts a few fixed strings and inline keyboards have three optional fields that exactly one of them should be filled with a value.\n\nYou might need to use the defined `Type`s to create and pass data more easily, in cases that Telegram expects a certain type as the value for some parameter. For example,\nif you want to send a keyboard as the `reply_markup` for some message, you can create the keyboard object with the `ReplyKeyboardMarkup` object and pass\nit as the value. Please note that `Type` classes' constructor is designed to accept a JSON object. If you want to create an instance of such classes,\nyou should use another method called `a`. \n\nAll of the `Type`s have a method called `a` that allow you to create an object of that type. They get the parameters and validate them and return an object of that type.\nFor example, if you want to create a keyboard with two buttons one saying `A` and other saying `B` this is how you create it:\n```python\nkeyboard = ReplyKeyboardMarkup.a(keyboard=[\n    [KeyboardButton.a(text='A'), KeyboardButton.a(text='B')]\n])\n```\n\nAll `Type` classes also have a `to_dict` and `to_json` method that may help you in some scenarios. For more information see the package docs.\n\n<hr>\n\n### Final Notes\n* As explained earlier, some API methods have certain requirements for some of their parameters. One of them is the `reply_markup` parameter for all of the methods that have it.\nThis parameter should be passed as a JSON object. However, since it is a very common parameter to use in a lot of methods, if you pass this as a `Type` (e.g. `ReplyKeyboardMarkup` or `InlineKeyboardMarkup`) \nit will be converted to JSON automatically.\n* To send a file when using methods that accept it (such as `sendPhoto` or `sendDocument`), if you are going to upload the file (and not providing the file url or file id), set the `upload` argument to `True` and pass the opened file to the according argument. For example:\n`bot.sendPhoto(chat_id, photo=open('my_file.png', 'rb'), upload=True)`\n\n\n### Links\n* A demo bot created with `django-tgbot`: [https://github.com/ARKhoshghalb/django-tgbot_demo](https://github.com/ARKhoshghalb/django-tgbot_demo)  \n* Full documentation: [https://django-tgbot.readthedocs.io/en/latest/](https://django-tgbot.readthedocs.io/en/latest/)",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://www.github.com/ARKhoshghalb/django-tgbot",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-tgbot",
    "package_url": "https://pypi.org/project/django-tgbot/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-tgbot/",
    "project_urls": {
      "Homepage": "https://www.github.com/ARKhoshghalb/django-tgbot"
    },
    "release_url": "https://pypi.org/project/django-tgbot/1.0.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "A Django app to create Telegram bots.",
    "version": "1.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14679224,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "acda5ae425e141e717b2327559030a1b0ba748b1ecbb77bda4a1e18f6162f207",
        "md5": "63ee682ffd897ef3af00d3d9aaf1b4c6",
        "sha256": "ac68e771e74748768f7de11f209dba95cfccfdbd91c294955a6a903ca0ea4e94"
      },
      "downloads": -1,
      "filename": "django-tgbot-1.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "63ee682ffd897ef3af00d3d9aaf1b4c6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 43095,
      "upload_time": "2020-02-06T03:39:27",
      "upload_time_iso_8601": "2020-02-06T03:39:27.086103Z",
      "url": "https://files.pythonhosted.org/packages/ac/da/5ae425e141e717b2327559030a1b0ba748b1ecbb77bda4a1e18f6162f207/django-tgbot-1.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}