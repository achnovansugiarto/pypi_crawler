{
  "info": {
    "author": "Robert Grzesik",
    "author_email": "rob@lumiwealth.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "README\n-------\n\nThis library is covered by the MIT license for open sourced software which can be found here: https://github.com/Lumiwealth/lumibot/blob/master/LICENSE\n\n# Quickstart\n\nCurrently Alpaca and Interactive Brokers are available as a brokerage services. This \nquickstart is about using Alpaca services. After the quickstart will be instructions \nspecific to Interactive Brokers.\n\n1) Install the package on your computer\n```shell\npip install lumibot\n```\n2) Create an alpaca paper trading account: https://app.alpaca.markets/paper/dashboard/overview\n3) Copy your API_KEY and API_SECRET from alpaca dashboard \n   and create a credentials.py file in the root directory of this project with the following class:\n```python\nclass AlpacaConfig:\n    API_KEY = \"YOUR ALPACA API KEY\"\n    API_SECRET = \"YOUR ALPACA API SECRET\"\n```\n```API_KEY``` and ```API_SECRET``` are obtained from alpaca paper trading dashboard: https://app.alpaca.markets/paper/dashboard/overview\n\n4) Create your own strategy class (See strategy section) e.g. ```class MyStrategy(Startegy)```\nor import an example from our libraries\n   \n```python\nfrom lumibot.strategies.examples import Momentum\n```\n\n5) Create another file meant to be the entrypoint of your code e.g. main.py\n6) import the following modules in your main.py:\n```python\n# importing the trader class\nfrom lumibot.traders import Trader\n# importing the alpaca broker class\nfrom lumibot.brokers import Alpaca\n# importing the credential class created in step 2\nfrom credentials import AlpacaConfig\n# importing the strategy class created in step 3\nfrom lumibot.strategies.examples import Momentum\n```\n7) In your main.py, define variables for the budget allocated to your strategy. \n   Additionally, define the destination of the logfile.\n```python\nbudget = 40000\nlogfile = \"logs/test.log\"\n```\n8) Instantiate the ```Trader``` class and the ```Alpaca``` class like so:\n```python\ntrader = Trader(logfile=logfile)\nbroker = Alpaca(AlpacaConfig)\n```\nThe ```Alpaca``` broker class needs your credentials created in step 3 to loging to your paper trading account.\n\n9) Instantiate your strategy class like so:\n```python\nstrategy = Momentum(name=\"momentum\", budget=budget, broker=broker)\n```\n10) Register the strategy within the trader\n```python\ntrader.add_strategy(strategy)\n```\n11) Run the trader\n```python\ntrader.run_all()\n```\n\nBelow an example of main.py:\n```python\n# main.py\nfrom lumibot.traders import Trader\nfrom lumibot.brokers import Alpaca\nfrom lumibot.strategies.examples import Momentum\nfrom credentials import AlpacaConfig\n\nbudget = 40000\nlogfile = \"logs/test.log\"\n\ntrader = Trader(logfile=logfile)\nbroker = Alpaca(AlpacaConfig)\n\nstrategy = Momentum(name=\"momentum\", budget=budget, broker=broker)\ntrader.add_strategy(strategy)\ntrader.run_all()\n```\n\n# Interactive Brokers\n\nTo trade in your interactive brokers account, you must install Trader Workstation \n(or Gateway). Instructions for installation can be found [here](https://interactivebrokers.github.io/tws-api/initial_setup.html).\n\nOnce installed, navigate in Trader Workstation to `File/Global Configuration/ then \nAPI/Settings` The key settings required to trade using Lumibot are: \n  - Enable ActiveX and Socket Clients\n  - Disable Read-Only API\n  - Socket port `7496` for live trading, `7497` for paper account trading. \n    > It is highly recommended to thoroughly test your algorithm in paper trading mode \n    before trading live.\n  - Master API Client ID: You can find in the Trader Workstation by going to File -> Global Configurations -> API -> Settings, then looking for \"Master API client ID\". This can be any number you choose up to 999. You will use \n    this in your configuration file to log in.\n\nSet up your `credentials.py` file as follows: \n    \n    class InteractiveBrokersConfig:\n        SOCKET_PORT = 7497 \n        CLIENT_ID = \"your Master API Client ID three digit number\"\n        IP = \"127.0.0.1\"\n\nSet up your entry point file as above, except using Interactive Brokers. Here is an \nexample of a completed file: \n\n```python\n# main.py\nfrom lumibot.traders import Trader\nfrom lumibot.brokers import InteractiveBrokers\nfrom lumibot.strategies.examples import Strangle \nfrom credentials import InteractiveBrokersConfig\n\nbudget = 40000\nlogfile = \"logs/test.log\"\n\ntrader = Trader(logfile=logfile)\ninteractive_brokers = InteractiveBrokers(InteractiveBrokersConfig)\n\nstrategy = Strangle(name=\"option\", budget=budget, broker=interactive_brokers)\ntrader.add_strategy(strategy)\ntrader.run_all()\n```\n\nYou can also see the file `simple_start_ib.py` for a working bot\n\n# Backtesting\n\nYou can also run backtests very easily on your strategies, you do not have to \nmodify anything in your strategies. (Intraday and options backtests are not available at this time.)\nSimply call the `backtest()` function on your strategy class. You will also have the \ndetails of your backtest (the portfolio value each day, unspent money, etc) \nput into a CSV file in the location of `stats_file`.\n\n```python\nfrom lumibot.backtesting import YahooDataBacktesting\nfrom my_strategy import MyStrategy\n\nfrom datetime import datetime\n\n# Pick the dates that you want to start and end your backtest\n# and the allocated budget\nbacktesting_start = datetime(2020, 1, 1)\nbacktesting_end = datetime(2020, 12, 31)\nbudget = 100000\n\n# Run the backtest\nstats_file = \"logs/my_strategy_backtest.csv\"\nMyStrategy.backtest(\n    \"my_strategy\",\n    budget,\n    YahooDataBacktesting,\n    backtesting_start,\n    backtesting_end,\n    stats_file=stats_file,\n)\n```\n\n## Example Strategies\n\nLumibot provides a set of several example strategies that you can copy from to create \nyour own, they are located in `lumibot->strategies->examples`. Here is a breakdown of each example strategy:\n\n#### Diversification\nAllocates the budget by the percent allocations set in self.portfolio and rebalances every self.\nperiod days. For example, if there is a budget of $100,000 then the strategy will buy $30,000 SPY, \n$40,000 TLT, etc. at current default weights in the strategy. The strategy will then buy/sell \nassets every day depending on self.portfolio_value (the amount of money available in this \nstrategy) so that the target percentages laid out in self.portfolio are achieved.\n\n#### Intraday Momentum\nBuys the best performing asset from self.symbols over self.momentum_length number of minutes.\nFor example, if TSLA increased 0.03% in the past two minutes, but SPY, GLD, TLT and MSFT only \nincreased 0.01% in the past two minutes, then the strategy will buy TSLA.\n\n#### Momentum\nBuys the best performing asset from self.symbols over self.period number of days.\nFor example, if SPY increased 2% yesterday, but VEU and AGG only increased 1% yesterday,\nthen the strategy will buy SPY.\n\n#### Simple\nBuys and sells 10 of self.buy_symbol every day (not meant to make money, just an example).\nFor example, Day 1 it will buy 10 shares, Day 2 it will sell all of them, Day 3 it will \nbuy 10 shares again, etc.\n\n#### Strangle\nAn options strategy trading through Interactive Brokers only. A simple strangle \nstrategy where the bot simultaneously buys an out-of-the-money call and an \nout-of-the-money put option. The call option's strike price is higher than the \nunderlying asset's current market price, while the put has a strike price that is \nlower than the asset's market price.\n\n# Entities\n\n## asset\n\nAn asset object represents securities such as stocks or options in Lumibot. Attributes \nthat are tracked for assets are: \n  - symbol(str): Ticker symbol representing the stock or underlying for options. So for \n    example if trading IBM calls the symbol would just be `IBM`. \n  - asset_type(str): Asset type can be either `stock` or `option`. default: `stock`\n  - name(str): Optional to add in the name of the corporation for logging or printout.  \n  #### Options only\n  - expiration (str): Expiration of the options contract. Format is \"YYYYMMDD\".\n  - strike(float): Contract strike price.\n  - right(str): May enter `call` or `put`.\n  - multiplier(float): Contract multiplier to the underlying. (default: 1)\n\nWhen creating a new security there are two options. \n1. Security symbol: It is permissible to use the security symbol only when trading \n   stocks. Lumibot will convert the ticker symbol to an asset behind the scenes.\n   \n2. Asset object: Asset objects may be created at anytime for stocks or options. For \n   options asset objects are mandatory due to the additional details required to \n   identify and trade options. \n   \nAssets may be created using the `create_asset` method as follows: \n  `create_asset(symbol, asset_type=`option`, **kwargs)` \n    * see attributes above.\n\n## bars\n\nThis object is a wrapper around pandas dataframe and contains bars data. The raw pandas dataframe\nobject corresponds to ```bars.df```. The dataframe has the following columns\n- open\n- high\n- low\n- close\n- volume\n- dividend\n- stock_splits\n\nThe dataframe index is of type ```pd.Timestamp``` localized at the timezone ```America/New_York```.   \n\nBars objects have the following fields:\n- source: the source of the data e.g. (yahoo, alpaca, ...)\n- symbol: the symbol of the bars\n- df: the pandas dataframe containing all the datas\n\nBars objects has the following helper methods:\n- ```get_last_price()```: returns the closing price of the last dataframe row\n- ```get_last_dividend()```: returns the dividend per share value of the last dataframe row\n- ```get_momentum(start=None, end=None)```: calculates the global price momentum of the dataframe.\n\nWhen specified, start and end will be used to filter the daterange for the momentum calculation.\n  If none of ``start`` or ``end`` are specified the momentum will be calculated from the first row untill\n  the last row of the dataframe.\n- ```get_total_volume(start=None, end=None)```: returns the sum of the volume column. \n  When ```start``` and/or ```end``` is/are specified use them to filter for that given daterange\n  before returning the total volume\n- ```filter(start=None, end=None)```: Filter the bars dataframe.\n  When ```start``` and/or ```end``` is/are specified use them to filter for that given daterange\n  before returning the total volume\n\nWhen getting historical data from Interactive Brokers, it is important to note that they do not\nconsider themselves a data supplier. If you exceed these data access pacing rates, your data\nwill be throttled. Additionally, with respect to above three mentioned helpers, when using \nInteractive Brokers live, tick data is called instead of bar data. This allows for more frequent \nand accurate pricing updates. `get_last_dividend` are not available in Interactive Brokers. (see \n[Interactive Brokers' pacing rules](https://interactivebrokers.github.\nio/tws-api/historical_limitations.html))\n\n## order\n\nThis object represents an order. Each order belongs to a specific strategy. \n\nA simple market order can be constructed as follows:\n\n```python\nstrategy_name = \"Test Strategy\"\nsymbol = \"SPY\"\nquantity = 50\nside = \"buy\"\norder = self.create_order(strategy_name, symbol, quantity, side)\n```\n\nWith:\n- strategy_name (str): the strategy name that this order belongs to\n- symbol (str): the string representation of the asset e.g. \"GOOG\" for Google\n- quantity (int): the number of shares to buy/sell\n- side (str): must be either ```\"buy\"``` for buying order or ```\"sell\"``` for selling order\n\nOrder objects have the following helper methods\n- ```to_position()```: convert an order to a position belonging to the same strategy with \n```order.quantity``` amount of shares.\n- ```get_increment()```: for selling orders returns ```- order.quantity```, for buying orders returns ```order.quantity```\n- ```wait_to_be_registered```: wait for the order to be registered by the broker\n- ```wait_to_be_closed```: wait for the order to be closed by the broker (Order either filled or closed)\n\n### advanced order types\n\n#### limit order\n\nA limit order is an order to buy or sell at a specified price or better.\n\nTo create a limit order object, add the keyword parameter `limit_price`\n\n```python\nmy_limit_price = 500\norder = self.create_order(strategy_name, symbol, quantity, side, limit_price=my_limit_price)\nself.submit_order(order)\n```\n\n#### stop order\n\nA stop (market) order is an order to buy or sell a security when its price moves past a particular point, ensuring a higher probability of achieving a predetermined entry or exit price.\n\nTo create a stop order object, add the keyword parameter `stop_price`.\n\n```python\nmy_stop_price = 400\norder = self.create_order(strategy_name, symbol, quantity, side, stop_price=my_stop_price)\nself.submit_order(order)\n```\n\n#### stop_limit order\n\nA stop_limit order is a stop order with a limit price (combining stop orders and limit orders)  \n\nTo create a stop_limit order object, add the keyword parameters `stop_price` and `limit_price`.\n\n```python\nmy_limit_price = 405\nmy_stop_price = 400\norder = self.create_order(strategy_name, symbol, quantity, side, stop_price=my_stop_price,               limit_price=my_limit_price)\nself.submit_order(order)\n```\n\n#### trailing_stop order\n\nTrailing stop orders allow you to continuously and automatically keep updating the stop price threshold \nbased on the stock price movement.\n\nTo create trailing_stop orders, add either a `trail_price` or a `trail_percent` keyword parameter.\n\n```python\nmy_trail_price = 20\norder_1 = self.create_order(strategy_name, symbol, quantity, side, trail_price=my_trail_price)\nself.submit_order(order_1)\n\nmy_trail_percent = 2.0 # 2.0 % \norder_2 = self.create_order(strategy_name, symbol, quantity, side, trail_percent=my_trail_percent)\nself.submit_order(order_2)\n```\n\n> *** NOTE: Advanced type of orders work as normal in live trading, but will be ignored in \nbacktesting. Meaning that a backtest will assume limit and stop orders were never executed.\n\n### order with legs\n\n#### bracket order\n\nA bracket order is a chain of three orders that can be used to manage your position entry and exit.\n\nThe first order is used to enter a new long or short position, and once it is completely filled, \ntwo conditional exit orders will be activated. One of the two closing orders is called a \ntake-profit order, which is a limit order, and the other closing order is a stop-loss order, \nwhich is either a stop or stop-limit order. \nImportantly, only one of the two exit orders can be executed. Once one of the exit orders fills, \nthe other order cancels. Please note, however, that in extremely volatile and fast market \nconditions, both orders may fill before the cancellation occurs.\n\nTo create a bracket order object, add the keyword parameters `take_profit_price` and `stop_loss_price`.\nA `stop_loss_limit_price` can also be specified to make the stop loss order a stop-limit order.\n\n```python\nmy_take_profit_price = 420\nmy_stop_loss_price = 400\norder = self.create_order(\n  strategy_name, symbol, quantity, side, \n  take_profit_price=my_take_profit_price,\n  stop_loss_price=my_stop_loss_price\n)\nself.submit_order(order)\n```\n> Interactive Brokers requires the main or parent order to be a limit order. Add  \n> `limit_price=my_limit_price`. \n\n#### OTO (One-Triggers-Other) order \n\nOTO (One-Triggers-Other) is a variant of bracket order. \nIt takes one of the take-profit or stop-loss order in addition to the entry order.\n\nTo create an OTO order object, add either a `take_profit_price` or a `stop_loss_price` keyword parameter.\nA `stop_loss_limit_price` can also be specified in case of stop loss exit.\n\n> Interactive Brokers requires the main or parent order to be a limit order. Add \n> `limit_price=my_limit_price`. \n\n#### OCO (One-Cancels-Other) order\n\nOCO orders are a set of two orders with the same side (buy/buy or sell/sell).\nIn other words, this is the second part of the bracket orders where the entry order is already filled, \nand you can submit the take-profit and stop-loss in one order submission.\n\nTo create an OCO order object, add the keyword parameters `take_profit_price` and `stop_loss_price`\nand set `position_filled` to `True`. \nA `stop_loss_limit_price` can also be specified to make the stop loss order a stop-limit order.\n\n```python\nmy_take_profit_price = 420\nmy_stop_loss_price = 400\norder = self.create_order(\n  strategy_name, symbol, quantity, side, \n  take_profit_price=my_take_profit_price,\n  stop_loss_price=my_stop_loss_price,\n  position_filled=True\n)\nself.submit_order(order)\n```\n> Interactive Brokers requires the main or parent order to be a limit order. Add `limit_price=my_limit_price`. \n\n*** NOTE: Orders with legs work as normal in live trading, but will be ignored in backtesting. Meaning that a backtest will never execute the order legs.\n\n## position\n\nThis object represents a position. Each position belongs to a specific strategy.\nPosition object has the following properties\n- strategy (str): the strategy name that this order belongs to\n- symbol (str): the string representation of the asset e.g. \"GOOG\" for Google\n- quantity (int): the number of shares held\n- orders (list(order)): a list of orders objects responsible for the current state of the position\n\nPosition objects have also the following helper methods\n- ```get_selling_order()```: returns an order for selling all the shares attached to this position.\n\n# Strategies\n\n## Strategy\n\nAll user defined strategies should inherit from the Strategy class.\n```python\nfrom strategies import Strategy\n\nclass MyStrategy(Strategy):\n    pass\n```\n\nThe abstract class ```Strategy``` has global parameters with default values, and some \nproperties that can be used as helpers to build trading logic.\n\nThe methods of this class can be split into several categories:\n\n**Lifecycle Methods** These are executed at different times during the execution of the bot. These represent the main flow of a strategy, some are mandatory.\n\n**Strategy Methods** These are strategy helper methods.\n\n**Broker Methods** How to interact with the broker (buy, sell, get positions, etc)\n\n**Data Methods** How to get price data easily\n\nAll the methods in each of these categories are described below.\n\n## Lifecycle Methods\n\nThe abstract class Strategy defines a design pattern that needs to be followed by user-defined \nstrategies. The design pattern was greatly influenced by React.js components and their lifecycle \nmethods.\n\nWhen building strategies, lifecycle methods needs to be overloaded.\nTrading logics should be implemented in these methods.\n\n![lifecycle methods](lifecycle_methods.png)\n\n#### initialize\n\nThis lifecycle methods is executed only once, when the strategy execution starts.\nUse this lifecycle method to initialize parameters like:\n- ```self.sleeptime```: the sleeptime duration between each trading iteration in minutes\n- ```self.minutes_before_closing```: number of minutes before the market closes to stop trading\n\n```python\nclass MyStrategy(Strategy):\n    def initialize(self, my_custom_parameter=True):\n        self.sleeptime = 5\n        self.minutes_before_closing = 15\n        self.my_custom_parameter = my_custom_parameter\n```\n\nYou can also use the initialize method to define custom parameters \nlike ```my_custom_parameter``` in the example above. You can name these parameters however you'd like, and add as many as you'd like.\n\nThese parameters can easily be set using the strategy constructor later on.\n\n```python\nstrategy_1 = MyStrategy(\n  name=\"strategy_1\",\n  budget=budget,\n  broker=broker,\n  my_custom_parameter=False,\n  my_other_parameter=50\n)\n\nstrategy_2 = MyStrategy(\n  name=\"strategy_2\",\n  budget=budget,\n  broker=broker,\n  my_custom_parameter=True,\n  my_last_parameter=\"SPY\"\n)\n```\n\nor just for backtesting\n\n```python\noptions = [True, False]\nfor option in options:\n    MyStrategy.backtest(\n        \"my_strategy\",\n        budget,\n        YahooDataBacktesting,\n        backtesting_start,\n        backtesting_end,\n        stats_file=stats_file,\n        my_custom_parameter=option,\n        my_last_parameter=\"SPY\"\n    )\n# `options` in this example is not referring to trading options contracts.\n```\n\n#### before_market_opens\n\nThis lifecycle method is executed each day before market opens. \nIf the strategy is first run when the market is already open, this method will be skipped the first day.\nUse this lifecycle methods to execute business logic before starting trading like canceling all open orders.\n\n```python\nclass MyStrategy(Strategy):\n    def before_market_opens(self):\n        self.cancel_open_orders()\n```\n\n#### before_starting_trading\n\nThis lifecycle method is similar to before_market_opens.\nHowever, unlike before_market_opens, this method will always be executed before starting \ntrading even if the market is already open when the strategy was first launched.\nAfter the first execution, both methods will be executed in the following order\n1) before_market_opens\n2) before_starting_trading.\n\nUse this lifecycle method to reinitialize variables for day trading like resetting the list of\nblacklisted shares.\n\n```python\nclass MyStrategy(Strategy):\n    def before_starting_trading(self):\n        self.blacklist = []\n```\n\n#### on_trading_iteration\n\nThis lifecycle method contains the main trading logic.\nWhen the market opens, it will be executed in a loop.\nAfter each iteration, the strategy will sleep for ```self.sleeptime``` minutes.\nIf no crash or interuption, the loop will be stopped\n```self.minutes_before_closing``` minutes before market closes and will restart \non the next day when market opens again.\n\n```python\nclass MyStrategy(Strategy):\n    def on_trading_iteration(self):\n        # pull data\n        # check if should buy an asset based on data\n        # if condition, buy/sell asset\n        pass\n```\n\n#### before_market_closes\n\nThis lifecycle method is executed ```self.minutes_before_closing``` minutes before the market closes.\nUse this lifecycle method to execute business logic like selling shares and closing open orders.\n\n```python\nclass MyStrategy(Strategy):\n    def before_market_closes(self):\n        self.sell_all()\n```\n\n#### after_market_closes\n\nThis lifecycle method is executed right after the market closes.\n\n```python\nclass MyStrategy(Strategy):\n    def after_market_closes(self):\n        pass\n```\n\n#### trace_stats\n\nLifecycle method that will be executed after on_trading_iteration. \ncontext is a dictionary containing the result of ```locals()``` of ```on_trading_iteration()```\nat the end of its execution. \n\n```locals()``` returns a dictionary of the variables defined in the\nscope where it is called.\n\nUse this method to dump stats\n\n```python\nimport random\nclass MyStrategy(Strategy):\n   def on_trading_iteration(self):\n       google_symbol = \"GOOG\"\n  \n   def trace_stats(self, context, snapshot_before):\n       print(context)\n       # printing\n       # { \"google_symbol\":\"GOOG\"}\n       random_number = random.randint(0, 100)\n       row = {\"my_custom_stat\": random_number}\n\n       return row\n```\n\n#### on_abrupt_closing\n\nThis lifecycle method runs when the strategy execution gets interrupted.\nUse this lifecycle method to execute code to stop trading gracefully like selling all assets\n\n```python\nclass MyStrategy(Strategy):\n    def on_abrupt_closing(self):\n        self.sell_all()\n```\n\n#### on_bot_crash\n\nThis lifecycle method runs when the strategy crashes.\nBy default, if not overloaded,  it calls on_abrupt_closing.\n\n```python\nclass MyStrategy(Strategy):\n    def on_bot_crash(self, error):\n        self.on_abrupt_closing()\n```\n\n#### on_new_order\n\nThis lifecycle method runs when a new order has been successfully submitted to the broker.\nUse this lifecycle event to execute code when the broker processes a new order.\n\nParameters:\n- order (Order): The corresponding order object processed \n\n```python\nclass MyStrategy(Strategy):\n    def on_new_order(self, order):\n        self.log_message(\"%r is currently being processed by the broker\" % order)\n```\n\n#### on_canceled_order\n\nThe lifecycle method called when an order has been successfully canceled by the broker.\nUse this lifecycle event to execute code when an order has been canceled by the broker\n\nParameters:\n- order (Order): The corresponding order object that has been canceled\n\n```python\nclass MyStrategy(Strategy):\n    def on_canceled_order(self, order):\n        self.log_message(\"%r has been canceled by the broker\" % order)\n```\n\n#### on_partially_filled_order\n\nThe lifecycle method called when an order has been partially filled by the broker.\nUse this lifecycle event to execute code when an order has been partially filled by the broker.\n\nParameters:\n- order (Order): The order object that is being processed by the broker\n- price (float): The filled price\n- quantity (int): The filled quantity\n- multiplier (int): Options multiplier\n\n```python\nclass MyStrategy(Strategy):\n    def on_partially_filled_order(self, order, price, quantity, multiplier):\n        missing = order.quantity - quantity\n        self.log_message(f\"{quantity} has been filled\")\n        self.log_message(f\"{quantity} waiting for the remaining {missing}\")\n```\n\n#### on_filled_order\n\nThe lifecycle method called when an order has been successfully filled by the broker.\nUse this lifecycle event to execute code when an order has been filled by the broker\n\nParameters:\n- position (Position): The updated position object related to the order symbol. \n  If the strategy already holds 200 shares of SPY and 300 has just been filled, \n  then `position.quantity` will be 500 shares otherwise if it is a new\n  position, a new position object will be created and passed to this method.\n- order (Order): The corresponding order object that has been filled\n- price (float): The filled price\n- quantity (int): The filled quantity\n- multiplier (int): Options multiplier\n\n```python\nclass MyStrategy(Strategy):\n    def on_filled_order(self, position, order, price, quantity, multiplier):\n        if order.side == \"sell\":\n            self.log_message(f\"{quantity} shares of {order.symbol} has been sold at {price}$\")\n        elif order.side == \"buy\":\n            self.log_message(f\"{quantity} shares of {order.symbol} has been bought at {price}$\")\n\n        self.log_message(f\"Currently holding {position.quantity} of {position.symbol}\")\n```\n\n## Strategy Methods\n\n#### log_message\n\nLogs an info message prefixed with the strategy name\n\n## Broker Methods\n\nWhen a strategy is instantiated, a broker object is passed to it (Check Quickstart).\nThe strategy is run with the passed broker object.\nThe following shortcuts executes broker methods within the strategy. Some methods \ncan use either a `symbol` or an `asset` object. Please see [asset](#asset).\n\n#### sleep\n\nSleeps for `sleeptime` seconds\n\nParameters:\n- sleeptime (float): The sleep duration in seconds \n\n#### await_market_to_open\n\nIf the market is closed, pauses code execution until ```self.minutes_before_opening``` minutes\nbefore market opens again. If an input (float) is passed as parameter, pauses code execution until \n```input``` minutes before market opens again.\n\nParameters:\n- timedelta (float): Duration in minutes\n\nReturn type: ```None```\n\n#### await_market_to_close\n\nIf the market is open, pauses code execution until ```self.minutes_before_closing``` minutes\nbefore market closes. If an input (float) is passed as parameter, pauses code execution until \n```input``` minutes before market closes again.\n\nParameters:\n- timedelta (float): Duration in minutes\n\nReturn type: ```None```\n\n#### get_tracked_position\n\nReturn the strategy tracked position for a given symbol if found else ```None```.\n\nParameters:\n- symbol (str): The share/asset string representation (e.g AAPL, GOOG, ...) \n\nReturn type: position\n\n#### get_tracked_positions\n\nReturn all the strategy tracked positions.\n\nReturn type: list(position)\n\n#### get_tracked_order\n\nReturn the strategy tracked order with the specified identifier if found else ```None```.\n\nParameters:\n- identifier (str): The broker order identifier \n\nReturn type: order\n\n#### get_tracked_orders\n\nReturn all the strategy tracked orders.\n\nReturn type: list(order)\n\n#### get_tracked_assets\n\nReturn the strategy list of symbols for all tracked positions and orders.\n\nReturn type: list(str/asset) \n\n#### get_asset_potential_total\n\nCheck the ongoing positions and the tracked orders of the strategy and returns the total number of shares provided all orders went through. In other words, add all outstanding orders and the total value of the position for an asset.\n\nFor example, if you own 100 SPY and have an outstanding limit order of 10 shares, we will count all 110 shares.\n\nParameters:\n- symbol (str/asset): the string representation of the share/asset\n\nReturn type: int\n\n#### create_order\n\nCreate an order object attached to this strategy (Check the Entities, order section)\n\nRequired Parameters:\n- symbol (str/asset): representation of the asset to buy\n- quantity (int): the quantity of the asset to buy\n- side (str): either ```\"buy\"``` or ```\"sell\"```\n\nOptional Parameters:\n- limit_price (default = None)\n- stop_price (default = None)\n- time_in_force (default = \"day\")\n- take_profit_price (default = None),\n- stop_loss_price (default = None),\n- stop_loss_limit_price (default = None),\n- trail_price (default = None),\n- trail_percent (default = None),\n- position_filled (default = None)e,\n\n*** NOTE: Limit and stop orders work as normal in live trading, but will be ignored in backtesting. Meaning that a backtest will assume limit and stop orders were never executed.\n\nReturn type: order\n\n```python\nclass MyStrategy(Strategy):\n    def on_trading_iteration(self):\n      # Buy 100 shares of SPY\n      order = self.create_order(\"SPY\", 100, \"buy\")\n      self.submit_order(order)\n```\n\nFor a limit order:\n\n```python\nclass MyStrategy(Strategy):\n    def on_trading_iteration(self):\n      # Buy 100 shares of SPY\n      order = self.create_order(\"SPY\", 100, \"buy\", limit_price=100)\n      self.submit_order(order)\n```\n\n#### submit_order\n\nSubmit an order. Returns the processed order.\n\nParameters:\n- order (order): the order object\n\nReturn type: order\n\n```python\nclass MyStrategy(Strategy):\n    def my_function(self):\n      # Sell 100 shares of TLT\n      order = self.create_order(\"TLT\", 100, \"sell\")\n      self.submit_order(order)\n```\n\n#### submit_orders\n\nSubmit a list of orders\n\nParameters:\n- orders (list(order)): the list of orders\n\nReturn type: ```list(order)```\n\n#### wait_for_order_registration\n\nWait for the order to be registered by the broker\n\nParameters:\n- order (order): the order object\n\nReturn type: ```None```\n\n#### wait_for_order_execution\n\nWait for the order to execute/be canceled\n\nParameters:\n- order (order): the order object\n\nReturn type: ```None```\n\n#### wait_for_orders_registration\n\nWait for the orders to be registered by the broker\n\nParameters:\n- orders (list(order)): the list of orders\n\nReturn type: ```None```\n\n#### wait_for_orders_execution\n\nWait for the orders to execute/be canceled\n\nParameters:\n- orders (list(order)): the list of orders\n\nReturn type: ```None```\n\n#### cancel_order\n\nCancel an order.\n\nParameters:\n- order (order): the order to cancel\n\nReturn type: ```None```\n\n#### cancel_orders\n\nCancel a list of orders\n\nParameters:\n- orders (list(order)): the list of orders to cancel\n\nReturn type: ```None```\n\n#### cancel_open_orders\n\nCancel all the strategy open orders\n\nReturn type: ```None```\n\n#### sell_all\n\nSell all strategy current positions\n\nReturn type: ```None```\n\n```python\nclass MyStrategy(Strategy):\n   # Will sell all shares that the strategy is tracking on Ctrl + C\n   def on_abrupt_closing(self):\n        self.sell_all()\n```\n\n#### get_last_price\n\nReturn the last known price for a given symbol\n\nParameters:\n- symbol (str/asset): the string representation of the asset/share\n\nReturn type: float\n\n```python\nsymbol = \"SPY\"\ncurrent_price = self.get_last_price(symbol)\nlogging.info(f\"The current price of {symbol} is {current_price}\")\n```\n\n#### get_last_prices\n\nReturn the last known prices for a list symbols\n\nParameters:\n- symbols (list(str/asset)): list of share/asset representations\n\nReturn type: dict of str:float or asset:asset object\n\n#### get_tradable_assets\nReturn the list of tradable assets for the used broker  \nReturn type: list(str/asset)  \n### Options\n#### get_chains  \nFor a given symbol/asset, returns the full options chain for all exchanges.   \nParameters: symbol/asset  \nReturn type: Dictionary with `exchanges` as keys, `chain dictionary` as value.  \n\n#### get_chain\nReturns an option chain for one symbol on one exchange.   \nParameters: chains, exchange='SMART'   \nReturns: Dictionary with:  \n- Underlying_conid: Contract ID with Interactive Brokers. \n- TradingClass: Stock symbol\n- Multiplier: Option leverage multiplier.\n- Expiration: Set of expiration dates. Format 'YYYYMMDD'\n- Strikes: Set of strike prices. \n\n#### get_expiration\nRetrieves all of the expiration dates for an option chain, sorted by date.   \nParameters: chains, exchange='SMART'  \nReturns: list of expirations date in the format \"YYYYMMDD\"  \n```python\nasset = self.create_asset(\"FB\")\nchains = self.get_chains(asset)\nchain = self.get_chain(chains)\nexpiration = self.get_expiration(chains)\n```\n\n\n## Data Source Methods\n\nWhen a strategy is instantiated, a broker object is passed to it (Check Quickstart).\nA data_source object can also be passed. When passed, the data_source will be used for\nextracting bars and data. If not specified, the strategy will use the broker passed\nas the default data source.\n\nThe following shortcuts executes data sources methods within the strategy.\n\n#### get_datetime\n\nReturn the current datetime localized the datasource timezone e.g. ```America/New_York```. \nDuring backtesting this will be the time that the strategy thinks that it is.\n\nReturn type: datetime\n\n```python\nprint(f\"The current time is {self.get_datetime()}\")\n```\n\n#### get_timestamp\n\nReturn the current UNIX timestamp. \nDuring backtesting this will be the UNIX timestamp that the strategy thinks that it is.\n\nReturn type: float\n\n```python\nprint(f\"The current time is {self.get_timestamp()}\")\n```\n\n#### get_round_minute\n\nReturns a minute rounded datetime object.\n\nOptional Parameters:\n- timeshift (int): a timeshift in minutes from the present.\n\nExample:\n```python\nimport timedelta\n# Return a midnight rounded datetime object of three minutes ago \ndt =  self.get_round_minute(timeshift=3)\nprint(dt)\n# datetime.datetime(2021, 2, 21, 9, 17, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>)\n```\n\nReturn type: datetime\n\n#### get_last_minute\n\nReturns the last minute rounded datetime object. Shortcut to ```straregy.get_round_minute(timeshift=1)```\n\nReturn type datetime.\n\n#### get_round_day\n\nReturns a day rounded datetime object.\n\nOptional Parameters:\n- timeshift (int): a timeshift in days from the present.\n\nExample:\n```python\nimport timedelta\n# Return a midnight rounded datetime object of three days ago \ndt =  self.get_round_day(timeshift=3)\nprint(dt)\n# datetime.datetime(2021, 2, 21, 0, 0, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>)\n```\n\nReturn type datetime\n\n#### get_last_day\n\nReturns the last day rounded datetime object. Shortcut to ```straregy.get_round_day(timeshift=1)```\n\nReturn type datetime.\n\n#### get_datetime_range\n\nTakes as input length, timestep and timeshift and returns a tuple of datetime representing the start date and end date.\n\nParameters:\n  - length (int): represents the number of bars required\n  - timestep (str): represents the timestep, either ```minute``` (default value) or ```day```.\n  - timeshift (timedelta): ```None``` by default. If specified indicates the time shift from the present.\n\nReturn type datetime\n\n#### localize_datetime\n\nConverts an unaware datetime object (datetime object without a timezone) to an aware datetime object.\nThe default timezone is ```America/New_York```.\n\nParameter:\n- dt (datetime): the datetime object to convert.\n\nExample:\n```python\nfrom datetime import datetime\ndt =  datetime(2021, 2, 21)\nprint(dt)\n# datetime.datetime(2021, 2, 21, 0, 0)\ndt_aware = self.localize_datetime(dt)\nprint(dt_aware)\n# datetime.datetime(2021, 2, 21, 0, 0, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>)\n```\n\nReturn type: datetime\n\n#### to_default_timezone\n\nTranspose an aware datetime object to the default timezone ```America/New_York```.  \n\nParameter:\n- dt (datetime): the datetime object to convert.\n\nReturn type: datetime\n\n#### get_symbol_bars\n\nReturn bars for a given symbol.\n\nParameters:\n- symbol (str/asset): The symbol string representation (e.g AAPL, GOOG, ...) or \n  asset object. \n- length (int): The number of rows (number of timestamps)\n- timestep (str): Either ```\"minute\"\"``` for minutes data or ```\"day\"\"``` for days data\n  default value depends on the data_source (minute for alpaca, day for yahoo, ...)\n- timeshift (timedelta): ```None``` by default. If specified indicates the time shift from the present.\n\nExample:\n```python\nimport timedelta\n#...\n\n# Extract 10 rows of SPY data with one minute timestep between each row\n# with the latest data being 24h ago (timedelta(days=1))\nbars =  self.get_symbol_bars(\"SPY\",10,\"minute\",timedelta(days=1))\n```\n\nReturn type: bars\n\n#### get_bars\n\nReturn a dictionary of bars for a given list of symbols. Works the same as get_symbol_bars\nbut take as first parameter a list of symbols.\n\nParameters:\n- symbol (list(str/asset)): The symbol string representation (e.g AAPL, GOOG, ...) or \n  asset object. \n- length (int): The number of rows (number of timestamps)\n- timestep (str): Either ```\"minute\"\"``` for minutes data or ```\"day\"\"``` for days data\n  default value depends on the data_source (minute for alpaca, day for yahoo, ...)\n- timeshift (timedelta): ```None``` by default. If specified indicates the time shift from the present.\n\nReturn type: dict of str/asset:bars\n\n#### get_yesterday_dividend\n\nReturn dividend per share for the day before for a given symbol\n\nParameters:\n- symbol (str/asset): The symbol string representation (e.g AAPL, GOOG, ...) or\n  asset object.\n\nReturn type: float or asset object\n\n#### get_yesterday_dividends\n\nReturn dividend per share for the day before for a given list of symbols. \nWorks the same as get_yesterday_dividend but take as parameter a list of symbols.\n\nParameters:\n- symbol (str/asset): The symbol string representation (e.g AAPL, GOOG, ...) or\n  asset object.\n\nReturn type: dict of str:float\n\n\n## Properties and Parameters\n\nA strategy object has the following properties:\n\n- name: indicates the name of the strategy.\n- initial budget: indicates the initial budget\n- minutes_before_closing. The lifecycle method on_trading_iteration is \n  executed inside a loop that stops only when there is only ```minutes_before_closing``` \n  minutes remaining before market closes. By default equals to 5 minutes.\n  This value can be overloaded when creating a strategy class in order to change the \n  default behaviour. Another option is to specify it when creating an instance the strategy class\n  ```python\n  my_strategy = MyStrategy(\"my_strategy\", budget, broker, minutes_before_closing=15)\n  ```\n- minutes_before_opening. The lifecycle method before_market_opens is executed ```minutes_before_opening```\n  minutes before the market opens. By default equals to 60 minutes.\n  This value can be overloaded when creating a strategy class in order to change the \n  default behaviour. Another option is to specify it when creating an instance the strategy class\n  ```python\n  my_strategy = MyStrategy(\"my_strategy\", budget, broker, minutes_before_opening=15)\n  ```\n- sleeptime: Sleeptime in minute after executing the lifecycle method \n  on_trading_iteration. By default equals to 1 minute. \n  This value can be overloaded when creating a strategy class in order to change the \n  default behaviour. Another option is to specify it when instanciation the strategy class\n  ```python\n  my_strategy = MyStrategy(\"my_strategy\", budget, broker, sleeptime=2)\n  ```\n- parameters: a dictionary that contains keyword arguments passed to the constructor. \n  These keyords arguments will be passed to the `self.initialize()` lifecycle method\n- is_backtesting: A boolean that indicates whether the strategy is run in live trading\n  or in backtesting mode.\n- portfolio_value: indicates the actual values of shares held by \n  the current strategy plus the total unspent money.\n- unspent_money: indicates the amount of unspent money from the initial\n  budget allocated to the strategy. This property is updated whenever a transaction was filled \n  by the broker or when dividends are paid.\n- first_iteration: is `True` if the lifecycle method `on_trading_iteration` is being excuted for the first time.\n- timezone: The string representation of the timezone used by the trading data_source. \n  By default ``America/New_York``.\n- pytz: the ```pytz``` object representation of the timezone property.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Lumiwealth/lumibot",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "lumibot",
    "package_url": "https://pypi.org/project/lumibot/",
    "platform": "",
    "project_url": "https://pypi.org/project/lumibot/",
    "project_urls": {
      "Homepage": "https://github.com/Lumiwealth/lumibot"
    },
    "release_url": "https://pypi.org/project/lumibot/1.1.1/",
    "requires_dist": [
      "alpaca-trade-api",
      "ibapi (==9.81.1.post1)",
      "yfinance (==0.1.59)",
      "matplotlib",
      "quandl",
      "pandas",
      "pandas-datareader",
      "pandas-market-calendars",
      "flask-socketio",
      "flask-sqlalchemy",
      "flask-marshmallow",
      "marshmallow-sqlalchemy",
      "flask-security",
      "email-validator",
      "bcrypt"
    ],
    "requires_python": ">=3.6",
    "summary": "Trading Framework",
    "version": "1.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16881487,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "59650d2b1c54a48567048e3ac8939e58f7ffc9b29f28381a51e8dcd8370d58d9",
        "md5": "a3c5cc11b13d7baa4fbf70343e7ade62",
        "sha256": "4b6f7d44134015734032b561132fbfd0532146007328c3029b5fb66fd189d78c"
      },
      "downloads": -1,
      "filename": "lumibot-1.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a3c5cc11b13d7baa4fbf70343e7ade62",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 99472,
      "upload_time": "2021-06-25T20:50:59",
      "upload_time_iso_8601": "2021-06-25T20:50:59.066789Z",
      "url": "https://files.pythonhosted.org/packages/59/65/0d2b1c54a48567048e3ac8939e58f7ffc9b29f28381a51e8dcd8370d58d9/lumibot-1.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "38859f18e1221207b979109d708f738f43b2cc316c2a00b6cbf4ec496e6309da",
        "md5": "e9b948d33b39b37e49b710e9c9fc69e6",
        "sha256": "e683b3d4e3008b381f07a277bc6dfe81570fc0fbb549dc7be5c55627fb4a69e5"
      },
      "downloads": -1,
      "filename": "lumibot-1.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "e9b948d33b39b37e49b710e9c9fc69e6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 98431,
      "upload_time": "2021-06-25T20:51:00",
      "upload_time_iso_8601": "2021-06-25T20:51:00.774781Z",
      "url": "https://files.pythonhosted.org/packages/38/85/9f18e1221207b979109d708f738f43b2cc316c2a00b6cbf4ec496e6309da/lumibot-1.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}