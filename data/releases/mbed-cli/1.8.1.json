{
  "info": {
    "author": "ARM mbed",
    "author_email": "support@mbed.org",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3"
    ],
    "description": "## Introduction\r\n\r\nArm Mbed CLI is the name of the Arm Mbed command-line tool, packaged as `mbed-cli`. Mbed CLI enables Git- and Mercurial-based version control, dependencies management, code publishing, support for remotely hosted repositories (GitHub, GitLab and mbed.org), use of the Arm Mbed OS build system and export functions and other operations.\r\n\r\nThis document covers the installation and usage of Mbed CLI.\r\n\r\n## Table of Contents\r\n\r\n1. [Using Mbed CLI](#using-mbed-cli)\r\n1. [Installing and uninstalling](#installing-mbed-cli)\r\n1. [Understanding working context and program root](#before-you-begin-understanding-the-working-context-and-program-root)\r\n1. [Creating and importing programs](#creating-and-importing-programs)\r\n    1. [Creating a new program](#creating-a-new-program-for-mbed-os-5)\r\n    2. [Importing an existing program](#importing-an-existing-program)\r\n1. [Adding and removing libraries](#adding-and-removing-libraries)\r\n1. [Compiling code](#compiling-code)\r\n    1. [Toolchain selection](#toolchain-selection)\r\n    2. [Compiling your program](#compiling-your-program)\r\n    3. [Compiling static libraries](#compiling-static-libraries)\r\n    4. [Compile configuration system](#compile-configuration-system)\r\n    5. [Compile-time customizations](#compile-time-customizations)\r\n1. [Exporting to desktop IDEs](#exporting-to-desktop-ides)\r\n1. [Testing](#testing)\r\n    1. [Finding available tests](#finding-available-tests)\r\n    2. [Compiling and running tests](#compiling-and-running-tests)\r\n    3. [Limiting the test scope](#limiting-the-test-scope)\r\n    4. [Test directory structure](#test-directory-structure)\r\n1. [Unit testing](#unit-testing)\r\n1. [Publishing your changes](#publishing-your-changes)\r\n    1. [Checking status](#checking-status)\r\n    2. [Pushing upstream](#pushing-upstream)\r\n1. [Updating programs and libraries](#updating-programs-and-libraries)\r\n    1. [Updating to an upstream version](#updating-to-an-upstream-version)\r\n    2. [Update examples](#update-examples)\r\n1. [Mbed CLI configuration](#mbed-cli-configuration)\r\n1. [Troubleshooting](#troubleshooting)\r\n\r\n\r\n## Using Mbed CLI\r\n\r\nThe basic workflow for Mbed CLI is to:\r\n\r\n1. Initialize a new repository, for either a new application (or library) or an imported one. In both cases, this action also adds the Mbed OS codebase.\r\n1. Build the application code.\r\n1. Test your build.\r\n1. Publish your application.\r\n\r\nTo support long-term development, Mbed CLI offers source control, including selective updates of libraries and the codebase, support for multiple toolchains and manual configuration of the system.\r\n\r\n<span class=\"tips\">**Tip:** To list all Mbed CLI commands, use `mbed --help`. A detailed command-specific help is available by using `mbed <command> --help`.</span>\r\n\r\n## Installation\r\n\r\nWindows, Linux and Mac OS X support Mbed CLI. We're keen to learn about your experience with Mbed CLI on other operating systems at the [Mbed CLI development page](https://github.com/ARMmbed/mbed-cli).\r\n\r\n### Requirements\r\n\r\n* **Python** - Mbed CLI is a Python script, so you'll need Python to use it. We test Mbed CLI with [version 2.7.11 of Python](https://www.python.org/downloads/release/python-2711/) and [version 3.6.0 of Python](https://www.python.org/downloads/release/python-360/)\r\n\r\n#### Mbed CLI and pip compatibility\r\n\r\n<span class=\"notes\">**Note:** Mbed CLI versions older than 1.5.1 are **not compatible** with `pip` version 10.0 (or newer). Also Mbed CLI versions older than 1.7.0 support only Python 2. Please use latest Mbed CLI.</span>\r\n\r\n\r\n* **Git and Mercurial** - Mbed CLI supports both Git and Mercurial repositories, so you need to install both:\r\n    * [Git](https://git-scm.com/) - version 1.9.5 or later.\r\n    * [Mercurial](https://www.mercurial-scm.org/) - version 2.2.2 or later.\r\n\r\nThe directories of Git and Mercurial executables (`git` and `hg`) need to be in your system's PATH.\r\n\r\n* **Command-line compiler or IDE toolchain** - Mbed CLI invokes the [Mbed OS 5](https://github.com/ARMmbed/mbed-os) tools for various features, such as compiling, testing and exporting to industry standard toolchains. To compile your code, you need either a compiler or an IDE:\r\n    * Compilers: GCC ARM, Arm Compiler 5, Arm Compiler 6, IAR.\r\n    * IDE: Keil uVision, DS-5, IAR Workbench.\r\n\r\n<span class=\"tips\">**Note:** When installing the Arm Compiler 5 on a 64-bit Linux machine, you may need to also install the i386 architecture package:</span>\r\n\r\n```\r\n$ sudo dpkg --add-architecture i386\r\n$ sudo apt-get update\r\n$ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386\r\n```\r\n\r\n### Video tutorial for manual installation\r\n\r\n<span class=\"images\">[![Video tutorial](https://img.youtube.com/vi/cM0dFoTuU14/0.jpg)](https://www.youtube.com/watch?v=cM0dFoTuU14)</span>\r\n\r\n### Installing Mbed CLI\r\n\r\nWindows users can use the [Mbed CLI for Windows installer](https://docs.mbed.com/docs/mbed-os-handbook/en/latest/dev_tools/cli_install/) to install Mbed CLI and all necessary requirements with one installer.\r\n\r\nYou can get the latest stable version of Mbed CLI through pip by running:\r\n\r\n```\r\n$ pip install mbed-cli\r\n```\r\n\r\nOn Linux or Mac, you may need to run with `sudo`.\r\n\r\nAlternatively, you can get the development version of Mbed CLI by cloning the development repository [https://github.com/ARMmbed/mbed-cli](https://github.com/ARMmbed/mbed-cli):\r\n\r\n```\r\n$ git clone https://github.com/ARMmbed/mbed-cli\r\n```\r\n\r\nOnce cloned, you can install Mbed CLI as a Python package:\r\n\r\n```\r\n$ python setup.py install\r\n```\r\n\r\nOn Linux or Mac, you may need to run with `sudo`.\r\n\r\n<span class=\"tips\">**Note:** Mbed CLI is compatible with [Virtual Python Environment (virtualenv)](https://pypi.python.org/pypi/virtualenv). You can read more about isolated Python virtual environments [here](http://docs.python-guide.org/en/latest/).</span>\r\n\r\n### Updating Mbed CLI\r\n\r\nTo update an existing installation of Mbed CLI, run:\r\n\r\n```\r\npip install -U mbed-cli\r\n```\r\n\r\n### Uninstalling Mbed CLI\r\n\r\nTo uninstall Mbed CLI, run:\r\n\r\n```\r\npip uninstall mbed-cli\r\n```\r\n\r\n### Adding Bash tab completion\r\n\r\nTo install `mbed-cli` bash tab completion navigate to the `tools/bash_completion` directory. Then, copy the `mbed` script into your `/etc/bash_completion.d/` or `/usr/local/etc/bash_completion.d` directory and reload your terminal.  \r\n\r\n[Full documentation here](https://github.com/ARMmbed/mbed-cli/blob/master/tools/bash_completion/install.md)\r\n\r\n## Quickstart video\r\n\r\n<span class=\"images\">[![Video tutorial](https://img.youtube.com/vi/PI1Kq9RSN_Y/0.jpg)](https://www.youtube.com/watch?v=PI1Kq9RSN_Y)</span>\r\n\r\n## Before you begin: understanding the working context and program root\r\n\r\nMbed CLI uses the current directory as a working context, in a similar way to Git, Mercurial and many other command-line tools. This means that before calling any Mbed CLI command, you must first change to the directory containing the code you want to act on. For example, if you want to update the Mbed OS sources in your `mbed-example-program` directory:\r\n\r\n```\r\n$ cd mbed-example-program\r\n$ cd mbed-os\r\n$ mbed update master   # This will update \"mbed-os\", not \"my-program\"\r\n```\r\n\r\nVarious Mbed CLI features require a program root, which should be under version control - either [Git](https://git-scm.com/) or [Mercurial](https://www.mercurial-scm.org/). This makes it possible to switch between revisions of the whole program and its libraries, control the program history, synchronize the program with remote repositories, share it with others and so on. Version control is also the primary and preferred delivery mechanism for Mbed OS source code, which allows everyone to contribute to Mbed OS.\r\n\r\n<span class=\"warnings\">**Warning**: Mbed CLI stores information about libraries and dependencies in reference files that use the `.lib` extension (such as `lib_name.lib`). Although these files are human-readable, we *strongly* advise that you don't edit these manually - let Mbed CLI manage them instead.</span>\r\n\r\n## Creating and importing programs\r\n\r\nMbed CLI can create and import programs based on both Mbed OS 2 and Mbed OS 5.\r\n\r\n### Creating a new program for Mbed OS 5\r\n\r\nWhen you create a new program, Mbed CLI automatically imports the latest [Mbed OS release](https://github.com/ARMmbed/mbed-os/). Each release includes all the components: code, build tools and IDE exporters.\r\n\r\nWith this in mind, let's create a new program (we'll call it `mbed-os-program`):\r\n\r\n```\r\n$ mbed new mbed-os-program\r\n[mbed] Creating new program \"mbed-os-program\" (git)\r\n[mbed] Adding library \"mbed-os\" from \"https://github.com/ARMmbed/mbed-os\" at latest revision in the current branch\r\n[mbed] Updating reference \"mbed-os\" -> \"https://github.com/ARMmbed/mbed-os/#89962277c20729504d1d6c95250fbd36ea5f4a2d\"\r\n```\r\n\r\nThis creates a new folder \"mbed-os-program\", initializes a new repository and imports the latest revision of the `mbed-os` dependency to your program tree.\r\n\r\n<span class=\"tips\">**Tip:** You can instruct Mbed CLI to use a specific source control management system or prevent source control management initialization, by using `--scm [name|none]` option.</span>\r\n\r\nUse `mbed ls` to list all the libraries imported to your program:\r\n\r\n```\r\n$ cd mbed-os-program\r\n$ mbed ls\r\nmbed-os-program (no revision)\r\n`- mbed-os (#182bbd51bc8d, tags: latest, mbed-os-5.6.5)\r\n```\r\n\r\nUse `mbed releases` to list all releases in a program or library:\r\n\r\n```\r\n$ cd mbed-os\r\n$ mbed releases\r\nmbed-os (#182bbd51bc8d, tags: latest, mbed-os-5.6.5)\r\n  ...\r\n  * mbed-os-5.6.0 \r\n  * mbed-os-5.6.1 \r\n  * mbed-os-5.6.2 \r\n  * mbed-os-5.6.3 \r\n  * mbed-os-5.6.4 \r\n  * mbed-os-5.6.5  <- current\r\n```\r\n\r\n<span class=\"notes\">**Note**: If you want to start from an existing folder in your workspace, you can use `mbed new .`, which initializes an Mbed program, as well as a new Git or Mercurial repository in that folder. </span>\r\n\r\n### Creating a new program for Mbed OS 2\r\n\r\nMbed CLI is also compatible with Mbed OS 2 programs based on the [Mbed library](https://mbed.org/users/mbed_official/code/mbed/), and it automatically imports the latest [Mbed library release](https://mbed.org/users/mbed_official/code/mbed/) if you use the `--mbedlib` option:\r\n\r\n```\r\n$ mbed new mbed-classic-program --mbedlib\r\n[mbed] Creating new program \"mbed-classic-program\" (git)\r\n[mbed] Adding library \"mbed\" from \"https://mbed.org/users/mbed_official/code/mbed/builds\" at latest revision in the current branch\r\n[mbed] Downloading mbed library build \"f9eeca106725\" (might take a minute)\r\n[mbed] Unpacking mbed library build \"f9eeca106725\" in \"D:\\Work\\examples\\mbed-classic-program\\mbed\"\r\n[mbed] Updating reference \"mbed\" -> \"https://mbed.org/users/mbed_official/code/mbed/builds/f9eeca106725\"\r\n[mbed] Couldn't find build tools in your program. Downloading the mbed 2.0 SDK tools...\r\n```\r\n\r\n### Creating a new program without OS version selection\r\n\r\nYou can create plain (empty) programs, without either Mbed OS 5 or Mbed OS 2, by using the `--create-only` option.\r\n\r\n### Managing multiple Mbed projects\r\n\r\nYou can create multiple Mbed projects and use the same Mbed OS library directory for each of these projects with the following commands:\r\n\r\n```\r\n$ cd <projects directory>\r\n$ mbed import mbed-os\r\n$ mbed config -G MBED_OS_DIR <projects directory>/mbed-os\r\n[mbed] <projects directory>/mbed-os now set as global MBED_OS_DIR\r\n$ mbed new project1\r\n[mbed] Creating new program \"project1\" (git)\r\n$ mbed new project2\r\n[mbed] Creating new program \"project2\" (git)\r\n```\r\n\r\nAdd your `main.cpp` file and other project files to the `project1` and `project2` directories. Then compile each project from the root `<projects directory>` with the following example commands:\r\n\r\n```\r\n$ mbed compile -t ARM -m LPC1768 --source project1 --source mbed-os --build BUILD/project1\r\n$ mbed compile -t ARM -m K64F --source project2 --source mbed-os --build BUILD/project2  \r\n```\r\n\r\n### Importing an existing program\r\n\r\nUse `mbed import` to clone an existing program and all its dependencies to your machine:\r\n\r\n```\r\n$ mbed import https://github.com/ARMmbed/mbed-os-example-blinky\r\n[mbed] Importing program \"mbed-os-example-blinky\" from \"https://github.com/ARMmbed/mbed-os-example-blinky\" at latest revision in the current branch\r\n[mbed] Adding library \"mbed-os\" from \"https://github.com/ARMmbed/mbed-os\" at rev #dd36dc4228b5\r\n$ cd mbed-os-example-blinky\r\n```\r\n\r\nMbed CLI also supports programs based on Mbed OS 2, which it automatically detects and which do not require additional options:\r\n\r\n```\r\n$ mbed import https://mbed.org/teams/mbed/code/mbed_blinky/\r\n[mbed] Importing program \"mbed_blinky\" from \"https://mbed.org/teams/mbed/code/mbed_blinky\" at latest revision in the current branch\r\n[mbed] Adding library \"mbed\" from \"http://mbed.org/users/mbed_official/code/mbed/builds\" at rev #f9eeca106725\r\n[mbed] Couldn't find build tools in your program. Downloading the mbed 2.0 SDK tools...\r\n$ cd mbed-os-example-blinky\r\n```\r\n\r\nYou can use the \"import\" command without specifying a full URL; Mbed CLI adds a prefix (https://github.com/ARMmbed) to the URL if one is not present. For example, this command:\r\n\r\n```\r\n$ mbed import mbed-os-example-blinky\r\n```\r\n\r\nis equivalent to this command:\r\n\r\n```\r\n$ mbed import https://github.com/ARMmbed/mbed-os-example-blinky\r\n```\r\n\r\n### Importing from a Git or GitHub clone\r\n\r\nIf you have manually cloned a Git repository into your workspace and you want to add all missing libraries, then you can use the `deploy` command:\r\n\r\n```\r\n$ mbed deploy\r\n[mbed] Adding library \"mbed-os\" from \"https://github.com/ARMmbed/mbed-os\" at rev #dd36dc4228b5\r\n```\r\n\r\nDon't forget to set the current directory as the root of your program:\r\n\r\n```\r\n$ mbed new .\r\n```\r\n\r\n## Adding and removing libraries\r\n\r\nWhile working on your code, you may need to add another library to your application or remove existing libraries.\r\n\r\nAdding a new library to your program is not the same as cloning the repository. Don't clone a library using `hg` or `git`; use `mbed add` to add the library. This ensures that all libraries and sublibraries are populated as well.\r\n\r\nRemoving a library from your program is not the same as deleting the library directory. Mbed CLI updates and removes library reference files. Use `mbed remove` to remove the library; don't remove its directory with `rm`.\r\n\r\n### Adding a library\r\n\r\nUse `mbed add` to add the latest revision of a library:\r\n\r\n```\r\n$ mbed add https://developer.mbed.org/users/wim/code/TextLCD/\r\n```\r\n\r\nUse the `URL#hash` format to add a library from a URL at a specific revision hash:\r\n\r\n```\r\n$ mbed add https://developer.mbed.org/users/wim/code/TextLCD/#e5a0dcb43ecc\r\n```\r\n\r\n#### Specifying a destination directory\r\n\r\nIf you want to specify a directory to which to add your library, you can give an additional argument to ``add``, which names that directory. For example, If you'd rather add the previous library in a directory called \"text-lcd\" (instead of TextLCD):\r\n\r\n```\r\n$ mbed add https://developer.mbed.org/users/wim/code/TextLCD/ text-lcd\r\n```\r\n\r\nAlthough Mbed CLI supports this functionality, we don't encourage it. Adding a library with a name that differs from its source repository can lead to confusion.\r\n\r\n### Removing a library\r\n\r\nIf at any point you decide that you don't need a library any more, you can use `mbed remove` with the path of the library:\r\n\r\n```\r\n$ mbed remove text-lcd\r\n```\r\n\r\n## Compiling code\r\n\r\n### Toolchain selection\r\n\r\nAfter importing a program or creating a new one, you need to tell Mbed CLI where to find the toolchains that you want to use for compiling your source tree.\r\n\r\nThere are multiple ways to configure toolchain locations:\r\n* `mbed_settings.py` file in the root of your program. The tools will automatically create this file if it doesn't already exist.\r\n* The Mbed CLI configuration.\r\n* Setting an environment variable.\r\n* Adding directory of the compiler binary to your PATH.\r\n\r\nMethods for configuring toolchains that appear earlier in the above list override methods that appear later.\r\n\r\n#### Through `mbed_settings.py`\r\n\r\nEdit `mbed_settings.py` to set your toolchain:\r\n\r\n* To use [Arm Compiler 5](https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-5/downloads), set `ARM_PATH` to the *base* directory of your Arm Compiler installation (example: C:\\Program Files\\ARM\\armcc5.06). Use version 5.06 of Arm Compiler 5.\r\n* To use [Arm Compiler 6](https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-6/downloads), set `ARMC6_PATH` to the *binary* directory of your Arm Compiler installation (example: C:\\Program Files\\ARM\\armcc6.10\\bin). Use version 6.10 of Arm Compiler 6.\r\n* To use the [GNU Arm Embedded toolchain (GCC) version 6](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads), set `GCC_ARM_PATH` to the *binary* directory of your GCC Arm installation (example: C:\\Program Files\\GNU Tools ARM Embedded\\6 2017q2\\bin). Use version 6 of GCC Arm Embedded; version 5.0 or any older version might be incompatible with the tools.\r\n* To use the [IAR EWARM toolchain](https://www.iar.com/iar-embedded-workbench/#!?architecture=ARM), set `IAR_PATH` to the *base* directory of your IAR installation (example: C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 7.5\\arm). Use versions 7.70 to 7.80.x of the IAR EWARM; newer (or older) versions might be incompatible with the tools.\r\n\r\nBecause `mbed_settings.py` contains local settings (possibly relevant only to a single OS on a single machine), you should not check it into version control.\r\n\r\n#### Through Mbed CLI configuration\r\n\r\nYou can set the Arm Compiler 5 location via the command:\r\n\r\n```\r\n$ mbed config -G ARM_PATH \"C:\\Program Files\\ARM\"\r\n[mbed] C:\\Program Files\\ARM now set as global ARM_PATH\r\n```\r\n\r\nThe `-G` switch tells Mbed CLI to set this as a global setting, rather than local for the current program.\r\n\r\nSupported settings for toolchain paths are `ARM_PATH`, `ARMC6_PATH`, `GCC_ARM_PATH` and `IAR_PATH`.\r\n\r\nYou can see the active Mbed CLI configuration via:\r\n\r\n```\r\n$ mbed config --list\r\n[mbed] Global config:\r\nARM_PATH=C:\\Program Files\\ARM\\armcc5.06\r\nIAR_PATH=C:\\Program Files\\IAR Workbench 7.0\\arm\r\n\r\n[mbed] Local config (D:\\temp\\mbed-os-program):\r\nNo local configuration is set\r\n```\r\n\r\nMore information about Mbed CLI configuration is available in the [configuration section](#mbed-cli-configuration) of this document.\r\n\r\n#### Setting environment variable\r\n\r\nFor each of the compilers, `mbed compile` checks a corresponding environment variable for the compiler's location. The environment variables are as follows:\r\n* `MBED_ARM_PATH`: The path to the *base* directory of your Arm Compiler installation. This should be the directory containing the directory containing the binaries for `armcc` and friends.\r\n* `MBED_ARMC6_PATH`: The path to the *binary* directory of your Arm Compiler installation. This should be the directory containing the binaries for `armclang` and friends.\r\n* `MBED_IAR_PATH`: The path to the *base* directory of your IAR EWARM Compiler installation. This should be one directory containing the directory containing the binaries for `iccarm` and friends.\r\n* `MBED_GCC_ARM_PATH`: The path to the *binary* directory of your GCC Arm Embedded Compiler installation. This should be the directory containing the binaries for `arm-none-eabi-gcc` and friends.\r\n\r\n#### Compiler detection through the `PATH`\r\n\r\nIf none of the above are configured, the `mbed compile` command will fall back to checking your `PATH` for an executable that is part of the compiler suite in question. This check is the same as a shell would perform to find the executable on the command-line. When `mbed compile` finds the executable it is looking for, it uses the location of that executable as the appropriate path except in the case of GCC, which will not use a path.\r\n\r\n### Compiling your program\r\n\r\nUse the `mbed compile` command to compile your code:\r\n\r\n```\r\n$ mbed compile -t ARM -m K64F\r\nBuilding project mbed-os-program (K64F, GCC_ARM)\r\nCompile: aesni.c\r\nCompile: blowfish.c\r\nCompile: main.cpp\r\n... [SNIP] ...\r\nCompile: configuration_store.c\r\nLink: mbed-os-program\r\nElf2Bin: mbed-os-program\r\n+----------------------------+-------+-------+------+\r\n| Module                     | .text | .data | .bss |\r\n+----------------------------+-------+-------+------+\r\n| Fill                       |   170 |     0 | 2294 |\r\n| Misc                       | 36282 |  2220 | 2152 |\r\n| core/hal                   | 15396 |    16 |  568 |\r\n| core/rtos                  |  6751 |    24 | 2662 |\r\n| features/FEATURE_IPV4      |    96 |     0 |   48 |\r\n| frameworks/greentea-client |   912 |    28 |   44 |\r\n| frameworks/utest           |  3079 |     0 |  732 |\r\n| Subtotals                  | 62686 |  2288 | 8500 |\r\n+----------------------------+-------+-------+------+\r\nAllocated Heap: 65540 bytes\r\nAllocated Stack: 32768 bytes\r\nTotal Static RAM memory (data + bss): 10788 bytes\r\nTotal RAM memory (data + bss + heap + stack): 109096 bytes\r\nTotal Flash memory (text + data + misc): 66014 bytes\r\nImage: BUILD/K64F/GCC_ARM/mbed-os-program.bin\r\n```\r\n\r\nThe arguments for *compile* are:\r\n\r\n* `-m <MCU>` to select a target. If `detect` or `auto` parameter is passed to `-m`, then Mbed CLI detects the connected target.\r\n* `-t <TOOLCHAIN>` to select a toolchain (of those defined in `mbed_settings.py`, see above). The value can be `ARM` (Arm Compiler 5), `GCC_ARM` (GNU Arm Embedded) or `IAR` (IAR Embedded Workbench for Arm).\r\n* `--source <SOURCE>` to select the source directory. The default is `.` (the current directory). You can specify multiple source locations, even outside the program tree.\r\n* `--build <BUILD>` to select the build directory. Default: `BUILD/` inside your program root.\r\n* `--profile <PATH_TO_BUILD_PROFILE>` to select a path to a build profile configuration file. Example: `mbed-os/tools/profiles/debug.json`.\r\n* `--library` to compile the code as a [static .a/.ar library](#compiling-static-libraries).\r\n* `--config` to inspect the runtime compile configuration (see below).\r\n* `-S` or `--supported` shows a matrix of the supported targets and toolchains.\r\n* `-f` or `--flash` to flash/program a connected target after successful compile.\r\n* `-c ` to build from scratch, a clean build or rebuild.\r\n* `-j <jobs>` to control the compile processes on your machine. The default value is 0, which infers the number of processes from the number of cores on your machine. You can use `-j 1` to trigger a sequential compile of source code.\r\n* `-v` or `--verbose` for verbose diagnostic output.\r\n* `-vv` or `--very_verbose` for very verbose diagnostic output.\r\n\r\nYou can find the compiled binary, ELF image, memory usage and link statistics in the `BUILD` subdirectory of your program.\r\n\r\nFor more information on build profiles, see [our build profiles](https://docs.mbed.com/docs/mbed-os-handbook/en/latest/dev_tools/build_profiles/) and [toolchain profiles](https://docs.mbed.com/docs/mbed-os-handbook/en/latest/advanced/toolchain_profiles/) pages.\r\n\r\n### Compiling static libraries\r\n\r\nYou can build a static library of your code by adding the `--library` argument to `mbed compile`. Static libraries are useful when you want to build multiple applications from the same Mbed OS codebase without having to recompile for every application. To achieve this:\r\n\r\n1. Build a static library for `mbed-os`.\r\n2. Compile multiple applications or tests against the static library:\r\n\r\n```\r\n$ mbed compile -t ARM -m K64F --library --no-archive --source=mbed-os --build=../mbed-os-build\r\nBuilding library mbed-os (K64F, ARM)\r\n[...]\r\nCompleted in: (47.4)s\r\n\r\n$ mbed compile -t ARM -m K64F --source=mbed-os/TESTS/integration/basic --source=../mbed-os-build --build=../basic-out\r\nBuilding project basic (K64F, ARM)\r\nCompile: main.cpp\r\nLink: basic\r\nElf2Bin: basic\r\nImage: ../basic-out/basic.bin\r\n\r\n$ mbed compile -t ARM -m K64F --source=mbed-os/TESTS/integration/threaded_blinky --source=../mbed-os-build --build=..\\/hreaded_blinky-out\r\nBuilding project threaded_blinky (K64F, ARM)\r\nCompile: main.cpp\r\nLink: threaded_blinky\r\nElf2Bin: threaded_blinky\r\nImage: ../threaded_blinky-out/threaded_blinky.bin\r\n```\r\n\r\n### Compile configuration system\r\n\r\nThe [compile configuration system](https://docs.mbed.com/docs/mbed-os-handbook/en/5.3/advanced/config_system/) provides a flexible mechanism for configuring the Mbed program, its libraries and the build target.\r\n\r\n#### Inspecting the configuration\r\n\r\nYou can use `mbed compile --config` to view the configuration:\r\n\r\n```\r\n$ mbed compile --config -t GCC_ARM -m K64F\r\n```\r\n\r\nTo display more verbose information about the configuration parameters, use `-v`:\r\n\r\n```\r\n$ mbed compile --config -t GCC_ARM -m K64F -v\r\n```\r\n\r\nIt's possible to filter the output of `mbed compile --config` by specifying one or more prefixes for the configuration parameters that Mbed CLI displays. For example, to display only the configuration defined by the targets:\r\n\r\n```\r\n$ mbed compile --config -t GCC_ARM -m K64F --prefix target\r\n```\r\n\r\nYou may use `--prefix` more than once. To display only the application and target configuration, use two `--prefix` options:\r\n\r\n```\r\n$ mbed compile --config -t GCC_ARM -m K64F --prefix target --prefix app\r\n```\r\n\r\n### Compile-time customizations\r\n\r\n#### Macros\r\n\r\nYou can specify macros in your command-line using the -D option. For example:\r\n\r\n```\r\n$ mbed compile -t GCC_ARM -m K64F -c -DUVISOR_PRESENT\r\n```\r\n\r\n#### Compiling in debug mode\r\n\r\nTo compile in debug mode (as opposed to the default *develop* mode), use `--profile mbed-os/tools/profiles/debug.json` in the compile command-line:\r\n\r\n```\r\n$ mbed compile -t GCC_ARM -m K64F --profile mbed-os/tools/profiles/debug.json\r\n```\r\n\r\n<span class=\"tips\">**Tip:** If you have files that you want to compile only in debug mode, put them in a directory called `TARGET_DEBUG` at any level of your tree (then use `--profile` as explained above).\r\n</span>\r\n\r\n### Automating toolchain and target selection\r\n\r\nUsing `mbed target <target>` and `mbed toolchain <toolchain>`, you can set the default target and toolchain for your program. You won't have to specify these every time you compile or generate IDE project files.\r\n\r\nYou can also use `mbed target detect`, which detects the connected target board and uses it as a parameter to every subsequent compile and export.\r\n\r\n## Exporting to desktop IDEs\r\n\r\nIf you need to debug your code, you can export your source tree to an IDE project file to use the IDE's debugging facilities. Mbed CLI supports exporting to Keil uVision, IAR Workbench, a Makefile using GCC Arm, Eclipse using GCC Arm and other IDEs.\r\n\r\nFor example, to export to uVision, run:\r\n\r\n```\r\n$ mbed export -i uvision -m K64F\r\n```\r\n\r\nMbed CLI creates a `.uvprojx` file in the root project directory. You can open the project file with uVision.\r\n\r\n### Serial terminal\r\n\r\nYou can open a serial terminal to the COM port of a connected Mbed target (usually board) using the `mbed sterm` command. If no COM port is specified, Mbed CLI will attempt to detect the connected Mbed targets and their COM ports.\r\n\r\nThere are various options to `mbed sterm`:\r\n* `--port <COM port>` to specify system COM port to connect to.\r\n* `--baudrate <numeric>` to select the communication baudrate, where the default value is 9600.\r\n* `--echo <on|off>` to switch local echo (default is `on`).\r\n* `--reset` to reset the connected target by sending Break before opening the serial terminal.\r\n\r\nYou can also set default port, baudrate and echo mode using the `TERM_PORT`, `TERM_BAUDRATE` and `TERM_ECHO` Mbed CLI configuration options.\r\n\r\nThe following shortcuts are available within the serial terminal:\r\n- Ctrl+b - Send Break (reset target)\r\n- Ctrl+c - Exit terminal\r\n- Ctrl+e - Toggle local echo\r\n- Ctrl+h - Help\r\n- Ctrl+t - Menu escape key\r\n- _More shortcuts can be viewed within the serial terminal's help menu (Ctrl+h)._\r\n\r\nYou can also add the `--sterm` option to `mbed compile -f` to compile a new program, flash the program/firmware image to the connected target and then open the serial terminal to it's COM port:\r\n\r\n```\r\n$ mbed compile -t GCC_ARM -m K64F -f --sterm\r\n```\r\n\r\n## Testing\r\n\r\nUse the `mbed test` command to compile and run tests.\r\n\r\nThe arguments to `test` are:\r\n* `-m <MCU>` to select a target for the compilation. If `detect` or `auto` parameter is passed, then Mbed CLI will attempt to detect the connected target and compile against it.\r\n* `-t <TOOLCHAIN>` to select a toolchain (of those defined in `mbed_settings.py`, see above), where `toolchain` can be either `ARM` (Arm Compiler 5), `GCC_ARM` (GNU Arm Embedded), or `IAR` (IAR Embedded Workbench for Arm).\r\n* `--compile-list` to list all the tests that can be built.\r\n* `--run-list` to list all the tests that can be run (they must be built first).\r\n* `--compile` to only compile the tests.\r\n* `--run` to only run the tests.\r\n* `-n <TESTS_BY_NAME>` to limit the tests built or run to a comma separated list (ex. test1,test2,test3).\r\n* `--source <SOURCE>` to select the source directory. Default is `.` (the current directory). You can specify multiple source locations, even outside the program tree.\r\n* `--build <BUILD>` to select the build directory. Default: `BUILD/` inside your program.\r\n* `--profile <PATH_TO_BUILD_PROFILE>` to select a path to a build profile configuration file. Example: `mbed-os/tools/profiles/debug.json`.\r\n* `-c or --clean` to clean the build directory before compiling.\r\n* `--test-spec <TEST_SPEC>` to set the path for the test spec file used when building and running tests (the default path is the build directory).\r\n* `-v` or `--verbose` for verbose diagnostic output.\r\n* `-vv` or `--very_verbose` for very verbose diagnostic output.\r\n\r\nInvoke `mbed test`:\r\n\r\n```\r\n$ mbed test -m K64F -t GCC_ARM\r\nBuilding library mbed-build (K64F, GCC_ARM)\r\nBuilding project GCC_ARM to TESTS-unit-myclass (K64F, GCC_ARM)\r\nCompile: main.cpp\r\nLink: TESTS-unit-myclass\r\nElf2Bin: TESTS-unit-myclass\r\n+-----------+-------+-------+------+\r\n| Module    | .text | .data | .bss |\r\n+-----------+-------+-------+------+\r\n| Fill      |   74  |   0   | 2092 |\r\n| Misc      | 47039 |  204  | 4272 |\r\n| Subtotals | 47113 |  204  | 6364 |\r\n+-----------+-------+-------+------+\r\nAllocated Heap: 65540 bytes\r\nAllocated Stack: 32768 bytes\r\nTotal Static RAM memory (data + bss): 6568 bytes\r\nTotal RAM memory (data + bss + heap + stack): 104876 bytes\r\nTotal Flash memory (text + data + misc): 48357 bytes\r\nImage: build\\tests\\K64F\\GCC_ARM\\TESTS\\mbedmicro-rtos-mbed\\mutex\\TESTS-unit-myclass.bin\r\n...[SNIP]...\r\nmbedgt: test suite report:\r\n+--------------+---------------+---------------------------------+--------+--------------------+-------------+\r\n| target       | platform_name | test suite                      | result | elapsed_time (sec) | copy_method |\r\n+--------------+---------------+---------------------------------+--------+--------------------+-------------+\r\n| K64F-GCC_ARM | K64F          | TESTS-unit-myclass              | OK     | 21.09              |    shell    |\r\n+--------------+---------------+---------------------------------+--------+--------------------+-------------+\r\nmbedgt: test suite results: 1 OK\r\nmbedgt: test case report:\r\n+--------------+---------------+------------------------------------------+--------+--------+--------+--------------------+\r\n| target       | platform_name | test suite         | test case           | passed | failed | result | elapsed_time (sec) |\r\n+--------------+---------------+--------------------+---------------------+--------+--------+--------+--------------------+\r\n| K64F-GCC_ARM | K64F          | TESTS-unit-myclass | TESTS-unit-myclass1 | 1      | 0      | OK     | 5.00               |\r\n| K64F-GCC_ARM | K64F          | TESTS-unit-myclass | TESTS-unit-myclass2 | 1      | 0      | OK     | 5.00               |\r\n| K64F-GCC_ARM | K64F          | TESTS-unit-myclass | TESTS-unit-myclass3 | 1      | 0      | OK     | 5.00               |\r\n+--------------+---------------+--------------------+---------------------+--------+--------+--------+--------------------+\r\nmbedgt: test case results: 3 OK\r\nmbedgt: completed in 21.28 sec\r\n```\r\n\r\nYou can find the compiled binaries and test artifacts in the `BUILD/tests/<TARGET>/<TOOLCHAIN>` directory of your program.\r\n\r\n#### Finding available tests\r\n\r\nYou can find the tests that are available for **building** by using the `--compile-list` option:\r\n\r\n```\r\n$ mbed test --compile-list\r\nTest Case:\r\n    Name: TESTS-functional-test1\r\n    Path: .\\TESTS\\functional\\test1\r\nTest Case:\r\n    Name: TESTS-functional-test2\r\n    Path: .\\TESTS\\functional\\test2\r\nTest Case:\r\n    Name: TESTS-functional-test3\r\n    Path: .\\TESTS\\functional\\test3\r\n```\r\n\r\nYou can find the tests that are available for **running** by using the `--run-list` option:\r\n\r\n```\r\n$ mbed test --run-list\r\nmbedgt: test specification file '.\\build\\tests\\K64F\\ARM\\test_spec.json' (specified with --test-spec option)\r\nmbedgt: using '.\\build\\tests\\K64F\\ARM\\test_spec.json' from current directory!\r\nmbedgt: available tests for built 'K64F-ARM', location '.\\build\\tests\\K64F\\ARM'\r\n        test 'TESTS-functional-test1'\r\n        test 'TESTS-functional-test2'\r\n        test 'TESTS-functional-test3'\r\n```\r\n\r\n#### Compiling and running tests\r\n\r\nYou can specify to only **build** the tests by using the `--compile` option:\r\n\r\n```\r\n$ mbed test -m K64F -t GCC_ARM --compile\r\n```\r\n\r\nYou can specify to only **run** the tests by using the `--run` option:\r\n\r\n```\r\n$ mbed test -m K64F -t GCC_ARM --run\r\n```\r\n\r\nIf you don't specify any of these, `mbed test` will first compile all available tests and then run them.\r\n\r\n#### Limiting the test scope\r\n\r\nYou can limit the scope of the tests built and run by using the `-n` option. This takes a comma-separated list of test names as an argument:\r\n\r\n```\r\n$ mbed test -m K64F -t GCC_ARM -n TESTS-functional-test1,TESTS-functional-test2\r\n```\r\n\r\nYou can use the wildcard character `*` to run a group of tests that share a common prefix without specifying each test individually. For instance, if you only want to run the three tests `TESTS-functional-test1`, `TESTS-functional-test2` and `TESTS-functional-test3`, but you have other tests in your project, you can run:\r\n\r\n```\r\n$ mbed test -m NUCLEO_F429ZI -t GCC_ARM -n TESTS-functional*\r\n```\r\n\r\n**Note:** Some shells expand the wildcard character `*` into file names that exist in your working directory. To prevent this behavior, please see your shell's documentation.\r\n\r\n### Test directory structure\r\n\r\nTest code must follow this directory structure:\r\n\r\n```\r\nmbed-os-program\r\n |- main.cpp            # Optional main.cpp with main() if it is an application module.\r\n |- pqr.lib             # Required libs\r\n |- xyz.lib\r\n |- mbed-os\r\n |  |- frameworks        # Test dependencies\r\n |  |  `_greentea-client # Greentea client required by tests.\r\n |  |...\r\n |  `- TESTS              # Tests directory. Special name upper case TESTS is excluded during application build process\r\n |     |- TestGroup1      # Test Group directory\r\n |     |  `- TestCase1    # Test case source directory\r\n |     |      `- main.cpp # Test source\r\n |     |- TestGroup2\r\n |     |   `- TestCase2\r\n |     |      `- main.cpp\r\n |     `- host_tests      # Python host tests script directory\r\n |        |- host_test1.py\r\n |        `- host_test2.py\r\n `- build                 # Build directory\r\n     |- <TARGET>          # Target directory\r\n     | `- <TOOLCHAIN>     # Toolchain directory\r\n     |   |- TestCase1.bin # Test binary\r\n     |   `- TestCase2.bin\r\n     | ....\r\n```\r\n\r\nAs shown above, tests exist inside `TESTS\\testgroup\\testcase\\` directories. Please note that `TESTS` is a special upper case directory that is excluded from module sources while compiling.\r\n\r\n<span class=\"notes\">**Note:** `mbed test` does not work in applications that contain a  `main` function that is outside of a `TESTS` directory.</span>\r\n\r\n## Unit testing\r\n\r\nUse the `mbed test --unittests` command to build and run unit tests, or to generate files for new unit tests.\r\n\r\nBuild and run unit tests with `mbed test --unittests`. The arguments are:\r\n\r\n* `--compile` to only compile unit tests.\r\n* `--run` to only run unit tests.\r\n* `-c` or `--clean` to clean build directory.\r\n* `--profile debug` to prepare debug build.\r\n* `--coverage <TYPE>` to generate code coverage report where TYPE can be \"html\", \"xml\" or \"both\".\r\n* `-m <NAME>` or `--make-program <NAME>` to select which make build tool to use where NAME can be \"make\", \"gmake\", \"mingw32-make\" or \"ninja\".\r\n* `-g <NAME>` or `--generator <NAME>` to select which CMake generator to use where NAME can be \"Unix Makefiles\", \"MinGW Makefiles\" or \"Ninja\".\r\n* `-r <EXPRESSION>` or `--regex <EXPRESSION>` to run tests matching the regular expression.\r\n* `--build <PATH>` to specify build directory.\r\n* `-v` or `--verbose` for verbose diagnostic output.\r\n\r\nGenerate files for a new unit test with `mbed test --unittests --new <FILE>`.\r\n\r\n### Building and running unit tests\r\n\r\nYou can specify to only **build** the unit tests by using the `--compile option:\r\n\r\n```\r\n$ mbed test --unittests --compile\r\n```\r\n\r\nYou can specify to only **run** the unit tests by using the `--run` option:\r\n\r\n```\r\n$ mbed test --unittests --run\r\n```\r\n\r\nIf you do not specify any of these, `mbed test --unittests` will build all available unit tests and run them.\r\n\r\n### Running a subset of tests\r\n\r\nYou can run a **limited set** of unit tests by using the `-r` or `--regex` option. This takes a regular expression, which it compares against the test names. For example to run all cellular unit tests you can specify:\r\n\r\n```\r\n$ mbed test --unittests -r cellular\r\n```\r\n\r\n### Getting code coverage\r\n\r\nYou can generate a code coverage report by using the `--coverage` option. For example to create an html report you can specify:\r\n\r\n```\r\n$ mbed test --unittests --coverage html\r\n```\r\n\r\n### Creating new unit tests\r\n\r\nAll unit tests are under `mbed-os/UNITTESTS` directory. You can **generate** the necessary files for a unit test by using the `--new` option. For example to create the files for `rtos/Semaphore.cpp` you can specify:\r\n\r\n```\r\n$ mbed test --unittests --new rtos/Semaphore.cpp\r\n```\r\n\r\n## Device Update\r\n\r\nArm Mbed OS allows you to update your device firmware, enabled by our Pelion IoT platform. Mbed CLI includes features to prepare and ship updates for devices managed through the [Device Management Portal](https://cloud.mbed.com/docs/current/introduction/index.html). Mbed CLI provides the subcommand `mbed device-management` to manage devices (`mbed dev-mgmt` and `mbed dm` are also available as shorter aliases). The remainder of this document uses the `mbed dm` alias for all device management subcommands. This document explains the steps to enable and use Pelion Device Management with a project.\r\n\r\n### Project setup\r\n\r\nConfigure your Mbed Cloud SDK API key, target and toolchain. Obtain the API key from the the Device Management Portal.\r\n\r\n```\r\n$ mbed config -G CLOUD_SDK_API_KEY <API_KEY>\r\n$ mbed target K64F\r\n$ mbed toolchain GCC_ARM\r\n```\r\n\r\nInitialize the device management feature of Mbed CLI with the following command:\r\n\r\n```\r\n$ mbed dm init -d \"<company domain name>\" --model-name \"<product model identifier>\"\r\n```\r\n\r\n<span class=\"notes\">**Note:** If you do not want to enter the subject information for your update certificate (country, state, city, organization and so on), add the `-q` flag to the command above.</span>\r\n\r\nThis command asks for information about your update certificate. After completing the prompts, Mbed CLI creates several files:\r\n\r\n- A certificate in `.update-certificates/default.der`.\r\n- A matching private key in `.update-certificates/default.key.pem`.\r\n- A set of default settings in `.manifest_tool.json`.\r\n- Device Management update credentials in `update_defalut_resources.c`\r\n- Device Management settings in `.mbed_cloud_config.json`, including default settings for:\r\n   - A unique vendor identifier, based on the domain name supplied as the `-d` parameter to `mbed dm init`.\r\n   - A unique model identifier, based on the vendor identifier and the model name supplied as the `--model-name` to `mbed dm init`.\r\n   - The path of the update certificate and private key.\r\n- Device Management developer credentials in `mbed_cloud_dev_credentials.c`\r\n\r\n<span class=\"notes\">**Note:** The certificate created in `mbed dm init` is not suitable for production. Use it for testing and development only. To create a certificate for production purposes, use an air-gapped computer or a Hardware Security Module. When going to production, conduct a security review on your manifest signing infrastructure because it is the core of the security guarantees for update client.</span>\r\n\r\n### Single-device update\r\n\r\nMbed CLI provides a subcommand, `mbed dm update device`, for development with a device and for testing purposes. After following the steps in [Project setup](#project-setup), perform firmware updates on a device by running:\r\n\r\n```\r\n$ mbed compile\r\n```\r\n\r\nThis generates a payload to update the device with. After generating the payload, update the device through Device Management with:\r\n\r\n```\r\n$ mbed dm update device -D <device ID> -m <target>\r\n```\r\n\r\nThis performs several actions:\r\n\r\n1. Upload the payload, generated by `mbed compile`, to Device Management.\r\n1. Hash the payload, and create a manifest that links to its location in Device Management.\r\n1. Create an update campaign for the supplied device ID, with the newly created manifest.\r\n1. Start the campaign.\r\n1. Wait for the campaign to complete.\r\n1. Delete the payload, manifest and update campaign out of Device Management.\r\n\r\n### Multidevice update\r\n\r\nTo update more than one device, use Mbed CLI to generate and upload a manifest and payload to the Device Management portal. Then use the Device Management portal to create device filters that include many devices in an update campaign. After the steps in [Project Setup](#project-setup), you can create and upload manifests and payloads by running:\r\n\r\n```\r\n$ mbed compile\r\n```\r\n\r\nThis generates a payload to update the device with. After generating the payload, upload the payload and manifest with:\r\n\r\n```\r\n$ mbed dm update prepare\r\n```\r\n\r\n`mbed dm update prepare` automatically uses the update payload that `mbed compile` generates. You may provide a name and description for the payload and corresponding manifest with additional arguments:\r\n\r\n```\r\n$ mbed dm update prepare -n <PAYLOAD_NAME> -d <PAYLOAD_DESCRIPTION>\\\r\n    --manifest-name <MANIFEST_NAME> --manifest-description <MANIFEST_DESCRIPTION>\r\n```\r\n\r\nBoth methods of creating a manifest use the defaults created in `mbed dm init`. You can override each default using an input file or command-line arguments.\r\n\r\nOnce you execute `mbed dm update prepare`, Mbed CLI automatically uploads the payload and manifest to Device Management, and you can then create and start an [update campaign](https://cloud.mbed.com/docs/current/updating-firmware/update-campaigns.html) using the Device Management Portal.\r\n\r\n### Advanced use\r\n\r\nMbed CLI allows for significantly more flexibility than the model above shows in exactly the same way as [the manifest tool](https://cloud.mbed.com/docs/current/updating-firmware/manifest-tool.html). You can override each of the defaults that `mbed dm init` sets by using the command-line or an input file. Mbed CLI supports a variety of commands. You can print a full list of commands by using `manifest-tool --help`.\r\n\r\n## Publishing your changes\r\n\r\n### Checking status\r\n\r\nAs you develop your program, you'll edit parts of it. You can get the status of all the repositories in your program (recursively) by running `mbed status`. If a repository has uncommitted changes, this command displays these changes.\r\n\r\nHere's an example:\r\n\r\n```\r\n[mbed] Status for \"mbed-os-program\":\r\n M main.cpp\r\n M mbed-os.lib\r\n?? gdb_log.txt\r\n?? test_spec.json\r\n\r\n[mbed] Status for \"mbed-os\":\r\n M tools/toolchains/arm.py\r\n M tools/toolchains/gcc.py\r\n\r\n[mbed] Status for \"mbed-client-classic\":\r\n M source/m2mtimerpimpl.cpp\r\n\r\n[mbed] Status for \"mbed-mesh-api\":\r\n M source/include/static_config.h\r\n```\r\n\r\nYou can then commit or discard these changes through that repository's version control system.\r\n\r\n### Pushing upstream\r\n\r\nTo push the changes in your local tree upstream, run `mbed publish`. `mbed publish` works recursively, pushing the leaf dependencies first, then updating the dependents and pushing them too.\r\n\r\nLet's assume that the list of dependencies of your program (obtained by running `mbed ls`) looks like this:\r\n\r\n```\r\nmy-mbed-os-example (#a5ac4bf2e468)\r\n|- mbed-os (#182bbd51bc8d, tags: latest, mbed-os-5.6.5)\r\n`- my-libs (#e39199afa2da)\r\n   |- my-libs/iot-client (#571cfef17dd0)\r\n   `- my-libs/test-framework (#cd18b5a50df4)\r\n```\r\n\r\nLet's assume that you make changes to `iot-client`. `mbed publish` detects the change on the leaf `iot-client` dependency and asks you to commit it. Then `mbed publish` detects that `my-libs` depends on `iot-client`, updates the `my-libs` dependency on `iot-client` to its latest version by updating the `iot-client.lib` file and asks you to commit it. This propagates up to `my-libs` and finally to your program, `my-mbed-os-example`.\r\n\r\n## Publishing a local program or library\r\n\r\nWhen you create a new (local) version control managed program or library, its revision history exists only locally. The repository is not associated with the remote one. To publish the local repository, please follow these steps:\r\n\r\n1. Create a new empty repository on the remote site. This can be on a public repository hosting service (GitHub, Bitbucket, mbed.org), your own service or a different location on your system.\r\n1. Copy the URL/location of the new repository in your clipboard.\r\n1. Open command-line in the local repository directory (for example, change directory to `mbed-os-example/local-lib`).\r\n1. To associate the local repository:\r\n * For Git, run `git remote add origin <url-or-path-to-your-remote-repo>`.\r\n * For Mercurial, edit .hg/hgrc and add (or replace if exists):\r\n\r\n            ```\r\n            [paths]\r\n            default = <url-or-path-to-your-remote-repo>\r\n            ```\r\n\r\n1. Run `mbed publish` to publish your changes.\r\n\r\nIn a scenario with nested local repositories, start with the leaf repositories first.\r\n\r\n### Forking workflow\r\n\r\nGit enables a workflow where the publish/push repository may be different than the original (\"origin\") one. This allows new revisions in a fork repository while maintaining an association with the original repository. To use this workflow, first import an Mbed OS program or Mbed OS itself, and then associate the push remote with your fork. For example:\r\n\r\n```\r\n$ git remote set-url --push origin https://github.com/screamerbg/repo-fork\r\n```\r\n\r\nBoth `git commit & git push` and `mbed publish` push the new revisions to your fork. You can fetch from the original repository using `mbed update` or `git pull`. If you explicitly want to fetch or pull from your fork, then you can use `git pull https://github.com/screamerbg/repo-fork [branch]`.\r\n\r\nThrough the workflow explained above, Mbed CLI maintains association to the original repository (which you may want to send a pull request to) and records references with the revision hashes that you push to your fork. Until your pull request (PR) is accepted, all recorded references are invalid. Once the PR is accepted, all revision hashes from your fork become part the original repository, making them valid.\r\n\r\n## Updating programs and libraries\r\n\r\nYou can update programs and libraries on your local machine so that they pull in changes from the remote sources (Git or Mercurial).\r\n\r\nAs with any Mbed CLI command, `mbed update` uses the current directory as a working context. Before calling `mbed update`, you should change your working directory to the one you want to update. For example, if you're updating `mbed-os`, use `cd mbed-os` before you begin updating.\r\n\r\n<span class=\"tips\">**Tip: Synchronizing library references:** Before triggering an update, you may want to synchronize any changes that you've made to the program structure by running `mbed sync`, which updates the necessary library references and removes the invalid ones.</span>\r\n\r\n### Protection against overwriting local changes\r\n\r\nThe update command fails if there are changes in your program or library that `mbed update` could overwrite. This is by design. Mbed CLI does not run operations that would result in overwriting uncommitted local changes. If you get an error, take care of your local changes (commit or use one of the options below), and then rerun `mbed update`.\r\n\r\n### Updating to an upstream version\r\n\r\nBefore updating a program or a library, it's good to know the names of the stable releases, usually marked with a tag using a common format, such as `1.2`, `v1.0.1`, `r5.6`, `mbed-os-5.6` and so on. \r\n\r\nYou can find stable release versions of a program or a library using the `mbed releases` command:\r\n\r\n```\r\n$ cd mbed-os\r\n$ mbed releases\r\nmbed-os (#182bbd51bc8d, tags: latest, mbed-os-5.6.5)\r\n  ...\r\n  * mbed-os-5.6.0 \r\n  * mbed-os-5.6.1 \r\n  * mbed-os-5.6.2 \r\n  * mbed-os-5.6.3 \r\n  * mbed-os-5.6.4 \r\n  * mbed-os-5.6.5  <- current\r\n```\r\n\r\nYou can also recursively list stable releases for your program and libraries using the `-r` switch, for example `mbed releases -r`.\r\n\r\nLastly, you can list unstable releases, such as release candidates, alphas and betas by using the `-u` switch.\r\n\r\n```\r\n$ cd mbed-client\r\n$ mbed releases -u\r\nmbed-client (#31e5ce203cc0, tags: v3.0.0)\r\n  * mbed-os-5.0-rc1 \r\n  * mbed-os-5.0-rc2 \r\n  * r0.5-rc4 \r\n  ...\r\n  * v2.2.0 \r\n  * v2.2.1 \r\n  * v3.0.0  <- current\r\n```\r\n\r\nYou can use the `-a` switch to print release and revision hash pairs.\r\n\r\nMbed CLI recognizes stable release if the tags are in standard versioning format, such as `MAJOR[.MINOR][.PATCH][.BUILD]`, and optionally prefixed with either `v`, `r` or `mbed-os`. Unstable releases can be suffixed with any letter/number/hyphen/dot combination.\r\n\r\n#### Updating a program\r\n\r\nTo update your program to another upstream version, go to the root folder of the program, and run:\r\n\r\n```\r\n$ mbed update [branch|tag|revision]\r\n```\r\n\r\nThis fetches new revisions from the remote repository, updating the program to the specified branch, tag or revision. If you don't specify any of these, then `mbed update` updates to the latest revision of the current branch. `mbed update` performs this series of actions recursively against all dependencies in the program tree.\r\n\r\n\r\n#### Updating a library\r\n\r\nYou can change the working directory to a library folder and use `mbed update` to update that library and its dependencies to a different revision than the one referenced in the parent program or library. This allows you to experiment with different versions of libraries/dependencies in the program tree without having to change the parent program or library.\r\n\r\nThere are three additional options that modify how unpublished local libraries are handled:\r\n\r\n* `mbed update --clean-deps` - Update the current program or library and its dependencies, and discard all local unpublished repositories. Use this with caution because your local unpublished repositories cannot be restored unless you have a backup copy.\r\n\r\n* `mbed update --clean-files` - Update the current program or library and its dependencies, discard local uncommitted changes and remove any untracked or ignored files. Use this with caution because your local unpublished repositories cannot be restored unless you have a backup copy.\r\n\r\n* `mbed update --ignore` - Update the current program or library and its dependencies, and ignore any local unpublished libraries (they won't be deleted or modified, just ignored).\r\n\r\n### Update examples\r\n\r\nThere are two main scenarios when updating:\r\n\r\n* Update with local uncommitted changes: *dirty* update.\r\n\r\nRun `mbed update [branch|tag|revision]`. You might have to commit or stash your changes if the source control tool (Git or Mercurial) throws an error that the update will overwrite local changes.\r\n\r\n* Discard local uncommitted changes: *clean* update.\r\n\r\nRun `mbed update [branch|tag|revision] --clean`\r\n\r\nSpecifying a branch to `mbed update` will only check out that branch and won't automatically merge or fast-forward to the remote/upstream branch. You can run `mbed update` to merge (fast-forward) your local branch with the latest remote branch. On Git, you can do `git pull`.\r\n\r\n<span class=\"warnings\">**Warning**: The `--clean` option tells Mbed CLI to update that program or library and its dependencies and discard all local changes. This action cannot be undone; use with caution.</span>\r\n\r\n#### Combining update options\r\n\r\nYou can combine the options of the Mbed update command for the following scenarios:\r\n\r\n* `mbed update --clean --clean-deps --clean-files` - Update the current program or library and its dependencies, remove all local unpublished libraries, discard local uncommitted changes and remove all untracked or ignored files. This wipes every single change that you made in the source tree and restores the stock layout.\r\n\r\n* `mbed update --clean --ignore` - Update the current program or library and its dependencies, but ignore any local repositories. Mbed CLI updates whatever it can from the public repositories.\r\n\r\nUse these with caution because your uncommitted changes and unpublished libraries cannot be restored.\r\n\r\n## Repository caching\r\n\r\nTo minimize traffic and reduce import times, by default Mbed CLI caches repositories by storing their indexes under the Mbed CLI user config folder - typically `~/.mbed/mbed-cache/` on UNIX systems, or `%userprofile%/.mbed/mbed-cache/` on Windows systems. Compared to a fully checked out repository, indexes are significantly smaller in size and number of files and contain the whole revision history of that repository. This allows Mbed CLI to quickly create copies of previously downloaded repository indexes and pull/fetch only the latest changes from the remote repositories, therefore dramatically reducing network traffic and download times, especially for big repositories such as `mbed-os`.\r\n\r\nYou can manage the Mbed CLI caching behavior with the following subcommands:\r\n\r\n```\r\nmbed cache [on|off|dir <path>|ls|purge|-h|--help]\r\n```\r\n\r\n * `on` - Turn repository caching on. This uses either the user specified cache directory or the default one. See \"dir\".\r\n * `off` - Turn repository caching off. Note that this doesn't purge cached repositories. See \"purge\".\r\n * `dir` - Set cache directory. Set to \"default\" to let Mbed CLI determine the cache directory location. Typically, this is `~/.mbed/mbed-cache/` on UNIX systems, or `%%userprofile%%/.mbed/mbed-cache/` on Windows systems.\r\n * `ls` - List cached repositories and their size.\r\n * `purge` - Purge cached repositories. Note that this doesn't turn caching off.\r\n * `-h` or `--help` - Print cache command options.\r\n\r\nIf no subcommand is specified to `mbed cache`, Mbed CLI prints the current cache setting (ENABLED or DISABLED) and the path to the local cache directory.\r\n\r\nFor safety reasons, Mbed CLI uses the `mbed-cache` subfolder to a user specified location. This ensures that no user files are deleted during `purge` even if the user has specified root/system folder as a cache location (for example, `mbed cache dir /` or `mbed cache dir C:\\`).\r\n\r\n**Security notice**: If you use cache location outside your user home/profile directory, then other system users might be able to access the repository cache and therefore the data of the cached repositories.\r\n\r\n### Offline mode\r\n\r\nThrough the caching feature in Mbed CLI, you can enable offline mode, which uses the already cached repositories on your system. You can enable offline mode by adding the `--offline` switch to `mbed import`, `mbed add`, `mbed update` and `mbed new`.\r\n\r\nIn offline mode, Mbed CLI looks up locally cached repositories and uses them without fetching new content from their remote repositories. This is particularly useful if for example you are in a plane and you'd like to create another Mbed OS project (assuming you've imported or created one before), but you don't have access to the internet. By using the command `mbed new <project_name> --offline`, you can create the project with Mbed OS included.\r\n\r\n## Mbed CLI configuration\r\n\r\nYou can streamline many options in Mbed CLI with global and local configuration.\r\n\r\nThe Mbed CLI configuration syntax is:\r\n\r\n```\r\nmbed config [--global] <var> [value] [--unset]\r\n```\r\n\r\n* The **global** configuration (via `--global` option) defines the default behavior of Mbed CLI across programs unless overridden by *local* settings.\r\n* The **local** configuration (without `--global`) is specific to the Mbed program and allows overriding of global or default Mbed CLI settings.\r\n* If you do not specify a value, then Mbed CLI prints the value for this setting in this context.\r\n* The `--unset` option allows you to remove a setting.\r\n* The `--list` option allows you to list global and local configuration.\r\n\r\nHere is a list of configuration settings and their defaults:\r\n\r\n * `target` - defines the default target for `compile`, `test` and `export`; an alias of `mbed target`. Default: none.\r\n * `toolchain` - defines the default toolchain for `compile` and `test`; can be set through `mbed toolchain`. Default: none.\r\n * `ARM_PATH`, `ARMC6_PATH`, `GCC_ARM_PATH`, `IAR_PATH` - defines the path to Arm Compiler 5 and 6, GCC Arm and IAR Workbench toolchains. Default: none.\r\n * `protocol` - defines the default protocol used for importing or cloning of programs and libraries. The possible values are `https`, `http` and `ssh`. Use `ssh` if you have generated and registered SSH keys (Public Key Authentication) with a service such as GitHub, GitLab, Bitbucket and so on. Read more about SSH keys [here](https://help.github.com/articles/generating-an-ssh-key/). Default: `https`.\r\n * `depth` - defines the *clone* depth for importing or cloning and applies only to *Git* repositories. Note that though this option may improve cloning speed, it may also prevent you from correctly checking out a dependency tree when the reference revision hash is older than the clone depth. Read more about shallow clones [here](https://git-scm.com/docs/git-clone). Default: none.\r\n\r\n## Troubleshooting\r\n\r\n### Unable to import Mercurial (mbed.org) programs or libraries.\r\n1. Check whether you have Mercurial installed in your system path by  running `hg` in command prompt. If you're receiving \"command not found\" or a similar message, then you need to install Mercurial, and add it to your system path.\r\n\r\n2. Try to clone a Mercurial repository directly. For example, `hg clone https://developer.mbed.org/teams/mbed/code/mbed_blinky/`. If you receive an error similar to `abort: error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.:590)`, then your system certificates are out of date. You need to update your system certificates and possibly add the host certificate fingerprint of `mbed.com` and `mbed.org`. Read more about Mercurial's certificate management [here](https://www.mercurial-scm.org/wiki/CACertificates).\r\n\r\n### Various issues when running Mbed CLI in Cygwin environment\r\nCurrently Mbed CLI is not compatible with Cygwin environment and cannot be executed inside it (https://github.com/ARMmbed/mbed-cli/issues/299).\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://github.com/ARMmbed/mbed-cli",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mbed-cli",
    "package_url": "https://pypi.org/project/mbed-cli/",
    "platform": "",
    "project_url": "https://pypi.org/project/mbed-cli/",
    "project_urls": {
      "Homepage": "http://github.com/ARMmbed/mbed-cli"
    },
    "release_url": "https://pypi.org/project/mbed-cli/1.8.1/",
    "requires_dist": null,
    "requires_python": ">=2.7.10,!=3.0.*,!=3.1.*,<4",
    "summary": "Arm Mbed command line tool for repositories version control, publishing and updating code from remotely hosted repositories (GitHub, GitLab and mbed.com), and invoking Mbed OS own build system and export functions, among other operations",
    "version": "1.8.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8614879,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5f1a3157d882a1c9b2e67d6cc7a1825a1c77ae8129aae49a9753e68d776013a0",
        "md5": "db9502b6f616f9670f25c43a8acc9887",
        "sha256": "8832c329839ff0bc2a7e46e72d9a1b531297892eac5255c894cec9f0b49fd97f"
      },
      "downloads": -1,
      "filename": "mbed_cli-1.8.1-py2-none-any.whl",
      "has_sig": false,
      "md5_digest": "db9502b6f616f9670f25c43a8acc9887",
      "packagetype": "bdist_wheel",
      "python_version": "py2",
      "requires_python": ">=2.7.10,!=3.0.*,!=3.1.*,<4",
      "size": 53959,
      "upload_time": "2018-09-13T12:51:53",
      "upload_time_iso_8601": "2018-09-13T12:51:53.693748Z",
      "url": "https://files.pythonhosted.org/packages/5f/1a/3157d882a1c9b2e67d6cc7a1825a1c77ae8129aae49a9753e68d776013a0/mbed_cli-1.8.1-py2-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0ce5d6eb0a16a4080a6823a1b9efe694acc31d62cf93cb64a09ddf6e51179378",
        "md5": "ff1cec7f35d9b661a7217db75779f5c5",
        "sha256": "c1ed6d46a9e54a510375fb7a3a29659eeb15294a9f76a6b048969952ec95cad8"
      },
      "downloads": -1,
      "filename": "mbed-cli-1.8.1.tar.gz",
      "has_sig": false,
      "md5_digest": "ff1cec7f35d9b661a7217db75779f5c5",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=2.7.10,!=3.0.*,!=3.1.*,<4",
      "size": 91202,
      "upload_time": "2018-09-13T12:51:55",
      "upload_time_iso_8601": "2018-09-13T12:51:55.629353Z",
      "url": "https://files.pythonhosted.org/packages/0c/e5/d6eb0a16a4080a6823a1b9efe694acc31d62cf93cb64a09ddf6e51179378/mbed-cli-1.8.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}