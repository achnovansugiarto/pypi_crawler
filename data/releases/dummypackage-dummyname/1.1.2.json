{
  "info": {
    "author": "Dummy Name",
    "author_email": "dd@dummysolutions.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3 :: Only"
    ],
    "description": "# python3-template   [![Build Status](https://travis-ci.org/andres-fr/python3-template.svg?branch=master)](https://travis-ci.org/andres-fr/python3-template) [![PyPI version](https://badge.fury.io/py/dummypackage-dummyname.svg)](https://badge.fury.io/py/dummypackage-dummyname) [![Documentation Status](https://readthedocs.org/projects/python3-template/badge/?version=latest)](https://python3-template.readthedocs.io/en/latest/?badge=latest)\n\n\nDummy Python3 project providing structure for development, unit testing, runtime/memory benchmarking, PEP8 check, [autodocumentation](https://python3-template.readthedocs.io), and deployment to [PyPI](https://pypi.org/project/dummypackage-dummyname) and [GitHub Releases](https://github.com/andres-fr/python3-template/releases), automated via [Travis CI](https://travis-ci.org/andres-fr/python3-template) (online and locally).\n\n\n* The actual code is to be developed in the `dummypackage` library, and used in an application like `dummyapp.py`, which can be run with `python dummyapp.py`. **To ensure proper function of the tools, all subdirectories must include an `__init.py__` file**.\n\n* The unit tests are developed in the `utest` directory. They can also be arbitrarily nested, but also **must include an `__init.py__` file in each test directory**.\n\n* Reports for runtime and memory benchmarks can be generated into `timebenchmark` and `memorybenchmark` respectively.\n\n* Autodocs are also generated into `docs` in PDF as well as HTML (which can be deployed [online](https://python3-template.readthedocs.io)).\n\n* A `setup.py` script to create an OS-agnostic package into `dist` is provided, as well as functionality to deploy it into git releases and PyPI.\n\n* All these tasks can be performed manually as explained later on, and also are automated via Travis CI as it can be seen in the `.travis.yml` file, and the `ci_scripts` directory.\n\n\nThis readme has been developed for Ubuntu-like systems, but the Python examples should transfer well to other systems. Also note that this has been tested for Python 3 only, make sure that your `python` command invokes a Python 3 binary (or that you adapt the exmples presented here).\n\n\n# Dependencies:\n\nSome general dependencies are listed under the `addons` tag in the `.travis.yml` file. See `requirements.txt` for the python-specific dependencies. Also, if not using `conda`, add this line to your .bashrc to allow executing binaries installed with `pip --user`:\n\n```bash\nexport PATH=${PATH}:$HOME/.local/bin\n```\n\n# Unit Testing:\n\nAll unit test files must fulfill the following requirements (see the examples for more details):\n\n* They have to be in the `utest` directory\n* Their name has to end in `_test.py` (although this is customizable)\n* They import functionality from the package like this: `from dummypackage.foo_module import Foo`\n* They import functionality from each other like this: `from .foo_test import FooTestCaseCpu`\n* They import `unittest` and extend `unittest.TestCase` classes\n* All test method names from the extended unittest classes begin with `test` (also customizable)\n* Nested directories are allowed. However, **each test directory has to contain an empty `__init__.py` file**\n\nIf these conditions are met, all the tests can be run from the CLI or within Python.\n\n**Note**: the `utest` directory includes a special test case, `tautology.py` which should always pass and can be used to ensure that the testing facilities work correctly. Its name doesn't end in `_test.py`, so it doesn't get included in the ordinary tests and has to be called explicitly.\n\n### Run from CLI:\n\n```bash\n# run all existing tests\npython -m unittest discover -s utest -t . -p \"*_test.py\" -v\n# Run individual test modules (from the repo root dir)\npython -m unittest utest/foo_test.py -v\npython -m unittest utest/bar_test.py -v\npython -m unittest utest/nestedtests/nested_test.py -v\n# Run individual classes\npython -m unittest utest.foo_test.FooTestCaseCpu -v\npython -m unittest utest.nestedtests.nested_test.QuackTestCaseCpu -v\n# Run individual methods\npython -m unittest utest.bar_test.BarTestCaseCpu.test_inheritance -v\n```\n\n### Run within Python:\n\n```python\n\n# run all existing tests and collect results\nimport utest\nresults = utest.run_all_tests()\nprint(results)\n\n# run all tests for a given module and collect results\nimport utest.foo_test\nresults = utest.run_module(utest.foo_test);\nprint(results)\n\n# run for several modules:\nimport utest\nimport utest.foo_test as f\nimport utest.nestedtests.nested_test as n\nresults = utest.run_modules([f, n]);\nprint(results)\n\n# run for a single testcase\nimport utest\nfrom utest.foo_test import FooTestCaseCpu\nresults = utest.run_testcase(FooTestCaseCpu);\nprint(results)\n\n# run for several testcases\nimport utest\nfrom utest.foo_test import FooTestCaseCpu\nfrom utest.bar_test import BarTestCaseCpu\nresults = utest.run_testcases([FooTestCaseCpu, BarTestCaseCpu]);\nprint(results)\n\n# run for a single method\nimport utest\nresults = utest.run_testmethod(\"utest.foo_test.FooTestCaseCpu.test_loop\");\nprint(results)\n\n# run for several methods\nimport utest\nresults = utest.run_testmethods([\"utest.foo_test.FooTestCaseCpu.test_loop\",\n                                \"utest.bar_test.BarTestCaseCpu.test_loop\"]);\nprint(results)\n```\n\n\n# Code Coverage:\n\nCode coverage determines how much of the implemented code do the unit tests go through. Although not particularly sound, it can be used as a way to check that the unit testing relates closely to the developed code. Plus, it is easy to automate.\n\n### From CLI:\n\nThe usage is very similar to running with `python`, but prepending `coverage run` instead, and adding a `--source` directory, which contains the actual code pool being inspected:\n\n```\n# define the location for the coverage file:\nexport COVERAGE_FILE=codecoverage/coverage`date \"+%Y%m%d_%H%M%S\"`\n\n# Run whatever you want to run but prepending 'coverage run'\n# the --branch flag activates branch coverage (as opposed to statement coverage)\n# the -a flag will accumulate the reports\ncoverage run --source dummypackage --branch -m unittest discover -s utest -t . -p \"*_test.py\" -v\n\n# Print report on terminal\ncoverage report -m\n\n# more elaborated XML report:\ncoverage xml -o $COVERAGE_FILE.xml\n\n# interactive HTML report\ncoverage html -d $COVERAGE_FILE\\_html\nfirefox $COVERAGE_FILE\\_html/index.html\n```\n\n### Within Python:\n\nThis sample script performs unit testing AND test coverage wthout creating any files (see the script `ci_scripts/utest_with_coverage.py`):\n\n```python\n\nimport coverage\nimport utest\n\n# same as with the CLI. A suffix will be automatically added\nCOVERAGE_FILE = \"codecoverage/coverage\"\n\n# wrap the testing with the coverage analyzer:\nc = coverage.Coverage(data_file=COVERAGE_FILE, data_suffix=True, branch=True,\n                      source=[\"dummypackage\"])\nc.start()\ntest_results = utest.run_all_tests()\nc.stop()\n\n# at this point c.save() and c.html_report(outfile=etc) would generate files.\n# This instead handles the data within Python, as coverage.CoverageData\npercentage = c.report()\n\nprint(\"This script did\", test_results.testsRun, \"tests in total.\")\nprint(\"No. of test errors:\", len(test_results.errors))\nprint(\"No. of test failures:\", len(test_results.failures))\nprint(\"Code coverage of tests (percentage):\", percentage)\n```\n\n\n\n\n\n# CPU Runtime Benchmarking:\n\n\n### Run and print on terminal, sorted by total time:\n\n```bash\npython -m cProfile -s tottime dummyapp.py\n```\n\nIt can be sorted by any of these:\n```\ncalls (call count)\ncumulative (cumulative time)\ncumtime (cumulative time)\nfile (file name)\nfilename (file name)\nmodule (file name)\nncalls (call count)\npcalls (primitive call count)\nline (line number)\nname (function name)\nnfl (name/file/line)\nstdname (standard name)\ntime (internal time)\ntottime (internal time)\n```\n\nSample output:\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n      100    1.496    0.015    1.496    0.015 {method 'index' of 'list' objects}\n        1    0.023    0.023    0.023    0.023 bar_module.py:15(__init__)\n     93/1    0.016    0.000    1.590    1.590 {built-in method builtins.exec}\n        1    0.010    0.010    1.590    1.590 dummyapp.py:6(<module>)\n       47    0.005    0.000    0.005    0.000 {built-in method marshal.loads}\n  229/227    0.004    0.000    0.011    0.000 {built-in method builtins.__build_class__}\n```\n\n\n### Save to file and explore interactively with web browser using `snakeviz`:\n\n```bash\npython -m cProfile -o timebenchmark/dummyapp.`date \"+%Y%m%d_%H%M%S\"` dummyapp.py\n# open results in browser using the snakeviz server\nsnakeviz timebenchmark/dummyapp.20190112_195256\n```\n\n### Within Python:\n\nThis small snippet prints the results to the terminal and returns some relevant figures (see the script `ci_scripts/runtime_benchmark.py`):\n\n```\nimport cProfile\nimport pstats\nfrom io import StringIO\n\ndef get_total_time_and_calls(fn, sort_by=\"time\"):\n    \"\"\"\n    This function calls the given a parameterless functor while benchmarking\n    it via cProfile. A report is printed to the terminal and the tuple\n    (n_seconds, n_calls) is returned.\n    \"\"\"\n    pr = cProfile.Profile()\n    pr.enable()\n    fn()\n    pr.disable()\n    #\n    s = StringIO()\n    ps = pstats.Stats(pr, stream=s)\n    ps.strip_dirs().sort_stats(sort_by)\n    ps.print_stats()\n    print(s.getvalue())\n    #\n    return ps.total_tt, ps.total_calls\n\nget_total_time_and_calls(lambda: 2+2)\n```\n\n\n# Memory Benchmarking:\n\nThis package reports memory usage of the Python process, line-by-line or as a function of time. As with the runtime profiler, there are several ways to run this functionality.\n\n\n### Decorators:\n\nThis way requires to import and use the `@profile` decorator in the desired `def` declarations of your Python files. Unlike the other methods, it has the drawback that it requires to alter or duplicate the source code. To perform the profiling, run the decorated files (see e.g. the `memorybenchmark` directory) with the python interpreter. Sample output:\n\n\n```\nFilename: memorybenchmark/loop_benchmark.py\nLine     Mem usage    Increment   Line Contents\n================================================\n    21     14.6 MiB     14.6 MiB   @profile  # decorator for (https://pypi.org/project/memory-profiler/)\n    22                             def do_loop(clss, memsize, loopsize):\n    23                                 \"\"\"\n    24                                 Create a Foo instance and loop it.\n    25                                 \"\"\"\n    26     14.6 MiB      0.0 MiB       x = clss(memsize)\n    27     14.6 MiB      0.0 MiB       x.loop(loopsize)\n\n    21     14.6 MiB     14.6 MiB   @profile  # decorator for (https://pypi.org/project/memory-profiler/)\n    22                             def do_loop(clss, memsize, loopsize):\n    23                                 \"\"\"\n    24                                 Create a Foo instance and loop it.\n    25                                 \"\"\"\n    26     53.3 MiB     38.7 MiB       x = clss(memsize)\n    27     53.3 MiB      0.0 MiB       x.loop(loopsize)\n```\n\n\n\n### Time-based memory usage:\n\nThe module provides the `mprof` binary to perform time-based analysis. Calling `mprof run loop_benchmark.py` will generate a `mprofile_TIMESTAMP.dat` file, which can be visualized with `mprof plot`(if pylab/matplotlib is installed) and looks like this:\n\n```\nFUNC __main__.do_loop 14.4766 1547322141.5961 14.4766 1547322141.5963\nFUNC __main__.do_loop 14.4766 1547322141.5964 14.8281 1547322143.1454\nCMDLINE /usr/bin/python dummyapp.py\nMEM 1.511719 1547322141.5060\nMEM 31.281250 1547322141.6064\nMEM 53.195312 1547322141.7067\nMEM 53.195312 1547322141.8071\nMEM 53.195312 1547322141.9074\nMEM 53.195312 1547322142.0078\nMEM 53.195312 1547322142.1081\nMEM 53.195312 1547322142.2085\n```\n\nThe available `mprof` commands are:\n```bash\nmprof run: running an executable, recording memory usage\nmprof plot: plotting one the recorded memory usage (by default, the last one)\nmprof list: listing all recorded memory usage files in a user-friendly way.\nmprof clean: removing all recorded memory usage files.\nmprof rm: removing specific recorded memory usage files\n```\n\nFurther information can be found in the package homepage.\n\n### Within Python:\n\n\nThis small snippet returns memory usage as a function of time (see the script `ci_scripts/runtime_benchmark.py`). Line-by-line analysis using the `LineProfiler` class doesn't seem to be supported by this method, see the first and second approaches for alternatives:\n\n```\nfrom memory_profiler import memory_usage\n\ndef fn(times=1000, message=\"hello!\"):\n    l = []\n    for i in range(times):\n        l.append(message)\n    for i in range(times**2):\n        l.append(message)\n\nusage = memory_usage((fn, (1000, \"goodbye\")), interval=0.05)\nprint(usage)\n\n```\n\n\n# Codestyle Check:\n\nUsing it is pretty straightforward: simply call `flake8` or `python -m flake8` in the repository root directory. If any errors are present, the command will print them and return with error status.\n\nNote that some \"errors\" are actually proper design decissions. These can be bypassed with the `noqa` directive, like this: `import environment  # noqa: F401`.\n\n\n\n\n# Autodoc:\n\nThis project uses `sphinx` and `LaTeX` to automatically generate the docs. The `ci_scripts/maje_sphinx_docs.sh` script provides a most automated and flexible doc generation as HTML and PDF. It only requires the user to provide `projectname` and `author`. At the moment, it doesn't assert for input or environment errors and has to be called from the repo root as follows:\n\n```\n./ci_scripts/make_sphinx_docs.sh dummypackage \"Dummy Dumson\"\n```\n\nIt will then generate the files into `docs/_build` (they are also being uploaded to the repository as they aren't filtered by `.gitignore`).\n\n\nOptionally, you can deploy your docs into https://readthedocs.org/ by synchronizing it with your github account. Importing the repository should be straightforward: the page will automatically find your `conf.py` and generate the docs. The docs homepage of the project should provide a badge like the one at the top of this README and a link to the online docs. Note that the advertisment can be removed in the \"Admin\" tab. This repo's docs are being deployed to https://python3-template.readthedocs.io\n\nBy default, it will provide two versions of the doc: `latest` and `stable`. See this link about versioning in readthedocs: [here](https://docs.readthedocs.io/en/stable/versions.html).\n\n\n\n\n\n\n\n\n\n\n\n# Build and Deploy:\n\n\n### Tagging:\n\nOnce we reach a given milestone, we can label that specific commit with a version tag (like `v1.0.13`). The basics are discussed here: `https://git-scm.com/book/en/v2/Git-Basics-Tagging`. Especially, **note that tags have to be explicitly included in the push**: `git push --follow-tags`, otherwise, they won't be sent to the server. If you want this to be the default behaviour (as assumed in this project), call `git config --global push.followTags true`, after that every regular `git push` will also push all the valid existing tags.\n\nThere are different ways of handling the tag system, the `git` CLI and `gitpython` being very popular among them. Since we want here very specific functionality, we use the `bump2version` third-party library: It allows to automatically increment and set the version tag following semantic versioning (see `https://semver.org/`), which is highly encouraged. It works as follows:\n\n* The `.bumpversion.cfg` file holds the current version and the configuration.\n* Calling `bump2version <ADVANCE>` will automatically update the version in the `.bumpversion.cfg` and other specified files, and add the corresponding tag to the git repo. The `<ADVANCE>` parameter can be either **major**, **minor**, or **patch**.\n\nSo we just need to start our repo by setting the desired version in the `.bumpversion.cfg` file (usually `0.1.0`), and then commit normally. The process of adding a tag will be something like:\n\n```\n# Make sure you saved all files to avoid 'Git working directory is not clean' error\n# Also make sure that all specified files in the cfg file exist (e.g. docs/conf.py):\ngit add . # or whatever you want to add\ngit commit -m \"finished implementing the last feature we needed\"\nbump2version major\n```\n\n**NOTE** that the syntax of this file doesn't allow conditionals, so all specified files must exist at the moment of execution.\n\nAfter `bump2version`, doing a `git push` will send the commit to the server as usual, and the tag will automatically appear under the GitHub *Releases* tab, holding a snapshot of the current repo's state as `.zip` and `.tar.gz`.\n\n\nApparently, the format of `.bumpversion.cfg` is not standard and the tool doesn't provide a direct means to read the current version. Therefore, the following solutions are provided:\n\n1. From CLI: ``` version=`grep \"current_version\" .bumpversion.cfg | cut -d'=' -f2 | xargs` ```\n2. Within Python: See `ci_scripts/get_version.py`\n\n\n### Build and Local Install:\n\nThe `setup.py` script will build the package in *source dist* (`sdist`) and *wheel* forms. The package will be in the `dist` directory, and some files will be generated into the `build` directory too. **Important**: remember to adapt the variables in the `setup` function call to your repo's needs (except `version`, which as we seen is handled by `bump2version`).\n\n```\n# optionally clean cache to prevent side effects\npython setup.py clean --all\nrm -r *.egg-info\n# package the software\npython setup.py sdist bdist_wheel\n# now something like this will install the package locally:\npip install dist/dummypackage_dummyname-0.0.1-py3-none-any.whl\n# this will update it\npip install -U dist/dummypackage_dummyname-0.0.1-py3-none-any.whl\n# and this will remove it:\npip uninstall dist/dummypackage_dummyname-0.0.1-py3-none-any.whl\n```\n\nNote that in principle it is not necessary to build the package manually if you have automated the deployment via Travis.\n\n### GitHub Release:\n\nWe saw that tags get automatically tracked by GitHub. But for each release, we want to add two things to this default behaviour:\n\n1. Specify a changelog\n2. Pip-installable package in [wheel](https://pythonwheels.com/) format.\n\nThis can be performed manually via browser in the GitHub webpage, and also via CLI as follows:\n\n```\nTODO\n```\n\nNote that in principle it is not necessary to deploy manually if you have automated the deployment via Travis.\n\n### PyPI Release:\n\n\nThe built package can also be released to *PyPI*, a popular global repository for Python packages. The following command uploads then everything in the `dist` directory. You will need to provide your *PyPI* credentials (make a user if you don't have one):\n\n```\ntwine upload dist/*\n```\n\nNote that in principle it is not necessary to deploy manually if you have automated the deployment via Travis.\n\n\n\n\n# Travis CI:\n\n\n### Intro:\n\nIn the context of of CD/CI, a git repository (or any other similar object to automatize tasks on) is regarded as a **material**, with its specific set of **trigger actions** (e.g. commit or pull request in a git repo, or certain API requests in a custom REST system). It probably helps to think of materials as *classes*, and the actions as their *methods*.\n\nFor each of those actions, a **CD/CI pipeline** may be defined, which will be executed by the CD/CI system upon trigger by some event. Depending on the CI system, the pipelines allow some complexity like branching, but it is best practice to keep them as simple as possible.\n\nAlthough different materials have different sets of actions, the spirit is in general similar, in what is known as CI. [Quoting](https://github.com/mbonaci/mbo-storm/wiki/Integrate-Travis-CI-with-your-GitHub-repo):\n\n> \"Continuous Integration is the umbrella for various techniques and practices that every self-respecting software project should employ:\n> \n> * **Build automation** - every commit/push to an scm repo automatically triggers a new build (anything in the master branch is deployable)\n> * **Test automation** - tests are evaluated as integral part of the build process (that's old news, right?)\n> * **SCM integration** - primarily to facilitate build automation, but also to be able to report on issues, versions, milestones, ...\n> * **Project management integration** - Basecamp, Campfire, Acunote and other PM tools (people, tasks, schedules, ...)\n> * **Project Dashboard** - everything is out in the open (generally without any read access restrictions, making it available to all interested parties)\n\n\n\n### Travis and this repo:\n\n* https://docs.travis-ci.com\n* https://docs.travis-ci.com/user/languages/python/\n\nTravis is a CI/CD tool that can be easily linked to a GitHub account for free, and managed through a `travis.yaml` file present at the repo's root (More info: https://docs.travis-ci.com/user/languages/python/). The goal for this repository is to trigger Travis after each **commit** to master, to perform the following tasks:\n\n1. Run in parallel:\n   1. Check coding style with flake\n   2. Check that the tautology is true\n   3. Check that all unit tests are passing\n   4. Check that code coverage ratio is above a number\n   5. Check that running a given routine never surpasses a certain memory usage\n   6. Check that running a given routine never exceedes a certain duration\n\n2. If all checks success, build the docs and `dummypackage` into our desired architectures.\n\n3. Deploy package in a way that can be installed via `pip`+ repo link\n\n\nFor that, Travis implements two basic concepts, **stages** and **jobs**: A stage is a group of jobs that are allowed to run in parallel. However, each one of the stages runs one after another, and will only proceed if all jobs in the previous stage have passed successfully. If one job fails in one stage, all other jobs on the same stage will still complete, but all jobs in subsequent stages will be canceled, and the build fails.\n\nEach job can be mapped to a \"script\", which is a call to a program. If the script returns a nonzero status, deployment is considered a failure, and the build will be marked as “errored”.\n\nBy default, Travis starts a new virtual machine **from scratch for every single job**. All the required dependencies have to be installed prior to running the jobs. This can take a while, so it is helpful to design the CI pipeline in a way that minimizes overhead. Some of the dependencies can be shared across jobs using the `cache` keyword. Additionaly, the file cleanup that happens prior to some tasks can be also skipped.\n\n\n\n\n### Steps:\n\n1. sync your GitHub account with Travis, and allow access etc to your repositories. Finally, \"activate\" the desired repo in Travis. You should see the typical `[build | failing]` badge. Click on it and copy the markdown link into the main `README` of the repo, as shown on the top of this file.\n\n2. In your GitHub `activated_repo->settings->webhooks`, select which events you want to notify to Travis. In our case we will activate **commits** and **pull requests**. Any time any of these happens, GitHub will send a request to Travis with all the infos involved.\n\n3. Now both sides know about each other, make sure you understand the `.travis.yml` file and customize it as desired.\n\n4. For deployment, Travis will need your user credentials. As it wouldn't be safe to distribute your passwords in plain text, Travis offers you the possibility of encrypting them. In this project, we will need credentials for **PyPI** and **GitHub**:\n\n\n\n#### GitHub releases config:\n\nTravis can be configured to upload to GitHub releases by running `travis setup releases`. If you do this yourself, be careful because **this will reformat the `travis.yml` file**, deleting all comments and blank lines (although the functionality won't be affected). A temporary backup will help with this.\n\nIn the repo root, run `travis setup releases` and follow the steps:\n\n1. Confirm repo name\n2. Provide GitHub credentials\n3. Deploy only from ... -> yes\n4. Encrypt API key -> yes\n\nConveniently, this repo's `travis.yml` already provides structure for releasing into GitHub. You will, in any case, have to replace the credentials with your own ones. You can see how to do that here: `https://docs.travis-ci.com/user/deployment/releases#authenticating-with-an-oauth-token`.\n\nAlso note that the release can be customized with keywords like `name, body, draft, prerelease`.\n\n`https://docs-staging.travis-ci.com/user/deployment/releases/`.\n\n#### PyPI release config:\n\nAs with GitHub releases, the `.travis.yml` file already provides structure for deploying to PyPI. You just have to replace the credentials with your own. To encrypt your password, use the following command (more info here: `https://docs.travis-ci.com/user/encryption-keys/`). Again, be careful because **this will reformat the `travis.yml` file**, deleting all comments and blank lines (although the functionality won't be affected). A temporary backup will help with this:\n\n```\ntravis encrypt <PASSWORD> --add deploy.password\n```\n\nFor that, make sure you installed the Travis CLI (see `https://github.com/travis-ci/travis.rb#installation`).\n\n\n\n\n## TODO:\n\n\n* Find a clean way to store a changelog in the repo, and\n  1. Force user to update it upon every bumpversion\n  2. Make travis grab changes and add them to the release automatically\n  3. As OS-agnostic and automated as possible\n\n* improve `create_docs.sh`: **it should succeed only if everything succeeds**, check for environment and input consistency and should be callable from everywhere (requiring or computing repo root path).\n\n* add infrastructure for GitHub pages with Travis\n\n## MAYBE TODO:\n\n* add all OS to travis file: ATM not possible  https://github.com/travis-ci/travis-ci/issues/9744#issuecomment-419426053\n\n* Nice markup format in GH release body text: ATM not possible https://github.com/travis-ci/dpl/issues/155\n\n* add online codecov https://codecov.io/\n\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/andres-fr/python3-template",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dummypackage-dummyname",
    "package_url": "https://pypi.org/project/dummypackage-dummyname/",
    "platform": "",
    "project_url": "https://pypi.org/project/dummypackage-dummyname/",
    "project_urls": {
      "Homepage": "https://github.com/andres-fr/python3-template"
    },
    "release_url": "https://pypi.org/project/dummypackage-dummyname/1.1.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "A dummy package",
    "version": "1.1.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5833022,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a4685edb203aad0a8866fe14df3b4fe987e5315f2eb288259d91d42a3caf5ce2",
        "md5": "7bd6a0b0b407f6b5ffeef2311990388d",
        "sha256": "db95b5d04db779926469b8b270ba42c965a9fdee2e28c4fececb0854d9364e6a"
      },
      "downloads": -1,
      "filename": "dummypackage_dummyname-1.1.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7bd6a0b0b407f6b5ffeef2311990388d",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 26566,
      "upload_time": "2019-02-26T04:30:54",
      "upload_time_iso_8601": "2019-02-26T04:30:54.634199Z",
      "url": "https://files.pythonhosted.org/packages/a4/68/5edb203aad0a8866fe14df3b4fe987e5315f2eb288259d91d42a3caf5ce2/dummypackage_dummyname-1.1.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0f1adfc1c2ce5f6c0f3eb2f619ffdf78d7d1694dc7db08b685680d961ff61d2b",
        "md5": "4cb6b5e6bc6b59dd422f06296eb34582",
        "sha256": "39b0de0ba07532a9a39d5e318e66120ad61a448216b3ee46017d68ff77ff323f"
      },
      "downloads": -1,
      "filename": "dummypackage-dummyname-1.1.2.tar.gz",
      "has_sig": false,
      "md5_digest": "4cb6b5e6bc6b59dd422f06296eb34582",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 23792,
      "upload_time": "2019-02-26T04:30:55",
      "upload_time_iso_8601": "2019-02-26T04:30:55.997494Z",
      "url": "https://files.pythonhosted.org/packages/0f/1a/dfc1c2ce5f6c0f3eb2f619ffdf78d7d1694dc7db08b685680d961ff61d2b/dummypackage-dummyname-1.1.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}