{
  "info": {
    "author": "Frank Wiles",
    "author_email": "frank@revsys.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 1.11",
      "Framework :: Django :: 2.0",
      "Framework :: Django :: 2.1",
      "Framework :: Django :: 2.2",
      "Framework :: Pytest",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "# django-test-plus\n\nUseful additions to Django's default TestCase from [REVSYS](https://www.revsys.com/)\n\n<a href=\"http://travis-ci.org/revsys/django-test-plus\"><img src=\"https://secure.travis-ci.org/revsys/django-test-plus.svg\" /></a> <a href=\"https://coveralls.io/r/revsys/django-test-plus?branch=master\"><img src=\"https://coveralls.io/repos/revsys/django-test-plus/badge.svg?branch=master\" /></a>\n\n## Rationale\n\nLet's face it, writing tests isn't always fun. Part of the reason for\nthat is all of the boilerplate you end up writing. django-test-plus is\nan attempt to cut down on some of that when writing Django tests. We\nguarantee it will increase the time before you get carpal tunnel by at\nleast 3 weeks!\n\n## Support\n\nSupports: Python 2 and Python 3\n\nSupports Django Versions: 1.10, 1.11, 2.0, 2.1, 2.2\n\n## Documentation\n\nFull documentation is available at http://django-test-plus.readthedocs.org\n\n## Installation\n\n```shell\n$ pip install django-test-plus\n```\n\n## Usage\n\nUsing django-test-plus is pretty easy, simply have your tests inherit\nfrom test_plus.test.TestCase rather than the normal\ndjango.test.TestCase like so::\n\n```python\nfrom test_plus.test import TestCase\n\nclass MyViewTests(TestCase):\n    ...\n```\n\nThis is sufficient to get things rolling, but you are encouraged to\ncreate *your own* sub-class on a per project basis. This will allow you to add your own project specific helper methods.\n\nFor example, if you have a django project named 'myproject', you might\ncreate the following in `myproject/test.py`:\n\n```python\nfrom test_plus.test import TestCase as PlusTestCase\n\nclass TestCase(PlusTestCase):\n    pass\n```\n\nAnd then in your tests use:\n\n```python\nfrom myproject.test import TestCase\n\nclass MyViewTests(TestCase):\n    ...\n```\n\nNote that you can also option to import it like this if you want, which is\nmore similar to the regular importing of Django's TestCase:\n\n```python\nfrom test_plus import TestCase\n```\n\n## pytest Usage\n\nYou can get a TestCase like object as a pytest fixture now by simply asking for `tp`. All of the methods below would then work in pytest functions.  For\nexample:\n\n```python\ndef test_url_reverse(tp):\n    expected_url = '/api/'\n    reversed_url = tp.reverse('api')\n    assert expected_url == reversed_url\n```\n\nThe `tp_api` fixture will provide a `TestCase` that uses django-rest-framework's `APIClient()`:\n\n```python\ndef test_url_reverse(tp_api):\n    response = tp_api.client.post(\"myapi\", format=\"json\")\n    assert response.status_code == 200\n```\n\n## Methods\n\n### reverse(url_name, *args, **kwargs)\n\nWhen testing views you often find yourself needing to reverse the URL's name. With django-test-plus there is no need for the `from django.core.urlresolvers import reverse` boilerplate. Instead just use:\n\n```python\ndef test_something(self):\n    url = self.reverse('my-url-name')\n    slug_url = self.reverse('name-takes-a-slug', slug='my-slug')\n    pk_url = self.reverse('name-takes-a-pk', pk=12)\n```\n\nAs you can see our reverse also passes along any args or kwargs you need\nto pass in.\n\n## get(url_name, follow=True, *args, **kwargs)\n\nAnother thing you do often is HTTP get urls. Our `get()` method\nassumes you are passing in a named URL with any args or kwargs necessary\nto reverse the url_name.\nIf needed, place kwargs for `TestClient.get()` in an 'extra' dictionary.:\n\n```python\ndef test_get_named_url(self):\n    response = self.get('my-url-name')\n    # Get XML data via AJAX request\n    xml_response = self.get(\n        'my-url-name',\n        extra={'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest'})\n```\n\nWhen using this get method two other things happen for you, we store the\nlast response in `self.last_response` and the response's Context in `self.context`.\n\nSo instead of:\n\n```python\ndef test_default_django(self):\n    response = self.client.get(reverse('my-url-name'))\n    self.assertTrue('foo' in response.context)\n    self.assertEqual(response.context['foo'], 12)\n```\n\nYou can instead write:\n\n```python\ndef test_testplus_get(self):\n    self.get('my-url-name')\n    self.assertInContext('foo')\n    self.assertEqual(self.context['foo'], 12)\n```\n\nIt's also smart about already reversed URLs so you can be lazy and do:\n\n```python\ndef test_testplus_get(self):\n    url = self.reverse('my-url-name')\n    self.get(url)\n    self.response_200()\n```\n\nIf you need to pass query string parameters to your url name, you can do so like this. Assuming the name 'search' maps to '/search/' then:\n\n```python\ndef test_testplus_get_query(self):\n    self.get('search', data={'query': 'testing'})\n```\n\nWould GET `/search/?query=testing`.\n\n## post(url_name, data, follow=True, *args, **kwargs)\n\nOur `post()` method takes a named URL, the dictionary of data you wish\nto post and any args or kwargs necessary to reverse the url_name.\nIf needed, place kwargs for `TestClient.post()` in an 'extra' dictionary.:\n\n```python\ndef test_post_named_url(self):\n    response = self.post('my-url-name', data={'coolness-factor': 11.0},\n                         extra={'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest'})\n```\n\n*NOTE* Along with the frequently used get and post, we support all of the HTTP verbs such as put, patch, head, trace, options, and delete in the same fashion.\n\n## get_context(key)\n\nOften you need to get things out of the template context, so let's make that\neasy:\n\n```python\ndef test_context_data(self):\n    self.get('my-view-with-some-context')\n    slug = self.get_context('slug')\n```\n\n## assertInContext(key)\n\nYou can ensure a specific key exists in the last response's context by\nusing:\n\n```python\ndef test_in_context(self):\n    self.get('my-view-with-some-context')\n    self.assertInContext('some-key')\n```\n\n## assertContext(key, value)\n\nWe can get context values and ensure they exist, but so let's also test\nequality while we're at it. This asserts that key == value:\n\n```python\ndef test_in_context(self):\n    self.get('my-view-with-some-context')\n    self.assertContext('some-key', 'expected value')\n```\n\n## response_XXX(response, msg=None) - status code checking\n\nAnother test you often need to do is check that a response has a certain\nHTTP status code. With Django's default TestCase you would write:\n\n```python\nfrom django.core.urlresolvers import reverse\n\ndef test_status(self):\n    response = self.client.get(reverse('my-url-name'))\n    self.assertEqual(response.status_code, 200)\n```\n\nWith django-test-plus you can shorten that to be:\n\n```python\ndef test_better_status(self):\n    response = self.get('my-url-name')\n    self.response_200(response)\n```\n\ndjango-test-plus provides the following response method checks for you:\n\n- response_200()\n- response_201()\n- response_204()\n- response_301()\n- response_302()\n- response_400()\n- response_401()\n- response_403()\n- response_404()\n- response_405()\n- response_410()\n\nAll of which take an optional Django test client response and a string msg argument\nthat, if specified, is used as the error message when a failure occurs.\nIf it's available, the response_XXX methods will use the last response. So you\ncan do:\n\n```python\ndef test_status(self):\n    self.get('my-url-name')\n    self.response_200()\n```\n\nWhich is a bit shorter.\n\n## get_check_200(url_name, *args, **kwargs)\n\nGETing and checking views return status 200 is so common a test this\nmethod makes it even easier::\n\n```python\ndef test_even_better_status(self):\n    response = self.get_check_200('my-url-name')\n```\n\n## make_user(username='testuser', password='password', perms=None)\n\nWhen testing out views you often need to create various users to ensure\nall of your logic is safe and sound. To make this process easier, this\nmethod will create a user for you:\n\n```python\ndef test_user_stuff(self)\n    user1 = self.make_user('u1')\n    user2 = self.make_user('u2')\n```\n\nIf creating a User in your project is more complicated, say for example\nyou removed the `username` field from the default Django Auth model\nyou can provide a [Factory\nBoy](https://factoryboy.readthedocs.org/en/latest/) factory to create\nit or simply override this method on your own sub-class.\n\nTo use a Factory Boy factory simply create your class like this::\n\n```python\nfrom test_plus.test import TestCase\nfrom .factories import UserFactory\n\n\nclass MySpecialTest(TestCase):\n    user_factory = UserFactory\n\n    def test_special_creation(self):\n        user1 = self.make_user('u1')\n```\n\n**NOTE:** Users created by this method will have their password\nset to the string 'password' by default, in order to ease testing.\nIf you need a specific password simply override the `password` parameter.\n\nYou can also pass in user permissions by passing in a string of\n'`<app_name>.<perm name>`' or '`<app_name>.*`'.  For example:\n\n```python\nuser2 = self.make_user(perms=['myapp.create_widget', 'otherapp.*'])\n```\n\n## print_form_errors(response_or_form=None)\n\nWhen debugging a failing test for a view with a form, this method helps you\nquickly look at any form errors.\n\nExample usage:\n\n```python\nclass MyFormTest(TestCase):\n\n    self.post('my-url-name', data={})\n    self.print_form_errors()\n\n    # or\n\n    resp = self.post('my-url-name', data={})\n    self.print_form_errors(resp)\n\n    # or\n\n    form = MyForm(data={})\n    self.print_form_errors(form)\n```\n\n## Authentication Helpers\n\n### assertLoginRequired(url_name, *args, **kwargs)\n\nIt's pretty easy to add a new view to a project and forget to restrict\nit to be login required, this method helps make it easy to test that a\ngiven named URL requires auth:\n\n```python\ndef test_auth(self):\n    self.assertLoginRequired('my-restricted-url')\n    self.assertLoginRequired('my-restricted-object', pk=12)\n    self.assertLoginRequired('my-restricted-object', slug='something')\n```\n\n### login context\n\nAlong with ensuing a view requires login and creating users, the next\nthing you end up doing is logging in as various users to test our your\nrestriction logic. This can be made easier with the following context:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n    user2 = self.make_user('u2')\n\n    self.assertLoginRequired('my-protected-view')\n\n    with self.login(username=user1.username, password='password'):\n        response = self.get('my-protected-view')\n        # Test user1 sees what they should be seeing\n\n    with self.login(username=user2.username, password='password'):\n        response = self.get('my-protected-view')\n        # Test user2 see what they should be seeing\n```\n\nSince we're likely creating our users using `make_user()` from above,\nthe login context assumes the password is 'password' unless specified\notherwise. Therefore you you can do:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n\n    with self.login(username=user1.username):\n        response = self.get('my-protected-view')\n```\n\nWe can also derive the username if we're using `make_user()` so we can\nshorten that up even further like this:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n\n    with self.login(user1):\n        response = self.get('my-protected-view')\n```\n\n## Ensuring low query counts\n\n### assertNumQueriesLessThan(number) - context\n\nDjango provides\n[assertNumQueries](https://docs.djangoproject.com/en/1.8/topics/testing/tools/#django.test.TransactionTestCase.assertNumQueries)\nwhich is great when your code generates a specific number of\nqueries. However, if due to the nature of your data this number can vary\nyou often don't attempt to ensure the code doesn't start producing a ton\nmore queries than you expect:\n\n```python\ndef test_something_out(self):\n\n    with self.assertNumQueriesLessThan(7):\n        self.get('some-view-with-6-queries')\n```\n\n### assertGoodView(url_name, *args, **kwargs)\n\nThis method does a few of things for you, it:\n\n- Retrieves the name URL\n- Ensures the view does not generate more than 50 queries\n- Ensures the response has status code 200\n- Returns the response\n\nOften a wide sweeping test like this is better than no test at all. You\ncan use it like this:\n\n```python\ndef test_better_than_nothing(self):\n    response = self.assertGoodView('my-url-name')\n```\n\n## Testing DRF views\n\nTo take advantage of the convenience of DRF's test client, you can create a subclass of `TestCase` and set the `client_class` property:\n\n```python\nfrom test_plus import TestCase\nfrom rest_framework.test import APIClient\n\n\nclass APITestCase(TestCase):\n    client_class = APIClient\n```\n\nFor convenience, `test_plus` ships with `APITestCase`, which does just that:\n\n```python\nfrom test_plus import APITestCase\n\n\nclass MyAPITestCase(APITestCase):\n\n    def test_post(self):\n        data = {'testing': {'prop': 'value'}}\n        self.post('view-json', data=data, extra={'format': 'json'})\n        self.response_200()\n```\n\nNote that using `APITestCase` requires Django >= 1.8 and having installed `django-rest-framework`.\n\n## Testing class-based \"generic\" views\n\nThe TestCase methods `get()` and `post()` work for both function-based\nand class-based views. However, in doing so they invoke Django's\nURL resolution, middleware, template processing, and decorator systems.\nFor integration testing this is desirable, as you want to ensure your\nURLs resolve properly, view permissions are enforced, etc.\nFor unit testing this is costly because all these Django request/response\nsystems are invoked in addition to your method, and they typically do not\naffect the end result.\n\nClass-based views (derived from Django's `generic.models.View` class)\ncontain methods and mixins which makes granular unit testing (more) feasible.\nQuite often your usage of a generic view class comprises a simple override\nof an existing method. Invoking the entire view and the Django request/response\nstack is a waste of time... you really want to call the overridden\nmethod directly and test the result.\n\nCBVTestCase to the rescue!\n\nAs with TestCase above, simply have your tests inherit\nfrom test_plus.test.CBVTestCase rather than TestCase like so:\n\n```python\nfrom test_plus.test import CBVTestCase\n\nclass MyViewTests(CBVTestCase):\n```\n\n## Methods\n\n### get_instance(cls, initkwargs=None, request=None, *args, **kwargs)\n\nThis core method simplifies the instantiation of your class, giving you\na way to invoke class methods directly.\n\nReturns an instance of `cls`, initialized with `initkwargs`.\nSets `request`, `args`, and `kwargs` attributes on the class instance.\n`args` and `kwargs` are the same values you would pass to `reverse()`.\n\nSample usage:\n\n```python\nfrom django.views import generic\nfrom test_plus.test import CBVTestCase\n\nclass MyClass(generic.DetailView)\n\n    def get_context_data(self, **kwargs):\n        kwargs['answer'] = 42\n        return kwargs\n\nclass MyTests(CBVTestCase):\n\n    def test_context_data(self):\n        my_view = self.get_instance(MyClass, {'object': some_object})\n        context = my_view.get_context_data()\n        self.assertEqual(context['answer'], 42)\n```\n\n### get(cls, initkwargs=None, *args, **kwargs)\n\nInvokes `cls.get()` and returns the response, rendering template if possible.\nBuilds on the `CBVTestCase.get_instance()` foundation.\n\nAll test_plus.test.TestCase methods are valid, so the following works:\n\n```python\nresponse = self.get(MyClass)\nself.assertContext('my_key', expected_value)\n```\n\nAll test_plus TestCase side-effects are honored and all test_plus\nTestCase assertion methods work with `CBVTestCase.get()`.\n\n**NOTE:** This method bypasses Django's middleware, and therefore context\nvariables created by middleware are not available. If this affects your\ntemplate/context testing you should use TestCase instead of CBVTestCase.\n\n### post(cls, data=None, initkwargs=None, *args, **kwargs)\n\nInvokes `cls.post()` and returns the response, rendering template if possible.\nBuilds on the `CBVTestCase.get_instance()` foundation.\n\nExample:\n\n```python\nresponse = self.post(MyClass, data={'search_term': 'revsys'})\nself.response_200(response)\nself.assertContext('company_name', 'RevSys')\n```\n\nAll test_plus TestCase side-effects are honored and all test_plus\nTestCase assertion methods work with `CBVTestCase.post()`.\n\n**NOTE:** This method bypasses Django's middleware, and therefore context\nvariables created by middleware are not available. If this affects your\ntemplate/context testing you should use TestCase instead of CBVTestCase.\n\n### get_check_200(cls, initkwargs=None, *args, **kwargs)\n\nWorks just like `TestCase.get_check_200()`.\nCaller must provide a view class instead of a URL name or path parameter.\n\nAll test_plus TestCase side-effects are honored and all test_plus\nTestCase assertion methods work with `CBVTestCase.post()`.\n\n### assertGoodView(cls, initkwargs=None, *args, **kwargs)\n\nWorks just like `TestCase.assertGoodView()`.\nCaller must provide a view class instead of a URL name or path parameter.\n\nAll test_plus TestCase side-effects are honored and all test_plus\nTestCase assertion methods work with `CBVTestCase.post()`.\n\n## Development\n\nTo work on django-test-plus itself, you need to clone this repository and run the following commands:\n\n```shell\n$ pip install -r requirements.txt\n$ pip install -e .\n```\n\n**NOTE**: You will also need to ensure that the `test_project` directory, located\nat the root of this repo, is in your virtualenv's path.\n\n## Keep in touch!\n\nIf you have a question about this project, please open a GitHub issue. If you love us and want to keep track of our goings-on, here's where you can find us online:\n\n<a href=\"https://revsys.com?utm_medium=github&utm_source=django-test-plus\"><img src=\"https://pbs.twimg.com/profile_images/915928618840285185/sUdRGIn1_400x400.jpg\" height=\"50\" /></a>\n<a href=\"https://twitter.com/revsys\"><img src=\"https://cdn1.iconfinder.com/data/icons/new_twitter_icon/256/bird_twitter_new_simple.png\" height=\"43\" /></a>\n<a href=\"https://www.facebook.com/revsysllc/\"><img src=\"https://cdn3.iconfinder.com/data/icons/picons-social/57/06-facebook-512.png\" height=\"50\" /></a>\n<a href=\"https://github.com/revsys/\"><img src=\"https://assets-cdn.github.com/images/modules/logos_page/GitHub-Mark.png\" height=\"53\" /></a>\n<a href=\"https://gitlab.com/revsys\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/GitLab_Logo.svg/2000px-GitLab_Logo.svg.png\" height=\"44\" /></a>\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/revsys/django-test-plus/",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-test-plus",
    "package_url": "https://pypi.org/project/django-test-plus/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-test-plus/",
    "project_urls": {
      "Homepage": "https://github.com/revsys/django-test-plus/"
    },
    "release_url": "https://pypi.org/project/django-test-plus/1.3.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "django-test-plus provides useful additions to Django's default TestCase",
    "version": "1.3.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15388433,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "589e01aa8e37474d4586a436c2cf629456fe126fd0703c81db3d6ee04dcf6b57",
        "md5": "05a97ba721ff1487bb4541defb681a68",
        "sha256": "be3c34a8a757bbad0d1bf3cf49ef6ab381cb2138a9d02d7e2ce9b18f4e3a30a1"
      },
      "downloads": -1,
      "filename": "django_test_plus-1.3.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "05a97ba721ff1487bb4541defb681a68",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 15092,
      "upload_time": "2019-07-31T17:14:10",
      "upload_time_iso_8601": "2019-07-31T17:14:10.659200Z",
      "url": "https://files.pythonhosted.org/packages/58/9e/01aa8e37474d4586a436c2cf629456fe126fd0703c81db3d6ee04dcf6b57/django_test_plus-1.3.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "461e04089e2ba64fc9ea42fde4f3404c957e64c9368b46395af8ce89e2c811da",
        "md5": "f7dbb34931a2fd3a1c3fb911ee64c936",
        "sha256": "96ada2cdbc4206cfe92015623729381f1eaa4267e03add24e4e9bd0dcffcdef0"
      },
      "downloads": -1,
      "filename": "django-test-plus-1.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "f7dbb34931a2fd3a1c3fb911ee64c936",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 18784,
      "upload_time": "2019-07-31T17:14:12",
      "upload_time_iso_8601": "2019-07-31T17:14:12.352500Z",
      "url": "https://files.pythonhosted.org/packages/46/1e/04089e2ba64fc9ea42fde4f3404c957e64c9368b46395af8ce89e2c811da/django-test-plus-1.3.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}