{
  "info": {
    "author": "Frank Wiles",
    "author_email": "frank@revsys.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 1.10",
      "Framework :: Django :: 1.11",
      "Framework :: Django :: 1.8",
      "Framework :: Django :: 1.9",
      "Framework :: Django :: 2.0",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6"
    ],
    "description": "django-test-plus\n================\n\nUseful additions to Django's default TestCase from `Revolution\nSystems <http://www.revsys.com/>`__\n\n|travis ci status image| |Coverage Status|\n\n\nRationale\n---------\n\nLet's face it, writing tests isn't always fun. Part of the reason for\nthat is all of the boilerplate you end up writing. django-test-plus is\nan attempt to cut down on some of that when writing Django tests. We\nguarantee it will increase the time before you get carpal tunnel by at\nleast 3 weeks!\n\nSupport\n-------\n\nSupports: Python 2 and Python 3\n\nSupports Django Versions: 1.8, 1.9, 1.10, 1.11, 2.0\n\nDocumentation\n--------------\n\nFull documentation is available at http://django-test-plus.readthedocs.org\n\nInstallation\n------------\n\n::\n\n    $ pip install django-test-plus\n\nUsage\n-----\n\nUsing django-test-plus is pretty easy, simply have your tests inherit\nfrom test\\_plus.test.TestCase rather than the normal\ndjango.test.TestCase like so::\n\n    from test_plus.test import TestCase\n\n    class MyViewTests(TestCase):\n        ...\n\nThis is sufficient to get things rolling, but you are encouraged to\ncreate *your own* sub-class on a per project basis. This will allow you to add your own project specific helper methods.\n\nFor example, if you have a django project named 'myproject', you might\ncreate the following in ``myproject/test.py``::\n\n    from test_plus.test import TestCase as PlusTestCase\n\n    class TestCase(PlusTestCase):\n        pass\n\nAnd then in your tests use::\n\n    from myproject.test import TestCase\n\n    class MyViewTests(TestCase):\n        ...\n\nNote that you can also option to import it like this if you want, which is\nmore similar to the regular importing of Django's TestCase::\n\n    from test_plus import TestCase\n\nMethods\n-------\n\nreverse(url\\_name, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen testing views you often find yourself needing to reverse the URL's name. With django-test-plus there is no need for the ``from django.core.urlresolvers import reverse`` boilerplate. Instead just use::\n\n    def test_something(self):\n        url = self.reverse('my-url-name')\n        slug_url = self.reverse('name-takes-a-slug', slug='my-slug')\n        pk_url = self.reverse('name-takes-a-pk', pk=12)\n\nAs you can see our reverse also passes along any args or kwargs you need\nto pass in.\n\nget(url\\_name, follow=True, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAnother thing you do often is HTTP get urls. Our ``get()`` method\nassumes you are passing in a named URL with any args or kwargs necessary\nto reverse the url\\_name.\nIf needed, place kwargs for ``TestClient.get()`` in an 'extra' dictionary.::\n\n    def test_get_named_url(self):\n        response = self.get('my-url-name')\n        # Get XML data via AJAX request\n        xml_response = self.get(\n            'my-url-name',\n            extra={'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest'})\n\nWhen using this get method two other things happen for you, we store the\nlast response in ``self.last\\_response`` and the response's Context in ``self.context``.\nSo instead of::\n\n    def test_default_django(self):\n        response = self.client.get(reverse('my-url-name'))\n        self.assertTrue('foo' in response.context)\n        self.assertEqual(response.context['foo'], 12)\n\nYou can instead write::\n\n    def test_testplus_get(self):\n        self.get('my-url-name')\n        self.assertInContext('foo')\n        self.assertEqual(self.context['foo'], 12)\n\nIt's also smart about already reversed URLs so you can be lazy and do::\n\n    def test_testplus_get(self):\n        url = self.reverse('my-url-name')\n        self.get(url)\n        self.response_200()\n\nIf you need to pass query string parameters to your url name, you can do so like this. Assuming the name 'search' maps to '/search/' then::\n\n    def test_testplus_get_query(self):\n        self.get('search', data={'query': 'testing'})\n\nWould GET /search/?query=testing\n\npost(url\\_name, data, follow=True, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOur ``post()`` method takes a named URL, the dictionary of data you wish\nto post and any args or kwargs necessary to reverse the url\\_name.\nIf needed, place kwargs for ``TestClient.post()`` in an 'extra' dictionary.::\n\n    def test_post_named_url(self):\n        response = self.post('my-url-name', data={'coolness-factor': 11.0},\n                             extra={'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest'})\n\n*NOTE* Along with the frequently used get and post, we support all of the HTTP verbs such as put, patch, head, trace, options, and delete in the same fashion.\n\nget_context(key)\n~~~~~~~~~~~~~~~~\n\nOften you need to get things out of the template context, so let's make that\neasy::\n\n    def test_context_data(self):\n        self.get('my-view-with-some-context')\n        slug = self.get_context('slug')\n\nassertInContext(key)\n~~~~~~~~~~~~~~~~~~~~\n\nYou can ensure a specific key exists in the last response's context by\nusing::\n\n    def test_in_context(self):\n        self.get('my-view-with-some-context')\n        self.assertInContext('some-key')\n\nassertContext(key, value)\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe can get context values and ensure they exist, but so let's also test\nequality while we're at it. This asserts that key == value::\n\n    def test_in_context(self):\n        self.get('my-view-with-some-context')\n        self.assertContext('some-key', 'expected value')\n\nresponse\\_XXX(response) - status code checking\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAnother test you often need to do is check that a response has a certain\nHTTP status code. With Django's default TestCase you would write::\n\n    from django.core.urlresolvers import reverse\n\n    def test_status(self):\n        response = self.client.get(reverse('my-url-name'))\n        self.assertEqual(response.status_code, 200)\n\nWith django-test-plus you can shorten that to be::\n\n    def test_better_status(self):\n        response = self.get('my-url-name')\n        self.response_200(response)\n\ndjango-test-plus provides the following response method checks for you::\n\n    - response_200()\n    - response_201()\n    - response_302()\n    - response_403()\n    - response_404()\n    - response_405()\n\nAll of which take an option Django test client response as their only argument.\nIf it's available, the response_XXX methods will use the last response. So you\ncan do::\n\n    def test_status(self):\n        self.get('my-url-name')\n        self.response_200()\n\nWhich is a bit shorter.\n\nget\\_check\\_200(url\\_name, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nGETing and checking views return status 200 is so common a test this\nmethod makes it even easier::\n\n    def test_even_better_status(self):\n        response = self.get_check_200('my-url-name')\n\nmake\\_user(username='testuser', password='password', perms=None)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen testing out views you often need to create various users to ensure\nall of your logic is safe and sound. To make this process easier, this\nmethod will create a user for you::\n\n    def test_user_stuff(self)\n        user1 = self.make_user('u1')\n        user2 = self.make_user('u2')\n\nIf creating a User in your project is more complicated, say for example\nyou removed the ``username`` field from the default Django Auth model\nyou can provide a `Factory\nBoy <https://factoryboy.readthedocs.org/en/latest/>`__ factory to create\nit or simply override this method on your own sub-class.\n\nTo use a Factory Boy factory simply create your class like this::\n\n    from test_plus.test import TestCase\n    from .factories import UserFactory\n\n\n    class MySpecialTest(TestCase):\n        user_factory = UserFactory\n\n        def test_special_creation(self):\n            user1 = self.make_user('u1')\n\n**NOTE:** Users created by this method will have their password\nset to the string 'password' by default, in order to ease testing.\nIf you need a specific password simply override the ``password`` parameter.\n\nYou can also pass in user permissions by passing in a string of\n'``<app_name>.<perm name>``' or '``<app_name>.*``'.  For example::\n\n    user2 = self.make_user(perms=['myapp.create_widget', 'otherapp.*'])\n\nprint_form_errors(response_or_form=None)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen debugging a failing test for a view with a form, this method helps you\nquickly look at any form errors.\n\nExample usage::\n\n    class MyFormTest(TestCase):\n\n        self.post('my-url-name', data={})\n        self.print_form_errors()\n\n        # or\n\n        resp = self.post('my-url-name', data={})\n        self.print_form_errors(resp)\n\n        # or\n\n        form = MyForm(data={})\n        self.print_form_errors(form)\n\nAuthentication Helpers\n----------------------\n\nassertLoginRequired(url\\_name, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt's pretty easy to add a new view to a project and forget to restrict\nit to be login required, this method helps make it easy to test that a\ngiven named URL requires auth::\n\n    def test_auth(self):\n        self.assertLoginRequired('my-restricted-url')\n        self.assertLoginRequired('my-restricted-object', pk=12)\n        self.assertLoginRequired('my-restricted-object', slug='something')\n\nlogin context\n~~~~~~~~~~~~~\n\nAlong with ensuing a view requires login and creating users, the next\nthing you end up doing is logging in as various users to test our your\nrestriction logic. This can be made easier with the following context::\n\n    def test_restrictions(self):\n        user1 = self.make_user('u1')\n        user2 = self.make_user('u2')\n\n        self.assertLoginRequired('my-protected-view')\n\n        with self.login(username=user1.username, password='password'):\n            response = self.get('my-protected-view')\n            # Test user1 sees what they should be seeing\n\n        with self.login(username=user2.username, password='password'):\n            response = self.get('my-protected-view')\n            # Test user2 see what they should be seeing\n\nSince we're likely creating our users using ``make_user()`` from above,\nthe login context assumes the password is 'password' unless specified\notherwise. Therefore you you can do::\n\n    def test_restrictions(self):\n        user1 = self.make_user('u1')\n\n        with self.login(username=user1.username):\n            response = self.get('my-protected-view')\n\nWe can also derive the username if we're using ``make_user()`` so we can\nshorten that up even further like this::\n\n    def test_restrictions(self):\n        user1 = self.make_user('u1')\n\n        with self.login(user1):\n            response = self.get('my-protected-view')\n\nEnsuring low query counts\n-------------------------\n\nassertNumQueriesLessThan(number) - context\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDjango provides\n`assertNumQueries <https://docs.djangoproject.com/en/1.8/topics/testing/tools/#django.test.TransactionTestCase.assertNumQueries>`__\nwhich is great when your code generates generates a specific number of\nqueries. However, if due to the nature of your data this number can vary\nyou often don't attempt to ensure the code doesn't start producing a ton\nmore queries than you expect::\n\n    def test_something_out(self):\n\n        with self.assertNumQueriesLessThan(7):\n            self.get('some-view-with-6-queries')\n\n\nassertGoodView(url\\_name, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis method does a few of things for you, it:\n\n    - Retrieves the name URL\n    - Ensures the view does not generate more than 50 queries\n    - Ensures the response has status code 200\n    - Returns the response\n\nOften a wide sweeping test like this is better than no test at all. You\ncan use it like this::\n\n    def test_better_than_nothing(self):\n        response = self.assertGoodView('my-url-name')\n\nTesting DRF views\n-----------------\n\nTo take advantage of the convenience of DRF's test client, you can create a subclass of ``TestCase`` and set the ``client_class`` property::\n\n    from test_plus import TestCase\n    from rest_framework.test import APIClient\n\n\n    class APITestCase(TestCase):\n        client_class = APIClient\n\nFor convenience, ``test_plus`` ships with ``APITestCase``, which does just that::\n\n    from test_plus import APITestCase\n\n\n    class MyAPITestCase(APITestCase):\n\n        def test_post(self):\n            data = {'testing': {'prop': 'value'}}\n            self.post('view-json', data=data, extra={'format': 'json'})\n            self.response_200()\n\nNote that using ``APITestCase`` requires Django >= 1.8 and having installed ``django-rest-framework``.\n\nTesting class-based \"generic\" views\n------------------------------------\n\nThe TestCase methods ``get()`` and ``post()`` work for both function-based\nand class-based views. However, in doing so they invoke Django's\nURL resolution, middleware, template processing, and decorator systems.\nFor integration testing this is desirable, as you want to ensure your\nURLs resolve properly, view permissions are enforced, etc.\nFor unit testing this is costly because all these Django request/response\nsystems are invoked in addition to your method, and they typically do not\naffect the end result.\n\nClass-based views (derived from Django's ``generic.models.View`` class)\ncontain methods and mixins which makes granular unit testing (more) feasible.\nQuite often your usage of a generic view class comprises a simple override\nof an existing method. Invoking the entire view and the Django request/response\nstack is a waste of time... you really want to call the overridden\nmethod directly and test the result.\n\nCBVTestCase to the rescue!\n\nAs with TestCase above, simply have your tests inherit\nfrom test\\_plus.test.CBVTestCase rather than TestCase like so::\n\n    from test_plus.test import CBVTestCase\n\n    class MyViewTests(CBVTestCase):\n\nMethods\n-------\n\nget_instance(cls, initkwargs=None, request=None, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis core method simplifies the instantiation of your class, giving you\na way to invoke class methods directly.\n\nReturns an instance of ``cls``, initialized with ``initkwargs``.\nSets ``request``, ``args``, and ``kwargs`` attributes on the class instance.\n``args`` and ``kwargs`` are the same values you would pass to ``reverse()``.\n\nSample usage::\n\n    from django.views import generic\n    from test_plus.test import CBVTestCase\n\n    class MyClass(generic.DetailView)\n\n        def get_context_data(self, **kwargs):\n            kwargs['answer'] = 42\n            return kwargs\n\n    class MyTests(CBVTestCase):\n\n        def test_context_data(self):\n            my_view = self.get_instance(MyClass, {'object': some_object})\n            context = my_view.get_context_data()\n            self.assertEqual(context['answer'], 42)\n\nget(cls, initkwargs=None, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInvokes ``cls.get()`` and returns the response, rendering template if possible.\nBuilds on the ``CBVTestCase.get_instance()`` foundation.\n\nAll test\\_plus.test.TestCase methods are valid, so the following works::\n\n    response = self.get(MyClass)\n    self.assertContext('my_key', expected_value)\n\nAll test\\_plus TestCase side-effects are honored and all test\\_plus\nTestCase assertion methods work with ``CBVTestCase.get()``.\n\n**NOTE:** This method bypasses Django's middleware, and therefore context\nvariables created by middleware are not available. If this affects your\ntemplate/context testing you should use TestCase instead of CBVTestCase.\n\npost(cls, data=None, initkwargs=None, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInvokes ``cls.post()`` and returns the response, rendering template if possible.\nBuilds on the ``CBVTestCase.get_instance()`` foundation.\n\nExample::\n\n    response = self.post(MyClass, data={'search_term': 'revsys'})\n    self.response_200(response)\n    self.assertContext('company_name', 'RevSys')\n\nAll test\\_plus TestCase side-effects are honored and all test\\_plus\nTestCase assertion methods work with ``CBVTestCase.post()``.\n\n**NOTE:** This method bypasses Django's middleware, and therefore context\nvariables created by middleware are not available. If this affects your\ntemplate/context testing you should use TestCase instead of CBVTestCase.\n\nget_check_200(cls, initkwargs=None, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWorks just like ``TestCase.get_check_200()``.\nCaller must provide a view class instead of a URL name or path parameter.\n\nAll test\\_plus TestCase side-effects are honored and all test\\_plus\nTestCase assertion methods work with ``CBVTestCase.post()``.\n\nassertGoodView(cls, initkwargs=None, \\*args, \\*\\*kwargs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWorks just like ``TestCase.assertGoodView()``.\nCaller must provide a view class instead of a URL name or path parameter.\n\nAll test\\_plus TestCase side-effects are honored and all test\\_plus\nTestCase assertion methods work with ``CBVTestCase.post()``.\n\n\n.. |travis ci status image| image:: https://secure.travis-ci.org/revsys/django-test-plus.png\n   :target: http://travis-ci.org/revsys/django-test-plus\n.. |Coverage Status| image:: https://coveralls.io/repos/revsys/django-test-plus/badge.svg?branch=master\n   :target: https://coveralls.io/r/revsys/django-test-plus?branch=master\n",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/revsys/django-test-plus/",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-test-plus",
    "package_url": "https://pypi.org/project/django-test-plus/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-test-plus/",
    "project_urls": {
      "Homepage": "https://github.com/revsys/django-test-plus/"
    },
    "release_url": "https://pypi.org/project/django-test-plus/1.0.20/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "django-test-plus provides useful additions to Django's default TestCase",
    "version": "1.0.20",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15388433,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1c3133295ed87a78108daf622017c9315028be809819569aacafc97c459997cd",
        "md5": "f74048d9c106aabd743fee98a9560f22",
        "sha256": "dd10b80613a7c994999d1240277245ef0792c104b42879219db6db2ffcb68a6a"
      },
      "downloads": -1,
      "filename": "django-test-plus-1.0.20.tar.gz",
      "has_sig": false,
      "md5_digest": "f74048d9c106aabd743fee98a9560f22",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 18417,
      "upload_time": "2017-10-31T13:08:45",
      "upload_time_iso_8601": "2017-10-31T13:08:45.875110Z",
      "url": "https://files.pythonhosted.org/packages/1c/31/33295ed87a78108daf622017c9315028be809819569aacafc97c459997cd/django-test-plus-1.0.20.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}