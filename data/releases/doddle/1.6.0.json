{
  "info": {
    "author": "Alex Cross",
    "author_email": "AlexJCross90@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "<img src=\"https://raw.githubusercontent.com/CatchemAl/Doddle/main/images/DoddleLogo.png\" width=\"420\">\n\n## Features\n\n[![example workflow](https://github.com/CatchemAl/Doddle/actions/workflows/python-app.yml/badge.svg)](https://github.com/CatchemAl/Doddle/actions)\n[![codecov](https://codecov.io/gh/CatchemAl/Doddle/branch/main/graph/badge.svg?token=3JM8LJ3IKS)](https://codecov.io/gh/CatchemAl/Doddle)\n[![PyPI - Wheel](https://img.shields.io/pypi/wheel/Doddle)](https://pypi.org/project/doddle/#files)\n[![PyPI](https://img.shields.io/pypi/v/doddle.svg)](https://pypi.org/project/doddle/)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/Doddle)\n[![Tutorial](https://img.shields.io/badge/doddle-tutorial-orange?logo=jupyter)](https://github.com/CatchemAl/Doddle/blob/main/tutorial/Getting%20Started.ipynb)\n\n### Command line Interface Features\nDoddle exposes four entry points via the command line: `run`, `solve`, `hide`, `benchmark`\n1)  **Run** the solver to see how the game is optimally played\n2) **Solve** a game in realtime using Doddle's solver\n3) Play a variation of the game where the solver attempts to **hide** the answer from you for as long as possible (inspired by [Absurdle](https://qntm.org/files/absurdle/absurdle.html))\n4) **Benchmark** Doddle against the entire dictionary to see how well it performs\n\nThe commands can be run with additional parameters:\n- Play using words of length 4-9 (inclusive) by adding the optional `--size` parameter (default is 5).\n- Choose your solver using the `--solver=ENTROPY` or `--solver=MINIMAX` parameter (default is minimax)\n- Run deep searches using the `--depth` parameter (default is 1)\n- Solve multiple games of Wordle at the same time. This mode is inspired by popular spin-offs such as [Dordle](https://zaratustra.itch.io/dordle), [Quordle](https://www.quordle.com/#/) and [Octordle](https://octordle.com/). Playing multiple games with Doddle is easy: just add more answers to the run command `doddle run --answer=ULTRA,QUICK,SOLVE` and Doddle will solve them all at the same time.\n\n### A Clean API\nDoddle exposes a tonne of features, packed behind a simple API. Wanna play two six-letter word games simultaneously with your choice of an opening guess? Three lines ✨.\n```python\nfrom doddle import Doddle\ndoddle = Doddle(size=6)\nscoreboard = doddle(answer=[\"THOUGH\", \"FUSION\"], guess=\"PRAYER\")\n```\nWant custom emojis to show how the solver performed?\n```python\nemojis = scoreboard.emoji()\nprint(emoji)\n```\n\n```\nDoddle 5/7\n4️⃣5️⃣\n\n⬜⬜⬜⬜⬜⬜ ⬜⬜⬜⬜⬜⬜\n⬜⬜⬜🟨⬜⬜ ⬜🟨🟩⬜⬜⬜\n⬜🟨🟨🟨⬜⬜ ⬜🟩⬜🟨⬜⬜\n🟩🟩🟩🟩🟩🟩 ⬜⬜🟨🟨⬜⬜\n⬛⬛⬛⬛⬛⬛ 🟩🟩🟩🟩🟩🟩\n```\n\n### Beautiful Visualisations 🌴🌴🌴\nDoddle is not a black box. Create beautiful visualisations with just two lines of code that render the entire decision tree of games. Follow the flow diagram to see how Doddle plays a game. You can render the tree for any choice of opening guess, combination of guesses, depth or solver type.\n\n```python\nbenchmark = doddle.benchmark(guess=\"CRATE\")\nbenchmark.digraph()\n```\n\n<img src=\"https://raw.githubusercontent.com/CatchemAl/Doddle/main/images/sample.svg\" width=\"900\">\n\nNote that the full tree has been truncated here. Click [here](https://github.com/CatchemAL/LargeFiles/raw/main/Doddle/doddle_full_tree.pdf) to download the full PDF.\n\n\n\n### The Theoretical Minimum 💯\nDoddle's solver can also be used to generate the optimal decison tree via a recursive search. [Alex Selby](http://sonorouschocolate.com/notes/index.php?title=The_best_strategies_for_Wordle) was the first to prove that `SALET` yields the optimal decision tree with a total of 7,920 guesses to solve the 2,315 problems from the original Wordle dataset. To generate such a tree [using Doddle](https://github.com/CatchemAL/LargeFiles/raw/main/Doddle/Doddle-SALET.pdf):\n\n```\nbenchmark = doddle.tree_search('SALET')\nbenchmark\n\n1 |                                                         (0)\n2 | ***                                                    (78)\n3 | **************************************************  (1,225)\n4 | ****************************************              (971)\n5 | **                                                     (41)\n\nGuess:    SALET\nGames:    2,315\nGuesses:  7,920\nMean:     3.421\nStd:      0.589\n```\n\n## Install\nInstall Doddle with \n\n`$ pip install doddle`\n\n`$ pip install doddle[decision]`       <--- use this if you want awesome decision trees\n\nDoddle strives to keep dependencies to a minimum. For that reason, the decision tree functionality is included as an optional install and adds an additional dependency on [graphviz](https://pypi.org/project/graphviz/). Please note that the GraphViz python package assumes you have the (open-source) GraphViz executable correctly installed on your machine. Please see the graphviz [documentation](https://graphviz.readthedocs.io/en/stable/#installation) for more details.\n\n## Commands\nDoddle includes three entry points as part of the installation process.\n\n### Run\n\n```ruby\ndoddle run --answer=SALTY\ndoddle run --answer=SPEED --guess=SOLVE\ndoddle run --answer=FABULOUS --guess=SOLUTION,STRENGTH --solver=ENTROPY\ndoddle run --answer=DEEP --guess=MIND --solver=ENTROPY --depth=2\ndoddle run --answer=BRAVE,SHAME,TOWER,STEEP\n```\n\nRun a simulation with an answer of your choosing to see how Doddle solves the problem. You can optionally provide your own starting `guess` to see how the game plays out. With every guess, Doddle acquires more information and prunes the list of possible solutions. The output (far right column) shows you how many possible solutions still exist at each step of the solve.\n\nDoddle provides multiple ways to solve the game. You can choose between a **minimax** `solver` (the default), or an **entropy** reduction approach. An entropy based approach optimises for best average play; a minimax approach tries to avoid worst-case scenarios and never goes above 5 moves.\n\nDoddle supports deep searches for all of its solvers 🧠🧠🧠. These are slower, more exhaustive searches for those that want to go deeper. By default, Doddle plays the move that will yield the 'best' outcome on its next turn. In the case of minimax, that means playing the move that will result in the fewest number of possible words to search in the worst-case scenario (it chooses a word that **mini**mises the outcome that provides **max**imum uncertainty). In the case of `--solver=ENTROPY`, it plays the move that results in the greatest expected reduction in [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_(information_theory)). With deep searches, it thinks `n` steps ahead. So for `--depth=2`, the minimax solver plays the word that minimses the number of possible solutions in the worst case scenario on the turn after next taking into consideration ***all*** sensible first moves. The performance is still decent - a few seconds per game - but it is noticably slower as the search space explodes exponentially with depth.\n\n<img src=\"https://raw.githubusercontent.com/CatchemAl/Doddle/main/images/DoddleRun.png\" width=\"400\">\n\n\n### Solve\n\n```ruby\ndoddle solve\ndoddle solve --size=7\ndoddle solve --guess=RAISE\ndoddle solve --guess=MIND --solver=ENTROPY\ndoddle solve --guess=MIND --solver=MINIMAX --depth=2\n```\n\nWork smarter not harder. Use Doddle's solver to solve Wordle as fast as possible. If you're playing Wordle and need some... ahem... *divine inspiration*, fire up Doddle's solver. Doddle will give you the optimal word to use. Type the response back into Wordle to generate the next guess. Doddle represents answers as ternary numbers! Doddle uses `2` for exact matches, `1` for partial matches and `0` for unmatched letters (e.g. `10202`).\n\n```\n>>> doddle solve --guess=TORCH\nEnter score for TORCH:\n>>> 10000\n\nThe best guess is SNAIL\nEnter score for SNAIL:\n>>> 20101\n\nThe best guess is SALTY\nEnter score for SALTY:\n>>> 22222\n\nGreat success! ✨ 🔮 ✨\n```\n\nHalf way through a game and just want to know the next best move? Doddle's got you covered. With `solve`, you're not forced to play the move Doddle suggests. Doddle accepts two syntaxes when entering a score: 1) just a score (as above e.g. `20101`); or 2) a `WORD=SCORE` pair (`SNAKE=20100`). If you're half way through and need the best move, fill in what you've done so far using the second input method and let Doddle take over from there.\n\n\n```\nThe best guess is SNAIL\nEnter score for SNAIL:\n>>> SNAKE=20100\n\nThe best guess is SALTY\n...\n```\n\n### Hide\n```ruby\ndoddle hide --guess=SALTY\n```\nHide is a spin on the conventional Wordle game. Here, Doddle uses its solver to hide the final answer for as long as possible. Doddle doesn't choose an answer before the game starts - instead it always presents you with the score that results in maximum ambiguity. You'll get there in the end, but the game might take a while. 😈\n\n<img src=\"https://raw.githubusercontent.com/CatchemAl/Doddle/main/images/DoddleHide.png\" width=\"350\">\n\nSimilar to the original Wordle game, a keyboard is rendered to display what characters have been guessed so far.\n\n### Benchmark\n```ruby\ndoddle benchmark\ndoddle benchmark --guess=CRATE\ndoddle benchmark --guess=CRATE --solver=ENTROPY\ndoddle benchmark --guess=SOLUTION,STRENGTH --solver=ENTROPY\ndoddle benchmark --guess=MIND --solver=MINIMAX --depth=2\ndoddle benchmark --simul=4\n```\nDoddle comes with inbuilt benchmarking capabilities. This allows you to run a configuration of Doddle (e.g. starting guess, solver type, depth etc.) against all words in the dictionary. To benchmark an octordle stlye game (eight simultaneous games), simply add `--simul=8`.\n\nDoddle is built with performance in mind: a simple 5-letter game under minimax will complete in about 27 seconds on my machine (specs + timings may vary). See how your favourite starting word performs against every word in the dictionary:\n\n```\n>>> doddle benchmark --guess=CRATE --solver=ENTROPY\n\n1 |                                                         (1)\n2 | ***                                                    (83)\n3 | **************************************************  (1,204)\n4 | ****************************************              (968)\n5 | **                                                     (58)\n\nGuess:    CRATE\nGames:    2,314\nGuesses:  7,941\nMean:     3.432\nStd:      0.608\n```\n\n## Calling Doddle from Python\n\nIn addition to running Doddle via the command line, Doddle exposes an intuitive API to be used in code. Simply create a `Doddle` object to get started.\n```python\nfrom doddle import Doddle\ndoddle = Doddle()\nscoreboard = doddle(answer=\"FLAME\")\nscoreboard\n```\nIPython compatible tools such as Jupyter Lab inherently understand Doddle objects and will render them in rich HTML. Simply returning the scoreboard above will render the below:\n<table>\n<thead>\n  <tr>\n\t<th></th>\n\t<th>Soln</th>\n\t<th>Guess</th>\n\t<th>Score</th>\n\t<th>Poss</th>\n  </tr>\n</thead>\n<tbody>\n\t<tr>\n\t\t<td><b>1</b></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>RAISE</tt></td>\n\t\t<td>⬜🟨⬜⬜🟩</td>\n\t\t<td>41</td>\n\t</tr>\n\t<tr>\n\t\t<td><b>2</b></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>BLOCK</tt></td>\n\t\t<td>⬜🟩⬜⬜⬜</td>\n\t\t<td>7</td>\n\t</tr>\n\t<tr>\n\t\t<td><b>3</b></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>ADAPT</tt></td>\n\t\t<td>⬜⬜🟩⬜⬜</td>\n\t\t<td>2</td>\n\t</tr>\n\t<tr>\n\t\t<td><b>4</b></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td>🟩🟩🟩🟩🟩</td>\n\t\t<td></td>\n\t</tr>    \n</tbody>\n</table>\n\nIf you plan to play multiple games using Doddle, it is recommended that you create the Doddle object without lazy evaluation of its internal dictionary.\n```python\nfrom doddle import Doddle\ndoddle = Doddle(lazy_eval=False)\n```\nThis will take a few seconds to initialise, but subsequent solves will be materially faster. To play a 'quordle' style game, with two guesses of your choice, simply call:\n```python\nscoreboard = doddle(answer=[\"FLAME\",\"SNAKE\",\"BLAST\",\"CRAVE\"], guess=[\"SHALE\",\"IRATE\"])\nemojis = scoreboard.emoji()\nprint(emojis)\n```\n```\nDoddle 7/9\n6️⃣5️⃣\n3️⃣7️⃣\n\n⬜⬜🟩🟨🟩 🟩⬜🟩⬜🟩\n⬜⬜🟩⬜🟩 ⬜⬜🟩⬜🟩\n⬜🟩🟩⬜⬜ ⬜⬜🟩🟨⬜\n⬜⬜⬜⬜🟩 ⬜⬜⬜⬜🟩\n⬜⬜🟩⬜🟩 🟩🟩🟩🟩🟩\n🟩🟩🟩🟩🟩 ⬛⬛⬛⬛⬛\n\n🟨⬜🟩🟨⬜ ⬜⬜🟩⬜🟩\n⬜⬜🟩🟨⬜ ⬜🟩🟩⬜🟩\n🟩🟩🟩🟩🟩 ⬜⬜🟩⬜⬜\n⬛⬛⬛⬛⬛ ⬜⬜⬜⬜🟩\n⬛⬛⬛⬛⬛ ⬜⬜🟩⬜🟩\n⬛⬛⬛⬛⬛ ⬜⬜🟩⬜🟩\n⬛⬛⬛⬛⬛ 🟩🟩🟩🟩🟩\n```\n\nFor a simultaneous game such as the one above, the `scoreboard` object will display the rows associated with each guess in blocks. Try it in Jupyter lab to see the output!\n<table>\n<thead>\n  <tr>\n\t<th></th>\n\t<th>Soln</th>\n\t<th>Guess</th>\n\t<th>Score</th>\n\t<th>Poss</th>\n  </tr>\n</thead>\n<tbody>\n\t<tr>\n\t\t<th>1</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>SHALE</tt></td>\n\t\t<td>⬜⬜🟩🟨🟩</td>\n\t\t<td>15</td>\n\t</tr>\n\t<tr>\n\t\t<th>1</th>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td><tt>SHALE</tt></td>\n\t\t<td>🟩⬜🟩⬜🟩</td>\n\t\t<td>13</td>\n\t</tr>\n\t<tr>\n\t\t<th>1</th>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td><tt>SHALE</tt></td>\n\t\t<td>🟨⬜🟩🟨⬜</td>\n\t\t<td>5</td>\n\t</tr>            \n\t<tr>\n\t\t<th>1</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>SHALE</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>34</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>2</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>IRATE</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>10</td>\n\t</tr>\n\t<tr>\n\t\t<th>2</th>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td><tt>IRATE</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>4</td>\n\t</tr>\n\t<tr>\n\t\t<th>2</th>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td><tt>IRATE</tt></td>\n\t\t<td>⬜⬜🟩🟨⬜</td>\n\t\t<td>1</td>\n\t</tr>            \n\t<tr>\n\t\t<th>2</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>IRATE</tt></td>\n\t\t<td>⬜🟩🟩⬜🟩</td>\n\t\t<td>14</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>3</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td>⬜🟩🟩⬜⬜</td>\n\t\t<td>6</td>\n\t</tr>\n\t<tr>\n\t\t<th>3</th>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td>⬜⬜🟩🟨⬜</td>\n\t\t<td>4</td>\n\t</tr>\n\t<tr>\n\t\t<th>3</th>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td>🟩🟩🟩🟩🟩</td>\n\t\t<td></td>\n\t</tr>            \n\t<tr>\n\t\t<th>3</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>BLAST</tt></td>\n\t\t<td>⬜⬜🟩⬜⬜</td>\n\t\t<td>11</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>4</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>PUDGE</tt></td>\n\t\t<td>⬜⬜⬜⬜🟩</td>\n\t\t<td>2</td>\n\t</tr>\n\t<tr>\n\t\t<th>4</th>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td><tt>PUDGE</tt></td>\n\t\t<td>⬜⬜⬜⬜🟩</td>\n\t\t<td>1</td>\n\t</tr>            \n\t<tr>\n\t\t<th>4</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>PUDGE</tt></td>\n\t\t<td>⬜⬜⬜⬜🟩</td>\n\t\t<td>4</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>5</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>1</td>\n\t</tr>\n\t<tr>\n\t\t<th>5</th>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td>🟩🟩🟩🟩🟩</td>\n\t\t<td></td>\n\t</tr>            \n\t<tr>\n\t\t<th>5</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>SNAKE</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>3</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>6</th>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td>🟩🟩🟩🟩🟩</td>\n\t\t<td></td>\n\t</tr>            \n\t<tr>\n\t\t<th>6</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>FLAME</tt></td>\n\t\t<td>⬜⬜🟩⬜🟩</td>\n\t\t<td>2</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"5\" class=\"divider\"><hr /></td>\n\t</tr>\n\t<tr>\n\t\t<th>7</th>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td><tt>CRAVE</tt></td>\n\t\t<td>🟩🟩🟩🟩🟩</td>\n\t\t<td></td>\n\t</tr>\n</tbody>\n</table>\n\nAdditionally, it is easy to access the scoreboard for any individual game. Just use the `many()` method to decompose a simultaneous scoreboard into a list of available boards.\n```python\nscoreboards = scoreboard.many()\nscoreboards[2]\n```\n\n#### Benchmarking\n\nAll the benchmarking functionality is exposed via the libary. \n\n```python\ndoddle = Doddle(solver_type=\"entropy\")\nbenchmark = doddle.benchmark(\"CRATE\")\nbenchmark\n```\n\n#### Wordle Bot\n\nDoddle also integrates with [Wordle Bot](https://freshman.dev/wordle/#/leaderboard) so results can be written to the Wordle Bot format for direct upload. Wordle Bot works with a comma separated text file of solutions. To output in the required format:\n`benchmark.to_csv(filepath)`\n\nMore importantly, Doddle can create a benchmark from any Wordle Bot text file! Call `Benchmark.read_csv(filepath)` to load it in and start building decision trees from your own solves. Finally, you can generate an optimal decision tree via a recusive search. To do so:\n`benchmark = doddle.tree_search(starting_word)`\n\n## Algorithm\nDoddle offers two choices of algorithms for solving Wordle: Minimax and Entropy.\n\n### Minimax\nBy default, Doddle uses a [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm to solve the game. The easiest way to explain the algorithm is through example. \n\nSuppose you are half way through a game and have narrowed the solution down to one of four possibilties: `SKILL`, `SPILL`, `SWILL`, `STILL`.\n\nClearly, if we work our way through these words sequentially, the worst case scenario will be a further four guesses. To make things precise, let's create a histogram of all the scores that Wordle could return for each guess. We will consider the case where we naïvely choose the word `SKILL`.\n\n| Guess   | Score        | Partition Size | Possible Words               |\n|---------|--------------|----------------|------------------------------|\n| `SKILL` | 🟩🟨🟩🟩🟩 |             3 | { `SPILL`, `SWILL`, `STILL` } |\n| `SKILL` | 🟩🟩🟩🟩🟩 |             1 | { `SKILL` }                   |\n\nThe histogram is a great way to see how any guess **partitions** the remaining words. In the case above, there are two partitions with the worst case scenario being three (because three is the size of the largest partition).\n\nMinimax works by considering all possible words in the dictionary and choosing the word that minimises the size of its largest partition. So, in searching through all possible words, minimax would stumble upon a word like 💥 `KAPOW` 💥.\n\n| Guess   | Score        | Partition Size | Possible Words      |\n|---------|--------------|----------------|---------------------|\n| `KAPOW` | ⬜⬜⬜⬜⬜ |             1 | { `STILL` }         |\n| `KAPOW` | 🟨⬜⬜⬜⬜ |             1 | { `SKILL` }         |\n| `KAPOW` | ⬜⬜🟨⬜⬜ |             1 | { `SPILL` }         |\n| `KAPOW` | ⬜⬜⬜⬜🟨 |             1 | { `SWILL` }         |\n\nIn this case, each word is partitioned perfectly into its own bucket of length one and the game can be immediately solved on the next move. It's simple enough to compute this histogram for every possible word and the approach generalises all the way through the game.\n\n### Entropy\nAs an alternative to minimax, it is possible to play the game using an entropy based approach. Here, the solver always chooses the word that, on average, lowers the Shannon entropy of the game. To see how this works, let's assume we have reduced the game down to 20 possible words and decide to play the (excellent) move `THURL`. We shall construct a histogram as before - they're very useful.\n\n\n| Guess   | Score        | Partition Size | Probability | Possible Words                                 |\n|---------|--------------|----------------|-------------|------------------------------------------------|\n| `THURL` | ⬜⬜⬜⬜⬜ |             3 |        0.15 | { `SNAKE`, `SPACE`, `SPADE` }                   |\n| `THURL` | ⬜⬜⬜⬜🟨 |             1 |        0.05 | { `SCALE` }                                     |\n| `THURL` | ⬜⬜⬜🟩⬜ |             3 |        0.15 | { `SCARE`, `SNARE`, `SPARE` }                   |\n| `THURL` | ⬜🟩⬜⬜⬜ |             5 |        0.25 | { `SHADE`, `SHAKE`, `SHAME`, `SHAPE`, `SHAVE` } |\n| `THURL` | ⬜🟩⬜⬜🟨 |             1 |        0.05 | { `SHALE` }                                     |\n| `THURL` | ⬜🟩⬜🟩⬜ |             2 |        0.10 | { `SHARE`, `SHARK` }                            |\n| `THURL` | 🟨⬜⬜⬜⬜ |             3 |        0.15 | { `SKATE`, `STAGE`, `STAVE` }                   |\n| `THURL` | 🟨⬜⬜⬜🟨 |             2 |        0.10 | { `SLATE`, `STALE` }                            |\n\nUnder minimax, we would simply look at the largest bucket and assign a score of 5 to the word `THURL`. However, with an entropy based approach, we take into consideration how much each guess cuts down the entire problem *on average*. To do that, we need to look at all possible outcomes in the histogram and calculate the expected value of the number of bits of entropy that each guess provides. \n\nThe probability of any outcome is calculated simply as the **Partition Size** / **Total Number of Words**. The number of bits associated with any outcome is calculates as -log(probability, base=2) and, hence, the expected number of bits is simply the sum of the bits multiplied by their respective probabilities.\n\nIn the example above, the expected number of Shannon bits is 2.83 which tells us that the guess `THURL` roughly cuts the problem size in half 2.83 times. To be explicit, cutting the problem in half once would leave 10 words left to search on average. Cutting the problem in half twice would leave 5. And cutting the problem in half 2.83 times would leave 2.82 words on average which looks eminently sensible when we look at the partition sizes remaining.\n\nThe guess with the highest information content, as measured in Shannon bits, is picked. In this case, `THURL` is pretty optimal.\n\n## Tutorial\nWork through the tutorials [here](https://github.com/CatchemAl/Doddle/tree/main/tutorial) to see Doddle in action!\n1. Learn to use Doddle via the API\n2. Run benchmarks and generate trees\n3. Calculate the [optimal tree](https://github.com/CatchemAL/LargeFiles/raw/main/Doddle/Doddle-SALET.pdf) for a given starting word using a recursive search\n\n\nHappy Doddling!\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/CatchemAl/Doddle",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "doddle",
    "package_url": "https://pypi.org/project/doddle/",
    "platform": null,
    "project_url": "https://pypi.org/project/doddle/",
    "project_urls": {
      "Bug Tracker": "https://github.com/CatchemAl/Doddle/issues",
      "Homepage": "https://github.com/CatchemAl/Doddle"
    },
    "release_url": "https://pypi.org/project/doddle/1.6.0/",
    "requires_dist": [
      "numba",
      "numpy",
      "colorama",
      "tqdm",
      "graphviz ; extra == 'decision'",
      "black ; extra == 'dev'",
      "flake8 ; extra == 'dev'",
      "isort ; extra == 'dev'",
      "mypy ; extra == 'dev'",
      "types-colorama ; extra == 'dev'",
      "pytest-cov ; extra == 'dev'",
      "tox ; extra == 'dev'"
    ],
    "requires_python": ">=3.8",
    "summary": "doddle: Make Wordle A Doddle",
    "version": "1.6.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13422728,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7e322c2056c881f364408319c627f72be0faa682d13ef26b5fbf431b7a53852b",
        "md5": "836695bc3d290f5d5606b9b5c1f0dd66",
        "sha256": "46f7cc5ee7720f1a91a9525974de8bd6cb3cb58e954749a245e7fe6d5e5639d4"
      },
      "downloads": -1,
      "filename": "doddle-1.6.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "836695bc3d290f5d5606b9b5c1f0dd66",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 768703,
      "upload_time": "2022-04-06T01:01:12",
      "upload_time_iso_8601": "2022-04-06T01:01:12.296164Z",
      "url": "https://files.pythonhosted.org/packages/7e/32/2c2056c881f364408319c627f72be0faa682d13ef26b5fbf431b7a53852b/doddle-1.6.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "dc61ea37a4b4c90d9f9e602cfba761a2f67d85c3c552180c5b853cc9354a4649",
        "md5": "a1c99715d823ea6c9103fce741d915a2",
        "sha256": "bff9795c500b4449d6e59e188136dbb56be31aac3c0fd3423292b18eab68d05d"
      },
      "downloads": -1,
      "filename": "doddle-1.6.0.tar.gz",
      "has_sig": false,
      "md5_digest": "a1c99715d823ea6c9103fce741d915a2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 1274699,
      "upload_time": "2022-04-06T01:01:15",
      "upload_time_iso_8601": "2022-04-06T01:01:15.356875Z",
      "url": "https://files.pythonhosted.org/packages/dc/61/ea37a4b4c90d9f9e602cfba761a2f67d85c3c552180c5b853cc9354a4649/doddle-1.6.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}