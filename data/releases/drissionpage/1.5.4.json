{
  "info": {
    "author": "g1879",
    "author_email": "g1879@qq.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3.6",
      "Topic :: Utilities"
    ],
    "description": "# Introduction\n\n***\n\nDrissionPage, a combination of driver and session, is a python- based Web automation operation integration tool.  \nIt achieves seamless switching between selenium and requests.  \nTherefore, the convenience of selenium and the high efficiency of requests can be balanced.  \nIt integrates the common functions of the page, the API of the two modes is consistent, and it is easy to use.  \nIt uses the POM mode to encapsulate the commonly used methods of page elements, which is very suitable for automatic operation function expansion.  \nWhat's even better is that its usage is very concise and user- friendly, with a small amount of code and friendly to novices.\n\n**project address:**\n\n- https://github.com/g1879/DrissionPage\n- https://gitee.com/g1879/DrissionPage\n\n**Sample address:** [Use DrissionPage to crawl common websites and automation](https://gitee.com/g1879/DrissionPage-demos)\n\n**Contact Email: ** g1879@qq.com\n\n# Concept and background\n\n***\n\n## Idea\n\n**Concise, easy to use, extensible**\n\n\n\n## Background\n\nWhen the requests crawler faces the website to be logged in, it has to analyze data packets and JS source code, construct complex requests, and often has to deal with anti- climbing methods such as verification codes, JS confusion, and signature parameters, which has a high threshold. If the data is generated by JS calculation, the calculation process must be reproduced. The experience is not good and the development efficiency is not high.  \nUsing selenium, these pits can be bypassed to a large extent, but selenium is not efficient. Therefore, this library combines selenium and requests into one, switches the corresponding mode when different needs, and provides a user- friendly method to improve development and operation efficiency.  \nIn addition to merging the two, the library also encapsulates common functions in web pages, simplifies selenium's operations and statements. When used for web page automation, it reduces the consideration of details, focuses on function implementation, and makes it more convenient to use.  \nKeep everything simple, try to provide simple and direct usage, and be more friendly to novices.\n\n# Features\n\n***\n\n- The first pursuit is simple code.\n- Allow seamless switching between selenium and requests, sharing session.\n- The two modes provide consistent APIs, and the user experience is consistent.\n- Humanized page element operation mode, reducing the workload of page analysis and coding.\n- The common functions are integrated and optimized, which is more in line with actual needs.\n- Compatible with selenium code to facilitate project migration.\n- Use POM mode packaging for easy expansion.\n- A unified file download method makes up for the lack of browser downloads.\n- Simple configuration method, get rid of tedious browser configuration.\n\n# Project structure\n\n***\n## Structure diagram\n\n![](https://gitee.com/g1879/DrissionPage-demos/raw/master/pics/20201118164542.jpg)\n\n## Drission Class\n\nManage the WebDriver object and Session object responsible for communicating with the web page, which is equivalent to the role of the driver.\n\n## MixPage Class\n\nMixPage encapsulates the common functions of page operation. It calls the driver managed in the Drission class to access and operate the page. Can switch between driver and session mode. The login status will be automatically synchronized when switching.\n\n## DriverElement class\n\nThe page element class in driver mode can perform operations such as clicking on the element, inputting text, modifying attributes, running js, etc., and can also search for descendant elements at its lower level.\n\n## SessionElement Class\n\nThe page element class in session mode can obtain element attribute values and search for descendant elements at its lower levels.\n\n# Simple demo\n\n***\n\n## Comparison with selenium code\n\nThe following code implements exactly the same function, compare the amount of code between the two:\n\n- Use explicit waiting to find all elements that contain some text\n\n```python\n# Use selenium:\nelement = WebDriverWait(driver).until(ec.presence_of_all_elements_located((By.XPATH,'//*[contains(text(), \"some text\")]')))\n\n# Use DrissionPage:\nelement = page('some text')\n```\n\n\n\n- Jump to the first tab\n\n```python\n# Use selenium:\ndriver.switch_to.window(driver.window_handles[0])\n\n# Use DrissionPage:\npage.to_tab(0)\n```\n\n\n\n- Select drop- down list by text\n\n```python\n# Use selenium:\nfrom selenium.webdriver.support.select import Select\nselect_element = Select(element)\nselect_element.select_by_visible_text('text')\n\n# Use DrissionPage:\nelement.select('text')\n```\n\n\n\n- Drag and drop an element\n\n```python\n# Use selenium:\nActionChains(driver).drag_and_drop(ele1, ele2).perform()\n\n# Use DrissionPage:\nele1.drag_to(ele2)\n```\n\n\n\n- Scroll the window to the bottom (keep the horizontal scroll bar unchanged)\n\n```python\n# Use selenium:\ndriver.execute_script(\"window.scrollTo(document.documentElement.scrollLeft, document.body.scrollHeight);\")\n\n# Use DrissionPage:\npage.scroll_to('bottom')\n```\n\n\n\n- Set headless mode\n\n```python\n# Use selenium:\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"- - headless\")\n\n# Use DrissionPage:\nset_headless()\n```\n\n\n\n- Get pseudo element content\n\n```python\n# Use selenium:\ntext = webdriver.execute_script('return window.getComputedStyle(arguments[0], \"::after\").getPropertyValue(\"content\");', element)\n\n# Use DrissionPage:\ntext = element.after\n```\n\n\n\n- Get shadow- root\n\n```python\n# Use selenium:\nshadow_element = webdriver.execute_script('return arguments[0].shadowRoot', element)\n\n# Use DrissionPage:\nshadow_element = element.shadow_root\n```\n\n\n\n- Use xpath to get attributes or nodes\n\n```python\n# Use selenium:\nThe usage is not supported\n\n# Use DrissionPage:\nclass_name = element('xpath://div[@id=\"div_id\"]/@class')\ntext = element('xpath://div[@id=\"div_id\"]/text()[2]')\n```\n\n\n\n## Compare with requests code\n\nThe following code implements exactly the same function, compare the amount of code between the two:\n\n- Get element content\n\n```python\nurl ='https://baike.baidu.com/item/python'\n\n# Use requests:\nfrom lxml import etree\nheaders = {'User- Agent':'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36'}\nresponse = requests.get(url, headers = headers)\nhtml = etree.HTML(response.text)\nelement = html.xpath('//h1')[0]\ntitle = element.text\n\n# Use DrissionPage:\npage = MixPage('s')\npage.get(url)\ntitle = page('tag:h1').text\n```\n\nTips: DrissionPage comes with default headers\n\n\n\n-  download file\n\n```python\nurl ='https://www.baidu.com/img/flexible/logo/pc/result.png'\nsave_path = r'C:\\download'\n\n# Use requests:\nr = requests.get(url)\nwith open(f'{save_path}\\\\img.png','wb') as fd:\n   for chunk in r.iter_content():\n       fd.write(chunk)\n\n# Use DrissionPage:\npage.download(url, save_path,'img')  # Support renaming and handle file name conflicts\n```\n\n\n\n## Mode switch\n\nLog in to the website with selenium, and then switch to requests to read the web page. Both will share login information.\n\n```python\npage = MixPage()  # Create page object, default driver mode\npage.get('https://gitee.com/profile')  # Visit the personal center page (not logged in, redirect to the login page)\n\npage.ele('@id:user_login').input('your_user_name')  # Use selenium to enter the account password to log in\npage.ele('@id:user_password').input('your_password\\n')\n\npage.change_mode()  # Switch to session mode\nprint('Title after login:', page.title,'\\n')  # session mode output after login\n```\n\nOutput:\n\n```\nTitle after login: Personal Information- Code Cloud Gitee.com\n```\n\n\n\n## Get and print element attributes\n\n```python\n# Connect the previous code\nfoot = page.ele('@id:footer- left')  # find element by id\nfirst_col = foot.ele('css:>div')  # Use the css selector to find the element in the lower level of the element (the first one)\nlnk = first_col.ele('text: Command Learning')  # Use text content to find elements\ntext = lnk.text  # Get element text\nhref = lnk.attr('href')  # Get element attribute value\n\nprint(text, href,'\\n')\n\n# Concise mode series search\ntext = page('@id:footer- left')('css:>div')('text:command learning').text\nprint(text)\n```\n\nOutput:\n\n```\nGit command learning https://oschina.gitee.io/learn- git- branching/\n\nGit command learning\n```\n\n\n\n## download file\n\n```python\nurl ='https://www.baidu.com/img/flexible/logo/pc/result.png'\nsave_path = r'C:\\download'\npage.download(url, save_path)\n```\n\n\n\n# Installation\n\n***\n\n```\npip install DrissionPage\n```\nOnly supports python3.6 and above, and the driver mode currently only supports chrome.\nTo use the driver mode, you must download chrome and **corresponding version** of chromedriver. [[chromedriver download]](https://chromedriver.chromium.org/downloads)\nIt has only been tested in the Windows environment.\n\n# Instructions\n\n***\n\n## Import module\n\n```python\nfrom DrissionPage import *\n```\n\n\n\n## Initialization\n\nIf you only use session mode, you can skip this section.\n\nBefore using selenium, you must configure the path of chrome.exe and chromedriver.exe and ensure that their versions match.\n\nThere are three ways to configure the path:\n- Write two paths to system variables.\n- Manually pass in the path when in use.\n- Write the path to the ini file of this library (recommended).\n\nIf you choose the third method, please run these lines of code before using this library for the first time and record these two paths in the ini file.\n\n```python\nfrom DrissionPage.easy_set import set_paths\ndriver_path ='D:\\\\chrome\\\\chromedriver.exe'  # Your chromedriver.exe path, optional\nchrome_path ='D:\\\\chrome\\\\chrome.exe'  # Your chrome.exe path, optional\nset_paths(driver_path, chrome_path)\n```\n\nThis method also checks whether the chrome and chromedriver versions match, and displays:\n\n```\nThe version matches and can be used normally.\n\n# Or\n\nAbnormal:\nMessage: session not created: Chrome version must be between 70 and 73\n  (Driver info: chromedriver=73.0.3683.68 (47787ec04b6e38e22703e856e101e840b65afe72),platform=Windows NT 10.0.19631 x86_64)\nchromedriver download URL: https://chromedriver.chromium.org/downloads\n```\n\nAfter passing the check, you can use the driver mode normally.\n\nIn addition to the above two paths, this method can also set the following paths:\n\n```python\ndebugger_address  # Debug browser address, such as: 127.0.0.1:9222\ndownload_path  # Download file path\nglobal_tmp_path  # Temporary folder path\nuser_data_path  # User data path\ncache_path  # cache path\n```\n\nTips:\n\n- Different projects may require different versions of chrome and chromedriver. You can also save multiple ini files and use them as needed.\n- It is recommended to use the green version of chrome, and manually set the path, to avoid browser upgrades causing mismatch with the chromedriver version.\n- It is recommended to set the debugger_address when debugging the project and use the manually opened browser to debug, saving time and effort.\n\n\n\n## Create drive object Drission\n\nThe creation step is not necessary. If you want to get started quickly, you can skip this section. The MixPage object will automatically create the object.\n\nDrission objects are used to manage driver and session objects. When multiple pages work together, the Drission object is used to pass the driver, so that multiple page classes can control the same browser or Session object.\nThe configuration information of the ini file can be directly read and created, or the configuration information can be passed in during initialization.\n\n```python\n# Create from the default ini file\ndrission = Drission()\n\n# Create by other ini files\ndrission = Drission(ini_path ='D:\\\\settings.ini')\n\n# Create without ini files\ndrission = Drission(read_file = False)\n```\n\nTo manually pass in the configuration:\n\n```python\n# Create with the incoming configuration information (ignore the ini file)\nfrom DrissionPage.config import DriverOptions\n\n# Create a driver configuration object, read_file = False means not to read the ini file\ndo = DriverOptions(read_file = False)\n\n# Set the path, if it has been set in the system variable, it can be ignored\ndo.set_paths(chrome_path ='D:\\\\chrome\\\\chrome.exe',\n              driver_path ='D:\\\\chrome\\\\chromedriver.exe')\n\n# Settings for s mode\nsession_options = {'headers': {'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)'}}\n\n# Incoming configuration, driver_options and session_options are optional, you need to use the corresponding mode to pass in\ndrission = Drission(driver_options, session_options)\n```\n\n\n\n## Use page object MixPage\n\nThe MixPage page object encapsulates common web page operations and realizes the switch between driver and session modes.\nMixPage must receive a Drission object and use the driver or session in it. If it is not passed in, MixPage will create a Drission by itself (using the configuration of the default ini file).\n\nTips: When multiple page objects work together, remember to manually create a Drission object and pass it to the page object for use. Otherwise, the page objects will each create their own Drission objects, making the information unable to pass.\n\n### Create Object\n\nThere are three ways to create objects: simple, passing in Drission objects, and passing in configuration. Can be selected according to actual needs.\n\n```python\n# Simple creation method, automatically create Drission objects with ini file default configuration\npage = MixPage()\npage = MixPage('s')\n\n# Create by passing in the Drission object\npage = MixPage(drission)\npage = MixPage(drission, mode='s', timeout=5)  # session mode, waiting time is 5 seconds (default 10 seconds)\n\n# Create with incoming configuration information\npage = MixPage(driver_options=DriverOption, session_options=SessionOption)  # default d mode\n```\n\n\n\n### visit website\n\nIf there is an error in the connection, the program will automatically retry twice. The number of retries and the waiting interval can be specified.\n\n```python\n# Default mode\npage.get(url)\npage.post(url, data, **kwargs)  # Only session mode has post method\n\n# Specify the number of retries and interval\npage.get(url, retry=5, interval=0.5)\n```\n\n\n\n### Switch mode\n\nSwitch between s and d modes, the cookies and the URL you are visiting will be automatically synchronized when switching.\n\n```python\npage.change_mode(go=False)  # If go is False, it means that the url is not redirected\n```\n\n\n\n### Page properties\n\n```python\npage.url  # currently visited url\npage.mode  # current mode\npage.drission  # Dirssion object currently in use\npage.driver  # WebDirver object currently in use\npage.session  # Session object currently in use\npage.cookies  # Get cookies information\npage.html  # Page source code\npage.title  # Current page title\n\n# d mode unique:\npage.tabs_count  # Return the number of tab pages\npage.tab_handles  # Return to the handle list of all tabs\npage.current_tab_num  # Return the serial number of the current tab page\npage.current_tab_handle  # Return to the current tab page handle\n```\n\n\n\n### Page operation\n\nWhen calling a method that only belongs to d mode, it will automatically switch to d mode. See APIs for detailed usage.\n\n```python\npage.change_mode()  # switch mode\npage.cookies_to_session()  # Copy cookies from WebDriver object to Session object\npage.cookies_to_driver()  # Copy cookies from Session object to WebDriver object\npage.get(url, retry, interval, **kwargs)  # Use get to access the web page, you can specify the number of retries and the interval\npage.ele(loc_or_ele, timeout)  # Get the first element, node or attribute that meets the conditions\npage.eles(loc_or_ele, timeout)  # Get all eligible elements, nodes or attributes\npage.download(url, save_path, rename, file_exists, **kwargs)  # download file\npage.close_driver()  # Close the WebDriver object\npage.close_session()  # Close the Session object\n\n# s mode unique:\npage.post(url, data, retry, interval, **kwargs)  # To access the webpage in post mode, you can specify the number of retries and the interval\n\n# d mode unique:\npage.wait_ele(loc_or_ele, mode, timeout)  # Wait for the element to be deleted, displayed, and hidden from the dom\npage.run_script(js, *args)  # Run js statement\npage.create_tab(url)  # Create and locate a tab page, which is at the end\npage.to_tab(num_or_handle)  # Jump to tab page\npage.close_current_tab()  # Close the current tab page\npage.close_other_tabs(num)  # Close other tabs\npage.to_iframe(iframe)  # cut into iframe\npage.screenshot(path)  # Page screenshot\npage.scrool_to_see(element)  # Scroll until an element is visible\npage.scroll_to(mode, pixel)  # Scroll the page as indicated by the parameter, and the scroll direction is optional:'top','bottom','rightmost','leftmost','up','down','left', ' right'\npage.refresh()  # refresh the current page\npage.back()  # Browser back\npage.et_window_size(x, y)  # Set the browser window size, maximize by default\npage.check_page()  # Check whether the page meets expectations\npage.chrome_downloading()  # Get the list of files that chrome is downloading\npage.process_alert(mode, text)  # Process the prompt box\n```\n\n\n\n## Find element\n\nele() returns the first eligible element, and eles() returns a list of all eligible elements.\nYou can use these two functions under the page object or element object to find subordinate elements.\n\npage.eles() and element.eles() search and return a list of all elements that meet the conditions.\n\nDescription:\n\n- The element search timeout is 10 seconds by default, you can also set it as needed.\n\n- In the following search statement, the colon: indicates a fuzzy match, and the equal sign = indicates an exact match\n\n- There are five types of query strings: @attribute name, tag, text, xpath, and css\n\n```python\n# Find by attribute\npage.ele('@id:ele_id', timeout = 2)  # Find the element whose id is ele_id and set the waiting time for 2 seconds\npage.eles('@class')  # Find all elements with class attribute\npage.eles('@class:class_name')  # Find all elements that have ele_class in class\npage.eles('@class=class_name')  # Find all elements whose class is equal to ele_class\n\n# Find by tag name\npage.ele('tag:li')  # Find the first li element\npage.eles('tag:li')  # Find all li elements\n\n# Find according to tag name and attributes\npage.ele('tag:div@class=div_class')  # Find the div element whose class is div_class\npage.ele('tag:div@class:ele_class')  # Find div elements whose class contains ele_class\npage.ele('tag:div@class=ele_class')  # Find div elements whose class is equal to ele_class\npage.ele('tag:div@text():search_text')  # Find div elements whose text contains search_text\npage.ele('tag:div@text()=search_text')  # Find the div element whose text is equal to search_text\n\n# Find according to text content\npage.ele('search text')  # find the element containing the incoming text\npage.eles('text:search text')  # If the text starts with @, tag:, css:, xpath:, text:, add text: in front to avoid conflicts\npage.eles('text=search text')  # The text is equal to the element of search_text\n\n# Find according to xpath or css selector\npage.eles('xpath://div[@class=\"ele_class\"]')\npage.eles('css:div.ele_class')\n\n# Find according to loc\nloc1 = By.ID,'ele_id'\nloc2 = By.XPATH,'//div[@class=\"ele_class\"]'\npage.ele(loc1)\npage.ele(loc2)\n\n# Find lower- level elements\nelement = page.ele('@id:ele_id')\nelement.ele('@class:class_name')  # Find the first element whose class is ele_class at the lower level of element\nelement.eles('tag:li')  # find all li elements under ele_id\n\n# Find by location\nelement.parent  # parent element\nelement.next  # next sibling element\nelement.prev  # previous sibling element\n\n# Get shadow- dom, only support open shadow- root\nele1 = element.shadow_root.ele('tag:div')\n\n# Chain search\npage.ele('@id:ele_id').ele('tag:div').next.ele('some text').eles('tag:a')\n\n# Simplified writing\neles = page('@id:ele_id')('tag:div').next('some text').eles('tag:a')\nele2 = ele1('tag:li').next('some text')\n```\n\n\n\n## Get element attributes\n\n```python\nelement.html  # Return element outerHTML\nelement.inner_html  # Return element innerHTML\nelement.tag  # Return element tag name\nelement.text  # Return element innerText value\nelement.link  # Returns absolute href or src value of the element.\nelement.texts()  # Returns the text of all direct child nodes in the element, including elements and text nodes, you can specify to return only text nodes\nelement.attrs  # Return a dictionary of all attributes of the element\nelement.attr(attr)  # Return the value of the specified attribute of the element\nelement.css_path  # Return the absolute css path of the element\nelement.xpath  # Return the absolute xpath path of the element\nelement.parent  # Return element parent element\nelement.next  # Return the next sibling element of the element\nelement.prev  # Return the previous sibling element of the element\nelement.parents(num)  # Return the numth parent element\nelement.nexts(num, mode)  # Return the following elements or nodes\nelement.prevs(num, mode)  # Return the first few elements or nodes\nelement.ele(loc_or_str, timeout)  # Return the first sub- element, attribute or node text of the current element that meets the conditions\nelement.eles(loc_or_str, timeout)  # Return all eligible sub- elements, attributes or node texts of the current element\n\n# d mode unique:\nelement.before  # Get pseudo element before content\nelement.after  # Get pseudo element after content\nelement.is_valid  # Used to determine whether the element is still in dom\nelement.size  # Get element size\nelement.location  # Get element location\nelement.shadow_root  # Get the ShadowRoot element under the element\nelement.get_style_property(style, pseudo_ele)  # Get element style attribute value, can get pseudo element\nelement.is_selected()  # Returns whether the element is selected\nelement.is_enabled()  # Returns whether the element is available\nelement.is_displayed()  # Returns whether the element is visible\n```\n\n\n\n## Element operation\n\nElement operation is unique to d mode. Calling the following method will automatically switch to d mode.\n\n```python\nelement.click(by_js)  # Click the element, you can choose whether to click with js\nelement.input(value)  # input text\nelement.run_script(js)  # Run JavaScript script on the element\nelement.submit()  # Submit\nelement.clear()  # Clear the element\nelement.screenshot(path, filename)  # Take a screenshot of the element\nelement.select(text)  # Select the drop- down list based on the text\nelement.set_attr(attr, value)  # Set element attribute value\nelement.drag(x, y, speed, shake)  # Drag the relative distance of the element, you can set the speed and whether to shake randomly\nelement.drag_to(ele_or_loc, speed, shake)  # Drag the element to another element or a certain coordinate, you can set the speed and whether to shake randomly\nelement.hover()  # Hover the mouse over the element\n```\n\n\n\n## Docking with selenium code\n\nThe DrissionPage code can be seamlessly spliced ​​with the selenium code, either directly using the selenium WebDriver object, or using its own WebDriver everywhere for the selenium code. Make the migration of existing projects very convenient.\n\n### selenium to DrissionPage\n\n```python\ndriver = webdriver.Chrome()\ndriver.get('https://www.baidu.com')\n\npage = MixPage(Drission(driver))  # Pass the driver to Drission, create a MixPage object\nprint(page.title)  # Print result: You will know by clicking on Baidu\n```\n\n\n\n### DrissionPage to selenium\n\n```python\npage = MixPage()\npage.get('https://www.baidu.com')\n\ndriver = page.driver  # Get the WebDriver object from the MixPage object\nprint(driver.title)  # Print results: You will know by clicking on Baidu\n```\n\n\n\n## download file\n\nSelenium lacks effective management of browser download files, and it is difficult to detect download status, rename, and fail management.\nUsing requests to download files can better achieve the above functions, but the code is more cumbersome.\nTherefore, DrissionPage encapsulates the download method and integrates the advantages of the two. You can obtain login information from selenium and download it with requests.\nTo make up for the shortcomings of selenium, make the download simple and efficient.\n\n### Features\n\n- Specify download path\n- Rename the file without filling in the extension, the program will automatically add\n- When there is a file with the same name, you can choose to rename, overwrite, skip, etc.\n- Show download progress\n- Support post method\n- Support custom connection parameters\n\n### Demo\n\n```python\nurl ='https://www.baidu.com/img/flexible/logo/pc/result.png'  # file url\nsave_path = r'C:\\download'  # save path\n\n# Rename to img.png, and automatically add a serial number to the end of the file name when there is a duplicate name to display the download progress\npage.download(url, save_path,'img','rename', show_msg=True)\n```\n\n\n\n\n## Chrome Quick Settings\n\nThe configuration of chrome is very cumbersome. In order to simplify the use, this library provides setting methods for common configurations.\n\n### DriverOptions Object\n\nThe DriverOptions object inherits from the Options object of selenium.webdriver.chrome.options, and the following methods are added to it:\n\n```python\nremove_argument(value)  # delete an argument value\nremove_experimental_option(key)  # delete an experimental_option setting\nremove_all_extensions()  # Remove all plugins\nsave()  # Save the configuration to the default ini file\nsave('D:\\\\settings.ini')  # save to other path\nset_argument(arg, value)  # set argument attribute\nset_headless(on_off)  # Set whether to use no interface mode\nset_no_imgs(on_off)  # Set whether to load images\nset_no_js(on_off)  # Set whether to disable js\nset_mute(on_off)  # Set whether to mute\nset_user_agent(user_agent)  # set user agent\nset_proxy(proxy)  # set proxy address\nset_paths(driver_path, chrome_path, debugger_address, download_path, user_data_path, cache_path)  # Set browser- related paths\n```\n\n\n\n### Instructions\n\n```python\ndo = DriverOptions(read_file=False)  # Create chrome configuration object, not read from ini file\ndo.set_headless(False)  # show the browser interface\ndo.set_no_imgs(True)  # Do not load pictures\ndo.set_paths(driver_path='D:\\\\chromedriver.exe', chrome_path='D:\\\\chrome.exe')  # set path\ndo.set_headless(False).set_no_imgs(True)  # Support chain operation\n\ndrission = Drission(driver_options=do)  # Create Drission object with configuration object\npage = MixPage(drission)  # Create a MixPage object with Drission object\n\ndo.save()  # Save the configuration to the default ini file\n```\n\n\n\n## Save configuration\n\nBecause there are many configurations of chrome and headers, an ini file is set up specifically to save common configurations. You can use the OptionsManager object to get and save the configuration, and use the DriverOptions object to modify the chrome configuration. You can also save multiple ini files and call them according to different projects.\n\nTips: It is recommended to save the commonly used configuration files to another path to prevent the configuration from being reset when the library is upgraded.\n\n### ini file content\n\nThe ini file has three parts by default: paths, chrome_options, and session_options. The initial content is as follows.\n\n```ini\n[paths]\n; chromedriver.exe path\nchromedriver_path =\n; Temporary folder path, used to save screenshots, file downloads, etc.\nglobal_tmp_path =\n\n[chrome_options]\n; The address and port of the opened browser, such as 127.0.0.1:9222\ndebugger_address =\n; chrome.exe path\nbinary_location =\n; Configuration information\narguments = [\n            ; Hide browser window\n            '- - headless',\n            ; Mute\n            '- - mute- audio',\n            ; No sandbox\n            '- - no- sandbox',\n            ; Google documentation mentions that this attribute needs to be added to avoid bugs\n            '- - disable- gpu',\n            ; Ignore warning\n            'ignore- certificate- errors',\n            ; Do not display the information bar\n            '- - disable- infobars'\n            ]\n; Plugin\nextensions = []\n; Experimental configuration\nexperimental_options = {\n                       'prefs': {\n                       ; Download does not pop up\n                       'profile.default_content_settings.popups': 0,\n                       ; No popup\n                       'profile.default_content_setting_values': {'notifications': 2},\n                       ; Disable PDF plugin\n                       'plugins.plugins_list': [{\"enabled\": False, \"name\": \"Chrome PDF Viewer\"}]\n                       },\n                       ; Set to developer mode, anti- reptile\n                       'excludeSwitches': [\"enable- automation\"],\n                       'useAutomationExtension': False\n                       }\n\n[session_options]\nheaders = {\n          \"User- Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8\",\n          \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n          \"Connection\": \"keep- alive\",\n          \"Accept- Charset\": \"utf- 8;q=0.7,*;q=0.7\"\n          }\n```\n\n\n\n### OptionsManager Object\n\nThe OptionsManager object is used to read, set and save the configuration.\n\n```python\nget_value(section, item) - > str  # Get the value of a configuration\nget_option(section) - > dict  # Return all attributes of configuration in dictionary format\nset_item(section, item, value)  # Set configuration attributes\nsave()  # Save the configuration to the default ini file\nsave('D:\\\\settings.ini')  # save to other path\n```\n\n\n\n### Usage example\n\n```python\nfrom DrissionPage.configs import *\n\noptions_manager = OptionsManager()  # Create OptionsManager object from the default ini file\noptions_manager = OptionsManager('D:\\\\settings.ini')  # Create OptionsManager object from other ini files\ndriver_path = options_manager.get_value('paths','chromedriver_path')  # read path information\noptions_manager.save()  # Save to the default ini file\noptions_manager.save('D:\\\\settings.ini')  # save to other path\n\ndrission = Drission(ini_path ='D:\\\\settings.ini')  # Use other ini files to create objects\n```\n\n**Note**: If you do not pass in the path when saving, it will be saved to the ini file in the module directory, even if the read is not the default ini file.\n\n\n\n## easy_set method\n\nCalling the easy_set method will modify the content of the default ini file.\n\n```python\nset_headless(True)  # Turn on headless mode\nset_no_imgs(True)  # Turn on no image mode\nset_no_js(True)  # Disable JS\nset_mute(True)  # Turn on mute mode\nset_user_agent('Mozilla/5.0 (Macintosh; Int......')  # set user agent\nset_proxy('127.0.0.1:8888')  # set proxy\nset_paths(paths)  # See [Initialization] section\nset_argument(arg, value)  # Set the attribute. If the attribute has no value (such as'zh_CN.UTF- 8'), the value is bool, which means switch; otherwise, the value is str. When the value is'' or False, delete the attribute item\n```\n\n# POM mode\n\n***\n\nMixPage encapsulates common page operations and can be easily used for extension.\n\nExample: extend a list page reading class\n\n```python\nimport re\nfrom time import sleep\nfrom DrissionPage import *\n\nclass ListPage(MixPage):\n    \"\"\"This class encapsulates the method of reading the list page. According to the necessary 4 elements, the isomorphic list page can be read\n    (Chinese variable is really fragrant) \"\"\"\n    def __init__(self, drission: Drission, url: str = None, **xpaths):\n        super().__init__(drission)\n        self._url = url\n        self.xpath_column name = xpaths['column name']  # [xpath string, regular expression]\n        self.xpath_next page = xpaths['next page']\n        self.xpath_lines = xpaths['line']\n        self.xpath_page number = xpaths['page number']  # [xpath string, regular expression]\n        self.total pages = self.get_total pages()\n        if url:\n            self.get(url)\n\n    def get_column name (self) - > str:\n        if self.xpath_ column name[1]:\n            s = self.ele(f'xpath:{self.xpath_column name[0]}').text\n            r = re.search(self.xpath_column name[1], s)\n            return r.group(1)\n        else:\n            return self.ele(f'xpath:{self.xpath_column name[0]}').text\n\n    def get_total number of pages (self) - > int:\n        if self.xpath_page number[1]:\n            s = self.ele(f'xpath:{self.xpath_number of pages[0]}').text\n            r = re.search(self.xpath_number of pages[1], s)\n            return int(r.group(1))\n        else:\n            return int(self.ele(f'xpath:{self.xpath_number of pages[0]}').text)\n\n    def click_next page(self, wait: float = None):\n        self.ele(f'xpath:{self.xpath_next page}').click()\n        if wait:\n            sleep(wait)\n\n    def get_ current page list (self, content to be crawled: list) - > list:\n        \"\"\"\n        Format of content to be crawled: [[xpath1,parameter1],[xpath2,parameter2]...]\n        Return list format: [[Parameter1,Parameter2...],[Parameter1,Parameter2...]...]\n        \"\"\"\n        Result list = []\n        Line s = self.eles(f'xpath:{self.xpath_lines}')\n        for line in line s:\n            Row result = []\n            for j in content to be crawled:\n                Line result.append(line.ele(f'xpath:{j[0]}').attr(j[1]))\n            Result list.append (row result)\n            print(line result)\n        return result list\n\n    def get_list(self, content to be crawled: list, wait: float = None) - > list:\n        List = self.get_ current page list (content to be crawled)\n        for _ in range(self. total pages- 1):\n            self.click_next page(wait)\n            List.extend(self.get_current page list (content to be crawled))\n        return list\n```\n\n# Other\n\n***\n\n## DriverPage and SessionPage\n\nIf you don't need to switch modes, you can only use DriverPage or SessionPage as needed, and the usage is the same as MixPage.\n\n```python\nfrom DrissionPage.session_page import SessionPage\nfrom DrissionPage.drission import Drission\n\nsession = Drission().session\npage = SessionPage(session)  # Pass in Session object\npage.get('http://www.baidu.com')\nprint(page.ele('@id:su').text)  # Output: Baidu\n\ndriver = Drission().driver\npage = DriverPage(driver)  # Pass in Driver object\npage.get('http://www.baidu.com')\nprint(page.ele('@id:su').text)  # Output: Baidu\n```\n\n# APIs\n\n***\n\n## Drission Class\n\n### class Drission()\n\nThe Drission class is used to manage WebDriver objects and Session objects, and is the role of the driver.\n\nParameter Description:\n\n- driver_or_options: [WebDriver, dict, Options]  - WebDriver object or chrome configuration parameters.\n- session_or_options: [Session, dict]  - Session object configuration parameters\n- ini_path: str  - ini file path, the default is the ini file under the DrissionPage folder\n- proxy: dict  - proxy settings\n\n\n\n### session\n\nReturn the Session object, which is automatically initialized according to the configuration information.\n\nReturns: Session- the managed Session object\n\n\n\n### driver\n\nReturn the WebDriver object, which is automatically initialized according to the configuration information.\n\nReturns: WebDriver- Managed WebDriver object\n\n\n\n### driver_options\n\nReturn or set the driver configuration.\n\nReturns: dict\n\n\n\n### session_options\n\nReturn to session configuration.\n\nReturns: dict\n\n\n\n### session_options()\n\nSet the session configuration.\n\nReturns: None\n\n\n\n### proxy\n\nReturn to proxy configuration.\n\nReturns: dict\n\n\n\n### cookies_to_session()\n\nCopy the cookies of the driver object to the session object.\n\nParameter Description:\n\n- copy_user_agent: bool  - whether to copy user_agent to session\n- driver: WebDriver- Copy the WebDriver object of cookies\n- session: Session- Session object that receives cookies\n\nReturns: None\n\n\n\n### cookies_to_driver()\n\nCopy cookies from session to driver.\n\nParameter Description:\n\n- url: str  - the domain of cookies\n- driver: WebDriver- WebDriver object that receives cookies\n- session: Session- Copy the Session object of cookies\n\nReturns: None\n\n\n\n### user_agent_to_session()\n\nCopy the user agent from the driver to the session.\n\nParameter Description:\n\n- driver: WebDriver- WebDriver object, copy user agent\n- session: Session- Session object, receiving user agent\n\nReturns: None\n\n\n\n### close_driver()\n\nClose the browser and set the driver to None.\n\nReturns: None\n\n\n\n### close_session()\n\nClose the session and set it to None.\n\nReturns: None\n\n\n\n### close()\n\nClose the driver and session.\n\nReturns: None\n\n\n\n## MixPage Class\n\n### class MixPage()\n\nMixPage encapsulates the common functions of page operation and can seamlessly switch between driver and session modes. Cookies are automatically synchronized when switching.\nThe function of obtaining information is shared by the two modes, and the function of operating page elements is only available in mode d. Calling a function unique to a certain mode will automatically switch to that mode.\nIt inherits from DriverPage and SessionPage classes, these functions are implemented by these two classes, and MixPage exists as a scheduling role.\n\nParameter Description:\n\n- drission: Drission  - Drission object, if not passed in, create one. Quickly configure the corresponding mode when's' or'd' is passed in\n- mode: str  - mode, optional'd' or's', default is'd'\n- timeout: float  - timeout, driver mode is the time to find elements, session mode is the connection waiting time\n\n\n\n### url\n\nReturns the URL currently visited by the MixPage object.\n\nReturns: str\n\n\n\n### mode\n\nReturns the current mode ('s' or'd').\n\nReturns: str\n\n\n\n### drission\n\nReturns the Dirssion object currently in use.\n\nReturns: Drission\n\n\n\n### driver\n\nReturn the driver object, if not, create it, and switch to driver mode when calling.\n\nReturns: WebDriver\n\n\n\n### session\n\nReturn the session object, if not, create it.\n\nReturns: Session\n\n\n\n### response\n\nReturn the Response object obtained in s mode, and switch to s mode when called.\n\nReturns: Response\n\n\n\n### cookies\n\nReturn cookies, obtained from the current mode.\n\nReturns: [dict, list]\n\n\n\n### html\n\nReturn the html text of the page.\n\nReturns: str\n\n\n\n### title\n\nReturn to the page title.\n\nReturns: str\n\n\n\n### url_available\n\nReturns the validity of the current url.\n\nReturns: bool\n\n\n\n### change_mode()\n\nSwitch mode,'d' or's'. When switching, the cookies of the current mode will be copied to the target mode.\n\nParameter Description:\n\n- mode: str  - Specify the target mode,'d' or's'.\n- go: bool  - whether to jump to the current url after switching mode\n\nReturns: None\n\n\n\n### ele()\n\nReturn the eligible elements on the page, the first one is returned by default.\nIf the query parameter is a string, the options of'@attribute name:','tag:','text:','css:', and'xpath:' are available. When there is no control mode, the text mode is used to search by default.\nIf it is loc, query directly according to the content.\n\nParameter Description:\n\n- loc_or_str: [Tuple[str, str], str, DriverElement, SessionElement, WebElement]  - The positioning information of the element, which can be an element object, a loc tuple, or a query string\n- mode: str  - 'single' or'all', corresponding to find one or all\n- timeout: float  - Find the timeout of the element, valid in driver mode\n\nExample:\n\n- When the element object is received: return the element object object\n\n- Find with loc tuple:\n\n  - ele.ele((By.CLASS_NAME,'ele_class'))  - returns the first child element whose class is ele_class\n\n- Find with query string:\n\n  Attributes, tag name and attributes, text, xpath, css selector.\n\n  Among them, @ means attribute, = means exact match,: means fuzzy match, the string is searched by default when there is no control string.\n\n  - page.ele('@class:ele_class')  - returns the element with ele_class in the first class\n  - page.ele('@name=ele_name')  - returns the first element whose name is equal to ele_name\n  - page.ele('@placeholder')  - returns the first element with placeholder attribute\n  - page.ele('tag:p')  - return the first p element\n  - page.ele('tag:div@class:ele_class')  - returns the first class div element with ele_class\n  - page.ele('tag:div@class=ele_class')  - returns the first div element whose class is equal to ele_class\n  - page.ele('tag:div@text():some_text')  - returns the first div element whose text contains some_text\n  - page.ele('tag:div@text()=some_text')  - returns the first div element whose text is equal to some_text\n  - page.ele('text:some_text')  - returns the first element whose text contains some_text\n  - page.ele('some_text')  - returns the first text element containing some_text (equivalent to the previous line)\n  - page.ele('text=some_text')  - returns the first element whose text is equal to some_text\n  - page.ele('xpath://div[@class=\"ele_class\"]')  - return the first element that matches xpath\n  - page.ele('css:div.ele_class')  - returns the first element that matches the css selector\n\nReturns: [DriverElement, SessionElement, str]  - element object or attribute, text node text\n\n\n\n### eles()\n\nGet the list of elements that meet the conditions according to the query parameters. The query parameter usage method is the same as the ele method.\n\nParameter Description:\n\n- loc_or_str: [Tuple[str, str], str]  - query condition parameter\n- timeout: float  - Find the timeout of the element, valid in driver mode\n\nReturns: [List[DriverElement or str], List[SessionElement or str]]  - a list of element objects or attributes and text node text\n\n\n\n### cookies_to_session()\n\nCopy cookies from the WebDriver object to the Session object.\n\nParameter Description:\n\n- copy_user_agent: bool  - whether to copy user agent at the same time\n\nReturns: None\n\n\n\n### cookies_to_driver()\n\nCopy cookies from the Session object to the WebDriver object.\n\nParameter Description:\n\n- url: str  - the domain or url of cookies\n\nReturns: None\n\n\n\n### get()\n\nTo jump to a url, synchronize cookies before the jump, and return whether the target url is available after the jump.\n\nParameter Description:\n\n- url: str  - target url\n- go_anyway: bool  - Whether to force a jump. If the target url is the same as the current url, it will not redirect by default.\n- show_errmsg: bool  - whether to display and throw an exception\n- retry: int  - the number of retries when a connection error occurs\n- interval: float  - Retry interval (seconds)\n- **kwargs  - connection parameters for requests\n\nReturns: [bool, None]  - whether the url is available\n\n\n\n### post()\n\nJump in post mode, automatically switch to session mode when calling.\n\nParameter Description:\n\n- url: str  - target url\n- data: dict  - submitted data\n- go_anyway: bool  - Whether to force a jump. If the target url is the same as the current url, it will not redirect by default.\n- show_errmsg: bool  - whether to display and throw an exception\n- retry: int  - the number of retries when a connection error occurs\n- interval: float  - Retry interval (seconds)\n- **kwargs  - connection parameters for requests\n\nReturns: [bool, None]  - whether the url is available\n\n\n\n### download()\n\nDownload a file, return whether it is successful and the download information string. This method will automatically avoid the same name with the existing file in the target path.\n\nParameter Description:\n\n- file_url: str  - file url\n- goal_path: str  - storage path, the default is the temporary folder specified in the ini file\n- rename: str  - rename the file without changing the extension\n- file_exists: str  - If there is a file with the same name, you can choose'rename','overwrite','skip' to process\n- post_data: dict  - data submitted in post mode\n- show_msg: bool  - whether to show download information\n- show_errmsg: bool  - whether to display and throw an exception\n- **kwargs  - connection parameters for requests\n\nReturns: Tuple[bool, str]  - a tuple of whether the download was successful (bool) and status information (the information is the file path when successful)\n\n\n\nThe following methods and properties only take effect in driver mode, and will automatically switch to driver mode when called\n\n***\n\n### tabs_count\n\nReturns the number of tab pages.\n\nReturns: int\n\n\n\n### tab_handles\n\nReturns the handle list of all tabs.\n\nReturns: list\n\n\n\n### current_tab_num\n\nReturns the serial number of the current tab page.\n\nReturns: int\n\n\n\n### current_tab_handle\n\nReturns the handle of the current tab page.\n\nReturns: str\n\n\n\n### wait_ele()\n\nWait for the element to be deleted, displayed, and hidden from the dom.\n\nParameter Description:\n\n- loc_or_ele: [str, tuple, DriverElement, WebElement]  - Element search method, same as ele()\n- mode: str  - waiting mode, optional:'del','display','hidden'\n- timeout: float  - waiting timeout\n\nReturns: bool  - whether the wait is successful\n\n\n\n### check_page()\n\nIn d mode, check whether the web page meets expectations. The response status is checked by default, and can be overloaded to achieve targeted checks.\n\nParameter Description:\n\n- by_requests: bool  - Force the use of built- in response for checking\n\nReturn: [bool, None]  - bool is available, None is unknown\n\n\n\n### run_script()\n\nExecute JavaScript code.\n\nParameter Description:\n\n- script: str  - JavaScript code text\n- *args  - incoming parameters\n\nReturns: Any\n\n\n\n### create_tab()\n\nCreate and locate a tab page, which is at the end.\n\nParameter Description:\n\n- url: str  - the URL to jump to the new tab page\n\nReturns: None\n\n\n\n### close_current_tab()\n\nClose the current tab.\n\nReturns: None\n\n\n\n### close_other_tabs()\n\nClose tab pages other than the incoming tab page, and keep the current page by default.\n\nParameter Description:\n\n- num_or_handle:[int, str]  - The serial number or handle of the tab to keep, the first serial number is 0, and the last is - 1\n\nReturns: None\n\n\n\n### to_tab()\n\nJump to the tab page.\n\nParameter Description:\n\n- num_or_handle:[int, str]  - tab page serial number or handle string, the first serial number is 0, the last is - 1\n\nReturns: None\n\n\n\n### to_iframe()\n\nJump to iframe, jump to the highest level by default, compatible with selenium native parameters.\n\nParameter Description:\n\n- loc_or_ele:[int, str, tuple, WebElement, DriverElement]  - Find the condition of iframe element, can receive iframe serial number (starting at 0), id or name, query string, loc parameter, WebElement object, DriverElement object, and pass in ' main' jump to the highest level, and pass in'parent' to jump to the upper level\n\nExample:\n- to_iframe('tag:iframe')- locate by the query string passed in iframe\n- to_iframe('iframe_id')- Positioning by the id attribute of the iframe\n- to_iframe('iframe_name')- locate by the name attribute of iframe\n- to_iframe(iframe_element)- locate by passing in the element object\n- to_iframe(0)- locate by the serial number of the iframe\n- to_iframe('main')- jump to the top level\n- to_iframe('parent')- jump to the previous level\n\nReturns: None\n\n\n\n### scroll_to_see()\n\nScroll until the element is visible.\n\nParameter Description:\n\n- loc_or_ele:[str, tuple, WebElement, DriverElement]  - The conditions for finding elements are the same as those of the ele() method.\n\nReturns: None\n\n\n\n### scroll_to()\n\nScroll the page and decide how to scroll according to the parameters.\n\nParameter Description:\n\n- mode: str  - scroll direction, top, bottom, rightmost, leftmost, up, down, left, right\n- pixel: int  - scrolling pixel\n\nReturns: None\n\n\n\n### refresh()\n\nrefresh page.\n\nReturns: None\n\n\n\n### back()\n\nThe page goes back.\n\nReturns: None\n\n\n\n### set_window_size()\n\nSet the window size, maximize by default.\n\nParameter Description:\n\n- x: int  - target width\n- y: int  - target height\n\nReturns: None\n\n\n\n### screenshot()\n\nTake a screenshot of the web page and return the path of the screenshot file\n\nParameter Description:\n\n- path: str  - The screenshot save path, the default is the temporary folder specified in the ini file\n- filename: str  - the name of the screenshot file, the default is the page title as the file name\n\nReturns: str\n\n\n\n### chrome_downloading()\n\nReturn to the list of files downloaded by the browser.\n\nParameter Description:\n\n- download_path: str  - download folder path\n\nReturns: list\n\n\n\n### process_alert()\n\nProcess the prompt box.\n\nParameter Description:\n\n- mode: str  - 'ok' or'cancel', if another value is entered, the button will not be pressed but the text value will still be returned\n- text: str  - You can enter text when processing the prompt box\n\nReturns: [str, None]  - the text of the prompt box content\n\n\n\n### close_driver()\n\nClose the driver and browser.\n\nReturns: None\n\n\n\n### close_session()\n\nClose the session.\n\nReturns: None\n\n\n\n## DriverElement class\n\n### class DriverElement()\n\nThe element object in driver mode encapsulates a WebElement object and encapsulates common functions.\n\nParameter Description:\n\n- ele: WebElement- WebElement object\n- page: DriverPage- the page object where the element is located\n- timeout: float  - Find the timeout of the element (it can be set separately each time the element is searched)\n\n\n\n### inner_ele\n\nThe wrapped WebElement object.\n\nReturns: WebElement\n\n\n\n### html\n\nReturns the outerHTML text of the element.\n\nReturns: str\n\n\n\n### inner_html\n\nReturns the innerHTML text of the element.\n\nReturns: str\n\n\n\n### tag\n\nReturns the element tag name.\n\nReturns: str\n\n\n\n### attrs\n\nReturn all attributes and values ​​of the element in a dictionary.\n\nReturns: dict\n\n\n\n### text\n\nReturns the text inside the element.\n\nReturns: str\n\n\n\n### link\n\nReturns absolute href or src value of the element.\n\nReturns: str\n\n\n\n### css_path\n\nReturns the absolute path of the element css selector.\n\nReturns: str\n\n\n\n### xpath\n\nReturns the absolute path of the element xpath.\n\nReturns: str\n\n\n\n### parent\n\nReturns the parent element object.\n\nReturns: DriverElement\n\n\n\n### next\n\nReturn the next sibling element object.\n\nReturns: DriverElement\n\n\n\n### prev\n\nReturns the previous sibling element object.\n\nReturns: DriverElement\n\n\n\n### size\n\nReturn the element size in a dictionary.\n\nReturns: dict\n\n\n\n### location\n\nReplace the element coordinates in a dictionary.\n\nReturns: dict\n\n\n\n### shadow_root\n\nReturns the shadow_root element object of the current element\n\nReturns: ShadowRoot\n\n\n\n### before\n\nReturns the content of the ::before pseudo- element of the current element\n\nReturns: str\n\n\n\n### after\n\nReturns the content of the ::after pseudo element of the current element\n\nReturns: str\n\n\n\n### texts()\n\nReturns the text of all direct child nodes within the element, including elements and text nodes\n\nParameter Description:\n\n- text_node_only: bool  - whether to return only text nodes\n\nReturns: List[str]\n\n\n\n### parents()\n\nReturns the Nth level parent element object.\n\nParameter Description:\n\n- num: int  - which level of parent element\n\nReturns: DriverElement\n\n\n\n### nexts()\n\nReturns the text of the numth sibling element or node.\n\nParameter Description:\n\n- num: int  - the next sibling element or node\n- mode: str  - 'ele','node' or'text', matching element, node, or text node\n\nReturns: [DriverElement, str]\n\n\n\n### prevs()\n\nReturns the text of the previous num sibling element or node.\n\nParameter Description:\n\n- num: int  - the previous sibling element or node\n- mode: str  - 'ele','node' or'text', matching element, node, or text node\n\nReturns: [DriverElement, str]\n\n\n\n### attr()\n\nGet the value of an attribute of an element.\n\nParameter Description:\n\n- attr: str  - attribute name\n\nReturns: str\n\n\n\n### ele()\n\nReturns the sub- elements, attributes or node texts of the current element that meet the conditions.\nIf the query parameter is a string, the options of'@attribute name:','tag:','text:','css:', and'xpath:' are available. When there is no control mode, the text mode is used to search by default.\nIf it is loc, query directly according to the content.\n\nParameter Description:\n\n- loc_or_str: [Tuple[str, str], str]  - the positioning information of the element, which can be a loc tuple or a query string\n- mode: str  - 'single' or'all', corresponding to find one or all\n- timeout: float  - Find the timeout of the element\n\nExample:\n\n- Find with loc tuple:\n\n  - ele.ele((By.CLASS_NAME,'ele_class'))  - returns the first child element whose class is ele_class\n\n- Find with query string:\n\n  Attributes, tag name and attributes, text, xpath, css selector.\n\n  Among them, @ means attribute, = means exact match,: means fuzzy match, the string is searched by default when there is no control string.\n\n  - ele.ele('@class:ele_class')  - returns the first class element that contains ele_class\n  - ele.ele('@name=ele_name')  - returns the first element whose name is equal to ele_name\n  - ele.ele('@placeholder')  - returns the first element with placeholder attribute\n  - ele.ele('tag:p')  - returns the first p element\n  - ele.ele('tag:div@class:ele_class')    - Returns the div element with ele_class in the first class\n  - ele.ele('tag:div@class=ele_class')  - returns the first div element whose class is equal to ele_class\n  - ele.ele('tag:div@text():some_text')  - returns the first div element whose text contains some_text\n  - ele.ele('tag:div@text()=some_text')    - Returns the first div element whose text is equal to some_text\n  - ele.ele('text:some_text')  - returns the first element whose text contains some_text\n  - ele.ele('some_text')  - returns the first text element containing some_text (equivalent to the previous line)\n  - ele.ele('text=some_text')  - returns the first element whose text is equal to some_text\n  - ele.ele('xpath://div[@class=\"ele_class\"]')  - Return the first element that matches xpath\n  - ele.ele('css:div.ele_class')  - returns the first element that matches the css selector\n\nReturns: [DriverElement, str]\n\n\n\n### eles()\n\nGet the list of elements that meet the conditions according to the query parameters. The query parameter usage method is the same as the ele method.\n\nParameter Description:\n\n- loc_or_str: [Tuple[str, str], str]  - query condition parameter\n- timeout: float  - Find the timeout of the element\n\nReturns: List[DriverElement or str]\n\n\n\n### get_style_property()\n\nReturns the element style attribute value.\n\nParameter Description:\n\n- style: str  - style attribute name\n- pseudo_ele: str  - pseudo element name\n\nReturns: str\n\n\n\n### click()\n\nClick on the element. If it is unsuccessful, click in js mode. You can specify whether to click in js mode.\n\nParameter Description:\n\n- by_js: bool  - whether to click with js\n\nReturns: bool\n\n\n\n### input()\n\nEnter text and return whether it is successful.\n\nParameter Description:\n\n- value: str  - text value\n- clear: bool  - whether to clear the text box before typing\n\nReturns: bool\n\n\n\n### run_script()\n\nExecute the js code and pass in yourself as the first parameter.\n\nParameter Description:\n\n- script: str  - JavaScript text\n- *args  - incoming parameters\n\nReturns: Any\n\n\n\n### submit()\n\nsubmit Form.\n\nReturns: None\n\n\n\n### clear()\n\nClear the text box.\n\nReturns: None\n\n\n\n### is_selected()\n\nWhether the element is selected.\n\nReturns: bool\n\n\n\n### is_enabled()\n\nWhether the element is available on the page.\n\nReturns: bool\n\n\n\n### is_displayed()\n\nWhether the element is visible.\n\nReturns: bool\n\n\n\n### is_valid()\n\nWhether the element is still in the DOM. This method is used to determine when the page jump element cannot be used\n\nReturns: bool\n\n\n\n### screenshot()\n\nTake a screenshot of the web page and return the path of the screenshot file\n\nParameter Description:\n\n- path: str  - The screenshot save path, the default is the temporary folder specified in the ini file\n- filename: str  - the name of the screenshot file, the default is the page title as the file name\n\nReturns: str\n\n\n\n### select()\n\nSelect from the drop- down list.\n\nParameter Description:\n\n- text: str  - option text\n\nReturns: bool  - success\n\n\n\n### set_attr()\n\nSet element attributes.\n\nParameter Description:\n\n- attr: str  - parameter name\n- value: str  - parameter value\n\nReturns: bool  - whether it was successful\n\n\n\n### drag()\n\nDrag the current element a certain distance, and return whether the drag is successful.\n\nParameter Description:\n\n- x: int  - drag distance in x direction\n- y: int  - drag distance in y direction\n- speed: int  - drag speed\n- shake: bool  - whether to shake randomly\n\nReturns: bool\n\n\n\n### drag_to()\n\nDrag the current element, the target is another element or coordinate tuple, and return whether the drag is successful.\n\nParameter Description:\n\n- ele_or_loc[tuple, WebElement, DrissionElement]  - Another element or relative current position, the coordinates are the coordinates of the element's midpoint.\n- speed: int  - drag speed\n- shake: bool  - whether to shake randomly\n\nReturns: bool\n\n\n\n### hover()\n\nHover the mouse over the element.\n\nReturns: None\n\n\n\n## SessionElement Class\n\n### class SessionElement()\n\nThe element object in session mode encapsulates an Element object and encapsulates common functions.\n\nParameter Description:\n\n- ele: HtmlElement  - HtmlElement object of lxml library\n- page: SessionPage  - the page object where the element is located\n\n\n\n### inner_ele\n\nThe wrapped HTMLElement object.\n\nReturns: HtmlElement\n\n\n\n### html\n\nReturns the outerHTML text of the element.\n\nReturns: str\n\n\n\n### inner_html\n\nReturns the innerHTML text of the element.\n\nReturns: str\n\n\n\n### tag\n\nReturns the element tag name.\n\nReturns: srt\n\n\n\n### attrs\n\nReturns the names and values of all attributes of the element in dictionary format.\n\nReturns: dict\n\n\n\n### text\n\nReturns the text within the element, namely innerText.\n\nReturns: str\n\n\n\n### link\n\nReturns absolute href or src value of the element.\n\nReturns: str\n\n\n\n### css_path\n\nReturns the absolute path of the element css selector.\n\nReturns: srt\n\n\n\n### xpath\n\nReturns the absolute path of the element xpath.\n\nReturns: srt\n\n\n\n### parent\n\nReturns the parent element object.\n\nReturns: SessionElement\n\n\n\n### next\n\nReturn the next sibling element object.\n\nReturns: SessionElement\n\n\n\n### prev\n\nReturns the previous sibling element object.\n\nReturns: SessionElement\n\n\n\n### parents()\n\nReturns the Nth level parent element object.\n\nParameter Description:\n\n- num: int  - which level of parent element\n\nReturns: SessionElement\n\n\n\n### nexts()\n\nReturns the text of the numth sibling element or node.\n\nParameter Description:\n\n- num- the next few sibling elements\n- mode: str  - 'ele','node' or'text', matching element, node, or text node\n\nReturns: [SessionElement, str]\n\n\n\n### prevs()\n\nReturn the first N sibling element objects.\n\nParameter Description:\n\n- num- the first few sibling elements\n- mode: str  - 'ele','node' or'text', matching element, node, or text node\n\nReturns: [SessionElement, str]\n\n\n\n### attr()\n\nGet the value of an attribute of an element.\n\nParameter Description:\n\n- attr: str  - attribute name\n\nReturns: str\n\n\n\n### ele()\n\nGet elements based on query parameters.\nIf the query parameter is a string, you can choose the methods of'@attribute name:','tag:','text:','css:', and'xpath:'. When there is no control mode, the text mode is used to search by default.\nIf it is loc, query directly according to the content.\n\nParameter Description:\n\n- loc_or_str:[Tuple[str, str], str]  - query condition parameter\n\n- mode: str  - Find one or more, pass in'single' or'all'\n\n\nExample:\n\n- Find with loc tuple:\n\n- ele.ele((By.CLASS_NAME,'ele_class'))  - returns the first child element whose class is ele_class\n\n- Find with query string:\n\nAttributes, tag name and attributes, text, xpath, css selector.\n\nAmong them, @ means attribute, = means exact match,: means fuzzy match, the string is searched by default when there is no control string.\n\n- ele.ele('@class:ele_class')  - return the first class element containing ele_class\n- ele.ele('@name=ele_name')  - returns the first element whose name is equal to ele_name\n- ele.ele('@placeholder')  - returns the first element with placeholder attribute\n- ele.ele('tag:p')  - return the first p element\n- ele.ele('tag:div@class:ele_class')    - Returns the div element with ele_class in the first class\n- ele.ele('tag:div@class=ele_class')  - returns the first div element whose class is equal to ele_class\n- ele.ele('tag:div@text():some_text')  - returns the first div element whose text contains some_text\n- ele.ele('tag:div@text()=some_text')    - Returns the first div element whose text is equal to some_text\n- ele.ele('text:some_text')  - returns the first element whose text contains some_text\n- ele.ele('some_text')  - returns the first element whose text contains some_text (equivalent to the previous line)\n- ele.ele('text=some_text')  - returns the first element whose text is equal to some_text\n- ele.ele('xpath://div[@class=\"ele_class\"]')    - Return the first element that matches xpath\n- ele.ele('css:div.ele_class')  - returns the first element that matches the css selector\n\nReturns: [SessionElement, str]\n\n\n\n### eles()\n\nGet the list of elements that meet the conditions according to the query parameters. The query parameter usage method is the same as the ele method.\n\nParameter Description:\n\n- loc_or_str: [Tuple[str, str], str]  - query condition parameter\n\nReturns: List[SessionElement or str]\n\n\n\n\n\n## OptionsManager class\n\n### class OptionsManager()\n\nThe class that manages the content of the configuration file.\n\nParameter Description:\n\n- path: str  - the path of the ini file, if not passed in, the configs.ini file in the current folder will be read by default\n\n\n\n### get_value()\n\nGet the configured value.\n\nParameter Description:\n\n- section: str  - section name\n- item: str  - configuration item name\n\nReturns: Any\n\n\n\n### get_option()\n\nReturn the configuration information of the entire paragraph in dictionary format.\n\nParameter Description:\n\n- section: str  - section name\n\nReturns: dict\n\n\n\n### set_item()\n\nSet the configuration value and return to yourself for chain operation.\n\nParameter Description:\n\n- section: str  - section name\n- item: str  - configuration item name\n- value: Any  - value content\n\nReturn: OptionsManager  - return to yourself\n\n\n\n### save()\n\nSave the settings to a file and return to yourself for chain operation.\n\nParameter Description:\n\n- path: str  - the path of the ini file, saved to the module folder by default\n\nReturn: OptionsManager  - return to yourself\n\n\n\n## DriverOptions class\n\n### class DriverOptions()\n\nThe Chrome browser configuration class, inherited from the Options class of selenium.webdriver.chrome.options, adds the methods of deleting configuration and saving to file.\n\nParameter Description:\n\n- read_file: bool  - Whether to read configuration information from the ini file when creating\n\n\n\n### driver_path\n\nThe path of chromedriver.exe.\n\nReturns: str\n\n\n\n### chrome_path\n\nchrome.exe path\n\nReturns: str\n\n\n\n### save()\n\nSave the settings to a file and return to yourself for chain operation.\n\nParameter Description:\n\n- path: str  - the path of the ini file, saved to the module folder by default\n\nReturn: DriverOptions  - return self\n\n\n\n### remove_argument()\n\nRemove a setting.\n\nParameter Description:\n\n- value: str  - the attribute value to be removed\n\nReturn: DriverOptions  - return self\n\n\n\n### remove_experimental_option()\n\nRemove an experiment setting and delete the key value.\n\nParameter Description:\n\n- key: str  - the key value of the experiment setting to be removed\n\nReturn: DriverOptions  - return self\n\n\n\n### remove_all_extensions()\n\nRemove all plug- ins, because plug- ins are stored in the entire file, it is difficult to remove one of them, so if you need to set, remove all and reset.\n\nReturn: DriverOptions  - return self\n\n\n\n### set_argument()\n\nSet the chrome attribute, the attribute with no value can be set to switch, and the attribute with value can set the value of the attribute.\n\nParameter Description:\n\n- arg: str  - attribute name\n- value[bool, str]  - attribute value, the attribute with value is passed in the value, and the attribute without value is passed in bool\n\nReturn: DriverOptions    - return self\n\n\n\n### set_headless()\n\nTurn on or off the interfaceless mode.\n\nParameter Description:\n\non_off: bool  - turn on or off\n\nReturn: DriverOptions  - return self\n\n\n\n### set_no_imgs()\n\nWhether to load the picture.\n\nParameter Description:\n\non_off: bool  - turn on or off\n\nReturn: DriverOptions  - return self\n\n\n\n### set_no_js()\n\nWhether to disable js.\n\nParameter Description:\n\non_off: bool  - turn on or off\n\nReturn: DriverOptions  - return self\n\n\n\n### set_mute()\n\nWhether to mute.\n\nParameter Description:\n\non_off: bool  - turn on or off\n\nReturn: DriverOptions  - return self\n\n\n\n### set_user_agent()\n\nSet the browser user agent.\n\nParameter Description:\n\n- user_agent: str  - user agent string\n\nReturn: DriverOptions    - return self\n\n\n\n### set_proxy()\n\nSet up a proxy.\n\nParameter Description:\n\n- proxy: str  - proxy address\n\nReturn: DriverOptions    - return self\n\n\n\n### set_paths()\n\nSet the path related to the browser.\n\nParameter Description:\n\n- driver_path: str  - the path of chromedriver.exe\n- chrome_path: str  - the path of chrome.exe\n- debugger_address: str  - debug browser address, for example: 127.0.0.1:9222\n- download_path: str  - download file path\n- user_data_path: str  - user data path\n- cache_path: str  - cache path\n\nReturn: DriverOptions    - return self\n\n\n\n## easy_set method\n\nChrome's configuration is too difficult to remember, so the commonly used configuration is written as a simple method, and the call will modify the relevant content of the ini file.\n\n### set_paths()\n\nConvenient way to set the path, save the incoming path to the default ini file, and check whether the chrome and chromedriver versions match.\n\nParameter Description:\n\n- driver_path: str  - chromedriver.exe path\n- chrome_path: str  - chrome.exe path\n- debugger_address: str  - debug browser address, for example: 127.0.0.1:9222\n- download_path: str  - download file path\n- global_tmp_path: str  - Temporary folder path\n- user_data_path: str  - user data path\n- cache_path: str  - cache path\n- check_version: bool  - whether to check if chromedriver and chrome match\n\nReturns: None\n\n\n\n### set_argument()\n\nSet the properties. If the attribute has no value (such as'zh_CN.UTF- 8'), value is passed in bool to indicate switch; otherwise, value is passed in str, and when value is'' or False, delete the attribute item.\n\nParameter Description:\n\n- arg:str    - Property name\n- value[bool, str]  -  Attribute value, the attribute with value is passed in the value, and the attribute without value is passed in bool\n\nReturns: None\n\n\n\n### set_headless()\n\nTurn headless mode on or off.\n\nParameter Description:\n\n- on_off: bool  -  whether to turn on headless mode\n\nReturns: None\n\n\n\n### set_no_imgs()\n\nTurn picture display on or off.\n\nParameter Description:\n\n- on_off: bool  -  Whether to turn on the no image mode\n\nReturns: None\n\n\n\n### set_no_js()\n\nTurn on or off disable JS mode.\n\nParameter Description:\n\n- on_off: bool  -  Whether to enable the disable JS mode\n\nReturns: None\n\n\n\n### set_mute()\n\nTurn on or off the silent mode.\n\nParameter Description:\n\n- on_off: bool  -  Whether to turn on silent mode\n\nReturns: None\n\n\n\n### set_user_agent()\n\nSet user_agent.\n\nParameter Description:\n\n- user_agent: str  -  user_agent value\n\nReturns: None\n\n\n\n### set_proxy()\n\nSet up a proxy.\n\nParameter Description:\n\n- proxy: str  -  proxy value\n\nReturns: None\n\n\n\n### check_driver_version()\n\nCheck if the chrome and chromedriver versions match.\n\nParameter Description:\n\n- driver_path: bool  -  chromedriver.exe path\n- chrome_path: boo  -  chrome.exe path\n\nReturns: bool\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/g1879/DrissionPage",
    "keywords": "DrissionPage",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "DrissionPage",
    "package_url": "https://pypi.org/project/DrissionPage/",
    "platform": "",
    "project_url": "https://pypi.org/project/DrissionPage/",
    "project_urls": {
      "Homepage": "https://github.com/g1879/DrissionPage"
    },
    "release_url": "https://pypi.org/project/DrissionPage/1.5.4/",
    "requires_dist": [
      "selenium",
      "lxml",
      "tldextract",
      "requests",
      "cssselect"
    ],
    "requires_python": ">=3.6",
    "summary": "A module that integrates selenium and requests session, encapsulates common page operations.",
    "version": "1.5.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17552282,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "abe2876600b7ec1bbdd04c3ad3704b6b5a65d04c1718f1e26854abf901943397",
        "md5": "8471004171b684e3ff02ce15add4b457",
        "sha256": "b4cde2df3021924ffd5aa74178b1650752f1528c3818e727bd3c3fe73c801996"
      },
      "downloads": -1,
      "filename": "DrissionPage-1.5.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "8471004171b684e3ff02ce15add4b457",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 61115,
      "upload_time": "2020-11-18T13:37:56",
      "upload_time_iso_8601": "2020-11-18T13:37:56.014268Z",
      "url": "https://files.pythonhosted.org/packages/ab/e2/876600b7ec1bbdd04c3ad3704b6b5a65d04c1718f1e26854abf901943397/DrissionPage-1.5.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2ab2ad6fa2edf426660be5b17143c838a2c2ba88a2de69ac8f128421008debab",
        "md5": "678c6b1d89e8d821db1943262f2a1522",
        "sha256": "b95107e40e420e009cbe3fe1c2645213df59e987e60fa3e8b7e9c72d5263181c"
      },
      "downloads": -1,
      "filename": "DrissionPage-1.5.4.tar.gz",
      "has_sig": false,
      "md5_digest": "678c6b1d89e8d821db1943262f2a1522",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 86214,
      "upload_time": "2020-11-18T13:37:58",
      "upload_time_iso_8601": "2020-11-18T13:37:58.276306Z",
      "url": "https://files.pythonhosted.org/packages/2a/b2/ad6fa2edf426660be5b17143c838a2c2ba88a2de69ac8f128421008debab/DrissionPage-1.5.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}