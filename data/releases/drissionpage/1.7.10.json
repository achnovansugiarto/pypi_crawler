{
  "info": {
    "author": "g1879",
    "author_email": "g1879@qq.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3.6",
      "Topic :: Utilities"
    ],
    "description": "# 简介\n\n***\n\nDrissionPage，即 driver 和 session 组合而成的 page。  \n是个基于 python 的 Web 自动化操作集成工具。  \n它实现了 selenium 和 requests 之间的无缝切换。  \n可以兼顾 selenium 的便利性和 requests 的高效率。  \n它集成了页面常用功能，两种模式系统一致的 API，使用便捷。  \n它用 POM 模式封装了页面元素常用的方法，适合自动化操作功能扩展。  \n更棒的是，它的使用方式非常简洁和人性化，代码量少，对新手友好。\n\n**项目地址：**\n\n- https://github.com/g1879/DrissionPage\n- https://gitee.com/g1879/DrissionPage\n\n**示例地址：** [使用DrissionPage的网页自动化及爬虫示例](https://gitee.com/g1879/DrissionPage-demos)\n\n**联系邮箱：**  g1879@qq.com\n\n**交流QQ群：**  897838127\n\n**理念**\n\n**简洁、易用 、可扩展**\n\n**背景**\n\nrequests 爬虫面对要登录的网站时，要分析数据包、JS 源码，构造复杂的请求，往往还要应付验证码、JS 混淆、签名参数等反爬手段，门槛较高。若数据是由 JS 计算生成的，还须重现计算过程，体验不好，开发效率不高。  \n使用 selenium，可以很大程度上绕过这些坑，但 selenium 效率不高。因此，这个库将 selenium 和 requests 合而为一，不同须要时切换相应模式，并提供一种人性化的使用方法，提高开发和运行效率。  \n除了合并两者，本库还以网页为单位封装了常用功能，简化了 selenium 的操作和语句，在用于网页自动化操作时，减少考虑细节，专注功能实现，使用更方便。  \n一切从简，尽量提供简单直接的使用方法，对新手更友好。\n\n# 特性\n\n***\n\n- 以简洁的代码为第一追求。\n- 允许在 selenium 和 requests 间无缝切换，共享 session。\n- 两种模式提供一致的 API，使用体验一致。\n- 人性化的页面元素操作方式，减轻页面分析工作量和编码量。\n- 对常用功能作了整合和优化，更符合实际使用需要。\n- 兼容 selenium 代码，便于项目迁移。\n- 使用 POM 模式封装，便于扩展。\n- 统一的文件下载方法，弥补浏览器下载的不足。\n- 简易的配置方法，摆脱繁琐的浏览器配置。\n\n# 项目结构\n\n***\n\n**结构图**\n\n![](https://gitee.com/g1879/DrissionPage-demos/raw/master/pics/20201118170751.jpg)\n\n**Drission 类**\n\n管理负责与网页通讯的 WebDriver 对象和 Session 对象，相当于驱动器的角色。\n\n**MixPage 类**\n\nMixPage 封装了页面操作的常用功能，它调用 Drission 类中管理的驱动器，对页面进行访问、操作。可在 driver 和 session 模式间切换。切换的时候会自动同步登录状态。\n\n**DriverElement 类**\n\ndriver 模式下的页面元素类，可对元素进行点击、输入文本、修改属性、运行 js 等操作，也可在其下级搜索后代元素。\n\n**SessionElement 类**\n\nsession 模式下的页面元素类，可获取元素属性值，也可在其下级搜索后代元素。\n\n# 简单演示\n\n***\n\n**与 selenium 代码对比**\n\n以下代码实现一模一样的功能，对比两者的代码量：\n\n- 用显性等待方式查找第一个文本包含 some text 的元素\n\n```python\n# 使用 selenium：\nelement = WebDriverWait(driver).until(ec.presence_of_element_located((By.XPATH, '//*[contains(text(), \"some text\")]')))\n\n# 使用 DrissionPage：\nelement = page('some text')\n```\n\n- 跳转到第一个标签页\n\n```python\n# 使用 selenium：\ndriver.switch_to.window(driver.window_handles[0])\n\n# 使用 DrissionPage：\npage.to_tab(0)\n```\n\n- 按文本选择下拉列表\n\n```python\n# 使用 selenium：\nfrom selenium.webdriver.support.select import Select\nselect_element = Select(element)\nselect_element.select_by_visible_text('text')\n\n# 使用 DrissionPage：\nelement.select('text')\n```\n\n- 拖拽一个元素\n\n```python\n# 使用 selenium：\nActionChains(driver).drag_and_drop(ele1, ele2).perform()\n\n# 使用 DrissionPage：\nele1.drag_to(ele2)\n```\n\n- 滚动窗口到底部（保持水平滚动条不变）\n\n```python\n# 使用 selenium：\ndriver.execute_script(\"window.scrollTo(document.documentElement.scrollLeft, document.body.scrollHeight);\")\n\n# 使用 DrissionPage：\npage.scroll_to('bottom')\n```\n\n- 设置 headless 模式\n\n```python\n# 使用 selenium：\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--headless\")\n\n# 使用 DrissionPage：\nset_headless()\n```\n\n- 获取伪元素内容\n\n```python\n# 使用 selenium：\ntext = webdriver.execute_script('return window.getComputedStyle(arguments[0], \"::after\").getPropertyValue(\"content\");', element)\n\n# 使用 DrissionPage：\ntext = element.after\n```\n\n- 获取 shadow-root\n\n```python\n# 使用 selenium：\nshadow_element = webdriver.execute_script('return arguments[0].shadowRoot', element)\n\n# 使用 DrissionPage：\nshadow_element = element.shadow_root\n```\n\n- 用 xpath 直接获取属性或文本节点（返回文本）\n\n```python\n# 使用 selenium：\n相当复杂\n\n# 使用 DrissionPage：\nclass_name = element('xpath://div[@id=\"div_id\"]/@class')\ntext = element('xpath://div[@id=\"div_id\"]/text()[2]')\n```\n\n**与 requests 代码对比**\n\n以下代码实现一模一样的功能，对比两者的代码量：\n\n- 获取元素内容\n\n```python\nurl = 'https://baike.baidu.com/item/python'\n\n# 使用 requests：\nfrom lxml import etree\nheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36'}\nresponse = requests.get(url, headers = headers)\nhtml = etree.HTML(response.text)\nelement = html.xpath('//h1')[0]\ntitle = element.text\n\n# 使用 DrissionPage：\npage = MixPage('s')\npage.get(url)\ntitle = page('tag:h1').text\n```\n\nTips: DrissionPage 自带默认 headers\n\n- 下载文件\n\n```python\nurl = 'https://www.baidu.com/img/flexible/logo/pc/result.png'\nsave_path = r'C:\\download'\n\n# 使用 requests：\nr = requests.get(url)\nwith open(f'{save_path}\\\\img.png', 'wb') as fd:\n   for chunk in r.iter_content():\n       fd.write(chunk)\n\n# 使用 DrissionPage：\npage.download(url, save_path, 'img')  # 支持重命名，处理文件名冲突\n```\n\n**模式切换**\n\n用 selenium 登录网站，然后切换到 requests 读取网页。两者会共享登录信息。\n\n```python\npage = MixPage()  # 创建页面对象，默认 driver 模式\npage.get('https://gitee.com/profile')  # 访问个人中心页面（未登录，重定向到登录页面）\n\npage.ele('@id:user_login').input('your_user_name')  # 使用 selenium 输入账号密码登录\npage.ele('@id:user_password').input('your_password\\n')\nsleep(1)\n\npage.change_mode()  # 切换到 session 模式\nprint('登录后title：', page.title, '\\n')  # 登录后 session 模式的输出\n```\n\n输出：\n\n```\n登录后title： 个人资料 - 码云 Gitee.com\n```\n\n**获取并打印元素属性**\n\n```python\n# 接上段代码\nfoot = page.ele('@id:footer-left')  # 用 id 查找元素\nfirst_col = foot.ele('css:>div')  # 使用 css selector 在元素的下级中查找元素（第一个）\nlnk = first_col.ele('text:命令学')  # 使用文本内容查找元素\ntext = lnk.text  # 获取元素文本\nhref = lnk.attr('href')  # 获取元素属性值\n\nprint(text, href, '\\n')\n\n# 简洁模式串联查找\ntext = page('@id:footer-left')('css:>div')('text:命令学').text\nprint(text)\n```\n\n输出：\n\n```\nGit 命令学习 https://oschina.gitee.io/learn-git-branching/\n\nGit 命令学习\n```\n\n**下载文件**\n\n```python\nurl = 'https://www.baidu.com/img/flexible/logo/pc/result.png'\nsave_path = r'C:\\download'\npage.download(url, save_path)\n```\n\n# 使用方法\n\n***\n\n## 安装及导入\n\n**安装**\n\n```\npip install DrissionPage\n```\n\n只支持 python3.6 及以上版本，driver 模式目前只支持 chrome，目前只在 Windows 环境下作了测试。  \n若要使用 driver 模式，须配置 chrome 和 **对应版本** 的 chromedriver。[[chromedriver下载]](http://npm.taobao.org/mirrors/chromedriver)  \neasy_set 工具中的 get_match_driver() 方法可自动识别 chrome 版本并下载匹配的 driver 。\n\n**导入模块**\n\n```python\nfrom DrissionPage import MixPage\n```\n\n## 初始化\n\n> 如果你只使用 session 模式，可跳过本节。\n\n使用 selenium 前，必须配置 chrome.exe 和 chromedriver.exe 的路径，并确保它们版本匹配。  \n新版本中，运行时若程序发现它们版本不匹配，会自动下载对应版本并设置路径。如无特殊须要，无须手动干预。\n\n配置路径有四种方法：\n\n- 直接运行，让程序自动完成设置（推荐）\n- 使用 easy_set 工具的 get_match_driver() 方法\n- 将路径写入本库的 ini 文件\n- 将两个路径写入系统变量\n- 在代码中填写路径\n\n**自动设置**\n\n新版本中，您无须做任何配置，只要直接运行程序，程序会获取系统中 chrome.exe 路径，并自动下载版本匹配的 chromedriver.exe。全程无感。如须自行设置所使用的 chrome.exe，可用下面的方法。\n\n**使用 get_match_driver()  方法**\n\n若你选择这种方式，请在第一次使用前，运行以下代码，程序会自动检测电脑安装的 chrome 版本，下载对应 driver，并记录到 ini 文件。\n\n```python\nfrom DrissionPage.easy_set import get_match_driver\nget_match_driver()\n```\n\n输出：\n\n```\nini文件中chrome.exe路径 D:\\Google Chrome\\Chrome\\chrome.exe \n\nversion 75.0.3770.100 \n\nchromedriver_win32.zip\nDownloading to: D:\\python\\projects\\DrissionPage\\DrissionPage\n 100% Success.\n\n解压路径 D:\\python\\projects\\chromedriver.exe \n\n正在检测可用性...\n版本匹配，可正常使用。\n```\n\n然后就可以开始使用了。\n\n若你想使用指定的 chrome.exe（绿色版），及指定 ini 文件和 chromedriver.exe 的保存路径，可以这样写：\n\n```python\nget_match_driver(ini_path='ini文件路径', save_path='保存路径', chrome_path='chrome路径')\n```\n\nTips：当指定 chrome_path 时，检测成功后程序会把这个路径写进 ini 文件。\n\n**使用 set_paths() 方法**\n\n若上一种方法失败，可自行下载 chromedriver.exe，然后运行以下代码，把路径记录到 ini 文件中。\n\n```python\nfrom DrissionPage.easy_set import set_paths\ndriver_path = 'D:\\\\chrome\\\\chromedriver.exe'  # 你的 chromedriver.exe 路径，若不填写会在系统变量中查找\nchrome_path = 'D:\\\\chrome\\\\chrome.exe'  # 你的 chrome.exe 路径，若不填写会在系统变量中查找\nset_paths(driver_path, chrome_path)\n```\n\n该方法还会检查 chrome 和 chromedriver 版本是否匹配，显示：\n\n```\n正在检测可用性...\n版本匹配，可正常使用。\n```\n\n或\n\n```\n出现异常：\nMessage: session not created: Chrome version must be between 70 and 73\n  (Driver info: chromedriver=73.0.3683.68 (47787ec04b6e38e22703e856e101e840b65afe72),platform=Windows NT 10.0.19631 x86_64)\n可执行easy_set.get_match_driver()自动下载匹配的版本。\n或自行从以下网址下载：https://chromedriver.chromium.org/downloads\n```\n\n检查通过后，即可正常使用 driver 模式。\n\n除了上述两个路径，该方法还可以设置以下路径：\n\n```python\ndebugger_address  # 调试浏览器地址，如：127.0.0.1:9222\ndownload_path  # 下载文件路径\ntmp_path  # 临时文件夹路径\nuser_data_path # 用户数据路径\ncache_path # 缓存路径\n```\n\nTips：\n\n- 不同项目可能须要不同版本的 chrome 和 chromedriver，你还可保存多个 ini 文件，按须使用。\n- 推荐使用绿色版 chrome，并手动设置路径，避免浏览器升级造成与 chromedriver 版本不匹配。\n- 调试项目时推荐设置 debugger_address，使用手动打开的浏览器，再用程序接管，好处多多。\n\n**其它方法**\n\n若你不想使用 ini 文件（如要打包项目时），可在系统路径写入以上两个路径，或在程序中填写。后者的使用方法见下一节。\n\n## Drission 对象\n\n> 创建的步骤不是必须，若想快速上手，可跳过本节。MixPage 会自动创建该对象。\n\nDrission 对象用于管理 driver 和 session 对象。在多个页面协同工作时，Drission 对象用于传递驱动器，使多个页面类可控制同一个浏览器或 Session 对象。  \n可直接读取 ini 文件配置信息创建，也可以在初始化时传入配置信息。\n\n```python\n# 由默认 ini 文件创建\ndrission = Drission()  \n\n# 由其它 ini 文件创建\ndrission = Drission(ini_path='D:\\\\settings.ini')  \n\n# 不从 ini 文件创建\ndrission = Drission(read_file=False)\n```\n\n若要手动传入配置（不使用 ini 文件）：\n\n```python\nfrom DrissionPage.config import DriverOptions\n\n# 创建 driver 配置对象，read_file = False 表示不读取 ini 文件\ndo = DriverOptions(read_file=False)  \n\n# 设置路径，若已在系统变量设置，可忽略\ndo.set_paths(chrome_path='D:\\\\chrome\\\\chrome.exe',\n             driver_path='D:\\\\chrome\\\\chromedriver.exe')  \n\n# 用于 s 模式的设置\nsession_options = {'headers': {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)'}}\n\n# 代理设置，可选\nproxy = {'http': '127.0.0.1:1080', 'https': '127.0.0.1:1080'}\n\n# 传入配置，driver_options 和 session_options 都是可选的，须要使用对应模式才须要传入\ndrission = Drission(driver_options, session_options, proxy=proxy)  \n```\n\nDriverOptions 和 SessionOptions 用法详见下文。\n\n## MixPage 对象\n\nMixPage 页面对象封装了常用的网页操作，并实现 driver 和 session 模式之间的切换。  \nMixPage 须控制一个 Drission 对象并使用其中的 driver 或 session，如没有传入，MixPage 会自己创建一个（使用传入的配置信息或从默认 ini 文件读取）。\n\nTips: 多对象协同工作时，可将一个 MixPage 中的 Drission 对象传递给另一个，使多个对象共享登录信息或操作同一个页面。\n\n**创建对象**\n\n创建对象方式有3种：简易、传入 Drission 对象、传入配置。可根据实际需要选择。\n\n```python\n# 简易创建方式，以 ini 文件默认配置自动创建 Drission 对象\npage = MixPage()\npage = MixPage('s')\n\n# 以传入 Drission 对象创建\npage = MixPage(drission)\npage = MixPage(drission, mode='s', timeout=5)  # session 模式，等待时间5秒（默认10秒）\n\n# 传入配置信息，MixPage 根据配置在内部创建 Drission\npage = MixPage(driver_options=do, session_options=so)  # 默认 d 模式\n```\n\n**访问网页**\n\n```python\n# 默认方式\npage.get(url)\npage.post(url, data, **kwargs)  # 只有 session 模式才有 post 方法\n\n# 指定重试次数和间隔\npage.get(url, retry=5, interval=0.5)\n```\n\nTips：若连接出错，程序会自动重试2次，可指定重试次数和等待间隔。\n\n**切换模式**\n\n在 s 和 d 模式之间切换，切换时会自动同步 cookies 和正在访问的 url。\n\n```python\npage.change_mode(go=False)  # go 为 False 表示不跳转 url\n```\n\nTips：使用某种模式独有的方法时会自动跳转到该模式。\n\n**页面属性**\n\n```python\npage.url  # 当前访问的 url\npage.mode  # 当前模式\npage.drission  # 当前使用的 Dirssion 对象\npage.driver  # 当前使用的 WebDirver 对象\npage.session  # 当前使用的 Session 对象\npage.cookies  # 获取 cookies 信息\npage.html  # 页面源代码\npage.title  # 当前页面标题\n\n# d 模式独有：\npage.tabs_count  # 返回标签页数量\npage.tab_handles  # 返回所有标签页 handle 列表\npage.current_tab_num  # 返回当前标签页序号\npage.current_tab_handle  # 返回当前标签页 handle\n```\n\n**页面操作**\n\n调用只属于 d 模式的方法，会自动切换到 d 模式。详细用法见 APIs。\n\n```python\npage.set_cookies()  # 设置cookies\npage.get_cookies()  # 获取 cookies，可以 list 或 dict 方式返回\npage.change_mode()  # 切换模式，会自动复制 cookies\npage.cookies_to_session()  # 从 WebDriver 对象复制 cookies 到 Session 对象\npage.cookies_to_driver()  # 从 Session 对象复制 cookies 到 WebDriver 对象\npage.get(url, retry, interval, **kwargs)  # 用 get 方式访问网页，可指定重试次数及间隔时间\npage.ele(loc_or_ele, timeout)  # 获取符合条件的第一个元素、节点或属性\npage.eles(loc_or_ele, timeout)  # 获取所有符合条件的元素、节点或属性\npage.download(url, save_path, rename, file_exists, **kwargs)  # 下载文件\npage.close_driver()  # 关闭 WebDriver 对象\npage.close_session()  # 关闭 Session 对象\n\n# s 模式独有：\npage.post(url, data, retry, interval, **kwargs)  # 以 post 方式访问网页，可指定重试次数及间隔时间\n\n# d 模式独有：\npage.wait_ele(loc_or_ele, mode, timeout)  # 等待元素从 dom 删除、显示、隐藏\npage.run_script(js, *args)  # 运行 js 语句\npage.create_tab(url)  # 新建并定位到一个标签页,该标签页在最后面\npage.to_tab(num_or_handle)  # 跳转到标签页\npage.close_current_tab()  # 关闭当前标签页\npage.close_other_tabs(num_or_handles)  # 关闭其它标签页\npage.to_iframe(iframe)  # 切入 iframe\npage.screenshot(path)  # 页面截图\npage.scroll_to_see(element)  # 滚动直到某元素可见\npage.scroll_to(mode, pixel)  # 按参数指示方式滚动页面，可选滚动方向：'top', 'bottom', 'rightmost', 'leftmost', 'up', 'down', 'left', 'right'\npage.refresh()  # 刷新当前页面\npage.back()  # 浏览器后退\npage.et_window_size(x, y)  # 设置浏览器窗口大小，默认最大化\npage.check_page()  # 检测页面是否符合预期\npage.chrome_downloading()  # 获取 chrome 正在下载的文件列表\npage.process_alert(mode, text)  # 处理提示框\n```\n\n**cookies 的使用**\n\nMixPage 支持获取和设置 cookies，具体使用方法如下：\n\n```python\npage.cookies  # 以字典形式返回 cookies，只会返回当前域名可用的 cookies\npage.get_cookies(as_dict=False)  # 以列表形式返回当前域名可用 cookies，每个 cookie 包含所有详细信息\npage.get_cookies(all_domains=True)  # 以列表形式返回所有 cookies，只有 s 模式有效\npage.set_cookies(cookies)  # 设置 cookies，可传入 RequestsCookieJar, list, tuple, str, dict\n```\n\nTips:\n\n- d 模式设置 cookies 后要刷新页面才能看到效果。\n- s 模式可在 ini 文件、SessionOptions、配置字典中设置 cookies，在 MixPage 初始化时即可传入，d 模式只能用 set_cookies() 函数设置。\n\n## 查找元素\n\nele() 返回第一个符合条件的元素，eles() 返回所有符合条件的元素列表。  \n你可在页面对象或元素对象下使用这两个函数，以查找下级元素。\n\npage.eles() 和 element.eles() 查找返回符合条件的所有元素列表。\n\n说明：\n\n- 元素查找超时默认为10秒，超时或找到元素时停止等待，你也可以按需要设置。\n- 下面的查找语句中，冒号 : 表示模糊匹配，等号 = 表示精确匹配\n- 可用查询字符串或 selenium 原生的 loc 元组（s 模式也能用）查找元素\n- 查询字符串有 @属性名、tag、text、xpath、css、.、# 等7种方法\n\n```python\n# 根据属性查找，@ 后面可跟任意属性\npage.ele('@id:ele_id', timeout=2)  # 查找 id 为 ele_id 的元素，设置等待时间2秒  \npage.eles('@class')  # 查找所有拥有 class 属性的元素\npage.eles('@class:class_name')  # 查找所有 class 含有 ele_class 的元素 \npage.eles('@class=class_name')  # 查找所有 class 等于 ele_class 的元素 \n\n# 根据 class 或 id 查找\npage.ele('#ele_id')  # 等价于 page.ele('@id=ele_id')\npage.ele('#:ele_id')  # 等价于 page.ele('@id:ele_id')\npage.ele('.ele_class')  # 等价于 page.ele('@class=ele_class')\npage.ele('.:ele_class')  # 等价于 page.ele('@class:ele_class')\n\n# 根据 tag name 查找\npage.ele('tag:li')  # 查找第一个 li 元素  \npage.eles('tag:li')  # 查找所有 li 元素  \n\n# 根据 tag name 及属性查找\npage.ele('tag:div@class=div_class')  # 查找 class 为 div_class 的 div 元素\npage.ele('tag:div@class:ele_class')  # 查找 class 含有 ele_class 的 div 元素\npage.ele('tag:div@class=ele_class')  # 查找 class 等于 ele_class 的 div 元素\npage.ele('tag:div@text():search_text')  # 查找文本含有 search_text 的 div 元素\npage.ele('tag:div@text()=search_text')  # 查找文本等于 search_text 的 div 元素\n\n# 根据文本内容查找\npage.ele('search text')  # 查找包含传入文本的元素  \npage.eles('text:search text')  # 如文本以 @、tag:、css:、xpath:、text: 开头，则应在前加上 text: 避免冲突  \npage.eles('text=search text')  # 文本等于 search_text 的元素\n\n# 根据 xpath 或 css selector 查找\npage.eles('xpath://div[@class=\"ele_class\"]')\npage.eles('css:div.ele_class')\n\n# 根据 loc 查找\nloc1 = By.ID, 'ele_id'\nloc2 = By.XPATH, '//div[@class=\"ele_class\"]'\npage.ele(loc1)\npage.ele(loc2)\n\n# 查找下级元素\nelement = page.ele('@id:ele_id')\nelement.ele('@class:class_name')  # 在 element 下级查找第一个 class 为 ele_class 的元素\nelement.eles('tag:li')  # 在 ele_id 下级查找所有li元素\n\n# 根据位置查找\nelement.parent  # 父元素  \nelement.next  # 下一个兄弟元素  \nelement.prev  # 上一个兄弟元素  \n\n# 获取 shadow-root，把它作为元素对待。只支持 open 的 shadow-root\nele1 = element.shadow_root.ele('tag:div')\n\n# 串连查找\npage.ele('@id:ele_id').ele('tag:div').next.ele('some text').eles('tag:a')\n\n# 简化写法\neles = page('@id:ele_id')('tag:div').next('some text').eles('tag:a')\nele2 = ele1('tag:li').next('some text')\n```\n\n## 获取元素属性\n\n```python\nelement.html  # 返回元素 outerHTML\nelement.inner_html  # 返回元素 innerHTML\nelement.tag  # 返回元素 tag name\nelement.text  # 返回元素 innerText 值\nelement.link  # 返回元素 href 或 src 绝对 url\nelement.texts()  # 返回元素内所有直接子节点的文本，包括元素和文本节点，可指定只返回文本节点\nelement.attrs  # 返回元素所有属性的字典\nelement.attr(attr)  # 返回元素指定属性的值\nelement.css_path  # 返回元素绝对 css 路径\nelement.xpath  # 返回元素绝对 xpath 路径\nelement.parent  # 返回元素父元素\nelement.next  # 返回元素后一个兄弟元素\nelement.prev  # 返回元素前一个兄弟元素\nelement.parents(num)  # 返回第 num 级父元素\nelement.nexts(num, mode)  # 返回后面第几个元素或节点\nelement.prevs(num, mode)  # 返回前面第几个元素或节点\nelement.ele(loc_or_str, timeout)  # 返回当前元素下级第一个符合条件的子元素、属性或节点文本\nelement.eles(loc_or_str, timeout)  # 返回当前元素下级所有符合条件的子元素、属性或节点文本\n\n# d 模式独有：\nelement.before  # 获取伪元素 before 内容\nelement.after  # 获取伪元素 after 内容\nelement.is_valid  # 用于判断元素是否还在dom中\nelement.size  # 获取元素大小\nelement.location  # 获取元素位置\nelement.shadow_root  # 获取元素下的 ShadowRoot 元素\nelement.get_style_property(style, pseudo_ele)  # 获取元素样式属性值，可获取伪元素的\nelement.is_selected()  # 返回元素是否被选中\nelement.is_enabled()  # 返回元素是否可用\nelement.is_displayed()  # 返回元素是否可见\n```\n\n## 元素操作\n\n元素操作为 d 模式独有，调用以下方法会自动切换到 d 模式。\n\n```python\nelement.click(by_js)  # 点击元素，可选择是否用 js 方式点击\nelement.input(value)  # 输入文本\nelement.run_script(js)  # 对元素运行 JavaScript 脚本\nelement.submit()  # 提交\nelement.clear()  # 清空元素\nelement.screenshot(path, filename)  # 对元素截图\nelement.select(text)  # 根据文本选择下拉列表\nelement.set_attr(attr, value)  # 设置元素属性值\nelement.remove_attr(attr)  # 删除属性\nelement.drag(x, y, speed, shake)  # 拖动元素相对距离，可设置速度和是否随机抖动\nelement.drag_to(ele_or_loc, speed, shake)  # 拖动元素到另一个元素或某个坐标，可设置速度和是否随机抖动\nelement.hover()  # 在元素上悬停鼠标\n```\n\n## shadow-dom 操作\n\nd 模式独有，支持获取 shadow-root 及内部元素，获取到的 shadow-root 元素类型为 ShadowRootElement，用法和正常元素类似，但功能有所简化。\n\n**注意：**\n\n- 只能获取 open 的 shadow-root\n- 查找 shadow-root 内部元素不能使用 xpath 方式\n\n获取依附在普通元素内的 shadow-root 元素\n```python\nshadow_root_element = element.shadow_root  # element 为含有 shadow-root 的普通元素\n```\n\n属性及方法\n\n```python\nshadow_root_element.tag  # 返回 'shadow-root'\nshadow_root_element.html  # html 内容\nshadow_root_element.parent  # 父元素\nshadow_root_element.next  # 下一个兄弟元素\n\nshadow_root_element.parents(num)  # 获取向上 num 级父元素\nshadow_root_element.nexts(num)  # 获取向后 num 个兄弟元素\nshadow_root_element.ele(loc_or_str)  # 获取第一个符合条件的内部元素\nshadow_root_element.eles(loc_or_str)  # 获取全部符合条件的内部元素\nshadow_root_element.run_scrpit(js_text)  # 运行 js 脚本\nshadow_root_element.is_enabled()  # 返回元素是否可用\nshadow_root_element.is_valid()  # 返回元素是否还在 dom 内\n```\n\n**Tips:** 以上属性或方法获取到的元素是普通的 DriverElement，用法参考上文所述。\n\n## 对接 selenium 及 requests\n\nDrissionPage 代码可与 selenium 及 requests 代码无缝拼接。既可直接使用 selenium 的 WebDriver 对象，也可导出自身的 WebDriver 给 selenium 代码使用。requests 的\nSession 对象也可直接传递。使已有项目的迁移非常方便。\n\n**selenium 转 DrissionPage**\n\n```python\ndriver = webdriver.Chrome()\ndriver.get('https://www.baidu.com')\n\npage = MixPage(Drission(driver))  # 把 driver 传递给 Drission，创建 MixPage 对象\nprint(page.title)  # 打印结果：百度一下，你就知道\n```\n\n**DrissionPage 转 selenium**\n\n```python\npage = MixPage()\npage.get('https://www.baidu.com')\n\ndriver = page.driver  # 从 MixPage 对象中获取 WebDriver 对象\nprint(driver.title)  # 打印结果：百度一下，你就知道\nelement = driver.find_element_by_xpath('//div')  # 使用 selenium 原生功能\n```\n\n**requests 转 DrissionPage**\n\n``` python\nsession = requets.Session()\ndrission = Drission(session_or_options=session)\npage = MixPage(drission, mode='s')\n\npage.get('https://www.baidu.com')\n```\n\n**DrissionPage 转 requests**\n\n```python\npage = MixPage('s')\nsession = page.session\n\nresponse = session.get('https://www.baidu.com')\n```\n\n## requests 功能使用\n\n**连接参数**\n\n除了在创建时传入配置信息及连接参数，如有必要，s 模式下也可在每次访问网址时设置连接参数。\n\n```python\nheaders = {'User-Agent': '......', }\ncookies = {'name': 'value', }\nproxies = {'http': '127.0.0.1:1080', 'https': '127.0.0.1:1080'}\npage.get(url, headers=headers, cookies=cookies, proxies=proxies)\n```\n\nTips：\n\n- 如果连接参数内没有指定，s 模式会根据当前域名自动填写 Host 和 Referer 属性\n- 在创建 MixPage 时传入的 Session 配置是全局有效的\n\n**Response 对象**\n\nrequests 获取到的 Response 对象存放在 page.response，可直接使用。如：\n\n```python\nprint(page.response.status_code)\nprint(page.response.headers)\n```\n\n## 下载文件\n\nselenium 缺乏对浏览器下载文件的有效管理，难以进行检测下载状态、重命名、失败管理。  \n使用 requests 下载文件能较好实现以上功能，但代码较为繁琐。  \n因此 DrissionPage 封装了 download 方法，整合了两者优点，可从 selenium 获取登录信息，用 requests 进行下载。  \n弥补了 selenium 的不足，使下载简洁高效。\n\n**功能**\n\n- 指定下载路径\n- 重命名文件，可不填写扩展名，程序自动补充\n- 存在同名文件时，可选择重命名、覆盖、跳过等处理方式\n- 显示下载进度\n- 支持 post 方式\n- 支持自定义连接参数\n\n**演示**\n\n```python\nurl = 'https://www.baidu.com/img/flexible/logo/pc/result.png'  # 文件 url\nsave_path = r'C:\\download'  # 存放路径\n\n# 重命名为img.png，存在重名时自动在文件名末尾加上序号，显示下载进度\npage.download(url, save_path, 'img', 'rename', show_msg=True)\n```\n\n## Chrome 设置\n\nchrome 的配置很繁琐，为简化使用，本库提供了常用配置的设置方法。\n\n**DriverOptions 对象**\n\nDriverOptions 对象继承自 selenium.webdriver.chrome.options 的 Options 对象，在其基础上增加了以下方法：\n\n```python\noptions.remove_argument(value)  # 删除某 argument 值\noptions.remove_experimental_option(key)  # 删除某 experimental_option 设置\noptions.remove_all_extensions()  # 删除全部插件\noptions.save()  # 保存当前打开的 ini 文件\noptions.save('D:\\\\settings.ini')  # 保存到指定路径 ini 文件\noptions.save('default')  # 保存当前设置到默认 ini 文件\noptions.set_argument(arg, value)  # 设置 argument 属性\noptions.set_headless(on_off)  # 设置是否使用无界面模式\noptions.set_no_imgs(on_off)  # 设置是否加载图片\noptions.set_no_js(on_off)  # 设置是否禁用 js\noptions.set_mute(on_off)  # 设置是否静音\noptions.set_user_agent(user_agent)  # 设置 user agent\noptions.set_proxy(proxy)  # 设置代理地址\noptions.set_paths(driver_path, chrome_path, debugger_address, download_path, user_data_path, cache_path)  # 设置浏览器相关的路径\n```\n\n**使用方法**\n\n```python\ndo = DriverOptions()  # 读取默认 ini 文件创建 DriverOptions 对象\ndo = DriverOptions('D:\\\\settings.ini')  # 读取指定 ini 文件创建 DriverOptions 对象\ndo = DriverOptions(read_file=False)  # 不读取 ini 文件，创建空的 DriverOptions 对象\n\ndo.set_headless(False)  # 显示浏览器界面\ndo.set_no_imgs(True)  # 不加载图片\ndo.set_paths(driver_path='D:\\\\chromedriver.exe', chrome_path='D:\\\\chrome.exe')  # 设置路径\ndo.set_headless(False).set_no_imgs(True)  # 支持链式操作\n\ndrission = Drission(driver_options=do)  # 用配置对象创建 Drission 对象\npage = MixPage(driver_options=do)  # 用配置对象创建 MixPage 对象\n\ndo.save()  # 保存当前打开的 ini 文件\ndo.save('D:\\\\settings.ini')  # 保存到指定的 ini 文件\ndo.save('default')  # 保存当前设置到默认 ini 文件\n```\n\n## Session 设置\n\n**SessionOPtions 对象**\n\nSessionOptions 对象用于管理 Session 的配置信息。它创建时默认读取默认 ini 文件配置信息，也可手动设置所需信息。\n\n可配置的属性：\n\nheaders、cookies、auth、proxies、hooks、params、verify、cert、adapters、stream、trust_env、max_redirects。\n\n**Tips:** cookies 可接收 dict、list、tuple、str、RequestsCookieJar 等格式的信息。\n\n**使用方法**\n\n```python\nso = SessionOptions()  # 读取默认 ini 文件创建 SessionOptions 对象\nso = SessionOptions('D:\\\\settings.ini')  # 读取指定 ini 文件创建 SessionOptions 对象\nso = SessionOptions(read_file=False)  # 不读取 ini 文件，创建空的 SessionOptions 对象\n\nso.cookies = ['key1=val1; domain=xxxx', 'key2=val2; domain=xxxx']  # 设置 cookies\nso.headers = {'User-Agent': 'xxxx', 'Accept-Charset': 'xxxx'}\nso.set_a_header('Connection', 'keep-alive')\n\ndrission = Drission(session_options=so)  # 用配置对象创建 Drission 对象\npage = MixPage(session_options=so)  # 用配置对象创建 MixPage 对象\n\nso.save()  # 保存当前打开的 ini 文件\nso.save('D:\\\\settings.ini')  # 保存到指定的 ini 文件\nso.save('default')  # 保存当前设置到默认 ini 文件\n```\n\n## 保存配置\n\n因 chrome 和 headers 配置繁多，故设置一个 ini 文件专门用于保存常用配置，你可使用 OptionsManager 对象获取和保存配置，用 DriverOptions 对象修改 chrome 配置。你也可以保存多个 ini\n文件，按不同项目须要调用。\n\nTips：建议把常用配置文件保存到别的路径，以防本库升级时配置被重置。\n\n**ini 文件内容**\n\nini 文件默认拥有三部分配置：paths、chrome_options、session_options，初始内容如下。\n\n```ini\n[paths]\n; chromedriver.exe路径\nchromedriver_path =\n; 临时文件夹路径，用于保存截图、文件下载等\ntmp_path =\n\n[chrome_options]\n; 已打开的浏览器地址和端口，如127.0.0.1:9222\ndebugger_address =\n; chrome.exe路径\nbinary_location =\n; 配置信息\narguments = [\n            ; 静音\n            '--mute-audio',\n            ; 不使用沙盒\n            '--no-sandbox',\n            ; 谷歌文档提到需要加上这个属性来规避bug\n            '--disable-gpu',\n            ; 忽略警告\n            'ignore-certificate-errors',\n            ; 不显示信息栏\n            '--disable-infobars'\n            ]\n; 插件\nextensions = []\n; 实验性配置\nexperimental_options = {\n                       'prefs': {\n                       ; 下载不弹出窗口\n                       'profile.default_content_settings.popups': 0,\n                       ; 无弹窗\n                       'profile.default_content_setting_values': {'notifications': 2},\n                       ; 禁用PDF插件\n                       'plugins.plugins_list': [{\"enabled\": False, \"name\": \"Chrome PDF Viewer\"}]\n                       },\n                       ; 设置为开发者模式，防反爬虫\n                       'excludeSwitches': [\"enable-automation\"],\n                       'useAutomationExtension': False\n                       }\n\n[session_options]\nheaders = {\n          \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8\",\n          \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n          \"Connection\": \"keep-alive\",\n          \"Accept-Charset\": \"utf-8;q=0.7,*;q=0.7\"\n          }\n```\n\n**OptionsManager 对象**\n\nOptionsManager 对象用于读取、设置和保存配置。\n\n```python\nmanager.paths  # 以字典形式返回路径设置\nmanager.chrome_options  # 以字典形式返回chrome设置\nmanager.session_options  # 以字典形式返回session设置\nmanager.get_value(section, item)  # 获取某个配置的值\nmanager.get_option(section)  # 以字典格式返回配置全部属性\nmanager.set_item(section, item, value)  # 设置配置属性\nmanager.manager.save()  # 保存当前打开的 ini 文件\nmanager.save('D:\\\\settings.ini')  # 保存到指定路径 ini 文件\nmanager.save('default')  # 保存当前设置到默认 ini 文件\n```\n\n**使用示例**\n\n```python\nfrom DrissionPage.configs import *\n\noptions_manager = OptionsManager()  # 从默认ini文件创建OptionsManager对象\noptions_manager = OptionsManager('D:\\\\settings.ini')  # 从其它ini文件创建OptionsManager对象\ndriver_path = options_manager.get_value('paths', 'chromedriver_path')  # 读取路径信息\noptions_manager.save()  # 保存当前打开的 ini 文件\noptions_manager.save('D:\\\\settings.ini')  # 保存到指定路径 ini 文件\n\ndrission = Drission(ini_path='D:\\\\settings.ini')  # 使用指定 ini 文件创建对象\n```\n\n## easy_set 方法\n\n可快速地修改常用设置的方法。全部用于 driver 模式的设置。调用 easy_set 方法会修改默认 ini 文件相关内容。\n\n```python\nget_match_driver()  # 识别chrome版本并自动下载匹配的chromedriver.exe\nshow_settings()  # 打印所有设置\nset_headless(True)  # 开启 headless 模式\nset_no_imgs(True)  # 开启无图模式\nset_no_js(True)  # 禁用 JS\nset_mute(True)  # 开启静音模式\nset_user_agent('Mozilla/5.0 (Macintosh; Int......')  # 设置 user agent\nset_proxy('127.0.0.1:8888')  # 设置代理\nset_paths(paths)  # 见 [初始化] 一节\nset_argument(arg, value)  # 设置属性，若属性无值（如'zh_CN.UTF-8'），value 为 bool 表示开关；否则value为str，当 value为''或 False，删除该属性项\ncheck_driver_version()  # 检查chrome和chromedriver版本是否匹配\n```\n\n## POM 模式\n\nMixPage 封装了常用的页面操作，可方便地用于扩展。\n\n例：扩展一个列表页面读取类\n\n```python\nimport re\nfrom time import sleep\nfrom DrissionPage import *\n\nclass ListPage(MixPage):\n    \"\"\"本类封装读取列表页面的方法，根据必须的4个元素，可读取同构的列表页面\n    （中文变量真香）\"\"\"\n    def __init__(self, drission: Drission, url: str = None, **xpaths):\n        super().__init__(drission)\n        self._url = url\n        self.xpath_栏目名 = xpaths['栏目名']  # [xpath字符串, 正则表达式]\n        self.xpath_下一页 = xpaths['下一页']\n        self.xpath_行s = xpaths['行']\n        self.xpath_页数 = xpaths['页数']  # [xpath字符串, 正则表达式]\n        self.总页数 = self.get_总页数()\n        if url:\n            self.get(url)\n\n    def get_栏目名称(self) -> str:\n        if self.xpath_栏目名[1]:\n            s = self.ele(f'xpath:{self.xpath_栏目名[0]}').text\n            r = re.search(self.xpath_栏目名[1], s)\n            return r.group(1)\n        else:\n            return self.ele(f'xpath:{self.xpath_栏目名[0]}').text\n\n    def get_总页数(self) -> int:\n        if self.xpath_页数[1]:\n            s = self.ele(f'xpath:{self.xpath_页数[0]}').text\n            r = re.search(self.xpath_页数[1], s)\n            return int(r.group(1))\n        else:\n            return int(self.ele(f'xpath:{self.xpath_页数[0]}').text)\n\n    def click_下一页(self, wait: float = None):\n        self.ele(f'xpath:{self.xpath_下一页}').click()\n        if wait:\n            sleep(wait)\n\n    def get_当前页列表(self, 待爬内容: list) -> list:\n        \"\"\"\n        待爬内容格式：[[xpath1,参数1],[xpath2,参数2]...]\n        返回列表格式：[[参数1,参数2...],[参数1,参数2...]...]\n        \"\"\"\n        结果列表 = []\n        行s = self.eles(f'xpath:{self.xpath_行s}')\n        for 行 in 行s:\n            行结果 = []\n            for j in 待爬内容:\n                行结果.append(行.ele(f'xpath:{j[0]}').attr(j[1]))\n            结果列表.append(行结果)\n            print(行结果)\n        return 结果列表\n\n    def get_列表(self, 待爬内容: list,  wait: float = None) -> list:\n        列表 = self.get_当前页列表(待爬内容)\n        for _ in range(self.总页数 - 1):\n            self.click_下一页(wait)\n            列表.extend(self.get_当前页列表(待爬内容))\n        return 列表\n```\n\n## DriverPage 和 SessionPage\n\n如果无须切换模式，可根据需要只使用 DriverPage 或 SessionPage，用法和 MixPage 一致。\n\n```python\nfrom DrissionPage.session_page import SessionPage\nfrom DrissionPage.drission import Drission\n\nsession = Drission().session\npage = SessionPage(session)  # 传入 Session 对象\npage.get('http://www.baidu.com')\nprint(page.ele('@id:su').text)  # 输出：百度一下\n\ndriver = Drission().driver\npage = DriverPage(driver)  # 传入 Driver 对象\npage.get('http://www.baidu.com')\nprint(page.ele('@id:su').text)  # 输出：百度一下\n```\n\n# 版本历史\n\n***\n\n请在 Wiki中查看：[点击查看版本历史](https://gitee.com/g1879/DrissionPage/wikis/%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2?sort_id=3201403)\n\n# APIs\n\n***\n\n请在 Wiki中查看：[点击查看APIs](https://gitee.com/g1879/DrissionPage/wikis/Drission%20%E7%B1%BB?sort_id=3159323)\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/g1879/DrissionPage",
    "keywords": "DrissionPage",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "DrissionPage",
    "package_url": "https://pypi.org/project/DrissionPage/",
    "platform": "",
    "project_url": "https://pypi.org/project/DrissionPage/",
    "project_urls": {
      "Homepage": "https://github.com/g1879/DrissionPage"
    },
    "release_url": "https://pypi.org/project/DrissionPage/1.7.10/",
    "requires_dist": [
      "selenium",
      "lxml",
      "tldextract",
      "requests"
    ],
    "requires_python": ">=3.6",
    "summary": "A module that integrates selenium and requests session, encapsulates common page operations.",
    "version": "1.7.10",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17552282,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "30f571b4387874e38866b8cc31f8e59edc745cbeb55d1ebf4d4f21280160b1eb",
        "md5": "2757b60fa34a94c764c7c8bdd81c761c",
        "sha256": "5b24f45eab71efd3f480cbcf1d49bc6af310af11a02a544249190997ae25f79b"
      },
      "downloads": -1,
      "filename": "DrissionPage-1.7.10-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2757b60fa34a94c764c7c8bdd81c761c",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 64419,
      "upload_time": "2020-12-28T07:09:55",
      "upload_time_iso_8601": "2020-12-28T07:09:55.703238Z",
      "url": "https://files.pythonhosted.org/packages/30/f5/71b4387874e38866b8cc31f8e59edc745cbeb55d1ebf4d4f21280160b1eb/DrissionPage-1.7.10-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4bb3fe72a2375f76051c23f23c50af2b75ae4f9bcf371a09ecdbaf49137dea93",
        "md5": "7628d051d33034467e4b46ce69584e1b",
        "sha256": "4b37d2c5ba47d1dea934a1dcd3574de55e03d89bad4c70cf51faeb2a84123ca2"
      },
      "downloads": -1,
      "filename": "DrissionPage-1.7.10.tar.gz",
      "has_sig": false,
      "md5_digest": "7628d051d33034467e4b46ce69584e1b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 81021,
      "upload_time": "2020-12-28T07:09:57",
      "upload_time_iso_8601": "2020-12-28T07:09:57.954151Z",
      "url": "https://files.pythonhosted.org/packages/4b/b3/fe72a2375f76051c23f23c50af2b75ae4f9bcf371a09ecdbaf49137dea93/DrissionPage-1.7.10.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}