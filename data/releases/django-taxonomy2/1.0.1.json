{
  "info": {
    "author": "robert crowther",
    "author_email": "rw.crowther@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Django Taxonomy\n> :warning: **Due to a name clash** This code is in Python repositories named as \"django-taxonomy2\".\n\nCreate categories in a tree structure.\n\nThis app is called 'django-taxonomy', but internally the module is called 'taxonomy'.\n\n## Alternatives\n\n- [django-packages](https://github.com/callowayproject/django-categories)\n    This project is mature with many commits. It uses an MPTT implementation.\n\n- [django-treebeard](https://github.com/django-treebeard/django-treebeard)\n    Django Treebeard is mature, has multiple tree implementations, an API, and AJAX Admin. It's a legendary Django package. It can do everything this package can do and much more.\n\n- [django-modelcluster](https://github.com/wagtail/django-modelcluster)\n    This is a chunk of the Wagtail CMS. It allows you to join model objects together, even as they are created, then save in a chunk. Not quite the same thing as a taxonomy, but it does define relations between models, so if you are looking for that, it may be a fit.\n\n- [django-taxonomy](https://pypi.org/project/django_taxonomy/#files)\n    Still there as a package. Looks like it was intended as a Drupal port, long ago.\n\n- [django-treenav](https://djangopackages.org/packages/p/django-treenav/)\n    Makes interesting reading what is in it, but not sure what it is. I think it may do what this does? Not investigated too far.\n\n \n## Why you may or may not want this app\nPro\n- It's simple\n- Nodes (Categories) can be customised\n- It's got displays and Admin builtin \n- Comprehensive and acessible API\n\nCon\n- No multi-parent (node map) option\n- Poor at finding descendant elements, so poor the functionality has not been implemented\n- For 500 lines of code, a lot of README\n- tests [Ummm](#tests)\n\nIf you want the standard, get [TreeBeard](https://github.com/django-treebeard/django-treebeard). If you are building a shopping site, you want an MPTT or maybe Treebeard's PathTree implementation. This is not that app.\n\nThis app has only one (non)feature over the heavyweights. It is simple. \nIt has no dependencies. It has only 500 (or near) lines of core code. It has a bone-simple SQL layout, you can fix it with 'dbshell'. If you don't need the weight, but want to catalogue some uploads, or gather pages on a website, you may prefer this.\n\nI know it's unprofessional to think of performance, but I tried creating 30,000 categories on an old laptop with an SQLite DB. Slow changes but reading fast. Of course, the displays fell to pieces.\n\n## Overview\nThe app is called Taxonomy, because that's what it is, a vocabulary of terms. You might think of that as a tree of categories. However, I've used the common Python/Django word 'Node' for the categories.\n\nTo make a tree of categories, Taxonomy has a model 'AbstractNode'. You subclass 'AbstractNode' to make a new Model. One Model/database table = one tree. \n\n'AbstractNode' can be extended with whatever data you want. So a Node (category) can be customised with descriptions, SEO material, external reference numbers, whatever you need to reference and present your material.\n\n'Node' is not a good name for end users. Whenever end users are concerned, I'd use the word 'category'. Even in the application help I use the word 'Category'.\n\nAny Node/Category can have Elements attached. An Element is any Django Model instance. The join is usually through a Foreign key.\n\n\n## If you have done this before\n- Install\n- Declare a taxonomy\n- [Add an Admin](#Admin)\n\nI think that's all. Use the [API](#the-api) to access the taxonomy, and foreign keys to [add objects](#attaching-objects).\n\n\n## Install\nPyPi,\n\n    pip install django-taxonomy2\n\nOr download the app code to Django.\n\nDeclare in Django settings,\n\n        INSTALLED_APPS = [\n            ...\n            'taxonomy.apps.TaxonomyConfig',\n            ...\n        ]\n\nThere will be migrations, but not for the app. That comes after you have declared a tree. See next section.\n\n\n## Creating a Taxonomy\nOften, a taxonomy is associated with one model/object. In which case, you can create the taxonomy in the model for the app. If you use [Multiple Models](#multiple-models) it may be better to create the taxonomy in a freestanding app e.g.\n\n    /manage.py startapp sitecategory\n\nand install. Either way, here is an example of a model declaration. This adds a 'description' field, so the taxonomy can be used for more helpful user display. It also includes a 'slug' field, so the category titles can be used in URLs. That means the model has a get_absolute_url() method too (see below),\n        \n    from django.db import models\n    from django.urls import reverse\n    from taxonomy.models import AbstractNode, AbstractNodeParent\n    from taxonomy.api import NodeTreeAPI\n\n\n\n    class SiteCategory(AbstractNode):\n\n        # Not unique. Node names may be duplicated at different places in a \n        # hierarchy e.g. 'sports>news', 'local>news'. but it may save later\n        # trouble to make them unique...\n        slug = models.SlugField(\n            max_length=64,\n            help_text=\"Short name for use in urls.\",\n        )\n      \n        description = models.CharField(\n            max_length=255,\n            blank=True,\n            default='',\n            help_text=\"Description of the category. Limited to 255 characters.\",\n        )\n          \n        def get_absolute_url(self):\n            return reverse(\"category_detail\", kwargs={\"slug\": self.slug})\n\n        api = None\n\n        def __repr__(self):\n            return \"SiteCategory(id:{}, name:{}, slug:{}, weight:{})\".format(\n                self.id,\n                self.name,\n                self.slug,\n                self.weight,\n            ) \n\n\n\n    # Always the same, but a new class needed for every taxonomy.\n    class SiteCategoryParent(AbstractNodeParent):\n            pass\n                    \n\n    # Always this format, but a new instance needed for every taxonomy.\n    SiteCategory.api = NodeTreeAPI(\n                SiteCategory, \n                SiteCategoryParent, \n             ) \n\nNote that I called the new Node, and hence tree of nodes, 'SiteCategory'. You'll probably want to include the model name of attached elements somewhere, to avoid clashes if you have two or three taxonomies. 'Category' alone is too generic. 'ImgCategories' is probably better.\n\nThen migrate.\n\n\n## Admin\nNB: Even though the data is available, I have not found a way to push into Admin, which is obsessed with queryset machinery. Hence the funny bullet display.\n \nYou need a special admin found in 'taxonomy.admins'. The admin adds a 'parent' field to Node forms, and routes CRUD operations through the API.\n\nAs usual, the admin needs a 'fields' attribute. One comment here, if you do not have a 'fields' statement, the 'parent' field is placed at the bottom of the form. This is probably not what you want. Also, you will want the 'parent' field to show in most cases, so put 'parent' in the 'fields' list. \n\nYou can customise as usual. Here I've added a 'prepopulate' attribute for the slug field added to the SiteCategory node in the example above,\n\n    from django.contrib import admin\n    from ???.models import SiteCategory\n    from taxonomy import admins\n\n\n\n    class SiteCategoryAdmin(admins.CatAdmin):\n        fields = ('parent', 'name', 'slug', 'description', 'weight')\n        prepopulated_fields = {\"slug\": (\"name\",)}\n    admin.site.register(SiteCategory, SiteCategoryAdmin)\n\nThere we are,\n\n![Admin](screenshots/admin.png)\n\n\n## The API\nAs an app, Taxonomy is spread across DB tables which need code to manipulate them. The code is gathered into a manager. Since this is not the same as a Django (QuerySet) Manager, I've called it an API, not a manager. You'll use it for access to taxonomy data (unless you're hacking or have a broken installation).\n\nThe api hangs off any object based on AbstractNode, and can also be accessed from any AbstractNode class. Using the model created above, SiteCategory,\n\n    from sitecategory.models import SiteCategory\n\n    api = SiteCategory.api\n\nThe api is also present on any AbstractNode object,\n\n    from sitecategory.models import SiteCategory\n\n    obj = SiteCategory.objects.get(id=1)\n    obj,api\n\nThe attribute 'api' exposes methods for a tree,\n\n    delete() (whole tree)\n    save() (a Cat)\n    tree()\n\ne.g.\n\n    obj,api.delete()\n\ndeletes the whole tree, i.e. all nodes (including 'obj'), all other data, and cache. \n\nYou can call the API with a Node id, which gives you methods for a single Node,\n\n    from sitecategory.models import SiteCategory\n\n    # node = node with id=4\n    node = SiteCategory.api(4).node()\n\nThe call also accepts get() parameters, like the Django objects manager objects.get(), which can be handy,\n \n    node = SiteCategory.api(name='dvds').node()\n\nSo,\n\n    Category.api(7).node()\n\nreturns the same result as,\n\n    Category.api(id=7).node()\n\n...but the simple integer parameter does no initial DB lookup.\n\nThe call exposes many node-specific methods. For making pages, the simple-named methods return full node data,\n\n    parent()\n    children()\n    ascendant_path()\n    descendant_paths()\n    tree(self, max_depth=None)\n\ne.g.\n\n    SiteCategory.api(id=7).tree()\n\nreturns a tree descending from Node id=7.\n\nSome of the other methods only deal with DB ids.\n\nThe structure of tree data is worth mentioning. It is usually a flat tree of depth and Node data coupled in a Tuple, gathered into a list,\n\n    [\n        (0, Node1)\n        (1, Node2)\n        (1, Node3)\n        (0, Node4)\n        (1, Node5)\n        (2, Node6)\n        (3, Node7)\n        ...\n    ]\n\nThis is the kind of data the app uses to render the select boxes in Admin.\n\nOne point worth knowing is that, since these taxonomies are single-parent, there can be only one path back to the root. But there can be several paths towards leaves. Ask for descendant_paths() and you will get a list of lists.\n\n### Accessing taxonomy data\nYou can use the API in the shell, but also jamb it statically into a webpage. For example, here are the root categories in a tree, \n\n    from taxonomy import NO_PARENT\n\n        ctx['root_elements'] = SiteCategory.api(NO_PARENT).children()\n\npushed into a navbar with some CSS,\n\n![some children](screenshots/taxonomy_children_adjusted.png)\n\n\n## Attaching objects\n### Category recorded in object\nThis is the way most people think about this. A model 'Page' has a category of 'Psychology'.\n\nYou'll need to add a field to your Model. Usually you would use a ForeignKey (unless your data can fall into many categories. In that case, use a ManyToManyField).\n\n    ...\n    from sitecategory.models import SiteCategory\n\n    class Page(models.Model):\n        category = models.ForeignKey(\n            SiteCategory,\n            on_delete=models.CASCADE,\n            related_name='+',\n        )\n\nCASCADE means if the Node is deleted, the element is deleted also. One day this will be an important decision. If you want to keep material when the taxonomy is changed or discarded, use SET_NULL or SET_DEFAULT. \n\nAlso [related_name selects are switched off](https://docs.djangoproject.com/en/3.1/ref/models/fields/#django.db.models.ForeignKey.related_name). Related name selects will let you see a node and find the objects attached to it. But I'll be ok searching Page for elements in a category. Your choice.\n\nIt's possible you may want to leave an object without a parent. That could mean 'unpublished', or \"don't destroy with the category\". To do that, enable null or a default on the field,\n\n    from taxonomy import UNCATEGORIZED\n\n    class Page(models.Model):\n        category = models.ForeignKey(\n            Category,\n            blank=True,\n            default=UNCATEGORIZED,\n            on_delete=models.SET_DEFAULT,\n        )\n\nUNCATEGORIZED is a sentinel value from the app. I'm not fond of null in DB's, but you can use null if you want.\n\nThis model will deliver the usual Django display in Admin, a ModelChoiceField, which is ok. If you have many Nodes you may want to try [autocomplete](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.autocomplete_fields) or [raw id](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.raw_id_fields) widgets.\n\n### Attached object views\nLet's say this object is set up, and has a DetailView. There's much taxonomy detail you can recover and use to extend the functionality of the page. This is discussed in more detail in [rendering](#rendering), but this is how to get the data,\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n\n        if self.object:\n            category = self.object.category\n            # get the path to root\n            ctx['crumb_nodes'] = category.api(category.id).ascendant_path()\n            # child nodes\n            ctx['child_categories'] = category.api(category.id).children()\n            # disorganised collection of descendant nodes\n            ctx['descendant_categories'] = category.api(category.id).descendants()\n            # get sibling objects (in the same category)\n            ctx['siblings'] = self.model.objects.filter(category=category)\n        return ctx\n\nThen render.\n\n\n### Multiple models\nIf you follow this method for attaching-objects then different models can be attached to the same taxonomy nodes. The taxonomy knows nothing about the attached objects, and CRUD manipulation of the Taxonomy will work as you hope. For example, if the foreign key is set to cascade deletes, delete a node and attached objects will be deleted, even in different models.\n\nThis can get messy in a few ways. First, you'll need to think about how to handle objects returned from nodes, because they may be from different models. Perhaps a base model will help, so you can guarantee consistent handling? \n\nSecond, if you use Django's related managers, multiple models will create multiple related managers. Every different model you add to a taxonomy will add a new manager until each Node has a list like 'info_page_set', 'article_set', 'code_article_set', and more. There's two basic approaches. Either accept multiple managers, and try to be consistent. Or turn off related lookups and, if you need a list of elements, search the original models. Either way, you need to think if you are searching for elements of one type attached to a node (easy), or elements of any type (needs organisation).\n\n\n### Notes\nI would point out the above is not the only way. Objects can be recorded against categories. Not only is the above not the only way, I don't like it. I'd prefer category data did not intrude on objects. However, [Django has no ability](#the-evironment).\n\n\n\n## Rendering\nFirst I want to say this, and am going to shout,\n\n> :warning: This app's rendering acilities are not a settled API and may in the future change\n\nRight, let's move forward. There are a lot of options which are nothing to do with this app, they are conceptual. What do you want to render?\n\nThe overview of Django rendering is,\n- In a view, using the API, retrieve data from a taxonomy, then...\n- Render HTML immediately to push, throught the context, into the template, or...\n- Push data into a context then use template tags to semi-automatically render, or...\n- Render data in the template usuing template facilities\nOf these options, regading this module in particular, rendering in the view is the most flexible, but muddles logic and HTML. Template tags are tidiest, but inflecible and may need writing (which is time consuming for small efforts). As for using template facilities, the data returned by the API is complex, so may outreach the abilities of template rendering. \n\nThe app currently contains a few solutions.\n\n\nLet's say...\n\n### Using template facilites for breadcrumbs\nYou have a model linked to a taxonomy. \n \n![breadreumbs](screenshots/breadcrumb.png)\n\nWith some CSS work.\n\nStock Django. Add some taxonomy data to the model View, \n\n    from django.views.generic import ListView, DetailView\n    from page.models import Page\n\n    class PageDetailView(DetailView):\n        model = Page\n        context_object_name = 'page'\n        \n        def get_context_data(self, **kwargs):\n            ctx = super().get_context_data(**kwargs)\n            if self.object:\n                # cranky, but avoids Taxonomy import\n                category = self.object.category\n                ctx['crumb_nodes'] = category.api(category.id).ascendant_path()\n            return ctx\n\n\nThen, in the template 'page_detail.html', render 'crumb_nodes'. Can do that explicitly, \n\n   <nav class=\"topbar\">\n        <ul>\n            {% for node in crumb_nodes %}\n            <li class=\"menu-item\">\n                {{ node.name }}\n            </li>\n            {% endfor %}\n        </ul>\n    </nav>\n\nNow do your CSS.\n\n### Using the inline-templates\nThere are several pieces of code used to render taxonomy data directly in a view. These are all in 'inline-templates.py'. The current renderers are,\n\n- FlatTreeRenderer\n- FlatTreeRendererAsLinks\n- NodeListRenderer\n- NodeListRendererAsLinks\nThe base methods generate text displays, the ...AsLinks subvlasses generate HTML anchors.\n\nThe classes are used by generating an instance, then calling the method rend() with some data. Showing two of the vlasses at work, in a view put something like this,\n\n        tree = ArticleCategory.api.tree()\n        tr = FlatTreeRendererAsLinks()\n        rend_tree = tr.rend(\n            tree, \n            list_attrs={'class':\"category-tree\"}, \n            data_attrs={'class':\"category-anchor\"}\n            )\n        ctx['category_tree'] = mark_safe(rend_tree)\n        \n        crumb = ArticleCategory.api(id=7).ascendant_path()\n        nr = NodeListRendererAsLinks()\n        rend_breadcrumb = nr.rend(\n            crumb,\n            data_attrs={'class':\"bc-anchor\"}\n            )\n        ctx['breadcrumb'] = mark_safe(rend_breadcrumb)\n\nThen in the view template summon the template variables. Note that, like Djano form rendering, the template must provide the surrounding HTML list element declarations,\n\n    <ul class=\"breadcrumb\">\n        {{ breadcrumb }}\n    </ul>\n    <ul class=\"toc toc-list groove\">\n        {{ category_tree }}\n    </ul>\n\nThat's it. \n\n\n\n\n### Extra (unsupported) render code\nThere are several other pieces of code for rendering. All are working, all are not completed or unified, so may be changed in the future.\n\n#### Flat Trees\nTrees made of node data plus a depth. As used in the selector boxes in admin.\n\n![Flat Tree](screenshots/anchor_flat_tree.png)\n\nThe tags and classes return HTML.\n\n\n##### FlatTreeRendererMark\nRenders a tree, but depth is indicate by a flexible mark, not nested HTML lists,\n\n\n##### AnchorFlatTreeRendererMark\nA FlatTreeRendererMark rendered with anchors e.g.\n\n\n    from django.utils.safestring import mark_safe\n    from taxonomy.models import SiteCategoryNode\n    from taxonomy.inline_templates import AnchorFlatTreeRenderer\n\n\n\n    class CategoryDetailView(DetailView):\n        ...\n        def get_context_data(self, **kwargs):\n            ctx = super().get_context_data(**kwargs)\n            tree = Category.api.tree()\n            tr=AnchorFlatTreeRenderer()\n            rend_tree = tr.rend(tree)\n            ctx['nav_tree'] = mark_safe(rend_tree)\n            return ctx\n\n\n#### Stacked Trees\nTrees that display nodes on top of each other, extending downwards like roots on a plant.\n\n![Stacked Tree](screenshots/stack_tree.png)\n\nThese displays use a lot of visual space. Only a small taxonomy can be displayed. And, as you can see, the classes and tags return SVG graphics. \n\n\n##### StackTreeRenderer\nFor example,\n\n    from django.utils.safestring import mark_safe\n    from taxonomy.models import SiteCategoryNode\n    from taxonomy.inline_templates import StackTreeRenderer\n\n\n\n    # lightly customise the renderer to colour the beam and stem marks\n    class PrettyStackTreeRenderer(StackTreeRenderer):\n       beam_style = 'stroke:darkseagreen;stroke-width:4;stroke-linecap:square;'\n       stem_style = 'stroke:darkseagreen;stroke-width:2;'\n\n\n\n    class CategoryDetailView(DetailView):\n        ...\n        def get_context_data(self, **kwargs):\n            ctx = super().get_context_data(**kwargs)\n\n            # Get a tree\n            tree = SiteCategoryNode.api.tree()\n\n            # Rend\n            tr = PrettyStackTreeRenderer()\n            rend_tree = tr.rend_default(tree, 300, 12)\n\n            # Deliver into a template\n            ctx['cat_tree'] = mark_safe(rend_tree)\n            return ctx\n\nIn the template,\n\n            {{ cat_tree }}\n\nTo modify further, look at code. 'text_style', 'beam_style' and 'stem_style' can be overloaded (different colors/widths/cap-style). Use 'rend', instead of 'default_rend' to modify gaps and distances. Different data can printed by overloading 'get_context' and 'data_template'.\n\n##### AnchorStackTreeRenderer\nInline SVG is live DOM code and can render working anchors,\n\n    from taxonomy.inline_templates import AnchorStackTreeRenderer\n\n    ...\n        def get_context_data(self, **kwargs):\n            ctx = super().get_context_data(**kwargs)\n\n            # Get a tree\n            tree = SiteCategoryNode.api.tree()\n\n            # Rend\n            tr = AnchorStackTreeRenderer()\n            rend_tree = tr.rend_default(tree, 300, 12)\n\n            # Deliver into a template\n            ctx['cat_tree'] = mark_safe(rend_tree)\n            return ctx\n\nTo customise, AnchorStackTreeRenderer can be overridden like StackTreeRenderer.\n\n\n\n#### Notes on SVG graphics\nNotes,\n\n- The output image should auto-size into any webpage container it is placed in. Including browser resizing.\n- It is an image. Text size is fixed, and will not respond to page zoom \n- After generation, the web delivery load is very low...\n- ...but the SVG image puts extra load on the receiving browser\n\nThe render works by writing node data into boxes, which are laid out according to node hierarchy. To make text smaller, try make the 'x' size larger (which scales text down).\n\n#### Template tags\nThere are several template tags which can deliver the treerenderers. Sorry, but I not worked them through.\n\nFor rxample, there's a template tag that prints a depth tree in HTML. It is easy to use, though operation is limited,\n\nUse a view to send a tree (the usual depth-Node type),\n\n    from sitecategory.models import SiteCategory\n        ....\n        ctx['site_tree'] = SiteCategory.api.tree()\n\nRender that data in a template with this tag,\n\n    {% load taxonomy_displays %}\n        ...\n        {% flat_tree site_tree %}\n\n\n\n\n\n## Considering URLs for Taxonomies \nWhat we mean by presenting a taxonomy to users is making URLs to point to nodes, then presenting nodes as a View.\n\nNot all taxonomies will need URLs. Taxonomies can be used for internal organisation. But a taxonomy with URLs can make the base of a site. For example, a few CMS now assume that pages on a site are organised as a tree.\n\n\n### Planning\nAll kinds of fancy pages nowadays, but a classic web navigation page for a directory would be a list of sub-directories and files. Navigate to a category on most sites and you will find lists of attached elements. But if you have a search page enabled on your site, maybe you would want to go to that? That's a different kind of URL.\n\nIf you want pages for node/categories, you need to decide how your URLs will look. Will element URLs include a subject? There is advice [they should not](https://www.w3.org/Provider/Style/URI). But then the URL is not so hackable, which is also a case.\n\nI've not worked on a full URL solution. Here is a 'distracted' URL solution, that retains elements at their Django URLs (e.g. host/page/xxx) but provides breadcrumbs and category listings.\n\nAnyway, lets start with...\n\n\n### Taxonomy data as anchors\nYou start with rendering taxonomy data as anchors. This will happen in some View. You use the API to deliver some data to a template.\n\nIf the model has a field 'slug', and is a list of nodes, the app has a templatetag,\n\n    <nav>\n        {% node_anchors crumb_nodes url_prefix='/category/' class='breadcrumb' %}\n    </nav>\n\nwhich accepts optional args,\n\n    url_prefix\n        to go before the slug. Default '/category/'\n    url_id_field\n        fieldname for id data for the URL. Default 'slug'\n\nOther keyword arguments are rendered as HTML attributes.\n\nThe templatetag has not much control over rendering, but maybe you don't need that. The tag above renders as,\n\n    <ul class=\"breadcrumb\">\n        <li><a href=\"/category/node_1\">node 1</a></li>\n        <li><a href=\"/category/node_2\">node 2</a></li>\n        ...\n    </ul>\n\nUnless you've built some taxonomy Views, these links don't point at anything. But it's a start.\n\n\n### Declare a Node model with a slug field\nYou can, and sites do, have URLs like,\n\n    [host]/sitecategory/4\n\nIf it won't be important for users, this is simple and clean. But if you'd like something more visual, add a slug field to the node model. Then the URL can look like,\n\n    [host]/sitecategory/shrubs\n\nNow a View.\n\n### Node views\nWherever the taxonomy is located, make a DetailView for the Nodes. Note this isn't a ListView. Sure, we are listing things, but the basic idea here is 'something to do with a single category', not 'list of categories',\n\n    from django.views.generic import DetailView\n    from sitecattegory.models import SiteCategory\n    from page.models import Page\n\n\n    class SiteCategoryDetailView(DetailView):\n        model = SiteCategory\n        context_object_name = 'sitecategory'\n\n        def get_context_data(self, **kwargs):\n            ctx = super().get_context_data(**kwargs)\n            if self.object:\n                # You chould shovel in some breadcrumb data\n                ctx['crumb_nodes'] = self.object.api(self.object.id).ascendant_path()\n\n                # ...or a list of descendant Nodes            \n                ctx['descendant_nodes'] = self.object.api(self.object.id).descendants()\n\n                # ...or element data from this category (this could use a related query if you have set up like that)\n                ctx['elements'] = Page.objects.filter(category=self.object)\n            return ctx\n\nAnd a template, sitecategory_detail.py. For example,\n\n    {% extends 'base.html' %}\n    {% load taxonomy_displays %}\n\n    {% block title %}{{ sitecategory.name }}{% endblock %}\n    {% block body_class %}template-sitecategory{% endblock %}\n\n    {% block content %}\n    <nav>\n        {% node_anchors crumb_nodes url_prefix='sitecategories' class='breadcrumb' %}\n    </nav>\n    <div class=\"sitecategorydetail-stock\">\n        <header class=\"sitecategorydetail-header\">\n            <div class=\"topbar\">Topbar</div>\n        </header>\n\n        <div class=\"sitecategorydetail-block\">\n            <h1>{{ sitecategory.name }}</h1>\n            <h2>Sub-categories</h2>\n            {% node_anchors descendant_nodes %}\n            <h2>Elements</h2>\n            <p class=\"elements-text\">{{ elements }}</p>\n        </div>\n    </div>\n    {% endblock %}\n\nYou'll want to do more than this. Underneath these pages is a category View, but nowadays people go berserk with them. Import your site logos, messaging and navigation templates. Jamb the descendant Node data into menus. If you keep the elements on the page, make them into a list of image anchors. Load with search bars, gadget images, manipulative headlines, and entrapment buttons. Time to express yourself.\n\n\n### Category URLs\nNow need to wire in the View. Add a link in your URLs file,\n\n    from sitecategory.views import SiteCategoryDetailView\n\n    urlpatterns = [\n        path('sitecategory/<slug:slug>',  SiteCategoryDetailView.as_view(), name='sitecategory_detail'), \n    ]\n\n\nThen maybe a reverse URL on the Category model. That would give in Admin a 'View on site' button,\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('sitecategory_detail', kwargs={'slug': self.slug})\n\nDone.\n\n\n\n## Implementation notes\nThere are a few ways to implement a tree.\n\n### Creating a Root Node\nYou can set any number of nodes at base. If you would like a taxonomy with a singular base, start a single node which will be the 'root'. Build from there e.g. ::\n\n    base = 'car categories'\n    - Cars\n    -- saloon \n    -- hatchback \n    -- sport\n    ...\n  \netc.\n\n\n### Tests\nSo far I have not found a way to test this app without Python ducktape. There are tests.  They are in a directory 'ttest'. This is a full app.\n\nTo run the tests you must install django-taxonomy, then move 'ttests' to the top level of a project. Install,\n\n    \n        INSTALLED_APPS = [\n            ...\n            'ttest.apps.TTestConfig',\n            'taxonomy.apps.TaxonomyConfig',\n            ...\n        ]\n\n...and migrate. The tests are in the ''tests' sub-folder of 'ttests'.\n\n\n\n## EndNote\n### The environment\nThe Django system presents substantial difficulties to anyone implementing structures like this. There is the issue of the ORM and foreign keys, about which you can say nothing, or write a book. Form-building seems flexible, but you can't pin partials together, nor integrate with Admin. And admin may be customisable, but it's a blob of code and can not be extended. The only functionality on the coder's side is Django's model building, and Python hackability. It's clear other projects have wrestled with these issues. I'm just working as I can to make something usable.\n\n\n### Straight vs. MPTT etc. implementation\nDjango-taxonomy uses direct links between its tree nodes. This is fundamentally different to an MPTT structure, which links tree nodes as a list, or a path structure. It's something like the difference between an array and a linked list. They both present a similar API, but the underlying implementation is different. There are advantages to both. An MPTT structure is excellent at gathering data from multiple categories, say 'cars' and all sub-categories. It is also capable of ordering it's categories and references exactly. Whereas the straight structure is poor at this, and I have not implemented either functionality. But the straight structure is simple to create and maintain, and good at displaying the categories themselves.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rcrowther/django-taxonomy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-taxonomy2",
    "package_url": "https://pypi.org/project/django-taxonomy2/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-taxonomy2/",
    "project_urls": {
      "Homepage": "https://github.com/rcrowther/django-taxonomy"
    },
    "release_url": "https://pypi.org/project/django-taxonomy2/1.0.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Category tree for Django. Replicable and customizable. Includes Admin. Low on features, easy setup.",
    "version": "1.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12554916,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "535ac1297c4c604c3094fcf3ce3fbca895d6e5b9af72ff74cf20406b878b207d",
        "md5": "d2c13719fbd42c08345c2032f41541d5",
        "sha256": "723ca6438ba4acb6dc89a5ac2718fc191e9c39081e757fa87f46440ab1818bf7"
      },
      "downloads": -1,
      "filename": "django_taxonomy2-1.0.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "d2c13719fbd42c08345c2032f41541d5",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 30146,
      "upload_time": "2022-01-12T16:33:59",
      "upload_time_iso_8601": "2022-01-12T16:33:59.797582Z",
      "url": "https://files.pythonhosted.org/packages/53/5a/c1297c4c604c3094fcf3ce3fbca895d6e5b9af72ff74cf20406b878b207d/django_taxonomy2-1.0.1-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f4ae6f33305ebff184b1fe656764f469bf6f3176d9bf3330eb57640ec3034e55",
        "md5": "46d777d672dcda28bed35ec7bcab092c",
        "sha256": "64c13cb00bfbbfc737769480e0b98eeda322b7041d724b23adebdab10588a19e"
      },
      "downloads": -1,
      "filename": "django-taxonomy2-1.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "46d777d672dcda28bed35ec7bcab092c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 77801,
      "upload_time": "2022-01-12T16:34:03",
      "upload_time_iso_8601": "2022-01-12T16:34:03.753193Z",
      "url": "https://files.pythonhosted.org/packages/f4/ae/6f33305ebff184b1fe656764f469bf6f3176d9bf3330eb57640ec3034e55/django-taxonomy2-1.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}