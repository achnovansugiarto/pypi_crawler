{
  "info": {
    "author": "robert crowther",
    "author_email": "rw.crowther@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# django-static-models\n> :warning: **If you have tried this app** This is a new version, can run older configs, but URL handling is new and much extended \n\nGenerate static pages from a Django Views. The static pages are gathered in a single configurable directory, with appropriate generated or configured subdirectories. The name of this app is historic, the app can now evoke pages from most Views.\n\nThis app is what I need it to be. It has no deployment code, as this is a separate step, and your business. However, the app is developing some generality.\n\n## What this app is and is not\nBecause most websites include some static files, the word ''static' has many uses,\n\nThis app generates pages from views and URLs in a Django site. The targetted Views will not have dynamic facilities such as logons or personalisation. Naturally, webpages delivered in this way will be fast, easy to deploy and, in terms of conventional concerns, have few security issues. \n\nIt should be noted that some dynamic facilities can still be added to such pages. Email handling, shopping, and search can be created using links to external sites. Javascript can be used to inject tailored information. Or Django can be enabled where necessary---for, say, admin pages,\n\nThis app is not for supplementing Django's existing tools for handling of static resources. Nor is it specifically for optimizing output.\n\n## Why you may or may not use it\nPros,\n- You want to output static pages from a Django project\n- Simple. Add some configuration\n\nCons,\n- No middleware solution. So generated pages are not deployed in the running app (though you can view them directly)\n- Deploy is not considered\n\n## Quickstart\nQuickstart is not a good name as there is no quick start here. You need a model and a view, typically a DetailView or like, to work with. Or use some URLs,\n\n- Set a config\n- Generate some pages './manage.py -o viewstaticmerge' \n- Look in the 'site/' folder in the top level of the project,\n\n\n## Overview\nThe process for main app usage is... configure some settings which target a View, run the management command, do something with the generated pages.\n \nThe main work is in the config, which describes which views are served with what data, and where the generated pages are to be written.\n\nThis being Django, the action is not as simple as it sounds. What the app does is generate an HTML response, which in Django is an encoded stream. The stream is then written to an HTML file. There are various configurations possible to decide file placement and name.\n\nThe main code is in 'static_models.utils.ViewGenerator', which is well-documented. You may want a different kind of action, for example semi-automatic page generation. If so, look at the ViewGenerator class.\n\n## Install\nThe code can either be downloaded from Github, or installed using Pip,\n\n    pip3 install django-static-models\n\nThe code needs to be declared in settings.py,\n\n    INSTALLED_APPS = [\n         'static_models.apps.StaticModelsConfig',\n    ]\n\n\n## Configuration\nYou need to set a base directory,\n\n    STATICVIEWS_DIR = BASE_DIR / 'page_collection'\n\nor similar.\n\n### Generating from data Models\nA simple View configuration is,\n\n    STATIC_VIEWS = [\n        {\n        'query': 'all',\n        'view' : 'page.views.PageDetailView',\n        },\n    ]\n    ...\n\nThis will render the model on the PageDetailView through the view PageDetailView. It will search for all Page objects, then render them to an auto-named directory. The output files will be named by the 'pk' e.g. '3'.\n\nOften you will not want to use the 'pk' data to name the files. Configure like this,\n\n    STATIC_VIEWS = [\n        {\n        'query': 'all',\n        'view' : 'page.views.PageDetailView',\n        'filename_from_attribute' : 'slug',\n        },\n    ]\n\nThis configuration presumes the model Pages has a field called 'slug'. 'filename_from_attribute' uses the 'slug' field to name the files. So now, in the 'sites' directory, the app may generate a file 'web-lunacy', not '3'. \n\nNote that Django configures models so that the fields are acessible as Python attributes. 'filename_from_attribute' can also call a zero-argument callable (method/function whatever). This makes it possible to generate pages from different views of the same object---add a callable returning the secondary filenames/url_id to the model.\n\nSometimes you will not want to use the model name to name the pathroot of the files. Configure like this,\n\n    STATIC_VIEWS = [\n        {\n        'query': 'all',\n        'view' : 'page.views.PageDetailView',\n        'filename_from_attribute' : 'slug',\n        'filepath' : 'article'\n        },\n    ]\n\nNow the files go to 'STATICMODELS_DIR/article', not 'STATICMODELS_DIR/Page'. You can substitute any path in 'filepath', the filename is appended to the value.\n\n\n### Generating from URLs\nIf you are generating from database models, I recomment the approach above. However, some views get their information from URLs only e.g. ListViews contain all their information inside them, they only need evoking. Presuming a suitable view, the key is the URL, the value is the filename, \n    {\n    'urls' : {'products/': 'products'},\n    'filepath' : 'products'\n    },\n\n\nIf the filename (the value) is None, the generator makes a filename from the URL. May work in many instances,\n\n    {\n    'urls' : { 'home': 'index', 'about': None, 'contact': None},\n    'view' : 'hp_reviews.views.SitePageDetailView',\n    'filepath' : ''\n    },\n\nYou can state many URLs at once,\n\n    {\n    'urls' : { 'home': 'index', 'about': 'about', 'contact': 'contact'},\n    'view' : 'hp_reviews.views.SitePageDetailView',\n    'filepath' : ''\n    },\n\n\n### Generating one-off pages\nSome views do nothing but generate single pages. You can 'filename' these,\n\n    {\n    'view' : 'homepage.views.HomepageView',\n    'filename' : 'index',\n    }\n\n\n## Management commands\nThe main way of invoking the configuration. Typically,\n\n    ./manage.py viewstaticmerge\n\n\nBy default 'modelstaticmerge' will not touch files if it finds the generated files work are the same size as the existing file.  This is similar to 'rsync' behaviour. Also, it will not add a file extension. But you have these options,\n\n-  -o, --overwrite       Replace currently existing files (default is to ignore if unchanged)\n- -e, --html_extension  Add '.html' extension to generated files.\n\n\nSo,\n\n    ./manage.py modelstaticmerge -e\n\nWill generate HTML files from the configuration. From the second configuration above the files will be put in site/page/ and will be named from the slug data + '.html'.\n\nThe management command is a little stripped down. You can do the same, with a few more options, by using the shell to import the ViewGenerator class from static_models.utils.\n\n\n## ViewGenerator\nOffers options which may be of use. All options are exposed in the settings or the management command,\n\n\n## Viewing files\nI suggest to start you go look at the generated file. Try loading to a browser, see what happens. Straight away you will see the issue.\n\nThe generated pages will have correct internal links ie. for resources like CSS or image links. But...\n\n### Servers and browsers default files without extensions\nThis applies to Django development servers and to deployment servers like Apache and Nginx. \n\nIf you used this app's default setup, you will generate files without an 'htm/html' extension. The files are named,\n\n    site/page/many-wonders\n\nNot,\n\n    site/page/many-wonders.html\n\nA browser or server will usually read these as an 'octet-stream', not a HTML file. They will not show the page, they will offer a download. \n\nThis is an issue with static page serving, not this app or Django. There are ways round this.\n\n#### Use the app facilities to generate extensions\nThat way, every page will load and display. The issue with this is that links between pages will be broken. And your project will loose any pretty URL setup. So, of course, you can rewrite your templates to add extensions to links. Or you may not care about dev viewing. Remember, these files are not what the dev server will be using for viewing, unless you [set up a URL]().\n\n\n#### Coax the server into using a different default type\nBrowsers will not be able to read the files, they almost always use the extension, not the MIME type of the file. However, coaxing the server into seeing files as a different type is not as difficult as it sounds. It depends on your server. But if you can ask it to accept file types without an extension as MIME type 'text/html', you are up and running.\n\nAs for delivery, there are another option. Many deployment servers would allow you to rewrite the filename with an extension. Which is web-classic form, and guaranteed.\n \n\n## Viewing files in development\nDjango static app has a middleware solution, where any URL looking for a file seeks first in the 'static' folder, and if that fails, goes hunting round the apps.\n\nIt would be interesting to have a parallel process for the static pages, but I've not implemented this. However, I have bashed together a View that can deliver the pages, even with no extension. Put this in ''urls.py',\n\n    from django.conf import settings\n    from static_models.views import StaticView\n        ...\n    path('site/<path:path>/', StaticView.as_view(path_root= settings.BASE_DIR  + '/site/'), name='site-detail'),\n\nThis code uses a setting BASE_DIR. StaticView has no opinion on the pathstyle. Now you can see all the static files on the URL 'site/...'. Such as 'site/page/many-wonders/'.\n\nIf there is a problem with the above, it is that links between pages will not work. All pages have been re-rooted to a URL root 'site'. A link like 'page/many-wonders' will now be broken. It needs to be 'site/page/many-wonders'. And we don't want to configure a URL for web root ('/') because likely you have some home page or other good use for that.\n \nAs a partial solution, StaticView also accepts 'pk' and 'slug' segment captures. So you can generate static pages, then rewrite urls.py, e.g. \n\n    from django.conf import settings\n    from static_models.views import StaticView\n        ...\n\n    # New URL for static pages\n    path('page/<slug:slug>/', StaticView.as_view(path_root= settings.MEDIA_ROOT + '/site/page/'), name='page-detail'),\n\n    # original URL for dynamic pages\n    #path('page/<slug:slug>/',  PageDetailView.as_view(), name='page-detail'), \n\nNow links between pages work. So reverse URLs. But you will need to set up a URL path for every model you generate static files from.\n\n\n### Static definition, in the View, of path_root \nThis is not something that would be of interest to many.\n\nYou can define path_root using a custom class declaration, With that you can configure fancy URL resolution/HTTP responses etc. e.g.\n\n    from django.conf import settings\n    from static_models.views import StaticView\n\n    class PageStaticView(StaticView):\n        path_root = settings.MEDIA_ROOT + '/site/page/'\n        ...\n\nAnd in ''urls.py',\n\n    from page.views import PageStaticView\n        ...\n        path('page/<int:pk>/', PageStaticView.as_view(), name='page-detail'),\n\n\n## Generating URL'/' root\nIf you are planning a complete static site, as opposed to boosting part of your site, you may run into the Django root abstraction. Django serves static files from the 'static/' directory, not the root. It has no analogy for a physical base 'root' directory. It either errors, or returns a configured URL. So what will you do with '/'?\n\nWell, most visual websites will have a 'home' page of some kind. You could cook something up in deployment, and ignore anything that doesn't work through page generation. Or you could take advantage of this app's one-off generation, and generate an 'index.html' page from a project's 'home' page view.\n\n\n\n## Maintaining a tree of static webpages\nRun the management command whenever you update. Or automate the process in a deploy script. Another way is to run a maintenance command periodically. \n\nIf you want to merge eagerly and automatically, there's a few ways, none are wonderful. I'd favour using the post_save signal in 'apps.py'. That will work with all model changes, and contains the logic within an app,\n\nTo auto-merge filesystem storage,\n\n    def static_merge(sender, instance=None, **kwargs):\n        from image.views import ArticleDetailView\n        from static_models.utils import file_static_merge\n        file_static_merge(instance, ArticleDetailView)\n\n    class ImageConfig(AppConfig):\n        ...\n        def ready(self):\n            ...\n            from django.db.models.signals import post_save\n            from image.models import Page\n            post_save.connect(static_merge, sender=Page)\n\nFor more options, run full static handling,\n\n    def static_merge(sender, instance=None, **kwargs):\n        from article.views import ArticleDetailView\n        from static_models.utils import ModelGenerator\n        g = ModelGenerator(sender, ArticleDetailView, overwrite=True)\n        g.obj_create(instance)\n\n    class ImageConfig(AppConfig):\n        ...\n        def ready(self):\n            ...\n            from django.db.models.signals import post_save\n            from article.models import Page\n            post_save.connect(static_merge, sender=Page)\n\n\ng.obj_delete() can be used in the same way on post_delete, but be careful if you want to share the static pages, that you do not delete data expected elsewhere.\n \n## Alternatives\nYou could use some outside tool to grab pages from the server. In the same way a web-cache like Squid works.\n\nCloser to the codebase, Wagtail CMS have been [talking about using Gatsby](https://wagtail.io/blog/using-gatsby-wagtail-build-case-study/) for the purpose of storing static pages.\n\n[Deploy Django without admin](https://stackoverflow.com/questions/4845239/how-can-i-disable-djangos-admin-in-a-deployed-project-but-keep-it-for-local-de). No logons then, of course, but removes many potential security violations while allowing dynamic templates and form-handling. \n\n[django-static-sites](https://github.com/ciotto/django-static-sites/tree/master/staticsites) \n    Deployment options built in. \n\n[django-static-delivery 0.0.1](https://pypi.org/project/django-static-delivery/) \n    A middleware solution, which makes sense. Probably more of an optimiser than a generator, but untested.\n\n[django-static-pages](https://pypi.org/project/django-static-pages/)\n    Uses a test client to generate pages, Not clear if it is only for testing?\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": null,
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rcrowther/django-static_models",
    "keywords": null,
    "license": null,
    "maintainer": null,
    "maintainer_email": null,
    "name": "django-static-models",
    "package_url": "https://pypi.org/project/django-static-models/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-static-models/",
    "project_urls": {
      "Homepage": "https://github.com/rcrowther/django-static_models"
    },
    "release_url": "https://pypi.org/project/django-static-models/1.0.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Generate static pages from views",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17126544,
  "urls": [
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "27f5f431b8db51b3f8e67201215ee270f040c8dff40ef52127c6601bf1e9b5ad",
        "md5": "ef1917b3e8a9317a35d0e0852c2d7039",
        "sha256": "b00490fcce5b82d474b28c72a0b2d5d6354448a25cf00d666464bcba73ea6429"
      },
      "downloads": -1,
      "filename": "django_static_models-1.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "ef1917b3e8a9317a35d0e0852c2d7039",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 19261,
      "upload_time": "2023-02-19T11:15:36",
      "upload_time_iso_8601": "2023-02-19T11:15:36.900885Z",
      "url": "https://files.pythonhosted.org/packages/27/f5/f431b8db51b3f8e67201215ee270f040c8dff40ef52127c6601bf1e9b5ad/django_static_models-1.0.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "c78b02d104a651b2697bbdcaaf8a2242942221068d7a3488bb682060d9c27a7b",
        "md5": "29b45d57ad35c44212f3feea49fb5812",
        "sha256": "0f09a8c22e563e43f949caa3ac0113cbb05489b1bc4b6e4fb2ac97fb5606a49d"
      },
      "downloads": -1,
      "filename": "django-static-models-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "29b45d57ad35c44212f3feea49fb5812",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 21466,
      "upload_time": "2023-02-19T11:15:39",
      "upload_time_iso_8601": "2023-02-19T11:15:39.756203Z",
      "url": "https://files.pythonhosted.org/packages/c7/8b/02d104a651b2697bbdcaaf8a2242942221068d7a3488bb682060d9c27a7b/django-static-models-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}