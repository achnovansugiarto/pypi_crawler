{
  "info": {
    "author": "Gabe Morris",
    "author_email": "gabemorris1231@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "License :: OSI Approved :: MIT License",
      "Operating System :: Microsoft :: Windows",
      "Programming Language :: Python :: 3.10"
    ],
    "description": "# Purpose\r\n\r\nThis package was created to aid with the designing process of mechanisms involving linkages, cams, and gears. In regard\r\nto linkages, it is capable of implementing a kinematic analysis with the knowledge of the degrees of freedom for the\r\nvectors that make up the mechanism. With the aid of numerical solving and iteration, the position, velocity, and\r\nacceleration of these vectors and points may be acquired.\r\n\r\nIn regard to cams, this package is capable of supplying coordinates of a cam profile, plotting SVAJ diagrams, and\r\ngetting a cam and follower animation for roller and flat faced followers. In turn, the coordinates may be supplied to a\r\nmachinist or imported into SolidWorks. All that is needed to know is the motion description (i.e. rise 2 inches in 1\r\nsecond, dwell for 1.5 seconds, fall 2 inches in 3 seconds). As of right now, the kinds of motion supported are\r\nnaive/uniform motion (how the cam shouldn't be designed), harmonic motion, and cycloidal motion. It is possible that\r\nthis gets updated in the future with better options such as modified sinusoidal motion.\r\n\r\nFor gears, this package is capable of providing the coordinates of a spur gear tooth profile given a set of properties.\r\nThe analysis is based on the diametral pitch, number of teeth, and pitch diameter if desired over the number of teeth.\r\nAn argument for AGMA standards may be set to `True` if desired.\r\n\r\nInstall this package via pip: `pip install mechanism`.\r\n\r\n# Results/Examples\r\n\r\n`fourbarlinkage.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage.gif)\r\n\r\n`fivebarlinkage.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fivebarlinkage.gif)\r\n\r\n`crunode_coupler.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/crunode_coupler.gif)\r\n\r\n`crankslider.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/crankslider.gif)\r\n\r\n`engine.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/engine.gif)\r\n\r\n`non_grashof.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/non_grashof.gif)\r\n\r\n`offset_crankslider.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/offset_crankslider.gif)\r\n\r\n`cam2_example.py`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam2.gif)\r\n\r\n# Linkages, Cranks, Couplers, and Rockers\r\n\r\nIn order to use the contents of `mechanism.py`, a basic knowledge of vector loops must be known. The structure of the\r\nvector loops function is shown in several files under the `examples` folder. To gain a greater understanding of this\r\npackage's usage, this walk through is provided.\r\n\r\n## Four Bar Linkage Example\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage.PNG)\r\n\r\nA four bar linkage is the basic building block of all mechanisms. This is similar to how the triangle is the basic\r\nbuilding block of all structures. What defines a mechanism or structure is the system's overall number of degrees of\r\nfreedom, and the number of degrees of freedom is determined via Kutzbachâ€™s equation.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage_dof.PNG)\r\n\r\nKutzbach's equation is: *total degrees of freedom = 3(#links - 1) - 2(J1) - J2* where J1 is the number of full joints\r\n(also known as a revolute joint) and J2 is the number of half joints. For this four bar linkage, there are 4 full\r\njoints.\r\n\r\nThe number of degrees of freedom is: 3(4 - 1) - 2(4) = 1\r\n\r\nThis means that we need one known input to find the unknowns of the system. This can be explained further with a diagram\r\nof the vectors that make up the four bar linkage.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbarlinkage_loop.PNG)\r\n\r\nFrom the above image, the vector \"a\" is the crank. The speed at which it rotates will be considered as the input to the\r\nsystem, and thus, it is the defining parameter to the system.\r\n\r\nThe lengths of all the vectors are known. The only two unknowns are the angle that corresponds to vector \"b\" and \"d\". It\r\nis important to note that the objects that make up this package are vectors, and the polar form of the vectors is the\r\nmain interest.\r\n\r\nThere is only one loop equation which provides two equations when breaking down the vectors into its components. With\r\ntwo equations and two unknowns, this system becomes solvable.\r\n\r\n### Problem Statement\r\n\r\nConsider the four bar linkage shown above. The lengths of a, b, c, and d are 5\", 8\", 8\" and 9\". The crank (a) rotates at\r\na constant 500 RPM. Use `mechanism` to get an animation of this linkage system and plot the angles, angular velocity,\r\nand angular acceleration of vector d as a function of time.\r\n\r\n### Solution\r\n\r\nThe four bar linkage is a grashof linkage because it satisfies the grashof condition (9 + 5 < 8 + 8). This means that\r\nthe crank is able to fully rotate. The input can be deduced by integrating and differentiating the constant value of the\r\nconstant angular velocity of the crank.\r\n\r\nAlways begin with defining the joints and vectors.\r\n\r\n```python\r\nfrom mechanism import *\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n# Declare the joints that make up the system.\r\nO, A, B, C = get_joints('O A B C')\r\n\r\n# Declare the vectors and keep in mind that angles are in radians and start from the positive x-axis.\r\na = Vector((O, A), r=5)\r\nb = Vector((A, B), r=8)\r\nc = Vector((O, C), r=8, theta=0, style='ground')\r\nd = Vector((C, B), r=9)\r\n```\r\n\r\nAlways define the vectors in the polar form. The first argument is the joints, and the first joint is the tail of the\r\nvector, and the second is the head. Additionally, extra keyword arguments will be passed to plt.plot() for styling.\r\nThere should be half as many loop equations as there are unknown. The input vector \"a\" does not need to have its known\r\nvalues at its declaration. Instead, it's values will be accounted for in the loop equation. The next thing to do is to\r\ndefine the known input and guesses for the first iteration of the unknown values.\r\n\r\n```python\r\n# Define the known input to the system.\r\n# For a 500 RMP crank, the time it takes to rotate one rev is 0.12s\r\ntime = np.linspace(0, 0.12, 300)\r\nangular_velocity = 50*np.pi/3  # This is 500 RPM in rad/s\r\n\r\ntheta = angular_velocity*time  # Integrate to find the theta\r\nomega = np.full((time.size,), angular_velocity)  # Just an array of the same angular velocity\r\nalpha = np.zeros(time.size)\r\n\r\n# Guess the unknowns\r\npos_guess = np.deg2rad([45, 90])\r\nvel_guess = np.array([1000, 1000])\r\nacc_guess = np.array([1000, 1000])\r\n```\r\n\r\nThe guess values need to be arrays of the same length as the number of unknowns. These arrays will be passed as the\r\nfirst iteration. The next thing to do is to define the loop function and create the mechanism object.\r\n\r\n```python\r\n# Define the loop equation(s)\r\ndef loop(x, i):\r\n    return a(i) + b(x[0]) - c() - d(x[1])\r\n\r\n\r\n# Create the mechanism object\r\nmechanism = Mechanism(vectors=(a, b, c, d), origin=O, loops=loop, pos=theta, vel=omega, acc=alpha,\r\n                      guess=(pos_guess, vel_guess, acc_guess))\r\n```\r\n\r\nThis example is simpler than most others because there is only one loop equation. For multiple loop equations, it is\r\nimportant that the function returns a flattened array of the same length as there are unknown, and the indexing of the\r\nfirst array argument to the loop corresponds to the input guess values. The second argument is the input. It is strongly\r\nencouraged to view the examples for the more rigorous structure of the loop function. The last thing to do is to\r\ncall `mechanism.iterate()`, which is necessary if the input from `pos`, `vel`, and `acc` are arrays. If they are not\r\narrays, then it is assumed that the mechanism at an instant is desired. If this is the case, then\r\ncall `mechanism.calculate()` then call `mechanism.plot()` (see `plot_at_instant.py`).\r\n\r\n```python\r\n# Call mechanism.iterate() then get and show the animation\r\nmechanism.iterate()\r\nani, fig_, ax_ = mechanism.get_animation()\r\n\r\n# Plot the angles, angular velocity, and angular acceleration of vector d\r\nfig, ax = plt.subplots(nrows=3, ncols=1)\r\nax[0].plot(time, d.pos.thetas, color='maroon')\r\nax[1].plot(time, d.vel.omegas, color='maroon')\r\nax[2].plot(time, d.acc.alphas, color='maroon')\r\n\r\nax[0].set_ylabel(r'$\\theta$')\r\nax[1].set_ylabel(r'$\\omega$')\r\nax[2].set_ylabel(r'$\\alpha$')\r\n\r\nax[2].set_xlabel(r'Time (s)')\r\nax[0].set_title(r'Analysis of $\\vec{d}$')\r\n\r\nfor a in (ax[0], ax[1], ax[2]):\r\n    a.minorticks_on()\r\n    a.grid(which='both')\r\n\r\nfig.set_size_inches(7, 7)\r\n# fig.savefig('../images/analysis_d.png')\r\n\r\nplt.show()\r\n```\r\n\r\nThis will produce the following output:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/fourbar_animation.gif)\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/analysis_d.png)\r\n\r\n# Cams\r\n\r\nThere are several kinds of motion types for a cam, but there is an important corollary when designing cams: *The jerk\r\nfunction must be finite across the entire interval (360 degrees)* (Robert Norton's *Design of Machinery*). Usually, the\r\ncycloidal motion type achieves this corollary, but it comes at a cost. It produces an acceleration and velocity that is\r\ntypically higher than the other motion types. More motion types are to come later (hopefully).\r\n\r\n## Problem Statement\r\n\r\nDesign a cam using cycloidal motion that has the following motion description:\r\n\r\n* Dwell at zero displacement for 90 degrees\r\n* Rise 1 inch in 90 degrees\r\n* Dwell for 90 degrees\r\n* Fall 1 inch in 90 degrees\r\n\r\nThe cam's angular velocity is 2*pi radians per second. Show the SVAJ diagram as well as the cam's profile. Size the cam\r\nfor a roller follower with a radius of 1/2\" with a maximum pressure angle of 30 degrees. Also size the cam for a flat\r\nfaced follower. Get an animation for both a roller/flat faced follower. Finally, save the coordinates of the profile to\r\na text file and show the steps for creating a part in SolidWorks.\r\n\r\n## Solution\r\n\r\nBegin by creating a cam object with the correct motion description.\r\n\r\n```python\r\nimport numpy as np\r\nfrom mechanism import Cam\r\nimport matplotlib.pyplot as plt\r\n\r\ncam = Cam(motion=[\r\n    ('Dwell', 90),\r\n    ('Rise', 1, 90),\r\n    ('Dwell', 90),\r\n    ('Fall', 1, 90)\r\n], degrees=True, omega=2*np.pi)\r\n```\r\n\r\nThe motion description is a list of tuples. Each tuple must contain 3 items for rising and falling and two items for\r\ndwelling. The first item of the tuple is a string equal to \"Rise\", \"Fall\", or \"Dwell\" (not case-sensitive). For rise and\r\nfall motion, the second item in the tuple is the distance at which the follower falls or rises. For dwelling, the second\r\nitem in the tuple is either the time (in seconds) or angle (in degrees) for which the displacement remains constant. The\r\nthird item in the tuple for rising and falling is equivalent to the second item for dwelling. If degrees is set to true,\r\nthen the last item in each tuple is interpreted as the angle for which the action occurs. A manual input for the angular\r\nvelocity is then required if conducting further analysis via SVAJ.\r\n\r\nThis is all that's required to call the following methods.\r\n\r\n```python\r\nfig1, ax1 = cam.plot(kind='all')\r\nfig2, ax2 = cam.svaj(kind='cycloidal')\r\nplt.show()\r\n```\r\n\r\nThis produces the following:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/displacement_plot.png)\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/svaj.png)\r\n\r\nLooking at the acceleration plot, there are no vertical lines. This means that there is no infinite derivative at any\r\ninstant along the cam's profile; the jerk function is finite across each instant, making this an acceptable motion type.\r\n\r\nIf a roller follower with a 1/2\" radius is desired, an analysis depending on the cam's radius of curvature and pressure\r\nangle can be conducted to determine the base circle of the cam.\r\n\r\n```python\r\nroller_analysis = cam.get_base_circle(kind='cycloidal', follower='roller', roller_radius=1/2, max_pressure_angle=30,\r\n                                      plot=True)\r\nfig3, ax3 = cam.profile(kind='cycloidal', base=roller_analysis['Rb'], show_base=True, roller_radius=1/2,\r\n                        show_pitch=True)\r\nplt.show()\r\n```\r\n\r\nOutput:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/pressure_angle.png)\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/roller_profile.png)\r\n\r\nFor a flat faced follower, the radius of curvature at the point of contact should be positive (or greater than 0.25\")\r\nfor all theta. There is an option to return the base radius such that the radius of curvature of the cam's profile is\r\npositive for all values of theta (this is the conservative approach).\r\n\r\n```python\r\nflat_analysis = cam.get_base_circle(kind='cycloidal', follower='flat', desired_min_rho=0.25)\r\nprint(flat_analysis['Rb'])\r\nprint(flat_analysis['Min Face Width'])\r\nfig4, ax4 = cam.profile(kind='cycloidal', base=flat_analysis['Rb'], show_base=True)\r\nplt.show()\r\n```\r\n\r\nOutput:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/flat_profile.png)\r\n\r\nThe base circle radius was found to be 1.893\" and the minimum face width for the follower was found to be 2.55\".\r\n\r\nTo get the roller animation, call this:\r\n\r\n```python\r\nani, fig5, ax5, follower = cam.get_animation(kind='cycloidal', base=roller_analysis['Rb'], roller_radius=1/2, length=2,\r\n                                             width=3/8, inc=5)\r\nfig6, ax6 = follower.plot()\r\nplt.show()\r\n```\r\n\r\nOutput:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam_roller.gif)\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/roller_follower_displacement.png)\r\n\r\nThe graph above shows the actual follower displacement due to the circle having to always be tangent to the surface of\r\nthe cam. Note that as a result of this physical limitation, the follower will have higher magnitudes of velocity and\r\nacceleration.\r\n\r\nFor the flat faced follower,\r\n\r\n```python\r\nani_flat, fig7, ax7, follower = cam.get_animation(kind='cycloidal', base=flat_analysis['Rb'], face_width=2.75, length=2,\r\n                                                  width=3/8, inc=5)\r\nfig8, ax8 = follower.plot()\r\nplt.show()\r\n```\r\n\r\nOutput:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/cam_flat.gif)\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/flat_follower_displacement.png)\r\n\r\n### Getting Coordinates into SolidWorks\r\n\r\nSave the coordinates to a text file.\r\n\r\n```python\r\ncam.save_coordinates('cam_coordinates.txt', kind='cycloidal', base=1.3, solidworks=True)\r\n```\r\n\r\nSelect `Curve Through XYZ Points`\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/curve_xyz.png)\r\n\r\nThe cam profile will always be extended to the front plane due to the manner in which SolidWorks defines the global\r\ncoordinates. Next, select browse and choose the saved coordinate file, making sure that text files are able to be seen.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/select_file.PNG)\r\n\r\nCreate a sketch on the front plane. Select the curve and then convert entities. The sketch is now projected to the front\r\nplane.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/front_plane.PNG)\r\n\r\nNotice that the sketch is not closed. Add a line to close the sketch, then extrude the sketch.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/solidworks_cam.PNG)\r\n\r\n# Gears\r\n\r\nTo use this feature, a knowledge of gear nomenclature must be known. Here is a figure from Robert Norton's *Design of\r\nMachinery*:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear_nomenclature.PNG)\r\n\r\nFor gears, a general rule of thumb is that the base circle must fall below the dedendum circle because the curve below\r\nbase circle cannot be an involute curve. This package will send a warning if this occurs, and if it is desired to\r\ncontinue, the curve below the circle is just a straight line, and undercutting will occur.\r\n\r\nFor a reference, here are the AGMA (American Gear Manufacturers Association) standards from *Design of Machinery*:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/agma.PNG)\r\n\r\n## Problem Statement\r\n\r\nDesign a gear that has a diametral pitch of 32 and has 60 teeth using `mechanism`. The gear follows the AGMA standards.\r\nCompare the gear to SolidWorks' gear from the tool library.\r\n\r\n## Solution\r\n\r\nDefine a gear object with the known information and save the coordinates to a file.\r\n\r\n```python\r\nfrom mechanism import SpurGear\r\nimport matplotlib.pyplot as plt\r\n\r\ngear = SpurGear(N=60, pd=32, agma=True, size=500)\r\nfig, ax = gear.plot()\r\nfig.savefig('../images/gear60.PNG', dpi=240)\r\nplt.show()\r\ngear.save_coordinates(file='gear_tooth_coordinates.txt', solidworks=True)\r\ngear.rundown()\r\n```\r\n\r\noutput:\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear60.PNG)\r\n\r\n| Property                 | Value    |\r\n|--------------------------|----------|\r\n| Number of Teeth (N)      | 60       |\r\n| Diametral Pitch (pd)     | 32.00000 |\r\n| Pitch Diameter (d)       | 1.87500  |\r\n| Pitch Radius (r)         | 0.93750  |\r\n| Pressure Angle (phi)     | 20.00000 |\r\n| Base Radius              | 0.88096  |\r\n| Addendum (a)             | 0.03125  |\r\n| Dedendum (b)             | 0.03906  |\r\n| Circular Tooth Thickness | 0.04846  |\r\n| Circular Space Width     | 0.04971  |\r\n| Circular Backlash        | 0.00125  |\r\n\r\nKeep in mind that the `size` argument refers to the size of the coordinates that make up the involute curve. The more\r\npoints, the sharper it is, but SolidWorks sometimes struggles with points being too close together. To fix this issue,\r\nmake the size smaller. The default value is 1000.\r\n\r\n### SolidWorks Results\r\n\r\nFollow the same steps to get the curve into SolidWorks from the cam example. Make sure that the units in SolidWorks\r\nmatches the units of the analysis.\r\n\r\n![image not found](https://github.com/gabemorris12/mechanism/raw/master/images/gear60_compare.PNG)\r\n\r\nThe results are a near identical match, and the addendum and dedendum fit perfectly. If analyzed closely, the only difference is the tooth thickness. The gray gear\r\n(the resulting gear from this package) has a slightly larger tooth thickness compared to SolidWorks' gear. This is due\r\nto the fact that SolidWorks doesn't use an involute gear tooth profile, as gears from the SolidWorks toolbox are for \r\nvisuals only. Instead, the tooth profile is circular. Their gears should not be used for manufacturing as this is not \r\naccurate at all. The purpose of the involute tooth profile is that the meshing of gears will always produce a constant \r\nangular velocity, even when the gears aren't perfectly placed tangent to the pitch circles.\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/gabemorris12/mechanism",
    "keywords": "mechanism,kinematic,cams,linkages,analysis,animations",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mechanism",
    "package_url": "https://pypi.org/project/mechanism/",
    "platform": null,
    "project_url": "https://pypi.org/project/mechanism/",
    "project_urls": {
      "Homepage": "https://github.com/gabemorris12/mechanism"
    },
    "release_url": "https://pypi.org/project/mechanism/1.1.4/",
    "requires_dist": [
      "matplotlib",
      "scipy"
    ],
    "requires_python": "",
    "summary": "A package that provides a kinematic analysis of mechanisms and cams and custom tooth profile for spur gears.",
    "version": "1.1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16533483,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8086ebac9c576323471d86a449c497113732691b253aebd940f1262a41a772a1",
        "md5": "6d1225cbc88109ecc1a8d623ed5149e4",
        "sha256": "8286112dc4be4f4b72f4c171d5cecb2678881b81834f69d34d494ca1c3bf52fc"
      },
      "downloads": -1,
      "filename": "mechanism-1.1.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6d1225cbc88109ecc1a8d623ed5149e4",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 35714,
      "upload_time": "2023-01-23T14:50:55",
      "upload_time_iso_8601": "2023-01-23T14:50:55.364664Z",
      "url": "https://files.pythonhosted.org/packages/80/86/ebac9c576323471d86a449c497113732691b253aebd940f1262a41a772a1/mechanism-1.1.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "51309e4572cebe7b6b8aac4358de2d38d51604d19a2ccc7dca39536c20cad8d8",
        "md5": "a5130e72f9c8cc007c6716339f7a3397",
        "sha256": "8edc79d2bd8e7e6eedc61337231a0977a6a31e4e191bf1733aef7c395e480eb9"
      },
      "downloads": -1,
      "filename": "mechanism-1.1.4.tar.gz",
      "has_sig": false,
      "md5_digest": "a5130e72f9c8cc007c6716339f7a3397",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 39375,
      "upload_time": "2023-01-23T14:50:57",
      "upload_time_iso_8601": "2023-01-23T14:50:57.775663Z",
      "url": "https://files.pythonhosted.org/packages/51/30/9e4572cebe7b6b8aac4358de2d38d51604d19a2ccc7dca39536c20cad8d8/mechanism-1.1.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}