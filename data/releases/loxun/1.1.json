{
  "info": {
    "author": "Thomas Aglassinger",
    "author_email": "roskakori@users.sourceforge.net",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Plugins",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2.5",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
      "Topic :: Software Development :: Libraries",
      "Topic :: Text Processing :: Markup :: XML"
    ],
    "description": "loxun is a Python module to write large output in XML using Unicode and\r\nnamespaces. Of course you can also use it for small XML output with plain 8\r\nbit strings and no namespaces.\r\n\r\nloxun's features are:\r\n\r\n* **small memory foot print**: the document is created on the fly by writing to\r\n  an output stream, no need to keep all of it in memory.\r\n\r\n* **easy to use namespaces**: simply add a namespace and refer to it using the\r\n  standard ``namespace:tag`` syntax.\r\n\r\n* **mix unicode and string**: pass both unicode or plain 8 bit strings to any\r\n  of the methods. Internally loxun converts them to unicode, so once a\r\n  parameter got accepted by the API you can rely on it not causing any\r\n  messy ``UnicodeError`` trouble.\r\n\r\n* **automatic escaping**: no need to manually handle special characters such\r\n  as ``<`` or ``&`` when writing text and attribute values.\r\n\r\n* **robustness**: while you write the document, sanity checks are performed on\r\n  everything you do. Many silly mistakes immediately result in an\r\n  ``XmlError``, for example missing end elements or references to undeclared\r\n  namespaces.\r\n\r\n* **open source**: distributed under the GNU Lesser General Public License 3\r\n  or later.\r\n\r\nHere is a very basic example. First you have to create an output stream. In\r\nmany cases this would be a file, but for the sake of simplicity we use a\r\n``StringIO`` here:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n\r\nThen you can create an `XmlWriter` to write to this output:\r\n\r\n    >>> xml = XmlWriter(out)\r\n\r\nNow write the content:\r\n\r\n    >>> xml.addNamespace(\"xhtml\", \"http://www.w3.org/1999/xhtml\")\r\n    >>> xml.startTag(\"xhtml:html\")\r\n    >>> xml.startTag(\"xhtml:body\")\r\n    >>> xml.text(\"Hello world!\")\r\n    >>> xml.tag(\"xhtml:img\", {\"src\": \"smile.png\", \"alt\": \":-)\"})\r\n    >>> xml.endTag()\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n\r\nAnd the result is:\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <xhtml:html xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\r\n      <xhtml:body>\r\n        Hello world!\r\n        <xhtml:img alt=\":-)\" src=\"smile.png\" />\r\n      </xhtml:body>\r\n    </xhtml:html>\r\n\r\nWriting a simple document\r\n=========================\r\n\r\nThe following example creates a very simple XHTML document.\r\n\r\nTo make it simple, the output goes to a string, but you could also use\r\na file that has been created using\r\n``codecs.open(filename, \"wb\", encoding)``.\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n\r\nFirst create an `XmlWriter` to write the XML code to the specified output:\r\n\r\n    >>> xml = XmlWriter(out)\r\n\r\nThis automatically adds the XML prolog:\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\r\nNext add the ``<html>`` start tag:\r\n\r\n    >>> xml.startTag(\"html\")\r\n\r\nNow comes the <body>. To pass attributes, specify them in a dictionary.\r\nSo in order to add::\r\n\r\n    <body id=\"top\">\r\n\r\nuse:\r\n\r\n    >>> xml.startTag(\"body\", {\"id\": \"top\"})\r\n\r\nLet' add a little text so there is something to look at:\r\n\r\n    >>> xml.text(\"Hello world!\")\r\n\r\nWrap it up: close all elements and the document.\r\n\r\n    >>> xml.endTag()\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n\r\nAnd this is what we get:\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <html>\r\n      <body id=\"top\">\r\n        Hello world!\r\n      </body>\r\n    </html>\r\n\r\nSpecifying attributes\r\n\r\nFirst create a writer:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out)\r\n\r\nNow write the content:\r\n\r\n    >>> xml.tag(\"img\", {\"src\": \"smile.png\", \"alt\": \":-)\"})\r\n\r\nAttribute values do not have to be strings, other types will be converted to\r\nUnicode using Python's ``unicode()`` function:\r\n\r\n    >>> xml.tag(\"img\", {\"src\": \"wink.png\", \"alt\": \";-)\", \"width\": 32, \"height\": 24})\r\n\r\nAnd the result is:\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <img alt=\":-)\" src=\"smile.png\" />\r\n    <img alt=\";-)\" height=\"24\" src=\"wink.png\" width=\"32\" />\r\n\r\nUsing namespaces\r\n================\r\n\r\nNow the same thing but with a namespace. First create the prolog\r\nand header like above:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out)\r\n\r\nNext add the namespace:\r\n\r\n    >>> xml.addNamespace(\"xhtml\", \"http://www.w3.org/1999/xhtml\")\r\n\r\nNow elements can use qualified tag names using a colon (:) to separate\r\nnamespace and tag name:\r\n\r\n    >>> xml.startTag(\"xhtml:html\")\r\n    >>> xml.startTag(\"xhtml:body\")\r\n    >>> xml.text(\"Hello world!\")\r\n    >>> xml.endTag()\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n\r\nAs a result, tag names are now prefixed with \"xhtml:\":\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <xhtml:html xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\r\n      <xhtml:body>\r\n        Hello world!\r\n      </xhtml:body>\r\n    </xhtml:html>\r\n\r\nWorking with non ASCII characters\r\n=================================\r\n\r\nSometimes you want to use characters outside the ASCII range, for example\r\nGerman Umlauts, the Euro symbol or Japanese Kanji. The easiest and performance\r\nwise best way is to use Unicode strings. For example:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, prolog=False)\r\n    >>> xml.text(u\"The price is \\\\u20ac 100\") # Unicode of Euro symbol\r\n    >>> out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    'The price is \\\\xe2\\\\x82\\\\xac 100'\r\n\r\nNotice the \"u\" before the string passed to `XmlWriter.text()`, it declares the\r\nstring to be a unicode string that can hold any character, even those that are\r\nbeyond the 8 bit range.\r\n\r\nAlso notice that in the output the Euro symbol looks very different from the\r\ninput. This is because the output encoding is UTF-8 (the default), which\r\nhas the advantage of keeping all ASCII characters the same and turning any\r\ncharacters with a code of 128 or more into a sequence of 8 bit bytes that\r\ncan easily fit into an output stream to a binary file or ``StringIO``.\r\n\r\nIf you have to stick to classic 8 bit string parameters, loxun attempts to\r\nconvert them to unicode. By default it assumes ASCII encoding, which does\r\nnot work out as soon as you use a character outside the ASCII range:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, prolog=False)\r\n    >>> xml.text(\"The price is \\\\xa4 100\") # ISO-8859-15 code of Euro symbol\r\n    Traceback (most recent call last):\r\n        ...\r\n    UnicodeDecodeError: 'ascii' codec can't decode byte 0xa4 in position 13: ordinal not in range(128)\r\n\r\nIn this case you have to tell the writer the encoding you use by specifying\r\nthe the ``sourceEncoding``:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, prolog=False, sourceEncoding=\"iso-8859-15\")\r\n\r\nNow everything works out again:\r\n\r\n    >>> xml.text(\"The price is \\\\xa4 100\") # ISO-8859-15 code of Euro symbol\r\n    >>> out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    'The price is \\\\xe2\\\\x82\\\\xac 100'\r\n\r\nOf course in practice you will not mess around with hex codes to pass your\r\ntexts. Instead you just specify the source encoding using the mechanisms\r\ndescribed in PEP 263,\r\n`Defining Python Source Code Encodings <http://www.python.org/dev/peps/pep-0263/>`_.\r\n\r\nPretty printing and indentation\r\n===============================\r\n\r\nBy default, loxun starts a new line for each ``startTag`` and indents the\r\ncontent with two spaces. You can change the spaces to any number of spaces and\r\ntabs you like:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, indent=\"    \") # <-- Indent with 4 spaces.\r\n    >>> xml.startTag(\"html\")\r\n    >>> xml.startTag(\"body\")\r\n    >>> xml.text(\"Hello world!\")\r\n    >>> xml.endTag()\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <html>\r\n        <body>\r\n            Hello world!\r\n        </body>\r\n    </html>\r\n\r\nYou can disable pretty printing all together using ``pretty=False``, resulting\r\nin an output of a single large line:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, pretty=False) # <-- Disable pretty printing.\r\n    >>> xml.startTag(\"html\")\r\n    >>> xml.startTag(\"body\")\r\n    >>> xml.text(\"Hello world!\")\r\n    >>> xml.endTag()\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?><html><body>Hello world!</body></html>\r\n\r\nChanging the XML prolog\r\n=======================\r\n\r\nWhen you create a writer, it automatically write an XML prolog\r\nprocessing instruction to the output. This is what the default prolog\r\nlooks like:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out)\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\r\nYou can change the version or encoding:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, encoding=u\"ascii\", version=u\"1.1\")\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.1\" encoding=\"ascii\"?>\r\n\r\nTo completely omit the prolog, set the parameter ``prolog=False``:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out, prolog=False)\r\n    >>> out.getvalue()\r\n    ''\r\n\r\nAdding other content\r\n====================\r\n\r\nApart from text and tags, XML provides a few more things you can add to\r\ndocuments. Here's an example that shows how to do it with loxun.\r\n\r\nFirst, create a writer:\r\n\r\n    >>> from StringIO import StringIO\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out)\r\n\r\nLet's add a document type definition:\r\n\r\n    >>> xml.raw(\"<!DOCTYPE html PUBLIC \\\\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\\\" SYSTEM \\\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\\\">\")\r\n    >>> xml.newline()\r\n    \r\nNotice that loxun uses the generic `XmlWriter.raw()` for that, which allows to\r\nadd any content without validation or escaping. You can do all sorts of nasty\r\nthings with ``raw()`` that will result in invalid XML, but this is one of its\r\nreasonable uses.\r\n\r\nNext, let's add a comment:\r\n\r\n    >>> xml.comment(\"Show case some rarely used XML constructs\")\r\n\r\nHere is a processing instruction:\r\n\r\n    >>> xml.processingInstruction(\"xml-stylesheet\", \"href=\\\\\"default.css\\\\\" type=\\\\\"text/css\\\\\"\")\r\n\r\nAnd finally a CDATA section:\r\n\r\n    >>> xml.cdata(\">> this will not be parsed <<\")\r\n\r\nAnd the result is:\r\n\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" SYSTEM \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\r\n    <!-- Show case some rarely used XML constructs -->\r\n    <?xml-stylesheet href=\"default.css\" type=\"text/css\"?>\r\n    <![CDATA[>> this will not be parsed <<]]>\r\n\r\n\r\nOptimization\r\n============\r\n\r\nLoxun automatically optimized pairs of empty start/end tags. For example:\r\n\r\n    >>> out = StringIO()\r\n    >>> xml = XmlWriter(out)\r\n    >>> xml.startTag(\"customers\")\r\n    >>> xml.startTag(\"person\", {\"id\": \"12345\", \"name\": \"Doe, John\"})\r\n    >>> xml.endTag(\"person\") # without optimization, this would add </person>.\r\n    >>> xml.endTag()\r\n    >>> xml.close()\r\n    >>> print out.getvalue().rstrip(\"\\\\r\\\\n\")\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <customers>\r\n      <person id=\"12345\" name=\"Doe, John\" />\r\n    </customers>\r\n\r\nDespite the explicit ``startTag(\"person\")`` and matching ``endtag()``, the\r\noutput only contains a simple ``<person ... />`` tag.\r\n\r\nContributing\r\n------------\r\n\r\nIf you want to help improve loxun, you can access the source code at \r\n<http://github.com/roskakori/loxun>.\r\n\r\nFuture\r\n======\r\n\r\nCurrently loxun does what it was built for.\r\n\r\nThere are is no real plans to improve it in the near future, but here is a list\r\nof features that might be added at some point:\r\n\r\n* Add validation of tag and attribute names to ensure that all characters used\r\n  are allowed. For instance, currently loxun does not complain about a tag\r\n  named \"a#b*c$d_\".\r\n* Raise an `XmlError` when namespaces are added with attributes instead of\r\n  `XmlWriter.addNamespace()`.\r\n* Logging support to simplify debugging of the calling code. Probably\r\n  `XmlWriter` would get a property ``logger`` which is a standard\r\n  ``logging.Logger``. By default it could log original exceptions that\r\n  loxun turns into an `XmlError` and namespaces opened and closed.\r\n  Changing it to ``logging.DEBUG`` would log each tag and XML construct\r\n  written, including additional information about the internal tag stack.\r\n  That way you could dynamically increase or decrease logging output.\r\n* Rethink pretty printing. Instead of a global property that can only be set\r\n  when initializing an `XmlWriter`, it could be a optional parameter for\r\n  `XmlWriter.startTag()` where it could be turned on and off as needed. And\r\n  the property could be named ``literal`` instead of ``pretty`` (with an\r\n  inverse logic). \r\n* Add a ``DomWriter`` that creates a ``xml.dom.minidom.Document``.\r\n\r\nSome features other XML libraries support but I never saw any real use for:\r\n\r\n* Specify attribute order for tags.\r\n\r\nVersion history\r\n===============\r\n\r\nVersion 1.1, 08-Jan-2011\r\n\r\n* Fixed ``AssertionError`` when ``pretty`` was set to ``False``\r\n  (issue #1; fixed by David Cramer).\r\n\r\nVersion 1.0, 11-Oct-2010\r\n\r\n* Added support for Python's ``with`` so you don not have to manually call\r\n  `XmlWriter.close()` anymore.\r\n* Added Git repository at <http://github.com/roskakori/loxun>.\r\n\r\nVersion 0.8, 11-Jul-2010\r\n\r\n* Added possibility to pass attributes to `XmlWriter.startTag()` and\r\n  `XmlWriter.tag()` with values that have other types than ``str`` or\r\n  ``unicode``. When written to XML, the value is converted using Python's\r\n  built-in ``unicode()`` function.\r\n* Added a couple of files missing from the distribution, most important the\r\n  test suite.\r\n\r\nVersion 0.7, 03-Jul-2010\r\n\r\n* Added optimization of matching start and end tag without any content in\r\n  between. For example, ``x.startTag(\"some\"); x.endTag()`` results in\r\n  ``<some />`` instead of ``<some></some>``.\r\n* Fixed handling of unknown name spaces. They now raise an `XmlError` instead\r\n   of ``ValueError``. \r\n\r\nVersion 0.6, 03-Jun-2010\r\n\r\n* Added option ``indent`` to specify the indentation text each new line starts with.\r\n* Added option ``newline`` to specify how lines written should end.\r\n* Fixed that `XmlWriter.tag()` did not remove namespaces declared immediately\r\n  before it. \r\n* Cleaned up documentation.\r\n\r\nVersion 0.5, 25-May-2010\r\n\r\n* Fixed typo in namespace attribute name.\r\n* Fixed adding of namespaces before calls to `XmlWriter.tag()` which resulted\r\n  in an `XmlError`.\r\n\r\nVersion 0.4, 21-May-2010\r\n\r\n* Added option ``sourceEncoding`` to simplify processing of classic strings.\r\n  The manual section \"Working with non ASCII characters\" explains how to use\r\n  it.\r\n\r\nVersion 0.3, 17-May-2010\r\n\r\n* Added scoped namespaces which are removed automatically by\r\n  `XmlWriter.endTag()`.\r\n* Changed ``text()`` to normalize newlines and white space if pretty printing\r\n  is enabled.\r\n* Moved writing of XML prolog to the constructor and removed\r\n  ``XmlWriter.prolog()``. To omit the prolog, specify ``prolog=False`` when\r\n  creating the `XmlWriter`. If you later want to write the prolog yourself,\r\n  use `XmlWriter.processingInstruction()`.\r\n* Renamed ``*Element()`` to ``*Tag`` because they really only write tags, not\r\n  whole elements.\r\n\r\nVersion 0.2, 16-May-2010\r\n\r\n* Added `XmlWriter.comment()`, `XmlWriter.cdata()` and\r\n  `XmlWriter.processingInstruction()` to write these specific XML constructs.\r\n* Added indentation and automatic newline to text if pretty printing is\r\n  enabled.\r\n* Removed newline from prolog in case pretty printing is disabled.\r\n* Fixed missing \"?\" in prolog.\r\n\r\nVersion 0.1, 15-May-2010\r\n\r\n* Initial release.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://pypi.python.org/pypi/loxun/",
    "keywords": "xml output stream large big huge namespace unicode memory footprint",
    "license": "GNU Lesser General Public License 3 or later",
    "maintainer": "",
    "maintainer_email": "",
    "name": "loxun",
    "package_url": "https://pypi.org/project/loxun/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/loxun/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "http://pypi.python.org/pypi/loxun/"
    },
    "release_url": "https://pypi.org/project/loxun/1.1/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "large output in XML using unicode and namespaces",
    "version": "1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1171404,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f9a0cb7aa1619a1cef58c4fe465bccb4a32818aa6704299cb67c435a7e91b9bf",
        "md5": "6b36324b705995e516c0534749addd22",
        "sha256": "781deb3c46010a69a05b49f4dffeb188490dfa45737f848027eb9190c8c8935f"
      },
      "downloads": -1,
      "filename": "loxun-1.1.zip",
      "has_sig": false,
      "md5_digest": "6b36324b705995e516c0534749addd22",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 26220,
      "upload_time": "2011-01-08T11:16:58",
      "upload_time_iso_8601": "2011-01-08T11:16:58.577065Z",
      "url": "https://files.pythonhosted.org/packages/f9/a0/cb7aa1619a1cef58c4fe465bccb4a32818aa6704299cb67c435a7e91b9bf/loxun-1.1.zip",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}