{
  "info": {
    "author": "Lele Gaifax",
    "author_email": "lele@metapensiero.it",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.3",
      "Topic :: Database"
    ],
    "description": "=============================\n metapensiero.sphinx.patchdb\n=============================\n\nCollects and applies scripts embedded in a reST document\n========================================================\n\n:version: 1.1.0\n:author: Lele Gaifax <lele@metapensiero.it>\n:license: GPLv3\n\nBuilding and maintaining the schema of a database is always a\nchallenge. It may quickly become a nightmare when dealing with even\nmoderately complex databases, in a distribuited development\nenvironment. You have new features going in, and fixes here and there,\nthat keeps accumulating in the development `branch`. You also have\nseveral already deployed instances of the database you wanna upgrade\nnow and then.\n\nIn my experience, it's very difficult to impossible to come up with a\ncompletely automated solution, for several reasons:\n\n* comparison between different releases of a database schema is tricky\n* actual contents of the database must be preserved\n* some changes require specific recipes to upgrade the data\n* any automated solution hide some detail, by definition: I need\n  complete control, to be able to create temporary tables and/or\n  procedures for example\n\nI tried, and wrote myself, several different approaches to the\nproblem, and this package is my latest and most satisfying effort: it\nbuilds on top of `docutils`_ and `Sphinx`_, with the side advantage\nthat you get a quite nice and good documentation of the whole\narchitecture: `literate database scheming`!\n\n.. _docutils: http://docutils.sourceforge.net/\n.. _sphinx: http://sphinx.pocoo.org/intro.html\n\nHow it works\n------------\n\nThe package contains two distinct pieces: a `Sphinx`_ extension and\nthe ``patchdb`` command line tool.\n\nThe extension implements a new `ReST` directive able to embed a\n`script` in the document: when processed by the ``sphinx-build`` tool,\nall the scripts will be collected in an external file, configurable.\n\nThe ``patchdb`` tool takes that script collection and determines which\nscripts need to be applied to some database, and the right order.\n\nIt keeps and maintains a single very simple table within the database,\nwhere it records the last version of each script it successfully\nexecute, so that it won't reexecute the same script (actually, a\nparticular `revision` of it) twice.\n\nSo, on the development side you simply write (and document!) each\npiece, and when it comes the time of deploying current state you\ndistribute just the script collection (a single file, usually in\n`YAML`_ or `JSON`_ format, or a ``pickle`` archive) to the end points\nwhere the database instances live, and execute ``patchdb`` against\neach one.\n\n.. _yaml: http://yaml.org/\n.. _json: http://json.org/\n\nScripts\n~~~~~~~\n\nThe basic building block is a `script`, an arbitrary sequence of\nstatements written in some language (currently, either ``Python``,\n``SQL`` or ``Shell``), augmented with some metadata such as the\n`scriptid`, possibly a longer `description`, its `revision` and so on.\n\nAs a complete example of the syntax, consider the following::\n\n  .. patchdb:script:: My first script\n     :description: Full example of a script\n     :revision: 2\n     :depends: Other script@4\n     :preceeds: Yet another\n     :language: python\n     :conditions: python_2_x\n\n     print \"Yeah!\"\n\nThis will introduce a script globally identified by `My first script`,\nwritten in ``Python``: this is its second release, and its execution\nmust be constrained such that it happens **after** the execution of the\nfourth revision of `Other script` and **before** `Yet another`.\n\nThe example shows also an usage of the conditions, allowing more than\none variant of a script like::\n\n  .. patchdb:script:: My first script (py3)\n     :description: Full example of a script\n     :revision: 2\n     :depends: Other script@4\n     :preceeds: Yet another\n     :language: python\n     :conditions: python_3_x\n\n     print(\"Yeah!\")\n\nThe dependencies may be a comma separated list of script ids, such\nas::\n\n  .. patchdb:script:: Create master table\n\n     CREATE TABLE some_table (id INTEGER PRIMARY KEY, tt_id INTEGER)\n\n  .. patchdb:script:: Create target table\n\n     CREATE TABLE target_table (id INTEGER PRIMARY KEY)\n\n  .. patchdb:script:: Add foreign key to some_table\n     :depends: Create master table, Create target table\n\n     ALTER TABLE some_table\n           ADD CONSTRAINT fk_master_target\n               FOREIGN KEY (tt_id) REFERENCES target_table (id)\n\nIndependently from the order these scripts appear in the\ndocumentation, the third script will execute only after the first two\nget successfully applied to the database. As you can notice, most of\nthe options are optional: by default, ``:language:`` is ``sql``,\n``:revision:`` is ``1``, the ``:description:`` is taken from the title\n(that is, the script ID), while ``:depends:`` and ``:preceeds:`` are\nempty.\n\nJust for illustration\npurposes, the same effect could be achieved with::\n\n  .. patchdb:script:: Create master table\n     :preceeds: Add foreign key to some_table\n\n     CREATE TABLE some_table (id INTEGER PRIMARY KEY, tt_id INTEGER)\n\n  .. patchdb:script:: Create target table\n\n     CREATE TABLE target_table (id INTEGER PRIMARY KEY)\n\n  .. patchdb:script:: Add foreign key to some_table\n     :depends: Create target table\n\n     ALTER TABLE some_table\n           ADD CONSTRAINT fk_master_target\n               FOREIGN KEY (tt_id) REFERENCES target_table (id)\n\nPatches\n~~~~~~~\n\nA `patch` is a particular flavour of script, one that specify a\n`brings` dependency list. Imagine that the example above was the first\nversion of the database, and that the current version looks like the\nfollowing::\n\n  .. patchdb:script:: Create master table\n     :revision: 2\n\n     CREATE TABLE some_table (\n       id INTEGER PRIMARY KEY,\n       description VARCHAR(80),\n       tt_id INTEGER\n     )\n\nthat is, ``some_table`` now contains one more field, ``description``.\n\nWe need an upgrade path from the first revision of the table to the\nsecond::\n\n  .. patchdb:script:: Add a description to the master table\n     :depends: Create master table@1\n     :brings: Create master table@2\n\n     ALTER TABLE some_table ADD COLUMN description VARCHAR(80)\n\nWhen ``patchdb`` examines the database status, it will execute one\n*or* the other. If the script `Create master table` isn't executed yet\n(for example when operating on a new database), it will take the\nformer script (the one that creates the table from scratch).\nOtherwise, if the database \"contains\" revision 1 (and not higher\nthan 1) of the script, it will execute the latter, bumping up the\nrevision number.\n\nUsage\n-----\n\nTo use it, first of all you must register the extension within the\nSphinx environment, adding the full name of the package to the\n``extensions`` list in the file ``conf.py``, for example::\n\n    # Add any Sphinx extension module names here, as strings.\n    extensions = ['metapensiero.sphinx.patchdb']\n\nThe other required bit of customization is the location of the `on\ndisk scripts storage`, i.e. the path of the file that will contain the\ninformation about every found script: this is kept separated from the\ndocumentation itself because you will probably deploy on production\nservers just to update their database. If the filename ends with\n``.json`` it will contain a JSON formatted array, if it ends with\n``.yaml`` the information will be dumped in YAML, otherwise it will be\na Python ``pickle``. I usually prefer JSON or YAML, because those\nformats are more VCs friendly and open to human inspection.\n\nThe location may be set in the same ``conf.py`` as above, like::\n\n    # Location of the external storage\n    patchdb_storage = 'â€¦/dbname.json'\n\nOtherwise, you can set it using the ``-D`` option of the\n``sphinx-build`` command, so that you can easily share its definition\nwith other rules in a ``Makefile``. I usually put the following\nsnippet at the beginning of the ``Makefile`` created by\n``sphinx-quickstart``::\n\n    TOPDIR ?= ..\n    STORAGE ?= $(TOPDIR)/database.json\n\n    SPHINXOPTS = -D patchdb_storage=$(STORAGE)\n\nso that I can have the following in the outer ``Makefile``::\n\n    export TOPDIR := $(CURDIR)\n    DBHOST := localhost\n    DBPORT := 5432\n    DBNAME := dbname\n    DROPDB := dropdb --host=$(DBHOST) --port=$(DBPORT)\n    CREATEDB := createdb --host=$(DBHOST) --port=$(DBPORT) --encoding=UTF8\n    STORAGE := $(TOPDIR)/$(DBNAME).json\n    DSN := host=$(DBHOST) port=$(DBPORT) dbname=$(DBNAME)\n    PUP := $(PATCHDB) --patch-storage=$(STORAGE) \\\n                      --postgres=\"$(DSN)\" --log-file=$(DBNAME).log\n\n    # Build the Sphinx documentation\n    doc:\n            $(MAKE) -C doc STORAGE=$(STORAGE) html\n\n    $(STORAGE): doc\n\n    # Show what is missing\n    missing-patches: $(STORAGE)\n            $(PUP) --dry-run\n\n    # Upgrade the database to the latest revision\n    database: $(STORAGE)\n            $(PUP)\n\n    # Remove current database and start from scratch\n    scratch-database:\n            -$(DROPDB) $(DBNAME)\n            $(CREATEDB) $(DBNAME)\n            $(MAKE) database\n\n\nChanges\n-------\n\n1.1.0 (unreleased)\n~~~~~~~~~~~~~~~~~~\n\n* Use setuptools instead of distribute\n\n* Use argparse instead of optparse\n\n* New mimetype property on scripts, to select the right Pygments highlighter\n\n* New MySQL specific context, using cymysql\n\n\n1.0.7 (2013-08-23)\n~~~~~~~~~~~~~~~~~~\n\n* published on bitbucket\n\n\n1.0.6 (2013-03-12)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady: ability to load field values from external files\n\n\n1.0.5 (2013-03-11)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady: fix encoding error when printing messages coming from PostgresQL\n\n* dbloady: emit a progress bar on stderr\n\n\n1.0.4 (2013-02-27)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady, a new utility script, to load base data from a YAML stream.\n\n\n1.0.3 (2012-11-07)\n~~~~~~~~~~~~~~~~~~\n\n* Fix ``:patchdb:script`` role\n\n\n1.0.2 (2012-10-19)\n~~~~~~~~~~~~~~~~~~\n\n* Pickier way to split the multi-statements SQL scripts, now the\n  ``;;`` separator must be on a line by its own\n\n* More precise line number tracking when applying multi-statements SQL\n  scripts\n\n* Dump and load script dependencies and conditions as lists, to avoid\n  pointless repeated splits and joins\n\n\n1.0.1 (2012-10-13)\n~~~~~~~~~~~~~~~~~~\n\n* Fix error loading JSON storage, simplejson already yields unicode strings\n\n* Possibly use the original title of the script as description, if not\n  explicitly set\n\n* More precise error on unknown script reference\n\n* Minor corrections\n\n\n1.0 (2012-10-10)\n~~~~~~~~~~~~~~~~\n\n* Added JSON support for the on disk `scripts storage`\n\n* Adapted to work with SQLAlchemy 0.7.x\n\n* Updated to work with docutils > 0.8\n\n* Refactored as a `Sphinx domain <http://sphinx.pocoo.org/domains.html>`_\n\n  .. attention:: This means that the directive names are now prefixed\n                 with ``patchdb:`` (that is, the old ``script``\n                 directive is now ``patchdb:script``). You can use the\n                 `default-domain`__ directive if that annoys you.\n\n  __ http://sphinx.pocoo.org/domains.html#directive-default-domain\n\n* Renamed the status table from ``prst_applied_info`` to simply\n  ``patchdb``\n\n  .. attention:: This is the main incompatible change with previous\n                 version: you should eventually rename the table\n                 manually, sorry for the inconvenience.\n\n* Renamed ``prst_patch_storage`` configuration setting to\n  ``patchdb_storage``\n\n* Each script ID is now lower case, to avoid ambiguities\n\n\n0.3 (2010-11-14)\n~~~~~~~~~~~~~~~~\n\n* Updated to work with Sphinx 1.0\n\n* New :script: role for cross-references\n\n* New :file: option on script directive, to keep the actual text in an\n  external file\n\n\n0.2 (2010-03-03)\n~~~~~~~~~~~~~~~~\n\n* Compatibility with SQLAlchemy 0.6\n\n* New patchdb command line tool\n\n\n0.1 (2009-10-28)\n~~~~~~~~~~~~~~~~\n\n* Replace home brew solution with SQLAlchemy topological sort\n\n* Use YAML for the persistent storage\n\n* Mostly working Sphinx adaptor\n\n* Rudimentary and mostly untested SQLAlchemy backend (basically only\n  the direct PostgresQL backend has been battle tested in production...)\n\n* First standalone version\n\n\n0.0\n~~~\n\n* still a PylGAM side-product\n\n* simply a set of docutils directives\n\n* started with Firebird in mind, but grown up with PostgresQL",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "UNKNOWN",
    "keywords": null,
    "license": "UNKNOWN",
    "maintainer": null,
    "maintainer_email": null,
    "name": "metapensiero.sphinx.patchdb",
    "package_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "UNKNOWN"
    },
    "release_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/1.1.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Extract scripts from a reST document and apply them in order.",
    "version": "1.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16877674,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2f0523a24da79d6ad904157cfe9c14e037ab6e50d395a648c73518b0c2f639d5",
        "md5": "c42fd004de84d18fdfd8c96e8361174c",
        "sha256": "dcd104cb7c07cba9e86aba74f3e02ffe7bfcccd3f2c955b636585eb5d058063d"
      },
      "downloads": -1,
      "filename": "metapensiero.sphinx.patchdb-1.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "c42fd004de84d18fdfd8c96e8361174c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 25850,
      "upload_time": "2014-06-03T16:01:42",
      "upload_time_iso_8601": "2014-06-03T16:01:42.557562Z",
      "url": "https://files.pythonhosted.org/packages/2f/05/23a24da79d6ad904157cfe9c14e037ab6e50d395a648c73518b0c2f639d5/metapensiero.sphinx.patchdb-1.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}