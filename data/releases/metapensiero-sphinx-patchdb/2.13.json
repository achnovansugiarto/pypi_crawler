{
  "info": {
    "author": "Lele Gaifax",
    "author_email": "lele@metapensiero.it",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Sphinx :: Extension",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Database"
    ],
    "description": ".. -*- coding: utf-8 -*-\n.. :Project:   PatchDB\n.. :Created:   Sat Aug 22 16:19:15 2009 +0000\n.. :Author:    Lele Gaifax <lele@metapensiero.it>\n.. :License:   GNU General Public License version 3 or later\n.. :Copyright: © 2009, 2010, 2012, 2013, 2014, 2015, 2016 Lele Gaifax\n..\n\n=============================\n metapensiero.sphinx.patchdb\n=============================\n\nCollects and applies scripts embedded in a reST document\n========================================================\n\n:version: 2.0\n:author: Lele Gaifax <lele@metapensiero.it>\n:license: GPLv3\n\nBuilding and maintaining the schema of a database is always a challenge. It may quickly become\na nightmare when dealing with even moderately complex databases, in a distribuited development\nenvironment. You have new features going in, and fixes here and there, that keeps accumulating\nin the development `branch`. You also have several already deployed instances of the database\nyou wanna upgrade now and then.\n\nIn my experience, it's very difficult to impossible to come up with a completely automated\nsolution, for several reasons:\n\n* comparison between different releases of a database schema is tricky\n\n* actual contents of the database must be preserved\n\n* some changes require specific recipes to upgrade the data\n\n* any automated solution hides some detail, by definition: I need complete control, to be able\n  to create temporary tables and/or procedures for example\n\nI tried, and wrote myself, several different approaches to the problem\\ [*]_, and this package\nis my latest and most satisfying effort: it builds on top of `docutils`_ and `Sphinx`_, with\nthe side advantage that you get a quite nice and good documentation of the whole architecture:\n`literate database scheming`!\n\n.. _docutils: http://docutils.sourceforge.net/\n.. _sphinx: http://sphinx.pocoo.org/intro.html\n\n\n.. contents::\n\n.. [*] Just to mention a few alternatives:\n\n       `Alembic <https://pypi.python.org/pypi/alembic>`_\n         Written on top of SQLAlchemy_ by the same author: it does not help when you need to\n         manage something outside SA knowledge (stored procedures, permissions, …)\n\n       `Sqlibrist <https://pypi.python.org/pypi/sqlibrist>`_\n         Some similarities with PatchDB, very young, Django integration.\n\n       `Squitch <http://sqitch.org/>`_\n         Quite good, *although* Perl based…\n\n       See the `schema migration <https://en.wikipedia.org/wiki/Schema_migration>`_ page on\n       Wikipedia for further details.\n\n----\n\nHow it works\n------------\n\nThe package contains two distinct pieces: a `Sphinx`_ extension and the ``patchdb`` command\nline tool.\n\nThe extension implements a new `ReST` directive able to embed a `script` in the document: when\nprocessed by the ``sphinx-build`` tool, all the scripts will be collected in an external file,\nconfigurable.\n\nThe ``patchdb`` tool takes that script collection and determines which scripts need to be\napplied to some database, and the right order.\n\nIt creates and maintains a single very simple table within the database (unsurprisingly named\n``patchdb``), where it records the last version of each script it successfully execute, so that\nit won't reexecute the same script (actually, a particular `revision` of it) twice.\n\nSo, on the development side you simply write (and document!) each piece, and when it comes the\ntime of deploying current state you distribute just the script collection (a single file,\nusually in `AXON`_, `JSON`_ or `YAML`_ format, or a ``pickle`` archive, see `storage formats`_\nbelow) to the end points where the database instances live, and execute ``patchdb`` against\neach one.\n\n.. _yaml: http://yaml.org/\n.. _json: http://json.org/\n.. _axon: http://intellimath.bitbucket.org/axon/\n\n\nScripts\n~~~~~~~\n\nThe basic building block is a `script`, an arbitrary sequence of statements written in some\nlanguage (currently, either ``Python``, ``SQL`` or ``Shell``), augmented with some metadata\nsuch as the `scriptid`, possibly a longer `description`, its `revision` and so on.\n\nAs a complete example of the syntax, consider the following::\n\n  .. patchdb:script:: My first script\n     :description: Full example of a script\n     :revision: 2\n     :depends: Other script@4\n     :preceeds: Yet another\n     :language: python\n     :conditions: python_2_x\n\n     print \"Yeah!\"\n\nThis will introduce a script globally identified by `My first script`, written in ``Python``:\nthis is its second release, and its execution must be constrained such that it happens\n**after** the execution of the fourth revision of `Other script` and **before** `Yet another`.\n\n\nConditions\n++++++++++\n\nThe example shows also an usage of the conditions, allowing more than one variant of a script\nlike::\n\n  .. patchdb:script:: My first script (py3)\n     :description: Full example of a script\n     :revision: 2\n     :depends: Other script@4\n     :preceeds: Yet another\n     :language: python\n     :conditions: python_3_x\n\n     print(\"Yeah!\")\n\nAs another use case of this feature, the following snippet declares the same table for two\ndifferent databases::\n\n  .. patchdb:script:: Simple table (PostgreSQL)\n    :language: sql\n    :mimetype: text/x-postgresql\n    :conditions: postgres\n    :file: postgresql/simple.sql\n\n  .. patchdb:script:: Simple table (MySQL)\n    :language: sql\n    :mimetype: text/x-mysql\n    :conditions: mysql\n    :file: mysql/simple.sql\n\nAs you can see, the content of the script can be conveniently stored in an external file, and\nthe particular dialect specified with the ``:mimetype:`` option, so it will be properly\nhighlighted by Pygments.\n\nSuch conditions may also be arbitrarily defined on the command line, so you can have for\nexample::\n\n  .. patchdb:script:: Configure for production\n    :language: sql\n    :conditions: PRODUCTION\n\n    UPDATE configuration SET is_production = true\n\nand then add the option ``--assert PRODUCTION`` when it is the case.\n\nA condition can be `negated`, prepending a ``!`` to its name::\n\n  .. patchdb:script:: Configure for production\n    :language: sql\n    :conditions: !PRODUCTION\n\n    UPDATE configuration SET is_production = false\n\n\nVariables\n+++++++++\n\nAnother way to influence a script effect is by using *variables*: a script may contain one or\nmore references to arbitrary variables using the syntax ``{{VARNAME}}``, that **must** be\ndefined at application time, using the ``--define VARNAME=VALUE`` command line option.\nAlternatively with the syntax ``{{name=default}}`` the reference can set the default value for\nthe variable, that can be overridden from the command line.\n\nAs an example, you can have the following script::\n\n  .. patchdb:script:: Create table and give read-only rights to the web user\n     :language: sql\n\n     CREATE TABLE foo (id INTEGER)\n     ;;\n     GRANT SELECT ON TABLE foo TO {{WEB=www}}\n     ;;\n     GRANT ALL ON TABLE foo TO {{ADMIN}}\n\nTo apply it, you must specify the value for the ``ADMIN`` variable, with something like\n``--define ADMIN=$USER``.\n\nThe variable name must be an *identifier* (that is, at least an alphabetic letter possibly\nfollowed by alphanumerics or underscores), while its value may contain whitespaces, letters or\ndigits.\n\nIf the name starts with ``ENV_``, the value is looked up in the process `environment`. In the\nfollowing example, the name of the user is taken from the the ``USER`` environment variable\n(that must be present), while the password comes from the ``PASSWORD`` environment entry or, if\nnot set, from the specified default::\n\n  .. patchdb:script:: Insert a default user name\n     :language: sql\n\n     INSERT INTO users (name, password) VALUES ('{{ENV_USER}}', '{{ENV_PASSWORD=password}}')\n\nNote that you can override the environment using an explicit ``--define`` option on the command\nline, for example with ``--define ENV_PASSWORD=foobar``.\n\n\nDependencies\n++++++++++++\n\n.. _master-table:\n\nThe dependencies may be a comma separated list of script ids, such as::\n\n  .. patchdb:script:: Create master table\n\n     CREATE TABLE some_table (id INTEGER PRIMARY KEY, tt_id INTEGER)\n\n  .. patchdb:script:: Create target table\n\n     CREATE TABLE target_table (id INTEGER PRIMARY KEY)\n\n  .. patchdb:script:: Add foreign key to some_table\n     :depends: Create master table, Create target table\n\n     ALTER TABLE some_table\n           ADD CONSTRAINT fk_master_target\n               FOREIGN KEY (tt_id) REFERENCES target_table (id)\n\nIndependently from the order these scripts appear in the documentation, the third script will\nexecute only after the first two get successfully applied to the database. As you can notice,\nmost of the options are optional: by default, ``:language:`` is ``sql``, ``:revision:`` is\n``1``, the ``:description:`` is taken from the title (that is, the script ID), while\n``:depends:`` and ``:preceeds:`` are empty.\n\nJust for illustration purposes, the same effect could be achieved with::\n\n  .. patchdb:script:: Create master table\n     :preceeds: Add foreign key to some_table\n\n     CREATE TABLE some_table (id INTEGER PRIMARY KEY, tt_id INTEGER)\n\n  .. patchdb:script:: Create target table\n\n     CREATE TABLE target_table (id INTEGER PRIMARY KEY)\n\n  .. patchdb:script:: Add foreign key to some_table\n     :depends: Create target table\n\n     ALTER TABLE some_table\n           ADD CONSTRAINT fk_master_target\n               FOREIGN KEY (tt_id) REFERENCES target_table (id)\n\n\nErrors handling\n+++++++++++++++\n\nBy default ``patchdb`` stops when it fails to apply one script. Some time you may want to relax\nthat rule, for example when operating on a database that was created with other methods so you\ncannot relay on the existence of a specific script to make the decision. In such cases, the\noption ``:onerror:`` may be used::\n\n  .. patchdb:script:: Remove obsoleted tables and functions\n     :onerror: ignore\n\n     DROP TABLE foo\n     ;;\n     DROP FUNCTION initialize_record_foo()\n\nWhen ``:onerror:`` is set to `ignore`, each statement in the script is executed and if an error\noccurs it is ignored and ``patchdb`` proceeds with the next one. On good databases like\nPostgreSQL and SQLite where even DDL statements are transactional, each statement is executed\nin a nested subtransaction, so subsequent errors do not ruin the effect of correctly applied\nprevious statements.\n\nAnother possible setting of this option is `skip`: in this case, whenever an error occurs the\neffect of the whole script is undone and it is considered as applied. For example, assuming\nthat the old version of ``SomeProcedure`` accepted a single argument and the new one requires\ntwo of them, you could do something like the following::\n\n  .. patchdb:script:: Fix stored procedure signature\n     :onerror: skip\n\n     SELECT somecol FROM SomeProcedure(NULL, NULL)\n     ;;\n     ALTER PROCEDURE SomeProcedure(p_first INTEGER, p_second INTEGER)\n     RETURNS (somecol INTEGER) AS\n     BEGIN\n       somecol = p_first * p_second;\n       SUSPEND;\n     END\n\n\nPatches\n~~~~~~~\n\nA `patch` is a particular flavour of script, one that specify a `brings` dependency\nlist. Imagine that the `example above`__ was the first version of the database, and that the\ncurrent version looks like the following::\n\n  .. patchdb:script:: Create master table\n     :revision: 2\n\n     CREATE TABLE some_table (\n       id INTEGER PRIMARY KEY,\n       description VARCHAR(80),\n       tt_id INTEGER\n     )\n\nthat is, ``some_table`` now contains one more field, ``description``.\n\nWe need an upgrade path from the first revision of the table to the second::\n\n  .. patchdb:script:: Add a description to the master table\n     :depends: Create master table@1\n     :brings: Create master table@2\n\n     ALTER TABLE some_table ADD COLUMN description VARCHAR(80)\n\nWhen ``patchdb`` examines the database status, it will execute one *or* the other. If the\nscript `Create master table` isn't executed yet (for example when operating on a new database),\nit will take the former script (the one that creates the table from scratch).  Otherwise, if\nthe database \"contains\" revision 1 (and not higher than 1) of the script, it will execute the\nlatter, bumping up the revision number.\n\n__ master-table_\n\n\nRun-always scripts\n~~~~~~~~~~~~~~~~~~\n\nYet another variant of scripts, which get applied always, **every time** ``patchdb`` is\nexecuted.  This kind may be used to perform arbitrary operations, either at the start or at the\nend of the ``patchdb`` session::\n\n    .. patchdb:script:: Say hello\n       :language: python\n       :always: first\n\n       print(\"Hello!\")\n\n    .. patchdb:script:: Say goodbye\n       :language: python\n       :always: last\n\n       print(\"Goodbye!\")\n\n\nFake data domains\n+++++++++++++++++\n\nAs a special case that uses this kind of script, the following example illustrate an\n`approximation` of the `data domains` with MySQL, that lacks them::\n\n    .. patchdb:script:: Define data domains (MySQL)\n       :language: sql\n       :mimetype: text/x-mysql\n       :conditions: mysql\n       :always: first\n\n       CREATE DOMAIN bigint_t bigint\n       ;;\n       CREATE DOMAIN `Boolean_t` char(1)\n\n    .. patchdb:script:: Create some table (MySQL)\n       :language: sql\n       :mimetype: text/x-mysql\n       :conditions: mysql\n       :always: first\n\n       CREATE TABLE `some_table` (\n           `ID` bigint_t NOT NULL,\n         , `FLAG` `Boolean_t`\n\n         , PRIMARY KEY (`ID`)\n       )\n\n.. warning:: This is just a dirty hack, based on relatively simple search and replace: don't\n             take it seriously, use a better database if you really need `data domains`!\n\n.. note:: This works also with SQLite.\n\n\nPlaceholders\n~~~~~~~~~~~~\n\nAnother feature is that the definition of the database, that is the collection of the scripts\nthat actually define its schema, may be splitted on multiple Sphinx environments: the use case\nis when you have a complex application, composed by multiple modules, each of them requiring\nits own set of DB objects.\n\nA script is considered a `placeholder` when it has an empty body: it won't be ever applied, but\ninstead its presence in the database will be asserted. In this way, one Sphinx environment\ncould contain the following script::\n\n  .. patchdb:script:: Create table a\n\n     CREATE TABLE a (\n         id INTEGER NOT NULL PRIMARY KEY\n       , value INTEGER\n     )\n\nand another documentation set could extend that with::\n\n  .. patchdb:script:: Create table a\n     :description: Place holder\n\n  .. patchdb:script:: Create unique index on value\n     :depends: Create table a\n\n     CREATE UNIQUE INDEX on_value ON a (value)\n\nThe second set can be applied **only** after the former one is.\n\n\nUsage\n-----\n\nCollecting patches\n~~~~~~~~~~~~~~~~~~\n\nTo use it, first of all you must register the extension within the Sphinx environment, adding\nthe full name of the package to the ``extensions`` list in the file ``conf.py``, for example::\n\n    # Add any Sphinx extension module names here, as strings.\n    extensions = ['metapensiero.sphinx.patchdb']\n\nIf you want to take advantage of the augmented ``DataDocumenter``, add also\n``metapensiero.sphinx.patchdb.autodoc_sa`` to that list.\n\nThe other required bit of customization is the location of the `on disk scripts storage`,\ni.e. the path of the file that will contain the information about every found script: this is\nkept separated from the documentation itself because you will probably deploy it on production\nservers just to update their database.\n\n.. _storage formats:\n\n.. topic:: Storage formats\n\n   If the filename ends with ``.json`` it will contain a ``JSON`` formatted array, if it ends\n   with ``.yaml`` the information will be dumped in ``YAML``, if it ends with ``.axon`` the\n   dump will be formatted using ``AXON``, otherwise it will be a Python ``pickle``. I usually\n   prefer ``AXON``, ``JSON`` or ``YAML``, because those formats are more VCs friendly and open\n   to human inspection. These days I tend to use ``AXON`` for this kind of things as it is\n   slightly more readable and more VCs friendly than ``JSON``, while ``YAML`` is very slow.\n\nThe location may be set in the same ``conf.py`` as above, like::\n\n    # Location of the external storage\n    patchdb_storage = '…/dbname.json'\n\nOtherwise, you can set it using the ``-D`` option of the ``sphinx-build`` command, so that you\ncan easily share its definition with other rules in a ``Makefile``. I usually put the following\nsnippet at the beginning of the ``Makefile`` created by ``sphinx-quickstart``::\n\n    TOPDIR ?= ..\n    STORAGE ?= $(TOPDIR)/database.json\n\n    SPHINXOPTS = -D patchdb_storage=$(STORAGE)\n\nAt this point, executing the usual ``make html`` will update the scripts archive: that file\ncontains everything is needed to update the database either local or remote; in other words,\nrunning Sphinx (or even having it installed) is **not** required to update a database.\n\n\nUpdating the database\n~~~~~~~~~~~~~~~~~~~~~\n\nThe other side of the coin is managed by the ``patchdb`` tool, that digests the scripts archive\nand is able to determine which of the scripts are not already applied and eventually does that,\nin the right order.\n\nWhen your database does already exist and you are just starting using ``patchdb`` you may need\nto force the initial state with the following command::\n\n    patchdb --assume-already-applied --postgresql \"dbname=test\" database.json\n\nthat will just update the `patchdb` table registering current revision of all the missing\nscripts, without executing them.\n\nYou can inspect what will be done, that is obtain the list of not already applied patches, with\na command like::\n\n    patchdb --dry-run --postgresql \"dbname=test\" database.json\n\nThe `database.json` archive can be sent to the production machines (in some cases I put it in a\n*production* branch of the repository and use the version control tool to update the remote\nmachines, in other I simply used ``scp`` or ``rsync`` based solutions). Another way is to\ninclude it in some package and then use the syntax ``some.package:path/database.json``.\n\nThe scripts may even come from several different archives (see `placeholders`_ above)::\n\n    patchdb --postgresql \"dbname=test\" app.db.base:pdb.json app.db.auth:pdb.json\n\n\nAutomatic backup\n~~~~~~~~~~~~~~~~\n\nIn particular in development mode, I find it useful to have a simple way of going back to a\nprevious state and retry the upgrade, either to test different upgrade paths or to fix silly\ntypos in the new patches.\n\nSince version 2.3 ``patchdb`` has a new option, ``--backups-dir``, that controls an automatic\nbackup facility: at each execution, before proceeding with applying missing patches,\n*regardless* whether there are any, by default it takes a backup of the current database and\nkeeps a simple index of these snapshots.\n\nThe option defaults to the system-wide temporary directory (usually ``/tmp`` on POSIX systems):\nif you you don't need the automatic backup (a reasonable production system should have a\ndifferent approach to taking such snapshots), specify ``None`` as argument to the option.\n\nWith the ``patchdb-states`` tool you obtain a list of the available snapshots, or restore any\nprevious one::\n\n  $ patchdb-states list\n  [lun 18 apr 2016 08:24:48 CEST] bc5c5527ece6f11da529858d5ac735a8 <create first table@1>\n  [lun 18 apr 2016 10:27:11 CEST] 693fd245ad9e5f4de0e79549255fbd6e <update first table@1>\n\n  $ patchdb-states restore --sqlite /tmp/quicktest.sqlite 693fd245ad9e5f4de0e79549255fbd6e\n  [I] Creating patchdb table\n  [I] Restored SQLite database /tmp/quicktest.sqlite from /tmp/693fd245ad9e5f4de0e79549255fbd6e\n\n  $ patchdb-states clean -k 1\n  Removed /tmp/bc5c5527ece6f11da529858d5ac735a8\n  Kept most recent 1 snapshot\n\n\nSupported databases\n~~~~~~~~~~~~~~~~~~~\n\nAs of version 2, ``patchdb`` can operate on the following databases:\n\n* Firebird (requires fdb_)\n* MySQL (requires PyMySQL_ by default, see option ``--driver`` to select a different one)\n* PostgreSQL (requires psycopg2_)\n* SQLite (uses the standard library ``sqlite3`` module)\n\n.. _fdb: https://pypi.python.org/pypi/fdb\n.. _PyMySQL: https://pypi.python.org/pypi/PyMySQL\n.. _psycopg2: https://pypi.python.org/pypi/psycopg2\n.. _SQLAlchemy: http://www.sqlalchemy.org/\n\n\nExample development Makefile snippet\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe following is a snippet that I usually put in my outer ``Makefile``::\n\n    export TOPDIR := $(CURDIR)\n    DBHOST := localhost\n    DBPORT := 5432\n    DBNAME := dbname\n    DROPDB := dropdb --host=$(DBHOST) --port=$(DBPORT) --if-exists\n    CREATEDB := createdb --host=$(DBHOST) --port=$(DBPORT) --encoding=UTF8\n    STORAGE := $(TOPDIR)/$(DBNAME).json\n    DSN := host=$(DBHOST) port=$(DBPORT) dbname=$(DBNAME)\n    PUP := $(PATCHDB) --postgresql=\"$(DSN)\" --log-file=$(DBNAME).log $(STORAGE)\n\n    # Build the Sphinx documentation\n    doc:\n            $(MAKE) -C doc STORAGE=$(STORAGE) html\n\n    $(STORAGE): doc\n\n    # Show what is missing\n    missing-patches: $(STORAGE)\n            $(PUP) --dry-run\n\n    # Upgrade the database to the latest revision\n    database: $(STORAGE)\n            $(PUP)\n\n    # Remove current database and start from scratch\n    scratch-database:\n            $(DROPDB) $(DBNAME)\n            $(CREATEDB) $(DBNAME)\n            $(MAKE) database\n\n\nChanges\n-------\n\n2.13 (2016-10-25)\n~~~~~~~~~~~~~~~~~\n\n* Require sqlparse >= 0.2.2 and toposort >= 1.5\n\n* Emit cleaner errors for dependency problems\n\n* Tag PatchDB specific errors as such instead of using the generic Sphinx's \"extension errors\"\n\n\n2.12 (2016-10-15)\n~~~~~~~~~~~~~~~~~\n\n* Use sqlparse 0.2.x\n\n* Handle *special* statements that under PostgreSQL must be executed outside of a transaction\n  block (autocommit__ mode in psycopg2 parlance)\n\n__ http://initd.org/psycopg/docs/connection.html#connection.autocommit\n\n\n2.11 (2016-10-14)\n~~~~~~~~~~~~~~~~~\n\n* Use more specific exception to avoid traceback output from Sphinx\n\n\n2.10 (2016-09-29)\n~~~~~~~~~~~~~~~~~\n\n* Handle PostgreSQL RCs\n\n\n2.9 (2016-06-11)\n~~~~~~~~~~~~~~~~\n\n* A script variable may reference environment variables\n\n* A condition may be negated\n\n\n2.8 (2016-06-07)\n~~~~~~~~~~~~~~~~\n\n* Remove dependency from SQLAlchemy replacing usage of its topological sort with the\n  toposort__ one\n\n* Drop suboptimal SQLAlchemy backend\n\n__ https://pypi.python.org/pypi/toposort\n\n\n2.7 (2016-05-29)\n~~~~~~~~~~~~~~~~\n\n* Properly handle comments in SQL scripts, using the sqlparse__ ``Lexer`` to reimplement\n  statement kind recognition and `fake data domains`\n\n__ https://pypi.python.org/pypi/sqlparse\n\n\n2.6 (2016-05-28)\n~~~~~~~~~~~~~~~~\n\n* Handle `fake data domains` also in ``ALTER TABLE`` statements\n\n\n2.5 (2016-05-17)\n~~~~~~~~~~~~~~~~\n\n* Catch silly MySQL's “There is no such grant defined” error on ``REVOKE ALL PRIVILEGES``\n\n\n2.4 (2016-05-13)\n~~~~~~~~~~~~~~~~\n\n* User defined variables\n\n\n2.3 (2016-04-19)\n~~~~~~~~~~~~~~~~\n\n* Automatic backup functionality, with a new patchdb-states tool able to go back to a previous\n  state of the database\n\n* Bring back Firebird support\n\n* Fix Python 2.7 compatibility\n\n\n2.2 (2016-03-12)\n~~~~~~~~~~~~~~~~\n\n* Support loading from multiple archives in one shot, particularly handy with placeholder\n  scripts\n\n\n2.1 (2016-03-04)\n~~~~~~~~~~~~~~~~\n\n* Promote script problems to hard Sphinx errors\n\n\n2.0 (2016-03-01)\n~~~~~~~~~~~~~~~~\n\n* Shiny new tests suite\n\n* New SQLite specific context\n\n* Generalized and somewhat better `fake data domains` for MySQL and SQLite. **Warning**: the\n  syntax in not backward compatible with previous implementation added in version 1.2.0.\n\n* New placeholder scripts, to allow splitting schema in several different Sphinx environments\n\n* Now two scripts cannot have the same title, even within the same document\n\n* Fix onerror handling, broken long ago by a typo\n\n\n1.7 (2016-02-20)\n~~~~~~~~~~~~~~~~\n\n* Fix packaging issues\n\n\n1.6 (2016-02-10)\n~~~~~~~~~~~~~~~~\n\n* Data files and preload/postload scripts may be specified also as package relative resources\n\n* Deprecate the ``--patch-storage`` option for ``patchdb``, replaced by a single positional\n  argument: it's going to be removed in version 2.0, in the meanwhile it's still recognized\n\n\n1.5 (2016-01-07)\n~~~~~~~~~~~~~~~~\n\n* Repackage dbloady as a standalone tool, metapensiero.sqlalchemy.dbloady\n\n\n1.4.2 (2015-10-22)\n~~~~~~~~~~~~~~~~~~\n\n* Allow using keyed values (e.g. PostgreSQL HSTORE) to lookup instances in dbloady\n\n\n1.4.1 (2015-09-23)\n~~~~~~~~~~~~~~~~~~\n\n* Augmented Sphinx autodoc DataDocumenter able to pretty print SA queries\n\n\n1.4.0 (2015-08-19)\n~~~~~~~~~~~~~~~~~~\n\n* New experimental dbloady feature, mainly intendended for test fixtures: it is now able to\n  take note about the instances it creates writing a YAML file with the same input format, and\n  delete them from the database in a subsequent run\n\n\n1.3.11 (2015-08-16)\n~~~~~~~~~~~~~~~~~~~\n\n* dbloady now flushes changes after each entity to honor referential integrity checks\n\n\n1.3.10 (2015-08-15)\n~~~~~~~~~~~~~~~~~~~\n\n* Fix problem with the ``patchdb:script`` role, when the target gets splitted on two or more\n  lines\n\n\n1.3.9 (2015-08-08)\n~~~~~~~~~~~~~~~~~~\n\n* Fix problem with different MySQL drivers exceptions internals\n\n\n1.3.8 (2015-08-08)\n~~~~~~~~~~~~~~~~~~\n\n* Allow longer patch ids, up to 100 characters\n\n\n1.3.7 (2015-07-20)\n~~~~~~~~~~~~~~~~~~\n\n* Use PyMySQL by default, allow selection of a different driver with a command line option\n\n\n1.3.6 (2015-07-06)\n~~~~~~~~~~~~~~~~~~\n\n* Do not decode patch id from UTF-8 but let the driver do that if needed\n\n\n1.3.5 (2015-07-06)\n~~~~~~~~~~~~~~~~~~\n\n* Fix type of MySQL port number, must be an integer\n\n\n1.3.4 (2015-07-06)\n~~~~~~~~~~~~~~~~~~\n\n* Accept also the port number to reach the MySQL server\n\n\n1.3.3 (2015-06-24)\n~~~~~~~~~~~~~~~~~~\n\n* Some more tweaks to adapt dbloady to Python 3\n\n\n1.3.2 (2015-06-23)\n~~~~~~~~~~~~~~~~~~\n\n* Flush the standard error stream to show the progress immediately\n\n* Do not encode statements in UTF-8 but let the driver do that if needed\n\n\n1.3.1 (2015-06-23)\n~~~~~~~~~~~~~~~~~~\n\n* Fix \"brown paper bag\" syntax error\n\n\n1.3.0 (2015-06-21)\n~~~~~~~~~~~~~~~~~~\n\n* Use ``fdb`` instead of ``kinterbasdb`` for ``Firebird``\n\n* Support the ``AXON`` format for the on disk patch storage\n\n\n1.2.1 (2014-07-02)\n~~~~~~~~~~~~~~~~~~\n\n* Add script's \"conditions\" and \"run-always\" to the sphinx rendering\n\n* dbloady's load_yaml() now returns a dictionary with loaded instances\n\n\n1.2.0 (2014-06-19)\n~~~~~~~~~~~~~~~~~~\n\n* New \"run-always\" scripts\n\n* Poor man \"CREATE DOMAIN\" for MySQL\n\n* User defined assertions\n\n\n1.1.2 (2014-06-05)\n~~~~~~~~~~~~~~~~~~\n\n* New --assume-already-applied option, useful when you start using ``patchdb``\n  on an already existing database\n\n\n1.1.1 (2014-06-03)\n~~~~~~~~~~~~~~~~~~\n\n* Fix packaging, adding a MANIFEST.in\n\n\n1.1.0 (2014-06-03)\n~~~~~~~~~~~~~~~~~~\n\n* Use setuptools instead of distribute\n\n* Use argparse instead of optparse\n\n* New mimetype property on scripts, to select the right Pygments highlighter\n\n* New MySQL specific context, using cymysql\n\n\n1.0.7 (2013-08-23)\n~~~~~~~~~~~~~~~~~~\n\n* published on bitbucket\n\n\n1.0.6 (2013-03-12)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady: ability to load field values from external files\n\n\n1.0.5 (2013-03-11)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady: fix encoding error when printing messages coming from PostgreSQL\n\n* dbloady: emit a progress bar on stderr\n\n\n1.0.4 (2013-02-27)\n~~~~~~~~~~~~~~~~~~\n\n* dbloady, a new utility script, to load base data from a YAML stream.\n\n\n1.0.3 (2012-11-07)\n~~~~~~~~~~~~~~~~~~\n\n* Fix ``:patchdb:script`` role\n\n\n1.0.2 (2012-10-19)\n~~~~~~~~~~~~~~~~~~\n\n* Pickier way to split the multi-statements SQL scripts, now the\n  ``;;`` separator must be on a line by its own\n\n* More precise line number tracking when applying multi-statements SQL\n  scripts\n\n* Dump and load script dependencies and conditions as lists, to avoid\n  pointless repeated splits and joins\n\n\n1.0.1 (2012-10-13)\n~~~~~~~~~~~~~~~~~~\n\n* Fix error loading JSON storage, simplejson already yields unicode strings\n\n* Possibly use the original title of the script as description, if not\n  explicitly set\n\n* More precise error on unknown script reference\n\n* Minor corrections\n\n\n1.0 (2012-10-10)\n~~~~~~~~~~~~~~~~\n\n* Added JSON support for the on disk `scripts storage`\n\n* Adapted to work with SQLAlchemy 0.7.x\n\n* Updated to work with docutils > 0.8\n\n* Refactored as a `Sphinx domain <http://sphinx.pocoo.org/domains.html>`_\n\n  .. attention:: This means that the directive names are now prefixed\n                 with ``patchdb:`` (that is, the old ``script``\n                 directive is now ``patchdb:script``). You can use the\n                 `default-domain`__ directive if that annoys you.\n\n  __ http://sphinx.pocoo.org/domains.html#directive-default-domain\n\n* Renamed the status table from ``prst_applied_info`` to simply\n  ``patchdb``\n\n  .. attention:: This is the main incompatible change with previous\n                 version: you should eventually rename the table\n                 manually, sorry for the inconvenience.\n\n* Renamed ``prst_patch_storage`` configuration setting to\n  ``patchdb_storage``\n\n* Each script ID is now lower case, to avoid ambiguities\n\n\n0.3 (2010-11-14)\n~~~~~~~~~~~~~~~~\n\n* Updated to work with Sphinx 1.0\n\n* New :script: role for cross-references\n\n* New :file: option on script directive, to keep the actual text in an\n  external file\n\n\n0.2 (2010-03-03)\n~~~~~~~~~~~~~~~~\n\n* Compatibility with SQLAlchemy 0.6\n\n* New patchdb command line tool\n\n\n0.1 (2009-10-28)\n~~~~~~~~~~~~~~~~\n\n* Replace home brew solution with SQLAlchemy topological sort\n\n* Use YAML for the persistent storage\n\n* Mostly working Sphinx adaptor\n\n* Rudimentary and mostly untested SQLAlchemy backend (basically only\n  the direct PostgreSQL backend has been battle tested in production...)\n\n* First standalone version\n\n\n0.0\n~~~\n\n* still a PylGAM side-product\n\n* simply a set of docutils directives\n\n* started with Firebird in mind, but grown up with PostgreSQL\n",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/lele/metapensiero.sphinx.patchdb",
    "keywords": "",
    "license": "GPLv3+",
    "maintainer": "",
    "maintainer_email": "",
    "name": "metapensiero.sphinx.patchdb",
    "package_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/",
    "platform": "",
    "project_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/",
    "project_urls": {
      "Homepage": "https://bitbucket.org/lele/metapensiero.sphinx.patchdb"
    },
    "release_url": "https://pypi.org/project/metapensiero.sphinx.patchdb/2.13/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Extract scripts from a reST document and apply them in order.",
    "version": "2.13",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16877674,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ad4e8b704f5129e9105dba9e44cdcb714750409fc9b5435bf84b09cd5e7407ca",
        "md5": "4a833de45e37c27b412fc44ca6e5a67f",
        "sha256": "f1fb742fae1fbbb9126544605db8a5279fa956006aefd56a52e8d7bc42531e6c"
      },
      "downloads": -1,
      "filename": "metapensiero.sphinx.patchdb-2.13.tar.gz",
      "has_sig": false,
      "md5_digest": "4a833de45e37c27b412fc44ca6e5a67f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 50813,
      "upload_time": "2016-10-25T07:44:13",
      "upload_time_iso_8601": "2016-10-25T07:44:13.037075Z",
      "url": "https://files.pythonhosted.org/packages/ad/4e/8b704f5129e9105dba9e44cdcb714750409fc9b5435bf84b09cd5e7407ca/metapensiero.sphinx.patchdb-2.13.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}