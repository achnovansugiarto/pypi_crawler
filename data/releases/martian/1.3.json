{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "information in Python code. Martian can then grok the system and\ndo the appropriate configuration registrations. One example of a system\nthat uses Martian is the system where it originated: Grok\n(http://grok.zope.org)\n\nHome-page: https://github.com/zopefoundation/martian\nAuthor: Grok project\nAuthor-email: grok-dev@zope.org\nLicense: ZPL\nDescription: *******\n        Martian\n        *******\n        \n        .. image:: https://travis-ci.org/zopefoundation/martian.svg?branch=master\n                :target: https://travis-ci.org/zopefoundation/martian\n        \n        .. image:: https://readthedocs.org/projects/martian/badge/?version=latest\n                :target: https://martian.readthedocs.org/en/latest/\n                :alt: Documentation Status\n        \n        .. image:: https://img.shields.io/pypi/v/martian.svg\n                :target: https://pypi.python.org/pypi/martian\n                :alt: PyPI\n        \n        .. image:: https://img.shields.io/pypi/pyversions/martian.svg\n                :target: https://pypi.python.org/pypi/martian\n                :alt: Python versions\n        \n        \n        A library to grok configuration from Python code.\n        \n        Martian tutorial\n        ****************\n        \n        Introduction\n        ============\n        \n        \"There was so much to grok, so little to grok from.\" -- Stranger in a\n        Strange Land, by Robert A. Heinlein\n        \n        Martian provides infrastructure for declarative configuration of\n        Python code. Martian is especially useful for the construction of\n        frameworks that need to provide a flexible plugin\n        infrastructure. Martian doesn't actually provide infrastructure for\n        plugin registries (except for itself). Many frameworks have their own\n        systems for this, and if you need a generic one, you might want to\n        consider ``zope.component``. Martian just allows you to make the\n        registration of plugins less verbose.\n        \n        You can see Martian as doing something that you can also solve with\n        metaclasses, with the following advantages:\n        \n        * the developer of the framework doesn't have to write a lot of ad-hoc\n          metaclasses anymore; instead we offer an infrastructure to make life\n          easier.\n        \n        * configuration doesn't need to happen at import time, but can happen at\n          program startup time. This also makes configuration more tractable for\n          a developer.\n        \n        * we don't bother the developer that *uses* the framework with the\n          surprising behavior that metaclasses sometimes bring. The classes\n          the user has to deal with are normal classes.\n        \n        Why is this package named ``martian``? In the novel \"Stranger in a\n        Strange Land\", the verb *grok* is introduced:\n        \n          Grok means to understand so thoroughly that the observer becomes a\n          part of the observed -- to merge, blend, intermarry, lose identity\n          in group experience.\n        \n        In the context of this package, \"grokking\" stands for the process of\n        deducing declarative configuration actions from Python code. In the\n        novel, grokking is originally a concept that comes from the planet\n        Mars. Martians *grok*. Since this package helps you grok code, it's\n        called Martian.\n        \n        Martian provides a framework that allows configuration to be expressed\n        in declarative Python code. These declarations can often be deduced\n        from the structure of the code itself. The idea is to make these\n        declarations so minimal and easy to read that even extensive\n        configuration does not overly burden the programmers working with the\n        code.\n        \n        The ``martian`` package is a spin-off from the `Grok project`_, in the\n        context of which this codebase was first developed. While Grok uses\n        it, the code is completely independent of Grok.\n        \n        .. _`Grok project`: http://grok.zope.org\n        \n        Motivation\n        ==========\n        \n        \"Deducing declarative configuration actions from Python code\" - that\n        sounds very abstract. What does it actually mean? What is\n        configuration?  What is declarative configuration? In order to explain\n        this, we'll first take a look at configuration.\n        \n        Larger frameworks often offer a lot of points where you can modify\n        their behavior: ways to combine its own components with components you\n        provide yourself to build a larger application. A framework offers\n        points where it can be *configured* with plugin code. When you plug\n        some code into a plugin point, it results in the updating of some\n        registry somewhere with the new plugin. When the framework uses a\n        plugin, it will first look it up in the registry. The action of\n        registering some component into a registry can be called\n        *configuration*.\n        \n        Let's look at an example framework that offers a plugin point. We\n        introduce a very simple framework for plugging in different template\n        languages, where each template language uses its own extension. You\n        can then supply the framework with the template body and the template\n        extension and some data, and render the template.\n        \n        Let's look at the framework::\n        \n          >>> import string\n          >>> class templating(FakeModule):\n          ...\n          ...   class InterpolationTemplate(object):\n          ...      \"Use %(foo)s for dictionary interpolation.\"\n          ...      def __init__(self, text):\n          ...          self.text = text\n          ...      def render(self, **kw):\n          ...          return self.text % kw\n          ...\n          ...   class TemplateStringTemplate(object):\n          ...      \"PEP 292 string substitutions.\"\n          ...      def __init__(self, text):\n          ...          self.template = string.Template(text)\n          ...      def render(self, **kw):\n          ...          return self.template.substitute(**kw)\n          ...\n          ...   # the registry, we plug in the two templating systems right away\n          ...   extension_handlers = { '.txt': InterpolationTemplate,\n          ...                          '.tmpl': TemplateStringTemplate }\n          ...\n          ...   def render(data, extension, **kw):\n          ...      \"\"\"Render the template at filepath with arguments.\n          ...\n          ...      data - the data in the file\n          ...      extension - the extension of the file\n          ...      keyword arguments - variables to interpolate\n          ...\n          ...      In a real framework you could pass in the file path instead of\n          ...      data and extension, but we don't want to open files in our\n          ...      example.\n          ...\n          ...      Returns the rendered template\n          ...      \"\"\"\n          ...      template = extension_handlers[extension](data)\n          ...      return template.render(**kw)\n        \n        Since normally we cannot create modules in a doctest, we have emulated\n        the ``templating`` Python module using the ``FakeModule``\n        class. Whenever you see ``FakeModule`` subclasses, imagine you're\n        looking at a module definition in a ``.py`` file. Now that we have\n        defined a module ``templating``, we also need to be able to import\n        it. Fake modules are always placed automatically into the\n        ``martiantest.fake`` namespace so you can import them from there::\n        \n          >>> from martiantest.fake import templating\n        \n        Now let's try the ``render`` function for the registered template\n        types, to demonstrate that our framework works::\n        \n          >>> templating.render('Hello %(name)s!', '.txt', name=\"world\")\n          'Hello world!'\n          >>> templating.render('Hello ${name}!', '.tmpl', name=\"universe\")\n          'Hello universe!'\n        \n        File extensions that we do not recognize cause a ``KeyError`` to be\n        raised::\n        \n          >>> templating.render('Hello', '.silly', name=\"test\")\n          Traceback (most recent call last):\n          ...\n          KeyError: '.silly'\n        \n        We now want to plug into this filehandler framework and provide a\n        handler for ``.silly`` files. Since we are writing a plugin, we cannot\n        change the ``templating`` module directly. Let's write an extension\n        module instead::\n        \n          >>> class sillytemplating(FakeModule):\n          ...   class SillyTemplate(object):\n          ...      \"Replace {key} with dictionary values.\"\n          ...      def __init__(self, text):\n          ...          self.text = text\n          ...      def render(self, **kw):\n          ...          text = self.text\n          ...          for key, value in kw.items():\n          ...              text = text.replace('{%s}' % key, value)\n          ...          return text\n          ...\n          ...   templating.extension_handlers['.silly'] = SillyTemplate\n          >>> from martiantest.fake import sillytemplating\n        \n        In the extension module, we manipulate the ``extension_handlers``\n        dictionary of the ``templating`` module (in normal code we'd need to\n        import it first), and plug in our own function. ``.silly`` handling\n        works now::\n        \n          >>> templating.render('Hello {name}!', '.silly', name=\"galaxy\")\n          'Hello galaxy!'\n        \n        Above we plug into our ``extension_handler`` registry using Python\n        code. Using separate code to manually hook components into registries\n        can get rather cumbersome - each time you write a plugin, you also\n        need to remember you need to register it.\n        \n        Doing template registration in Python code also poses a maintenance\n        risk. It is tempting to start doing fancy things in Python code such\n        as conditional configuration, making the configuration state of a\n        program hard to understand. Another problem is that doing\n        configuration at import time can also lead to unwanted side effects\n        during import, as well as ordering problems, where you want to import\n        something that really needs configuration state in another module that\n        is imported later. Finally, it can also make code harder to test, as\n        configuration is loaded always when you import the module, even if in\n        your test perhaps you don't want it to be.\n        \n        Martian provides a framework that allows configuration to be expressed\n        in declarative Python code. Martian is based on the realization that\n        what to configure where can often be deduced from the structure of\n        Python code itself, especially when it can be annotated with\n        additional declarations. The idea is to make it so easy to write and\n        register a plugin so that even extensive configuration does not overly\n        burden the developer.\n        \n        Configuration actions are executed during a separate phase (\"grok\n        time\"), not at import time, which makes it easier to reason about and\n        easier to test.\n        \n        Configuration the Martian Way\n        =============================\n        \n        Let's now transform the above ``templating`` module and the\n        ``sillytemplating`` module to use Martian. First we must recognize\n        that every template language is configured to work for a particular\n        extension. With Martian, we annotate the classes themselves with this\n        configuration information. Annotations happen using *directives*,\n        which look like function calls in the class body.\n        \n        Let's create an ``extension`` directive that can take a single string\n        as an argument, the file extension to register the template class\n        for::\n        \n          >>> import martian\n          >>> class extension(martian.Directive):\n          ...   scope = martian.CLASS\n          ...   store = martian.ONCE\n          ...   default = None\n        \n        We also need a way to easily recognize all template classes. The normal\n        pattern for this in Martian is to use a base class, so let's define a\n        ``Template`` base class::\n        \n          >>> class Template(object):\n          ...   pass\n        \n        We now have enough infrastructure to allow us to change the code to use\n        Martian style base class and annotations::\n        \n          >>> class templating(FakeModule):\n          ...\n          ...   class InterpolationTemplate(Template):\n          ...      \"Use %(foo)s for dictionary interpolation.\"\n          ...      extension('.txt')\n          ...      def __init__(self, text):\n          ...          self.text = text\n          ...      def render(self, **kw):\n          ...          return self.text % kw\n          ...\n          ...   class TemplateStringTemplate(Template):\n          ...      \"PEP 292 string substitutions.\"\n          ...      extension('.tmpl')\n          ...      def __init__(self, text):\n          ...          self.template = string.Template(text)\n          ...      def render(self, **kw):\n          ...          return self.template.substitute(**kw)\n          ...\n          ...   # the registry, empty to start with\n          ...   extension_handlers = {}\n          ...\n          ...   def render(data, extension, **kw):\n          ...      # this hasn't changed\n          ...      template = extension_handlers[extension](data)\n          ...      return template.render(**kw)\n          >>> from martiantest.fake import templating\n        \n        As you can see, there have been very few changes:\n        \n        * we made the template classes inherit from ``Template``.\n        \n        * we use the ``extension`` directive in the template classes.\n        \n        * we stopped pre-filling the ``extension_handlers`` dictionary.\n        \n        So how do we fill the ``extension_handlers`` dictionary with the right\n        template languages? Now we can use Martian. We define a *grokker* for\n        ``Template`` that registers the template classes in the\n        ``extension_handlers`` registry::\n        \n          >>> class meta(FakeModule):\n          ...   class TemplateGrokker(martian.ClassGrokker):\n          ...     martian.component(Template)\n          ...     martian.directive(extension)\n          ...     def execute(self, class_, extension, **kw):\n          ...       templating.extension_handlers[extension] = class_\n          ...       return True\n          >>> from martiantest.fake import meta\n        \n        What does this do? A ``ClassGrokker`` has its ``execute`` method\n        called for subclasses of what's indicated by the ``martian.component``\n        directive. You can also declare what directives a ``ClassGrokker``\n        expects on this component by using ``martian.directive()`` (the\n        ``directive`` directive!) one or more times.\n        \n        The ``execute`` method takes the class to be grokked as the first\n        argument, and the values of the directives used will be passed in as\n        additional parameters into the ``execute`` method. The framework can\n        also pass along an arbitrary number of extra keyword arguments during\n        the grokking process, so we need to declare ``**kw`` to make sure we\n        can handle these.\n        \n        All our grokkers will be collected in a special Martian-specific\n        registry::\n        \n          >>> reg = martian.GrokkerRegistry()\n        \n        We will need to make sure the system is aware of the\n        ``TemplateGrokker`` defined in the ``meta`` module first, so let's\n        register it first. We can do this by simply grokking the ``meta``\n        module::\n        \n          >>> reg.grok('meta', meta)\n          True\n        \n        Because ``TemplateGrokker`` is now registered, our registry now knows\n        how to grok ``Template`` subclasses. Let's grok the ``templating``\n        module::\n        \n          >>> reg.grok('templating', templating)\n          True\n        \n        Let's try the ``render`` function of templating again, to demonstrate\n        we have successfully grokked the template classes::\n        \n          >>> templating.render('Hello %(name)s!', '.txt', name=\"world\")\n          'Hello world!'\n          >>> templating.render('Hello ${name}!', '.tmpl', name=\"universe\")\n          'Hello universe!'\n        \n        ``.silly`` hasn't been registered yet::\n        \n          >>> templating.render('Hello', '.silly', name=\"test\")\n          Traceback (most recent call last):\n          ...\n          KeyError: '.silly'\n        \n        Let's now register ``.silly`` from an extension module::\n        \n          >>> class sillytemplating(FakeModule):\n          ...   class SillyTemplate(Template):\n          ...      \"Replace {key} with dictionary values.\"\n          ...      extension('.silly')\n          ...      def __init__(self, text):\n          ...          self.text = text\n          ...      def render(self, **kw):\n          ...          text = self.text\n          ...          for key, value in kw.items():\n          ...              text = text.replace('{%s}' % key, value)\n          ...          return text\n          >>> from martiantest.fake import sillytemplating\n        \n        As you can see, the developer that uses the framework has no need\n        anymore to know about ``templating.extension_handlers``. Instead we can\n        simply grok the module to have ``SillyTemplate`` be register appropriately::\n        \n          >>> reg.grok('sillytemplating', sillytemplating)\n          True\n        \n        We can now use the ``.silly`` templating engine too::\n        \n          >>> templating.render('Hello {name}!', '.silly', name=\"galaxy\")\n          'Hello galaxy!'\n        \n        Admittedly it is hard to demonstrate Martian well with a small example\n        like this. In the end we have actually written more code than in the\n        basic framework, after all. But even in this small example, the\n        ``templating`` and ``sillytemplating`` module have become more\n        declarative in nature. The developer that uses the framework will not\n        need to know anymore about things like\n        ``templating.extension_handlers`` or an API to register things\n        there. Instead the developer can registering a new template system\n        anywhere, as long as he subclasses from ``Template``, and as long as\n        his code is grokked by the system.\n        \n        Finally note how Martian was used to define the ``TemplateGrokker`` as\n        well. In this way Martian can use itself to extend itself.\n        \n        Grokking instances\n        ==================\n        \n        Above we've seen how you can grok classes. Martian also supplies a way\n        to grok instances. This is less common in typical frameworks, and has\n        the drawback that no class-level directives can be used, but can still\n        be useful.\n        \n        Let's imagine a case where we have a zoo framework with an ``Animal``\n        class, and we want to track instances of it::\n        \n          >>> class Animal(object):\n          ...   def __init__(self, name):\n          ...     self.name = name\n          >>> class zoo(FakeModule):\n          ...   horse = Animal('horse')\n          ...   chicken = Animal('chicken')\n          ...   elephant = Animal('elephant')\n          ...   lion = Animal('lion')\n          ...   animals = {}\n          >>> from martiantest.fake import zoo\n        \n        We define an ``InstanceGrokker`` subclass to grok ``Animal`` instances::\n        \n          >>> class meta(FakeModule):\n          ...   class AnimalGrokker(martian.InstanceGrokker):\n          ...     martian.component(Animal)\n          ...     def execute(self, instance, **kw):\n          ...       zoo.animals[instance.name] = instance\n          ...       return True\n          >>> from martiantest.fake import meta\n        \n        Let's create a new registry with the ``AnimalGrokker`` in it::\n        \n          >>> reg = martian.GrokkerRegistry()\n          >>> reg.grok('meta', meta)\n          True\n        \n        We can now grok the ``zoo`` module::\n        \n          >>> reg.grok('zoo', zoo)\n          True\n        \n        The animals will now be in the ``animals`` dictionary::\n        \n          >>> sorted(zoo.animals.items())\n          [('chicken', <Animal object at ...>),\n           ('elephant', <Animal object at ...>),\n           ('horse', <Animal object at ...>),\n           ('lion', <Animal object at ...>)]\n        \n        More information\n        ================\n        \n        For many more details and examples of more kinds of grokkers, please\n        see ``src/martian/core.txt``. For more information on directives see\n        ``src/martian/directive.txt``.\n        \n        CHANGES\n        *******\n        \n        1.3 (2019-03-14)\n        ================\n        \n        - Add support for Python 3.7 and 3.8.\n        \n        \n        1.2 (2018-05-09)\n        ================\n        \n        - Add a new directive ``martian.ignore()`` to explicitly not grok\n          something in a module::\n        \n            class Example:\n                pass\n        \n            martian.ignore('Example')\n        \n        - Fix the code to be pep 8 compliant.\n        \n        1.1 (2018-01-25)\n        ================\n        \n        - Bypass bootstrap, add coverage to tox\n        \n        - Fix ``inspect.getargspec()`` deprecation in python3\n        \n        \n        1.0 (2017-10-19)\n        ================\n        \n        - Add support for Python 3.5, 3.6, PyPy2 and PyPy3.\n        \n        - Drop support for Python 2.6 and 3.3.\n        \n        \n        0.15 (2015-04-21)\n        =================\n        \n        - compatibility for python 3\n        - adjust egg to work with newer version of setuptools\n        - Fix an encoding issue under Python-2.7 in the doctests.\n        \n        \n        0.14 (2010-11-03)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * The computation of the default value for a directive can now be defined inside\n          the directive class definition. Whenever there is a ``get_default``\n          classmethod, it is used for computing the default::\n        \n              class name(Directive):\n                  scope = CLASS\n                  store = ONCE\n        \n                  @classmethod\n                  def get_default(cls, component, module=None, **data):\n                     return component.__name__.lower()\n        \n          When binding the directive, the default-default behaviour can still be\n          overriden by passing a ``get_default`` function::\n        \n              def another_default(component, module=None, **data):\n                 return component.__name__.lower()\n        \n              name.bind(get_default=another_default).get(some_component)\n        \n          Making the default behaviour intrinsic to the directive, prevents having to\n          pass the ``get_default`` function over and over when getting values, for\n          example in the grokkers.\n        \n        0.13 (2010-11-01)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * Ignore all __main__ modules.\n        \n        * List zope.testing as a test dependency.\n        \n        0.12 (2009-06-29)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * Changes to better support various inheritance scenarios in combination with\n          directives. Details follow.\n        \n        * ``CLASS_OR_MODULE`` scope directives will be aware of inheritance of\n          values that are defined in module-scope. Consider the following case::\n        \n            module a:\n              some_directive('A')\n              class Foo(object):\n                pass\n        \n            module b:\n              import a\n              class Bar(a.Foo):\n                pass\n        \n          As before, ``Foo`` will have the value ``A`` configured for it. ``Bar``,\n          since it inherits from ``Foo``, will inherit this value.\n        \n        * ``CLASS_OR_MODULE`` and ``CLASS`` scope directives will be aware of\n          inheritance of computed default values. Consider the following case::\n        \n            module a:\n              class Foo(object):\n                 pass\n        \n            module b:\n              import a\n              class Bar(a.Foo):\n                 pass\n        \n            def get_default(component, module, **data):\n                if module.__name__ == 'a':\n                   return \"we have a default value for module a\"\n                return martian.UNKNOWN\n        \n          When we now do this::\n        \n            some_directive.bind(get_default=get_default).get(b.Bar)\n        \n          We will get the value \"we have a default value for module a\". This\n          is because when trying to compute the default value for ``Bar`` we\n          returned ``martian.UNKNOWN`` to indicate the value couldn't be found\n          yet. The system then looks at the base class and tries again, and in\n          this case it succeeds (as the module-name is ``a``).\n        \n        * ``martian.ONCE_IFACE`` storage option to allow the creation of\n          directives that store their value on ``zope.interface``\n          interfaces. This was originally in ``grokcore.view`` but was of\n          wider usefulness.\n        \n        Bugs fixed\n        ----------\n        \n        * Ignore things that look like Python modules and packages but aren't.\n          These are sometimes created by editors, operating systems and\n          network file systems and we don't want to confuse them.\n        \n        * Ignore .pyc and .pyo files that don't have a matching .py file via\n          ``module_info_from_dotted_name`` if its ``ignore_nonsource``\n          parameter is ``True``.  The default is ``True``.  To revert to the\n          older behavior where .pyc files were honored, pass\n          ``ignore_nonsource=False``.\n        \n        * Pass along ``exclude_filter`` (and the new ``ignore_nonsource``\n          flag) to ModuleInfo constructor when it calls itself recursively.\n        \n        * Replace ``fake_import`` to import fake modules in tests with a real\n          python import statement (``from martiantest.fake import\n          my_fake_module``). This works by introducing a metaclass for\n          ``FakeModule`` that automatically registers it as a module. The\n          irony does not escape us. This also means that\n          ``martian.scan.resolve()`` will now work on fake modules.\n        \n        0.11 (2008-09-24)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * Added MULTIPLE_NOBASE option for directive store. This is like MULTIPLE\n          but doesn't inherit information from the base class.\n        \n        0.10 (2008-06-06)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * Add a ``validateClass`` validate function for directives.\n        \n        * Moved ``FakeModule`` and ``fake_import`` into a ``martian.testing``\n          module so that they can be reused by external packages.\n        \n        * Introduce new tutorial text as README.txt. The text previously in\n          ``README.txt`` was rather too detailed for a tutorial, so has been\n          moved into ``core.txt``.\n        \n        * Introduce a ``GrokkerRegistry`` class that is a ``ModuleGrokker``\n          with a ``MetaMultiGrokker`` in it. This is the convenient thing to\n          instantiate to start working with Grok and is demonstrated in the\n          tutorial.\n        \n        * Introduced three new martian-specific directives:\n          ``martian.component``, ``martian.directive`` and\n          ``martian.priority``. These replace the ``component_class``,\n          ``directives`` and ``priority`` class-level attributes. This way\n          Grokkers look the same as what they grok. This breaks backwards\n          compatibility again, but it's an easy replace operation. Note that\n          ``martian.directive`` takes the directive itself as an argument, and\n          then optionally the same arguments as the ``bind`` method of\n          directives (``name``, ``default`` and ``get_default``). It may be\n          used multiple times. Note that ``martian.baseclass`` was already a\n          Martian-specific directive and this has been unchanged.\n        \n        * For symmetry, add an ``execute`` method to ``InstanceGrokker``.\n        \n        0.9.7 (2008-05-29)\n        ==================\n        \n        Feature changes\n        ---------------\n        \n        * Added a ``MethodGrokker`` base class for grokkers that want to grok\n          methods of a class rather than the whole class itself.  It works\n          quite similar to the ``ClassGrokker`` regarding directive\n          definition, except that directives evaluated not only on class (and\n          possibly module) level but also for each method.  That way,\n          directives can also be applied to methods (as decorators) in case\n          they support it.\n        \n        0.9.6 (2008-05-14)\n        ==================\n        \n        Feature changes\n        ---------------\n        \n        * Refactored the ``martian.Directive`` base class yet again to allow\n          more declarative (rather than imperative) usage in grokkers.\n          Directives themselves no longer have a ``get()`` method nor a\n          default value factory (``get_default()``).  Instead you will have to\n          \"bind\" the directive first which is typically done in a grokker.\n        \n        * Extended the ``ClassGrokker`` baseclass with a standard ``grok()``\n          method that allows you to simply declare a set of directives that\n          are used on the grokked classes.  Then you just have to implement an\n          ``execute()`` method that will receive the data from those\n          directives as keyword arguments.  This simplifies the implementation\n          of class grokkers a lot.\n        \n        0.9.5 (2008-05-04)\n        ==================\n        \n        * ``scan_for_classes`` just needs a single second argument specifying\n          an interface. The support for scanning for subclasses directly has\n          been removed as it became unnecessary (due to changes in\n          grokcore.component).\n        \n        0.9.4 (2008-05-04)\n        ==================\n        \n        Features changes\n        ----------------\n        \n        * Replaced the various directive base classes with a single\n          ``martian.Directive`` base class:\n        \n          - The directive scope is now defined with the ``scope`` class\n            attribute using one of ``martian.CLASS``, ``martian.MODULE``,\n            ``martian.CLASS_OR_MODULE``.\n        \n          - The type of storage is defined with the ``store`` class attribute\n            using one of ``martian.ONCE``, ``martian.MULTIPLE``,\n            ``martian.DICT``.\n        \n          - Directives have now gained the ability to read the value that they\n            have set on a component or module using a ``get()`` method.  The\n            ``class_annotation`` and ``class_annotation_list`` helpers have\n            been removed as a consequence.\n        \n        * Moved the ``baseclass()`` directive from Grok to Martian.\n        \n        * Added a ``martian.util.check_provides_one`` helper, in analogy to\n          ``check_implements_one``.\n        \n        * The ``scan_for_classes`` helper now also accepts an ``interface``\n          argument which allows you to scan for classes based on interface\n          rather than base classes.\n        \n        Bug fixes\n        ---------\n        \n        * added dummy ``package_dotted_name`` to ``BuiltinModuleInfo``. This\n          allows the grokking of views in test code using Grok's\n          ``grok.testing.grok_component`` without a failure when it sets up the\n          ``static`` attribute.\n        \n        * no longer use the convention that classes ending in -Base will be considered\n          base classes. You must now explicitly use the grok.baseclass() directive.\n        \n        * The type check of classes uses isinstance() instead of type(). This means\n          Grok can work with Zope 2 ExtensionClasses and metaclass programming.\n        \n        0.9.3 (2008-01-26)\n        ==================\n        \n        Feature changes\n        ---------------\n        \n        * Added an OptionalValueDirective which allows the construction of\n          directives that take either zero or one argument. If no arguments\n          are given, the ``default_value`` method on the directive is\n          called. Subclasses need to override this to return the default value\n          to use.\n        \n        Restructuring\n        -------------\n        \n        * Move some util functions that were really grok-specific out of Martian\n          back into Grok.\n        \n        0.9.2 (2007-11-20)\n        ==================\n        \n        Bug fixes\n        ---------\n        \n        * scan.module_info_from_dotted_name() now has special behavior when it\n          runs into __builtin__. Previously, it would crash with an error. Now\n          it will return an instance of BuiltinModuleInfo. This is a very\n          simple implementation which provides just enough information to make\n          client code work. Typically this client code is test-related so that\n          the module context will be __builtin__.\n        \n        0.9.1 (2007-10-30)\n        ==================\n        \n        Feature changes\n        ---------------\n        \n        * Grokkers now receive a ``module_info`` keyword argument.  This\n          change is completely backwards-compatible since grokkers which don't\n          take ``module_info`` explicitly will absorb the extra argument in\n          ``**kw``.\n        \n        0.9 (2007-10-02)\n        =================\n        \n        Feature changes\n        ---------------\n        \n        * Reverted the behaviour where modules called tests or ftests were skipped\n          by default and added an API to provides a filtering function for skipping\n          modules to be grokked.\n        \n        0.8.1 (2007-08-13)\n        ==================\n        \n        Feature changes\n        ---------------\n        \n        * Don't grok tests or ftests modules.\n        \n        Bugs fixed\n        ----------\n        \n        * Fix a bug where if a class had multiple base classes, this could end up\n          in the resultant list multiple times.\n        \n        0.8 (2007-07-02)\n        ================\n        \n        Feature changes\n        ---------------\n        \n        * Initial public release.\n        \n        Download\n        ********\n        \nPlatform: UNKNOWN\nClassifier: Development Status :: 6 - Mature\nClassifier: Intended Audience :: Developers\nClassifier: License :: OSI Approved :: Zope Public License\nClassifier: Operating System :: OS Independent\nClassifier: Programming Language :: Python :: 2\nClassifier: Programming Language :: Python :: 2.7\nClassifier: Programming Language :: Python :: 3\nClassifier: Programming Language :: Python :: 3.4\nClassifier: Programming Language :: Python :: 3.5\nClassifier: Programming Language :: Python :: 3.6\nClassifier: Programming Language :: Python :: 3.7\nClassifier: Programming Language :: Python :: 3.8\nClassifier: Programming Language :: Python :: Implementation :: CPython\nClassifier: Programming Language :: Python :: Implementation :: PyPy\nClassifier: Topic :: Utilities\nProvides-Extra: test\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "martian",
    "package_url": "https://pypi.org/project/martian/",
    "platform": "",
    "project_url": "https://pypi.org/project/martian/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/martian/1.3/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Martian is a library that allows the embedding of configuration",
    "version": "1.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17417549,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "32702c17b1bffd5fd23afdc91a5e47f9b68f92204fbb64213ed692bfec0a2d01",
        "md5": "693011d31b828361ce3cefa2cf6c14bf",
        "sha256": "d9e33e50fefadf6bad35173b0484bc027829e9d01554f1522578bbbe61079b64"
      },
      "downloads": -1,
      "filename": "martian-1.3.tar.gz",
      "has_sig": false,
      "md5_digest": "693011d31b828361ce3cefa2cf6c14bf",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 66375,
      "upload_time": "2019-03-14T09:18:27",
      "upload_time_iso_8601": "2019-03-14T09:18:27.539536Z",
      "url": "https://files.pythonhosted.org/packages/32/70/2c17b1bffd5fd23afdc91a5e47f9b68f92204fbb64213ed692bfec0a2d01/martian-1.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}