{
  "info": {
    "author": "guangrun",
    "author_email": "3569843851@qq.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 3.2",
      "Framework :: Django :: 4.0",
      "Framework :: Django :: 4.1",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Utilities"
    ],
    "description": "# `django-notifications` Documentation\n\n[![build-status](https://travis-ci.org/django-notifications/django-notifications.svg)](https://travis-ci.org/django-notifications/django-notifications)\n[![Coverage Status](https://coveralls.io/repos/github/django-notifications/django-notifications/badge.svg?branch=master)](https://coveralls.io/github/django-notifications/django-notifications?branch=master)\n\n\n[django-notifications](https://github.com/django-notifications/django-notifications) is a GitHub notification alike app for Django, it was derived from [django-activity-stream](https://github.com/justquick/django-activity-stream)\n\nThe major difference between `django-notifications` and `django-activity-stream`:\n\n- `django-notifications` is for building something like Github \"Notifications\"\n- While `django-activity-stream` is for building Github \"News Feed\"\n\nNotifications are actually actions events, which are categorized by four main components.\n\n-   `Actor`. The object that performed the activity.\n-   `Verb`. The verb phrase that identifies the action of the activity.\n-   `Action Object`. *(Optional)* The object linked to the action\n    itself.\n-   `Target`. *(Optional)* The object to which the activity was\n    performed.\n\n`Actor`, `Action Object` and `Target` are `GenericForeignKeys` to any\narbitrary Django object. An action is a description of an action that\nwas performed (`Verb`) at some instant in time by some `Actor` on some\noptional `Target` that results in an `Action Object` getting\ncreated/updated/deleted.\n\nFor example: [justquick](https://github.com/justquick/) `(actor)`\n*closed* `(verb)` [issue\n2](https://github.com/justquick/django-activity-stream/issues/2)\n`(action_object)` on\n[activity-stream](https://github.com/justquick/django-activity-stream/)\n`(target)` 12 hours ago\n\nNomenclature of this specification is based on the Activity Streams\nSpec: <http://activitystrea.ms/specs/atom/1.0/>\n\n## Requirements\n\n-   Python 3.7, 3.8, 3.9, 3.10, 3.11\n-   Django 3.2, 4.0, 4.1\n\n## Installation\n\nInstallation is easy using `pip` and will install all required\nlibraries.\n```bash\n$ pip install django-notifications-hq\n```\nor get it from source\n\n```bash\n$ git clone https://github.com/django-notifications/django-notifications\n$ cd django-notifications\n$ python setup.py sdist\n$ pip install dist/django-notifications-hq*\n```\n\nNote that [django-model-utils](http://pypi.python.org/pypi/django-model-utils)\nwill be installed: this is required for the pass-through QuerySet manager.\n\nThen to add the Django Notifications to your project add the app\n`notifications` to your `INSTALLED_APPS` and urlconf.\n\nThe app should go somewhere after all the apps that are going to be\ngenerating notifications like `django.contrib.auth`\n\n```python\nINSTALLED_APPS = (\n    'django.contrib.auth',\n    ...\n    'notifications',\n    ...\n)\n```\n\nAdd the notifications urls to your urlconf:\n\n```python\nimport notifications.urls\n\nurlpatterns = [\n    ...\n    url('^inbox/notifications/', include(notifications.urls, namespace='notifications')),\n    ...\n]\n```\n\nThe method of installing these urls, importing rather than using\n`'notifications.urls'`, is required to ensure that the urls are\ninstalled in the `notifications` namespace.\n\nTo run schema migration, execute\n`python manage.py migrate notifications`.\n\n## Generating Notifications\n\nGenerating notifications is probably best done in a separate signal.\n\n```python\nfrom django.db.models.signals import post_save\nfrom notifications.signals import notify\nfrom myapp.models import MyModel\n\ndef my_handler(sender, instance, created, **kwargs):\n    notify.send(instance, verb='was saved')\n\npost_save.connect(my_handler, sender=MyModel)\n```\nTo generate an notification anywhere in your code, simply import the\nnotify signal and send it with your actor, recipient, and verb.\n\n```python\nfrom notifications.signals import notify\n\nnotify.send(user, recipient=user, verb='you reached level 10')\n```\n\nThe complete syntax is.\n\n```python\nnotify.send(actor, recipient, verb, action_object, target, level, description, public, timestamp, **kwargs)\n```\n\nArguments:\n\n-   **actor**: An object of any type. (Required) Note: Use\n    **sender** instead of **actor** if you intend to use keyword\n    arguments\n-   **recipient**: A **Group** or a **User QuerySet** or a list of\n    **User**. (Required)\n-   **verb**: An string. (Required)\n-   **action\\_object**: An object of any type. (Optional)\n-   **target**: An object of any type. (Optional)\n-   **level**: One of Notification.LEVELS (\\'success\\', \\'info\\',\n    \\'warning\\', \\'error\\') (default=info). (Optional)\n-   **description**: An string. (Optional)\n-   **public**: An boolean (default=True). (Optional)\n-   **timestamp**: An tzinfo (default=timezone.now()). (Optional)\n\n### Extra data\n\nYou can attach arbitrary data to your notifications by doing the\nfollowing:\n\n-   Add to your settings.py:\n    `DJANGO_NOTIFICATIONS_CONFIG = { 'USE_JSONFIELD': True}`\n\nThen, any extra arguments you pass to `notify.send(...)` will be\nattached to the `.data` attribute of the notification object. These will\nbe serialised using the JSONField\\'s serialiser, so you may need to take\nthat into account: using only objects that will be serialised is a good\nidea.\n\n### Soft delete\n\nBy default, `delete/(?P<slug>\\d+)/` deletes specified notification\nrecord from DB. You can change this behaviour to \\\"mark\n`Notification.deleted` field as `True`\\\" by:\n\n-   Add to your settings.py:\n    `DJANGO_NOTIFICATIONS_CONFIG = { 'SOFT_DELETE': True}`\n\nWith this option, QuerySet methods `unread` and `read` contain one more\nfilter: `deleted=False`. Meanwhile, QuerySet methods `deleted`,\n`active`, `mark_all_as_deleted`, `mark_all_as_active` are turned on. See\nmore details in QuerySet methods section.\n\n## API\n\n### QuerySet methods\n\nUsing `django-model-utils`, we get the ability to add queryset methods\nto not only the manager, but to all querysets that will be used,\nincluding related objects. This enables us to do things like:\n\n```python\n    Notification.objects.unread()\n```\n\nwhich returns all unread notifications. To do this for a single user, we\ncan do:\n\n```python\n    user = User.objects.get(pk=pk)\n    user.notifications.unread()\n```\n\nThere are some other QuerySet methods, too.\n\n#### `qs.unsent()`\n\nReturn all of the unsent notifications, filtering the current queryset.\n(emailed=False)\n\n#### `qs.sent()`\n\nReturn all of the sent notifications, filtering the current queryset.\n(emailed=True)\n\n#### `qs.unread()`\n\nReturn all of the unread notifications, filtering the current queryset.\nWhen `SOFT_DELETE=True`, this filter contains `deleted=False`.\n\n#### `qs.read()`\n\nReturn all of the read notifications, filtering the current queryset.\nWhen `SOFT_DELETE=True`, this filter contains `deleted=False`.\n\n#### `qs.mark_all_as_read()` \\| `qs.mark_all_as_read(recipient)`\n\nMark all of the unread notifications in the queryset (optionally also\nfiltered by `recipient`) as read.\n\n#### `qs.mark_all_as_unread()` \\| `qs.mark_all_as_unread(recipient)`\n\nMark all of the read notifications in the queryset (optionally also\nfiltered by `recipient`) as unread.\n\n#### `qs.mark_as_sent()` \\| `qs.mark_as_sent(recipient)`\n\nMark all of the unsent notifications in the queryset (optionally also\nfiltered by `recipient`) as sent.\n\n#### `qs.mark_as_unsent()` \\| `qs.mark_as_unsent(recipient)`\n\nMark all of the sent notifications in the queryset (optionally also\nfiltered by `recipient`) as unsent.\n\n#### `qs.deleted()`\n\nReturn all notifications that have `deleted=True`, filtering the current\nqueryset. Must be used with `SOFT_DELETE=True`.\n\n#### `qs.active()`\n\nReturn all notifications that have `deleted=False`, filtering the\ncurrent queryset. Must be used with `DELETE=True`.\n\n#### `qs.mark_all_as_deleted()` \\| `qs.mark_all_as_deleted(recipient)`\n\nMark all notifications in the queryset (optionally also filtered by\n`recipient`) as `deleted=True`. Must be used with `DELETE=True`.\n\n#### `qs.mark_all_as_active()` \\| `qs.mark_all_as_active(recipient)`\n\nMark all notifications in the queryset (optionally also filtered by\n`recipient`) as `deleted=False`. Must be used with `SOFT_DELETE=True`.\n\n### Model methods\n\n#### `obj.timesince([datetime])`\n\nA wrapper for Django\\'s `timesince` function.\n\n#### `obj.mark_as_read()`\n\nMark the current object as read.\n\n### Template tags\n\nPut `{% load notifications\\_tags %}` in the template before\nyou actually use notification tags.\n\n### `notifications_unread`\n\n```python\n    {% notifications_unread %}\n```\n\nGive the number of unread notifications for a user, or nothing (an empty\nstring) for an anonymous user.\n\nStoring the count in a variable for further processing is advised, such\nas:\n\n```python\n    {% notifications_unread as unread_count %}\n    ...\n    {% if unread_count %}\n        You have <strong>{{ unread_count }}</strong> unread notifications.\n    {% endif %}\n```\n\n## Live-updater API\n\nTo ensure users always have the most up-to-date notifications,\n`django-notifications` includes a simple javascript API for\nupdating specific fields within a django template.\n\nThere are two possible API calls that can be made:\n\n1.  `api/unread_count/` that returns a javascript object with 1 key:\n    `unread_count` eg:\n\n        {\"unread_count\":1}\n\n2.  `api/unread_list/` that returns a javascript object with 2 keys:\n    `unread_count` and `unread_list` eg:\n\n        {\n         \"unread_count\":1,\n         \"unread_list\":[--list of json representations of notifications--]\n        }\n\n    Representations of notifications are based on the django method:\n    `model_to_dict`\n\n    Query string arguments:\n\n    -   **max** - maximum length of unread list.\n    -   **mark\\_as\\_read** - mark notification in list as read.\n\n    For example, get `api/unread_list/?max=3&mark_as_read=true` returns\n    3 notifications and mark them read (remove from list on next\n    request).\n\n### How to use:\n\n1.  Put `{% load notifications_tags %}` in the template before you\n    actually use notification tags.\n\n2.  In the area where you are loading javascript resources add the\n    following tags in the order below:\n\n        <script src=\"{% static 'notifications/notify.js' %}\" type=\"text/javascript\"></script>\n        {% register_notify_callbacks callbacks='fill_notification_list,fill_notification_badge' %}\n\n    `register_notify_callbacks` takes the following arguments:\n\n    1.  `badge_class` (default `live_notify_badge`) - The identifier\n        `class` of the element to show the unread count,\n        that will be periodically updated.\n    2.  `menu_class` (default `live_notify_list`) - The identifier\n        `class` of the element to insert a list of unread\n        items, that will be periodically updated.\n    3.  `refresh_period` (default `15`) - How often to fetch unread\n        items from the server (integer in seconds).\n    4.  `fetch` (default `5`) - How many notifications to fetch each\n        time.\n    5.  `callbacks` (default `<empty string>`) - A comma-separated list\n        of javascript functions to call each period.\n    6.  `api_name` (default `list`) - The name of the API to call (this\n        can be either `list` or `count`).\n\n3.  To insert a live-updating unread count, use the following template:\n\n        {% live_notify_badge %}\n\n    `live_notify_badge` takes the following arguments:\n\n    -  `badge_class` (default `live_notify_badge`) - The identifier\n        `class` for the `<span>` element that will be created to show\n        the unread count.\n\n4.  To insert a live-updating unread list, use the following template:\n\n        {% live_notify_list %}\n\n    `live_notify_list` takes the following arguments:\n\n    -  `list_class` (default `live_notify_list`) - The identifier\n        `class` for the `<ul>` element that will be created to insert\n        the list of notifications into.\n\n### Using the live-updater with bootstrap\n\nThe Live-updater can be incorporated into bootstrap with minimal code.\n\nTo create a live-updating bootstrap badge containing the unread count,\nsimply use the template tag:\n\n    {% live_notify_badge badge_class=\"badge\" %}\n\nTo create a live-updating bootstrap dropdown menu containing a selection\nof recent unread notifications, simply use the template tag:\n\n    {% live_notify_list list_class=\"dropdown-menu\" %}\n\n### Customising the display of notifications using javascript callbacks\n\nWhile the live notifier for unread counts should suit most use cases,\nusers may wish to alter how unread notifications are shown.\n\nThe `callbacks` argument of the `register_notify_callbacks` dictates\nwhich javascript functions are called when the unread api call is made.\n\nTo add a custom javascript callback, simply add this to the list, like\nso:\n\n    {% register_notify_callbacks callbacks='fill_notification_badge,my_special_notification_callback' %}\n\nThe above would cause the callback to update the unread count badge, and\nwould call the custom function\n`my_special_notification_callback`. All callback\nfunctions are passed a single argument by convention called\n`data`, which contains the entire result from the API.\n\nFor example, the below function would get the recent list of unread\nmessages and log them to the console:\n\n```javascript\nfunction my_special_notification_callback(data) {\n    for (var i=0; i < data.unread_list.length; i++) {\n        msg = data.unread_list[i];\n        console.log(msg);\n    }\n}\n```\n\n### Testing the live-updater\n\n1.  Clone the repo\n2.  Run `./manage.py runserver`\n3.  Browse to `yourserverip/test/`\n4.  Click \\'Make a notification\\' and a new notification should appear\n    in the list in 5-10 seconds.\n\n## Serializing the django-notifications Model\n\nSee here - <http://www.django-rest-framework.org/api-guide/relations/#generic-relationships>\n\nIn this example the target object can be of type Foo or Bar and the\nappropriate serializer will be used.\n\n```python\nclass GenericNotificationRelatedField(serializers.RelatedField):\n\n    def to_representation(self, value):\n        if isinstance(value, Foo):\n            serializer = FooSerializer(value)\n        if isinstance(value, Bar):\n            serializer = BarSerializer(value)\n\n        return serializer.data\n\n\nclass NotificationSerializer(serializers.Serializer):\n    recipient = PublicUserSerializer(User, read_only=True)\n    unread = serializers.BooleanField(read_only=True)\n    target = GenericNotificationRelatedField(read_only=True)\n```\n\nThanks to @DaWy\n\n### `AbstractNotification` model\n\nIn case you need to customize the notification model in order to add\nfield or customised features that depend on your application, you can\ninherit and extend the `AbstractNotification` model, example:\n\n```python\n#In your_app/models.py\n\nfrom django.db import models\nfrom notifications.base.models import AbstractNotification\n\n\nclass Notification(AbstractNotification):\n    # custom field example\n    category = models.ForeignKey('myapp.Category',\n                                 on_delete=models.CASCADE)\n\n    class Meta(AbstractNotification.Meta):\n        abstract = False\n```\n\nYou will require to define `NOTIFICATIONS_NOTIFICATION_MODEL` setting in\n`setting.py` as follows:\n\n```python\n# In your_project/settings.py\n\nNOTIFICATIONS_NOTIFICATION_MODEL = 'your_app.Notification'\n```\n\n## Notes\n\n### Email Notification\n\nSending email to users has not been integrated into this library. So for\nnow you need to implement it if needed. There is a reserved field\n`Notification.emailed` to make it easier.\n\n### Sample App\n\nA sample app has been implemented in\n`notifications/tests/sample_notifications` that extends\n`django-notifications` with the sole purpose of testing its\nextensibility. You can run the SAMPLE APP by setting the environment\nvariable `SAMPLE_APP` as follows\n\n```bash\nexport SAMPLE_APP=1\n# Run the Django development server with sample_notifications app installed\npython manage.py runserver\n# Unset SAMPLE_APP to remove sample_notifications app from list of INSTALLED_APPS\nunset SAMPLE_APP\n```\n\n## `django-notifications` Team\n\nCore contributors (in alphabetical order):\n\n-   [Alvaro Leonel](https://github.com/AlvaroLQueiroz)\n-   [Federico Capoano](https://github.com/nemesisdesign)\n-   [Samuel Spencer](https://github.com/LegoStormtroopr)\n-   [Yang Yubo](https://github.com/yangyubo)\n-   [YPCrumble](https://github.com/YPCrumble)\n-   [Zhongyuan Zhang](https://github.com/zhang-z)\n\n## Contribute\n\nWe are looking for contributors, for anyone who\\'d like to contribute\nand willing to put time and energy on this project, please contact [Yang\nYubo](https://github.com/yangyubo).",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "django notifications github action event stream",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-notifications-test",
    "package_url": "https://pypi.org/project/django-notifications-test/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-notifications-test/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/django-notifications-test/1.7.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "A Test",
    "version": "1.7.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15990465,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "55b4ee83495350771dcc967a620671281bb9fcc1088b3a9d876648c789b8cc7c",
        "md5": "f6e3f3670ea1eca4f2ef395257700c18",
        "sha256": "69a9918cd797eaafb9f71c470cc3bf8c609396bc8c964e0962ff5a235f3774c1"
      },
      "downloads": -1,
      "filename": "django-notifications-test-1.7.1.tar.gz",
      "has_sig": false,
      "md5_digest": "f6e3f3670ea1eca4f2ef395257700c18",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 30162,
      "upload_time": "2022-12-03T02:36:07",
      "upload_time_iso_8601": "2022-12-03T02:36:07.774623Z",
      "url": "https://files.pythonhosted.org/packages/55/b4/ee83495350771dcc967a620671281bb9fcc1088b3a9d876648c789b8cc7c/django-notifications-test-1.7.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}