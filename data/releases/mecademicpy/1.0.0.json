{
  "info": {
    "author": "Mecademic",
    "author_email": "support@mecademic.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "![Mecademic](https://github.com/Mecademic/mecademicpy/blob/main/docs/logo/mecademic_logo.jpg?raw=true  \"Mecademic\")\n# Mecademic Python API\n\nA python module designed for robot products from Mecademic. The module offers tools that give access to the features of the Mecademic Robots such as MoveLin and MoveJoints available through the TCP/IP text interface. The module can be started from a terminal or a python application and controls the Mecademic products. \n\n#### Supported Robots\n\n * Meca500 R2, R3\n\n#### Supported Firmware Versions\n\n * 8.3 and up\n\n## Prerequisites\n\nPlease read the [user programming manual](https://mecademic.com/resources/documentation) to understand concepts necessary for proper usage of the API. This API implements a subset of the commands in the `Communicating over TCP/IP` section. For the exact list of available commands, use the `help()` command as explained in [API Reference](#api-reference).\n\nTo be able to use the module without unexpected errors, the user must have a copy of python installed on their machine and it is required to use python version 3.7 or higher. We recommend using Python 3.9 since this is the version on which this module is actively tested. [Python](https://www.python.org/) can be installed from its main website (a reboot will be require after the installation to complete the setup).\n\nThe user can validate their python installation by running `python --version` in a terminal.\n\nThis library is compatible with Windows, Linux, and Mac.\n\n## Downloading the package\n\nTo download and install the package, the user can easily do so through pip. Pip will download and install the package on your machine and place it in the python local packages directory. This is done by running the following command:\n\n```\npip install mecademicpy\n``` \n\n## Quick Start\n\n**Ensure the robot is properly connected to the computer, powered on, and in a nominal state.**\n\nIn a python shell or script, import the library. Then initialize an instance of the `Robot` class. Finally, use the `Connect` function by passing the IP Address of the robot as an argument to establish a connection:\n\n```python\nimport mecademicpy.robot as mdr\nrobot = mdr.Robot()\nrobot.Connect(address='192.168.0.100')\n```\n\nThe `Connect` function returns `True` if connection is successful.\nThis function is synchronous (awaits for success or timeout) even when using the `Robot` class in [asynchronous mode](#synchronous-vs.-asynchronous-mode). \n\nBefore using the robot, it must be activated and homed. To do so, run the following functions:\n\n```python\nrobot.ActivateRobot()\nrobot.Home()\n```\n\nThe robot should move slightly to perform its homing routine. We can also use `robot.WaitHomed()` or [synchronous mode](#synchronous-vs.-asynchronous-mode) to block execution until homing is done. \n\nOnce homing is complete, the robot is now ready to perform operations. [The user programming manual](https://mecademic.com/resources/documentation) or the documentation in the module is sufficient to be able to make the Robot perform actions and control the robot. \n\nHere is an example of a simple motion to perform:\n\n```python\nrobot.MoveJoints(0, 0, 0, 0, 0, 0)\nrobot.MoveJoints(0, -60, 60, 0, 0, 0)\n```\n\nWhen done with the robot, the user should always deactivate and disconnect. Note that deactivating before the motion is complete will cause the motion to immediately stop. The user can wait for motions to complete using `WaitIdle()`.\n\nDeactivating and disconnecting can be done with the following commands:\n\n```python\nrobot.WaitIdle()\nrobot.DeactivateRobot()\nrobot.Disconnect()\n```\n\nIf the robot encounters an error during operation, the robot will go into an error mode. In this mode, the module will block any command to the robot unless the error is reset. To properly reset errors on the robot, the following function must be run:\n\n```python\nrobot.ResetError()\n```\n\nFor complete and working examples, please refer to the `examples` folder.\n\n## Features and Additional Information\n\n### Synchronous vs. Asynchronous Mode\n\nBy default the API operates in 'asynchronous mode', which means sending a command to the robot does not block program execution. To illustrate, the following code will be able to successfully print out the changing joint values resulting from the `MoveJoints` command:\n\n```python\nimport mecademicpy.robot as mdr\nimport time\n\nrobot = mdr.Robot()\nrobot.Connect(address='192.168.0.100', enable_synchronous_mode=False)\nrobot.ActivateAndHome()\n\nrobot.MoveJoints(0, 0, 0, 0, 0, 0)\nrobot.MoveJoints(0, -60, 60, 0, 0, 0)\n\nfor _ in range(100):\n    print(robot.GetJoints())\n    time.sleep(0.05)\n\nrobot.WaitIdle()\nrobot.DeactivateRobot()\nrobot.Disconnect()\n```\n\nHowever, sometimes it is desired for programs to wait until the previous command is completed before sending the next command. It is generally encouraged to use the [checkpoints](#checkpoints) system or the various `Wait()` functions, but for smaller or simpler programs, the user can set `enable_synchronous_mode=True` to have each command block until the robot has completed the command.\n\nThe code block below will only print out the final joint position, since `robot.GetJoints()` doesn't execute until the motion is complete.\n\n```python\nimport mecademicpy.robot as mdr\nrobot = mdr.Robot()\nrobot.Connect(address='192.168.0.100', enable_synchronous_mode=True)\nrobot.ActivateAndHome()\n\nrobot.MoveJoints(0, 0, 0, 0, 0, 0)\nrobot.MoveJoints(0, -60, 60, 0, 0, 0)\n\n# The returned robot position will be (0, -60, 60, 0, 0, 0), because this line will only be executed once MoveJoints(0, -60, 60, 0, 0, 0) has completed.\nprint(robot.GetJoints())\n\nrobot.DeactivateRobot()\nrobot.Disconnect()\n```\n\nOne disadvantage of using synchronous mode is that blending between motions is not possible, since the next motion is not sent to the robot until the previous motion is complete.\n\n### Disconnect on Exception\n\nBy default, if any unrecoverable error occurs during usage of the Robot class, the class will automatically disconnect from the robot to avoid possible issues. Disconnection also causes the robot to pause its motion.\n\nHowever, disconnecting on exceptions may be undesired when using an interactive terminal or Jupyter notebook, as an accidental mal-formed function call may cause disconnection. As such, this feature can be disabled by setting `disconnect_on_exception=False` when attempting the connection:\n\n```python\nrobot.Connect(address='192.168.0.100', disconnect_on_exception=False)\n```\n\n### Checkpoints\n\nThe checkpoint system allows for creating event objects which will be triggered once the robot reaches a specified point in its execution. The `SetCheckpoint(n)` call registers a checkpoint with the robot (with `n` as the ID), and returns an event-type object that can be used to wait for the checkpoint. For example, the following code will wait until both `MoveJoints()` motions have completed, and then print \"`The MoveJoints() motions are complete.`\":\n\n```python\nrobot.MoveJoints(0, -60, 60, 0, 0, 0)\nrobot.MoveJoints(0, 0, 0, 0, 0, 0)\ncheckpoint_1 = robot.SetCheckpoint(1)\n\ncheckpoint_1.wait(timeout=10) # A timeout of 10s is set to avoid infinite wait in case of error.\nprint('The MoveJoints() motions are complete.')\n```\n\nNote that creating multiple checkpoints with the same ID is possible but not recommended. The checkpoints will be triggered in the order they are set.\n\nCheckpoints may also be set in an offline program, saved to robot memory. Use `ExpectExternalCheckpoint(n)` to receive these checkpoints while the robot is running the offline program. The call to `ExpectExternalCheckpoint(n)` should be made before the offline program is started, or otherwise must be guaranteed to occur before the robot can possibly send the checkpoint. For example, the following code will start an offline program and expect to receive a checkpoint from the program, and then print \"`Received expected external checkpoint`\":\n\n```python\nrobot.StartOfflineProgram(1)\ncheckpoint_event = robot.ExpectExternalCheckpoint(5)\ncheckpoint_event.wait(30)\nprint(\"Received expected external checkpoint\")\n```\nwhere offline program 1 is\n```\nStartSaving(1)\nMoveJoints(100,0,0,0,0,0)\nMoveJoints(-100,0,0,0,0,0)\nSetCheckpoint(5)\nMoveJoints(0,-60,60,0,0,0)\nMoveJoints(0,0,0,0,0,0)\nSetOfflineProgramLoop(1)\nStopSaving\n```\n\nIf the robot motion command queue is cleared (using `ClearMotion()` for example), or the robot is disconnected, all pending checkpoints will be aborted, and all active `wait()` calls will raise an `InterruptException`.\n\n### Callbacks\n\nThe `Robot` class supports user-provided callback functions on a variety of events. These callbacks are entirely optional and are not required, but useful to implement asynchronous applications. The available events are listed in the `RobotCallbacks` class. Here are some of these callbacks:\n\n- `on_connected`\n- `on_disconnected`\n- `on_activated`\n- `on_deactivated`\n- `on_homed`\n- `on_error`\n- `on_checkpoint_reached`\n- etc... (refer to class `RobotCallbacks` for exhaustive list of callbacks)\n\nNote that some callbacks pass arguments. For example `on_checkpoint_reached` passes the ID of the checkpoint, `on_command_message` and `on_monitor_message` passes a `mecademicpy.robot.Message` object. Refer to class documentation for details.\n\nA simple usage example:\n\n```python\nimport mecademicpy.robot as mdr\nrobot = mdr.Robot()\n\ndef print_connected():\n    print('Connected!')\n\ncallbacks = mdr.RobotCallbacks()\ncallbacks.on_connected = print_connected\n\nrobot.RegisterCallbacks(callbacks=callbacks, run_callbacks_in_separate_thread=True)\nrobot.Connect(address='192.168.0.100') # Will print 'Connected!' if successful.\n```\n\nIf the user does not want to automatically run callbacks in a separate thread, set `run_callbacks_in_separate_thread=False` and call `RunCallbacks()` when ready to run all triggered callbacks.\n\nRunning any callback in a separate thread (either through the `Robot` class or otherwise) requires that the callback function is thread-safe and uses the proper locks when accessing shared state. Calling any public method of the `Robot` class is thread-safe.\n\nNote that, due to a Python limitation, all Python threads share the same CPU core and will not take advantage of parallelism and multiple CPU cores of a PC. Unfortunately, this means that an application performing heavy computations (in callback thread or in any other thread) may impact the performance of the `Robot` class (especially when processing many monitoring messages at high frequency).\n\nIf non-trivial computation and high-frequency monitoring are both necessary, the user may offload computation into a separate python process using the built-in [multiprocessing](https://docs.python.org/3/library/multiprocessing.html) library.\n\n### Handling Robot Errors\n\nIf the robot encounters an error during use, the robot will go into error mode. In this mode, the module will refuse any command to the robot unless the error is reset. If the robot is in an error state, `GetStatusRobot().error_status` will return `True`. To properly reset errors on the robot, the following function must be run:\n\n```python\nrobot.ResetError()\n```\n\nIt may also be necessary to call `ResumeMotion()`.\n\nThe `on_error` callback can also be used to manage robot errors.\n\nImproper use of the class can also cause exceptions to be raised. For example, calling `MoveJoints()` without any arguments will raise an exception. \n\nIf the user is waiting on an event or checkpoint that the `Robot` class later determines will never occur, the event will unblock and raise an exception. For example, if the user is waiting on a checkpoint (`WaitCheckpoint`), but calls `Disconnect()` or `ClearMotion()` before the checkpoint is received, the checkpoint will unblock and raise an exception. Events and checkpoints will also unblock with exception on robot error state.\n\nThe user should use python's built-in `try...except` blocks to handle appropriate exceptions.\n\n### Preserved State on Disconnection\n\nOnce the robot is disconnected, not all state is immediately cleared. Therefore, it is possible to still get the last-known state of the robot. \n\n### Logging Data to File\n\nIt is possible to continuously log the robot state to a file using the API either using the `StartLogging` and `EndLogging` functions or using the `FileLogger` context. \n\nAn example usage of `StartLogging` and `EngLogging`:\n\n```python\nrobot.WaitIdle()\nrobot.WaitEndOfCycle()\nrobot.StartLogging(0.001)\ntry:\n    robot.MoveJoints(0, -60, 60, 0, 0, 0)\n    robot.MoveJoints(0, 0, 0, 0, 0, 0)\n    robot.WaitIdle()\nexcept BaseException as e:\n    print(f'Logging unsuccessful, exception encountered: {e}')\nfinally:\n    robot.EndLogging()\n```\n\nNote that the user should wait for the robot to be idle before starting to log, and also wait for idle before ending the log. This is to ensure the log correctly captures the movements of interest. It is also recommended to wait for the end of a monitoring cycle before and after logging, as the logger will thus produce more consistently sized files.\n\nIt should also be noted that it is mandatory to give a monitoring interval, in seconds, to `StartLogging`, to specify at which rate data should be logged. In the example above, the monitoring interval is set at 0.001 seconds, or 1 ms. It is the minimum monitoring interval that can be set using `SetMonitoringInterval`, which is the robot command used by `StartLogging` to choose the monitoring interval.\n\nThe user can also use the `FileLogger` context:\n\n```python\nrobot.WaitIdle()\nrobot.WaitEndOfCycle()\nwith robot.FileLogger(0.001):\n    robot.MoveJoints(0, -60, 60, 0, 0, 0)\n    robot.MoveJoints(0, 0, 0, 0, 0, 0)\n    robot.WaitIdle()\n```\n\nThe `FileLogger` context will automatically end logging after either completing the `with` block or encountering an exception.\n\nThe user can select which fields to log using the `fields` parameter in `StartLogging` or `FileLogger`. By default, all available fields are logged. The available fields are currently:\n\n- `\"TargetJointPos\"` \n- `\"TargetCartPos\"`\n- `\"TargetJointVel\"`\n- `\"TargetCartVel\"`\n- `\"TargetConf\"`\n- `\"TargetConfTurn\"`\n\n- `\"JointPos\"`\n- `\"CartPos\"`\n- `\"JointVel\"` \n- `\"JointTorq\"` \n- `\"CartVel\"` \n- `\"Conf\"` \n- `\"ConfTurn\"`\n\n- `\"Accel\"`\n\n\nThese strings should be placed into the list given to the `fields` parameter.\n\nThe following example only logs the `\"TargetJointPos\"` and `\"JointPos\"`.\n\n```python\nrobot.WaitIdle()\nrobot.WaitEndOfCycle()\nwith robot.FileLogger(0.001, fields=['TargetJointPos', 'JointPos']):\n    robot.MoveJoints(0, -60, 60, 0, 0, 0)\n    robot.MoveJoints(0, 0, 0, 0, 0, 0)\n    robot.WaitIdle()\n```\n\nNote that the `SetRealTimeMonitoring` command is used by in `StartLogging` or `FileLogger` to enable all the real-time monitoring events which are logged.\n\n### Sending Custom Commands\n\nIt is possible to send an arbitrary command to the robot using the `SendCustomCommand()` call. The user can optionally provide expected response codes, which will cause `SendCustomCommand()` to return an event which can be used to wait for the response.\n\nExample usage:\n```python\nimport mecademicpy.robot as mdr\nimport mecademicpy.mx_robot_def as mdr_def\n# Connect, activate, and home robot...\n\nresponse_codes = [mdr_def.MX_ST_ERROR_RESET, mdr_def.MX_ST_NO_ERROR_RESET]\nresponse_event = robot.SendCustomCommand('ResetError', expected_responses=response_codes)\nresponse = response_event.wait(timeout=10)\n```\n\nAlthough raw numerical response codes can also be used, it is recommended to use the named aliases provided in `mx_robot_def.py` for clarity.\n\n### API Reference\n\nFor a complete list of available methods and further documentation, use the help() function on any class in a python terminal (such as `ipython`).\n\n```python\n>>> import mecademicpy.robot as mdr\n>>> help(mdr.Robot)\n>>> help(mdr.Message)\n>>> help(mdr.RobotCallbacks)\n```\n\n## Getting Help\n\n\n\nTo get support, you can start an issue on the Mecademic github page, issues section or send an email to support@mecademic.com.\n\n## License\n\nAll packages in this repository are licensed under the MIT license.\n\n## Authors \n\n* **Mecademic** - *Continuous work*\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Mecademic/mecademicpy",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mecademicpy",
    "package_url": "https://pypi.org/project/mecademicpy/",
    "platform": "",
    "project_url": "https://pypi.org/project/mecademicpy/",
    "project_urls": {
      "Homepage": "https://github.com/Mecademic/mecademicpy"
    },
    "release_url": "https://pypi.org/project/mecademicpy/1.0.0/",
    "requires_dist": [
      "dataclasses-json (>=0.5.4)",
      "pandas"
    ],
    "requires_python": ">=3.7",
    "summary": "A package to control the Mecademic robots through python",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15869499,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ae430b7226b7e592f3d45d5a9de9df672ef7a31fe7b4fdc324ffb73df0be2a57",
        "md5": "6bca4e0d8ce7aa8ba7b8f1c20501859b",
        "sha256": "fb954f79ec250381570bce1909a3e9ef465d2ce12edf76d48826a9042540ec9f"
      },
      "downloads": -1,
      "filename": "mecademicpy-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6bca4e0d8ce7aa8ba7b8f1c20501859b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 54116,
      "upload_time": "2021-09-09T15:46:27",
      "upload_time_iso_8601": "2021-09-09T15:46:27.606349Z",
      "url": "https://files.pythonhosted.org/packages/ae/43/0b7226b7e592f3d45d5a9de9df672ef7a31fe7b4fdc324ffb73df0be2a57/mecademicpy-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "22bec38604c9cbfe49312b5fa6f16b0436835ec1097c669f6e0ae3e3f92bb7f2",
        "md5": "9d6d94b320ebdf7d4845f59bede6a6d9",
        "sha256": "2aee42d9381ecfa2909a4bdd03d4fe7101808485e0646df1cafb665c78124bd2"
      },
      "downloads": -1,
      "filename": "mecademicpy-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "9d6d94b320ebdf7d4845f59bede6a6d9",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 51877,
      "upload_time": "2021-09-09T15:46:29",
      "upload_time_iso_8601": "2021-09-09T15:46:29.282429Z",
      "url": "https://files.pythonhosted.org/packages/22/be/c38604c9cbfe49312b5fa6f16b0436835ec1097c669f6e0ae3e3f92bb7f2/mecademicpy-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}