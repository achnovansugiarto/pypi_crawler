{
  "info": {
    "author": "Ryan Emenecker - Holehouse Lab - WUSM",
    "author_email": "remenecker@wustl.edu",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# metapredict: A machine learning-based tool for predicting protein disorder.\n\n**Important update** - as of February 15, 2022 we have updated metapredict to V2.0. This comes with important changes that improve the accuracy of metapredict. Please see the section on the update *Major update to metapredict predictions to increase overall accuracy* below. In addition, this update changes the functionality of the *predict_disorder_domains()* function, so please read the documentation on that function if you were using it previously. \n\n**metapredict** uses a bidirectional recurrent neural network trained on the consensus disorder values from 8 disorder predictors from 12 proteomes that were obtained from [MobiDB](https://mobidb.bio.unipd.it/). In addition, as of version 2, metapredict incorporates an additional layer of predictions by counter-selecting based on structure predictions from AlphaFold2. The creation of metapredict was made possible by [parrot](https://github.com/idptools/parrot).\n\n## How can I use metapredict?\nMetapredict can be used in four different ways:\n\n1. As a stand-alone command-line tool (installable via pip - the code in this repository).\n2. As a Python library for integrating into your favorite bioinformatics pipeline (installable via pip - the code in this repository).\n3. As a web-server for examining disorder predictions on individual sequences found at [https://metapredict.net/](https://metapredict.net/).\n4. *NEW as of August 2022:* as a Google Colab notebook for batch-predicting disorder scores for larger numbers of sequences: [**LINK HERE**](https://colab.research.google.com/drive/1UOrOxun9i23XDE8lFo_4I89Tw8P3Z1D-?usp=sharing). Performance-wise, batch mode can predict the entire yeast proteome in ~6 min.\n\n\n\n## What is metapredict?\n\n**metapredict** is a bit different than your typical protein disorder predictor. Instead of predicting the percent chance that a residue within a sequence might be disordered, metapredict tries to predict the consensus disorder score for the residue. This is because metapredict was trained on **consensus** values from MobiDB. These values are the percent of other disorder predictors that predicted a residue in a sequence to be disordered. For example, if a residue in a sequence has a value of 1 from the MobiDB consensus values, then *all disorder predictors predicted that residue to be disordered*. If the value was 0.5, than half of the predictors predicted that residue to be disordered. In this way, metapredict can help you quickly determine the likelihood that any given sequence is disordered by giving you an approximation of what other predictors would predict (things got pretty 'meta' there, hence the name metapredict).\n\n## Major update to metapredict predictions to increase overall accuracy\n\nWe are always working to make metapredict better, and we have recently managed just that. More details will be below, but the short story is that we have made significant improvements in the accuracy of disorder predictions using metapredict. By analyzing our new network using the Disprot-PDB dataset predictions, we found that the MCC (which is a measurement accounting for false positives, false negatives, true positives, and true negatives) for metapredict increased from 0.588 for the old (original) network to 0.7 for our new network. To put this in perspective, our original network was ranked 12th most accurate when analyzing the Disprot-PDB dataset, and it is now ranked as the 2nd most accurate available predictor. We should also note that we are still trying a few 'tweaks' to this new network and plan to updated it if we can improve accuracy any further We will be publishing the updated benchmarks for the 'new metapredict' in the near future (unless we already have but forgot to take this sentence out of the documentation...).\n\n### But wait! I need the old metapredict predictions!!!\n\nNo worries! We left users access to the old network. The *default network is now our new, more accurate network*. However, by calling **-l** or **--legacy** from the command line or by specifying **legacy=True** from Python, you will be able to use the original metapredict network. We wanted to keep making metapredict better, but we also wanted to minimize disruptions to anyone currently relying on the original metapredict predictions for whatever reason.\n\n\n## So... how exactly was this more more accurate metapredict network made?\n\nWe didn't think it was possible, but metapredict has somehow become *even more meta*. Get ready, because things are about to get a little weird. When we implemented the AlphaFold2 pLDDT prediction feature (see section below), we noticed that there were occasional discrepancies between metapredict and the predicted pLDDT (ppLDDT) scores. When the ppLDDT scores get high enough, it is unlikely that a given region is actually disordered. So, we developed a version of metapredict that we originally called 'metapredict-hybrid' that essentially combined aspects of the ppLDDT scores and the original metapredict scores. We found that this 'hybrid predictor' was **much better** than the original metapredict disorder predictor at predicting disordered regions. **But we didn't stop there.** We think one of metapredicts best features is *it is really really fast*. This 'hybrid-predictor' was a little on the slow side, coming in at about 1/3 the speed of the original metapredict predictor. This is still VERY fast, but we thought we could do better. So, we took a little over 300,000 protein sequences and generated metapredict-hybrid scores for those sequences. We then fed those sequences and the corresponding metapredict-hybrid scores and generated a new bidirectional recurrent neural network (BRNN) using PARROT. We then tested this new network against the original metapredict-hybrid predictions and the original metapredict network. The new network that was trained on metapredict-hybrid scores *actually outperformed the metapredict-hybrid predictions when benchmarking against Disprot-PDB*. Importantly, this new (super accurate) network was only 30% slower than the original metapredict network, which is substantially better than the 70% hit that metapredict-hybrid took. \n \n**TL;DR** We made the original metapredict predictor using a network trained on consensus scores from MobiDB. We then trained a network on AlphaFold2 pLDDT scores. Next, we made a predictor that combined prediction values from the original metapredict predictor and the AlphaFold2 pLDDT predictor to make very accurate disorder predictions. Finally, we took hundreds of thousands of proteins, generated disorder prediction scores using the aforementioned combination of the original metapredict predictions and the AlphaFold2 predictions, and then trained our final network on those scores. **That's pretty dang meta.**\n\n\n### In addition to predicting disorder, metapredict also can predict AlphaFold2 pLDDT confidence scores\n\nIn addition, metapredict offers predicted pLDDT confidence scores from AlphaFold2. These predicted scores use a bidirectional recurrent neural network (BRNN) trained on the per residue pLDDT (predicted IDDT-Ca) confidence scores generated by AlphaFold2 (AF2). The confidence scores (pLDDT) from the proteomes of *Danio rerio*, *Candida albicans*, *Mus musculus*, *Escherichia coli*, *Drosophila melanogaster*, *Methanocaldococcus jannaschii*, *Plasmodium falciparum*, *Mycobacterium tuberculosis*, *Caenorhabditis elegans*, *Dictyostelium discoideum*, *Trypanosoma cruzi*, *Saccharomyces cerevisiae*, *Schizosaccharomyces pombe*, *Rattus norvegicus*, *Homo sapiens*, *Arabidopsis thaliana*, *Zea mays*, *Leishmania infantum*, *Staphylococcus aureus*, *Glycine max*, *Oryza sativa* were used to generate the BRNN. These pLDDT scores measure the local confidence that AlphaFold2 has in its predicted structure. The scores go from 0-100 where 0 represents low confidence and 100 represents high confidence. For more information, please see: *Highly accurate protein structure prediction with AlphaFold* https://doi.org/10.1038/s41586-021-03819-2. In describing these scores, the team states that regions with pLDDT scores of less than 50 should not be interpreted except as *possible* disordered regions.\n\n\n### What might the predicted pLDDT scores from AlphaFold2 be used for?\n\nThese scores can be used for many applications such as generating a quick preview of which regions of your protein of interest AF2 might be able to predict with high confidence, or which regions of your protein *might* be disordered. AF2 is not (strictly speaking) a disorder predictor, and the pLDDT scores are not directly representative of protein disorder. Therefore, any conclusions drawn with regards to disorder from predicted AF2 pLDDT scores should be interpreted with care, but they may be able to provide an additional metric to assess the likelihood that any given protein region may be disordered.\n\n \n## Why is metapredict useful?\n\nA major drawback of consensus disorder databases is that they can only give you values of *previously predicted protein sequences*. Therefore, if your sequence of interest is not in their database, tough luck. In addition, installing multiple different predictors to generate consensus scores locally is computationally expensive, time consuming, and in some cases simply not possible. Fortunately, **metapredict** gives you a way around this problem!\n\n**metapredict** allows for predicting disorder for any amino acid sequence, and predictions can be output as graphs or as raw values. Additionally, metapredict allows for predicting disorder values for protein sequences from .fasta files either directly in Python or from the command-line. This gives maximum flexibility so the user can easily predict/graph disorder from a single sequence or for an entire proteome.\n\nFor full documentation, please see:\nhttps://metapredict.readthedocs.io/en/latest/getting_started.html\n\nFor disorder predictions using our server, please see:\nhttps://metapredict.net\n\n\n## What's new?\n\nThe most recent update to metapredict on March 15, 2023 introduced multiprocessing support to the command-line interface (you're welcome, Jeff). This is only implemented for the CLI at this time. **We were able to predict disorder in the entire human proteome in about 4 minutes with metapredict V2 and in about 2 minutes using legacy metapredict!** *We didn't even have to close the 40 chrome tabs we definitely had to have open for testing.* If there is additional interest in speeding up other functionality by using multiple cores, let us know!\n\n\n## How to cite metapredict\n\nIf you use metapredict for your work, please cite the metapredict paper - \n \n*Emenecker RJ, Griffith D, Holehouse AS, metapredict: a fast, accurate, and easy-to-use predictor of consensus disorder and structure, Biophysical Journal (2021), doi: https:// doi.org/10.1016/j.bpj.2021.08.039.*\n\n\n## Installation:\n\n**metapredict** is available through PyPI - to install simply run\n\n\t$ pip install metapredict\n\n\nAlternatively, you can get **metapredict** directly from GitHub. \n\nTo clone the GitHub repository and gain the ability to modify a local copy of the code, run\n\n\t$ git clone https://github.com/idptools/metapredict.git\n\t$ cd metapredict\n\t$ pip install .\n\nThis will install **metapredict** locally.\n\n## Usage:\n\nThere are two ways you can use metapredict:\n1. Directly from the command-line\n2. From within Python\n\n## Using metapredict from the command-line:\n\n**Note** for any commands from the command-line, if you need to use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n\n### Predicting Disorder from a fasta file\n\nThe ``metapredict-predict-disorder`` command from the command line takes a .fasta file as input and returns disorder scores for the sequences in the FASTA file.\n\n\t$ metapredict-predict-disorder <Path to .fasta file>\n\n**Example**\n\n\t$ metapredict-predict-disorder /Users/thisUser/Desktop/interestingProteins.fasta \n\n**Additional Usage**\n\n**specifying where to save the output -** \nIf you would like to specify where to save the output, simply use the ``-o`` or ``--output-file`` flag and then specify the file path and file name. By default this command will save the output file as disorder_scores.csv to your current working directory. However, you can specify the file name in the output path.\n\n**Example**\n\n    $ metapredict-predict-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/disorder_predictions/my_disorder_predictions.csv\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n### Predicting Disorder from a fasta file using multiple cores\n\nThe ``metapredict-multipredict`` command from the command line takes a .fasta file as input and returns disorder scores for the sequences in the FASTA file. It works the same as metapredict-predict-disroder but splits the sequences across the number of cores you specify. USE THIS AT YOUR OWN RISK! If you specify too many cores, you're going to have a bad time.\n\n\t$ metapredict-multipredict <Path to .fasta file> <number of cores>\n\n**Example - using 5 cores**\n\n\t$ metapredict-multipredict /Users/thisUser/Desktop/interestingProteins.fasta 5\n\n**Additional Usage**\n\n**specifying where to save the output -** \nIf you would like to specify where to save the output, simply use the ``-o`` or ``--output-file`` flag and then specify the file path and file name. By default this command will save the output file as disorder_scores.csv to your current working directory. However, you can specify the file name in the output path.\n\n**Example**\n\n    $ metapredict-multipredict /Users/thisUser/Desktop/interestingProteins.fasta 5 -o /Users/thisUser/Desktop/disorder_predictions/my_disorder_predictions.csv\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n### Predicting Disorder from a sequence\n\n``metapredict-quick-predict`` is a command that will let you input a sequence and get disorder values immediately printed to the terminal. The only argument that can be input is the sequence.\n\n**Example:**\n\n\t$ metapredict-quick-predict ISQQMQAQPAMVKSQQQQQQQQQQHQHQQQQLQQQQQLQMSQQQVQQQGIYNNGTIAVAN\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n\n### Predicting AlphaFold2 Confidence Scores from a fasta file\n\nThe ``metapredict-predict-pLDDT`` command from the command line takes a .fasta file as input and returns predicted AlphaFold2 pLDDT scores for the sequences in the FASTA file.\n\n\t$ metapredict-predict-pLDDT <Path to .fasta file>\n\n**Example**\n\n\t$ metapredict-predict-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta \n\n**Additional Usage**\n\n**Specify where to save the output -** \nIf you would like to specify where to save the output, simply use the ``-o`` or ``--output-file`` flag and then specify the file path. By default this command will save the output file as pLDDT_scores.csv to your current working directory. However, you can specify the file name in the output path.\n\n**Example**\n\n    $ metapredict-predict-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/disorder_predictions/my_pLDDT_predictions.csv\n\n\n### Graphing Disorder from a fasta file\n\nThe ``metapredict-graph-disorder`` command from the command line takes a .fasta file as input and returns a graph for every sequence within the .fasta file. **Warning** This will return a graph for every sequence in the FASTA file. \n\n\t$ metapredict-graph-disorder <Path to .fasta file> \n\n**Example**\n\n\t$ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta \n\nIf no output directory is specified, this function will make an output directory in the current working directory called *disorder_out*. This directory will hold all generated graphs.\n\n**Additional Usage**\n\n**Adding AlphaFold2 Confidence Scores -**\nTo add predicted AlphaFold2 pLDDT scores, simply use the ``-p`` or ``--pLDDT`` flag.\n\n**Example**\n\n\t$ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -p\n\n\n**Specifying where to save the output -**\nTo specify where to dave the output, simply use the ``-o`` or ``--output-directory`` flag.\n\n**Example**\n\n    $ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/FolderForCoolPredictions\n\n\n**Changing resolution of saved graphs -**\nBy default, the output graphs have a DPI of 150. However, the user can change the DPI of the output (higher values have greater resolution but take up more space). To change the DPI simply add the flag ``-D`` or ``--dpi`` followed by the wanted DPI value. \n\n**Example**\n\n\t$ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/DisorderGraphsFolder/ -D 300\n\n\n**Changing the file type -**\nBy default the graphs will save as .png files. However, you can specify the file type by calling ``--filetype`` and then specifying the file type. Any matplotlib compatible file extension should work (for example, pdf).\n\n**Example**\n\n    $ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/DisorderGraphsFolder/ --filetype pdf\n\n**Indexing file names -**\nIf you would like to index the file names with a leading unique integer starting at 1, use the ``--indexed-filenames`` flag.\n\n**Example**\n\n    $ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/DisorderGraphsFolder/ --indexed-filenames\n\n**Changing the disorder threshhold line on the graph -**\nIf you would like to change the disorder threshold line plotted on the graph, use the ``--disorder-threshold`` flag followed by some value between 0 and 1. Default is 0.3.\n\n**Example**\n\n    $ metapredict-graph-disorder /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/DisorderGraphsFolder/ --disorder-threshold 0.5\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n\n### Graphing Disorder from a sequence\n\n``metapredict-quick-graph`` is a command that will let you input a sequence and get a plot of the disorder back immediately. You cannot input fasta files for this command. The command only takes three arguments, 1. the sequence 2. *optional* DPI ``-D``  or ``--dpi`` of the output graph which defaults to 150 DPI, and 3. *optional* to include predicted AlphaFold2 condience scores, use the ``-p`` or ``--pLDDT`` flag.\n\n\n**Example:**\n\n\t$ metapredict-quick-graph ISQQMQAQPAMVKSQQQQQQQQQQHQHQQQQLQQQQQLQMSQQQVQQQGIYNNGTIAVAN\n\n**Example:**\n\n\t$ metapredict-quick-graph ISQQMQAQPAMVKSQQQQQQQQQQHQHQQQQLQQQQQLQMSQQQVQQQGIYNNGTIAVAN -D 200\n\n**Example:**\n\n\t$ metapredict-quick-graph ISQQMQAQPAMVKSQQQQQQQQQQHQHQQQQLQQQQQLQMSQQQVQQQGIYNNGTIAVAN -D 200 -p\n\n### Graphing Disorder from a Uniprot ID\n\n``metapredict-uniprot`` is a command that will let you input any Uniprot ID and get a plot of the disorder for the corresponding protein. The default behavior is to have a plot automatically appear. Apart from the Uniprot ID which is required for this command, the command has four possible additional *optional* arguments, 1. To include predicted AlphaFold2 2 pLDDT confidence scores, use the ``-p``  or ``--pLDDT`` flag. DPI can be changed with the ``-D``  or ``--dpi`` flags, default is 150 DPI, 3. Using ``-o``  or ``--output-file`` will save the plot to a specified directory (default is current directory) - filenames and file extensions (pdf, jpg, png, etc) can be specified here. If there is no file name specified, it will save as the Uniprot ID and as a .png, 4. ``-t``  or ``--title`` will let you specify the title of the plot. By default the title will be *Disorder for* followed by the Uniprot ID.\n\n**Example:**\n\n\t$ metapredict-uniprot Q8RYC8\n\n**Example:**\n\n\t$ metapredict-uniprot Q8RYC8 -p\n\n**Example:**\n\n\t$ metapredict-uniprot Q8RYC8 -D 300\n\n**Example:**\n\n\t$ metapredict-uniprot Q8RYC8 -o /Users/ThisUser/Desktop/MyFolder/DisorderGraphs\n\n**Example:**\n\n\t$ metapredict-uniprot Q8RYC8 -o /Users/ThisUser/Desktop/MyFolder/DisorderGraphs/my_graph.png\n\n**Example:**\n\n    $ metapredict-uniprot Q8RYC8 -t ARF19\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n\n### Graphing disorder using the common name of a protein\n\nSometimes you just don't know the Uniprot ID for your favorite protein, and looking it up can be a pain. With the ``metapredict-name`` command, you can input the common name of your favorite protein and get a graph in return. Metapredict will also print the name of the organisms and the uniprot ID it found so you know you're looking at the correct protein. This is because this functionality queries your input protein name on Uniprot and takes the top hit. Sometimes this is the protein you're looking for, but not always. To increase the likelihood of success, use your protein name and the organism name for this command.\n\n*Example*\n\n\t$ metapredict-name p53 \n\nwill graph the metapredict disorder scores for the Homo sapiens p53 protein. This is because Homo sapiens p53 is the top hit on Uniprot when you search p53. However...\n\n\t$ metapredict-name p53 chicken\n\nwill graph the p53 from Gallus gallus!\n\n**Additional Usage**\n\n**Changing the DPI**\n\nChanging the DPI will adjust the resolution of the graph. To change the DPI, use the ``-D`` or ``--dpi`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -D 300\n\n\n**Graphing predicted pLDDT scores**\n\nTo add predicted pLDDT scores to the graph, use the ``-p`` or ``--pLDDT`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -p\n\n\n**Changing the title**\n\nTo change the title, use the ``-t`` or ``--title`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -t my_cool_graph_of_p53\n\n\n**Using the legacy version of metapredict**\n\nTo use the legacy version of metapredict for your disorder scores, use the ``-l`` or ``--legacy`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -l\n\n\n**Printing the full Uniprot ID to your terminal**\n\nTo have your terminal print the entire Uniprot ID as well as the full protein sequence from your specified protein upon graphing, use the ``-v`` or ``--verbose`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -v\n\n\n**Turning off all printing to the terminal**\n\nBy default, the *metapredict-name* command prints the uniprot ID as well as other information related to your protein to the terminal. The purpose of this is to make it explicitly clear which protein was graphed because grabbing the top hit from Uniprot *does not gaurentee* that it is the protein you want or expected. However, this behavior can be turned off by using the ``-s`` or ``--silent`` flag.\n\n**Example**\n\n\t$ metapredict-name p53 -s\n\n\n\n\n### Graphing Predicted AlphaFold2 Confidence Scores from a fasta file\n\nThe ``metapredict-graph-pLDDT`` command from the command line takes a .fasta file as input and returns a graph of the predicted AlphaFold2 pLDDT confidence score for every sequence within the .fasta file. **Warning** This will return a graph for every sequence in the FASTA file. \n\n\t$ metapredict-graph-pLDDT <Path to .fasta file> \n\n**Example**\n\n\t$ metapredict-graph-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta \n\nIf no output directory is specified, this function will make an output directory in the current working directory called *pLDDT_out*. This directory will hold all generated graphs.\n\n**Additional Usage**\n\n**Specifying where to save the output -**\nTo specify where to dave the output, simply use the ``-o`` or ``--output-directory`` flag.\n\n**Example**\n\n    $ metapredict-graph-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/FolderForCoolPredictions\n\n\n**Changing resolution of saved graphs -**\nBy default, the output graphs have a DPI of 150. However, the user can change the DPI of the output (higher values have greater resolution but take up more space). To change the DPI simply add the flag ``-D`` or ``--dpi`` followed by the wanted DPI value. \n\n**Example**\n\n\t$ metapredict-graph-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/pLLDTGraphsFolder/ -D 300\n\n\n**Changing the file type -**\nBy default the graphs will save as .png files. However, you can specify the file type by calling ``--filetype`` and then specifying the file type. Any matplotlib compatible file extension should work (for example, pdf).\n\n**Example**\n\n    $ metapredict-graph-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/pLDDTGraphsFolder/ --filetype pdf\n\n**Indexing file names -**\nIf you would like to index the file names with a leading unique integer starting at 1, use the ``--indexed-filenames`` flag.\n\n**Example**\n\n    $ metapredict-graph-pLDDT /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/pLDDTGraphsFolder/ --indexed-filenames\n\n\n\n### Predicting IDRs from a fasta file\n\nThe ``metapredict-predict-idrs`` command from the command line takes a .fasta file as input and returns a .fasta file containing the IDRs for every sequence from the input .fasta file. \n\n\t$ metapredict-predict-idrs <Path to .fasta file> \n\n**Example**\n\n\t$ metapredict-predict-idrs /Users/thisUser/Desktop/interestingProteins.fasta \n\n**Additional Usage**\n\n**specifying where to save the output -** \nIf you would like to specify where to save the output, simply use the ``-o`` or ``--output-file`` flag and then specify the file path and file name.\n\n**Example**\n\n    $ metapredict-predict-idrs /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/disorder_predictions/my_idrs.fasta\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, use the ``-l`` or ``--legacy`` flag!\n\n**Example**\n\n    $ metapredict-predict-idrs /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/disorder_predictions/my_idrs.fasta -l\n\n**Changing output threshold for disorder-**\nTo change the cutoff value for something to be considered disordered, simply use the ``--threshold`` flag and then specify your value. For legacy, the default is 0.42. For the new version of metapredict, the value is 0.5. \n\n**Example**\n\n    $ metapredict-predict-idrs /Users/thisUser/Desktop/interestingProteins.fasta -o /Users/thisUser/Desktop/disorder_predictions/my_idrs.fasta --threshold 0.3\n\n\n\n## Using metapredict in Python:\n\nIn addition to using metapredict from the command line, you can also use metapredict directly in Python.\n\nFirst import metapredict -\n \n\timport metapredict as meta\n\n\nOnce metapredict is imported you can work with individual sequences or .fasta files. \n\n\n### Predicting Disorder\n\nThe ``predict_disorder`` function will return a list of predicted disorder values for each residue of the input sequence. The input sequence should be a string. Running -\n\n\tmeta.predict_disorder(\"DSSPEAPAEPPKDVPHDWLYSYVFLTHHPADFLR\")\n\nwould output -\n\n\t[1, 1, 1, 1, 0.957, 0.934, 0.964, 0.891, 0.863, 0.855, 0.793, 0.719, 0.665, 0.638, 0.576, 0.536, 0.496, 0.482, 0.306, 0.152, 0.096, 0.088, 0.049, 0.097, 0.235, 0.317, 0.341, 0.377, 0.388, 0.412, 0.46, 0.47, 0.545, 0.428]\n\nBy default, output prediction values are normalized between 0 and 1. However, some of the raw values from the predictor are slightly less than 0 or slightly greater than 1. The negative values are simply replaced with 0 and the values greater than 1 are replaced with 1 by default. However, the user can get the raw prediction values by specifying *normalized=False* as a second argument in meta.predict_disorder. There is not a very good reason to do this, and it is generally not recommended. However, we wanted to give users the maximum amount of flexibility when using metapredict, so we made it an option.\n\n\tmeta.predict_disorder(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\", normalized=False)\n\n\n**NOTE - using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.predict_disorder(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\", legacy=True)\n\n\n### Predicting AlphaFold2 Confidence Scores\n\nThe ``predict_pLDDT`` function will return a list of predicted AlphaFold2 pLDDT confidence scores  for each residue of the input sequence. The input sequence should be a string. Running -\n\n\tmeta.predict_pLDDT(\"DAPPTSQEHTQAEDKERD\")\n\nwould output -\n\n\t[35.7925, 40.4579, 46.3753, 46.2976, 42.3189, 42.0248, 43.5976, 40.7481, 40.1676, 41.9618, 43.3977, 43.938, 41.8352, 44.0462, 44.5382, 46.3081, 49.2345, 46.0671]\n\n\n### Predicting Disorder Domains\n\nThe ``predict_disorder_domains()`` function takes in an amino acid sequence and returns a DisorderObject. The DisorderObject has 6 dot variables that can be called to get information about your input sequence. They are as follows:\n\n\n.sequence : str    \n    Amino acid sequence \n\n.disorder : list or np.ndarray\n    Hybrid disorder score\n\n.disordered_domain_boundaries : list\n    List of domain boundaries for IDRs using Python indexing\n\n.folded_domain_boundaries : list\n    List of domain boundaries for folded domains using Python indexing\n\n.disordered_domains : list\n    List of the actual sequences for IDRs\n\n.folded_domains : list\n    List of the actual sequences for folded domains\n\n**Examples**\n\n\tseq = meta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLVSLPPVGSLVVYFPQGHSEQVAASMQKQTDFIPNYPNLPSKLICLLHS\")\n\nNow we can call the various dot values for **seq**. \n\n**Getting the sequence**\n\n\tprint(seq.sequence)\n\nreturns\n\n\tMKAPSNGFLPSSNEGEKKPINSQLWHACAGPLVSLPPVGSLVVYFPQGHSEQVAASMQKQTDFIPNYPNLPSKLICLLHS\n\n\n**Getting the disorder scores**\n\n\tprint(seq.disorder)\n\nreturns\n\n\t[0.922  0.9223 0.9246 0.9047 0.8916 0.8956 0.8931 0.883  0.8613 0.8573\n \t0.852  0.8582 0.8614 0.8455 0.826  0.7974 0.7616 0.7248 0.6782 0.6375\n \t0.5886 0.5476 0.5094 0.4774 0.4472 0.4318 0.4266 0.4222 0.3953 0.3993\n \t0.3904 0.4004 0.3962 0.3721 0.3855 0.3582 0.3456 0.3682 0.3488 0.3274\n \t0.3258 0.2937 0.2864 0.3004 0.3358 0.3815 0.4397 0.4594 0.4673 0.4535\n \t0.4446 0.4481 0.4546 0.4454 0.4549 0.4564 0.4677 0.4539 0.4713 0.49\n \t0.4934 0.4835 0.4815 0.4692 0.4548 0.4856 0.495  0.4809 0.502  0.4944\n \t0.4612 0.4561 0.436  0.4203 0.3784 0.3624 0.3739 0.3983 0.4348 0.4369]\n\n\n**Getting the disorder domain boundaries**\n\n\tprint(seq.disordered_domain_boundaries)\n\nreturns\n\n\t[[0, 23]]\n\nWhere each nested list is the boundaries for a specific disordered region and the first element in each list is the start of that region and the second element is the end of that region.\n\n**Getting the folded domain boundaries**\n\n\tprint(seq.folded_domain_boundaries)\n\nreturns\n\n\t[[23, 80]]\n\nWhere each nested list is the boundaries for a specific folded region and the first element in each list is the start of that region and the second element is the end of that region.\n\n**Getting the disordered domain sequences**\n\n\tprint(seq.disordered_domains)\n\nreturns\n\n\t['MKAPSNGFLPSSNEGEKKPINSQ']\n\nWhere each element in the list is a specific disordered region identified in the sequence.\n\n**Getting the folded domain sequences**\n\n\tprint(seq.folded_domains)\n\nreturns\n\n\t['LWHACAGPLVSLPPVGSLVVYFPQGHSEQVAASMQKQTDFIPNYPNLPSKLICLLHS']\n\nWhere each element in the list is a specific folded region identified in the sequence.\n\n\n**Additional Usage**\n\n**Altering the disorder theshhold -**\nTo alter the disorder threshold, simply set *disorder_threshold=my_value* where *my_value* is a float. The higher the threshold value, the more conservative metapredict will be for designating a region as disordered. Default = 0.42\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", disorder_threshold=0.3)\n\n**Altering minimum IDR size -**\nThe minimum IDR size will define the smallest possible region that could be considered an IDR. In other words, you will not be able to get back an IDR smaller than the defined size. Default is 12.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_IDR_size = 10)\n\n**Altering the minimum folded domain size -**\nThe minimum folded domain size defines where we expect the limit of small folded domains to be. *NOTE* this is not a hard limit and functions more to modulate the removal of large gaps. In other words, gaps less than this size are treated less strictly. *Note* that, in addition, gaps < 35 are evaluated with a threshold of 0.35 x disorder_threshold and gaps < 20 are evaluated with a threshold of 0.25 x disorder_threshold. These two lengths were decided based on the fact that coiled-coiled regions (which are IDRs in isolation) often show up with reduced apparent disorder within IDRs but can be as short as 20-30 residues. The folded_domain_threshold is used based on the idea that it allows a 'shortest reasonable' folded domain to be identified. Default=50.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_folded_domain = 60)\n\n**Altering gap_closure -**\nThe gap closure defines the largest gap that would be closed. Gaps here refer to a scenario in which you have two groups of disordered residues separated by a 'gap' of not disordered residues. In general large gap sizes will favor larger contiguous IDRs. It's worth noting that gap_closure becomes relevant only when minimum_region_size becomes very small (i.e. < 5) because really gaps emerge when the smoothed disorder fit is \"noisy\", but when smoothed gaps are increasingly rare. Default=10.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", gap_closure = 5)\n\n\n**Using the original metapredict network-**\nTo use the original metapredict network, simply set ``legacy=True``.\n\n**Example:** \n\n\tpredict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", legacy=True)\n\n\n\n\n\n\nThe ``predict_disorder_domains`` function takes in an amino acid sequence and returns a 4-position tuple with: 0. the raw disorder scores from 0 to 1 where 1 is the highest probability that a residue is disordered, 1. the smoothed disorder score used for boundary identification, 2. a list of elements where each element is a list where 0 and 1 define the IDR location and 2 gives the actual sequence, and 3. a list of elements where each element is a list where 0 and 1 define the folded domain location and 2 gives the actual sequence\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLVSLPPVGSLVVYFPQGHSEQVAASMQKQTDFIPNYPNLPSKLICLLHS\")\n\nwould output - \n\n\t[[0.828, 0.891, 0.885, 0.859, 0.815, 0.795, 0.773, 0.677, 0.66, 0.736, 0.733, 0.708, 0.66, 0.631, 0.601, 0.564, 0.532, 0.508, 0.495, 0.458, 0.383, 0.373, 0.398, 0.36, 0.205, 0.158, 0.135, 0.091, 0.09, 0.102, 0.126, 0.129, 0.114, 0.106, 0.097, 0.085, 0.099, 0.114, 0.093, 0.119, 0.117, 0.043, 0.015, 0.05, 0.139, 0.172, 0.144, 0.121, 0.124, 0.128, 0.147, 0.173, 0.129, 0.152, 0.169, 0.2, 0.172, 0.22, 0.216, 0.25, 0.272, 0.308, 0.248, 0.255, 0.301, 0.274, 0.264, 0.28, 0.25, 0.235, 0.221, 0.211, 0.235, 0.185, 0.14, 0.168, 0.307, 0.509, 0.544, 0.402], array([0.87596856, 0.86139124, 0.84596224, 0.82968293, 0.81255466,\n       0.79457882, 0.77575677, 0.75608988, 0.73557951, 0.71422703,\n       0.69203382, 0.66900124, 0.63956894, 0.62124099, 0.60188696,\n       0.57893168, 0.55241615, 0.52131925, 0.4859528 , 0.44109689,\n       0.39353789, 0.35264348, 0.31495776, 0.28      , 0.24661615,\n       0.21469814, 0.18500621, 0.15963478, 0.13604845, 0.1172087 ,\n       0.10798882, 0.1026882 , 0.09419503, 0.08462484, 0.08256398,\n       0.08832671, 0.0908559 , 0.09263851, 0.09438758, 0.09309938,\n       0.09102733, 0.09338137, 0.09665342, 0.10073913, 0.10392671,\n       0.11010311, 0.11402981, 0.11898634, 0.12430683, 0.13169441,\n       0.1381764 , 0.15245093, 0.16746957, 0.17518385, 0.18167578,\n       0.18893043, 0.20013416, 0.21581491, 0.23015652, 0.2420559 ,\n       0.25209814, 0.25817391, 0.26588944, 0.27456894, 0.27429068,\n       0.26411925, 0.24452671, 0.23076894, 0.22834783, 0.21689842,\n       0.20887549, 0.20564427, 0.20856996, 0.21901779, 0.23835296,\n       0.26794071, 0.30914625, 0.36333478, 0.43187154, 0.51612174]), [[0, 20, 'MKAPSNGFLPSSNEGEKKPI']], [[20, 80, 'NSQLWHACAGPLVSLPPVGSLVVYFPQGHSEQVAASMQKQTDFIPNYPNLPSKLICLLHS']]]\n\n\n**Additional Usage**\n\n**Altering the disorder theshhold -**\nTo alter the disorder threshold, simply set *disorder_threshold=my_value* where *my_value* is a float. The higher the threshold value, the more conservative metapredict will be for designating a region as disordered. Default = 0.42\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", disorder_threshold=0.3)\n\n**Altering minimum IDR size -**\nThe minimum IDR size will define the smallest possible region that could be considered an IDR. In other words, you will not be able to get back an IDR smaller than the defined size. Default is 12.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_IDR_size = 10)\n\n**Altering the minimum folded domain size -**\nThe minimum folded domain size defines where we expect the limit of small folded domains to be. *NOTE* this is not a hard limit and functions more to modulate the removal of large gaps. In other words, gaps less than this size are treated less strictly. *Note* that, in addition, gaps < 35 are evaluated with a threshold of 0.35 x disorder_threshold and gaps < 20 are evaluated with a threshold of 0.25 x disorder_threshold. These two lengths were decided based on the fact that coiled-coiled regions (which are IDRs in isolation) often show up with reduced apparent disorder within IDRs but can be as short as 20-30 residues. The folded_domain_threshold is used based on the idea that it allows a 'shortest reasonable' folded domain to be identified. Default=50.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_folded_domain = 60)\n\n**Altering gap_closure -**\nThe gap closure defines the largest gap that would be closed. Gaps here refer to a scenario in which you have two groups of disordered residues separated by a 'gap' of not disordered residues. In general large gap sizes will favor larger contiguous IDRs. It's worth noting that gap_closure becomes relevant only when minimum_region_size becomes very small (i.e. < 5) because really gaps emerge when the smoothed disorder fit is \"noisy\", but when smoothed gaps are increasingly rare. Default=10.\n\n**Example**\n\n\tmeta.predict_disorder_domains(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", gap_closure = 5)\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.predict_disorder_domains(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\", legacy=True)\n\n\n### Predicting Disorder Domains using a Uniprot ID\n\nIn addition to inputting a sequence, you can predict disorder domains by inputting a Uniprot ID by using the ``predict_disorder_domains_uniprot`` function. This function has the exact same functionality as ``predict_disorder_domains`` except you can now input a Uniprot ID. \n\n**Example**\n\n    meta.predict_disorder_domains_uniprot('Q8N6T3')\n\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.predict_disorder_domains_uniprot('Q8N6T3', legacy=True)\n\n\n### Graphing Disorder \n\nThe ``graph_disorder`` function will show a plot of the predicted disorder consensus values across the input amino acid sequence.\n\n\tmeta.graph_disorder(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\")\n\n**Additional Usage**\n\n**Adding Predicted AlphaFold2 Confidence Scores -**\nTo add predicted AlphaFold2 pLDDT confidence scores, simply specify *pLDDT_scores=True*.\n\n**Example**\n\n\tmeta.graph_disorder(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\", pLDDT_scores=True)\n\n\n**Changing the title of the generated graph -**\nThere are two parameters that the user can change for graph_disorder. The first is the name of the title for the generated graph. The name by default is blank and the title of the graph is simply *Predicted protein disorder*. However, the title can be specified by specifying *title* = \"my cool title\" would result in a title of *my cool title*.\n\n**Example**\n\n\tmeta.graph_disorder(\"DAPPTSQEHTQAEDKERD\", title=\"Name of this nonexistant protein\")\n\n**Changing the resolution of the generated graph -**\nBy default, the output graph has a DPI of 150. However, the user can change the DPI of the generated graph (higher values have greater resolution). To do so, simply specify *DPI=\"Number\"* where the number is an integer.\n\n**Example**\n\n\tmeta.graph_disorder(\"DAPPTSQEHTQAEDKERD\", DPI=300)\n\n**Changing the disorder threshold line -**\nThe disorder threshold line for graphs defaults to 0.3. However, if you want to change where the line designating the disorder cutoff is, simply specify *disorder_threshold = Float* where Float is some decimal value between 0 and 1. \n\n**Example**\n\n    meta.graph_disorder(\"DAPPTSQEHTQAEDKERD\", disorder_threshold=0.5)\n\n**Adding shaded regions to the graph -** If you would like to shade specific regions of your generated graph (perhaps shade the disordered regions), you can specify *shaded_regions=[[list of regions]]* where the list of regions is a list of lists that defines the regions to shade.\n\n**Example**\n\n    meta.graph_disorder(\"DAPPTSQEHTQAEDKERDDAPPTSQEHTQAEDKERDDAPPTSQEHTQAEDKERD\", shaded_regions=[[1, 20], [30, 40]])\n\nIn addition, you can specify the color of the shaded regions by specifying *shaded_region_color*. The default for this is red. You can specify any matplotlib color or a hex color string.\n\n**Example**\n\n    meta.graph_disorder(\"DAPPTSQEHTQAEDKERDDAPPTSQEHTQAEDKERDDAPPTSQEHTQAEDKERD\", shaded_regions=[[1, 20], [30, 40]], shaded_region_color=\"blue\")\n\n**Saving the graph -** By default, the graph will automatically appear. However, you can also save the graph if you'd like. To do this, simply specify *output_file = path_where_to_save/filename.file_extension.* For example, output_file=/Users/thisUser/Desktop/cool_graphs/myCoolGraph.png. You can save the file with any valid matplotlib extension (.png, .pdf, etc.). \n\n**Example**\n\n    meta.graph_disorder(\"DAPPTSQEHTQAEDKER\", output_file=/Users/thisUser/Desktop/cool_graphs/myCoolGraph.png)\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.graph_disorder(\"DAPPTSQEHTQAEDKER\", legacy=True)\n\n\n### Graphing AlphaFold2 Confidence Scores\n\nThe ``graph_pLDDT`` function will show a plot of the predicted AlphaFold2 pLDDT confidence scores across the input amino acid sequence.\n\n\tmeta.graph_pLDDT(\"DAPTSQEHTQAEDKERDSKTHPQKKQSPS\")\n\nThis function has all of the same functionality as ``graph_disorder``.\n\n### Calculating Percent Disorder\n\nThe ``percent_disorder`` function will return the percent of residues in a sequence that  have predicted consensus disorder values of 30% or more (as a decimal value).\n\n**Example**\n\n\tmeta.percent_disorder(\"DAPPTSQEHTQAEDKERD\")\n\nBy default, this function uses a cutoff value of equal to or greater than 0.3 for a residue to be considered disordered.\n\n**Additional Usage**\n\n**Changing the cutoff value -**\nIf you want to be more strict in what you consider to be disordered for calculating percent disorder of an input sequence, you can simply specify the cutoff value by adding the argument *cutoff=decimal* where the decimal corresponds to the percent you would like to use as the cutoff (for example, 0.8 would be 80%).\n\n\n**Example**\n\n\tmeta.percent_disorder(\"DAPPTSQEHTQAEDKERD\", cutoff=0.8)\n\nThe higher the cutoff value, the higher the value any given predicted residue must be greater than or equal to in order to be considered disordered when calculating the final percent disorder for the input sequence.\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.percent_disorder(\"DAPPTSQEHTQAEDKERD\", legacy=True)\n\n\n### Predicting Disorder From a .fasta File\n\nBy using the ``predict_disorder_fasta`` function, you can predict disorder values for the amino acid sequences in a .fasta file. By default, this function will return a dictionary where the keys in the dictionary are the fasta headers and the values are the consensus disorder predictions of the amino acid sequence associated with each fasta header in the original .fasta file.\n\n**Example**\n\n\tmeta.predict_disorder_fasta(\"file path to .fasta file/fileName.fasta\")\n\nAn actual filepath would look something like:\n\n\tmeta.predict_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\")\n\n\n**Additional Usage**\n\n**Save the output values -**\nBy default the predict_disorder_fasta function will immediately return a dictionary. However, you can also save the output to a .csv file by specifying *output_file = \"location you want to save the file to*\". When specifying the file path, you also want to specify the file name. The first cell of each row will contain a fasta header and the subsequent cells in that row will contain predicted consensus disorder values for the protein associated with the fasta header.\n\n**Example**\n\n\tmeta.predict_disorder_fasta(\"file path to .fasta file/fileName.fasta\", output_file=\"file path where the output .csv should be saved\")\n\nAn actual filepath would look something like:\n\n\tmeta.predict_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_file=\"/Users/thisUser/Desktop/cool_predictions.csv\")\n\n\n**Get raw prediction values -**\nBy default, this function will output prediction values that are normalized between 0 and 1. However, some of the raw values from the predictor are slightly less than 0 or slightly greater than 1. The negative values are simply replaced with 0 and the values greater than 1 are replaced with 1 by default. If you want the raw values simply specify *normalized=False*. There is not a very good reason to do this, and it is generally not recommended. However, we wanted to give users the maximum amount of flexibility when using metapredict, so we made it an option.\n\n**Example**\n\n\tmeta.predict_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", normalized=False)\n\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.predict_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", legacy=True)\n\n\n### Predicting AlphaFold2 pLDDT confidence scores From a .fasta File\n\nJust like with ``predict_disorder_fasta``, you can use ``predict_pLDDT_fasta`` to get predicted AlphaFold2 pLDDT confidence scores from a fasta file. All the same functionality in ``predict_disorder_fasta`` is in ``predict_pLDDT_fasta``.\n\n**Example**\n\n\tmeta.predict_pLDDT_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\")\n\n\n### Predict Disorder Using Uniprot ID\nBy using the ``predict_disorder_uniprot`` function, you can return predicted consensus disorder values for the amino acid sequence of a protein by specifying the Uniprot ID. \n\n**Example**\n\n    meta.predict_disorder_uniprot(\"Q8N6T3\")\n\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.predict_disorder_uniprot(\"Q8N6T3\", legacy=True)\n\n\n### Predicting AlphaFold2 Confidence Scores Using Uniprot ID\n\nBy using the ``predict_pLDDT_uniprot`` function, you can generate predicted AlphaFold2 pLDDT confidence scores by inputting a Uniprot ID.\n\n**Example**\n\n    meta.predict_pLDDT_uniprot('P16892')\n\n\n### Generating Disorder Graphs From a .fasta File\n\nBy using the ``graph_disorder_fasta`` function, you can graph predicted consensus disorder values for the amino acid sequences in a .fasta file. The *graph_disorder_fasta* function takes a .fasta file as input and by default will return the graphs immediately. However, you can specify *output_dir=path_to_save_files* which result in a a .png file saved to that directory for every sequence within the .fasta file. You cannot specify the output file name here! By default, the file name will be the first 14 characters of the FASTA header followed by the filetype as specified by filetype. If you wish for the files to include a unique leading number (i.e. X_rest_of_name where X starts at 1 and increments) then set *indexed_filenames = True*. This can be useful if you have sequences where the 1st 14 characters may be identical, which would otherwise overwrite an output file. By default this will return a single graph for every sequence in the FASTA file. \n\n**WARNING -**\nThis command will generate a graph for ***every*** sequence in the .fasta file. If you have 1,000 sequences in a .fasta file and you do not specify the *output_dir*, it will generate **1,000** graphs that you will have to close sequentially. Therefore, I recommend specifying the *output_dir* such that the output is saved to a dedicated folder.\n\n**Example**\n\n\tmeta.graph_disorder_fasta(\"file path to .fasta file/fileName.fasta\", output_dir=\"file path of where to save output graphs\")\n\nAn actual file path would look something like:\n\n\tmeta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_dir=\"/Users/thisUser/Desktop/folderForGraphs\")\n\n\n**Additional Usage**\n\n**Adding Predicted AlphaFold2 Confidence Scores -**\nTo add predicted AlphaFold2 pLDDT confidence scores, simply specify *pLDDT_scores=True*.\n\n**Example**\n\n\tmeta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", pLDDT_scores=True)\n\n\n**Changing resolution of saved graphs -**\nBy default, the output files have a DPI of 150. However, the user can change the DPI of the output files (higher values have greater resolution but take up more space). To change the DPI, specify *DPI=Number* where Number is an integer.\n\n**Example**\n\n\tmeta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", DPI=300, output_dir=\"/Users/thisUser/Desktop/folderForGraphs\")\n\n**Changing the output File Type -** \nBy default the output file is a .png. However, you can specify the output file type by using *output_filetype=\"file_type\"* where file_type is some matplotlib compatible file type (such as .pdf).\n\n**Example**\n\n    meta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_dir=\"/Users/thisUser/Desktop/folderForGraphs\", output_filetype = \"pdf\")\n\n\n**Indexing generated files -**\nIf you would like to index the file names with a leading unique integer starting at 1, set *indexed_filenames=True*.\n\n**Example**\n\n    meta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_dir=\"/Users/thisUser/Desktop/folderForGraphs\", indexed_filenames=True)\n\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.graph_disorder_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_dir=\"/Users/thisUser/Desktop/folderForGraphs\", legacy=True)\n\n\n### Generating AlphaFold2 Confidence Score Graphs from fasta files\n\nBy using the ``graph_pLDDT_fasta`` function, you can graph predicted AlphaFold2 pLDDT confidence scores for the amino acid sequences in a .fasta file. This works the same as ``graph_disorder_fasta`` but instead returns graphs with just the predicted AlphaFold2 pLDDT scores.\n\n**Example**\n\n\tmeta.graph_pLDDT_fasta(\"/Users/thisUser/Desktop/coolSequences.fasta\", output_dir=\"/Users/thisUser/Desktop/folderForGraphs\")\n\n\n### Generating Predicted Disorder Graphs Using Uniprot ID\n\nBy using the ``graph_disorder_uniprot`` function, you can graph predicted consensus disorder values for the amino acid sequence of a protein by specifying the Uniprot ID. \n\n**Example**\n\n    meta.graph_disorder_uniprot(\"Q8N6T3\")\n\nThis function carries all of the same functionality as ``graph_disorder`` including specifying disorder_threshold, title of the graph, the DPI, and whether or not to save the output.\n\n**Example**\n\n    meta.graph_disorder_uniprot(\"Q8N6T3\", disorder_threshold=0.5, title=\"my protein\", DPI=300, output_file=\"/Users/thisUser/Desktop/my_cool_graph.png\")\n\n**Additional usage**\n\n**Adding Predicted AlphaFold2 Confidence Scores -**\nTo add predicted AlphaFold2 pLDDT confidence scores, simply specify *pLDDT_scores=True*.\n\n**Example**\n\n\tmeta.graph_disorder_uniprot(\"Q8N6T3\", pLDDT_scores=True)\n\n\n**Using the original metapredict predictor**\nTo use the original metapredict predictor as opposed to our new, updated predictor, set ``legacy=True``\n\n\tmeta.graph_disorder_uniprot(\"Q8N6T3\", legacy=True)\n\n\n### Generating AlphaFold2 Confidnce Score Graphs Using Uniprot ID\n\nJust like with disorder predictions, you can also get AlphaFold2 pLDDT confidence score graphs using the Uniprot ID. This will **only display the pLDDT confidence scores** and not the predicted disorder scores. \n\n**Example**\n\n\tmeta.graph_pLDDT_uniprot(\"Q8N6T3\")\n\n\n\n###  Predicting Disorder Domains from external scores:\n\nThe ``predict_disorder_domains_from_external_scores()`` function takes in an array or list of disorder scores, an amino acid sequence (optionally), and returns a DisorderObject. This function lets you use other disorder predictor scores and still use the predict_disorder_domains() functionality. The DisorderObject has 6 dot variables that can be called to get information about your input sequence. They are as follows: \n\n.sequence : str    \n    Amino acid sequence \n\n.disorder : list or np.ndaarray\n    Hybrid disorder score\n\n.disordered_domain_boundaries : list\n    List of domain boundaries for IDRs using Python indexing\n\n.folded_domain_boundaries : list\n    List of domain boundaries for folded domains using Python indexing\n\n.disordered_domains : list\n    List of the actual sequences for IDRs\n\n.folded_domains : list\n    List of the actual sequences for folded domains\n\n**Examples**\n\n\tseq = meta.predict_disorder_domains_from_external_scores(disorder=[0.8577, 0.9313, 0.9313, 0.9158, 0.8985, 0.8903, 0.8895, 0.869, 0.8444, 0.8594, 0.8643, 0.8605, 0.8697, 0.8627, 0.8641, 0.8633, 0.8487, 0.8512, 0.8236, 0.8079, 0.8047, 0.8021, 0.7954, 0.7867, 0.7797, 0.7982, 0.7842, 0.7614, 0.7931, 0.8166, 0.8298, 0.8222, 0.8227, 0.8183, 0.8279, 0.838, 0.8535, 0.8512, 0.8464, 0.8469, 0.8322, 0.8265, 0.794, 0.7827, 0.7699, 0.7575, 0.7178, 0.5988], sequence = 'MKAPSNGFLPSSNEGEKKPINSQLMKAPSNGFLPSSNEGEKKPINSQL')\n\nNow we can call the various dot values for **seq**. \n\n**Getting the sequence**\n\n\tprint(seq.sequence)\n\nreturns\n\n\tMKAPSNGFLPSSNEGEKKPINSQLMKAPSNGFLPSSNEGEKKPINSQL\n\n\n**Getting the disorder scores**\n\n\tprint(seq.disorder)\n\n\n\n**Getting the disorder domain boundaries**\n\n\tprint(seq.disordered_domain_boundaries)\n\n\n\n**Getting the folded domain boundaries**\n\n\tprint(seq.folded_domain_boundaries)\n\n\n**Getting the disordered domain sequences**\n\n\tprint(seq.disordered_domains)\n\n\n**Getting the folded domain sequences**\n\n\tprint(seq.folded_domains)\n\n\n\n**Additional Usage**\n\n**Altering the disorder theshhold -**\nTo alter the disorder threshold, simply set *disorder_threshold=my_value* where *my_value* is a float. The higher the threshold value, the more conservative metapredict will be for designating a region as disordered. Default = 0.42\n\n**Example**\n\n\tmeta.predict_disorder_domains_from_external_scores(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", disorder_threshold=0.3)\n\n**Altering minimum IDR size -**\nThe minimum IDR size will define the smallest possible region that could be considered an IDR. In other words, you will not be able to get back an IDR smaller than the defined size. Default is 12.\n\n**Example**\n\n\tmeta.predict_disorder_domains_from_external_scores(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_IDR_size = 10)\n\n**Altering the minimum folded domain size -**\nThe minimum folded domain size defines where we expect the limit of small folded domains to be. *NOTE* this is not a hard limit and functions more to modulate the removal of large gaps. In other words, gaps less than this size are treated less strictly. *Note* that, in addition, gaps < 35 are evaluated with a threshold of 0.35 x disorder_threshold and gaps < 20 are evaluated with a threshold of 0.25 x disorder_threshold. These two lengths were decided based on the fact that coiled-coiled regions (which are IDRs in isolation) often show up with reduced apparent disorder within IDRs but can be as short as 20-30 residues. The folded_domain_threshold is used based on the idea that it allows a 'shortest reasonable' folded domain to be identified. Default=50.\n\n**Example**\n\n\tmeta.predict_disorder_domains_from_external_scores(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", minimum_folded_domain = 60)\n\n**Altering gap_closure -**\nThe gap closure defines the largest gap that would be closed. Gaps here refer to a scenario in which you have two groups of disordered residues seprated by a 'gap' of not disordered residues. In general large gap sizes will favour larger contiguous IDRs. It's worth noting that gap_closure becomes relevant only when minimum_region_size becomes very small (i.e. < 5) because really gaps emerge when the smoothed disorder fit is \"noisy\", but when smoothed gaps are increasingly rare. Default=10.\n\n**Example**\n\n\tmeta.predict_disorder_domains_from_external_scores(\"MKAPSNGFLPSSNEGEKKPINSQLWHACAGPLV\", gap_closure = 5)\n\n\n### metapredict isn't working!\n\nI have received occasional feedback that metapredict is not working for a user. A common problem is that the user is using a different version of Python than metapredict was made on. \n\nmetapredict should work without issue on Python versions 3.x and 3.8.x. It was developed on Python 3.7 and has been tested extensively on Python 3.8. It should also work on Python 3.9 although this has been less well-tested \n\nIn general, we recommend using a conda environment for any Python computing you're doing. This lets you control the packages being used and the Python version. For more info on conda, please see https://docs.conda.io/projects/conda/en/latest/index.html\n\nOnce you have conda installed, simply use the command \n\n\tconda create --name my_env python=3.7\n\nwhere you can replace the name of your environment with whatever you'd like. Then, use metapredict from within this conda environment.\n\nIf you are having other problems, please report them to the **issues** section on the metapredict Github page at\nhttps://github.com/idptools/metapredict/issues\n\n### Known Installation/Execution Issues\n\nBelow we include documentation on known issues. \n\nmacOS libiomp clash \n\nPyTorch current ships with its own version of the OpenMP library (``libiomp.dylib``). Unfortunately when numpy is installed from ``conda`` (although not from ``pip``) this leads to a collision because the ``conda``-derived numpy library also includes a local copy of the ``libiomp5.dylib`` library. This leads to the following error message (included here for google-ability).\n\n\n   OMP: Error #15: Initializing libiomp5.dylib, but found libomp.dylib already initialized.\n   OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. \n   That is dangerous, since it can degrade performance or cause incorrect results. The best thing to \n   do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static \n   linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you \n   can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, \n   but that may cause crashes or silently produce incorrect results. For more information, \n   please see http://www.intel.com/software/products/support/.\n\nTo avoid this error we make the executive decision to ignore this clash. This has largely not appeared to have any deleterious issues on performance or accuracy across the tests run. If you are uncomfortable with this then the code in ``metapredict/__init__.py`` can be edited with ``IGNORE_LIBOMP_ERROR`` set to ``False`` and **metapredict** re-installed from the source directory.\n\n### Testing\n\nTo see if your installation of **metapredict** is working properly, you can run the unit test included in the package by navigating to the metapredict/tests folder within the installation directory and\n\n**running:**\n\n    $ pytest -v\n\n\n### Example Datasets\n\nExample data that can be used with metapredict can be found in the metapredict/data folder on GitHub. The example data set is just a .fasta file containing 5 protein sequences.\n\n\n### Recent changes\n\nThis section is a log of recent changes with metapredict. My hope is that as I change things, this section can help you figure out why a change was made and if it will break any of your current work flows. The first major changes were made for the 0.56 release, so tracking will start there. Reasons are not provided for bug fixes for because the reason can assumed to be fixing the bug...\n\n\n#### V2.5\nChanges:\n\n* Added the first multicore support to metapredict. Currently limited to metapredict-predict-disorder functionality.\n=======\n#### V2.4.3\nChanges:\n\n* Updated the default names for `metapredict-predict-idrs` so that the FASTA output file is now called `idrs.fasta` instead of the inappropriate `shephard_idrs.tsv`.\n* Added link to the new batch-mode Google Colab notebook!\n\n#### V2.4.2 \nChanges:\n\n* Merged pull request from @FriedLabJHU to make f-strings more Pythonic. Thanks!!\n* Changed `return_normalized` keyword to `normalized` in `meta.predict_pLDDT()` for consistency with other functions\n* Added sanity check in case a passed sequence is an empty string (h/t Broder Schmidt)\n* Added docs for the mode keyword in `meta.percent_disorder()`, so this is actually obvious to understand (h/t Broder Schmidt)\n* Added several additional tests and updated the docs\n\n#### V2.4.1\nChanges:\n\n* Some minor bug fixes and updates to code \n\n#### V2.3 \nChanges:\n\n* Merged pull request from @FriedLabJHU to fix keyword name `cutoff` to `disorder_threshold` in `meta.percent_disorder()`. Thanks!!\n\n* Added the `mode` keyword into `meta.percent_disorder()` so disorder can be predicted in terms of what percentage of residues fall within IDRs, as well as what percent are above some fixed threshold.\n\n#### V2.2\n\nChanges: \nFixed bug in metapredict-name command that could result in the organism name being named twice in the title of the graph.\n\n#### V2.1\n\nChanges:\nAdded functionality to graph the disorder of a protein by specifying its common name using the *metapredict-name* command.\n\n\n#### V2.0\n\nChanges:\nMassive update to the network behind metapredict to improve accuracy. Implementation of code to keep the original network accessible to users. Changes to predict_disorder_domain functions where a DisorderObject is no returned and access to values are used by calling properties from the generated object. Graphing functionality updated to accommodate new cutoff value for the new network at 0.5. If the original metapredict network is used, then the cutoff value automatically resets to the original value of 0.3. Tests updated. Added metapredict-predict-idrs command to the command line. Added ability to predict disorder domains from python using external scores.\n\n\n#### V1.51\n\nChanges:\nUpdated to require V1.0 of alphaPredict for pLDDT scores. This improves accuracy from over 9% per residue to about 8% per residue for pLDDT score predictions. Documentation was updated for this change.\n\n\n#### V1.5\n\nChanges:\nFixed bug causing some functions to fail when getting sequences from Uniprot.\nAdded information on citing metapredict because the final publication went live.\n\n\n#### V1.4\n\nChange:\nFor clarity, previous functions that used the term 'confidence' such as *graph_confidence_uniprot()* were changed to use the term pLDDT rather than confidence. This is to clarify that the confidence scores are AlphaFold2 pLDDT confidence scores and not scores to reflect the confidence that the user should have in the metapredict disorder prediction. For command-line usage where confidence scores are optional (such as metapredict-graph-disorder), when a *-c* or *--confidence* flag used to be used, now a *-p* or *--pLDDT* flag is used to graph confidence scores. This is similarly reflected in Python where now you must use *pLDDT_scores=True* instead of *confidence_scores=True*.\n\n#### V1.3\n\nChange:\nAdded functionality to generate predicted AlphaFold2 pLDDT confidence scores. Can get scores or generate graphs from Python or command-line. Can also generate graphs with both predicted disorder and predicted pLDDT confidence scores. Also added functionality to predict disorder domains using scores from a different disorder predictor. \n\n#### V1.2\n\nChange:\nMajor update. Changed some basic functionality. Made it such that you don't need to specify to save (for disorder prediction values or graphs). Rather, if a file path is specified, the files will be saved. Updated graphing functionality to allow for specifying the disorder cutoff line and to allow users to highlight various regions of the graph. Changed import such that you can now just use import metapredict as meta in Python (as opposed to import metapredict and then from metapredict import meta). Lots of backend changes to make metapredict more stable. Added additional testing. Updated documentation. Standardized file reading/writing. Made it so user can specify file type of saved graphs. Added backend meta_tools.py to handle the busywork. Changed version numbering for networks. Updated code to avoid OMPLIB issue (known bug in previous versions). Updated all command-line tools to match backend code.\n\n#### V1.1\n\nChange:\nFixed some bugs.\n\n#### V1.0\n\nChange:\nAdded functionality to generate graphs using a Uniprot ID as the input from command line. Added functionality to predict disorder domains. Added functionality to predict/graph disorder and predict disorder domains using a Uniprot ID from Python. Updated tests to include testing new functionality.\n\n\n#### V0.61\n\nChange:\nAdded functionality to predict or graph a disordered sequence from the command line by directly inputting the sequence. This can only do one sequence at a time and does not save the disorder values or graph. It is meant to provide a very quick and easy way to check something out.\n\n#### V0.60\n\nChange:\nAdded functionality to specify the horizontal lines that appear across the graphs rather than only having the option of having the dashed lines appear at intervals of 0.2. This functionality is in both Python and the command line.\n\n#### V0.58\n\nChange:\nUpdated the network with a newly trained network (using the same dataset as the original) that is slightly more accurate.\n\nReason:\nI am always trying to find ways to make metapredict more accurate. When I manage to make the predictor better, I will update it.\n\n#### V0.57\n\nChange:\nBug fix that could result in prediction values to six decimal places in some scenarios\n\nChange:\nChanged titles for graphs generated by ``metapredict-graph-disorder`` to be 14 characters instead of 10. This is reflected in the title graph and the saved files.\n\nReason:\nThe 10 character save file was occasionally the same for multiple proteins. This resulted in the inability to discern which protein corresponded to which graph and could result in overwriting previously generated graphs. The 14 characters should be long enough to keep unique names for all proteins being analyzed.\n\nChange:\nFixed bug that could result in crashing due to short fasta headers.\n\n\n#### V0.56\n\nChange:\nNumber of decimals in predictions was reduced from 6 to 3.\n\nReason:\nIt is not necessary to have accuracy out to 6 decimal places.\n\nChange:\nAdded functionality to use . to specify current directory from command line.\n\nReason:\nImprove functionality.\n\nChange:\n-DPI flag changed to -dpi in command line graphing function\n\nReason:\nIt was annoying to have to do all caps for this flag.\n\nChange:\nThe ``predict-disorder`` command is now ``metapredict-predict-disorder`` and the ``graph-disorder`` command is now ``metapredict-graph-disorder``\n\nReason:\nThis will help users be able to use auto complete functionality from the command line using tab to pull up the graph or predict disorder commands while only having to remember metapredict.\n\nChange:\nThe output for `.csv` files will now have a comma space between each value instead of just a comma.\n\nReason:\nImprove readability.\n\n\n### Copyright\n\nCopyright (c) 2020-2022, Holehouse Lab - Washington University School of Medicine\n\n#### Acknowledgements\n\nPARROT, created by Dan Griffith, was used to generate the network used for metapredict. See [https://pypi.org/project/idptools-parrot/](https://pypi.org/project/idptools-parrot/) for some very cool machine learning stuff.\n\nIn addition to using Dan Griffith's tool for creating metapredict, the original code for `brnn_architecture.py` and `encode_sequence.py` was written by Dan.\n\nWe would like to thank the **DeepMind** team for developing AlphaFold and EBI/UniProt for making these data so readily available.\n\nWe would also like to thank the team at MobiDB for creating the database that was used to train this predictor. Check out their awesome stuff at [https://mobidb.bio.unipd.it](https://mobidb.bio.unipd.it)\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/idptools/metapredict.git",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "metapredict",
    "package_url": "https://pypi.org/project/metapredict/",
    "platform": null,
    "project_url": "https://pypi.org/project/metapredict/",
    "project_urls": {
      "Homepage": "https://github.com/idptools/metapredict.git"
    },
    "release_url": "https://pypi.org/project/metapredict/2.5/",
    "requires_dist": null,
    "requires_python": ">=3.5",
    "summary": "",
    "version": "2.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17319892,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "68307d2988eec561e53c9c404dae8812dafc81c617c533b4717826f47b11a5ad",
        "md5": "bac01bed980926958d0f0cee1f9c59f7",
        "sha256": "ed4a763df5a0d0571bf93452d89ea16ac4664e2a3052e4e374a2e0deec611d4c"
      },
      "downloads": -1,
      "filename": "metapredict-2.5.tar.gz",
      "has_sig": false,
      "md5_digest": "bac01bed980926958d0f0cee1f9c59f7",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 476616,
      "upload_time": "2023-03-15T21:00:32",
      "upload_time_iso_8601": "2023-03-15T21:00:32.367846Z",
      "url": "https://files.pythonhosted.org/packages/68/30/7d2988eec561e53c9c404dae8812dafc81c617c533b4717826f47b11a5ad/metapredict-2.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}