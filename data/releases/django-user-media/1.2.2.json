{
  "info": {
    "author": "Martin Brochhaus",
    "author_email": "martin.brochhaus@bitmazk.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "Django User Media\n=================\n\nAlmost all modern web apps allow their users to upload content such as audio,\nvideo or images. This raises a number of issues if that content should not be\nvisible to the whole world by default.\n\nIf you add an ImageField to your user model, you need to come up with a good\nidea on how to save those images. It is probably not a good idea to keep the\noriginal filenames as they might disturb your server's file system and open\ndoors for hackers, who might try to brute-force against your\n``/media/user_profiles/`` in the hope to steal some valuable files.\n\nSince it seems inevitable to implement a function for Django's FileField's\n``upload_to`` attribute I thought that this might be a candidate for a reusable\napp.\n\n\nPrerequisites\n-------------\n\nYou need at least the following packages in your virtualenv:\n\n* Django\n* django-libs\n* easy_thumbnails\n* django-generic-positions\n* simplejson\n\n\nInstallation\n------------\n\nTo get the latest stable release from PyPi::\n\n    $ pip install django-user-media\n\nTo get the latest commit from GitHub::\n\n    $ pip install -e git://github.com/bitmazk/django-user-media.git#egg=user_media\n\nAdd the app to your ``INSTALLED_APPS``::\n\n    INSTALLED_APPS = [\n        ...\n        'user_media',\n        'easy_thumbnails',\n        'django_libs',\n        'generic_positions',\n\n    ]\n\nHook the app into your main ``urls.py``::\n\n    urlpatterns += patterns('',\n        ...\n        url(r'^umedia/', include('user_media.urls')),\n    )\n\nRun the migrations to create the app's database tables::\n\n    $ ./manage.py migrate user_media\n\n\nUsage\n-----\n\n\nAdd generic relation\n++++++++++++++++++++\n\nLet's assume that you have a ``UserProfile`` model and you want to add an\n``avatar`` field to that model.\n\nFirst you might want to add a ``GenericRelation`` to your ``UserProfile``\nmodel::\n\n    from django.contrib.contenttypes import generic\n\n\n    class UserProfile(models.Model):\n        ...\n        user = models.ForeignKey(\n            getattr(settings, 'AUTH_USER_MODEL', 'auth.User'),\n        )\n\n        avatar = generic.GenericRelation(\n            'user_media.UserMediaImage',\n        )\n\n\nAdd property\n++++++++++++\n\nNow you will be able to get all uploaded images that belong to a\n``UserProfile`` by doing this::\n\n    profile = UserProfile.objects.get(pk=1)\n    images = profile.avatar.all()\n\nIt makes sense to add a convenience method to your ``UserProfile`` model::\n\n    class UserProfile(models.Model):\n        ...\n        @property\n        def avatar(self):\n            try:\n                return self.avatar.all()[0]\n            except IndexError:\n                return None\n\n\nAdd link to update form\n+++++++++++++++++++++++\n\nIn your templates you can now provide a link to the image creation view like\nthis (assuming that your ``UserProfile`` object is called ``object`` in the\ntemplate's context)::\n\n    <a href=\"{% url \"user_media_image_create\" content_type=\"userprofile\" object_id=object.pk %}\">Upload your picture</a>\n\nNote that ``userprofile`` is the model name that the ``ContentType`` of your\n``UserProfile`` model would return. You can figure this out with ``./manage.py\nshell`` for example::\n\n    $ ./manage.py shell\n    In [1]: from django.contrib.contenttypes.models import ContentType\n    In [2]: from your_app.models import UserProfile\n    In [3]: ContentType.objects.get_for_model(UserProfile).model\n    Out [1]: u'userprofile'\n\nWhen visiting that link, the user will see an image upload form. You might\nwant to override that template (``user_media/usermediaimage_form.html``).\n\nAfter uploading the image the view should redirect back to the absolute url\nof your ``UserProfile``. If you want to redirect to another URL, you can\nprovide a ``next`` URL parameter via POST or GET::\n\n        <a href=\"{% url \"user_media_image_create\" content_type=\"userprofile\" object_id=object.pk %}?next=/foo/bar\">Upload your picture</a>\n\n\nDisplay images\n++++++++++++++\n\nNow you should have all building blocks that you need to add links or buttons\nto your templates that call the views of this application. On your\n``UserProfile`` detail view you could display the avatar, if available::\n\n    {% if object.avatar %}\n        <img src=\"{{ MEDIA_URL }}{{ object.avatar.image }}\" />\n    {% endif %}\n\n\nDelete and edit images\n++++++++++++++++++++++\n\nOr in your ``UserProfile`` update view you could display a link to upload a\nnew image or to delete the existing image::\n\n    {% if form.instance.get_avatar %}\n        <p><img src=\"{{ MEDIA_URL }}{{ form.instance.avatar.image }}\" /></p>\n        <a href=\"{% url \"user_media_image_delete\" pk=form.instance.avatar.pk %}\">Delete picture</a>\n    {% else %}\n        <a href=\"{% url \"user_media_image_create\" content_type=\"userprofile\" object_id=form.instance.pk %}\">Add profile picture</a>\n    {% endif %}\n\nThe delete link in this example will render the\n``user_media/usermediaimage_confirm_delete.html`` template, which you might\nwant to override in your project.\n\nA link for editing an existing image would look like this::\n\n        <a href=\"{% url \"user_media_image_edit\" pk=form.instance.avatar.pk %}\">Edit picture</a>\n\n\nUpload from your own model form\n+++++++++++++++++++++++++++++++\n\nOften you might not want to provide a dedicated form for uploading images but\nyou might want to have an image field right on the model form of your content\nobject. In this case you can inherit from `UserMediaImageFormMixin`::\n\n    from django import forms\n    from user_media.forms import UserMediaImageFormMixin\n    from yourapp.models import UserProfile\n\n    class UserProfileForm(UserMediaImageFormMixin, forms.ModelForm):\n        image_label = _('Image')\n        require_user_media_image = False\n        image_field_name = 'user_media_image'\n        image_widget = forms.ClearableFileInput()  # optional\n\n        # your form implementation\n\nThe mixin will dynamically add a `forms.ImageField` with the name\n`user_media_image` to your form. You can control the label of that field by\nsetting the `image_label` attribute on your form class. You can also make the\nfield mandatory by setting the `require_user_media_image` attribute to `True`.\n\nAJAX calls\n----------\n\nYou might want to call the ``CreateImageView`` from an AJAX call, i.e. when\ndisplaying the form in a jQuery modal. To make life easier the view will\nreturn a different template when the request is an AJAX call.\n\nThe names of the alternative templates are\n``user_media/partials/ajax_usermediaimage_form.html`` and\n``user_media/partials/ajax_usermediaimage_confirm_delete.html``.\n\nMake sure to add a user field to the object::\n\n    user = models.ForeignKey(\n        getattr(settings, 'AUTH_USER_MODEL', 'auth.User'),\n        verbose_name=_('User'),\n    )\n\nAlternatively you can add a function called ``user_can_edit``: ::\n\n    def user_can_edit(self, user):\n        \"\"\"\n        Function, which returns True if the user is allowed edit the instance.\n\n        \"\"\"\n        if user in self.users.all():\n            return True\n        return False\n\n\nAJAX multi image upload\n-----------------------\n\nIf you want to upload multiple images at once, only prepare the following\ntemplates::\n\n    user_media/partials/image_upload.html\n    user_media/partials/image.html\n\nThen add styles and jQuery scripts. We've used blueimp's file upload, so you\nmake it work by adding jQuery & jQuery-UI plus the scripts in::\n\n    user_media/partials/image_upload_scripts.html\n\nNow include the form::\n\n    {% include \"user_media/partials/image_upload.html\" with object=request.user.get_profile maximum='5' hide_cutout='0' mode=\"multiple\" c_type=\"profile\" %}\n\nYou can use the variable `hide_cutout=\"0\"` to hide the link that triggers the\njQuery crop functionality.\n\nYou can limit the maximum upload by using the following setting::\n\n    USER_MEDIA_UPLOAD_MAXIMUM = 5\n\n\nAJAX single image upload\n------------------------\n\nYou can also combine single and multiple uploads. Just use the templates and\nadd the wanted variables::\n\n    {% include \"user_media/partials/image_upload.html\" with object=request.user.get_profile field='logo' mode=\"single\" show_main_thumb=\"True\" %}\n\nExtra classes for newly loaded image\n------------------------------------\n\nIf you are using the single image upload, your newly uploaded image will\nreplace the current `img`-element in your `userMediaImageUploaded`-element.\nSometimes you might have special CSS classes on your images and you might want\nto add those classes again to the `img` that has just been added to the DOM. In\norder to define the classes that should be added to newly loaded image, just\nadd the `data-img-class=\"myclass1 myclass2\"` attribute to the element that has\nthe `userMediaImageUploaded` class.\n\njQuery image cropping\n---------------------\n\nYou can easily add a frontend image cropping. First of all, add a new thumbnail\nprocessor ``user_media.processors.crop_box``::\n\n    THUMBNAIL_PROCESSORS = (\n        'user_media.processors.crop_box',\n        ...\n        'easy_thumbnails.processors.colorspace',\n        'easy_thumbnails.processors.autocrop',\n        'easy_thumbnails.processors.scale_and_crop',\n        'easy_thumbnails.processors.filters',\n    )\n\nThen add the cropping template and the relevant js libraries::\n\n    {% include \"user_media/partials/crop.html\" %}\n\n    <script src=\"{% static \"django_libs/js/getcookie.js\" %}\"></script>\n    <script src=\"{% static \"user_media/js/libs/jquery.Jcrop.js\" %}\"></script>\n\nYou can modify the settings by overwriting the input fields in ``crop.html``.\n\nCheck out: http://deepliquid.com/content/Jcrop.html\n\nNow, if a user clicks on ``Select another cutout``, the original image will be\npushed into the crop area, where the user is able to select a frame. If she\nthen saves the cropped area, the coordinates will be saved to the\n``UserMediaImage`` instance.\n\nBy using the new thumbnail processor it's easy to use this coordinates to\ngenerate thumbnails::\n\n    {% thumbnail image.image image.small_size box=image.box_coordinates %}\n\n\nSettings\n--------\n\nUSER_MEDIA_THUMB_SIZE_SMALL\n+++++++++++++++++++++++++++\n\nDefault: (95, 95)\n\nSize of the small auto-generated thumbnails, which are processed after\nupload/cropping.\n\n\nUSER_MEDIA_THUMB_SIZE_LARGE\n+++++++++++++++++++++++++++\n\nDefault: (150, 150)\n\nSize of the large auto-generated thumbnails, which are processed after\nupload/cropping.\n\n\nUSER_MEDIA_UPLOAD_MAXIMUM\n+++++++++++++++++++++++++\n\nDefault: 3\n\nAmount of images to be uploaded at a maximum.\n\n\nContribute\n----------\n\nIf you want to contribute to this project, please perform the following steps\n\n.. code-block:: bash\n\n    # Fork this repository\n    # Clone your fork\n    mkvirtualenv -p python2.7 django-user-media\n    make develop\n\n    git co -b feature_branch master\n    # Implement your feature and tests\n    git add . && git commit\n    git push -u origin feature_branch\n    # Send us a pull request for your feature branch\n\nIn order to run the tests, simply execute ``tox``. This will install two new\nenvironments (for Django 1.8 and Django 1.9) and run the tests against both\nenvironments.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/bitmazk/django-user-media",
    "keywords": "django,common,reusable,media,files,upload",
    "license": "The MIT License",
    "maintainer": null,
    "maintainer_email": null,
    "name": "django-user-media",
    "package_url": "https://pypi.org/project/django-user-media/",
    "platform": "OS Independent",
    "project_url": "https://pypi.org/project/django-user-media/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/bitmazk/django-user-media"
    },
    "release_url": "https://pypi.org/project/django-user-media/1.2.2/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "A reusable app to graceously handle files that your users might upload, such\nas profile pictures, foto albums etc...",
    "version": "1.2.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 3726333,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fd8e778131eea3b06e94cbc967e0a22b902b8bd8fc0387c9f46f60d1086d3fca",
        "md5": "9a16289f4560284b6fbc6587a1fb676a",
        "sha256": "d8b5f0fccd4312ecc1ee50111092c0d4d905b28fb833637f8b46c90e999386c2"
      },
      "downloads": -1,
      "filename": "django-user-media-1.2.2.tar.gz",
      "has_sig": false,
      "md5_digest": "9a16289f4560284b6fbc6587a1fb676a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 578773,
      "upload_time": "2016-04-20T07:21:13",
      "upload_time_iso_8601": "2016-04-20T07:21:13.615814Z",
      "url": "https://files.pythonhosted.org/packages/fd/8e/778131eea3b06e94cbc967e0a22b902b8bd8fc0387c9f46f60d1086d3fca/django-user-media-1.2.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}