{
  "info": {
    "author": "Mikhail Shvein",
    "author_email": "work_shvein_mihail@mail.ru",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "[![Python unit tests](https://github.com/M1ha-Shvn/django-pg-bulk-update/actions/workflows/python-tests.yml/badge.svg)](https://github.com/M1ha-Shvn/django-pg-bulk-update/actions/workflows/python-tests.yml)  [![Upload Python Package](https://github.com/M1ha-Shvn/django-pg-bulk-update/actions/workflows/python-publish.yml/badge.svg)](https://github.com/M1ha-Shvn/django-pg-bulk-update/actions/workflows/python-publish.yml) [![Downloads](https://pepy.tech/badge/django-pg-bulk-update/month)](https://pepy.tech/project/django-pg-bulk-update)\n\n# django-pg-bulk-update\nDjango extension to update multiple table records with similar (but not equal) conditions in efficient way on PostgreSQL\n\n## Requirements\n* Python 3.6+\n  Previous versions may also work, but are not tested in CI  \n* django >= 1.8  \n  Previous versions may also work, but are not tested in CI.  \n  django.postgres.contrib fields are also supported (available since django 1.8)\n  django.postgres.contrib.JSONField is supported since django 1.9  \n* pytz for python before 3.3\n* typing for python before 3.5\n* psycopg2\n* PostgreSQL 9.4+   \n  Previous versions may also work, but haven't been tested.  \n  JSONB operations are available for PostgreSQL 9.4+.\n  INSERT .. ON CONFLICT is used for PostgreSQL 9.5+.\n\n## Installation\nInstall via pip:  \n`pip install django-pg-bulk-update`    \nor via setup.py:  \n`python setup.py install`\n\n## Usage\nYou can make queries in 2 ways:\n* Declaring a custom manager for your model\n* Calling query functions directly\n\n### Query functions\nThere are 4 query helpers in this library. There parameters are unified and described in the section below.  \n\n* `bulk_update(model, values, key_fields='id', using=None, set_functions=None, key_fields_ops=(), where=None, returning=None, batch_size=None, batch_delay=0)`  \n    This function updates multiple records of given model in single database query.  \n    Functions forms raw sql query for PostgreSQL. It's work is not guaranteed on other databases.  \n    Function returns number of updated records.\n    \n* `bulk_update_or_create(model, values, key_fields='id', using=None, set_functions=None, update=True, key_is_unique=True, returning=None, batch_size=None, batch_delay=0)`  \n    This function finds records by key_fields. It creates not existing records with data, given in values.   \n    If `update` flag is set, it updates existing records with data, given in values.  \n    \n    There are two ways, this function may work:\n    1) Use INSERT ... ON CONFLICT statement. It is safe, but requires PostgreSQL 9.5+ and unique index on key fields.\n    This behavior is used by default.\n    2) 3-query transaction:  \n      + Search for existing records  \n      + Create not existing records (if values have any)  \n      + Update existing records (if values have any and `update` flag is set)  \n    This behavior is used by default on PostgreSQL before 9.5 and if key_is_unique parameter is set to False.\n    Note that transactional update has a known [race condition issue](https://github.com/M1hacka/django-pg-bulk-update/issues/14) that can't be fixed.\n      \n    Function returns number of records inserted or updated by query.\n    \n* `bulk_create(model, values, using=None, set_functions=None, returning=None, batch_size=None, batch_delay=0)`  \n  This function creates multiple records of given model in single database query.  \n  Its functionality is the same as django's [QuerySet.bulk_create](https://docs.djangoproject.com/en/3.0/ref/models/querysets/#bulk-create),\n  but it is implemented on this library bases and can be more effective in some cases (for instance, for wide models).\n  \n* `pdnf_clause(key_fields, field_values, key_fields_ops=())`  \n  Pure django implementation of principal disjunctive normal form. It is base on combining Q() objects.  \n  Condition will look like:\n  ```sql\n    SELECT ... WHERE (a = x AND b = y AND ...) OR (a = x1 AND b = y1  AND ...) OR ...\n  ```\n  Function returns a [django.db.models.Q](https://docs.djangoproject.com/en/2.0/topics/db/queries/#complex-lookups-with-q-objects) instance  \n\n\n### Function parameters\n* `model: Type[Model]`\n    A subclass of django.db.models.Model to update\n    \n* `values: Union[Union[TUpdateValuesValid, Dict[Any, Dict[str, Any]]], Iterable[Dict[str, Any]]]`    \n    Data to update. All items must update same fields!!!    \n    Parameter can have one of 2 forms:    \n    + Iterable of dicts. Each dict contains both key and update data. Each dict must contain all key_fields as keys.\n        You can't update key_fields with this format.\n    + Dict of key_values: update_fields_dict    \n        Can not be used for `bulk_create` function.\n        You can use this format to update key_fields\n        - key_values can be tuple or single object. If tuple, key_values length must be equal to key_fields length.\n         If single object, key_fields is expected to have 1 element\n        - update_fields_dict is a dictionary {field_name: update_value} to update\n        \n* `key_fields: Union[str, Iterable[str]]`\n  Optional. Field names, which are used as update conditions.\n  Parameter can have one of 2 forms:\n  + String for single key field. Primary key is used by default.\n  + Iterable of strings for multiple key fields.\n  \n* `using: Optional[str]`  \n  Optional. Database alias to query. If not set, 'default' database is used.\n  \n* `set_functions: Optional[Dict[str, Union[str, AbstractSetFunction]]]`  \n  Optional. Functions which will be used to set values.  \n  If given, it should be a dictionary:\n  + Key is a field name function is applied to\n  + Value can be:\n    + `django.db.models.expressions.BaseExpression` instance  \n        Any [django function expression](https://docs.djangoproject.com/en/3.2/ref/models/expressions/) returning a value.\n        Expression can use [Value](https://docs.djangoproject.com/en/3.2/ref/models/expressions/#value-expressions),\n        [F](https://docs.djangoproject.com/en/3.2/ref/models/expressions/#f-expressions),\n        [Func](https://docs.djangoproject.com/en/3.2/ref/models/expressions/#func-expressions) and their child classes.\n        It can not use annotations and tables other than updated model (like `F(a__b__c)`).\n        In create operations field default values is taken. If it is not provided, field default value is used.\n        Expression does not expect any value in `values` parameter and will ignore it if given.\n    \n    + Function alias name\n      - 'eq', '='  \n        Simple assign operator. It used by default for fields that are not mentioned in the dict.  \n      - 'incr', '+'  \n        Adds field value to previous one. It can be used for all numeric database types.   \n      - 'concat', '||'  \n        Concatenates field value to previous one. It can be used for string types, JSONField, HStoreField, ArrayField.\n      - 'eq_not_null'  \n        This function can be used, if you want to update value only if it is not None.\n      - 'union'  \n        This function combines ArrayField value with previous one, removing duplicates.\n      - 'array_remove'  \n        This function deletes value from ArrayField field using array_remove PSQL Function.\n      - 'now', 'NOW'  \n        This function sets field value to `NOW()` database function. Doesn't expect any value in `values` parameter. \n        If one is given it is ignored.   \n  \n    + `django_pg_bulk_update.set_functions.AbstractSetFunction` instance  \n      You can define your own set function. See section below.  \n    \n      Increment, union and concatenate functions concern NULL as default value.\n    \n* `key_field_ops: Union[Dict[str, Union[str, AbstractClauseOperator]], Iterable[Union[str, AbstractClauseOperator]]]`\n    Optional. Operators, which are used to fined records for update. Operators are applied to `key_fields`.  \n    If some fields are not given, equality operator is used.\n    `bulk_update_or_create` function always uses equality operator\n    Parameter can have one of 2 forms:  \n    - Iterable of operator alias names or AbstractClauseOperator instances.\n      Order of iterable must be the same as key_fields.\n    - Dictionary:\n      + Key is a field name, function is applied to\n      + Value is a function alias name of set function or AbstractSetFunction instance.  \n    Available name aliases:\n    - 'eq', '=', '=='\n      Simple equality condition. It is used by default.\n    - '!eq', '!=', '<>'\n      Not equal operator\n    - 'in'\n      Searches for records, which have field from values list. Value should be an iterable of correct field values.\n    - '!in'\n      Searches for records, which have field not from values list. Value should be an iterable of correct field values.\n    - 'lt', '<'\n    - 'lte', '<='\n    - 'gt', '>'\n    - 'gte', '>='\n    - 'between'\n      Searches for records, which have field between a and b. Value should be iterable with 2 items.\n    - 'is_null', 'isnull'\n      Checks field value for been NULL. Value should be boolean (true for IS NULL, false for IS NOT NULL)\n    - You can define your own clause operator. See section below.\n    \n* `where`: Optional[WhereNode]    \n    This parameter is used to filter data before doing bulk update, using QuerySet filter and exclude methods.\n    Generated condition should not contain annotations and other table references.    \n    *NOTE*: parameter is not supported in `bulk_update_or_create`\n    \n* `returning: Optional[Union[str, Iterable[str]]]`  \n    If this parameter is set, it can be:  \n    1. A field name string  \n    2. An iterable of field names   \n    3. '*' string to return all model fields  \n    \n    Query returns django_pg_returning.ReturningQuerySet instead of rows count.  \n    Using this feature requires [django-pg-returning](https://github.com/M1hacka/django-pg-returning/tree/v1.0.2) \n    library installed (it is not in requirements, though).\n      \n* `batch_size: Optional[int]`  \n    If this parameter is set, values are split into batches of given size. Each batch is processed separately.\n    Note that batch_size != number of records processed if you use key_field_ops other than 'eq'\n    \n* `batch_delay: float`  \n   If batch_size is set, this parameter sets time to sleep in seconds between batches execution\n    \n* `update: bool`  \n    If flag is not set, bulk_update_or_create function will not update existing records, only creating not existing. \n    \n* `key_is_unique: bool`\n    Defaults to True. Settings this flag to False forces library to use 3-query transactional update_or_create.\n    \n* `field_values: Iterable[Union[Iterable[Any], dict]]`  \n    Field values to use in `pdnf_clause` function. They have simpler format than update functions.\n    It can come in 2 formats:  \n    + An iterable of tuples in key_fields order `( (x, y), (x1, y1), ...)`\n    + An iterable of dicts with field name as key `({'a': x, 'b': y}, ...)`\n    \n\n### Examples\n```python\nfrom django.db import models, F\nfrom django.db.models.functions import Upper\nfrom django_pg_bulk_update import bulk_update, bulk_update_or_create, pdnf_clause\n\n# Test model\nclass TestModel(models.Model):\n    name = models.CharField(max_length=50)\n    int_field = models.IntegerField()\n\n# Create test data\ncreated = TestModel.objects.pg_bulk_create([\n    {'id': i, 'name': \"item%d\" % i, 'int_field': 1} for i in range(1, 4)\n])\nprint(created)\n# Outputs 3\n\n# Create test data returning\ncreated = TestModel.objects.pg_bulk_create([\n    {'id': i, 'name': \"item%d\" % i, 'int_field': 1} for i in range(4, 6)\n], returning='*')\nprint(created)\nprint(type(res), list(res.values_list('id', 'name', 'int_field')))\n# Outputs: \n# <class 'django_pg_returning.queryset.ReturningQuerySet'>\n# [\n#    (4, \"item4\", 1),\n#    (5, \"item5\", 1)\n# ]\n\n# Update by id field\nupdated = bulk_update(TestModel, [{\n    \"id\": 1,\n    \"name\": \"updated1\",\n}, {\n    \"id\": 2,\n    \"name\": \"updated2\"\n}])\n\nprint(updated)\n# Outputs: 2\n\n# Update returning\nres = bulk_update(TestModel, [{\n    \"id\": 1,\n    \"name\": \"updated1\",\n}, {\n    \"id\": 2,\n    \"name\": \"updated2\"\n}], returning=('id', 'name', 'int_field'))\n\nprint(type(res), list(res.values_list('id', 'name', 'int_field')))\n# Outputs: \n# <class 'django_pg_returning.queryset.ReturningQuerySet'>\n# [\n#    (1, \"updated1\", 1),\n#    (2, \"updated2\", 1)\n# ]\n\n# Call update by name field\nupdated = bulk_update(TestModel, {\n    \"updated1\": {\n        \"int_field\": 2\n    },\n    \"updated2\": {\n        \"int_field\": 3\n    }\n}, key_fields=\"name\")\n\nprint(updated)\n# Outputs: 2\n\nprint(list(TestModel.objects.all().order_by(\"id\").values(\"id\", \"name\", \"int_field\")))\n# Outputs: [\n#     {\"id\": 1, \"name\": \"updated1\", \"int_field\": 2},\n#     {\"id\": 2, \"name\": \"updated2\", \"int_field\": 3},\n#     {\"id\": 3, \"name\": \"item3\", \"int_field\": 1}\n# ]\n\n# Increment int_field by 3 and transform name to upper case for records where id >= 2 and int_field < 3\nupdated = bulk_update(TestModel, {\n        (2, 3): {\n            \"int_field\": 3\n        }\n    }, key_fields=['id', 'int_field'], key_fields_ops={'int_field': '<', 'id': 'gte'},\n    set_functions={'int_field': '+', 'name': Upper('name')})\n\nprint(updated)\n# Outputs: 1\n\nprint(list(TestModel.objects.all().order_by(\"id\").values(\"id\", \"name\", \"int_field\")))\n# Outputs: [\n#     {\"id\": 1, \"name\": \"updated1\", \"int_field\": 2},\n#     {\"id\": 2, \"name\": \"updated2\", \"int_field\": 3},\n#     {\"id\": 3, \"name\": \"incr\", \"int_field\": 4}\n# ]\n\n\nres = bulk_update_or_create(TestModel, [{\n    \"id\": 3,\n    \"name\": \"_concat1\"\n}, {\n    \"id\": 4,\n    \"name\": \"concat2\"\n}], set_functions={'name': '||', 'int_field': F('int_field') + 1})\n\nprint(res)\n# Outputs: 2\n\nprint(list(TestModel.objects.all().order_by(\"id\").values(\"id\", \"name\", \"int_field\")))\n# Note: IntegerField defaults to 0 in create operations. So 0 + 1 = 1.\n# Outputs: [\n#     {\"id\": 1, \"name\": \"updated1\", \"int_field\": 2},\n#     {\"id\": 2, \"name\": \"updated2\", \"int_field\": 3},\n#     {\"id\": 3, \"name\": \"incr_concat1\", \"int_field\": 5},\n#     {\"id\": 4, \"name\": \"concat2\", \"int_field\": 1},\n# ]\n\n# Find records where \n# id IN [1, 2, 3] AND name = 'updated2' OR id IN [3, 4, 5] AND name = 'concat2' OR id IN [2, 3, 4] AND name = 'updated1'\ncond = pdnf_clause(['id', 'name'], [([1, 2, 3], 'updated2'),\n                                    ([3, 4, 5], 'concat2'),\n                                    ([2, 3, 4], 'updated1')], key_fields_ops={'id': 'in'})\ndata = TestModel.objects.filter(cond).order_by('int_field').values_list('int_field', flat=True)\nprint(list(data))\n# Outputs: [3, 5]\n```\n\n### Using custom manager and query set\nIn order to simplify using `bulk_create`, `bulk_update` and `bulk_update_or_create` functions,\n you can use a custom manager.  \nIt automatically fills:\n * `model` parameter\n * `using` parameter (extracts queryset write database)\n * `where` parameter (applies queryset filters, if called as QuerySet method). Not supported in bulk_update_or_create.    \nYou can change database to use with [Manager.db_manager()](https://docs.djangoproject.com/en/2.0/topics/db/multi-db/#using-managers-with-multiple-databases) \nor [QuerySet.using()](https://docs.djangoproject.com/en/2.0/topics/db/multi-db/#manually-selecting-a-database-for-a-queryset) methods.  \nThe rest parameters are the same as above.  \n\n**Note**: As [django 2.2](https://docs.djangoproject.com/en/2.2/releases/2.2/) \n introduced [bulk_update](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#bulk-update) method,\n library methods were renamed to `pg_bulk_create`, `pg_bulk_update` and `pg_bulk_update_or_create` respectively.\n \nExample:\n```python\nfrom django.db import models\nfrom django_pg_bulk_update.manager import BulkUpdateManager\n\n# Test model\nclass TestModel(models.Model):\n    objects = BulkUpdateManager()\n    \n    name = models.CharField(max_length=50)\n    int_field = models.IntegerField()\n    \n# Now you can use functions like:\nTestModel.objects.pg_bulk_create([\n    # Any data here\n], set_functions=None)\n\nTestModel.objects.pg_bulk_update([\n    # Any data here\n], key_fields='id', set_functions=None, key_fields_ops=())\n\n# Update only records with id gtreater than 5 \nTestModel.objects.filter(id__gte=5).pg_bulk_update([\n    # Any data here\n], key_fields='id', set_functions=None, key_fields_ops=())\n\nTestModel.objects.pg_bulk_update_or_create([\n    # Any data here\n], key_fields='id', set_functions=None, update=True)           \n```\n\nIf you already have a custom manager, you can replace QuerySet to BulkUpdateQuerySet:\n```python\nfrom django.db import models\nfrom django.db.models.manager import BaseManager\nfrom django_pg_bulk_update.manager import BulkUpdateQuerySet\n\n\nclass CustomManager(BaseManager.from_queryset(BulkUpdateQuerySet)):\n    pass\n    \n    \n# Test model\nclass TestModel(models.Model):\n    objects = CustomManager()\n    \n    name = models.CharField(max_length=50)\n    int_field = models.IntegerField()\n```\n\nIf you already have a custom QuerySet, you can inherit it from BulkUpdateMixin:\n```python\nfrom django.db import models\nfrom django.db.models.manager import BaseManager\nfrom django_pg_bulk_update.manager import BulkUpdateMixin\n\n\nclass CustomQuerySet(BulkUpdateMixin, models.QuerySet):\n    pass\n    \n    \nclass CustomManager(BaseManager.from_queryset(CustomQuerySet)):\n    pass\n    \n    \n# Test model\nclass TestModel(models.Model):\n    objects = CustomManager()\n    \n    name = models.CharField(max_length=50)\n    int_field = models.IntegerField()\n```\n\n### Custom clause operator\nYou can define your own clause operator, creating `AbstractClauseOperator` subclass and implementing:\n* `names` attribute\n* `def get_django_filter(self, name)` method\n* One of `def get_sql_operator(self)` or `def get_sql(self, table_field, value)`\n  When clause is formed, it calls `get_sql()` method.\n  In order to simplify method usage of simple `field <op> value` operators,\n  by default `get_sql()` forms this condition, calling  `get_sql_operator()` method, which returns <op>.\n  \nOptionally, you can change `def format_field_value(self, field, val, connection, cast_type=True, **kwargs)` method,\nwhich formats value according to field rules\n\nExample:\n```python\nfrom django_pg_bulk_update import bulk_update\nfrom django_pg_bulk_update.clause_operators import AbstractClauseOperator\n\nclass LTClauseOperator(AbstractClauseOperator):\n    names = {'lt', '<'}\n\n    def get_django_filter(self, name):  # type: (str) -> str\n        \"\"\"\n        This method should return parameter name to use in django QuerySet.fillter() kwargs\n        :param name: Name of parameter\n        :return: String with filter\n        \"\"\"\n        return '%s__lt' % name\n\n    def get_sql_operator(self):  # type: () -> str\n        \"\"\"\n        If get_sql operator is simple binary operator like \"field <op> val\", this functions returns operator\n        :return: str\n        \"\"\"\n        return '<'\n        \n\n# Usage examples\n# import you function here before calling an update\nbulk_update(TestModel, [], key_field_ops={'int_field': 'lt'})\nbulk_update(TestModel, [], key_field_ops={'int_field': LTClauseOperator()})\n```\n\nYou can use class instance directly in `key_field_ops` parameter or use its aliases from `names` attribute.  \nWhen update function is called, it searches for all imported AbstractClauseOperator subclasses and takes first class\nwhich contains alias in `names` attribute.\n\n### Custom set function\nYou can define your own set function, creating `AbstractSetFunction` subclass and implementing:\n* `names` attribute\n* `supported_field_classes` attribute\n* One of:  \n  - `def get_sql_value(self, field, val, connection, val_as_param=True, with_table=False, for_update=True, **kwargs)` method\n  This method defines new value to set for parameter. It is called from `get_sql(...)` method by default.\n  - `def get_sql(self, field, val, connection, val_as_param=True, with_table=False, for_update=True, **kwargs)` method\n  This method sets full sql and it params to use in set section of update query.  \n  By default it returns: `\"%s\" = self.get_sql_value(...)`, params\n\nOptionally, you can change:\n* `def format_field_value(self, field, val, connection, cast_type=False, **kwargs)` method, if input data needs special formatting. \n* `def modify_create_params(self, model, key, kwargs)` method, to change data before passing them to model constructor\nin `bulk_update_or_create()`. This method is used in 3-query transactional update only. INSERT ... ON CONFLICT\nuses for_update flag of `get_sql()` and `get_sql_value()` functions\n\nExample:  \n\n```python\nfrom django_pg_bulk_update import bulk_update\nfrom django_pg_bulk_update.set_functions import AbstractSetFunction\n\nclass CustomSetFunction(AbstractSetFunction):\n    # Set function alias names\n    names = {'func_alias_name'}\n\n    # Names of django field classes, this function supports. You can set None (default) to support any field.\n    supported_field_classes = {'IntegerField', 'FloatField', 'AutoField', 'BigAutoField'}\n\n    def get_sql_value(self, field, val, connection, val_as_param=True, with_table=False, for_update=True, **kwargs):\n        \"\"\"\n        Returns value sql to set into field and parameters for query execution\n        This method is called from get_sql() by default.\n        :param field: Django field to take format from\n        :param val: Value to format\n        :param connection: Connection used to update data\n        :param val_as_param: If flag is not set, value should be converted to string and inserted into query directly.\n            Otherwise a placeholder and query parameter will be used\n        :param with_table: If flag is set, column name in sql is prefixed by table name\n        :param for_update: If flag is set, returns update sql. Otherwise - insert SQL\n        :param kwargs: Additional arguments, if needed\n        :return: A tuple: sql, replacing value in update and a tuple of parameters to pass to cursor\n        \"\"\"\n        # If operation is incremental, it should be ready to get NULL in database\n        null_default, null_default_params = self._parse_null_default(field, connection, **kwargs)\n        \n        # Your function/operator should be defined here\n        tpl = 'COALESCE(\"%s\", %s) + %s'\n\n        if val_as_param:\n            sql, params = self.format_field_value(field, val, connection)\n            return tpl % (field.column, null_default, sql), null_default_params + params\n        else:\n            return tpl % (field.column, null_default, str(val)), null_default_params\n            \n            \n# Usage examples\n# import you function here before calling an update\nbulk_update(TestModel, [], set_functions={'int_field': 'func_alias_name'})\nbulk_update(TestModel, [], set_functions={'int_field': CustomSetFunction()})\n```\n\nYou can use class instance directly in `set_functions` parameter or use its aliases from `names` attribute.  \nWhen update function is called, it searches for all imported AbstractSetFunction subclasses and takes first class\nwhich contains alias in `names` attribute.\n\n\n## Compatibility\nLibrary supports django.contrib.postgres.fields:  \n+ ArrayField  \n+ JSONField  \n+ HStoreField\n+ RangeField (IntegerRangeField, BigIntegerRangeField, FloatRangeField, DateTimeRangeField, DateRangeField)\n\nNote that ArrayField and HStoreField are available since django 1.8, JSONField - since django 1.9.  \nRangeField supports are available since PostgreSQL 9.2, psycopg2 since 2.5 and django since 1.8.  \nPostgreSQL before 9.4 doesn't support jsonb, and so - JSONField.  \nPostgreSQL 9.4 supports JSONB, but doesn't support concatenation operator (||). In order to support this set function a special function for postgres 9.4 was written. Add a migration to create it:\n\n```python\nfrom django.db import migrations,\nfrom django_pg_bulk_update.compatibility import Postgres94MergeJSONBMigration\n\nclass Migration(migrations.Migration):\n    dependencies = []\n\n    operations = [\n        Postgres94MergeJSONBMigration()\n    ]\n```\n\nPostgreSQL before 9.5 doesn't support INSERT ... ON CONFLICT statement. So 3-query transactional update will be used.\n\n## Performance\nTest background:\n- Django 2.0.2\n- PostgreSQL 10.2\n- Python 3.6.3\n- 1000 pre-created records  \nUpdating records one by one took 51,68 seconds.  \nUpdating records with bulk_update took 0.13 seconds.  \nYou can write your own tests, based on test.test_performance and running it.\n\n# Development\nThis is an Open source project developed by `M1ha-Shvn` under BSD 3 license. \nFeel free to create issues and make pull requests.   \nLibrary test system is based on [django.test](https://docs.djangoproject.com/en/3.2/topics/testing/overview/).\nYou can find them in `tests` directory. \n\n## Tests requirements  \n* [PostgreSQL](https://www.postgresql.org/)  \n* Pypi libraries listed in `requirements-test.txt` file  \n\n## Running tests\n### Running in docker\n1. Install [docker and docker-compose](https://www.docker.com/)\n2. Run `docker build . --tag django-pg-bulk-pupdate` in project directory\n3. Run `docker-compose run run_tests` in project directory  \n\n### Running in virtual environment\n1. Install all requirements listed above  \n2. [Create virtual environment](https://docs.python.org/3/tutorial/venv.html)  \n3. Create a superuser named 'test' on your local Postgres instance:\n  ```sql\n  CREATE ROLE test;\n  ALTER ROLE test WITH SUPERUSER;\n  ALTER ROLE test WITH LOGIN;\n  ALTER ROLE test PASSWORD 'test';\n  CREATE DATABASE test OWNER test;\n  CREATE DATABASE test2 OWNER test;\n  ```   \n3. Install requirements   \n  `pip3 install -U -r requirements-test.txt`  \n4. Start tests  \n  `python3 runtests.py`  \n   \n\n# Alternatives  \n## [django 2.2+ bulk_update](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#bulk-update) difference  \nPros:  \n* bulk_update_or_create() method\n* Ability to use complex set functions\n* Ability to use complex conditions\n* Ability to update primary key\n* pdnf_clause helper\n* Django 1.7+ support\n* Ability to make delay between batches\n* Ability to return affected rows instead of rowcount (using Postgres RETURNING feature)\n\nCons:  \n* PostgreSQL only\n* Ability to update parents/children (using extra queries)\n\n## [django-bulk-update](https://github.com/aykut/django-bulk-update) difference\nPros:\n* bulk_update_or_create() method\n* Ability to use complex set functions\n* Ability to use django expressions as set functions\n* Ability to use complex conditions\n* pdnf_clause helper\n* Django 1.7 support\n* Ability to make delay between batches\n* Ability to return affected rows instead of rowcount (using Postgres RETURNING feature)\n\nCons:\n* PostgreSQL only\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/M1hacka/django-pg-bulk-update",
    "keywords": "",
    "license": "BSD 3-clause \"New\" or \"Revised\" License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-pg-bulk-update",
    "package_url": "https://pypi.org/project/django-pg-bulk-update/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-pg-bulk-update/",
    "project_urls": {
      "Homepage": "https://github.com/M1hacka/django-pg-bulk-update"
    },
    "release_url": "https://pypi.org/project/django-pg-bulk-update/3.5.1/",
    "requires_dist": [
      "django (>=1.7)",
      "psycopg2",
      "pytz ; python_version < \"3.3\"",
      "typing ; python_version < \"3.5\""
    ],
    "requires_python": "",
    "summary": "Django extension, executing bulk update operations for PostgreSQL",
    "version": "3.5.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13705988,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c1b55c98ab166844cc901edff0dc5d935b63ef249d246f669419c2a3016f3ae3",
        "md5": "078ac03ef4d3c41525cccaee468d8141",
        "sha256": "6ecc42c8dec0d77fd62807aef861ee946b4c2d113f118917bb14cc4f206a839e"
      },
      "downloads": -1,
      "filename": "django_pg_bulk_update-3.5.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "078ac03ef4d3c41525cccaee468d8141",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 37873,
      "upload_time": "2022-02-06T17:02:35",
      "upload_time_iso_8601": "2022-02-06T17:02:35.604608Z",
      "url": "https://files.pythonhosted.org/packages/c1/b5/5c98ab166844cc901edff0dc5d935b63ef249d246f669419c2a3016f3ae3/django_pg_bulk_update-3.5.1-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "18f89e69e1c4e8f458a930ecc95acc6b7a7e2ac38185d2a625fffaf5f6613b20",
        "md5": "3bacebef32ddb068b2e2dd77a7f062a2",
        "sha256": "039389d68f62121f2953daf6b3762ded60be07a0b1c967b6b160d28850461cf3"
      },
      "downloads": -1,
      "filename": "django-pg-bulk-update-3.5.1.tar.gz",
      "has_sig": false,
      "md5_digest": "3bacebef32ddb068b2e2dd77a7f062a2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 40515,
      "upload_time": "2022-02-06T17:02:37",
      "upload_time_iso_8601": "2022-02-06T17:02:37.270718Z",
      "url": "https://files.pythonhosted.org/packages/18/f8/9e69e1c4e8f458a930ecc95acc6b7a7e2ac38185d2a625fffaf5f6613b20/django-pg-bulk-update-3.5.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}