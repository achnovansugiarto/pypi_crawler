{
  "info": {
    "author": "Kyle Lahnakoski",
    "author_email": "kyle@lahnakoski.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "More Logs - Structured Logging and Exception Handling\n=====================================================\n\nThis library provides two main features\n\n-  **Structured logging** - output is all JSON (with options to\n   serialize to text for humans)\n-  **Exception handling weaved in** - Good logs must represent what\n   happened, and that can not be done if the logging library is not\n   intimately familiar with the (exceptional) code paths taken.\n\nMotivation\n----------\n\nException handling and logging are undeniably linked. There are many\ninstances where exceptions are raised and must be logged, and others\nwhere the subsuming system can fully handle the exception, and no log\nshould be emitted. Exception handling semantics are great because they\ndecouple the cause from the solution, but this can be at odds with clean\nlogging - which couples raising and catching to make appropriate\ndecisions about what to emit to the log.\n\nThis logging module is additionally responsible for raising exceptions,\ncollecting the trace and context, and then deducing if it must be\nlogged, or if it can be ignored because something can handle it.\n\nMore Reading\n~~~~~~~~~~~~\n\n-  **Structured Logging is Good** -\n   https://sites.google.com/site/steveyegge2/the-emacs-problem\n\nBasic Usage\n-----------\n\nUse ``Log.note()`` for all logging\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n        Log.note(\"Hello, World!\")\n\nThere is no need to create logger objects. The ``Log`` module will keep\ntrack of what, where and who of every call.\n\nUse named parameters\n~~~~~~~~~~~~~~~~~~~~\n\nDo not use Python's formatting operator \"``%``\\ \" nor it's ``format()``\nfunction. Using them will create a string at call time, which is a\nparsing nightmare for log analysis tools.\n\n.. code:: python\n\n        Log.note(\"Hello, {{name}}!\", name=\"World!\")\n\nAll logs are structured logs; the parameters will be included,\nunchanged, in the log structure. This library also expects all parameter\nvalues to be JSON- serializable so they can be stored/processed by\ndownstream JSON tools.\n\n.. code:: javascript\n\n        {//EXAMPLE STRUCTURED LOG\n            \"template\": \"Hello, {{name}}!\",\n            \"param\": {\"name\": \"World!\"},\n            \"timestamp\": 1429721745,\n            \"thread\": {\n                \"name\": \"Main thread\"\n            },\n            \"location\": {\n                \"line\": 3,\n                \"file\": \"hello.py\",\n                \"method\": \"hello\"\n            },\n            \"machine\": {\n                \"python\": \"CPython\",\n                \"os\": \"Windows10\",\n                \"name\": \"ekyle-win\"\n            }\n        }\n\nInstead of ``raise`` use ``Log.error()``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n        Log.error(\"This will throw an error\")\n\nThe actual call will always raise an exception, and it manipulates the\nstack trace to ensure the caller is appropriately blamed. Feel free to\nuse the ``raise`` keyword (as in ``raise Log.error(\"\")``), if that looks\nnicer to you.\n\nAlways chain your exceptions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``cause`` parameter accepts an ``Exception``, or a list of\nexceptions. Chaining is generally good practice that helps you find the\nroot cause of a failure.\n\n.. code:: python\n\n        try:\n            # Do something that might raise exception\n        except Exception, e:\n            Log.error(\"Describe what you were trying to do\", cause=e)\n\nUse named parameters in your error descriptions too\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nError logging accepts keyword parameters just like ``Log.note()`` does\n\n.. code:: python\n\n        def worker(value):\n            try:\n                Log.note(\"Start working with {{key1}}\", key1=value1)\n                # Do something that might raise exception\n            except Exception, e:\n                Log.error(\"Failure to work with {{key2}}\", key2=value2, cause=e)\n\nNo need to formally type your exceptions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAn exception can be uniquely identified by the first-parameter string\ntemplate it is given; exceptions raised with the same template are the\nsame type. You should have no need to create new exception sub-types.\n\nTesting for exception \"types\"\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis library advocates chaining exceptions early and often, and this\nhides important exception types in a long causal chain. MoLogs allows\nyou to easily test if a type (or string, or template) can be found in\nthe causal chain by using the ``in`` keyword:\n\n.. code:: python\n\n        def worker(value):\n            try:\n                # Do something that might raise exception\n            except Exception, e:\n                if \"Failure to work with {{key2}}\" in e:\n                    # Deal with exception thrown in above code, no matter\n                    # how many other exception handlers where in the chain\n\nIf you can deal with an exception, then it will never be logged\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a caller catches an exception from a callee, it is the caller's\nresponsibility to handle that exception, or re-raise it. There are many\nsituations a caller can be expected to handle exceptions; and in those\ncases logging an error would be deceptive.\n\n.. code:: python\n\n        def worker(value):\n            try:\n                Log.error(\"Failure to work with {{key3}}\", key3=value3)\n            except Exception, e:\n                # Try something else\n\nUse ``Log.warning()`` if your code can deal with an exception, but you still\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwant to log it as an issue\n\n.. code:: python\n\n        def worker(value):\n            try:\n                Log.note(\"Start working with {{key4}}\", key4=value4)\n                # Do something that might raise exception\n            except Exception, e:\n                Log.warning(\"Failure to work with {{key4}}\", key4=value4, cause=e)\n\nDon't loose your stack trace!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBe aware your ``except`` clause can also throw exceptions: In the event\nyou catch a vanilla Python Exception, you run the risk of loosing its\nstack trace. To prevent this, wrap your exception in an ``Except``\nobject, which will capture your trace for later use. Exceptions thrown\nfrom this ``Log`` library need not be wrapped because they already\ncaptured their trace. If you wrap an ``Except`` object, you simply get\nback the object you passed.\n\n``python     try:         # DO SOME WORK             except Exception, e:         e = Except.wrap(e)         # DO SOME FANCY ERROR RECOVERY``\n\nAlways catch all ``Exceptions``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCatching all exceptions is preferred over the\n*only-catch-what-you-can-handle* strategy. First, exceptions are not\nlost because we are chaining. Second, we catch unexpected ``Exceptions``\nearly and we annotate them with a description of what the local code was\nintending to do. This annotation effectively groups the possible errors\n(known, or not) into a class, which can be used by callers to decide on\nappropriate mitigation.\n\nTo repeat: When using dependency injection, callers can not reasonably\nbe expected to know about the types of failures that can happen deep\ndown the call chain. This makes it vitally important that methods\nsummarize all exceptions, both known and unknown, so their callers have\nthe information to make better decisions on appropriate action.\n\nFor example: An abstract document container, implemented on top of a SQL\ndatabase, should not emit SQLExceptions of any kind: A caller that uses\na document container should not need to know how to handle SQLExceptions\n(or any other implementation-specific exceptions). Rather, in this\nexample, the caller should be told it \"can not add a document\", or \"can\nnot remove a document\". This allows the caller to make reasonable\ndecisions when they do occur. The original cause (the SQLException) is\nin the causal chain.\n\nAnother example, involves *nested exceptions*: If you catch a particular\ntype of exception, you may inadvertently catch the that same type of\nexception from deeper in the call chain. Narrow exception handling is an\nillusion. Broad exception handling will force you to consider a variety\nof failures early; force you to consider what it means when a block of\ncode fails; and force you to describe it for others.\n\nDon't make methods you do not need\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere is an argument that suggests you shoul break your code into\nmethods, rather than catching exceptions: The method name will describe\naction that failed, and the stack trace can be inspected to make\nmitigation decisions. But this is a poor solution:\n\n-  More methods means more complexity; the programmer must find the\n   method, remember he method, and wonder if it is used elsewhere.\n-  Catching exceptions allows you to add parameters\n-  Catching exceptions makes it clear the error is important; someone\n   might remove your method when refactoring\n-  Compiler optimizations can interfere with the call stack\n-  The name of the method might get very long to descibe the problem\n\nOther forms\n-----------\n\nAll the ``Log`` functions accept a ``default_params`` as a second\nparameter, like so:\n\n.. code:: python\n\n        Log.note(\"Hello, {{name}}!\", {\"name\": \"World!\"})\n\nthis is meant for the situation your code already has a bundled\nstructure you wish to use as a source of parameters. If keyword\nparameters are used, they will override the default values. Be careful\nwhen sending whole data structures, they will be logged!\n\nPlease, never use locals()\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n        def worker(value):\n            name = \"tout le monde!\"\n            password = \"123\"\n            Log.note(\"Hello, {{name}}\", locals())      # DO NOT DO THIS!\n\nDespite the fact using ``locals()`` is a wonderful shortcut for logging\nit is dangerous because it also picks up sensitive local variables. Even\nif ``{{name}}`` is the only value in the template, the whole\n``locals()`` dict will be sent to the structured loggers for recording.\n\nLog 'Levels'\n------------\n\nThe ``logs`` module has no concept of logging levels it is expected that\ndebug variables (variables prefixed with ``DEBUG_`` are used to control\nthe logging output.\n\n.. code:: python\n\n        # simple.py\n        DEBUG_SHOW_DETAIL = True\n\n        def worker():\n            if DEBUG_SHOW_DETAIL:\n                Log.note(\"Starting\")\n\n            # DO WORK HERE\n\n            if DEBUG_SHOW_DETAIL:\n                Log.note(\"Done\")\n\n        def main():\n            try:\n                settings = startup.read_settings()\n                Log.start(settings.debug)\n\n                # DO WORK HERE\n\n            except Exception, e:\n                Log.error(\"Complain, or not\", e)\n            finally:\n                Log.stop()\n\nThese debug variables can be set by configuration file:\n\n.. code:: javascript\n\n        // settings.json\n        {\n            \"debug\":{\n                \"constants\":{\"simple.DEBUG_SHOW_DETAILS\":false}\n            }\n        }\n\nConfiguration\n-------------\n\nThe ``logs`` module will log to the console by default.\n``Log.start(settings)`` will redirect the logging to other streams, as\ndefined by the settings:\n\n-  **log** - List of all log-streams and their parameters\n-  **trace** - Show more details in every log line (default False)\n-  **cprofile** - Used to enable the builtin python c-profiler (default\n   False)\n-  **profile** - Used to enable pyLibrary's simple profiling (default\n   False) (eg with Profiler(\"some description\"):)\n-  **constants** - Map absolute path of module constants to the values\n   that will be assigned. Used mostly to set debugging constants in\n   modules.\n\nOf course, logging should be the first thing to be setup (aside from\ndigesting settings of course). For this reason, applications should have\nthe following structure:\n\n.. code:: python\n\n        def main():\n            try:\n                settings = startup.read_settings()\n                Log.start(settings.debug)\n\n                # DO WORK HERE\n\n            except Exception as e:\n                Log.error(\"Complain, or not\", e)\n            finally:\n                Log.stop()\n\n::\n\n        \"log\": [\n            {\n                \"class\": \"logging.handlers.RotatingFileHandler\",\n                \"filename\": \"examples/logs/examples_etl.log\",\n                \"maxBytes\": 10000000,\n                \"backupCount\": 100,\n                \"encoding\": \"utf8\"\n            },\n            {\n                \"log_type\": \"email\",\n                \"from_address\": \"klahnakoski@mozilla.com\",\n                \"to_address\": \"klahnakoski@mozilla.com\",\n                \"subject\": \"[ALERT][DEV] Problem in ETL Spot\",\n                \"$ref\": \"file://~/private.json#email\"\n            },\n            {\n                \"log_type\": \"console\"\n            }\n        ]\n\nProblems with Python Logging\n----------------------------\n\n| `Python's default ``logging``\nmodule <https://docs.python.org/2/library/logging.html#logging.debug>`__\ncomes close to doing the right thing, but fails:\n|  \\* It has keyword parameters, but they are expanded at call time so\nthe values are lost in a string.\n|  \\* It has ``extra`` parameters, but they are lost if not used by the\nmatching ``Formatter``.\n|  \\* It even has stack trace with ``exc_info`` parameter, but only if\nan exception is being handled. \\* Python 2.x has no builtin exception\nchaining, but `Python 3\ndoes <https://www.python.org/dev/peps/pep-3134/>`__",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/klahnakoski/mo-logs",
    "keywords": "",
    "license": "MPL 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mo-logs",
    "package_url": "https://pypi.org/project/mo-logs/",
    "platform": "",
    "project_url": "https://pypi.org/project/mo-logs/",
    "project_urls": {
      "Homepage": "https://github.com/klahnakoski/mo-logs"
    },
    "release_url": "https://pypi.org/project/mo-logs/1.7.18029/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "More Logs! Structured Logging and Exception Handling",
    "version": "1.7.18029",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17547928,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1b838ced51a024df2f4449e81972fc6f456051e5983471a70124be2b59f621c2",
        "md5": "e3a805cc1ca0f45b207ba4987ad739a0",
        "sha256": "67a6699725241bcce58ed462f332df51e70429a2a1660f200e3f639474978499"
      },
      "downloads": -1,
      "filename": "mo-logs-1.7.18029.tar.gz",
      "has_sig": false,
      "md5_digest": "e3a805cc1ca0f45b207ba4987ad739a0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 31616,
      "upload_time": "2018-01-29T14:54:53",
      "upload_time_iso_8601": "2018-01-29T14:54:53.602141Z",
      "url": "https://files.pythonhosted.org/packages/1b/83/8ced51a024df2f4449e81972fc6f456051e5983471a70124be2b59f621c2/mo-logs-1.7.18029.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}