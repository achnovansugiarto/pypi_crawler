{
  "info": {
    "author": "Przemyslaw Wirkus, Johan Seferidis, James Crosby",
    "author_email": "Przemyslaw.Wirkus@arm.com, Johan.Seferidis@arm.com, James.Crosby@arm.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "[![Build status](https://circleci.com/gh/ARMmbed/mbed-ls/tree/master.svg?style=svg)](https://circleci.com/gh/ARMmbed/mbed-ls/tree/master)\n[![Coverage Status](https://coveralls.io/repos/github/ARMmbed/mbed-ls/badge.svg?branch=master)](https://coveralls.io/github/ARMmbed/mbed-ls?branch=master)\n[![PyPI version](https://badge.fury.io/py/mbed-ls.svg)](https://badge.fury.io/py/mbed-ls)\n\n# Table of contents\n\n* [Description](#description)\n* [Rationale](#rationale)\n* [Installation](#installation)\n  * [Installation from PyPI (Python Package Index)](#installation-from-pypi-python-package-index)\n  * [Installation from Python sources](#installation-from-python-sources)\n* [mbedls as command line tool](#mbedls-as-command-line-tool)\n  * [Exporting mbedls output to JSON](#exporting-mbedls-output-to-json)\n* [Porting instructions](#porting-instructions)\n  * [mbed-enabled technical specification overview](#mbed-enabled-technical-specification-overview)\n    * [TargetID as device unique identifier](#targetid-as-device-unique-identifier)\n  * [mbed-ls auto-detection approach for Ubuntu](#mbed-ls-auto-detection-approach-for-ubuntu)\n* [Retarget mbed-ls autodetection results](#retarget-mbed-ls-autodetection-results)\n  * [mbedls.json file properties](#mbedlsjson-file-properties)\n  * [Example of retargeting](#example-of-retargeting)\n* [Mocking new or existing target to custom platform name](#mocking-new-or-existing-target-to-custom-platform-name)\n  * [Mock command line examples](#mock-command-line-examples)\n  * [Mocking example with Freescale K64F platform](#mocking-example-with-freescale-k64f-platform)\n* [mbed-ls unit testing](#mbed-ls-unit-testing)\n  * [Code coverage](#code-coverage)\n* [Configure mbed-enabled device to work with your host](#configure-mbed-enabled-device-to-work-with-your-host)\n  * [Windows serial port configuration](#windows-serial-port-configuration)\n  * [Mounting with sync](#mounting-with-sync)\n    * [Ubuntu](#ubuntu)\n  * [Raspberry Pi - Raspbian Jessie Lite](#raspberry-pi---raspbian-jessie-lite)\n    * [Prerequisites](#prerequisites)\n    * [Install LDM](#install-ldm)\n    * [Enable LDM](#enable-ldm)\n    * [Making sure LDM is active (running)](#making-sure-ldm-is-active-running)\n* [Known issues](#known-issues)\n\n# Description\n\n```mbed-ls``` is a _Python 2.7_ module that detects and lists mbed-enabled devices connected to the host computer. It will be delivered as a redistributable Python module (package) and command line tool.\n\nCurrently supported operating system:\n\n* Windows 7.\n* Ubuntu.\n* Linux (generic).\n* Mac OS X (Darwin).\n* Raspbian Jessie Lite.\n\n# Rationale\n\nWhen connecting more than one mbed-enabled device to the host computer, it takes time to manually check the platforms' binds:\n\n* Mount point (MSD / disk).\n* Virtual serial port (CDC).\n* mbed's TargetID and generic platform name.\n\n```mbed-ls``` provides these points of information for all connected boards at once in a simple console (terminal) output.\n\n# Installation\n\n## Installation from PyPI (Python Package Index)\n\nmbed-ls module is redistributed via PyPI. We recommend you use the [application pip](https://pip.pypa.io/en/latest/installing.html#install-pip).\n\n**Note:** Python 2.7.9 onwards include ```pip``` by default, so you may have ```pip``` already.\n\nTo install mbed-ls from [PyPI](https://pypi.python.org/pypi/mbed-ls) use command:\n```\n$ pip install mbed-ls --upgrade\n```\n\n## Installation from Python sources\n\n**Prerequisites:** you need to have [Python 2.7.x](https://www.python.org/download/releases/2.7/) installed on your system.\n\n**Note:** if your OS is Windows, please follow the installation instructions [for the serial port driver](https://developer.mbed.org/handbook/Windows-serial-configuration).\n\nTo install the mbed-ls module:\n\nClone the mbed-ls repository. The following example uses the GitHub command line tools, but you can do this directly from the website:\n\n```\n$ git clone https://github.com/ARMmbed/mbed-ls.git\n```\n\nChange the directory to the mbed-ls repository directory:\n\n```\n$ cd mbed-ls\n```\n\nNow you are ready to install mbed-ls.\n\n```\n$ python setup.py install\n```\n\nOn Linux, if you have a problem with permissions please try to use ```sudo```:\n\n```\n$ sudo python setup.py install\n```\n\nThe above command should install the ```mbed-ls``` Python package (import ```mbed_lstools```) and mbedls command.\n\nTo test if your installation succeeded try the ```mbedls``` command:\n\n```\n$ mbedls\n```\n\nOr use the Python interpreter and import ```mbed_lstools```:\n\n```\n$ python\nPython 2.7.8 (default, Jun 30 2014, 16:03:49) [MSC v.1500 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n```\n\nGeneric mbedls API example:\n```python\n>>> import mbed_lstools\n>>> mbeds = mbed_lstools.create()\n>>> mbeds\n<mbed_lstools.lstools_win7.MbedLsToolsWin7 instance at 0x02F542B0>\n>>> mbeds.list_mbeds()\n[{'platform_name': 'K64F', 'mount_point': 'E:', 'target_id': '02400203D94B0E7724B7F3CF', 'serial_port': u'COM61'}]\n>>> print mbeds\n```\n\nExtended mbedls API example:\n```python\n>>> import mbed_lstools\n>>> m = mbed_lstools.create()\n>>> dir(m)\n['DEBUG_FLAG',\n 'ERRORLEVEL_FLAG',\n '__doc__',\n '__init__',\n '__module__',\n '__str__',\n 'debug',\n 'discover_connected_mbeds',\n 'err',\n 'get_connected_mbeds',\n 'get_dos_devices',\n 'get_json_data_from_file',\n 'get_mbed_com_port',\n 'get_mbed_devices',\n 'get_mbed_htm_target_id',\n 'get_mbeds',\n 'get_mounted_devices',\n 'get_string',\n 'iter_keys',\n 'iter_keys_as_str',\n 'iter_vals', 'list_mbeds',\n 'list_mbeds_by_targetid',\n 'list_mbeds_ext',\n 'list_platforms',\n 'list_platforms_ext',\n 'load_mbed_description',\n 'manufacture_ids',\n 'os_supported',\n 'regbin2str',\n 'scan_html_line_for_target_id',\n 'usb_vendor_list',\n 'winreg']\n>>> m.list_platforms()\n['LPC1768', 'K64F']\n>>> m.list_platforms_ext()\n{'K64F': 1, 'LPC1768': 2}\n```\n\n# mbedls as command line tool\n\nAfter installation of the mbed-ls package, you can use the mbedls command. It allows you to list all connected mbed-enabled devices and gives you the correct association between your board mount point (disk) and the serial port. TargetID information is also provided for your information.\n\n```\n$ mbedls\n+---------------------+-------------------+-------------------+--------------------------------+\n|platform_name        |mount_point        |serial_port        |target_id                       |\n+---------------------+-------------------+-------------------+--------------------------------+\n|KL25Z                |I:                 |COM89              |02000203240881BBD9F47C43        |\n|NUCLEO_F302R8        |E:                 |COM34              |07050200623B61125D5EF72A        |\n+---------------------+-------------------+-------------------+--------------------------------+\n```\n\nIf you want to use ```mbedls``` in your toolchain, continuous integration or automation script and do not necessarily want to use the Python module ```mbed_lstools``` - this solution is for you.\n\n## Exporting mbedls output to JSON\n\nYou can export mbedls outputs to JSON format: just use the ```---json``` switch and dump your file on the screen or redirect to a file. It should help you further automate your processes.\n\n```json\n$ mbedls --json\n[\n    {\n        \"mount_point\": \"E:\",\n        \"platform_name\": \"NUCLEO_L152RE\",\n        \"serial_port\": \"COM9\",\n        \"target_id\": \"07100200860579FAB960EFD7\"\n    },\n    {\n        \"mount_point\": \"F:\",\n        \"platform_name\": null,\n        \"serial_port\": \"COM5\",\n        \"target_id\": \"A000000001\"\n    },\n    {\n        \"mount_point\": \"G:\",\n        \"platform_name\": \"NUCLEO_F302R8\",\n        \"serial_port\": \"COM34\",\n        \"target_id\": \"07050200623B61125D5EF72A\"\n    },\n    {\n        \"mount_point\": \"H:\",\n        \"platform_name\": \"LPC1768\",\n        \"serial_port\": \"COM77\",\n        \"target_id\": \"101000000000000000000002F7F18695\"\n    },\n    {\n        \"mount_point\": \"I:\",\n        \"platform_name\": \"KL25Z\",\n        \"serial_port\": \"COM89\",\n        \"target_id\": \"02000203240881BBD9F47C43\"\n    }\n]\n```\n\n# Porting instructions\n\nYou can help us improve the mbed-ls tools by - for example - committing a new OS port. You can see the list of currently supported OSs in the [Description](#description) section; if your OS isn't there, you can port it.\n\nFor further study please check how Mac OS X (Darwin) was ported in [this pull request](https://github.com/ARMmbed/mbed-ls/pull/1).\n\n## mbed-enabled technical specification overview\n\n[mbed-enabled](https://www.mbed.com/en/about-mbed/mbed-enabled/) program is designed for mbed developers and partners who want to clearly identify their products as interoperable mbed Enabled technologies.\nUser facing [DAPLink](https://github.com/mbedmicro/DAPLink#daplink) interface connects mbed-enabled device with host computer using USB interface.\n\nInterface chip should in general follow few generic rules to allow proper host detection and compliance with for example mbed test tools. There are listed below:\n* Existance of CDC (virtual serial port)\n  * Must support at all standard baudrates 9600 thru 115200\n  * Must Support `SendBreak` resulting in target reset sequence\n  * MUst have TargetID embedded in USBID\n* Mass Storage Device Class\n  * Must support programming binary files (copy file on MSD results in target flashing)\n  * Target flashing should not result in automatic target reset\n  * Must have `DETAILS.TXT` with DAPlink specification\n  * Must have `mbed.htm` with DAPlink specification\n  * `mbed.htm` should contain link to platform with `TargetID` specified\n  * Must have TargetID embedded in `USBID`\n\n### TargetID as device unique identifier\n\nEach device must have an unique identifier which generic format is specified in below chapter.\n\nTargetID generic format:\n* ASCII string containing hexadecimal values only: `[a-fA-F0-9]{4, }`\n* Should be longer than four ASCII characters (two bytes of hex data)\n* First 2 bytes coded with four ASCII characters are `vendor code`\n    * Note: *There might be more than one vendor code value assigned to one vendor.*\n* Following 2 bytes coded with four ASCII characters are `platform code`*\n* Rest of ASCII characters are vendor / platform specific. Ignored by mbed-enabled tools\n* `Vendor code` + `platform code` should create globally unique value\n\nExample TargetID coding:\n* Freescale `K64F` TargetID: `0240000033514e450019500585d40008e981000097969900`\n\n```\n        02\t40\t000033514e450019500585d40008e981000097969900\n        |   |\n        |   v\n        v\tK64F\n        Freescale\n```\n\n## mbed-ls auto-detection approach for Ubuntu\n\nLet's connect a few mbed boards to our Ubuntu host. The devices should mount as MSC and CDC (virtual disk and serial port). We'll use regular Linux commands to see the boards, then see how ```mbed-ls``` displays them.\n\nIn this example, we've connected to our Ububtu machine's USB ports:\n\n* 2 x STMicro's Nucleo mbed boards.\n* 2 x NXP mbed boards.\n* 1 x Freescale Freedom board.\n\nWe can see the mounting result in the usb-id directories in Ubuntu's file system under ```/dev/```. To list mbed boards mounted to serial ports (CDC) via USB, we use the general Linux command:\n\n```\n$ ll /dev/serial/by-id\n```\n\nWe'll see:\n\n```\ntotal 0\ndrwxr-xr-x root 140 Feb 19 12:38 ./\ndrwxr-xr-x root  80 Feb 19 12:35 ../\nlrwxrwxrwx root  13 Feb 19 12:38 usb-MBED_MBED_CMSIS-DAP_02000203240881BBD9F47C43-if01 -> ../../ttyACM0\nlrwxrwxrwx root  13 Feb 19 12:35 usb-MBED_MBED_CMSIS-DAP_A000000001-if01 -> ../../ttyACM4\nlrwxrwxrwx root  13 Feb 19 12:35 usb-mbed_Microcontroller_101000000000000000000002F7F18695-if01 -> ../../ttyACM3\nlrwxrwxrwx root  13 Feb 19 12:35 usb-STMicroelectronics_STM32_STLink_066EFF525257775087141721-if02 -> ../../ttyACM2\nlrwxrwxrwx root  13 Feb 19 12:35 usb-STMicroelectronics_STM32_STLink_066EFF534951775087215736-if02 -> ../../ttyACM1\n```\n\nTo list boards mounted to disks (MSC) via USB, we use the general Linux command:\n```\n$ ll /dev/disk/by-id\n```\n\nWe'll see:\n\n```\ntotal 0\ndrwxr-xr-x root 340 Feb 19 12:38 ./\ndrwxr-xr-x root 120 Feb 19 12:35 ../\nlrwxrwxrwx root   9 Dec  3 09:10 ata-HDS728080PLA380_40Y9028LEN_PFDB32S7S44XLM -> ../../sda\nlrwxrwxrwx root  10 Dec  3 09:10 ata-HDS728080PLA380_40Y9028LEN_PFDB32S7S44XLM-part1 -> ../../sda1\nlrwxrwxrwx root  10 Dec  3 09:10 ata-HDS728080PLA380_40Y9028LEN_PFDB32S7S44XLM-part2 -> ../../sda2\nlrwxrwxrwx root  10 Dec  3 09:10 ata-HDS728080PLA380_40Y9028LEN_PFDB32S7S44XLM-part5 -> ../../sda5\nlrwxrwxrwx root   9 Dec  3 09:10 ata-TSSTcorpDVD-ROM_TS-H352C -> ../../sr0\nlrwxrwxrwx root   9 Feb 19 12:35 usb-MBED_MBED_CMSIS-DAP_A000000001-0:0 -> ../../sdf\nlrwxrwxrwx root   9 Feb 19 12:38 usb-MBED_microcontroller_02000203240881BBD9F47C43-0:0 -> ../../sdb\nlrwxrwxrwx root   9 Feb 19 12:35 usb-MBED_microcontroller_066EFF525257775087141721-0:0 -> ../../sdd\nlrwxrwxrwx root   9 Feb 19 12:35 usb-MBED_microcontroller_066EFF534951775087215736-0:0 -> ../../sdc\nlrwxrwxrwx root   9 Dec  3 16:10 usb-MBED_microcontroller_0670FF494956805087154420-0:0 -> ../../sdc\nlrwxrwxrwx root   9 Feb 19 12:35 usb-mbed_Microcontroller_101000000000000000000002F7F18695-0:0 -> ../../sde\nlrwxrwxrwx root   9 Dec  3 09:10 wwn-0x5000cca30ccffb77 -> ../../sda\nlrwxrwxrwx root  10 Dec  3 09:10 wwn-0x5000cca30ccffb77-part1 -> ../../sda1\nlrwxrwxrwx root  10 Dec  3 09:10 wwn-0x5000cca30ccffb77-part2 -> ../../sda2\nlrwxrwxrwx root  10 Dec  3 09:10 wwn-0x5000cca30ccffb77-part5 -> ../../sda5\n```\n\n***Note:*** ```mbed-ls``` tools pair only serial ports and mount points (not CMSIS-DAP - yet).\n\nWe can see that on our host machine (running Ubuntu) there are many 'disk type' devices visible under ```/dev/disk```. The mbed boards can be distinguished and filtered by their unique ```USB-ID``` conventions. In our case, we can see pairs of ```usb-ids``` in both ```/dev/serial/usb-id``` and ```/dev/disk/usb-id``` with embedded ``` TargetID```.  ```TargetID``` can be filtered out, for example using this sudo-regexpr: ```(“MBED”|”mbed”|”STMicro”)_([a-zA-z_-]+)_([a-fA_F0-0]){4,}```\n\nFor example, we can match the board 066EFF525257775087141721 by connecting a few dots:\n\n* ```usb-MBED_microcontroller_066EFF525257775087141721-0:0 -> ../../sdd```\n* ```usb-STMicroelectronics_STM32_STLink_066EFF525257775087141721-if02 -> ../../ttyACM2``` Based on the TargetID hash.\n\nFrom this we know that the target platform has these properties:\n\n* The unique target platform identifier is ```066E```.\n* The serial port is ```ttyACM2```.\n* The mount point is ```sdd```.\n\nYour ```mbed-ls``` implementation resolves those three and creates a “tuple” with those values (for each connected device). Using this tuple(s), ```mbed-ls``` will convert the platform number to a human-readable name etc.\n\nNote that for some boards the ```TargetID``` format is proprietary (see STMicro boards) and ```usb-id``` does not have a valid TargetID where the four first letters are the target platform's unique ID. In that case, ```mbed-ls``` tools inspects the ```mbed.htm``` file on the mbed mounted disk to get the proper TargetID from the URL in the ```meta``` part of the HTML header.\n\nIn the following example, the URL ```http://mbed.org/device/?code=07050200623B61125D5EF72A``` for the STMicro Nucleo F302R8 board contains the valid TargetID ```07050200623B61125D5EF72A```, which ```mbed-ls``` uses to detect the ```platform_name```. ```mbed-ls``` will then replace the invalid TargetID in ```usb-id``` with the value from ```mbed.htm```.\n\n```html\n<!-- mbed Microcontroller Website and Authentication Shortcut -->\n<!-- Version: 0200 Build: Aug 27 2014 13:29:28 -->\n<html>\n<head>\n<meta http-equiv=\"refresh\" content=\"0; url=http://mbed.org/device/?code=07050200623B61125D5EF72A\"/>\n<title>mbed Website Shortcut</title>\n</head>\n<body></body>\n</html>\n```\n\nThis is the result of ```mbedls``` listing the connected devices that we saw above:\n```\n$ mbedls\n+---------------------+-------------------+-------------------+----------------------------------------+\n|platform_name        |mount_point        |serial_port        |target_id                               |\n+---------------------+-------------------+-------------------+----------------------------------------+\n|KL25Z                |I:                 |COM89              |02000203240881BBD9F47C43                |\n|LPC1768              |H:                 |COM77              |101000000000000000000002F7F18695        |\n|NUCLEO_F302R8        |G:                 |COM34              |07050200623B61125D5EF72A                |\n|NUCLEO_L152RE        |E:                 |COM9               |07100200860579FAB960EFD7                |\n|unknown              |F:                 |COM5               |A000000001                              |\n+---------------------+-------------------+-------------------+----------------------------------------+\n```\n\n# Retarget mbed-ls autodetection results\n\nUser can create file ```mbedls.json``` in given directory. ```mbedls.json``` file should contain JSON formatted data which will redefine mbed's parameters returned by mbed-ls. ```mbed-ls``` will automatically read ```mbedls.json``` file and alter auto-detection result.\nFile should be placed in directory where we want to alter mbed-ls behavior.\n\n* Note: This feature in implicitly ON.\n* Note: This feature can be turned off with command line switch ```--skip-retarget```.\n\n## mbedls.json file properties\n* If file ```mbedls.json``` exists will be implicitly used to retarget results.\n* If file ```mbedls.json``` exists and flag ```--skip-retarget``` is set, there will be no retarget.\n* If file ```mbedls.json``` doesn't exist flag ```--skip-retarget``` has no effect.\n\n## Example of retargeting\nIn this example we will replace serial port name during Freescale's K64F auto-detection:\n```\n$ mbedls\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n|platform_name |platform_name_unique |mount_point |serial_port |target_id                                        |\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n|K64F          |K64F[0]              |F:          |COM9        |0240022648cb1e77000000000000000000000000b512e3cf |\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n```\n\nOur device is detected on port ```COM9``` and MSD is mounted on ```F:```. We can check more details using ```--json``` switch:\n```\n$ mbedls --json\n[\n    {\n        \"mount_point\": \"F:\",\n        \"platform_name\": \"K64F\",\n        \"platform_name_unique\": \"K64F[0]\",\n        \"serial_port\": \"COM9\",\n        \"target_id\": \"0240022648cb1e77000000000000000000000000b512e3cf\",\n        \"target_id_mbed_htm\": \"0240022648cb1e77000000000000000000000000b512e3cf\",\n        \"target_id_usb_id\": \"0240022648cb1e77000000000000000000000000b512e3cf\"\n    }\n]\n```\n\nWe must understand that ```mbed-ls``` stores information about mbed devices in dictionaries.\nThe same information can be presented as dictionary where its keys are ```target_id``` and value is a mbed auto-detection data.\n\n```\n$ mbedls --json-by-target-id\n{\n    \"0240022648cb1e77000000000000000000000000b512e3cf\": {\n        \"mount_point\": \"F:\",\n        \"platform_name\": \"K64F\",\n        \"platform_name_unique\": \"K64F[0]\",\n        \"serial_port\": \"COM9\",\n        \"target_id\": \"0240022648cb1e77000000000000000000000000b512e3cf\",\n        \"target_id_mbed_htm\": \"0240022648cb1e77000000000000000000000000b512e3cf\",\n        \"target_id_usb_id\": \"0240022648cb1e77000000000000000000000000b512e3cf\"\n    }\n}\n```\n\nLet's say we want change ```serial_port```'s value to other COM port. For example we are using other serial port (e.g. while debugging) on our device as standard output.\nTo do so we would have to create a new file called ```mbedls.json``` in directory where want to use this modification. File content could look like this: a JSON file where keys are ```target_id```'s and values are dictionaries with new values:\n\n```\n$ cat mbedls.json\n{\n    \"0240022648cb1e77000000000000000000000000b512e3cf\" : {\n        \"serial_port\" : \"MyComPort01\"\n    }\n}\n```\n\nNow, when we issue ```mbedls``` command in this directory our auto-detection data will be replaced:\n```\n$ mbedls\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n|platform_name |platform_name_unique |mount_point |serial_port |target_id                                        |\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n|K64F          |K64F[0]              |F:          |MyComPort01 |0240022648cb1e77000000000000000000000000b512e3cf |\n+--------------+---------------------+------------+------------+-------------------------------------------------+\n```\n\n# Mocking new or existing target to custom platform name\nCommand line switch ```--mock``` provide simple manufacturers ID masking with new platform name.\nUsers should be able to add temporarily new ```MID``` -> ```platform_name``` mapping when e.g. prototyping.\n\nMock configuration will be stored in `$HOME/.mbed-ls/` directory, in local file ```.mbedls-mock```.\n\n**Note***: ```MID``` stands for \"manufacturers ID\". `MID` is first four (4) characters of ```target_id``` string. Example: If ```target_id``` is ```02400221A0811E505D5FE3E8```, corresponding manufacturers ID is ```0240```.\n\n## Mock command line examples\n* Mock command line parameter: `--mock` or (switch `-m`)\n* Add new / mask existing mapping ```MID``` -> ```platform_name``` and assign `MID`:\n    * ```$ mbedls --mock MID:PLATFORM_NAME``` or\n    * ```$ mbedls --mock MID1:PLATFORM_NAME1,MID2:PLATFORM_NAME2```\n    * Example: `$ mbedls --mock 0818:NUCLEO_F767ZI`\n* Remove masking with '!' prefix: `$ mbedls --mock !MID`\n* Remove all maskings using !* notation: `$ mbedls --mock !*`\n* Combine above using comma (`,`) separator: `$ mbedls --mock MID1:PLATFORM_NAME1,!MID2`\n\n## Mocking example with Freescale K64F platform\nInitial setup with 1 x Freescale ```K64F``` board:\n```\n$ mbedls\n+--------------+---------------------+------------+------------+-------------------------+\n|platform_name |platform_name_unique |mount_point |serial_port |target_id                |\n+--------------+---------------------+------------+------------+-------------------------+\n|K64F          |K64F[0]              |F:          |COM146      |02400221A0811E505D5FE3E8 |\n+--------------+---------------------+------------+------------+-------------------------+\n```\n\n* We can mask current mapping ```0240``` -> ```K64F``` to something else. For example we can replace ```K64F``` name with maybe more suitable for us in current setup ```FRDM-K64F```:\n```\n$ mbedls --mock 0240:FRDM_K64F\n```\nCurrent mocking mapping is stored in local file ```.mbedls-mock```:\n```\n$ cat .mbedls-mock\n{\n    \"1234\": \"NEW_PLATFORM_1\",\n    \"0240\": \"FRDM_K64F\"\n}\n```\nWe can observe changes immediately. Please note this change only works in the same directory because we save ```.mbedls-mock``` file locally:\n```\n$ mbedls\n+--------------+---------------------+------------+------------+-------------------------+\n|platform_name |platform_name_unique |mount_point |serial_port |target_id                |\n+--------------+---------------------+------------+------------+-------------------------+\n|FRDM_K64F     |FRDM_K64F[0]         |F:          |COM146      |02400221A0811E505D5FE3E8 |\n+--------------+---------------------+------------+------------+-------------------------+\n```\n\n* We can remove mapping ```1234``` -> Anythying using ```!``` wild-card.\nNote: We are using flag ```-json``` to get JSON format output of the ```--mock``` operation.\n```\n$ mbedls --mock !1234 --json\n{\n    \"0240\": \"FRDM_K64F\"\n}\n```\n\n* We can add multiple mappings at the same time:\n```\n$ mbedls --mock 0000:DUMMY,1111:DUMMY_2 --json\n{\n    \"1111\": \"DUMMY_2\",\n    \"0240\": \"FRDM_K64F\",\n    \"0000\": \"DUMMY\"\n}\n```\n\n* We can remove (```!```) all mappings using ```*``` wildcard:\n```\n$ mbedls --mock !*\n```\n\nWe can verify our mapping is reset:\n```\n$ cat $HOME/.mbed-ls/.mbedls-mock\n{}\n```\n\n# mbed-ls unit testing\n* ```mbed-ls``` package contains basic unit tests.\n* Tests are stored under ```\\mbed-ls\\test ``` directory.\n* Tests cover basic function calls, object construction and check if minimal requirements for OS porting are fulfilled.\n* Standard Python’s ```unittest``` library was used so it is easy to contribute to test effort.\nTo invoke test procedure from command line please change directory to current mbed-ls repo directory and call setup.py with 'test' option.\n```\n$ cd mbed-ls\n$ python setup.py test\n```\n```\nrunning test\nrunning egg_info\nwriting requirements to mbed_ls.egg-info\\requires.txt\nwriting mbed_ls.egg-info\\PKG-INFO\nwriting top-level names to mbed_ls.egg-info\\top_level.txt\nwriting dependency_links to mbed_ls.egg-info\\dependency_links.txt\nwriting entry points to mbed_ls.egg-info\\entry_points.txt\nreading manifest file 'mbed_ls.egg-info\\SOURCES.txt'\nwriting manifest file 'mbed_ls.egg-info\\SOURCES.txt'\nrunning build_ext\ntest_example (test.basic.BasicTestCase) ... ok\ntest_detect_os_support_ext (test.detect_os.DetectOSTestCase) ... ok\ntest_porting_create (test.detect_os.DetectOSTestCase) ... ok\ntest_porting_mbed_lstools_os_info (test.detect_os.DetectOSTestCase) ... ok\ntest_porting_mbed_os_support (test.detect_os.DetectOSTestCase) ... ok\n.\n.\n.\n----------------------------------------------------------------------\nRan 18 tests in 0.302s\n\nOK\n```\n\n## Code coverage\n\nWe can measure code coverage for unit tests deployed together with ```mbed-ls```. To do so we can use popular Python ```coverage``` tools.\nFirst install ```coverage``` tool on your system:\n```\n$ pip install coverage --upgrade\n```\n\nNext go to ```mbed-ls``` local directory and execute coverage for unit tests:\n```\n$ cd mbed-ls\n$ coverage run setup.py test\n```\n\nAbove command will execute test cases and will grab code coverage numbers. Now we are ready to print code coverage for all tests we've run:\n\n```\n$ coverage report\nName                                    Stmts   Miss  Cover\n-----------------------------------------------------------\nmbed_lstools\\__init__.py                    2      0   100%\nmbed_lstools\\lstools_base.py              246    169    31%\nmbed_lstools\\lstools_darwin.py             88     77    13%\nmbed_lstools\\lstools_linux_generic.py     148     51    66%\nmbed_lstools\\lstools_ubuntu.py              5      0   100%\nmbed_lstools\\lstools_win7.py              112     60    46%\nmbed_lstools\\main.py                       90     63    30%\n-----------------------------------------------------------\nTOTAL                                     691    420    39%\n```\n\n# Configure mbed-enabled device to work with your host\n\n## Windows serial port configuration\n\nThe mbed serial port works by default on Mac and Linux, but Windows needs a driver. Check [here](https://developer.mbed.org/handbook/Windows-serial-configuration) for more details.\n\n## Mounting with sync\nWhile working under Ubuntu/Linux/OSX OSs you will have to mount your mbed-enabled device. You can follow instructions how to do it [here](https://developer.mbed.org/handbook/Mounting-with-sync).\n\n### Ubuntu\nWe recommend you use ```usbmount``` package to auto-mount mbed devices plugged to your host system:\n\n* Install ```usbmount```:\n\n```\n$ sudo apt-get install usbmount\n```\n\n* Make copy of ```/etc/usbmount/usbmount.conf```:\n\n```\n$ sudo cp /etc/usbmount/usbmount.conf /etc/usbmount/usbmount.conf.bak\n```\n\n* Modify ```/etc/usbmount/usbmount.conf``` file as follows:\n\n```\nENABLED=1\n\nMOUNTPOINTS=\"/media/usb0 /media/usb1 /media/usb2 /media/usb3\n             /media/usb4 /media/usb5 /media/usb6 /media/usb7\n             /media/usb8 /media/usb9 /media/usb10 /media/usb11\n             /media/usb12 /media/usb13 /media/usb14 /media/usb15\n             /media/usb16 /media/usb17 /media/usb18 /media/usb19\"\n\nFILESYSTEMS=\"vfat ext2 ext3 ext4 hfsplus\"\n\nMOUNTOPTIONS=\"sync,noexec,nodev,noatime,nodiratime\"\n\nFS_MOUNTOPTIONS=\"-fstype=vfat,gid=USERGROUP,uid=USERNAME,dmask=000,fmask=000\"\n\nVERBOSE=no\n```\n\n*Note*: In line:\n```\nFS_MOUNTOPTIONS=\"-fstype=vfat,gid=USERGROUP,uid=USERNAME,dmask=000,fmask=000\"\n```\nchange ```USERGROUP``` and ```USERNAME``` to your user and group names.\n\nYou can check user \"USERNAME\" group by typing:\n```\n$ groups USERNAME\n```\n\nThis ```usbmount``` configuration will auto-mount your mbed devices without need to type ```mount``` commands each time you plug your mbeds!\n\n## Raspberry Pi - Raspbian Jessie Lite\nFor Raspberry Pi you can use [LDM](https://github.com/LemonBoy/ldm): A lightweight device mounter. This should improve stability of your mounts when using mbed-ls on Raspberry Pi. Currently we are using it with _Raspbian Jessie Lite_.\n\nHow to install and use LDM on your Raspberry Pi in three easy steps:\n\n### Prerequisites\nLDM requires additional packages installed (libudev, mount and glib-2.0). You can use below command to check if all requirements are fulfilled:\n```\n$ pkg-config --cflags libudev mount glib-2.0\n```\n\nYou may need to install additional packages:\n\n```\n$ sudo apt-get install libudev1\n$ sudo apt-get install libudev-dev\n$ sudo apt-get install libmount-dev\n$ sudo apt-get install libglib2.0-dev\n```\n\nNote: You may want to issue ```$ sudo apt-get update``` to make sure that you have access to latest packages via apt-get.\n\n### Install LDM\n```\n$ git clone git@github.com:LemonBoy/ldm.git\n$ cd ldm\n$ sudo make install\n```\n\nAdd LDM configuration file and configuration itself. Remember to change the ```your_own_user_name``` to valid username.\n```\n$ sudo touch /etc/ldm.conf\n$ echo 'MOUNT_OWNER=your_own_user_name' >> /etc/ldm.conf\n$ echo 'BASE_MOUNTPOINT=/mnt' >> /etc/ldm.conf\n```\n\n### Enable LDM\n```\n$ systemctl status ldm\n$ sudo systemctl enable ldm\n```\n\nNow you probably have to safely reboot to make sure changes will take place ```$sudo shutdown -r now (or sudo reboot)``` and enjoy more stable ```mbed-ls``` queries with your Raspberry Pi (Raspbian Jessie Lite).\n\n### Making sure LDM is active (running)\n\n```\n$ systemctl status ldm\n```\n```\nldm.service - lightweight device mounter\n  Loaded: loaded (/usr/lib/systemd/system/ldm.service; enabled)\n  Active: active (running) since Fri 2016-04-29 12:54:23 UTC; 48min ago\nMain PID: 389 (ldm)\n  CGroup: /system.slice/ldm.service\n          └─389 /usr/bin/ldm -u jenkins -p /mnt\n```\n\n# Known issues\n* Users reported issues while using ```mbed-ls``` on VM (Virtual Machines).\n* [mbedls fails to list devices on OS X El Capitan](https://github.com/ARMmbed/mbed-ls/issues/38).\n* ```mbed-ls``` doesn't list not mounted devices (Ubuntu/Linux).",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ARMmbed/mbed-ls",
    "keywords": null,
    "license": "Apache-2.0",
    "maintainer": null,
    "maintainer_email": null,
    "name": "mbed-ls",
    "package_url": "https://pypi.org/project/mbed-ls/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/mbed-ls/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/ARMmbed/mbed-ls"
    },
    "release_url": "https://pypi.org/project/mbed-ls/1.1.5/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "mbed-ls is a Python module that detects and lists mbed-enabled devices connected to the host computer",
    "version": "1.1.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16560431,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "86d60ae305ff2122fca6277a5227823c58a2add1c2d1e9dd121a8b044f71752d",
        "md5": "75a2c04bfca7dda8f92ae9b4a950600d",
        "sha256": "26c7cc60b4c160805a9c9a1eb881e97b2643b3f882acea348d314f0bad21f954"
      },
      "downloads": -1,
      "filename": "mbed-ls-1.1.5.zip",
      "has_sig": false,
      "md5_digest": "75a2c04bfca7dda8f92ae9b4a950600d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 71032,
      "upload_time": "2016-07-22T10:10:24",
      "upload_time_iso_8601": "2016-07-22T10:10:24.303201Z",
      "url": "https://files.pythonhosted.org/packages/86/d6/0ae305ff2122fca6277a5227823c58a2add1c2d1e9dd121a8b044f71752d/mbed-ls-1.1.5.zip",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}