{
  "info": {
    "author": "Andre Tocci",
    "author_email": "andre.tocci@dp6.com.br",
    "bugtrack_url": null,
    "classifiers": [
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Marketing Attribution Models\n\n## 1. Sobre a Classe\nClasse em Python desenvolvida para soluções de problemas de atribuição de mídia em Marketing Digital.\n\n## 2. Sobre Atribuição Multicanal\nNo contexto digital, antes de conversão, o usuário é impactado por diversos pontos de contato, podendo gerar jornadas cada vez mais longas e complexas. \n\n*Como atribuir os créditos das conversões e otimizar o investimento em mídia online?*\n\nPara resolver esse problema, utilizamos **Modelos de Atribuição**.\n\n\n### 2.1 Tipos de Modelos\n\n#### Modelos Heurísticos\n\n- **Last Interaction**:\n    - Modelo padrão de atribuição tanto do Google Analytics, quanto de ferramentas de mídia como Google Ads e Facebook Business manager;\n    - Atribui todo o resultado da conversão para o último ponto de contato.\n\n- **Last non-Direct Click**:\n    - Todo o tráfego direto é ignorado, e 100% do crédito da venda vai para o último canal por meio do qual o cliente chegou ao site antes de concluir a conversão.\n\n- **First Interaction**:\n    - Atribui todo o resultado da conversão para o primeiro ponto de contato.\n\n- **Linear**:\n    - Cada ponto de contato no caminho de conversão.\n\n- **Time Decay**:\n    - Os pontos de contato mais próximos em termos de tempo da venda ou conversão recebem a maior parte do crédito. \n\n- **Position Based**:\n    - No modelo de atribuição Com base na posição, 40% do crédito é atribuído a cada primeira e última interação, e os 20% de crédito restantes são distribuídos uniformemente para as interações intermediárias.\n\n\n#### Modelos Algorítmicos\n\n#### **Shapley Value**\n\nConceito vindo da Teoria dos Jogos, para distribuir a contribuição de cada jogador em um jogo de cooperação.\n\nAtribui os créditos das conversões calculando a contribuição de cada canal presente na jornada, utilizando permutações de jornadas com e sem o canal em questão.\n\n\n**Por exemplo**, como podemos atribuir as 19 conversões na jornada abaixo?\n\nNatural Search > Facebook > Direto > **$19** \n\n\nO Shapley Value de cada canal é calculado com base em observações, isto é, para cada jornada, é preciso ter o valores de conversão para todas as combinações que a compõe. \n\n\nNatural Search > **$7** <br/>\nFacebook > **$6** <br/>\nDireto > **$4** <br/>\nNatural Search > Facebook > **$15** <br/>\nNatural Search > Direto > **$7** <br/>\nFacebook > Direto > **$9** <br/>\nNatural Search > Facebook > Direto > **$19** <br/>\n\n\nO número de iterações aumenta exponencialmente com o número de canais: da ordem de 2^N, sendo N o número de canais.\n\nAssim, para uma jornada com 3 canais são necessárias 8 cálculos. **Para jornadas com mais de 15 canais, se torna praticamente inviável.**\n\n\nO Shapley Value por padrão não considera a ordem dos canais,mas sim a contribuição da presença dele na jornada.\nPara levar isso em consideração é preciso aumentar a ordem do numero de combinações. \n\nDisso vem a dificuldade em usar um método que considere a *ordem dos canais* para um grande número N, pois, além das 2^N interações para o cálculo do Shapley Value de um determinado canal i, **precisamos da *observação* do canal i em todas as possíveis posições.**\n\n\n**Pontos negativos do Shapley Value**\n- Limita o número de pontos de contato uma vez que o número de iteração é da ordem de 2^N;\n- Se não ordenado, o Shapley Value considera que a contribuição de um canal A é a mesma se antecedido por B ou por C;\n- Se ordenado, o número de combinações cresce muito e as jornadas devem estar disponíveis, caso contrário atribui-se zero àquela jornada;\n- Canais que estão poucos presentes ou presentes em jornadas longas vão ter pequenas contribuições;\n\n\n#### **Cadeias de Markov**\nUma cadeia de Markov é um caso particular de processo estocástico com a propriedade de que a distribuição de probabilidade do próximo estado depende apenas do estado atual e não na sequência de eventos que o precederam.\n\n\nUtilizando cadeias de markov no contexto de atribuição multicanal, podemos calcular a probalidade de interações entre os canais de mídia por meio da **Matriz de Transição**.\n\n\nPara encontrar a contribuição de cada canal, utilizamos o **Removal Effect**: remove-se o canal em questão da jornada e calcula-se a probabilidade de conversão.\n\nA atribuição é dada pela razão entre a diferença da probabilidade total de conversão e a probabilidade de conversão sem o canal, e a probabilidade total de conversão original.\n\nQuanto maior o removal effect, maior a contribuição do canal para a conversão.\n\n\n**Os processos markovianos não possuem nenhum tipo de restrição em relação a quantidade ou ordem dos canais e\nconsidera a sequência de canais como uma parte fundamental do algoritmo**.\n\n\n### 2.2 Referências\n- [Attribution Models in Marketing](https://data-science-blog.com/blog/2019/04/18/attribution-models-in-marketing/)\n- [Attribution Theory: The Two Best Models for Algorithmic Marketing Attribution – Implemented in Apache Spark and R](http://datafeedtoolbox.com/attribution-theory-the-two-best-models-for-algorithmic-marketing-attribution-implemented-in-apache-spark-and-r/)\n- [Game Theory Attribution: The Model You’ve Probably Never Heard Of](https://clearcode.cc/blog/game-theory-attribution/)\n- [Marketing Channel Attribution With Markov Models In R](https://www.bounteous.com/insights/2016/06/30/marketing-channel-attribution-markov-models-r/?ns=l)\n- [Multi-Channel Funnels Data-Driven Attribution](https://support.google.com/analytics/topic/3180362?hl=en&ref_topic=3205717)\n- [Marketing Multi-Channel Attribution model with R (part 1: Markov chains concept)](https://analyzecore.com/2016/08/03/attribution-model-r-part-1/)\n- [Marketing Multi-Channel Attribution model with R (part 2: practical issues)](https://analyzecore.com/2017/05/31/marketing-multi-channel-attribution-model-r-part-2-practical-issues/)\n- [ml-book/shapley](https://christophm.github.io/interpretable-ml-book/shapley.html)\n- [Overview of Attribution modeling in MCF](https://support.google.com/analytics/answer/1662518?hl=en)\n\n## 3. Importando a Classe\n\n\n```python\n>> pip install marketing_attribution_models\n```\n\n\n```python\nfrom marketing_attribution_models import MAM\n```\n\n## 4. Demonstração\n\n### **Criando o objeto MAM**\n\n**A criação do objeto MAM** é baseado em **dois formatos de Data Frame** e que é guiado pelo parâmetro group_channels:\n\n*   **group_channels = True**. Espera-se receber uma base na qual **cada linha seria uma sessão da jornada do usuário**.\n  * Esse data frame deve conter colunas representando ID do Usuário, indicação booleana se houve ou não transação durante a sessão, timestamp da sessão e o canal na qual o usuário gerou a sessão;\n*   **group_channels = False**. Recebe a base na qual a **jornada já foi agrupada** e que cada linha representa uma jornada completa de determinado usuário até a conversão. Para os usuários do Google Analytics, essa base pode ser gerada através da exportação do relatório de Top Conversion Paths na aba de Conversions.\n  * Nesse caso a coluna de canais e time_till_conv_colname receberiam em cada linha uma jornada separada por um separador, ' > ' como padrão e que pode ser alterado no parâmetro path_separator.\n\nNo nosso caso, iremos apresentar um exemplo na qual as jornadas ainda não estão agrupadas, que cada linha representa uma jornada e que ainda não temos um ID de Cada Jornada.\n\n**Ponto de Atenção:**\nA classe já contempla uma função representada pelo parâmetro create_journey_id_based_on_conversion, que caso seja True, será criado um ID da Jornada baseado nas colunas de ID do Usuário, passada no parâmetro group_channels_id_list e a coluna que representa se houve ou não conversão, passada no parâmetro journey_with_conv_colname.\n\nNesse caso, serão ordenadas as sessões de cada usuário e a cada transação será criado um novo ID da Jornada. Entretanto, **encorajamos que seja criado um ID da Jornada com base no conhecimento de negócio de cada base explorada**. Podendo criar condições expecíficas de tempo para que haja uma quebra de jornada, como por explempo se identificado que a jornada média de determidado negócio dura 1 semana até a conversão, podemos adotar um critério que se determinado usuário não interagir com o site por uma semana, sua jornada será quebrada, pois pode haver uma quebra de interesse.\n\n\n\nExemplificando como seria a configuração dos parametros no cenário descrito acima com group_channels = True. \n\n1. Deve ser passado o **Pandas Data Frame** contendo a base de dados a ser analisada;\n2. Indicar o formato da base em **group_channels**=True\n3. Nome da coluna que contem os agrupamentos de canais em **channels_colname**;\n4. Coluna Booleana indicando se houve ou não conversão na sessão em **journey_with_conv_colname**;\n5. Lista contendo os nomes das colunas que representam o ID da Jornada, podendo ser uma combinação de colunas em **group_channels_by_id_list**. Mas nesse caso como estamos indicando que iremos criar um ID da Jornada no parâmetro **create_journey_id_based_on_conversion = True**, basta indicar a coluna de ID do Usuário; \n6. Coluna representando a data em que ocorreu a sessão em **group_timestamp_colname**. Coluna que pode receber além dos dias do ano, o horário em que a sessão ocorreu;\n7. Por fim, em nosso caso, indicamos que iremos gerar um ID da Jornada a partir das colunas indicadas nos parâmetros group_channels_by_id_list e journey_with_conv_colname, em **create_journey_id_based_on_conversion** = True\n\n\n\n```python\nattributions = MAM(df,\n    group_channels=True,\n    channels_colname = 'channels',\n    journey_with_conv_colname= 'has_transaction',\n    group_channels_by_id_list=['user_id'],\n    group_timestamp_colname = 'visitStartTime',\n    create_journey_id_based_on_conversion = True)\n```\n\nPara fins exploratórios e de aprendizado, implementamos uma forma de gerar uma **base de dados aleatória** através do parâmetro **random_df=True**. Não sendo necessário o preenchimento dos demais.\n\n\n```python\nattributions = MAM(random_df=True)\n```\n\nAssim que o objeto foi criado, podemos checar como ficou a **base após a criação do journey_id e o agrupamento das sessões** em joranadas através do **atributo .DataFrame.**\n\n\n```python\nattributions.DataFrame\n```\n|  | journey_id | channels_agg | time_till_conv_agg | converted_agg | conversion_value |\n| - | - | - | - | - | - |\n| 0 | id:0_J:0 | Facebook | 0.0 | True | 1 |\n| 1 | id:0_J:1 | Google Search | 0.0 | True | 1 |\n| 2 | id:0_J:10 | Google Search > Organic > Email Marketing | 72.0 > 24.0 > 0.0 | True | 1 |\n| 3 | id:0_J:11 | Organic | 0.0 | True | 1 |\n| 4 | id:0_J:12 | Email Marketing > Facebook | 432.0 > 0.0 | True | 1 |\n| ... | ... | ... | ... | ... | ... |\n| 20341 | id:9_J:5 | Direct > Facebook | 120.0 > 0.0 | True | 1 |\n| 20342 | id:9_J:6 | Google Search > Google Search > Google Search | 48.0 > 24.0 > 0.0 | True | 1 |\n| 20343 | id:9_J:7 | Organic > Organic > Google Search > Google Search | 480.0 > 480.0 > 288.0 > 0.0 | True | 1 |\n| 20344 | id:9_J:8 | Direct > Organic | 168.0 > 0.0 | True | 1 |\n| 20345 | id:9_J:9 | Google Search > Organic > Google Search > Emai... | 528.0 > 528.0 > 408.0 > 240.0 > 0.0 | True | 1 |\n\nEsse **atributo é atualizado para cada modelo gerado** e nos casos dos resultados heurísticos, será adicionado uma coluna contendo a atribuição dada por determinado modelo no final.\n\n**Atenção:**\nOs cálculos dos modelos não são calculados com base no parâmetro .DataFrame, caso ele seja alterado, os resultados não serão afetados.\n\n\n```python\nattributions.attribution_last_click()\nattributions.DataFrame\n```\n\n| | journey_id | channels_agg | time_till_conv_agg | converted_agg | conversion_value |\n| - | - | - | - | - | - |\n| 0 | id:0_J:0 | Facebook | 0.0 | True | 1 |\n| 1 | id:0_J:1 | Google Search | 0.0 | True | 1 |\n| 2 | id:0_J:10 | Google Search > Organic > Email Marketing | 72.0 > 24.0 > 0.0 | True | 1 |\n| 3 | id:0_J:11 | Organic | 0.0 | True | 1 |\n| 4 | id:0_J:12 | Email Marketing > Facebook | 432.0 > 0.0 | True | 1 |\n| ... | ... | ... | ... | ... | ... |\n| 20341 | id:9_J:5 | Direct > Facebook | 120.0 > 0.0 | True | 1 |\n| 20342 | id:9_J:6 | Google Search > Google Search > Google Search | 48.0 > 24.0 > 0.0 | True | 1 |\n| 20343 | id:9_J:7 | Organic > Organic > Google Search > Google Search | 480.0 > 480.0 > 288.0 > 0.0 | True | 1 |\n| 20344 | id:9_J:8 | Direct > Organic | 168.0 > 0.0 | True | 1 |\n| 20345 | id:9_J:9 | Google Search > Organic > Google Search > Emai... | 528.0 > 528.0 > 408.0 > 240.0 > 0.0 | True | 1 |\n\n\nComo trabalhamos com um grande volume de dados, sabemos que não é possivel avaliar os resultados atribuídos para cada jornada que resultou em uma transação. Assim, através da consulta do **atributo group_by_channels_models trazemos os resultados dos modelos agrupados por cada canal**. \n\n**Atenção:**\nOs resultados agrupados não se sobrescrevem caso o mesmo modelo seja calculado mais de uma vez e ambos resultados estarão presentes no atributo group_by_channels_models.\n\n\n```python\nattributions.group_by_channels_models\n```\n\n\n\n\n<div>\n\n| channels | attribution_last_click_heuristic |\n| -- | -- |\n| Direct | 2133 |\n| Email Marketing | 1033 |\n| Facebook | 3168 |\n| Google Display | 1073 |\n| Google Search | 4255 |\n| Instagram | 1028 |\n| Organic | 6322 |\n| Youtube | 1093 |\n\n\n\nE como acontece com o .DataFrame, o **group_by_channels_models também é atualizado para cada novo modelo rodado** e sem a limitação de não trazer os resultados algorítimicos\n\n\n```python\nattributions.attribution_shapley()\nattributions.group_by_channels_models\n```\n\n| | channels | attribution_last_click_heuristic | attribution_shapley_size4_conv_rate_algorithmic |\n| - | - | - | - |\n| 0 | Direct | 109 | 74.926849 |\n| 1 | Email Marketing | 54 | 70.558428 |\n| 2 | Facebook | 160 | 160.628945 |\n| 3 | Google Display | 65 | 110.649352 |\n| 4 | Google Search | 193 | 202.179519 |\n| 5 | Instagram | 64 | 72.982433 |\n| 6 | Organic | 315 | 265.768549 |\n| 7 | Youtube | 58 | 60.305925 |\n\n### **Sobre os modelos**\n\nTodos os modelos heurísticos apresentam o mesmo comportamento quanto à atualização dos **atributos .DataFrame e .group_by_channels_models** e também quanto ao **output do método** que irá retornar uma **tupla contendo dois pandas Series**.\n\n\n```python\nattribution_first_click = attributions.attribution_first_click()\n```\n\n**O primeiro output** da tupla corresponde aos resultados na **granularidade de jornada**, similar ao resultado encontrado no .DataFrame\n\n\n```python\nattribution_first_click[0]\n```\n\n\n\n\n    0                          [1, 0, 0, 0, 0]\n    1                                      [1]\n    2              [1, 0, 0, 0, 0, 0, 0, 0, 0]\n    3                                   [1, 0]\n    4                                      [1]\n                           ...                \n    20512                               [1, 0]\n    20513                            [1, 0, 0]\n    20514    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    20515                            [1, 0, 0]\n    20516                         [1, 0, 0, 0]\n    Length: 20517, dtype: object\n\n\n\n**Já o segundo** corresponde aos resultados na **granularidade de canal**, similar ao resultado encontrado no .DataFrame\n\n\n```python\nattribution_first_click[1]\n```\n\n|  | channels | attribution_first_click_heuristic |\n| - | - | - |\n| 0 | Direct | 2078 |\n| 1 | Email Marketing | 1095 |\n| 2 | Facebook | 3177 |\n| 3 | Google Display | 1066 |\n| 4 | Google Search | 4259 |\n| 5 | Instagram | 1007 |\n| 6 | Organic | 6361 |\n| 7 | Youtube | 1062 |\n\n#### **Customização dos modelos**\n\nDentre os modelos presentes na classe apenas o Last Click, o First Click e Linear não possuem parametros customizáveis além do **parametro group_by_channels_models**, que recebe um **valor booleano** e que caso **falso**, **não irá retornar os resultados dos modelos agrupados por canais**.\n\n##### **Modelo Last Click Non** \n\nFoi criado para replicar o comportamento padrão do Google Analytics na qual o **tráfego Direto é sobreposto** caso ocorra após alguma interação de outra origem dentro de determinado período.\n\nPor padrão o parâmetro but_not_this_channel recebe o valor 'Direct', mas pode ser alterado para outros canais / valores de acordo com os seus canais e agrupamentos.\n\n\n\n\n```python\nattributions.attribution_last_click_non(but_not_this_channel='Direct')[1]\n```\n\n| channels | attribution_last_click_non_Direct_heuristic |\n| - | - | - |\n| 0 | Direct | 11 |\n| 1 | Email Marketing | 60 |\n| 2 | Facebook | 172 |\n| 3 | Google Display | 69 |\n| 4 | Google Search | 224 |\n| 5 | Instagram | 67 |\n| 6 | Organic | 350 |\n| 7 | Youtube | 65 |\n\n##### **Modelo Position Based** \n\nPode receber uma lista no parâmetro **list_positions_first_middle_last** determinando os percentuais que serão atribuídos para o ínicio, meio e fim da jornada de acordo com o contexto de negócio do seu cliente/dado. E que **por padrão** é distribuído com os percentuáis **40% para o canal introdutor, 20% distribuído para os canais intermediários e 40% para o conversor.**\n\n\n```python\nattributions.attribution_position_based(list_positions_first_middle_last=[0.3, 0.3, 0.4])[1]\n```\n\n|  | channels | attribution_position_based_0.3_0.3_0.4_heuristic |\n| - | - | - |\n| 0 | Direct | 95.685085 |\n| 1 | Email Marketing | 57.617191 |\n| 2 | Facebook | 145.817501 |\n| 3 | Google Display | 56.340693 |\n| 4 | Google Search | 193.282305 |\n| 5 | Instagram | 54.678557 |\n| 6 | Organic | 288.148896 |\n| 7 | Youtube | 55.629772 |\n\n##### **Modelo Time Decay** \n\nPode ser curtomizado quanto ao **percentual de decaimento** no parâmetro **decay_over_time** e quanto ao **tempo em horas na qual esse percentual será aplicado** no parâmetro **frequency**.\n\nContudo, vale salientar que caso haja mais pontos de contato entre os espaços de tempo do decaimento, o valor será distribuído igualmente para esses canais;\n\nExemplo de funcionamento do modelo:\n- **Canais:** Facebook > Organic > Paid Search\n- **Tempo até a Conversão:** 14 > 12 > 0\n- **Frequência do decaimento:** 7\n- **Resultados atribuídos:**\n  - 25% para Facebook;\n  - 25% para Organic;\n  - 50% para Paid Search;\n\n\n\n```python\nattributions.attribution_time_decay(\n    decay_over_time=0.6,\n    frequency=7)[1]\n```\n\n|  | channels | attribution_time_decay0.6_freq7_heuristic |\n| - | - | - |\n| 0 | Direct | 108.679538 |\n| 1 | Email Marketing | 54.425914 |\n| 2 | Facebook | 159.592216 |\n| 3 | Google Display | 64.350107 |\n| 4 | Google Search | 192.838884 |\n| 5 | Instagram | 64.611414 |\n| 6 | Organic | 314.920082 |\n| 7 | Youtube | 58.581845 |\n\n##### **Markov Chains**\n\n**Modelo de Atribuição** baseado em **Cadeias de Markov** nos auxilia a solucionar o problema de atribuição de mídia com uma **abordagem algorítimica** baseada em dados que calcula a probabilidade de transição entre canais.\n\nEsse modelo se comporta como os demais quanto a atualização do .DataFrame e do .group_by_channels_models, além de **retornar uma tupla** com os dois primeiros resultados representando os mesmos descritos anteriormente nos modelos heurísticos. Contudo, obtemos dois outputs, a **matriz de transição** e o **removal effect**.\n\nComo parâmetro de entrada temos, a princípio, como indicar se irá ser considerado ou não a probabilidade de transição para o mesmo estado.\n\n\n```python\nattribution_markov = attributions.attribution_markov(transition_to_same_state=False)\n```\n\n|  | channels | attribution_markov_algorithmic |\n| - | - | - |\n| 0 | Direct | 2305.324362 |\n| 1 | Email Marketing | 1237.400774 |\n| 2 | Facebook | 3273.918832 |\n| 3 | Youtube | 1231.183938 |\n| 4 | Google Search | 4035.260685 |\n| 5 | Instagram | 1205.949095 |\n| 6 | Organic | 5358.270644 |\n| 7 | Google Display | 1213.691671 |\n\nEssa configuração **não afeta os resultados agregados** e que são atribuídos para cada canal, **mas sim os valores observados na matriz de transição**. E como inficamos **transition_to_same_state=False** a linha diagonal, que representa a auto-transição, aparece zerada.\n\n\n```python\nax, fig = plt.subplots(figsize=(15,10))\nsns.heatmap(attribution_markov[2].round(3), cmap=\"YlGnBu\", annot=True, linewidths=.5)\n```\n\n\n\n\n![png](https://raw.githubusercontent.com/DP6/Marketing-Attribution-Models/master/readme-images/output_37_1.png)\n\n\n**Removal Effect**, quarto output dos resultados attribution_markov, é dada pela razão entre a diferença da probabilidade total de conversão e a probabilidade de conversão sem o canal, e a probabilidade total de conversão original.\n\n\n```python\nax, fig = plt.subplots(figsize=(2,5))\nsns.heatmap(attribution_markov[3].round(3), cmap=\"YlGnBu\", annot=True, linewidths=.5)\n```\n\n\n\n\n![png](https://raw.githubusercontent.com/DP6/Marketing-Attribution-Models/master/readme-images/output_39_1.png)\n\n\n##### **Shapley Value**\n\nPor fim, temos o segundo modelo algorítmico da classe MAM o **Shapley Value**, conceito vindo da **Teoria dos Jogos**, para distribuir a contribuição de cada jogador em um jogo de cooperação.\n\nModelo atribui os créditos das conversões calculando a contribuição de cada canal presente na jornada, utilizando combinações de jornadas com e sem o canal em questão. \n\nParâmetro **size limita quantidade de canais únicos na jornada**, por **padrão** é definido como os **4 últimos**. Isso ocorre pois o número de iterações aumenta exponencialmente com o número de canais. Da ordem de 2N, sendo N o número de canais.   \n\nA metodologia do cálculo das contribuições marginais pode variar através do **parâmetro order**, que por padrão calcula a contribuição da **combinação dos canais independende da ordem em que aparecem** nas diferentes jornadas.\n\n\n\n```python\nattributions.attribution_shapley(size=4, order=True, values_col='conv_rate')[0]\n```\n\n|  | combinations | conversions | total_sequences | conversion_value | conv_rate | attribution_shapley_size4_conv_rate_order_algorithmic |\n| - | - | - | - | - | - | - |\n| 0 | Direct | 909 | 926 | 909 | 0.981641 | [909.0] |\n| 1 | Direct > Email Marketing | 27 | 28 | 27 | 0.964286 | [13.948270234099155, 13.051729765900845] |\n| 2 | Direct > Email Marketing > Facebook | 5 | 5 | 5 | 1.000000 | [1.6636366232390172, 1.5835883671498818, 1.752... |\n| 3 | Direct > Email Marketing > Facebook > Google D... | 1 | 1 | 1 | 1.000000 | [0.2563402919193473, 0.2345560799963515, 0.259... |\n| 4 | Direct > Email Marketing > Facebook > Google S... | 1 | 1 | 1 | 1.000000 | [0.2522517802130265, 0.2401286956930936, 0.255... |\n| ... | ... | ... | ... | ... | ... | ... |\n| 1278 | Youtube > Organic > Google Search > Google Dis... | 1 | 2 | 1 | 0.500000 | [0.2514214624662836, 0.24872101523605275, 0.24... |\n| 1279 | Youtube > Organic > Google Search > Instagram | 1 | 1 | 1 | 1.000000 | [0.2544401477637237, 0.2541071889956603, 0.253... |\n| 1280 | Youtube > Organic > Instagram | 4 | 4 | 4 | 1.000000 | [1.2757196742326997, 1.4712839059493295, 1.252... |\n| 1281 | Youtube > Organic > Instagram > Facebook | 1 | 1 | 1 | 1.000000 | [0.2357631944623868, 0.2610913781266248, 0.247... |\n| 1282 | Youtube > Organic > Instagram > Google Search | 3 | 3 | 3 | 1.000000 | [0.7223482210689489, 0.7769049003203142, 0.726... |\n\nPor fim, parâmetro na qual o Shapley Value será calculado pode ser alterado em **values_col**, que por padrão utiliza a **taxa de conversão** que é uma forma de **considerarmos as não conversões no cálculo do modelo**. Contudo, também podemos considerar no cálculo o total de conversões ou o valor gerados pelas conversões, como demostrado abaixo. \n\n\n```python\nattributions.attribution_shapley(size=3, order=False, values_col='conversions')[0]\n```\n\n|  | combinations | conversions | total_sequences | conversion_value | conv_rate | attribution_shapley_size3_conversions_algorithmic |\n| - | - | - | - | - | - | - |\n| 0 | Direct | 11 | 18 | 18 | 0.611111 | [11.0] |\n| 1 | Direct > Email Marketing | 4 | 5 | 5 | 0.800000 | [2.0, 2.0] |\n| 2 | Direct > Email Marketing > Google Search | 1 | 2 | 2 | 0.500000 | [-3.1666666666666665, -7.666666666666666, 11.8... |\n| 3 | Direct > Email Marketing > Organic | 4 | 6 | 6 | 0.666667 | [-7.833333333333333, -10.833333333333332, 22.6... |\n| 4 | Direct > Facebook | 3 | 4 | 4 | 0.750000 | [-8.5, 11.5] |\n| ... | ... | ... | ... | ... | ... | ... |\n| 75 | Instagram > Organic > Youtube | 46 | 123 | 123 | 0.373984 | [5.833333333333332, 34.33333333333333, 5.83333... |\n| 76 | Instagram > Youtube | 2 | 4 | 4 | 0.500000 | [2.0, 0.0] |\n| 77 | Organic | 64 | 92 | 92 | 0.695652 | [64.0] |\n| 78 | Organic > Youtube | 8 | 11 | 11 | 0.727273 | [30.5, -22.5] |\n| 79 | Youtube | 11 | 15 | 15 | 0.733333 | [11.0] |\n\n### Visualização\nE agora que temos os resultados atribuídos pelos diferentes modelos guardados em nosso objeto **.group_by_channels_models** de acordo com o nosso contexto de negócio podemos plotar um gráfico e comparar os resultados.\n\n\n```python\nattributions.plot()\n```\n\n\n\n![png](https://raw.githubusercontent.com/DP6/Marketing-Attribution-Models/master/readme-images/output_45_1.png)\n\n\nCaso queira selecionar apenas os modelos algorítimicos, podemos especifica-lo no **parâmetro model_type**.\n\n\n```python\nattributions.plot(model_type='algorithmic')\n```\n\n\n\n\n![png](https://raw.githubusercontent.com/DP6/Marketing-Attribution-Models/master/readme-images/output_47_1.png)\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/DP6/Marketing-Attribution-Models",
    "keywords": "",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "marketing-attribution-models",
    "package_url": "https://pypi.org/project/marketing-attribution-models/",
    "platform": "",
    "project_url": "https://pypi.org/project/marketing-attribution-models/",
    "project_urls": {
      "Homepage": "https://github.com/DP6/Marketing-Attribution-Models"
    },
    "release_url": "https://pypi.org/project/marketing-attribution-models/1.0.4/",
    "requires_dist": [
      "numpy",
      "pandas",
      "matplotlib",
      "seaborn"
    ],
    "requires_python": ">=3.5",
    "summary": "Metodos de atribuicao de midia",
    "version": "1.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14401024,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bb6a9b823906de4bee0f380a59a04ae4a2d2bc4a986bfc40147ba74b8ff8bb3d",
        "md5": "a2fb23bd5c069ae9d9b8fa356355874b",
        "sha256": "7ac02e20ca92d971e419ed922e583e205afadd998b07bc4f6c7f70bc93d23a47"
      },
      "downloads": -1,
      "filename": "marketing_attribution_models-1.0.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a2fb23bd5c069ae9d9b8fa356355874b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.5",
      "size": 20101,
      "upload_time": "2020-02-10T11:33:26",
      "upload_time_iso_8601": "2020-02-10T11:33:26.081048Z",
      "url": "https://files.pythonhosted.org/packages/bb/6a/9b823906de4bee0f380a59a04ae4a2d2bc4a986bfc40147ba74b8ff8bb3d/marketing_attribution_models-1.0.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d2efeb1887be6637c641b970324a4e4e39ba14408db791cc6d3c3cf0908800c8",
        "md5": "03df57959632fe722d634b7f42cbd97b",
        "sha256": "e91f1fa57e84c5840dd3102ef29549300771314be8254080f2a6b1958f322942"
      },
      "downloads": -1,
      "filename": "marketing_attribution_models-1.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "03df57959632fe722d634b7f42cbd97b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 160021,
      "upload_time": "2020-02-10T11:33:28",
      "upload_time_iso_8601": "2020-02-10T11:33:28.590763Z",
      "url": "https://files.pythonhosted.org/packages/d2/ef/eb1887be6637c641b970324a4e4e39ba14408db791cc6d3c3cf0908800c8/marketing_attribution_models-1.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}