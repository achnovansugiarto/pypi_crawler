{
  "info": {
    "author": "Boris Serebrov",
    "author_email": "dynamo_objects@googlegroups.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.5",
      "Topic :: Database"
    ],
    "description": "================================\ndynamo_objects\n================================\n\n.. image:: https://travis-ci.org/serebrov/dynamo_objects.png?branch=master\n    :target: https://travis-ci.org/serebrov/dynamo_objects\n.. image:: https://coveralls.io/repos/serebrov/dynamo_objects/badge.svg?branch=master&service=github \n    :target: https://coveralls.io/github/serebrov/dynamo_objects?branch=master\n.. image:: https://img.shields.io/pypi/v/dynamo-objects.svg\n    :target: https://pypi.python.org/pypi/dynamo-objects/\n.. image:: https://img.shields.io/pypi/dm/dynamo-objects.svg\n    :target: https://pypi.python.org/pypi/dynamo-objects/\n\ndynamo_objects is a set of tools to work with DynamoDB in python.\n\nIt is based on `boto <http://boto.readthedocs.org/en/latest/ref/dynamodb2.html>`_ and provides following features:\n\n* a simple object mapper - use object notation to work with dynamo records\n* new tables are automatically created in the database, so you just write \n  and deploy the new code\n* transparent support for table prefixes (multiple databases or multiple environments), you don't need to handle table prefixes in code, just set the prefix during the database connection\n* simple in-memory dynamodb mock for fast unit tests\n* supports `DynamoDB local <https://aws.amazon.com/blogs/aws/dynamodb-local-for-desktop-development/>`_ for slower tests\n* in-memory cached tables to speedup computational operations on top of DynamoDB - all data is read only once and then results are flushed back in a batch\n* additional tools - copy data from table to table, a context manager to update table throughputs and set back once operation is completed\n\n`Discussion group <https://groups.google.com/forum/#!forum/dynamo_objects>`_\n\n================================\nInstallation\n================================\n\n.. code-block:: bash\n\n    $ pip install dynamo_objects\n\n\n================================\nDB Connection and Table Prefixes\n================================\n\nDatabase connection method adds table prefix support on top of boto's connect_to_region method.\nUsing the table prefix it is possible to switch the application to different set of tables for different environments (or just use different prefixes for different applications).\n\nUse the following snippet to connect to the database:\n\n.. code-block:: python\n\n    from dynamo_objects import DynamoDatabase\n\n    DynamoDatabase().connect(\n        region_name='your-aws-region-name-here',\n        aws_access_key_id='access-key-id',\n        aws_secret_access_key='secret-access-key',\n        table_prefix='my_prefix_')\n\nRegion name, and aws credentials are passed to the boto's connect_to_region method, so you can use other ways `suppored by boto <http://boto.readthedocs.org/en/latest/boto_config_tut.html#credentials>`_ to specify aws credentials.\nFor example, it is not necessary to specify access key id and secret if you use IAM role.\n\nThe :code:`table_prefix` parameter is used to prefix all the table names with the string you specify.\n\nLike if you set the table_prefix to :code:`staging_`, the application will use tables like :code:`staging_user` and :code:`staging_post`. And if you set the prefix to :code:`dev_` then application will use :code:`dev_user`, :code:`dev_post`.\n\nIf you leave the table_prefix empty then it will be just :code:`user` and :code:`post`.\nThis way you can easily switch your application from one set of tables to another for different environments (development, staging, production).\n\nTo connect to the DynamoDB Local, specify the region_name='localhost':\n\n.. code-block:: python\n\n    from dynamo_objects import DynamoDatabase\n    DynamoDatabase().connect(\n        region_name='localhost',\n        table_prefix='dev_'\n    )\n\n================================\nObject Mapper\n================================\n\nTo use the object mapper, define record and table objects for each DynamoDB table:\n\n.. code-block:: python\n\n  from boto.dynamodb2.fields import HashKey, RangeKey\n  from dynamo_objects import DynamoRecord, DynamoTable\n\n  class Store(DynamoRecord):\n\n      def __init__(self, **data):\n          # define table fields in the __init__ method\n          self.store_id = ''\n          self.name = ''\n          self.tags = []\n          super(Store, self).__init__(**data)\n\n\n  class StoreTable(DynamoTable):\n\n      def __init__(self):\n          super(self.__class__, self).__init__(\n              'store',\n              schema=[HashKey('store_id')],\n              throughput={'read': 3, 'write': 3},\n              record_class=Store)\n\nHere the :code:`StoreTable` class describes the table: table name, schema (hash and optionally range keys), throughput and record class.\n\nAnd the :code:`Store` class describes the table row, \nin the :code:`__init__` method we put all the table fields.\n\nSee more examples of table/record objects in the `tests/schema.py <https://github.com/dynamo_objects/blob/master/tests/schema.py>`_ file.\n\nNow the record object can be created and used like this:\n\n.. code-block:: python\n\n    store = StoreTable()\n    store = Store()\n    store.name = 'My Store'\n    table.save(store)\n\n    # or initialize the fields using the constructor\n    store2 = Store(name='My Store 2')\n    # change the name\n    store2.name = 'Another Store'\n    StoreTable().save(store)\n\nCompare this to the pure boto code where you have a dictionary-like interface:\n\n.. code-block:: python\n\n    store = Item(stores, data={\n       name='My Store'\n    })\n    # ....\n    store['nmae'] = 'Another Store'\n\nIf you mistype the field name like in :code:`store['nmae']` there will be no error - you will just create a new field in the database.\nThe main purpose of the object mapper is to prevent this. \n\nThe :code:`DynamoRecord` object will raise an exception if you mistype the field name.\nTo actually go schema-less, it is possible to override the :code:`_freeze_schema` method with :code:`pass` in the method body.\n\nYou can also override the :code:`_check_data` method to do additional transformations before saving to the database (like convert data types or normalize/unify data format).\n\nFind a record, update it and save:\n\n.. code-block:: python\n\n    table = MyTable()\n    # will raise ItemNotFound exception if record does not exist\n    record = table.get('my_hash', 'my_range')\n    record.some_field = 100\n    table.save(record)\n\n    # to handle the case when there is no record int the database use\n    # try/except\n    from boto.dynamodb2.exceptions import ItemNotFound\n    try:\n        record = table.get('my_hash', 'my_range')\n    except ItemNotFound:\n        # handle the record not found case\n        # ...\n\n    # sometimes it is more convenient to get None for non-existing record\n    # `find` method will return None if record does not exist\n    record = table.find('my_hash', 'my_range')\n    if record is not None:\n        record.some_field = 100\n        table.save(record)\n\n    # get a record or create new one if record does not exist\n    record = table.get('my_hash', 'my_range', create=True)\n    record.some_field = 200\n    table.save(record)\n\n    # delete the existing record\n    # `delete` method will return the deleted record, so the record data can be\n    # used for some additional actions like logging\n    record = table.delete('hash', 'range')\n\nThe :code:`create=True` option for the :code:`table.get()` method is useful when you want to read the data from the database or get the Null object if data is not found.\nFor example:\n\n.. code-block:: python\n\n    class User(DynamoRecord):\n\n      def __init__(self, *data):\n         self.name = 'guest'\n         self.password = ''\n         super(User, self).__init__(**data)\n\n    # Find the user in the database, if not found - the `user` object \n    # will represent guest user\n    user = table.get(user_id, create=True)\n    # print user name or 'guest' (default)\n    print user.name\n\nQuery and scan methods have the same interface as boto's `query_2 <http://boto.readthedocs.org/en/latest/ref/dynamodb2.html#boto.dynamodb2.table.Table.query_2>`_ and `scan <http://boto.readthedocs.org/en/latest/ref/dynamodb2.html#boto.dynamodb2.table.Table.scan>`_, but will convert the resulting record set into :code:`DynamoRecord` objects.\n\n.. code-block:: python\n\n    # parameters are the same as for boto's query_2\n    # returns array of records\n    # don't use when you expect a lot of data, because it will\n    # fetch all the data from the database and convert to DynamoRecord\n    # before returning\n    records = table.query(hash__eq='value', range__gte=50)\n    ...\n    records = table.scan(some_field__gte=10)\n    ...\n    # get count\n    count = table.query_count(hash__eq='value', range__gte=50)\n\nTable object also supports the atomic counter update: \n\n.. code-block:: python\n\n    # increment the `counter_name` field by 2 for the \n    # item with hash key = `myhashkey`\n    table.update_counter('myhashkey', counter_name=2)\n\n    # decrement the `counter_name` field by 2 for the \n    # item with hash key = `myhashkey` and rangekey = 'myrange'\n    table.update_counter('myhashkey', 'myrange', counter_name=-2)\n\nAnd it is possible to use boto's objects directly:\n\n.. code-block:: python\n\n    table = MyTable()\n    # the boto Table object\n    boto_table = table.table\n    # ... \n\n    record = table.get('my_hash', 'my_range')\n    # the boto Item object\n    boto_item = record._item\n    # ... \n\n\n================================\nMemory tables\n================================\n\nMemory tables can be used to cache DynamoDB access in-memory.\nEvery record is only read once and no data is written until you call the :code:`save_data` or :code:`save_data_batch` method.\n\n.. code-block:: python\n\n  # StoreTable is a regular table definition, DynamoTable subclass\n  from myschema import StoreTable\n  from dynamo_objects.memorydb import MemoryTable\n\n  class StoreMemoryTable(MemoryTable):\n\n      def __init__(self):\n          super(StoreMemoryTable, self).__init__(StoreTable())\n\nHere we define a :code:`StoreMemoryTable` class for in-memory table which wraps the :code:`StoreTable` (a regular table definition).\nNow we can do this:\n\n\n.. code-block:: python\n\n    table = StoreMemoryTable()\n    # read records with store_id = 1 and store_id = 2\n    record = table.get(1)\n    record2 = table.get(2)\n    # data is not actually saved yet, no write db operations\n    table.save(record)\n    table.save(record2)\n    # ...\n    # read same records again - will fetch from memory, no db read operations\n    record = table.get(1)\n    record2 = table.get(2)\n    # ...\n    # data is not actually saved yet, no write db operations\n    table.save(record)\n    table.save(record2)\n    # Now we flush all the data back to DynamoDB\n    # the `save_data_batch` will use the `batch write` DynamoDB operation\n    table.save_data_batch()\n\nThis can be very useful if you do some computational operations and need to read / write a lot of small objects to the database.\nDepending on the data structure the used read / write throughput and the whole processing time can be noticeably reduced.\n\n================================\nTesting and DynamoDB Mock\n================================\n\nIt is possible to run unit tests using the real DynamoDB connection using the table prefixes feature: you can choose some special table prefix like :code:`xx_unit_tests_`. \nThis way you'll have a set of tables for your unit tests.\n\nBut this approach is not practical - tests will be slow and will consume the read/write operations (and this will cost money).\n\nAmazon provides a `DynamoDB emulator in java <https://aws.amazon.com/blogs/aws/dynamodb-local-for-desktop-development/>`_ but it is problematic to use it during development, because it is slow and consumes a lot of memory.\n\nThe solution is a simple in-memory `DynamoDB mock module <https://github.com/dynamo_objects/blob/master/dynamo_objects/dynamock.py>`_. \nIt is a fast, but very approximate dynamo emulation without permanent data storage.\n\nTo enable the mock, just import the :code:`dynamock` module:\n\n.. code-block:: python\n\n  from dynamo_objects import database\n  # once imported, the `dynamock` module will mock real DynamoDB\n  # operations and forward them to the simple implementation which \n  # keeps all the data in memory\n  from dynamo_objects import dynamock\n\nThere is an example of the mock usage in the `tests/base.py <https://github.com/dynamo_objects/blob/master/tests/base.py>`_ module.\n\nThis base test module can be used for any project to test parts of code which work with DynamoDB.\nYou can find examples of unit tests under the `tests <https://github.com/dynamo_objects/tree/master/tests/>`_ folder. The database schema is described in the `tests/schema.py <https://github.com/dynamo_objects/blob/master/tests/schema.py>`_.\n\nTo run all tests use :code:`nosetests` (install with :code:`pip install nose`):\n\n.. code-block:: bash\n\n    nosetests\n\nBy default it will use the in-memory `DynamoDB mock <https://github.com/dynamo_objects/blob/master/dynamo_objects/dynamock.py>`_. \nTo run tests against the  DynamoDB Local use following commands:\n\n.. code-block:: bash\n\n    # in the first terminal window launch the local dynamodb\n    # script will download it if necessary\n    ./tool/dynamodb-local.sh\n\n    # in another terminal window run the tests\n    DYNAMODB_MOCK= nosetests\n\nI use fast in-memory mock to run tests locally, during the development.\n\nOn the CI server tests a launched two times - first against the in-memory mock and then one more time against the DynamoDB local.\n\nHere is an example of the shell script to do this:\n\n.. code-block:: bash\n\n  # Run fast tests with in-memory mock\n  nosetests\n  RESULT_MOCK=$?\n  \n  # Run slow tests with DynamoDB local\n  pushd path/to/folder/with/dynamodb-local\n    java -Djava.library.path=./DynamoDBLocal_lib -jar ./DynamoDBLocal.jar -inMemory -sharedDb &\n    PID=$!\n  popd\n  echo \"Started local dynamodb: $PID\"\n  DYNAMODB_MOCK= nosetests\n  RESULT_LOCALDB=$?\n  kill -9 $PID\n  exit $(($RESULT_MOCK+$RESULT_LOCALDB))\n\n\n================================\nAdditional Tools\n================================\n\nThe `database <https://github.com/dynamo_objects/blob/master/dynamo_objects/database.py>`_ module contains few additional useful tools.\n\nThe :code:`copy_item` and :code:`copy_table_data` methods allow to copy data from table to table (for example, you may want to copy some data from staging to production):\n\n.. code-block:: python\n\n    db = database.Database()\n    # note: table_prefix is empty, so we can explicitly set table names\n    database.connect(\n        region_name='...', ...\n        table_prefix='')\n    num_copied = db.copy_table_data('table_name', 'staging_table_name')\n\n    # copy and transform data\n    def transform_fn(record):\n        record.name = 'staging_' + record.name\n    db.copy_table_data('table_name', 'staging_table_name', transform=transform_fn)\n\nThere are also some other useful methods to create the table, wait until the new table becomes active, delete the table, etc.\n\nThe :code:`TableThroughput` class is a context manager to update (usually set higher) throughput limits and put them back after some operation.\nIt is useful when you need to do something what requires a high read/write throughput. \n\nUsing the :code:`TableThroughput` it is possible to set high limits just before the operation and set them back just after it:\n\n.. code-block:: python\n\n        high_throughputs = {\n            'table_one': { 'table': { 'read': 100, 'write': 50, }, },\n            'table_two': {\n                'table': { 'read': 60, 'write': 120, },\n                'SomeGlobalIndex': { 'read': 1, 'write': 120 }\n            }\n        }\n\n        with database.TablesThroughput(high_throughputs):\n            # now throughputs are high\n            some_comutational_operation()\n        # now throughputs are low again (same as before the operation)\n\n\n================================\nRelated projects\n================================\n\n* `flywheel <https://github.com/mathcamp/flywheel>`_ - Object mapper for Amazon's DynamoDB\n* `PynamoDB <https://github.com/jlafon/PynamoDB>`_ - A pythonic interface to Amazon's DynamoDB\n* `Dynamodb-mapper <https://bitbucket.org/Ludia/dynamodb-mapper/overview>`_ Dynamodb-mapper - a DynamoDB object mapper, based on boto",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/serebrov/dynamo_objects",
    "keywords": "python dynamodb orm odm",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dynamo-objects",
    "package_url": "https://pypi.org/project/dynamo-objects/",
    "platform": "",
    "project_url": "https://pypi.org/project/dynamo-objects/",
    "project_urls": {
      "Homepage": "https://github.com/serebrov/dynamo_objects"
    },
    "release_url": "https://pypi.org/project/dynamo-objects/1.0.18/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Simple DynamoDB object mapper and utils",
    "version": "1.0.18",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 3990320,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "23f09e92559e3a5be2eb9e432be3812e086d495c1779b78bc57a4b666b496228",
        "md5": "b3fa9777310b9d64f6cda24c328bc121",
        "sha256": "f8f7b39d77e15f960869e76166b526edb32475b71683274c19d7e99aac335106"
      },
      "downloads": -1,
      "filename": "dynamo_objects-1.0.18.tar.gz",
      "has_sig": false,
      "md5_digest": "b3fa9777310b9d64f6cda24c328bc121",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 20988,
      "upload_time": "2018-06-22T19:33:32",
      "upload_time_iso_8601": "2018-06-22T19:33:32.475936Z",
      "url": "https://files.pythonhosted.org/packages/23/f0/9e92559e3a5be2eb9e432be3812e086d495c1779b78bc57a4b666b496228/dynamo_objects-1.0.18.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}