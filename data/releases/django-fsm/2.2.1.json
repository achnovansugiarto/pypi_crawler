{
  "info": {
    "author": "Mikhail Podgurskiy",
    "author_email": "kmmbvnr@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3"
    ],
    "description": "Django friendly finite state machine support\r\n============================================\r\n[![Build Status](https://travis-ci.org/kmmbvnr/django-fsm.svg?branch=master)](https://travis-ci.org/kmmbvnr/django-fsm)\r\n\r\ndjango-fsm adds declarative states management for django models.\r\n\r\nInstead of adding some state field to a django model, and managing its\r\nvalues by hand, you could use FSMState field and mark model methods\r\nwith the `transition` decorator. Your method could contain the side-effects\r\nof the state change.\r\n\r\nNice introduction is available here: https://gist.github.com/Nagyman/9502133\r\n\r\nYou may also take a look at django-fsm-admin project\r\ncontaining a mixin and template tags to integrate django-fsm\r\nstate transitions into the django admin.\r\n\r\nhttps://github.com/gadventures/django-fsm-admin\r\n\r\nTransition logging support could be achived with help of django-fsm-log package\r\n\r\nhttps://github.com/gizmag/django-fsm-log\r\n\r\nFSM really helps to structure the code, especially when a new\r\ndeveloper comes to the project.  FSM is most effective when you use it\r\nfor some sequential steps.\r\n\r\nIf you need parallel task execution, view and background task code reuse\r\nover different flows - check my new project django-viewflow\r\n\r\nhttps://github.com/kmmbvnr/django-viewflow\r\n\r\nInstallation\r\n------------\r\n```bash\r\n$ pip install django-fsm\r\n```\r\nOr, for the latest git version\r\n```bash\r\n$ pip install -e git://github.com/kmmbvnr/django-fsm.git#egg=django-fsm\r\n```\r\n\r\nThe library has full Python 3 support\r\n\r\n\r\nUsage\r\n-----\r\n\r\nAdd FSMState field to your model\r\n```python\r\nfrom django_fsm import FSMField, transition\r\n\r\nclass BlogPost(models.Model):\r\n\tstate = FSMField(default='new')\r\n```\r\n\r\nUse the `transition` decorator to annotate model methods\r\n```python\r\n@transition(field=state, source='new', target='published')\r\ndef publish(self):\r\n\t\"\"\"\r\n\tThis function may contain side-effects,\r\n\tlike updating caches, notifying users, etc.\r\n\tThe return value will be discarded.\r\n\t\"\"\"\r\n```\r\n\r\n`source` parameter accepts a list of states, or an individual state.\r\nYou can use `*` for source, to allow switching to `target` from any state.\r\n\r\nIf calling publish() succeeds without raising an exception, the state field\r\nwill be changed, but not written to the database.\r\n```python\r\nfrom django_fsm import can_proceed\r\n\r\ndef publish_view(request, post_id):\r\n    post = get_object__or_404(BlogPost, pk=post_id)\r\n    if not can_proceed(post.publish):\r\n        raise PermissionDenied\r\n\r\n    post.publish()\r\n    post.save()\r\n    return redirect('/')\r\n```\r\n\r\nIf some conditions are required to be met before changing the state, use the\r\n`conditions` argument to `transition`. `conditions` must be a list of functions\r\ntaking one argument, the model instance.  The function must return either\r\n`True` or `False` or a value that evaluates to `True` or `False`. If all functions\r\nreturn `True`, all conditions are considered to be met and the transition\r\nis allowed to happen. If one of the functions returns `False`, the transition\r\nwill not happen. These functions should not have any side effects.\r\n\r\nYou can use ordinary functions\r\n```python\r\ndef can_publish(instance):\r\n    # No publishing after 17 hours\r\n    if datetime.datetime.now().hour > 17:\r\n        return False\r\n    return True\r\n```\r\n\r\nOr model methods\r\n```python\r\ndef can_destroy(self):\r\n\treturn self.is_under_investigation()\r\n```\r\n\r\nUse the conditions like this:\r\n```python\r\n@transition(field=state, source='new', target='published', conditions=[can_publish])\r\n    def publish(self):\r\n    \"\"\"\r\n    Side effects galore\r\n    \"\"\"\r\n\r\n@transition(field=state, source='*', target='destroyed', conditions=[can_destroy])\r\n    def destroy(self):\r\n    \"\"\"\r\n    Side effects galore\r\n    \"\"\"\r\n```\r\n\r\nYou could instantiate a field with protected=True option, that prevents direct state field modification\r\n```python\r\nclass BlogPost(models.Model):\r\n    state = FSMField(default='new', protected=True)\r\n\r\nmodel = BlogPost()\r\nmodel.state = 'invalid' # Raises AttributeError\r\n```\r\n\r\n\r\n### `custom` properties\r\nCustom properties can be added by providing a dictionary to the `custom` keyword on the `transition` decorator.\r\n```python\r\n@transition(field=state,\r\n            source='*',\r\n            target='onhold',\r\n            custom=dict(verbose='Hold for legal reasons'), transition_type='manual')\r\ndef legal_hold(self):\r\n    \"\"\"\r\n    Side effects galore\r\n    \"\"\"\r\n```\r\n\r\n### `on_error` state\r\n\r\nIn case of transition method would raise exception, you can provide specific target state\r\n\r\n```python\r\n@transition(field=state, source='new', target='published', on_error='failed')\r\ndef publish(self):\r\n   \"\"\"\r\n   Some exceptio could happends here\r\n   \"\"\"\r\n```\r\n\r\n### `state_choices`\r\nInstead of passing two elements list `choices` you could use three elements `state_choices`,\r\nthe last element states for string reference to model proxy class.\r\n\r\nBase class instance would be dynamically changed to corresponding Proxy class instance, depending on the state.\r\nEven for queryset results, you will get Proxy class instances, even if QuerySet executed on base class.\r\n\r\nCheck the [test case](https://github.com/kmmbvnr/django-fsm/blob/master/tests/testapp/tests/test_state_transitions.py)\r\nfor example usage. Or read about [implementation internals](http://schinckel.net/2013/06/13/django-proxy-model-state-machine/)\r\n\r\n### Permissions\r\nIt is common to have permissions attached to each model transition. `django-fsm` handles this with\r\n`permission` keyword on the `transition` decorator. `permission` accepts a permission string, or\r\ncallable that expects `user` argument and returns True if user can perform the transition\r\n\r\n```python\r\n@transition(field=state, source='*', target='publish',\r\n            permission=lambda user: not user.has_perm('myapp.can_make_mistakes'))\r\ndef publish(self):\r\n    pass\r\n\r\n@transition(field=state, source='*', target='publish',\r\n            permission='myapp.can_remove_post')\r\ndef remove(self):\r\n    pass\r\n```\r\n\r\nYou can check permission with `has_transition_permission` method\r\n\r\n``` python\r\nfrom django_fsm import has_transition_perm\r\ndef publish_view(request, post_id):\r\n    post = get_object_or_404(BlogPost, pk=post_id)\r\n    if not has_transition_perm(post.publish, request.user):\r\n        raise PermissionDenied\r\n\r\n    post.publish()\r\n    post.save()\r\n    return redirect('/')\r\n```\r\n\r\n### Model methods\r\n\r\n`get_all_FIELD_transitions`\r\nEnumerates all declared transitions\r\n\r\n`get_available_FIELD_transitions`\r\nReturns all transitions data available in current state\r\n\r\n`get_available_user_FIELD_transitions`\r\nEnumerates all transitions data available in current state for provided user\r\n\r\n### Foreign Key constraints support\r\n\r\nIf you store the states in the db table you could use FSMKeyField to\r\nensure Foreign Key database integrity.\r\n\r\nIn your model :\r\n```python\r\nclass DbState(models.Model):\r\n    id = models.CharField(primary_key=True, max_length=50)\r\n    label = models.CharField(max_length=255)\r\n\r\n    def __unicode__(self):\r\n        return self.label\r\n\r\n\r\nclass BlogPost(models.Model):\r\n    state = FSMKeyField(DbState, default='new')\r\n\r\n    @transition(field=state, source='new', target='published')\r\n    def publish(self):\r\n        pass\r\n```\r\n\r\nIn your fixtures/initial_data.json :\r\n```json\r\n[\r\n    {\r\n        \"pk\": \"new\",\r\n        \"model\": \"myapp.dbstate\",\r\n        \"fields\": {\r\n            \"label\": \"_NEW_\"\r\n        }\r\n    },\r\n    {\r\n        \"pk\": \"published\",\r\n        \"model\": \"myapp.dbstate\",\r\n        \"fields\": {\r\n            \"label\": \"_PUBLISHED_\"\r\n        }\r\n    }\r\n]\r\n```\r\n\r\nNote : source and target parameters in @transition decorator use pk values of DBState model\r\nas names, even if field \"real\" name is used, without _id postfix, as field parameter.\r\n\r\n\r\n### Integer Field support\r\n\r\nYou can also use `FSMIntegerField`. This is handy when you want to use enum style constants.\r\n```python\r\nclass BlogPostStateEnum(object):\r\n    NEW = 10\r\n    PUBLISHED = 20\r\n    HIDDEN = 30\r\n\r\nclass BlogPostWithIntegerField(models.Model):\r\n    state = FSMIntegerField(default=BlogPostStateEnum.NEW)\r\n\r\n    @transition(field=state, source=BlogPostStateEnum.NEW, target=BlogPostStateEnum.PUBLISHED)\r\n    def publish(self):\r\n        pass\r\n```\r\n\r\n### Signals\r\n\r\n`django_fsm.signals.pre_transition` and `django_fsm.signals.post_transition` are called before\r\nand after allowed transition. No signals on invalid transition are called.\r\n\r\nArguments sent with these signals:\r\n\r\n**sender**\r\n   The model class.\r\n\r\n**instance**\r\n   The actual instance being procceed\r\n\r\n**name**\r\n   Transition name\r\n\r\n**source**\r\n   Source model state\r\n\r\n**target**\r\n   Target model state\r\n\r\n## Optimistic locking\r\n\r\n`django-fsm` provides optimistic locking mixin, to avoid concurent model state changes.\r\nIf model state was changed in database `django_fsm.ConcurrentTransition` exception would be raised\r\non model.save()\r\n\r\n```python\r\nfrom django_fsm import FMSField, ConcurrentTransitionMixin\r\n\r\nclass BlogPost(ConcurrentTransitionMixin, models.Model):\r\n    state = FSMField(default='new')\r\n```\r\n\r\nFor guaranteed protection against race conditions caused by concurrently executed transitions, make sure:\r\n* Your transitions do not have any side effects except for changes in the database,\r\n* You always run the save() method on the object within `django.db.transaction.atomic()` block.\r\n\r\nFollowing these recommendations, you can rely on ConcurrentTransitionMixin to cause a rollback of all the changes\r\nthat have been executed in an inconsistent (out of sync) state, thus practically negating their effect.\r\n\r\n## Drawing transitions\r\n\r\nRenders a graphical overview of your models states transitions\r\n\r\nYou need `pip install graphviz>=0.4` library\r\n\r\n```bash\r\n# Create a dot file\r\n$ ./manage.py graph_transitions > transitions.dot\r\n\r\n# Create a PNG image file only for specific model\r\n$ ./manage.py graph_transitions -o blog_transitions.png myapp.Blog\r\n```\r\n\r\nChangelog\r\n---------\r\n\r\n<img src=\"https://f.cloud.github.com/assets/41479/2227946/a9e77760-9ad0-11e3-804f-301d075470fe.png\" alt=\"django-fsm\" width=\"100px\"/>\r\n\r\n### django-fsm 2.2.1 2015-04-27\r\n* Improved exception message for unmet transition conditions.\r\n* Don't send post transiton signal in case of no state chnages on exception\r\n* Allow empty string as correct state value\r\n* Imporved graphviz fsm visualisation\r\n* Clean django 1.8 warnings\r\n\r\n\r\n### django-fsm 2.2.0 2014-09-03\r\n* Support for [class substitution](http://schinckel.net/2013/06/13/django-proxy-model-state-machine/) to proxy classes depending on the state\r\n* Added ConcurrentTransitionMixin with optimistic locking support\r\n* Default db_index=True for FSMIntegerField removed\r\n* Graph transition code migrated to new graphviz library with python 3 support\r\n* Ability to change state on transition exception\r\n\r\n### django-fsm 2.1.0 2014-05-15\r\n* Support for attaching permission checks on model transitions\r\n\r\n### django-fsm 2.0.0 2014-03-15\r\n* Backward incompatible release\r\n* All public code import moved directly to django_fsm package\r\n* Correct support for several @transitions decorator with different source states and conditions on same method\r\n* save parameter from transition decorator removed\r\n* get_available_FIELD_transitions return Transition data object instead of tuple\r\n* Models got get_available_FIELD_transitions, even if field specified as string reference\r\n* New get_all_FIELD_transitions method contributed to class\r\n\r\n### django-fsm 1.6.0 2014-03-15\r\n* FSMIntegerField and FSMKeyField support\r\n\r\n### django-fsm 1.5.1 2014-01-04\r\n\r\n* Ad-hoc support for state fields from proxy and inherited models\r\n\r\n### django-fsm 1.5.0 2013-09-17\r\n\r\n* Python 3 compatibility\r\n\r\n### django-fsm 1.4.0 2011-12-21\r\n\r\n* Add graph_transition command for drawing state transition picture\r\n\r\n### django-fsm 1.3.0 2011-07-28\r\n\r\n* Add direct field modification protection\r\n\r\n### django-fsm 1.2.0 2011-03-23\r\n\r\n* Add pre_transition and post_transition signals\r\n\r\n### django-fsm 1.1.0 2011-02-22\r\n\r\n* Add support for transition conditions\r\n* Allow multiple FSMField in one model\r\n* Contribute get_available_FIELD_transitions for model class\r\n\r\n### django-fsm 1.0.0 2010-10-12\r\n\r\n* Initial public release",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://github.com/kmmbvnr/django-fsm",
    "keywords": "django",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-fsm",
    "package_url": "https://pypi.org/project/django-fsm/",
    "platform": "any",
    "project_url": "https://pypi.org/project/django-fsm/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "http://github.com/kmmbvnr/django-fsm"
    },
    "release_url": "https://pypi.org/project/django-fsm/2.2.1/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Django friendly finite state machine support.",
    "version": "2.2.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14763537,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bbb06d49d266bdadac09e9b1a012845700ca567eb49cb044b46a70663692c817",
        "md5": "42c0a9a3a2f27925a3f5cd244665a6e0",
        "sha256": "70ee1cde7fbe4f62acd59027b5e9e782f7c77358b5e14aff9b539c0b4889ad19"
      },
      "downloads": -1,
      "filename": "django-fsm-2.2.1.tar.gz",
      "has_sig": false,
      "md5_digest": "42c0a9a3a2f27925a3f5cd244665a6e0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 7802,
      "upload_time": "2015-04-27T07:21:52",
      "upload_time_iso_8601": "2015-04-27T07:21:52.307309Z",
      "url": "https://files.pythonhosted.org/packages/bb/b0/6d49d266bdadac09e9b1a012845700ca567eb49cb044b46a70663692c817/django-fsm-2.2.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}