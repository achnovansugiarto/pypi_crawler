{
  "info": {
    "author": "Alexander Tikhonov",
    "author_email": "random.gauss@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# mashumaro (マシュマロ)\n\n> **mashumaro** is a fast and well tested serialization framework on top of dataclasses.\n\n[![Build Status](https://github.com/Fatal1ty/mashumaro/workflows/tests/badge.svg)](https://github.com/Fatal1ty/mashumaro/actions)\n[![Coverage Status](https://coveralls.io/repos/github/Fatal1ty/mashumaro/badge.svg?branch=master)](https://coveralls.io/github/Fatal1ty/mashumaro?branch=master)\n[![Latest Version](https://img.shields.io/pypi/v/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)\n[![Python Version](https://img.shields.io/pypi/pyversions/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n\n\nWhen using dataclasses, you often need to dump and load objects according to\nthe described scheme.\nThis framework not only adds this ability to serialize in different formats,\nbut also makes **serialization rapidly**.\n\nTable of contents\n--------------------------------------------------------------------------------\n* [Installation](#installation)\n* [Supported serialization formats](#supported-serialization-formats)\n* [Supported field types](#supported-field-types)\n* [Usage example](#usage-example)\n* [How does it work?](#how-does-it-work)\n* [API](#api)\n* [Customization](#customization)\n    * [User defined classes](#user-defined-classes)\n        * [Serializable Interface](#serializable-interface)\n        * [Serialization Strategy](#serialization-strategy)\n    * [Field options](#field-options)\n        * [`serialize` option](#serialize-option)\n        * [`deserialize` option](#deserialize-option)\n    * [Serialization hooks](#serialization-hooks)\n        * [Before deserialization](#before-deserialization)\n        * [After deserialization](#after-deserialization)\n        * [Before serialization](#before-serialization)\n        * [After serialization](#after-serialization)\n\nInstallation\n--------------------------------------------------------------------------------\n\nUse pip to install:\n```shell\n$ pip install mashumaro\n```\n\nSupported serialization formats\n--------------------------------------------------------------------------------\n\nThis framework adds methods for dumping to and loading from the\nfollowing formats:\n\n* plain dict\n* json\n* yaml\n* msgpack\n\nPlain dict can be useful when you need to pass a dict object to a\nthird-party library, such as a client for MongoDB.\n\nSupported field types\n--------------------------------------------------------------------------------\n\nThere is support for generic types from the standard *typing* module:\n* `List`\n* `Tuple`\n* `Set`\n* `FrozenSet`\n* `Deque`\n* `Dict`\n* `Mapping`\n* `MutableMapping`\n* `ChainMap`\n* `Sequence`\n\nfor special primitives from the *typing* module:\n* `Optional`\n* `Any`\n\nfor enumerations based on classes from the standard *enum* module:\n* `Enum`\n* `IntEnum`\n* `Flag`\n* `IntFlag`\n\nfor common built-in types:\n* `int`\n* `float`\n* `bool`\n* `str`\n* `bytes`\n* `bytearray`\n\nfor built-in datetime oriented types (see [more](#deserialize-option) details):\n* `datetime`\n* `date`\n* `time`\n* `timedelta`\n* `timezone`\n\nfor pathlike types:\n* `PurePath`\n* `Path`\n* `PurePosixPath`\n* `PosixPath`\n* `PureWindowsPath`\n* `WindowsPath`\n* `os.PathLike`\n\n\nfor other less popular built-in types:\n* `uuid.UUID`\n* `decimal.Decimal`\n* `fractions.Fraction`\n* `ipaddress.IPv4Address`\n* `ipaddress.IPv6Address`\n* `ipaddress.IPv4Network`\n* `ipaddress.IPv6Network`\n* `ipaddress.IPv4Interface`\n* `ipaddress.IPv6Interface`\n\nfor specific types like *NoneType*, nested dataclasses itself and\neven [user defined classes](#user-defined-classes).\n\nUsage example\n--------------------------------------------------------------------------------\n\n```python\nfrom enum import Enum\nfrom typing import Set\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassJSONMixin\n\nclass PetType(Enum):\n    CAT = 'CAT'\n    MOUSE = 'MOUSE'\n\n@dataclass(unsafe_hash=True)\nclass Pet(DataClassJSONMixin):\n    name: str\n    age: int\n    pet_type: PetType\n\n@dataclass\nclass Person(DataClassJSONMixin):\n    first_name: str\n    second_name: str\n    age: int\n    pets: Set[Pet]\n\n\ntom = Pet(name='Tom', age=5, pet_type=PetType.CAT)\njerry = Pet(name='Jerry', age=3, pet_type=PetType.MOUSE)\njohn = Person(first_name='John', second_name='Smith', age=18, pets={tom, jerry})\n\ndump = john.to_json()\nperson = Person.from_json(dump)\n# person == john\n\nPet.from_json('{\"name\": \"Tom\", \"age\": 5, \"pet_type\": \"CAT\"}')\n# Pet(name='Tom', age=5, pet_type=<PetType.CAT: 'CAT'>)\n```\n\nHow does it work?\n--------------------------------------------------------------------------------\n\nThis framework works by taking the schema of the data and generating a\nspecific parser and builder for exactly that schema.\nThis is much faster than inspection of field types on every call of parsing or\nbuilding at runtime.\n\nAPI\n--------------------------------------------------------------------------------\n\nMashumaro provides a couple of mixins for each format.\n\n#### `DataClassDictMixin.to_dict(use_bytes: bool, use_enum: bool, use_datetime: bool)`\n\nMake a dictionary from dataclass object based on the dataclass schema provided.\nOptions include:\n```python\nuse_bytes: False     # False - convert bytes/bytearray objects to base64 encoded string, True - keep untouched\nuse_enum: False      # False - convert enum objects to enum values, True - keep untouched\nuse_datetime: False  # False - convert datetime oriented objects to ISO 8601 formatted string, True - keep untouched\n```\n\n#### `DataClassDictMixin.from_dict(data: Mapping, use_bytes: bool, use_enum: bool, use_datetime: bool)`\n\nMake a new object from dict object based on the dataclass schema provided.\nOptions include:\n```python\nuse_bytes: False     # False - load bytes/bytearray objects from base64 encoded string, True - keep untouched\nuse_enum: False      # False - load enum objects from enum values, True - keep untouched\nuse_datetime: False  # False - load datetime oriented objects from ISO 8601 formatted string, True - keep untouched\n```\n\n#### `DataClassJSONMixin.to_json(encoder: Optional[Encoder], dict_params: Optional[Mapping], **encoder_kwargs)`\n\nMake a JSON formatted string from dataclass object based on the dataclass\nschema provided. Options include:\n```\nencoder        # function called for json encoding, defaults to json.dumps\ndict_params    # dictionary of parameter values passed underhood to `to_dict` function\nencoder_kwargs # keyword arguments for encoder function\n```\n\n#### `DataClassJSONMixin.from_json(data: Union[str, bytes, bytearray], decoder: Optional[Decoder], dict_params: Optional[Mapping], **decoder_kwargs)`\n\nMake a new object from JSON formatted string based on the dataclass schema\nprovided. Options include:\n```\ndecoder        # function called for json decoding, defaults to json.loads\ndict_params    # dictionary of parameter values passed underhood to `from_dict` function\ndecoder_kwargs # keyword arguments for decoder function\n```\n\n#### `DataClassMessagePackMixin.to_msgpack(encoder: Optional[Encoder], dict_params: Optional[Mapping], **encoder_kwargs)`\n\nMake a MessagePack formatted bytes object from dataclass object based on the\ndataclass schema provided. Options include:\n```\nencoder        # function called for MessagePack encoding, defaults to msgpack.packb\ndict_params    # dictionary of parameter values passed underhood to `to_dict` function\nencoder_kwargs # keyword arguments for encoder function\n```\n\n#### `DataClassMessagePackMixin.from_msgpack(data: Union[str, bytes, bytearray], decoder: Optional[Decoder], dict_params: Optional[Mapping], **decoder_kwargs)`\n\nMake a new object from MessagePack formatted data based on the\ndataclass schema provided. Options include:\n```\ndecoder        # function called for MessagePack decoding, defaults to msgpack.unpackb\ndict_params    # dictionary of parameter values passed underhood to `from_dict` function\ndecoder_kwargs # keyword arguments for decoder function\n```\n\n#### `DataClassYAMLMixin.to_yaml(encoder: Optional[Encoder], dict_params: Optional[Mapping], **encoder_kwargs)`\n\nMake an YAML formatted bytes object from dataclass object based on the\ndataclass schema provided. Options include:\n```\nencoder        # function called for YAML encoding, defaults to yaml.dump\ndict_params    # dictionary of parameter values passed underhood to `to_dict` function\nencoder_kwargs # keyword arguments for encoder function\n```\n\n#### `DataClassYAMLMixin.from_yaml(data: Union[str, bytes], decoder: Optional[Decoder], dict_params: Optional[Mapping], **decoder_kwargs)`\n\nMake a new object from YAML formatted data based on the\ndataclass schema provided. Options include:\n```\ndecoder        # function called for YAML decoding, defaults to yaml.safe_load\ndict_params    # dictionary of parameter values passed underhood to `from_dict` function\ndecoder_kwargs # keyword arguments for decoder function\n```\n\nCustomization\n--------------------------------------------------------------------------------\n\n### User defined classes\n\nYou can define and use custom classes with *mashumaro*. There are two options\nfor customization.\n\n#### Serializable Interface\n\nThe first one is useful when you already have the separate\ncustom class and you want to serialize instances of it with *mashumaro*.\nAll what you need is to implement *SerializableType* interface:\n\n```python\nfrom typing import Dict\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.types import SerializableType\n\nclass DateTime(datetime, SerializableType):\n    def _serialize(self) -> Dict[str, int]:\n        return {\n            \"year\": self.year,\n            \"month\": self.month,\n            \"day\": self.day,\n            \"hour\": self.hour,\n            \"minute\": self.minute,\n            \"second\": self.second,\n        }\n\n    @classmethod\n    def _deserialize(cls, value: Dict[str, int]) -> 'DateTime':\n        return DateTime(\n            year=value['year'],\n            month=value['month'],\n            day=value['day'],\n            hour=value['hour'],\n            minute=value['minute'],\n            second=value['second'],\n        )\n\n\n@dataclass\nclass Holiday(DataClassDictMixin):\n    when: DateTime = DateTime.now()\n\n\nnew_year = Holiday(when=DateTime(2019, 1, 1, 12))\ndictionary = new_year.to_dict()\n# {'x': {'year': 2019, 'month': 1, 'day': 1, 'hour': 0, 'minute': 0, 'second': 0}}\nassert Holiday.from_dict(dictionary) == new_year\n```\n\n#### Serialization Strategy\n\nThe second option is useful when you want to change the serialization behaviour\nfor a class depending on some defined parameters. For this case you can create\nthe special class implementing *SerializationStrategy* interface:\n\n```python\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.types import SerializationStrategy\n\nclass FormattedDateTime(SerializationStrategy):\n    def __init__(self, fmt):\n        self.fmt = fmt\n\n    def _serialize(self, value: datetime) -> str:\n        return value.strftime(self.fmt)\n\n    def _deserialize(self, value: str) -> datetime:\n        return datetime.strptime(value, self.fmt)\n\n\n@dataclass\nclass DateTimeFormats(DataClassDictMixin):\n    short: FormattedDateTime(fmt='%d%m%Y%H%M%S') = datetime.now()\n    verbose: FormattedDateTime(fmt='%A %B %d, %Y, %H:%M:%S') = datetime.now()\n\n\nformats = DateTimeFormats(\n    short=datetime(2019, 1, 1, 12),\n    verbose=datetime(2019, 1, 1, 12),\n)\ndictionary = formats.to_dict()\n# {'short': '01012019120000', 'verbose': 'Tuesday January 01, 2019, 12:00:00'}\nassert DateTimeFormats.from_dict(dictionary) == formats\n```\n\n> ⚠️ Since PEP-563 [breaks](https://github.com/Fatal1ty/mashumaro/issues/10)\n> `SerializationStrategy`, it will be implemented differently sometime in a\n> future version 2.x.\n\n### Field options\n\nIn some cases creating a new class just for one little thing could be\nexcessive. You can use `dataclasses.field` as a field value and configure some\nserialization aspects through its `metadata` argument. Next section describes\nall supported options to use in `metadata` mapping.\n\n#### `serialize` option\n\nThis option allows you to change the default serialization method through\na value of type `Callable[[Any], Any]` that could be any callable object like\na function, a class method, a class instance method, an instance of a callable\nclass or even a lambda function.\n\nExample:\n\n```python\n@dataclass\nclass A(DataClassDictMixin):\n    dt: datetime = field(\n        metadata={\n            \"serialize\": lambda v: v.strftime('%Y-%m-%d %H:%M:%S')\n        }\n    )\n```\n\n#### `deserialize` option\n\nThis option allows you to change the default deserialization method. When using\nthis option, the deserialization behaviour depends on what type of value the\noption has. It could be either `Callable[[Any], Any]` or `str`.\n\nA value of type `Callable[[Any], Any]` is a generic way to specify any callable\nobject like a function, a class method, a class instance method, an instance\nof a callable class or even a lambda function to be called for deserialization.\n\nA value of type `str` sets a specific engine for deserialization. Keep in mind\nthat all possible engines depend on the field type that this option is used\nwith. At this moment there are next deserialization engines to choose from:\n\n| Applicable field types     | Supported engines        | Description\n|:-------------------------- |:-------------------------|:------------------------------|\n| `datetime`, `date`, `time` | [`ciso8601`](https://github.com/closeio/ciso8601#supported-subset-of-iso-8601), [`pendulum`](https://github.com/sdispater/pendulum) | How to parse datetime string. By default native [`fromisoformat`](https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat) of corresponding class will be used for `datetime`, `date` and `time` fields. It's the fastest way in most cases, but you can choose an alternative. |\n\nExample:\n\n```python\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom mashumaro import DataClassDictMixin\nimport ciso8601\nimport dateutil\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: datetime = field(\n        metadata={\"deserialize\": \"pendulum\"}\n    )\n\nclass B(DataClassDictMixin):\n    x: datetime = field(\n        metadata={\"deserialize\": ciso8601.parse_datetime_as_naive}\n    )\n\n@dataclass\nclass C(DataClassDictMixin):\n    dt: List[datetime] = field(\n        metadata={\n            \"deserialize\": lambda l: list(map(dateutil.parser.isoparse, l))\n        }\n    )\n```\n\nIf you don't want to remember the names of the options you can use\n`field_params` helper function:\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, field_options\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: int = field(\n        metadata=field_options(\n            serialize=str,\n            deserialize=int\n        )\n    )\n```\n\nMore options are on the way. If you know which option would be useful for many,\nplease don't hesitate to create an issue or pull request.\n\n### Serialization hooks\n\nIn some cases you need to prepare input / output data or do some extraordinary\nactions at different stages of the deserialization / serialization lifecycle.\nYou can do this with different types of hooks.\n\n#### Before deserialization\n\nFor doing something with a dictionary that will be passed to deserialization\nyou can use `__pre_deserialize__` class method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n\n    @classmethod\n    def __pre_deserialize__(cls, d: Dict[Any, Any]) -> Dict[Any, Any]:\n        return {k.lower(): v for k, v in d.items()}\n\nprint(DataClass.from_dict({\"ABC\": 123}))    # DataClass(abc=123)\nprint(DataClass.from_json('{\"ABC\": 123}'))  # DataClass(abc=123)\n```\n\n#### After deserialization\n\nFor doing something with a dataclass instance that was created as a result\nof deserialization you can use `__post_deserialize__` class method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n\n    @classmethod\n    def __post_deserialize__(cls, obj: 'A') -> 'A':\n        obj.abc = 456\n        return obj\n\nprint(DataClass.from_dict({\"ABC\": 123}))    # DataClass(abc=456)\nprint(DataClass.from_json('{\"ABC\": 123}'))  # DataClass(abc=456)\n```\n\n#### Before serialization\n\nFor doing something before serialization you can use `__pre_serialize__`\nmethod:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n    counter: ClassVar[int] = 0\n\n    def __pre_serialize__(self) -> 'A':\n        self.counter += 1\n        return self\n\nobj = DataClass(abc=123)\nobj.to_dict()\nobj.to_json()\nprint(obj.counter)  # 2\n```\n\n#### After serialization\n\nFor doing something with a dictionary that was created as a result of\nserialization you can use `__post_serialize__` method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    user: str\n    password: str\n\n    def __post_serialize__(self, d: Dict[Any, Any]) -> Dict[Any, Any]:\n        d.pop('password')\n        return d\n\nobj = DataClass(user=\"name\", password=\"secret\")\nprint(obj.to_dict())  # {\"user\": \"name\"}\nprint(obj.to_json())  # '{\"user\": \"name\"}'\n```\n\nTODO\n--------------------------------------------------------------------------------\n\n* add Union support (try to match types on each call)\n* write benchmarks\n* add optional validation\n* write custom useful types such as URL, Email etc\n* write documentation",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Fatal1ty/mashumaro",
    "keywords": "",
    "license": "Apache License, Version 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mashumaro",
    "package_url": "https://pypi.org/project/mashumaro/",
    "platform": "all",
    "project_url": "https://pypi.org/project/mashumaro/",
    "project_urls": {
      "Homepage": "https://github.com/Fatal1ty/mashumaro"
    },
    "release_url": "https://pypi.org/project/mashumaro/1.21/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Fast serialization framework on top of dataclasses",
    "version": "1.21",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16835627,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "49ceeb50899d70ac2e068b8e8bee5fc8e21c168e93558ec0b015191b7d9e1575",
        "md5": "de56b9499303bd2a10328e322da2edab",
        "sha256": "90d260b13427bad5dd654155dbca786594268c9e12dd853d7c3dcdfbbfcb83db"
      },
      "downloads": -1,
      "filename": "mashumaro-1.21.tar.gz",
      "has_sig": false,
      "md5_digest": "de56b9499303bd2a10328e322da2edab",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 20742,
      "upload_time": "2021-01-10T16:49:00",
      "upload_time_iso_8601": "2021-01-10T16:49:00.357132Z",
      "url": "https://files.pythonhosted.org/packages/49/ce/eb50899d70ac2e068b8e8bee5fc8e21c168e93558ec0b015191b7d9e1575/mashumaro-1.21.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}