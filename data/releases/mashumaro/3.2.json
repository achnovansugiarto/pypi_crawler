{
  "info": {
    "author": "Alexander Tikhonov",
    "author_email": "random.gauss@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# mashumaro (マシュマロ)\n\n> **mashumaro** is a fast and well tested serialization framework on top of dataclasses.\n\n[![Build Status](https://github.com/Fatal1ty/mashumaro/workflows/tests/badge.svg)](https://github.com/Fatal1ty/mashumaro/actions)\n[![Coverage Status](https://coveralls.io/repos/github/Fatal1ty/mashumaro/badge.svg?branch=master)](https://coveralls.io/github/Fatal1ty/mashumaro?branch=master)\n[![Latest Version](https://img.shields.io/pypi/v/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)\n[![Python Version](https://img.shields.io/pypi/pyversions/mashumaro.svg)](https://pypi.python.org/pypi/mashumaro)\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n\n\nWhen using dataclasses, you often need to dump and load objects according to\nthe described scheme.\nThis framework not only adds this ability to serialize in different formats,\nbut also makes **serialization rapidly**.\n\nTable of contents\n--------------------------------------------------------------------------------\n* [Installation](#installation)\n* [Changelog](#changelog)\n* [Supported serialization formats](#supported-serialization-formats)\n* [Supported field types](#supported-field-types)\n* [Usage example](#usage-example)\n* [How does it work?](#how-does-it-work)\n* [Benchmark](#benchmark)\n* [Serialization mixins](#serialization-mixins)\n  * [`DataClassDictMixin`](#dataclassdictmixin)\n  * [`DataClassJSONMixin`](#dataclassjsonmixin)\n  * [`DataClassORJSONMixin`](#dataclassorjsonmixin)\n  * [`DataClassMessagePackMixin`](#dataclassmessagepackmixin)\n  * [`DataClassYAMLMixin`](#dataclassyamlmixin)\n  * [`DataClassTOMLMixin`](#dataclasstomlmixin)\n* [Customization](#customization)\n    * [`SerializableType` interface](#serializabletype-interface)\n    * [Field options](#field-options)\n        * [`serialize` option](#serialize-option)\n        * [`deserialize` option](#deserialize-option)\n        * [`serialization_strategy` option](#serialization_strategy-option)\n        * [`alias` option](#alias-option)\n    * [Config options](#config-options)\n        * [`debug` config option](#debug-config-option)\n        * [`code_generation_options` config option](#code_generation_options-config-option)\n        * [`serialization_strategy` config option](#serialization_strategy-config-option)\n        * [`aliases` config option](#aliases-config-option)\n        * [`serialize_by_alias` config option](#serialize_by_alias-config-option)\n        * [`omit_none` config option](#omit_none-config-option)\n        * [`namedtuple_as_dict` config option](#namedtuple_as_dict-config-option)\n        * [`allow_postponed_evaluation` config option](#allow_postponed_evaluation-config-option)\n        * [`dialect` config option](#dialect-config-option)\n        * [`orjson_options`](#orjson_options-config-option)\n    * [Passing field values as is](#passing-field-values-as-is)\n    * [Dialects](#dialects)\n      * [`serialization_strategy` dialect option](#serialization_strategy-dialect-option)\n      * [`omit_none` dialect option](#omit_none-dialect-option)\n      * [Changing the default dialect](#changing-the-default-dialect)\n    * [Code generation options](#code-generation-options)\n        * [Add `omit_none` keyword argument](#add-omit_none-keyword-argument)\n        * [Add `by_alias` keyword argument](#add-by_alias-keyword-argument)\n        * [Add `dialect` keyword argument](#add-dialect-keyword-argument)\n    * [User-defined generic types](#user-defined-generic-types)\n      * [User-defined generic dataclasses](#user-defined-generic-dataclasses)\n      * [Generic dataclasses as field types](#generic-dataclasses-as-field-types)\n      * [`GenericSerializableType` interface](#genericserializabletype-interface)\n    * [Serialization hooks](#serialization-hooks)\n        * [Before deserialization](#before-deserialization)\n        * [After deserialization](#after-deserialization)\n        * [Before serialization](#before-serialization)\n        * [After serialization](#after-serialization)\n\nInstallation\n--------------------------------------------------------------------------------\n\nUse pip to install:\n```shell\n$ pip install mashumaro\n```\n\nThe current version of `mashumaro` supports Python versions 3.7 - 3.11.\nThe latest version of `mashumaro` that can be installed on Python 3.6 is 3.1.1.\n\nChangelog\n--------------------------------------------------------------------------------\n\nThis project follows the principles of [Semantic Versioning](https://semver.org).\nChangelog is available on [GitHub Releases page](https://github.com/Fatal1ty/mashumaro/releases).\n\nSupported serialization formats\n--------------------------------------------------------------------------------\n\nThis framework adds methods for dumping to and loading from the\nfollowing formats:\n\n* [plain dict](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\n* [JSON](https://www.json.org)\n* [YAML](https://yaml.org)\n* [MessagePack](https://msgpack.org)\n* [TOML](https://toml.io)\n\nPlain dict can be useful when you need to pass a dict object to a\nthird-party library, such as a client for MongoDB.\n\nYou can find the documentation for the specific serialization format [below](#serialization-mixins).\n\nSupported field types\n--------------------------------------------------------------------------------\n\nThere is support for generic types from the standard [`typing`](https://docs.python.org/3/library/typing.html) module:\n* [`List`](https://docs.python.org/3/library/typing.html#typing.List)\n* [`Tuple`](https://docs.python.org/3/library/typing.html#typing.Tuple)\n* [`NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\n* [`Set`](https://docs.python.org/3/library/typing.html#typing.Set)\n* [`FrozenSet`](https://docs.python.org/3/library/typing.html#typing.FrozenSet)\n* [`Deque`](https://docs.python.org/3/library/typing.html#typing.Deque)\n* [`Dict`](https://docs.python.org/3/library/typing.html#typing.Dict)\n* [`OrderedDict`](https://docs.python.org/3/library/typing.html#typing.OrderedDict)\n* [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)\n* [`Mapping`](https://docs.python.org/3/library/typing.html#typing.Mapping)\n* [`MutableMapping`](https://docs.python.org/3/library/typing.html#typing.MutableMapping)\n* [`Counter`](https://docs.python.org/3/library/typing.html#typing.Counter)\n* [`ChainMap`](https://docs.python.org/3/library/typing.html#typing.ChainMap)\n* [`Sequence`](https://docs.python.org/3/library/typing.html#typing.Sequence)\n\nfor standard generic types on [PEP 585](https://www.python.org/dev/peps/pep-0585/) compatible Python (3.9+):\n* [`list`](https://docs.python.org/3/library/stdtypes.html#list)\n* [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple)\n* [`namedtuple`](https://docs.python.org/3/library/collections.html#collections.namedtuple)\n* [`set`](https://docs.python.org/3/library/stdtypes.html#set)\n* [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)\n* [`collections.abc.Set`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set)\n* [`collections.abc.MutableSet`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSet)\n* [`collections.deque`](https://docs.python.org/3/library/collections.html#collections.deque)\n* [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)\n* [`collections.OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict)\n* [`collections.abc.Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping)\n* [`collections.abc.MutableMapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping)\n* [`collections.Counter`](https://docs.python.org/3/library/collections.html#collections.Counter)\n* [`collections.ChainMap`](https://docs.python.org/3/library/collections.html#collections.ChainMap)\n* [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)\n* [`collections.abc.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence)\n\nfor special primitives from the [`typing`](https://docs.python.org/3/library/typing.html) module:\n* [`Any`](https://docs.python.org/3/library/typing.html#typing.Any)\n* [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional)\n* [`Union`](https://docs.python.org/3/library/typing.html#typing.Union)\n* [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar)\n* [`NewType`](https://docs.python.org/3/library/typing.html#newtype)\n* [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated)\n* [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal)\n* [`Self`](https://docs.python.org/3/library/typing.html#typing.Self)\n\nfor standard interpreter types from [`types`](https://docs.python.org/3/library/types.html#standard-interpreter-types) module:\n* [`NoneType`](https://docs.python.org/3/library/types.html#types.NoneType)\n* [`UnionType`](https://docs.python.org/3/library/types.html#types.UnionType)\n\nfor enumerations based on classes from the standard [`enum`](https://docs.python.org/3/library/enum.html) module:\n* [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum)\n* [`IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum)\n* [`StrEnum`](https://docs.python.org/3/library/enum.html#enum.StrEnum)\n* [`Flag`](https://docs.python.org/3/library/enum.html#enum.Flag)\n* [`IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag)\n\nfor common built-in types:\n* [`int`](https://docs.python.org/3/library/functions.html#int)\n* [`float`](https://docs.python.org/3/library/functions.html#float)\n* [`bool`](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values)\n* [`str`](https://docs.python.org/3/library/stdtypes.html#str)\n* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)\n* [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray)\n\nfor built-in datetime oriented types (see [more](#deserialize-option) details):\n* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)\n* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)\n* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)\n* [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta)\n* [`timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone)\n* [`ZoneInfo`](https://docs.python.org/3/library/zoneinfo.html#zoneinfo.ZoneInfo)\n\nfor pathlike types:\n* [`PurePath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath)\n* [`Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path)\n* [`PurePosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePosixPath)\n* [`PosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath)\n* [`PureWindowsPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PureWindowsPath)\n* [`WindowsPath`](https://docs.python.org/3/library/pathlib.html#pathlib.WindowsPath)\n* [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike)\n\n\nfor other less popular built-in types:\n* [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)\n* [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal)\n* [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction)\n* [`ipaddress.IPv4Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address)\n* [`ipaddress.IPv6Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address)\n* [`ipaddress.IPv4Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network)\n* [`ipaddress.IPv6Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network)\n* [`ipaddress.IPv4Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Interface)\n* [`ipaddress.IPv6Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Interface)\n\nfor backported types from [`typing-extensions`](https://github.com/python/typing_extensions):\n* [`OrderedDict`](https://docs.python.org/3/library/typing.html#typing.OrderedDict)\n* [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)\n* [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated)\n* [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal)\n* [`Self`](https://docs.python.org/3/library/typing.html#typing.Self)\n\nfor arbitrary types:\n* [user-defined classes](#serializabletype-interface)\n* [user-defined generic types](#user-defined-generic-types)\n\nUsage example\n--------------------------------------------------------------------------------\n\n```python\nfrom enum import Enum\nfrom typing import List\nfrom dataclasses import dataclass\nfrom mashumaro.mixins.json import DataClassJSONMixin\n\nclass Currency(Enum):\n    USD = \"USD\"\n    EUR = \"EUR\"\n\n@dataclass\nclass CurrencyPosition(DataClassJSONMixin):\n    currency: Currency\n    balance: float\n\n@dataclass\nclass StockPosition(DataClassJSONMixin):\n    ticker: str\n    name: str\n    balance: int\n\n@dataclass\nclass Portfolio(DataClassJSONMixin):\n    currencies: List[CurrencyPosition]\n    stocks: List[StockPosition]\n\nmy_portfolio = Portfolio(\n    currencies=[\n        CurrencyPosition(Currency.USD, 238.67),\n        CurrencyPosition(Currency.EUR, 361.84),\n    ],\n    stocks=[\n        StockPosition(\"AAPL\", \"Apple\", 10),\n        StockPosition(\"AMZN\", \"Amazon\", 10),\n    ]\n)\n\njson_string = my_portfolio.to_json()\nPortfolio.from_json(json_string)  # same as my_portfolio\n```\n\nHow does it work?\n--------------------------------------------------------------------------------\n\nThis framework works by taking the schema of the data and generating a\nspecific parser and builder for exactly that schema, taking into account the\nspecifics of the serialization format. This is much faster than inspection of\nfield types on every call of parsing or building at runtime.\n\nThese specific parsers and builders are presented by the corresponding\n`from_*` and `to_*` methods. They are compiled during import time (or at\nruntime in some cases) and are set as attributes to your dataclasses.\n\nBenchmark\n--------------------------------------------------------------------------------\n\n* macOS 13.0.1 Ventura\n* Apple M1\n* 8GB RAM\n* Python 3.11.0\n\nLoad and dump [sample data](https://github.com/Fatal1ty/mashumaro/blob/master/benchmark/sample.py) 100 times in 5 runs.\nThe following figures show the best overall time in each case.\n\n<img src=\"https://raw.githubusercontent.com/Fatal1ty/mashumaro/master/benchmark/charts/load.png\" width=\"400\"><img src=\"https://raw.githubusercontent.com/Fatal1ty/mashumaro/master/benchmark/charts/dump.png\" width=\"400\">\n\n<table>\n  <col>\n  <colgroup span=\"2\"></colgroup>\n  <colgroup span=\"2\"></colgroup>\n  <tr>\n    <th rowspan=\"2\">Framework</th>\n    <th colspan=\"2\" scope=\"colgroup\">From dict</th>\n    <th colspan=\"2\" scope=\"colgroup\">To dict</th>\n</tr>\n<tr>\n    <th scope=\"col\">Time</th>\n    <th scope=\"col\">Slowdown factor</th>\n    <th scope=\"col\">Time</th>\n    <th scope=\"col\">Slowdown factor</th>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://github.com/Fatal1ty/mashumaro\">mashumaro</a></th>\n    <td align=\"right\">0.14834</td>\n    <td align=\"left\">1x</td>\n    <td align=\"right\">0.10295</td>\n    <td align=\"left\">1x</td>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://github.com/Tinche/cattrs\">cattrs</a></th>\n    <td align=\"right\">0.18971</td>\n    <td align=\"left\">1.28x</td>\n    <td align=\"right\">0.13793</td>\n    <td align=\"left\">1.34x</td>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://github.com/samuelcolvin/pydantic/\">pydantic</a></th>\n    <td align=\"right\">0.92374</td>\n    <td align=\"left\">6.23x</td>\n    <td align=\"right\">0.80111</td>\n    <td align=\"left\">7.78x</td>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://github.com/marshmallow-code/marshmallow\">marshmallow</a></th>\n    <td align=\"right\">1.36620</td>\n    <td align=\"left\">9.21x</td>\n    <td align=\"right\">0.44991</td>\n    <td align=\"left\">4.37x</td>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict\">dataclasses</a></th>\n    <td align=\"left\">—</td>\n    <td align=\"left\">—</td>\n    <td align=\"right\">0.68515</td>\n    <td align=\"left\">6.65x</td>\n</tr>\n<tr>\n    <th scope=\"row\"><a href=\"https://github.com/konradhalas/dacite\">dacite</a></th>\n    <td align=\"right\">2.40733</td>\n    <td align=\"left\">16.23x</td>\n    <td align=\"left\">—</td>\n    <td align=\"left\">—</td>\n</tr>\n</table>\n\nTo run benchmark in your environment:\n```bash\ngit clone git@github.com:Fatal1ty/mashumaro.git\ncd mashumaro\npython3 -m venv env && source env/bin/activate\npip install -e .\npip install -r requirements-dev.txt\npython benchmark/run.py\n```\n\nSerialization mixins\n--------------------------------------------------------------------------------\n\n`mashumaro` provides mixins for each serialization format.\n\n#### [`DataClassDictMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L11)\n\nCan be imported in two ways:\n```python\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.mixins.dict import DataClassDictMixin\n```\n\nThe core mixin that adds serialization functionality to a dataclass.\nThis mixin is a base class for all other serialization format mixins.\nIt adds methods [`from_dict`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L35-L44)\nand [`to_dict`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/dict.py#L24-L33).\n\n#### [`DataClassJSONMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L14)\n\nCan be imported as:\n```python\nfrom mashumaro.mixins.json import DataClassJSONMixin\n```\n\nThis mixins adds json serialization functionality to a dataclass.\nIt adds methods [`from_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L24-L31)\nand [`to_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/json.py#L17-L22).\n\n#### [`DataClassORJSONMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.py#L29)\n\nCan be imported as:\n```python\nfrom mashumaro.mixins.orjson import DataClassORJSONMixin\n```\n\nThis mixins adds json serialization functionality to a dataclass using\na third-party [`orjson`](https://pypi.org/project/orjson/) library.\nIt adds methods [`from_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L33-L39),\n[`to_jsonb`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L19-L25),\n[`to_json`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/orjson.pyi#L26-L32).\n\nIn order to use this mixin, the [`orjson`](https://pypi.org/project/orjson/) package must be installed.\nYou can install it manually or using an extra option for `mashumaro`:\n\n```shell\npip install mashumaro[orjson]\n```\n\nUsing this mixin the following data types will be handled by\n[`orjson`](https://pypi.org/project/orjson/) library by default:\n* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)\n* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)\n* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)\n* [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)\n\n#### [`DataClassMessagePackMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L35)\n\nCan be imported as:\n```python\nfrom mashumaro.mixins.msgpack import DataClassMessagePackMixin\n```\n\nThis mixins adds MessagePack serialization functionality to a dataclass.\nIt adds methods [`from_msgpack`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L58-L65)\nand [`to_msgpack`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L51-L56).\n\nIn order to use this mixin, the [`msgpack`](https://pypi.org/project/msgpack/) package must be installed.\nYou can install it manually or using an extra option for `mashumaro`:\n\n```shell\npip install mashumaro[msgpack]\n```\n\nUsing this mixin the following data types will be handled by\n[`msgpack`](https://pypi.org/project/msgpack/) library by default:\n* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)\n* [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray)\n\n#### [`DataClassYAMLMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/yaml.py#L27)\n\nCan be imported as:\n```python\nfrom mashumaro.mixins.yaml import DataClassYAMLMixin\n```\n\nThis mixins adds YAML serialization functionality to a dataclass.\nIt adds methods [`from_yaml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/msgpack.py#L51-L56)\nand [`to_yaml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/yaml.py#L30-L35).\n\nIn order to use this mixin, the [`pyyaml`](https://pypi.org/project/PyYAML/) package must be installed.\nYou can install it manually or using an extra option for `mashumaro`:\n\n```shell\npip install mashumaro[yaml]\n```\n\n#### [`DataClassTOMLMixin`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L32)\n\nCan be imported as:\n```python\nfrom mashumaro.mixins.toml import DataClassTOMLMixin\n```\n\nThis mixins adds TOML serialization functionality to a dataclass.\nIt adds methods [`from_toml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L55-L62)\nand [`to_toml`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/mixins/toml.py#L48-L53).\n\nIn order to use this mixin, the [`tomli`](https://pypi.org/project/tomli/) and\n[`tomli-w`](https://pypi.org/project/tomli-w/) packages must be installed.\nIn Python 3.11+, `tomli` is included as\n[`tomlib`](https://docs.python.org/3/library/tomllib.html) standard library\nmodule and can be used my this mixin.\nYou can install the missing packages manually or using an extra option for `mashumaro`:\n\n```shell\npip install mashumaro[toml]\n```\n\nUsing this mixin the following data types will be handled by\n[`tomli`](https://pypi.org/project/tomli/)/\n[`tomli-w`](https://pypi.org/project/tomli-w/) library by default:\n* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)\n* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date)\n* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time)\n\nFields with value `None` will be omitted on serialization because TOML doesn't support null values.\n\nCustomization\n--------------------------------------------------------------------------------\n\n### SerializableType interface\n\nIf you already have a separate custom class, and you want to serialize\ninstances of it with `mashumaro`, you can achieve this by implementing\n`SerializableType` interface:\n\n```python\nfrom typing import Dict\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.types import SerializableType\n\nclass DateTime(datetime, SerializableType):\n    def _serialize(self) -> Dict[str, int]:\n        return {\n            \"year\": self.year,\n            \"month\": self.month,\n            \"day\": self.day,\n            \"hour\": self.hour,\n            \"minute\": self.minute,\n            \"second\": self.second,\n        }\n\n    @classmethod\n    def _deserialize(cls, value: Dict[str, int]) -> 'DateTime':\n        return DateTime(\n            year=value['year'],\n            month=value['month'],\n            day=value['day'],\n            hour=value['hour'],\n            minute=value['minute'],\n            second=value['second'],\n        )\n\n\n@dataclass\nclass Holiday(DataClassDictMixin):\n    when: DateTime = DateTime.now()\n\n\nnew_year = Holiday(when=DateTime(2019, 1, 1, 12))\ndictionary = new_year.to_dict()\n# {'x': {'year': 2019, 'month': 1, 'day': 1, 'hour': 0, 'minute': 0, 'second': 0}}\nassert Holiday.from_dict(dictionary) == new_year\n```\n\nIf you have a custom [generic type](https://docs.python.org/3/library/typing.html#user-defined-generic-types)\nand are looking for a generic version of such an interface, read [this](#genericserializabletype-interface).\n\n### Field options\n\nIn some cases creating a new class just for one little thing could be\nexcessive. Moreover, you may need to deal with third party classes that you are\nnot allowed to change. You can use[`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field)\nfunction as a default field value to configure some serialization aspects\nthrough its `metadata` parameter. Next section describes all supported options\nto use in `metadata` mapping.\n\n#### `serialize` option\n\nThis option allows you to change the serialization method. When using\nthis option, the serialization behaviour depends on what type of value the\noption has. It could be either `Callable[[Any], Any]` or `str`.\n\nA value of type `Callable[[Any], Any]` is a generic way to specify any callable\nobject like a function, a class method, a class instance method, an instance\nof a callable class or even a lambda function to be called for serialization.\n\nA value of type `str` sets a specific engine for serialization. Keep in mind\nthat all possible engines depend on the field type that this option is used\nwith. At this moment there are next serialization engines to choose from:\n\n| Applicable field types     | Supported engines        | Description                                                                                                                                                                                                  |\n|:-------------------------- |:-------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `NamedTuple`, `namedtuple` | `as_list`, `as_dict`     | How to pack named tuples. By default `as_list` engine is used that means your named tuple class instance will be packed into a list of its values. You can pack it into a dictionary using `as_dict` engine. |\n\nIn addition, you can pass a field value as is without changes using\n[`pass_through`](#passing-field-values-as-is).\n\nExample:\n\n```python\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import NamedTuple\nfrom mashumaro import DataClassDictMixin\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n    y: float\n\n@dataclass\nclass A(DataClassDictMixin):\n    dt: datetime = field(\n        metadata={\n            \"serialize\": lambda v: v.strftime('%Y-%m-%d %H:%M:%S')\n        }\n    )\n    t: MyNamedTuple = field(metadata={\"serialize\": \"as_dict\"})\n```\n\n#### `deserialize` option\n\nThis option allows you to change the deserialization method. When using\nthis option, the deserialization behaviour depends on what type of value the\noption has. It could be either `Callable[[Any], Any]` or `str`.\n\nA value of type `Callable[[Any], Any]` is a generic way to specify any callable\nobject like a function, a class method, a class instance method, an instance\nof a callable class or even a lambda function to be called for deserialization.\n\nA value of type `str` sets a specific engine for deserialization. Keep in mind\nthat all possible engines depend on the field type that this option is used\nwith. At this moment there are next deserialization engines to choose from:\n\n| Applicable field types     | Supported engines                                                                                                                   | Description                                                                                                                                                                                                                                                                                             |\n|:---------------------------|:------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `datetime`, `date`, `time` | [`ciso8601`](https://github.com/closeio/ciso8601#supported-subset-of-iso-8601), [`pendulum`](https://github.com/sdispater/pendulum) | How to parse datetime string. By default native [`fromisoformat`](https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat) of corresponding class will be used for `datetime`, `date` and `time` fields. It's the fastest way in most cases, but you can choose an alternative. |\n| `NamedTuple`, `namedtuple` | `as_list`, `as_dict`                                                                                                                | How to unpack named tuples. By default `as_list` engine is used that means your named tuple class instance will be created from a list of its values. You can unpack it from a dictionary using `as_dict` engine.                                                                                       |\n\nIn addition, you can pass a field value as is without changes using\n[`pass_through`](#passing-field-values-as-is).\n\nExample:\n\n```python\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import List, NamedTuple\nfrom mashumaro import DataClassDictMixin\nimport ciso8601\nimport dateutil\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n    y: float\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: datetime = field(\n        metadata={\"deserialize\": \"pendulum\"}\n    )\n\nclass B(DataClassDictMixin):\n    x: datetime = field(\n        metadata={\"deserialize\": ciso8601.parse_datetime_as_naive}\n    )\n\n@dataclass\nclass C(DataClassDictMixin):\n    dt: List[datetime] = field(\n        metadata={\n            \"deserialize\": lambda l: list(map(dateutil.parser.isoparse, l))\n        }\n    )\n\n@dataclass\nclass D(DataClassDictMixin):\n    x: MyNamedTuple = field(metadata={\"deserialize\": \"as_dict\"})\n```\n\n#### `serialization_strategy` option\n\nThis option is useful when you want to change the serialization behaviour\nfor a class depending on some defined parameters. For this case you can create\nthe special class implementing `SerializationStrategy` interface:\n\n```python\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.types import SerializationStrategy\n\nclass FormattedDateTime(SerializationStrategy):\n    def __init__(self, fmt):\n        self.fmt = fmt\n\n    def serialize(self, value: datetime) -> str:\n        return value.strftime(self.fmt)\n\n    def deserialize(self, value: str) -> datetime:\n        return datetime.strptime(value, self.fmt)\n\n@dataclass\nclass DateTimeFormats(DataClassDictMixin):\n    short: datetime = field(\n        metadata={\n            \"serialization_strategy\": FormattedDateTime(\n                fmt=\"%d%m%Y%H%M%S\",\n            )\n        }\n    )\n    verbose: datetime = field(\n        metadata={\n            \"serialization_strategy\": FormattedDateTime(\n                fmt=\"%A %B %d, %Y, %H:%M:%S\",\n            )\n        }\n    )\n\nformats = DateTimeFormats(\n    short=datetime(2019, 1, 1, 12),\n    verbose=datetime(2019, 1, 1, 12),\n)\ndictionary = formats.to_dict()\n# {'short': '01012019120000', 'verbose': 'Tuesday January 01, 2019, 12:00:00'}\nassert DateTimeFormats.from_dict(dictionary) == formats\n```\n\nIn addition, you can pass a field value as is without changes using\n[`pass_through`](#passing-field-values-as-is).\n\n#### `alias` option\n\nIn some cases it's better to have different names for a field in your class and\nin its serialized view. For example, a third-party legacy API you are working\nwith might operate with camel case style, but you stick to snake case style in\nyour code base. Or even you want to load data with keys that are invalid\nidentifiers in Python. This problem is easily solved by using aliases:\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, field_options\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    a: int = field(metadata=field_options(alias=\"FieldA\"))\n    b: int = field(metadata=field_options(alias=\"#invalid\"))\n\nx = DataClass.from_dict({\"FieldA\": 1, \"#invalid\": 2})  # DataClass(a=1, b=2)\nx.to_dict()  # {\"a\": 1, \"b\": 2}  # no aliases on serialization by default\n```\n\nIf you want to write all the field aliases in one place there is\n[such a config option](#aliases-config-option).\n\nIf you want to serialize all the fields by aliases you have two options to do so:\n* [`serialize_by_alias` config option](#serialize_by_alias-config-option)\n* [`by_alias` keyword argument in `to_*` methods](#add-by_alias-keyword-argument)\n\nIt's hard to imagine when it might be necessary to serialize only specific\nfields by alias, but such functionality is easily added to the library. Open\nthe issue if you need it.\n\nIf you don't want to remember the names of the options you can use\n`field_options` helper function:\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, field_options\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: int = field(\n        metadata=field_options(\n            serialize=str,\n            deserialize=int,\n            ...\n        )\n    )\n```\n\nMore options are on the way. If you know which option would be useful for many,\nplease don't hesitate to create an issue or pull request.\n\n### Config options\n\nIf inheritance is not an empty word for you, you'll fall in love with the\n`Config` class. You can register `serialize` and `deserialize` methods, define\ncode generation options and other things just in one place. Or in some\nclasses in different ways if you need flexibility. Inheritance is always on the\nfirst place.\n\nThere is a base class `BaseConfig` that you can inherit for the sake of\nconvenience, but it's not mandatory.\n\nIn the following example you can see how\nthe `debug` flag is changed from class to class: `ModelA` will have debug mode enabled but\n`ModelB` will not.\n\n```python\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import BaseConfig\n\nclass BaseModel(DataClassDictMixin):\n    class Config(BaseConfig):\n        debug = True\n\nclass ModelA(BaseModel):\n    a: int\n\nclass ModelB(BaseModel):\n    b: int\n\n    class Config(BaseConfig):\n        debug = False\n```\n\nNext section describes all supported options to use in the config.\n\n#### `debug` config option\n\nIf you enable the `debug` option the generated code for your data class\nwill be printed.\n\n#### `code_generation_options` config option\n\nSome users may need functionality that wouldn't exist without extra cost such\nas valuable cpu time to execute additional instructions. Since not everyone\nneeds such instructions, they can be enabled by a constant in the list,\nso the fastest basic behavior of the library will always remain by default.\nThe following table provides a brief overview of all the available constants\ndescribed below.\n\n| Constant                                                        | Description                                                          |\n|:----------------------------------------------------------------|:---------------------------------------------------------------------|\n| [`TO_DICT_ADD_OMIT_NONE_FLAG`](#add-omit_none-keyword-argument) | Adds `omit_none` keyword-only argument to `to_*` methods.            |\n| [`TO_DICT_ADD_BY_ALIAS_FLAG`](#add-by_alias-keyword-argument)   | Adds `by_alias` keyword-only argument to `to_*` methods.             |\n| [`ADD_DIALECT_SUPPORT`](#add-dialect-keyword-argument)          | Adds `dialect` keyword-only argument to `from_*` and `to_*` methods. |\n\n#### `serialization_strategy` config option\n\nYou can register custom `SerializationStrategy`, `serialize` and `deserialize`\nmethods for specific types just in one place. It could be configured using\na dictionary with types as keys. The value could be either a\n`SerializationStrategy` instance or a dictionary with `serialize` and\n`deserialize` values with the same meaning as in the\n[field options](#field-options).\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime, date\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import BaseConfig\nfrom mashumaro.types import SerializationStrategy\n\nclass FormattedDateTime(SerializationStrategy):\n    def __init__(self, fmt):\n        self.fmt = fmt\n\n    def serialize(self, value: datetime) -> str:\n        return value.strftime(self.fmt)\n\n    def deserialize(self, value: str) -> datetime:\n        return datetime.strptime(value, self.fmt)\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n\n    datetime: datetime\n    date: date\n\n    class Config(BaseConfig):\n        serialization_strategy = {\n            datetime: FormattedDateTime(\"%Y\"),\n            date: {\n                # you can use specific str values for datetime here as well\n                \"deserialize\": \"pendulum\",\n                \"serialize\": date.isoformat,\n            },\n        }\n\ninstance = DataClass.from_dict({\"datetime\": \"2021\", \"date\": \"2021\"})\n# DataClass(datetime=datetime.datetime(2021, 1, 1, 0, 0), date=Date(2021, 1, 1))\ndictionary = instance.to_dict()\n# {'datetime': '2021', 'date': '2021-01-01'}\n```\n\n#### `aliases` config option\n\nSometimes it's better to write the field aliases in one place. You can mix\naliases here with [aliases in the field options](#alias-option), but the last ones will always\ntake precedence.\n\n```python\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import BaseConfig\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    a: int\n    b: int\n\n    class Config(BaseConfig):\n        aliases = {\n            \"a\": \"FieldA\",\n            \"b\": \"FieldB\",\n        }\n\nDataClass.from_dict({\"FieldA\": 1, \"FieldB\": 2})  # DataClass(a=1, b=2)\n```\n\n#### `serialize_by_alias` config option\n\nAll the fields with [aliases](#alias-option) will be serialized by them by\ndefault when this option is enabled. You can mix this config option with\n[`by_alias`](#add-by_alias-keyword-argument) keyword argument.\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, field_options\nfrom mashumaro.config import BaseConfig\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    field_a: int = field(metadata=field_options(alias=\"FieldA\"))\n\n    class Config(BaseConfig):\n        serialize_by_alias = True\n\nDataClass(field_a=1).to_dict()  # {'FieldA': 1}\n```\n\n#### `omit_none` config option\n\nAll the fields with `None` values will be skipped during serialization by\ndefault when this option is enabled. You can mix this config option with\n[`omit_none`](#add-omit_none-keyword-argument) keyword argument.\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nfrom mashumaro import DataClassDictMixin, field_options\nfrom mashumaro.config import BaseConfig\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    x: Optional[int] = None\n\n    class Config(BaseConfig):\n        omit_none = True\n\nDataClass().to_dict()  # {}\n```\n\n#### `namedtuple_as_dict` config option\n\nDataclasses are a great way to declare and use data models. But it's not the only way.\nPython has a typed version of [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)\ncalled [NamedTuple](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\nwhich looks similar to dataclasses:\n\n```python\nfrom typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n```\n\nthe same with a dataclass will look like this:\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n```\n\nAt first glance, you can use both options. But imagine that you need to create\na bunch of instances of the `Point` class. Due to how dataclasses work you will\nhave more memory consumption compared to named tuples. In such a case it could\nbe more appropriate to use named tuples.\n\nBy default, all named tuples are packed into lists. But with `namedtuple_as_dict`\noption you have a drop-in replacement for dataclasses:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, NamedTuple\nfrom mashumaro import DataClassDictMixin\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    points: List[Point]\n\n    class Config:\n        namedtuple_as_dict = True\n\nobj = DataClass.from_dict({\"points\": [{\"x\": 0, \"y\": 0}, {\"x\": 1, \"y\": 1}]})\nprint(obj.to_dict())  # {\"points\": [{\"x\": 0, \"y\": 0}, {\"x\": 1, \"y\": 1}]}\n```\n\nIf you want to serialize only certain named tuple fields as dictionaries, you\ncan use the corresponding [serialization](#serialize-option) and\n[deserialization](#deserialize-option) engines.\n\n#### `allow_postponed_evaluation` config option\n\n[PEP 563](https://www.python.org/dev/peps/pep-0563/) solved the problem of forward references by postponing the evaluation\nof annotations, so you can write the following code:\n\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: B\n\n@dataclass\nclass B(DataClassDictMixin):\n    y: int\n\nobj = A.from_dict({'x': {'y': 1}})\n```\n\nYou don't need to write anything special here, forward references work out of\nthe box. If a field of a dataclass has a forward reference in the type\nannotations, building of `from_*` and `to_*` methods of this dataclass\nwill be postponed until they are called once. However, if for some reason you\ndon't want the evaluation to be possibly postponed, you can disable it using\n`allow_postponed_evaluation` option:\n\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\n\n@dataclass\nclass A(DataClassDictMixin):\n    x: B\n\n    class Config:\n        allow_postponed_evaluation = False\n\n# UnresolvedTypeReferenceError: Class A has unresolved type reference B\n# in some of its fields\n\n@dataclass\nclass B(DataClassDictMixin):\n    y: int\n```\n\nIn this case you will get `UnresolvedTypeReferenceError` regardless of whether\nclass B is declared below or not.\n\n#### `dialect` config option\n\nThis option is described [below](#changing-the-default-dialect) in the\nDialects section.\n\n#### `orjson_options` config option\n\nThis option changes default options for `orjson.dumps` encoder which is\nused in [`DataClassORJSONMixin`](#dataclassorjsonmixin). For example, you can\ntell orjson to handle non-`str` `dict` keys as the built-in `json.dumps`\nencoder does. See [orjson documentation](https://github.com/ijl/orjson#option)\nto read more about these options.\n\n```python\nimport orjson\nfrom dataclasses import dataclass\nfrom typing import Dict\nfrom mashumaro.config import BaseConfig\nfrom mashumaro.mixins.orjson import DataClassORJSONMixin\n\n@dataclass\nclass MyClass(DataClassORJSONMixin):\n    x: Dict[int, int]\n\n    class Config(BaseConfig):\n        orjson_options = orjson.OPT_NON_STR_KEYS\n\nassert MyClass({1: 2}).to_json() == {\"1\": 2}\n```\n\n### Passing field values as is\n\nIn some cases it's needed to pass a field value as is without any changes\nduring serialization / deserialization. There is a predefined\n[`pass_through`](https://github.com/Fatal1ty/mashumaro/blob/master/mashumaro/helper.py#L46)\nobject that can be used as `serialization_strategy` or\n`serialize` / `deserialize` options:\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, pass_through\n\nclass MyClass:\n    def __init__(self, some_value):\n        self.some_value = some_value\n\n@dataclass\nclass A1(DataClassDictMixin):\n    x: MyClass = field(\n        metadata={\n            \"serialize\": pass_through,\n            \"deserialize\": pass_through,\n        }\n    )\n\n@dataclass\nclass A2(DataClassDictMixin):\n    x: MyClass = field(\n        metadata={\n            \"serialization_strategy\": pass_through,\n        }\n    )\n\n@dataclass\nclass A3(DataClassDictMixin):\n    x: MyClass\n\n    class Config:\n        serialization_strategy = {\n            MyClass: pass_through,\n        }\n\n@dataclass\nclass A4(DataClassDictMixin):\n    x: MyClass\n\n    class Config:\n        serialization_strategy = {\n            MyClass: {\n                \"serialize\": pass_through,\n                \"deserialize\": pass_through,\n            }\n        }\n\nmy_class_instance = MyClass(42)\n\nassert A1.from_dict({'x': my_class_instance}).x == my_class_instance\nassert A2.from_dict({'x': my_class_instance}).x == my_class_instance\nassert A3.from_dict({'x': my_class_instance}).x == my_class_instance\nassert A4.from_dict({'x': my_class_instance}).x == my_class_instance\n\na1_dict = A1(my_class_instance).to_dict()\na2_dict = A2(my_class_instance).to_dict()\na3_dict = A3(my_class_instance).to_dict()\na4_dict = A4(my_class_instance).to_dict()\n\nassert a1_dict == a2_dict == a3_dict == a4_dict == {\"x\": my_class_instance}\n```\n\n### Dialects\n\nSometimes it's needed to have different serialization and deserialization\nmethods depending on the data source where entities of the dataclass are\nstored or on the API to which the entities are being sent or received from.\nThere is a special Dialect type that may contain all the differences from the\ndefault serialization and deserialization methods. You can create different\ndialects and use each of them for the same dataclass depending on\nthe situation.\n\nSuppose we have the following dataclass with a field of type `date`:\n```python\n@dataclass\nclass Entity(DataClassDictMixin):\n    dt: date\n```\n\nBy default, a field of `date` type serializes to a string in ISO 8601 format,\nso the serialized entity will look like `{'dt': '2021-12-31'}`. But what if we\nhave, for example, two sensitive legacy Ethiopian and Japanese APIs that use\ntwo different formats for dates — `dd/mm/yyyy` and `yyyy年mm月dd日`? Instead of\ncreating two similar dataclasses we can have one dataclass and two dialects:\n```python\nfrom dataclasses import dataclass\nfrom datetime import date, datetime\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import ADD_DIALECT_SUPPORT\nfrom mashumaro.dialect import Dialect\nfrom mashumaro.types import SerializationStrategy\n\nclass DateTimeSerializationStrategy(SerializationStrategy):\n    def __init__(self, fmt: str):\n        self.fmt = fmt\n\n    def serialize(self, value: date) -> str:\n        return value.strftime(self.fmt)\n\n    def deserialize(self, value: str) -> date:\n        return datetime.strptime(value, self.fmt).date()\n\nclass EthiopianDialect(Dialect):\n    serialization_strategy = {\n        date: DateTimeSerializationStrategy(\"%d/%m/%Y\")\n    }\n\nclass JapaneseDialect(Dialect):\n    serialization_strategy = {\n        date: DateTimeSerializationStrategy(\"%Y年%m月%d日\")\n    }\n\n@dataclass\nclass Entity(DataClassDictMixin):\n    dt: date\n\n    class Config:\n        code_generation_options = [ADD_DIALECT_SUPPORT]\n\nentity = Entity(date(2021, 12, 31))\nentity.to_dict(dialect=EthiopianDialect)  # {'dt': '31/12/2021'}\nentity.to_dict(dialect=JapaneseDialect)   # {'dt': '2021年12月31日'}\nEntity.from_dict({'dt': '2021年12月31日'}, dialect=JapaneseDialect)\n```\n\n#### `serialization_strategy` dialect option\n\nThis dialect option has the same meaning as the\n[similar config option](#serialization_strategy-config-option)\nbut for the dialect scope. You can register custom `SerializationStrategy`,\n`serialize` and `deserialize` methods for specific types.\n\n#### `omit_none` dialect option\n\nThis dialect option has the same meaning as the\n[similar config option](#omit_none-config-option) but for the dialect scope.\n\n#### Changing the default dialect\n\nYou can change the default serialization and deserialization methods for\na dataclass not only in the\n[`serialization_strategy`](#serialization_strategy-config-option) config option\nbut using the `dialect` config option. If you have multiple dataclasses without\na common parent class the default dialect can help you to reduce the number of\ncode lines written:\n\n```python\n@dataclass\nclass Entity(DataClassDictMixin):\n    dt: date\n\n    class Config:\n        dialect = JapaneseDialect\n\nentity = Entity(date(2021, 12, 31))\nentity.to_dict()  # {'dt': '2021年12月31日'}\nassert Entity.from_dict({'dt': '2021年12月31日'}) == entity\n```\n\n### Code generation options\n\n#### Add `omit_none` keyword argument\n\nIf you want to have control over whether to skip `None` values on serialization\nyou can add `omit_none` parameter to `to_*` methods using the\n`code_generation_options` list. The default value of `omit_none`\nparameter depends on whether the [`omit_none`](#omit_none-config-option)\nconfig option or [`omit_none`](#omit_none-dialect-option) dialect option is enabled.\n\n```python\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import BaseConfig, TO_DICT_ADD_OMIT_NONE_FLAG\n\n@dataclass\nclass Inner(DataClassDictMixin):\n    x: int = None\n    # \"x\" won't be omitted since there is no TO_DICT_ADD_OMIT_NONE_FLAG here\n\n@dataclass\nclass Model(DataClassDictMixin):\n    x: Inner\n    a: int = None\n    b: str = None  # will be omitted\n\n    class Config(BaseConfig):\n        code_generation_options = [TO_DICT_ADD_OMIT_NONE_FLAG]\n\nModel(x=Inner(), a=1).to_dict(omit_none=True)  # {'x': {'x': None}, 'a': 1}\n```\n\n#### Add `by_alias` keyword argument\n\nIf you want to have control over whether to serialize fields by their\n[aliases](#alias-option) you can add `by_alias` parameter to `to_*` methods\nusing the `code_generation_options` list. The default value of `by_alias`\nparameter depends on whether the [`serialize_by_alias`](#serialize_by_alias-config-option)\nconfig option is enabled.\n\n```python\nfrom dataclasses import dataclass, field\nfrom mashumaro import DataClassDictMixin, field_options\nfrom mashumaro.config import BaseConfig, TO_DICT_ADD_BY_ALIAS_FLAG\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    field_a: int = field(metadata=field_options(alias=\"FieldA\"))\n\n    class Config(BaseConfig):\n        code_generation_options = [TO_DICT_ADD_BY_ALIAS_FLAG]\n\nDataClass(field_a=1).to_dict()  # {'field_a': 1}\nDataClass(field_a=1).to_dict(by_alias=True)  # {'FieldA': 1}\n```\n\n#### Add `dialect` keyword argument\n\nSupport for [dialects](#dialects) is disabled by default for performance reasons. You can enable\nit using a `ADD_DIALECT_SUPPORT` constant:\n```python\nfrom dataclasses import dataclass\nfrom datetime import date\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.config import BaseConfig, ADD_DIALECT_SUPPORT\n\n@dataclass\nclass Entity(DataClassDictMixin):\n    dt: date\n\n    class Config(BaseConfig):\n        code_generation_options = [ADD_DIALECT_SUPPORT]\n```\n\n### User-defined generic types\n\nThere is support for [user-defined generic types](https://docs.python.org/3/library/typing.html#user-defined-generic-types).\nYou can inherit generic dataclasses along with overwriting types in them, use generic\ndataclasses as field types, or create your own generic types with serialization\nunder your control.\n\n#### User-defined generic dataclasses\n\nIf you have a generic version of a dataclass and want to serialize and\ndeserialize its instances depending on the concrete types, you can achieve\nthis using inheritance:\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import date\nfrom typing import Generic, Mapping, TypeVar\nfrom mashumaro import DataClassDictMixin\n\nKT = TypeVar(\"KT\")\nVT = TypeVar(\"VT\", date, str)\n\n@dataclass\nclass GenericDataClass(Generic[KT, VT]):\n    x: Mapping[KT, VT]\n\n@dataclass\nclass ConcreteDataClass(GenericDataClass[str, date], DataClassDictMixin):\n    pass\n\nConcreteDataClass.from_dict({\"x\": {\"a\": \"2021-01-01\"}})          # ok\nConcreteDataClass.from_dict({\"x\": {\"a\": \"not a date but str\"}})  # error\n```\n\nYou can override `TypeVar` field with a concrete type or another `TypeVar`.\nPartial specification of concrete types is also allowed. If a generic dataclass\nis inherited without type overriding the types of its fields remain untouched.\n\n#### Generic dataclasses as field types\n\nAnother approach is to specify concrete types in the field type hints. This can\nhelp to have different versions of the same generic dataclass:\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import date\nfrom typing import Generic, TypeVar\nfrom mashumaro import DataClassDictMixin\n\nT = TypeVar('T')\n\n@dataclass\nclass GenericDataClass(Generic[T], DataClassDictMixin):\n    x: T\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    date: GenericDataClass[date]\n    str: GenericDataClass[str]\n\ninstance = DataClass(\n    date=GenericDataClass(x=date(2021, 1, 1)),\n    str=GenericDataClass(x='2021-01-01'),\n)\ndictionary = {'date': {'x': '2021-01-01'}, 'str': {'x': '2021-01-01'}}\nassert DataClass.from_dict(dictionary) == instance\n```\n\n#### GenericSerializableType interface\n\nThere is a generic alternative to [`SerializableType`](#serializabletype-interface)\ncalled `GenericSerializableType`. It makes it possible to serialize and deserialize\ninstances of generic types depending on the types provided:\n\n```python\nfrom typing import Dict, TypeVar\nfrom dataclasses import dataclass\nfrom mashumaro import DataClassDictMixin\nfrom mashumaro.types import GenericSerializableType\n\nKT = TypeVar(\"KT\", int, str)\nVT = TypeVar(\"VT\", int, str)\n\nclass GenericDict(Dict[KT, VT], GenericSerializableType):\n    def _serialize(self, types) -> Dict[KT, VT]:\n        k_type, v_type = types\n        if k_type not in (int, str) or v_type not in (int, str):\n            raise TypeError\n        return {k_type(k): v_type(v) for k, v in self.items()}\n\n    @classmethod\n    def _deserialize(cls, value, types) -> 'GenericDict[KT, VT]':\n        k_type, v_type = types\n        if k_type not in (int, str) or v_type not in (int, str):\n            raise TypeError\n        return cls({k_type(k): v_type(v) for k, v in value.items()})\n\n@dataclass\nclass DataClass(DataClassDictMixin):\n    x: GenericDict[int, str]\n    y: GenericDict[str, int]\n\ninstance = DataClass(GenericDict({1: 'a'}), GenericDict({'b': 2}))\ndictionary = instance.to_dict()  # {'x': {1: 'a'}, 'y': {'b': 2}}\nassert DataClass.from_dict(dictionary) == instance\n```\n\nThe difference between [`SerializableType`](#serializabletype-interface) and\n[`GenericSerializableType`](#genericserializabletype-interface) is that\nthe methods of [`GenericSerializableType`](#genericserializabletype-interface)\nhave a parameter `types`, to which the concrete types will be passed.\nIf you don't need this information you can still use\n[`SerializableType`](#serializabletype-interface) interface even with generic\ntypes.\n\n### Serialization hooks\n\nIn some cases you need to prepare input / output data or do some extraordinary\nactions at different stages of the deserialization / serialization lifecycle.\nYou can do this with different types of hooks.\n\n#### Before deserialization\n\nFor doing something with a dictionary that will be passed to deserialization\nyou can use `__pre_deserialize__` class method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n\n    @classmethod\n    def __pre_deserialize__(cls, d: Dict[Any, Any]) -> Dict[Any, Any]:\n        return {k.lower(): v for k, v in d.items()}\n\nprint(DataClass.from_dict({\"ABC\": 123}))    # DataClass(abc=123)\nprint(DataClass.from_json('{\"ABC\": 123}'))  # DataClass(abc=123)\n```\n\n#### After deserialization\n\nFor doing something with a dataclass instance that was created as a result\nof deserialization you can use `__post_deserialize__` class method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n\n    @classmethod\n    def __post_deserialize__(cls, obj: 'A') -> 'A':\n        obj.abc = 456\n        return obj\n\nprint(DataClass.from_dict({\"abc\": 123}))    # DataClass(abc=456)\nprint(DataClass.from_json('{\"abc\": 123}'))  # DataClass(abc=456)\n```\n\n#### Before serialization\n\nFor doing something before serialization you can use `__pre_serialize__`\nmethod:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    abc: int\n    counter: ClassVar[int] = 0\n\n    def __pre_serialize__(self) -> 'A':\n        self.counter += 1\n        return self\n\nobj = DataClass(abc=123)\nobj.to_dict()\nobj.to_json()\nprint(obj.counter)  # 2\n```\n\n#### After serialization\n\nFor doing something with a dictionary that was created as a result of\nserialization you can use `__post_serialize__` method:\n\n```python\n@dataclass\nclass A(DataClassJSONMixin):\n    user: str\n    password: str\n\n    def __post_serialize__(self, d: Dict[Any, Any]) -> Dict[Any, Any]:\n        d.pop('password')\n        return d\n\nobj = DataClass(user=\"name\", password=\"secret\")\nprint(obj.to_dict())  # {\"user\": \"name\"}\nprint(obj.to_json())  # '{\"user\": \"name\"}'\n```\n\nTODO\n--------------------------------------------------------------------------------\n\n* add optional validation\n* write custom useful types such as URL, Email etc\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Fatal1ty/mashumaro",
    "keywords": "",
    "license": "Apache License, Version 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mashumaro",
    "package_url": "https://pypi.org/project/mashumaro/",
    "platform": "all",
    "project_url": "https://pypi.org/project/mashumaro/",
    "project_urls": {
      "Homepage": "https://github.com/Fatal1ty/mashumaro"
    },
    "release_url": "https://pypi.org/project/mashumaro/3.2/",
    "requires_dist": [
      "typing-extensions (>=4.1.0)",
      "msgpack (>=0.5.6) ; extra == 'msgpack'",
      "orjson ; extra == 'orjson'",
      "tomli-w (>=1.0) ; extra == 'toml'",
      "tomli (>=1.1.0) ; (python_version < \"3.11\") and extra == 'toml'",
      "pyyaml (>=3.13) ; extra == 'yaml'"
    ],
    "requires_python": ">=3.7",
    "summary": "Fast serialization framework on top of dataclasses",
    "version": "3.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16835627,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "463745d7871fa7d5dba5e84e1b852b71cf2298361fa1524bc7bb7d39122deca2",
        "md5": "4b00e6d7834cc5476a0df219d4e4fdd4",
        "sha256": "1e0bb20277151e1d3e39ce5df26fb734be76e177f5bfc291c3c5c0efd1bd32f0"
      },
      "downloads": -1,
      "filename": "mashumaro-3.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "4b00e6d7834cc5476a0df219d4e4fdd4",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 82163,
      "upload_time": "2022-12-02T22:18:06",
      "upload_time_iso_8601": "2022-12-02T22:18:06.884992Z",
      "url": "https://files.pythonhosted.org/packages/46/37/45d7871fa7d5dba5e84e1b852b71cf2298361fa1524bc7bb7d39122deca2/mashumaro-3.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "de4c9c5a03ec5e1d862ea1099ecdf1f510615c05a38fcf6b144fc592a0207318",
        "md5": "cc1eb22994ac78e353fd5540e672b612",
        "sha256": "5b12b56556373d2a907d54b3d61f59f5a1f3670a98040721aff19b8c476fd994"
      },
      "downloads": -1,
      "filename": "mashumaro-3.2.tar.gz",
      "has_sig": false,
      "md5_digest": "cc1eb22994ac78e353fd5540e672b612",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 65975,
      "upload_time": "2022-12-02T22:18:10",
      "upload_time_iso_8601": "2022-12-02T22:18:10.425677Z",
      "url": "https://files.pythonhosted.org/packages/de/4c/9c5a03ec5e1d862ea1099ecdf1f510615c05a38fcf6b144fc592a0207318/mashumaro-3.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}