{
  "info": {
    "author": "Jiri Helebrant",
    "author_email": "jiri.helebrant@nic.cz",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3"
    ],
    "description": "<img alt=\"CZ.NIC\" src=\"https://www.nic.cz/static/www.nic.cz/images/logo_en.png\" align=\"right\" /><br/><br/>\n\n# `dns-crawler`\n\n> A crawler for getting info about *(possibly a huge number of)* DNS domains\n\n# What does it do?\n\nDespite the name, the crawler gets info for more services than just DNS:\n\n- DNS:\n  - all A/AAAA records (for the 2nd level domain and `www.` subdomain), annotated with GeoIP\n  - TXT records (with SPF and DMARC parsed for easier filtering)\n  - TLSA (for the 2nd level domain and `www.` subdomain)\n  - MX\n  - DNSSEC validation\n  - nameservers:\n    - each server IP annotated with GeoIP\n    - HOSTNAME.BIND, VERSION.BIND, AUTHORS.BIND and fortune (also for all IPs)\n  - users can add custom additional RRs in the config file\n- E-mail (for every server from MX):\n  - SMTP server banners\n  - TLSA records\n- Web:\n  - HTTP status & headers (inc. parsed cookies) for ports 80 & 443 on each IP from A/AAAA records\n  - certificate info for HTTPS (optionally with an entire cert chain)\n  - webpage content (optional)\n  - everything of the above is saved for each _step_ in the redirect history – the crawler follows redirects until it gets a non-redirecting status or hits a configurable limit\n  - HSTS preload list status for a domain\n\nAnswers from name and mail servers are cached, so the crawler shouldn't flood hosting providers with repeating queries.\n \nIf you need to configure a firewall, the crawler connects to ports `53` (both UDP and TCP), `25` (TCP), `80` (TCP), and `443` (TCP for now, but we might add UDP with HTTP3…).\n\nSee [`result-example.json`](result-example.json) to get an idea what the resulting JSON looks like.\n\n## How fast is it anyway?\n\nA single fairly modern laptop on ~50Mbps connection can crawl the entire *.cz* zone (~1.3M second level domains) overnight, give or take, using 8 workers per CPU thread.\n\nSince the crawler is designed to be parallel, the actual speed depends almost entirely on the worker count. And it can scale accross multiple machines almost infinitely, so should you need a million domains crawled in an hour, you can always just throw more hardware at it (see below).\n\nCZ.NIC uses 4 machines in production (8-core Xeon Bronze 3106, 16 GB RAM, gigabit line) and crawling the entire *.cz* zone takes under 3 hours.\n\n## Installation\n\nCreate and activate a virtual environment:\n\n```bash\nmkdir dns-crawler\ncd dns-crawler\npython3 -m venv .venv\nsource .venv/bin/activate\n```\n\nInstall `dns-crawler`:\n\n```bash\npip install dns-crawler\n```\n\nThis is enough to make the crawler work, but you will probably get `AttributeError: module 'dns.message' has no attribute 'Truncated'` for a lot of domains. This is because the crawler uses current `dnspython`, but the last release on PyPI is ages behind the current code. It can be fixed easily just by installing `dnspython` from git:\n\n```bash\npip install -U git+https://github.com/rthalley/dnspython.git\n```\n\n(PyPI [doesn't allow us](https://github.com/pypa/pip/issues/6301) to specify the git url it in dependencies unfortunately)\n\n## Basic usage\n\nTo run a single-threaded crawler (suitable for small domain counts), just pass a domain list:\n\n```\n$ echo -e \"nic.cz\\nnetmetr.cz\\nroot.cz\" > domain-list.txt\n$ dns-crawler domain-list.txt > results.json\n[2019-12-03 11:03:54] Reading domains from domain-list.txt.\n[2019-12-03 11:03:54] Read 3 domains.\n[2019-12-03 11:03:55] 1/3\n[2019-12-03 11:03:55] 2/3\n[2019-12-03 11:03:56] 3/3\n[2019-12-03 11:03:56] Finished.\n```\n\nResults are printed to stdout – JSON for every domain, separated by `\\n`:\n\n```\n$ cat results.json\n{\"domain\": \"nic.cz\", \"timestamp\": \"2019-12-03 10:03:55\", \"results\": {…}}\n{\"domain\": \"netmetr.cz\", \"timestamp\": \"2019-12-03 10:03:55\", \"results\": {…}}\n{\"domain\": \"root.cz\", \"timestamp\": \"2019-12-03 10:03:56\", \"results\": {…}}\n```\n\nIf you want formatted JSONs, just pipe the output through [jq](https://stedolan.github.io/jq/) or your tool of choice: `dns-crawler domain-list.txt | jq`.\n\n## Multithreaded crawling\n\nThe crawler can run with multiple threads to speed things up when you have a lot of domains to go through. Communication betweeen the controller and workers is done through Redis (this makes it easy to run workers on multiple machines if needed, see below).\n\nStart Redis. The exact command depends on your system.\n\nFeed domains into queue and wait for results:\n\n```\n$ dns-crawler-controller domain-list.txt > result.json\n```\n\n(in another shell) Start workers which process the domains and return results to the controller:\n\n```\n$ dns-crawler-workers\n```\n\nUsing the controller also gives you caching of repeating queries (mailserver banners and hostname.bind/version.bind for nameservers) for free.\n\n### Redis configuration\n\nNo special config needed, but increase the memory limit if you have a lot of domains to process (eg. `maxmemory 2G`). You can also disable disk snapshots to save some I/O time (comment out the `save …` lines). If you're not already using Redis for other things, read its log – there are often some recommendations for performance improvements.\n\n## Results\n\nResults are printed to the main process' (`dns-crawler` or `dns-crawler-controller`) stdout – JSON for every domain, separated by `\\n`:\n\n```\n…\n[2019-05-03 07:38:17] 2/3\n{\"domain\": \"nic.cz\", \"timestamp\": \"2019-09-24T05:28:06.536991\", \"results\": {…}}\n…\n```\n\nThe progress info with timestamp is printed to stderr, so you can save just the output easily – `dns-crawler list.txt > results`.\n\nA JSON schema for the output JSON is included in this repository: [`result-schema.json`](result-schema.json), and also an example for nic.cz: [`result-example.json`](result-example.json).\n\nThere are several tools for schema validation, viewing, and even code generation.\n\nTo validate a result against schema (CI is set up to do it automatically):\n\n```bash\n$ pip install jsonschema\n$ jsonschema -i result-example.json result-schema.json # if it prints nothing, it's valid\n```\n\nOr, if you don't loathe JS, `ajv` has a much better output:\n\n```bash\n$ npm i -g ajv\n$ ajv validate -s result-schema.json -d result-example.json\n```\n\n### Storing crawler results\n\nIn production, CZ.NIC uses Hadoop cluster to store the results file after the crawler run is over – see a script in `utils/crawler-hadoop.sh` (pushes the results file to Hadoop and notifies a Mattermost channel).\n\nYou can even pipe the output right to hadoop without even storing it on your disk:\n\n```\ndns-crawler-controller domain-list.txt | ssh user@hadoop-node \"HADOOP_USER_NAME=… hadoop fs -put - /path/to/results.json;\"\n```\n\n### Working with the results\n\n- [R package for dns-crawler output processing](https://gitlab.labs.nic.cz/adam/dnscrawler.parser)\n\n## Usage in Python code\n\nJust import and use the `process_domain` function like so:\n\n```\n$ python\n>>> from dns_crawler.crawl import process_domain\n>>> result = process_domain(\"nic.cz\")\n>>> result\n{'domain': 'nic.cz', 'timestamp': '2019-09-13T09:21:10.136303', 'results': { … \n>>>\n>>> result[\"results\"][\"DNS_LOCAL\"][\"DNS_AUTH\"]\n[{'value': 'a.ns.nic.cz.'}, {'value': 'b.ns.nic.cz.'}, {'value': 'd.ns.nic.cz.'}]\n```\n\nThe `process_domain` function returns Python `dict`s. If you want json, use `from dns_crawler.crawl import get_json_result` instead:\n\n```\n$ python\n>>> from dns_crawler.crawl import get_json_result\n>>> result = get_json_result(\"nic.cz\")\n>>> result\n# same as above, just converted to JSON\n```\n\nThis function just calls `crawl_domain` and converts the `dict` to JSON string. It's used by the workers, so the conversion is done by them to take some pressure off the controller process.\n\n\n## Config file\n\nGeoIP DB paths, DNS resolver IP(s), and timeouts are read from `config.yml` in the working directory, if present.\n\nThe default values are:\n\n```yaml\ngeoip:\n  country: /usr/share/GeoIP/GeoLite2-Country.mmdb\n  asn: /usr/share/GeoIP/GeoLite2-ASN.mmdb\n  # Using commercial DBs instead:\n  # country: /usr/share/GeoIP/GeoIP2-Country.mmdb\n  # isp: /usr/share/GeoIP/GeoIP2-ISP.mmdb\ndns:\n  resolvers:\n    - 193.17.47.1  # https://www.nic.cz/odvr/\n  check_www: True  # get A/AAAA/TLSA records for the `www.` subdomain (and use them for WEB_* stuff later, too)\n  auth_chaos_txt:  # CH TXT to query the domain's auth server for (eg. `authors.bind` or `fortune`)\n    - hostname.bind\n    - version.bind\n  # add 'additional' here to get more DNS records, more about that in a dedicated section\n  # additional:\n  #  - SPF\ntimeouts:\n  job: 80  # seconds, overall job (one domain crawl) duration when using dns-crawler-controller, jobs will fail after that and you can retry/abort them as needed\n  dns: 2  # seconds, timeout for dns queries\n  http: 2  # seconds, connection timeout for HTTP(S)/TLS requests\n  http_read: 5  # seconds, read timeout when saving web content\n  cache: 900  # TTL for cached responses (used for mail and name servers), they will expire after this much seconds since their last use\nmail:\n  get_banners: False  # connect to SMTP servers and save banners they send (you might want to turn it off if your ISP is touchy about higher traffic on port 25, or just to save time)\n  ports: # ports to use for TLSA records (_PORT._tcp.…) and mailserver banners\n    - 25\n    - 465\n    - 587\nweb:\n  save_content: False  # save website content – beware, setting this to True will output HUGE files for higher domain counts\n  strip_html: True  # when saving web content, save just text (strip HTML tags, scripts, CSS, and abundant whitespace)\n  save_binary: True  # save even binary content (eg. application/octet-stream) in base64 data uris\n  max_redirects: 6  # follow HTTP redirrects (301, 302, …) until this limit\n  user_agent: Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36  # User-Agent header to use for HTTP(S) requests\n  accept_language: en-US;q=0.9,en;q=0.8  # Accept-Language header to use for HTTP(S) requests\n  content_size_limit: 5120000  # Truncate the saved content to this number of chacters (or bytes for binary content). If you choose to use strip_html, the content is truncated _after_ that. Huge values (hunderds of MB, depending on your RAM size and number of workers) can cause UnpicklingError when reading the result from Redis.\n  max_ips_per_domain: null  # max A/AAAA records to try to get web content from for each www/nonwww–80/443-ipv4/6 combination, integer or null for unlimited. Some domains take it the extreme (> 20 records) and have broken HTTPS on webservers, so adjust HTTP and job timeouts accordingly…\n  check_http: True  # Try to connect via HTTP (port 80)\n  check_https: True  # Try to connect via HTTPS (port 443)\n  check_ipv4: True  # Try to connect to IP(s) from A records\n  check_ipv6: True  # Try to connect to IP(s) from AAAA records\n  save_intermediate_steps: True  # Save intermediate redirect steps (otherwise save just the last one).\n  flatten_output: False  # If only one of www/nonwww–ipv4/ipv6–http/https combinations is left, save it directly into \"WEB\" field. Also save the per-ip object directly into web results if htere was only one Ip (either from DNS of by setting max_ips_per_domain to 1)\n```\n\nIf you're using the multi-threaded crawler (`dns-crawler-controller` & `dns-crawler-workers`), the config is loaded by the controlled and shared with the workers via Redis.\n\nYou can override it on the worker machines if needed – just create a `config.yml` in their working dir (eg. to set different resolver IP(s) or GeoIP paths on each machine). The config is then merged – directives not defined in the worker config are loaded from the controller one (and defaults are used if the're not defined there either).\n\n### Using commercial GeoIP DBs\n\nTell the crawler to use (GeoIP2 Country and ISP) DBs instead of free (GeoLite2 Country and ASN) ones:\n\n```yaml\ngeoip:\n  country: /usr/share/GeoIP/GeoLite2-Country.mmdb\n  #  asn: /usr/share/GeoIP/GeoLite2-ASN.mmdb  # 'asn' is the free DB\n  isp: /usr/share/GeoIP/GeoIP2-ISP.mmdb  # 'isp' is the commercial one\n```\n\n(use either absolute paths or relative to the working directory)\n\n`ISP` (paid) database is preferred over `ASN` (free), if both are defined. The difference is described on Maxmind's website: https://dev.maxmind.com/faq/what-is-the-difference-between-the-geoip-isp-and-organization-databases/.\n\nThe free `GeoLite2-Country` seems to be a bit inaccurate, especially for IPv6 (it places some CZ.NIC nameservers in Ukraine etc.).\n\n### Getting additional DNS resource records:\n\nYou can easily get some additional RRs (for the 2nd level domain) which aren't included in the crawler by default:\n\n```yaml\ndns:\n  additional:\n    - SPF\n    - CAA\n    - CERT\n    - LOC\n    - SSHFP\n```\n\nSee the [List of DNS record types](https://en.wikipedia.org/wiki/List_of_DNS_record_types) for some ideas. Things like OPENPGPKEY won't work though, because they are intented to be used on a subdomain (generated as a hash of part of e-mail address in this case).\n\nYou can plug a parser for the record by adding a function to the `additional_parsers` enum in `dns_utils.py`. The only one included by default is SPF (since the deprecated SPF record has the same format as SPF from TXT which the crawler is getting by default).\n\n## Command line parameters\n\n### dns-crawler\n\n```\ndns-crawler - a single-threaded crawler to process a small number of domains without a need for Redis\n\nUsage: dns-crawler <file>\n       file - plaintext domain list, one domain per line, empty lines are ignored\n```\n\n### dns-crawler-controller\n\n```\ndns-crawler-controller - the main process controlling the job queue and printing results.\n\nUsage: dns-crawler-controller <file> [redis]\n       file - plaintext domain list, one domain per line, empty lines are ignored\n       redis - redis host:port:db, localhost:6379:0 by default\n\nExamples: dns-crawler-controller domains.txt\n          dns-crawler-controller domains.txt 192.168.0.22:4444:0\n          dns-crawler-controller domains.txt redis.foo.bar:7777:2\n          dns-crawler-controller domains.txt redis.foo.bar # port 6379 and DB 0 will be used if not specified\n```\n\nThe controller process uses threads (4 for each CPU core) to create the jobs faster when you give it a lot of domains (>1000× CPU core count).\n\nIt's *much* faster on (more) modern machines – eg. i7-7600U (with HT) in a laptop does about 19k jobs/s, while server with Xeon X3430 (without HT) does just about ~7k (both using 16 threads, as they both appear as 4 core to the system).\n\nTo cancel the process, just send a kill signal or hit `Ctrl-C` any time. The process will perform cleanup and exit.\n\n### dns-crawler-workers\n\n```\ndns-crawler-workers - a process that spawns crawler workers.\n\nUsage: dns-crawler-workers [count] [redis]\n       count - worker count, 8 workers per CPU core by default\n       redis - redis host:port:db, localhost:6379:0 by default\n\nExamples: dns-crawler-workers 8\n          dns-crawler-workers 24 192.168.0.22:4444:0\n          dns-crawler-workers 16 redis.foo.bar:7777:2\n          dns-crawler-workers 16 redis.foo.bar # port 6379 and DB 0 will be used if not specified\n```\n\nTrying to use more than 24 workers per CPU core will result in a warning (and countdown before it actually starts the workers):\n\n```\n$ dns-crawler-workers 999\nWhoa. You are trying to run 999 workers on 4 CPU cores. It's easy toscale\nacross multiple machines, if you need to. See README.md for details.\n\nCancel now (Ctrl-C) or have a fire extinguisher ready.\n5 - 4 - 3 -\n```\n\nStopping works the same way as with the controller process – `Ctrl-C` (or kill signal) will finish the current job(s) and exit.\n\n## Resuming work\n\nStopping the workers won't delete the jobs from Redis. So, if you stop the `dns-crawler-workers` process and then start a new one (perhaps to use different worker count…), it will pick up the unfinished jobs and continue.\n\nThis can also be used change the worker count if it turns out to be too low or high for your machine or network:\n\n- to reduce the worker count, just stop the `dns-crawler-workers` process and start a new one with a new count\n- to increase the worker count, either use the same approach, or just start a second `dns-crawler-workers` process in another shell, the worker count will just add up\n- scaling to multiple machines works the same way, see below\n\n## Running on multiple machines\n\nSince all communication between the controller and workers is done through Redis, it's easy to scale the crawler to any number of machines:\n\n```\nmachine-1                     machine-1\n┬───────────────────────────┐         ┬─────────────────────┐\n│    dns-crawler-controller │ ------- │ dns-crawler-workers │\n│             +             │         └─────────────────────┘\n│           redis           │\n│             +             │\n│        DNS resolver       │\n└───────────────────────────┘\n                                      machine-2\n                                      ┬─────────────────────┐\n                              ------- │ dns-crawler-workers │\n                                      └─────────────────────┘\n                                      …\n                                      …\n\n                                      machine-n\n                                      ┬─────────────────────┐\n                              _______ │ dns-crawler-workers │\n                                      └─────────────────────┘\n```\n\nJust tell the workers to connect to the shared Redis on the main server, eg.:\n\n```\n$ dns-crawler-workers 24 192.168.0.2:6379\n                    ^            ^\n                    24 threads   redis host\n```\n\nMake sure to run the workers with ~same Python version on these machines, otherwise you'll get `unsupported pickle protocol` errors. See the [pickle protocol versions in Python docs](https://docs.python.org/3.8/library/pickle.html#data-stream-format).\n\nThe DNS resolver doesn't have to be on a same machine as the `dns-crawler-controller`, of course – just set it's IP in `config.yml`. The crawler is tested primarily with CZ.NIC's [Knot Resolver](https://www.knot-resolver.cz/), but should work with any sane resolver supporting DNSSEC. Systemd's `systemd-resolved` seems to be really slow though.\n\nSame goes for Redis, you can point both controller and workers to a separate machine running Redis (don't forget to point them to an empty DB if you're using Redis for other things than the dns-crawler, it uses `0` by default).\n\n## Updating dependencies\n\nMaxMind updates GeoIP DBs on Tuesdays, so it may be a good idea to set a cron job to keep them fresh. More about that on [maxmind.com: Automatic Updates for GeoIP2](https://dev.maxmind.com/geoip/geoipupdate/).\n\nIf you want reliable results for HSTS (= whether the given domain was included in the preload list at the time it was crawled), update the list regularly:\n\n```bash\npip install -U hstspreload\n```\n\nThe `utils/run-crawler.sh` example script does it for you on each run, feel free to adapt it to your environment.\n\nIf you use multiple machines to run the workers, don't forget to update GeoIP and hstspreload on all of them.\n\n## Monitoring\n\n### Command line\n\n```\n$ rq info\ndefault      |████████████████████ 219458\n1 queues, 219458 jobs total\n\n0 workers, 1 queues\n```\n\n### Web interface\n\n```\n$ pip install rq-dashboard\n$ rq-dashboard\nRQ Dashboard version 0.4.0                                                 \n * Serving Flask app \"rq_dashboard.cli\" (lazy loading)                            \n * Environment: production                                                \n   WARNING: Do not use the development server in a production environment. \n   Use a production WSGI server instead.                                          \n * Debug mode: off                            \n * Running on http://0.0.0.0:9181/ (Press CTRL+C to quit)\n ```\n\n<a href=\"https://i.vgy.me/sk7zWa.png\">\n<img alt=\"RQ Dashboard screenshot\" src=\"https://i.vgy.me/sk7zWa.png\" width=\"40%\">\n</a>\n<a href=\"https://i.vgy.me/4y5Zee.png\">\n<img alt=\"RQ Dashboard screenshot\" src=\"https://i.vgy.me/4y5Zee.png\" width=\"40%\">\n</a>\n\n## Tests\n\nSome basic tests are in the `tests` directory in this repo. If you want to run them manually, take a look at the `test` stage jobs in `.gitlab-ci.yml`. Basically it just downloads free GeoIP DBs, tells the crawler to use them, and crawles some domains, checking values in JSON output. It runs the tests twice – first with the default DNS resolvers (ODVR) and then with system one(s).\n\nIf you're looking into writing some additional tests, be aware that some Docker containers used in GitLab CI don't have IPv6 configured (even if it's working on the host machine), so checking for eg. `WEB6_80_www_VENDOR` will fail without additional setup.\n\n\n## OS support\n\nThe crawler is developed primarily for Linux, but it should work on any OS supported by Python – at least the worker part (but the controller should work too, if you manage to get a Redis server running on your OS).\n\nOne exception is Windows, because it [doesn't support `fork()`](https://github.com/rq/rq/issues/859), but it's possible to get it working under WSL (Windows Subsystem for Linux):\n\n![win10 screenshot](https://i.vgy.me/emJjGN.png)\n\n…so you can turn a gaming machine into an internet crawler quite easily.\n\n\n## Bug reporting\n\nPlease create [issues in this Gitlab repo](https://gitlab.labs.nic.cz/adam/dns-crawler/issues).",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://gitlab.labs.nic.cz/adam/dns-crawler",
    "keywords": "crawler,dns,http,https",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dns-crawler",
    "package_url": "https://pypi.org/project/dns-crawler/",
    "platform": "",
    "project_url": "https://pypi.org/project/dns-crawler/",
    "project_urls": {
      "Homepage": "https://gitlab.labs.nic.cz/adam/dns-crawler"
    },
    "release_url": "https://pypi.org/project/dns-crawler/1.4.4/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "A crawler for getting info about DNS domains and services attached to them.",
    "version": "1.4.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9855130,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "60776df71f82d2ba5d77d1b4328a6866f110f3cddcd8a81fbcfb26621dbaa53e",
        "md5": "1ac8904339045c441befdaef42ce5d99",
        "sha256": "fbf3c0301c09c190a32260759f3952725ad0e92d52c56c50d3503e710e071de1"
      },
      "downloads": -1,
      "filename": "dns-crawler-1.4.4.tar.gz",
      "has_sig": false,
      "md5_digest": "1ac8904339045c441befdaef42ce5d99",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 68339,
      "upload_time": "2020-04-23T10:47:13",
      "upload_time_iso_8601": "2020-04-23T10:47:13.910851Z",
      "url": "https://files.pythonhosted.org/packages/60/77/6df71f82d2ba5d77d1b4328a6866f110f3cddcd8a81fbcfb26621dbaa53e/dns-crawler-1.4.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}