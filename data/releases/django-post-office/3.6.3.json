{
  "info": {
    "author": "Selwin Ong",
    "author_email": "selwin.ong@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Communications :: Email",
      "Topic :: Internet :: WWW/HTTP",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# Django Post Office\n\nDjango Post Office is a simple app to send and manage your emails in\nDjango. Some awesome features are:\n\n-   Allows you to send email asynchronously\n-   Multi backend support\n-   Supports HTML email\n-   Supports inlined images in HTML email\n-   Supports database based email templates\n-   Supports multilingual email templates (i18n)\n-   Built in scheduling support\n-   Works well with task queues like [RQ](http://python-rq.org) or\n    [Celery](http://www.celeryproject.org)\n-   Uses multiprocessing (and threading) to send a large number of\n    emails in parallel\n\n## Dependencies\n\n-   [django \\>= 2.2](https://djangoproject.com/)\n-   [jsonfield](https://github.com/rpkilby/jsonfield)\n-   [bleach](https://bleach.readthedocs.io/)\n\nWith this optional dependency, HTML emails are nicely rendered\ninside the Django admin backend. Without this library, all HTML tags\nwill otherwise be stripped for security reasons.\n\n## Installation\n\n[![Build\nStatus](https://travis-ci.org/ui/django-post_office.png?branch=master)](https://travis-ci.org/ui/django-post_office) [![PyPI version](https://img.shields.io/pypi/v/django-post_office.svg)](https://pypi.org/project/django-post_office/) ![Software license](https://img.shields.io/pypi/l/django-post_office.svg)\n\nInstall from PyPI (or [manually download from PyPI](http://pypi.python.org/pypi/django-post_office)):\n\n```sh\npip install django-post_office\n```\n\nAdd `post_office` to your INSTALLED_APPS in django's `settings.py`:\n\n```python\nINSTALLED_APPS = (\n    # other apps\n    \"post_office\",\n)\n```\n\nRun `migrate`:\n\n```sh\npython manage.py migrate\n```\n\nSet `post_office.EmailBackend` as your `EMAIL_BACKEND` in Django's `settings.py`:\n\n```python\nEMAIL_BACKEND = 'post_office.EmailBackend'\n```\n\n## Quickstart\n\nSend a simple email is really easy:\n\n```python\nfrom post_office import mail\n\nmail.send(\n    'recipient@example.com', # List of email addresses also accepted\n    'from@example.com',\n    subject='My email',\n    message='Hi there!',\n    html_message='Hi <strong>there</strong>!',\n)\n```\n\nIf you want to use templates, ensure that Django's admin interface is\nenabled. Create an `EmailTemplate` instance via `admin` and do the\nfollowing:\n\n```python\nfrom post_office import mail\n\nmail.send(\n    'recipient@example.com', # List of email addresses also accepted\n    'from@example.com',\n    template='welcome_email', # Could be an EmailTemplate instance or name\n    context={'foo': 'bar'},\n)\n```\n\nThe above command will put your email on the queue so you can use the\ncommand in your webapp without slowing down the request/response cycle\ntoo much. To actually send them out, run\n`python manage.py send_queued_mail`. You can schedule this management\ncommand to run regularly via cron:\n\n    * * * * * (/usr/bin/python manage.py send_queued_mail >> send_mail.log 2>&1)\n\n## Usage\n\n### mail.send()\n\n`mail.send` is the most important function in this library, it takes\nthese arguments:\n\n| Argument | Required | Description |\n| --- | --- | --- |\n| recipients | Yes | List of recipient email addresses |\n| sender | No | Defaults to `settings.DEFAULT_FROM_EMAIL`, display name like `John <john@a.com>` is allowed |\n| subject | No | Email subject (if `template` is not specified) |\n| message | No | Email content (if `template` is not specified) |\n| html_message | No | HTML content (if `template` is not specified) |\n| template | No | `EmailTemplate` instance or name of template |\n| language | No | Language in which you want to send the email in (if you have multilingual email templates). |\n| cc | No | List of emails, will appear in `cc` field |\n| bcc | No | List of emails, will appear in `bcc` field |\n| attachments | No | Email attachments - a dict where the keys are the filenames and the values are files, file-like-objects or path to file |\n| context | No | A dict, used to render templated email |\n| headers | No | A dictionary of extra headers on the message |\n| scheduled_time | No | A date/datetime object indicating when the email should be sent |\n| expires_at | No | If specified, mails that are not yet sent won't be delivered after this date. |\n| priority | No | `high`, `medium`, `low` or `now` (sent immediately) |\n| backend | No | Alias of the backend you want to use, `default` will be used if not specified. |\n| render_on_delivery | No | Setting this to `True` causes email to be lazily rendered during delivery. `template` is required when `render_on_delivery` is True. With this option, the full email content is never stored in the DB. May result in significant space savings if you're sending many emails using the same template. |\n\nHere are a few examples.\n\nIf you just want to send out emails without using database templates.\nYou can call the `send` command without the `template` argument.\n\n```python\nfrom post_office import mail\n\nmail.send(\n    ['recipient1@example.com'],\n    'from@example.com',\n    subject='Welcome!',\n    message='Welcome home, {{ name }}!',\n    html_message='Welcome home, <b>{{ name }}</b>!',\n    headers={'Reply-to': 'reply@example.com'},\n    scheduled_time=date(2014, 1, 1),\n    context={'name': 'Alice'},\n)\n```\n\n`post_office` is also task queue friendly. Passing `now` as priority\ninto `send_mail` will deliver the email right away (instead of queuing\nit), regardless of how many emails you have in your queue:\n\n```python\nfrom post_office import mail\n\nmail.send(\n    ['recipient1@example.com'],\n    'from@example.com',\n    template='welcome_email',\n    context={'foo': 'bar'},\n    priority='now',\n)\n```\n\nThis is useful if you already use something like [django-rq](https://github.com/ui/django-rq) to send emails\nasynchronously and only need to store email related activities and logs.\n\nIf you want to send an email with attachments:\n\n```python\nfrom django.core.files.base import ContentFile\nfrom post_office import mail\n\nmail.send(\n    ['recipient1@example.com'],\n    'from@example.com',\n    template='welcome_email',\n    context={'foo': 'bar'},\n    priority='now',\n    attachments={\n        'attachment1.doc': '/path/to/file/file1.doc',\n        'attachment2.txt': ContentFile('file content'),\n        'attachment3.txt': {'file': ContentFile('file content'), 'mimetype': 'text/plain'},\n    }\n)\n```\n\n### Template Tags and Variables\n\n`post-office` supports Django's template tags and variables. For\nexample, if you put `Hello, {{ name }}` in the subject line and pass in\n`{'name': 'Alice'}` as context, you will get `Hello, Alice` as subject:\n\n```python\nfrom post_office.models import EmailTemplate\nfrom post_office import mail\n\nEmailTemplate.objects.create(\n    name='morning_greeting',\n    subject='Morning, {{ name|capfirst }}',\n    content='Hi {{ name }}, how are you feeling today?',\n    html_content='Hi <strong>{{ name }}</strong>, how are you feeling today?',\n)\n\nmail.send(\n    ['recipient@example.com'],\n    'from@example.com',\n    template='morning_greeting',\n    context={'name': 'alice'},\n)\n\n# This will create an email with the following content:\nsubject = 'Morning, Alice',\ncontent = 'Hi alice, how are you feeling today?'\ncontent = 'Hi <strong>alice</strong>, how are you feeling today?'\n```\n\n### Multilingual Email Templates\n\nYou can easily create email templates in various different languages.\nFor example:\n\n```python\ntemplate = EmailTemplate.objects.create(\n    name='hello',\n    subject='Hello world!',\n)\n\n# Add an Indonesian version of this template:\nindonesian_template = template.translated_templates.create(\n    language='id',\n    subject='Halo Dunia!'\n)\n```\n\nSending an email using template in a non default language is similarly easy:\n\n```python\nmail.send(\n    ['recipient@example.com'],\n    'from@example.com',\n    template=template, # Sends using the default template\n)\n\nmail.send(\n    ['recipient@example.com'],\n    'from@example.com',\n    template=template,\n    language='id', # Sends using Indonesian template\n)\n```\n\n### Inlined Images\n\nOften one wants to render images inside a template, which are attached\nas inlined `MIMEImage` to the outgoing email. This requires a slightly\nmodified Django Template Engine, keeping a list of inlined images, which\nlater will be added to the outgoing message.\n\nFirst we must add a special Django template backend to our list of template engines:\n\n```python\nTEMPLATES = [\n    {\n        ...\n    }, {\n        'BACKEND': 'post_office.template.backends.post_office.PostOfficeTemplates',\n        'APP_DIRS': True,\n        'DIRS': [],\n        'OPTIONS': {\n            'context_processors': [\n                'django.contrib.auth.context_processors.auth',\n                'django.template.context_processors.debug',\n                'django.template.context_processors.i18n',\n                'django.template.context_processors.media',\n                'django.template.context_processors.static',\n                'django.template.context_processors.tz',\n                'django.template.context_processors.request',\n            ]\n        }\n    }\n]\n```\n\nthen we must tell Post-Office to use this template engine:\n\n```python\nPOST_OFFICE = {\n    'TEMPLATE_ENGINE': 'post_office',\n}\n```\n\nIn templates used to render HTML for emails add\n\n```\n{% load post_office %}\n\n<p>... somewhere in the body ...</p>\n<img src=\"{% inline_image 'path/to/image.png' %}\" />\n```\n\nHere the templatetag named `inline_image` is used to keep track of\ninlined images. It takes a single parameter. This can either be the\nrelative path to an image file located in one of the `static`\ndirectories, or the absolute path to an image file, or an image-file\nobject itself. Templates rendered using this templatetag, render a\nreference ID for each given image, and store these images inside the\ncontext of the adopted template engine. Later on, when the rendered\ntemplate is passed to the mailing library, those images will be\ntransferred to the email message object as `MIMEImage`-attachments.\n\nTo send an email containing both, a plain text body and some HTML with\ninlined images, use the following code snippet:\n\n```python\nfrom django.core.mail import EmailMultiAlternatives\n\nsubject, body = \"Hello\", \"Plain text body\"\nfrom_email, to_email = \"no-reply@example.com\", \"john@example.com\"\nemail_message = EmailMultiAlternatives(subject, body, from_email, [to_email])\ntemplate = get_template('email-template-name.html', using='post_office')\ncontext = {...}\nhtml = template.render(context)\nemail_message.attach_alternative(html, 'text/html')\ntemplate.attach_related(email_message)\nemail_message.send()\n```\n\nTo send an email containing HTML with inlined images, but without a\nplain text body, use this code snippet:\n\n```python\nfrom django.core.mail import EmailMultiAlternatives\n\nsubject, from_email, to_email = \"Hello\", \"no-reply@example.com\", \"john@example.com\"\ntemplate = get_template('email-template-name.html', using='post_office')\ncontext = {...}\nhtml = template.render(context)\nemail_message = EmailMultiAlternatives(subject, html, from_email, [to_email])\nemail_message.content_subtype = 'html'\ntemplate.attach_related(email_message)\nemail_message.send()\n```\n\n### Custom Email Backends\n\nBy default, `post_office` uses django's `smtp.EmailBackend`. If you want\nto use a different backend, you can do so by configuring `BACKENDS`.\n\nFor example if you want to use [django-ses](https://github.com/hmarr/django-ses):\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'BACKENDS': {\n        'default': 'smtp.EmailBackend',\n        'ses': 'django_ses.SESBackend',\n    }\n}\n```\n\nYou can then choose what backend you want to use when sending mail:\n\n```python\n# If you omit `backend_alias` argument, `default` will be used\nmail.send(\n    ['recipient@example.com'],\n    'from@example.com',\n    subject='Hello',\n)\n\n# If you want to send using `ses` backend\nmail.send(\n    ['recipient@example.com'],\n    'from@example.com',\n    subject='Hello',\n    backend='ses',\n)\n```\n\n### Management Commands\n\n-   `send_queued_mail` - send queued emails, those aren't successfully\n    sent will be marked as `failed`. Accepts the following arguments:\n\n  | Argument | Description |\n  | --- | --- |\n  |`--processes` or `-p` | Number of parallel processes to send email. Defaults to 1 |\n  | `--lockfile` or `-L` | Full path to file used as lock file. Defaults to `/tmp/post_office.lock` |\n\n\n-   `cleanup_mail` - delete all emails created before an X number of\n    days (defaults to 90).\n\n| Argument | Description |\n| --- | --- |\n| `--days` or `-d` | Email older than this argument will be deleted. Defaults to 90 |\n| `--delete-attachments` | Flag to delete orphaned attachment records and files on disk. If not specified, attachments won't be deleted. |\n\nYou may want to set these up via cron to run regularly:\n\n    * * * * * (cd $PROJECT; python manage.py send_queued_mail --processes=1 >> $PROJECT/cron_mail.log 2>&1)\n    0 1 * * * (cd $PROJECT; python manage.py cleanup_mail --days=30 --delete-attachments >> $PROJECT/cron_mail_cleanup.log 2>&1)\n\n\n## Settings\n\nThis section outlines all the settings and configurations that you can\nput in Django's `settings.py` to fine tune `post-office`'s behavior.\n\n\n### Batch Size\n\nIf you may want to limit the number of emails sent in a batch (sometimes\nuseful in a low memory environment), use the `BATCH_SIZE` argument to\nlimit the number of queued emails fetched in one batch.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'BATCH_SIZE': 50,\n}\n```\n\n### Default Priority\n\nThe default priority for emails is `medium`, but this can be altered by\nsetting `DEFAULT_PRIORITY`. Integration with asynchronous email backends\n(e.g. based on Celery) becomes trivial when set to `now`.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'DEFAULT_PRIORITY': 'now',\n}\n```\n\n### Override Recipients\n\nDefaults to `None`. This option is useful if you want to redirect all\nemails to specified a few email for development purposes.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'OVERRIDE_RECIPIENTS': ['to@example.com', 'to2@example.com'],\n}\n```\n\n### Message-ID\n\nThe SMTP standard requires that each email contains a unique [Message-ID](https://tools.ietf.org/html/rfc2822#section-3.6.4). Typically the Message-ID consists of two parts separated by the `@`\nsymbol: The left part is a generated pseudo random number. The right\npart is a constant string, typically denoting the full qualified domain\nname of the sending server.\n\nBy default, **Django** generates such a Message-ID during email\ndelivery. Since **django-post_office** keeps track of all delivered\nemails, it can be very useful to create and store this Message-ID while\ncreating each email in the database. This identifier then can be looked\nup in the Django admin backend.\n\nTo enable this feature, add this to your Post-Office settings:\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'MESSAGE_ID_ENABLED': True,\n}\n```\n\nIt can further be fine tuned, using for instance another full qualified\ndomain name:\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'MESSAGE_ID_ENABLED': True,\n    'MESSAGE_ID_FQDN': 'example.com',\n}\n```\n\nOtherwise, if `MESSAGE_ID_FQDN` is unset (the default),\n**django-post_office** falls back to the DNS name of the server, which\nis determined by the network settings of the host.\n\n### Retry\n\nNot activated by default. You can automatically requeue failed email deliveries.\nYou can also configure failed deliveries to be retried after a specific time interval.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'MAX_RETRIES': 4,\n    'RETRY_INTERVAL': datetime.timedelta(minutes=15),  # Schedule to be retried 15 minutes later\n}\n```\n\n### Log Level\n\nLogs are stored in the database and is browsable via Django admin.\nThe default log level is 2 (logs both successful and failed deliveries)\nThis behavior can be changed by setting `LOG_LEVEL`.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'LOG_LEVEL': 1, # Log only failed deliveries\n}\n```\n\nThe different options are:\n\n* `0` logs nothing\n* `1` logs only failed deliveries\n* `2` logs everything (both successful and failed delivery attempts)\n\n### Sending Order\n\nThe default sending order for emails is `-priority`, but this can be\naltered by setting `SENDING_ORDER`. For example, if you want to send\nqueued emails in FIFO order :\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'SENDING_ORDER': ['created'],\n}\n```\n\n### Context Field Serializer\n\nIf you need to store complex Python objects for deferred rendering (i.e.\nsetting `render_on_delivery=True`), you can specify your own context\nfield class to store context variables. For example if you want to use\n[django-picklefield](https://github.com/gintas/django-picklefield/tree/master/src/picklefield):\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'CONTEXT_FIELD_CLASS': 'picklefield.fields.PickledObjectField',\n}\n```\n\n`CONTEXT_FIELD_CLASS` defaults to `jsonfield.JSONField`.\n\n### Logging\n\nYou can configure `post-office`'s logging from Django's `settings.py`.\nFor example:\n\n```python\nLOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"post_office\": {\n            \"format\": \"[%(levelname)s]%(asctime)s PID %(process)d: %(message)s\",\n            \"datefmt\": \"%d-%m-%Y %H:%M:%S\",\n        },\n    },\n    \"handlers\": {\n        \"post_office\": {\n            \"level\": \"DEBUG\",\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"post_office\"\n        },\n        # If you use sentry for logging\n        'sentry': {\n            'level': 'ERROR',\n            'class': 'raven.contrib.django.handlers.SentryHandler',\n        },\n    },\n    'loggers': {\n        \"post_office\": {\n            \"handlers\": [\"post_office\", \"sentry\"],\n            \"level\": \"INFO\"\n        },\n    },\n}\n```\n\n### Threads\n\n`post-office` >= 3.0 allows you to use multiple threads to dramatically\nspeed up the speed at which emails are sent. By default, `post-office`\nuses 5 threads per process. You can tweak this setting by changing\n`THREADS_PER_PROCESS` setting.\n\nThis may dramatically increase the speed of bulk email delivery,\ndepending on which email backends you use. In my tests, multi threading\nspeeds up email backends that use HTTP based (REST) delivery mechanisms\nbut doesn't seem to help SMTP based backends.\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'THREADS_PER_PROCESS': 10,\n}\n```\n\nPerformance\n-----------\n\n### Caching\n\nif Django's caching mechanism is configured, `post_office` will cache\n`EmailTemplate` instances . If for some reason you want to disable\ncaching, set `POST_OFFICE_CACHE` to `False` in `settings.py`:\n\n```python\n## All cache key will be prefixed by post_office:template:\n## To turn OFF caching, you need to explicitly set POST_OFFICE_CACHE to False in settings\nPOST_OFFICE_CACHE = False\n\n## Optional: to use a non default cache backend, add a \"post_office\" entry in CACHES\nCACHES = {\n    'post_office': {\n        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',\n        'LOCATION': '127.0.0.1:11211',\n    }\n}\n```\n\n### send_many()\n\n`send_many()` is much more performant (generates less database queries)\nwhen sending a large number of emails. `send_many()` is almost identical\nto `mail.send()`, with the exception that it accepts a list of keyword\narguments that you'd usually pass into `mail.send()`:\n\n```python\nfrom post_office import mail\n\nfirst_email = {\n    'sender': 'from@example.com',\n    'recipients': ['alice@example.com'],\n    'subject': 'Hi!',\n    'message': 'Hi Alice!'\n}\nsecond_email = {\n    'sender': 'from@example.com',\n    'recipients': ['bob@example.com'],\n    'subject': 'Hi!',\n    'message': 'Hi Bob!'\n}\nkwargs_list = [first_email, second_email]\n\nmail.send_many(kwargs_list)\n```\n\nAttachments are not supported with `mail.send_many()`.\n\n## Running Tests\n\nTo run the test suite:\n\n```python\n`which django-admin.py` test post_office --settings=post_office.test_settings --pythonpath=.\n```\n\nYou can run the full test suite for all supported versions of Django and Python with:\n\n```python\ntox\n```\n\nor:\n\n```python\npython setup.py test\n```\n\n\n## Integration with Celery\n\nIf your Django project runs in a Celery enabled configuration, you can use its worker to send out\nqueued emails. Compared to the solution with cron (see above), or the solution with uWSGI timers\n(see below) this setup has the big advantage that queued emails are send *immediately* after they\nhave been added to the mail queue. The delivery is still performed in a separate and asynchronous\ntask, which prevents sending emails during the request/response-cycle.\n\nIf you [configured Celery](https://docs.celeryproject.org/en/latest/userguide/application.html)\nin your project and started the\n[Celery worker](https://docs.celeryproject.org/en/latest/userguide/workers.html),\nyou should see something such as:\n\n```\n--------------- celery@halcyon.local v4.0 (latentcall)\n--- ***** -----\n-- ******* ---- [Configuration]\n- *** --- * --- . broker:      amqp://guest@localhost:5672//\n- ** ---------- . app:         __main__:0x1012d8590\n- ** ---------- . concurrency: 8 (processes)\n- ** ---------- . events:      OFF (enable -E to monitor this worker)\n- ** ----------\n- *** --- * --- [Queues]\n-- ******* ---- . celery:      exchange:celery(direct) binding:celery\n--- ***** -----\n\n[tasks]\n. post_office.tasks.cleanup_expired_mails\n. post_office.tasks.send_queued_mail\n```\n\nDelivering emails through the Celery worker must be explicitly enabled:\n\n```python\n# Put this in settings.py\nPOST_OFFICE = {\n    ...\n    'CELERY_ENABLED': True,\n}\n```\n\nEmails will then be delivered immediately after they have been queued. In order to make this happen,\nthe project's `celery.py` setup shall invoke the\n[autodiscoverttasks](https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.autodiscover_tasks)\nfunction. In case of a temporary delivery failure, we might want retrying to send those emails by a\nperiodic task. This can be scheduled with a simple\n[Celery beat configuration](https://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#entries),\nfor instance through\n\n```python\napp.conf.beat_schedule = {\n    'send-queued-mail': {\n        'task': 'post_office.tasks.send_queued_mail',\n        'schedule': 600.0,\n    },\n}\n```\n\nThe email queue now will be processed every 10 minutes. If you are using\n[Django Celery Beat](https://django-celery-beat.readthedocs.io/en/latest/),\nthen use the Django-Admin backend and add a periodic tasks for `post_office.tasks.send_queued_mail`.\n\nDepending on your policy, you may also want to remove expired emails from the queue. This can be\ndone by adding another periodic tasks for `post_office.tasks.cleanup_mail`, which may run once a\nweek or month.\n\n\n## Integration with uWSGI\n\nIf setting up Celery is too daunting and you use\n[uWSGI](https://uwsgi-docs.readthedocs.org/en/latest/) as application\nserver, then uWSGI decorators can act as a poor men's scheduler. Just\nadd this short snipped to the project's `wsgi.py` file:\n\n```python\nfrom django.core.wsgi import get_wsgi_application\n\napplication = get_wsgi_application()\n\n# add this block of code\ntry:\n    import uwsgidecorators\n    from django.core.management import call_command\n\n    @uwsgidecorators.timer(10)\n    def send_queued_mail(num):\n        \"\"\"Send queued mail every 10 seconds\"\"\"\n        call_command('send_queued_mail', processes=1)\n\nexcept ImportError:\n    print(\"uwsgidecorators not found. Cron and timers are disabled\")\n```\n\nAlternatively you can also use the decorator\n`@uwsgidecorators.cron(minute, hour, day, month, weekday)`. This will\nschedule a task at specific times. Use `-1` to signal any time, it\ncorresponds to the `*` in cron.\n\nPlease note that `uwsgidecorators` are available only, if the\napplication has been started with **uWSGI**. However, Django's internal\n`./manange.py runserver` also access this file, therefore wrap the block\ninto an exception handler as shown above.\n\nThis configuration can be useful in environments, such as Docker\ncontainers, where you don't have a running cron-daemon.\n\n## Signals\n\nEach time an email is added to the mail queue, Post Office emits a\nspecial [Django\nsignal](https://docs.djangoproject.com/en/stable/topics/signals/).\nWhenever a third party application wants to be informed about this\nevent, it shall connect a callback function to the Post Office's signal\nhandler `email_queued`, for instance:\n\n```python\nfrom django.dispatch import receiver\nfrom post_office.signals import email_queued\n\n@receiver(email_queued)\ndef my_callback(sender, emails, **kwargs):\n    print(\"Added {} mails to the sending queue\".format(len(emails)))\n```\n\nThe Emails objects added to the queue are passed as list to the callback\nhandler.\n\n\n## Changelog\n\nFull changelog can be found [here](https://github.com/ui/django-post_office/blob/master/CHANGELOG.md).\n\nCreated and maintained by the cool guys at [Stamps](https://stamps.co.id), Indonesia's most elegant\nCRM/loyalty platform.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ui/django-post_office",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-post-office",
    "package_url": "https://pypi.org/project/django-post-office/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-post-office/",
    "project_urls": {
      "Homepage": "https://github.com/ui/django-post_office"
    },
    "release_url": "https://pypi.org/project/django-post-office/3.6.3/",
    "requires_dist": [
      "bleach[css]",
      "django (>=2.2)",
      "jsonfield (>=3.0)",
      "pytz",
      "bleach ; extra == 'prevent-xss'",
      "tox (>=2.3) ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "A Django app to monitor and send mail asynchronously, complete with template support.",
    "version": "3.6.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15548824,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "73741e255e9717a10c2cca9cd49fb68c28a0c338587ded9c7b4ec72ccb5bc1c9",
        "md5": "533203203cc7513b98d0682f747996d5",
        "sha256": "1e2747a6f3d6a75c0a9eb8fa99f69106308e5371dc8dad8e2bcdd00babbb5556"
      },
      "downloads": -1,
      "filename": "django_post_office-3.6.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "533203203cc7513b98d0682f747996d5",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 84428,
      "upload_time": "2022-10-27T07:48:20",
      "upload_time_iso_8601": "2022-10-27T07:48:20.164887Z",
      "url": "https://files.pythonhosted.org/packages/73/74/1e255e9717a10c2cca9cd49fb68c28a0c338587ded9c7b4ec72ccb5bc1c9/django_post_office-3.6.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "79c2c4cd1058ff4f524ecbfea4f6f35b7708ec6c9ec545c7073f20c4afb7ba2e",
        "md5": "9f72f85761ff99561d53b55a1c95cea1",
        "sha256": "96a384ccb5ca68b5e35d05614a14625cffedcb911dbcfb5a8f6385362adafe3d"
      },
      "downloads": -1,
      "filename": "django-post_office-3.6.3.tar.gz",
      "has_sig": false,
      "md5_digest": "9f72f85761ff99561d53b55a1c95cea1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 74607,
      "upload_time": "2022-10-27T07:48:22",
      "upload_time_iso_8601": "2022-10-27T07:48:22.325321Z",
      "url": "https://files.pythonhosted.org/packages/79/c2/c4cd1058ff4f524ecbfea4f6f35b7708ec6c9ec545c7073f20c4afb7ba2e/django-post_office-3.6.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}