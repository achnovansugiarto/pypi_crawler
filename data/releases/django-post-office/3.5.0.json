{
  "info": {
    "author": "Selwin Ong",
    "author_email": "selwin.ong@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Communications :: Email",
      "Topic :: Internet :: WWW/HTTP",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "==================\nDjango Post Office\n==================\n\nDjango Post Office is a simple app to send and manage your emails in Django.\nSome awesome features are:\n\n* Allows you to send email asynchronously\n* Multi backend support\n* Supports HTML email\n* Supports inlined images in HTML email\n* Supports database based email templates\n* Supports multilingual email templates (i18n)\n* Built in scheduling support\n* Works well with task queues like `RQ <http://python-rq.org>`_ or `Celery <http://www.celeryproject.org>`_\n* Uses multiprocessing (and threading) to send a large number of emails in parallel\n\n\nDependencies\n============\n\n* `django >= 2.2 <https://djangoproject.com/>`_\n* `jsonfield <https://github.com/rpkilby/jsonfield>`_\n\n\nOptional Dependency\n-------------------\n\n* `bleach <https://bleach.readthedocs.io/>`_\n\nAdd this optional dependency, so that HTML emails are nicely rendered inside the Django admin\nbackend. Without this library, all HTML tags will otherwise be stripped for safety reasons in order\nto prevent XSS attacks.\n\n\nInstallation\n============\n\n|Build Status|\n|PyPI version|\n|Software license|\n\n* Install from PyPI (or you `manually download from PyPI <http://pypi.python.org/pypi/django-post_office>`_)::\n\n    pip install django-post_office\n\n* Add ``post_office`` to your INSTALLED_APPS in django's ``settings.py``:\n\n  .. code-block:: python\n\n    INSTALLED_APPS = (\n        # other apps\n        \"post_office\",\n    )\n\n* Run ``migrate``::\n\n    python manage.py migrate\n\n* Set ``post_office.EmailBackend`` as your ``EMAIL_BACKEND`` in django's ``settings.py``:\n\n  .. code-block:: python\n\n    EMAIL_BACKEND = 'post_office.EmailBackend'\n\n\nQuickstart\n==========\n\nSend a simple email is really easy:\n\n.. code-block:: python\n\n    from post_office import mail\n\n    mail.send(\n        'recipient@example.com', # List of email addresses also accepted\n        'from@example.com',\n        subject='My email',\n        message='Hi there!',\n        html_message='Hi <strong>there</strong>!',\n    )\n\n\nIf you want to use templates, ensure that Django's admin interface is enabled. Create an\n``EmailTemplate`` instance via ``admin`` and do the following:\n\n.. code-block:: python\n\n    from post_office import mail\n\n    mail.send(\n        'recipient@example.com', # List of email addresses also accepted\n        'from@example.com',\n        template='welcome_email', # Could be an EmailTemplate instance or name\n        context={'foo': 'bar'},\n    )\n\nThe above command will put your email on the queue so you can use the\ncommand in your webapp without slowing down the request/response cycle too much.\nTo actually send them out, run ``python manage.py send_queued_mail``.\nYou can schedule this management command to run regularly via cron::\n\n    * * * * * (/usr/bin/python manage.py send_queued_mail >> send_mail.log 2>&1)\n\n\nUsage\n=====\n\nmail.send()\n-----------\n\n``mail.send`` is the most important function in this library, it takes these\narguments:\n\n+--------------------+----------+--------------------------------------------------+\n| Argument           | Required | Description                                      |\n+--------------------+----------+--------------------------------------------------+\n| recipients         | Yes      | list of recipient email addresses                |\n+--------------------+----------+--------------------------------------------------+\n| sender             | No       | Defaults to ``settings.DEFAULT_FROM_EMAIL``,     |\n|                    |          | display name is allowed (``John <john@a.com>``)  |\n+--------------------+----------+--------------------------------------------------+\n| subject            | No       | Email subject (if ``template`` is not specified) |\n+--------------------+----------+--------------------------------------------------+\n| message            | No       | Email content (if ``template`` is not specified) |\n+--------------------+----------+--------------------------------------------------+\n| html_message       | No       | HTML content (if ``template`` is not specified)  |\n+--------------------+----------+--------------------------------------------------+\n| template           | No       | ``EmailTemplate`` instance or name               |\n+--------------------+----------+--------------------------------------------------+\n| language           | No       | Language in which you want to send the email in  |\n|                    |          | (if you have multilingual email templates.)      |\n+--------------------+----------+--------------------------------------------------+\n| cc                 | No       | list emails, will appear in ``cc`` field         |\n+--------------------+----------+--------------------------------------------------+\n| bcc                | No       | list of emails, will appear in `bcc` field       |\n+--------------------+----------+--------------------------------------------------+\n| attachments        | No       | Email attachments - A dictionary where the keys  |\n|                    |          | are the filenames and the values are either:     |\n|                    |          |                                                  |\n|                    |          | * files                                          |\n|                    |          | * file-like objects                              |\n|                    |          | * full path of the file                          |\n+--------------------+----------+--------------------------------------------------+\n| context            | No       | A dictionary, used to render templated email     |\n+--------------------+----------+--------------------------------------------------+\n| headers            | No       | A dictionary of extra headers on the message     |\n+--------------------+----------+--------------------------------------------------+\n| scheduled_time     | No       | A date/datetime object indicating when the email |\n|                    |          | should be sent                                   |\n+--------------------+----------+--------------------------------------------------+\n| expires_at         | No       | If specified, mails that are not yet sent        |\n|                    |          | won't be delivered after this date.              |\n+--------------------+----------+--------------------------------------------------+\n| priority           | No       | ``high``, ``medium``, ``low`` or ``now``         |\n|                    |          | (send_immediately)                               |\n+--------------------+----------+--------------------------------------------------+\n| backend            | No       | Alias of the backend you want to use.            |\n|                    |          | ``default`` will be used if not specified.       |\n+--------------------+----------+--------------------------------------------------+\n| render_on_delivery | No       | Setting this to ``True`` causes email to be      |\n|                    |          | lazily rendered during delivery. ``template``    |\n|                    |          | is required when ``render_on_delivery`` is True. |\n|                    |          | This way content is never stored in the DB.      |\n|                    |          | May result in significant space savings.         |\n+--------------------+----------+--------------------------------------------------+\n\n\nHere are a few examples.\n\nIf you just want to send out emails without using database templates. You can\ncall the ``send`` command without the ``template`` argument.\n\n.. code-block:: python\n\n    from post_office import mail\n\n    mail.send(\n        ['recipient1@example.com'],\n        'from@example.com',\n        subject='Welcome!',\n        message='Welcome home, {{ name }}!',\n        html_message='Welcome home, <b>{{ name }}</b>!',\n        headers={'Reply-to': 'reply@example.com'},\n        scheduled_time=date(2014, 1, 1),\n        context={'name': 'Alice'},\n    )\n\n``post_office`` is also task queue friendly. Passing ``now`` as priority into\n``send_mail`` will deliver the email right away (instead of queuing it),\nregardless of how many emails you have in your queue:\n\n.. code-block:: python\n\n    from post_office import mail\n\n    mail.send(\n        ['recipient1@example.com'],\n        'from@example.com',\n        template='welcome_email',\n        context={'foo': 'bar'},\n        priority='now',\n    )\n\nThis is useful if you already use something like `django-rq <https://github.com/ui/django-rq>`_\nto send emails asynchronously and only need to store email related activities and logs.\n\nIf you want to send an email with attachments:\n\n.. code-block:: python\n\n    from django.core.files.base import ContentFile\n    from post_office import mail\n\n    mail.send(\n        ['recipient1@example.com'],\n        'from@example.com',\n        template='welcome_email',\n        context={'foo': 'bar'},\n        priority='now',\n        attachments={\n            'attachment1.doc': '/path/to/file/file1.doc',\n            'attachment2.txt': ContentFile('file content'),\n            'attachment3.txt': {'file': ContentFile('file content'), 'mimetype': 'text/plain'},\n        }\n    )\n\nTemplate Tags and Variables\n---------------------------\n\n``post-office`` supports Django's template tags and variables.\nFor example, if you put \"Hello, {{ name }}\" in the subject line and pass in\n``{'name': 'Alice'}`` as context, you will get \"Hello, Alice\" as subject:\n\n.. code-block:: python\n\n    from post_office.models import EmailTemplate\n    from post_office import mail\n\n    EmailTemplate.objects.create(\n        name='morning_greeting',\n        subject='Morning, {{ name|capfirst }}',\n        content='Hi {{ name }}, how are you feeling today?',\n        html_content='Hi <strong>{{ name }}</strong>, how are you feeling today?',\n    )\n\n    mail.send(\n        ['recipient@example.com'],\n        'from@example.com',\n        template='morning_greeting',\n        context={'name': 'alice'},\n    )\n\n    # This will create an email with the following content:\n    subject = 'Morning, Alice',\n    content = 'Hi alice, how are you feeling today?'\n    content = 'Hi <strong>alice</strong>, how are you feeling today?'\n\n\nMultilingual Email Templates\n----------------------------\n\nYou can easily create email templates in various different languanges.\nFor example:\n\n.. code-block:: python\n\n    template = EmailTemplate.objects.create(\n        name='hello',\n        subject='Hello world!',\n    )\n\n    # Add an Indonesian version of this template:\n    indonesian_template = template.translated_templates.create(\n        language='id',\n        subject='Halo Dunia!'\n    )\n\nSending an email using template in a non default languange is\nalso similarly easy:\n\n.. code-block:: python\n\n    mail.send(\n        ['recipient@example.com'],\n        'from@example.com',\n        template=template, # Sends using the default template\n    )\n\n    mail.send(\n        ['recipient@example.com'],\n        'from@example.com',\n        template=template,\n        language='id', # Sends using Indonesian template\n    )\n\n\nInlined Images\n--------------\n\nOften one wants to render images inside a template, which are attached as inlined ``MIMEImage`` to\nthe outgoing email. This requires a slightly modified Django Template Engine, keeping a list of\ninlined images, which later will be added to the outgoing message.\n\nFirst we must add a special Django template backend to our list of template engines:\n\n.. code-block:: python\n\n\tTEMPLATES = [\n\t    {\n\t        ...\n\t    }, {\n\t        'BACKEND': 'post_office.template.backends.post_office.PostOfficeTemplates',\n\t        'APP_DIRS': True,\n\t        'DIRS': [],\n\t        'OPTIONS': {\n\t            'context_processors': [\n\t                'django.contrib.auth.context_processors.auth',\n\t                'django.template.context_processors.debug',\n\t                'django.template.context_processors.i18n',\n\t                'django.template.context_processors.media',\n\t                'django.template.context_processors.static',\n\t                'django.template.context_processors.tz',\n\t                'django.template.context_processors.request',\n\t            ]\n\t        }\n\t    }\n\t]\n\nthen we must tell Post-Office to use this template engine:\n\n.. code-block:: python\n\n\tPOST_OFFICE = {\n\t    'TEMPLATE_ENGINE': 'post_office',\n\t}\n\nIn templates used to render HTML for emails add\n\n.. code-block:: Django\n\n\t{% load ... post_office %}\n\n\t<p>... somewhere in the body ...</p>\n\t<img src=\"{% inline_image 'path/to/image.png' %}\" />\n\nHere the templatetag named ``inline_image`` is used to keep track of inlined images. It takes a single\nparameter. This can either be the relative path to an image file located in one of the ``static``\ndirectories, or the absolute path to an image file, or an image-file object itself. Templates\nrendered using this templatetag, render a reference ID for each given image, and store these images\ninside the context of the adopted template engine. Later on, when the rendered template is passed\nto the mailing library, those images will be transferred to the email message object as\n``MIMEImage``-attachments.\n\nTo send an email containing both, a plain text body and some HTML with inlined images, use the\nfollowing code snippet:\n\n.. code-block:: python\n\n\tfrom django.core.mail import EmailMultiAlternatives\n\n\tsubject, body = \"Hello\", \"Plain text body\"\n\tfrom_email, to_email = \"no-reply@example.com\", \"john@example.com\"\n\temail_message = EmailMultiAlternatives(subject, body, from_email, [to_email])\n\ttemplate = get_template('email-template-name.html', using='post_office')\n\tcontext = {...}\n\thtml = template.render(context)\n\temail_message.attach_alternative(html, 'text/html')\n\ttemplate.attach_related(email_message)\n\temail_message.send()\n\nTo send an email containing HTML with inlined images, but without a plain text body, use this\ncode snippet:\n\n.. code-block:: python\n\n\tfrom django.core.mail import EmailMultiAlternatives\n\n\tsubject, from_email, to_email = \"Hello\", \"no-reply@example.com\", \"john@example.com\"\n\ttemplate = get_template('email-template-name.html', using='post_office')\n\tcontext = {...}\n\thtml = template.render(context)\n\temail_message = EmailMultiAlternatives(subject, html, from_email, [to_email])\n\temail_message.content_subtype = 'html'\n\ttemplate.attach_related(email_message)\n\temail_message.send()\n\n\n\nCustom Email Backends\n---------------------\n\nBy default, ``post_office`` uses django's ``smtp.EmailBackend``. If you want to\nuse a different backend, you can do so by configuring ``BACKENDS``.\n\nFor example if you want to use `django-ses <https://github.com/hmarr/django-ses>`_::\n\n    POST_OFFICE = {\n        'BACKENDS': {\n            'default': 'smtp.EmailBackend',\n            'ses': 'django_ses.SESBackend',\n        }\n    }\n\nYou can then choose what backend you want to use when sending mail:\n\n.. code-block:: python\n\n    # If you omit `backend_alias` argument, `default` will be used\n    mail.send(\n        ['recipient@example.com'],\n        'from@example.com',\n        subject='Hello',\n    )\n\n    # If you want to send using `ses` backend\n    mail.send(\n        ['recipient@example.com'],\n        'from@example.com',\n        subject='Hello',\n        backend='ses',\n    )\n\n\nManagement Commands\n-------------------\n\n* ``send_queued_mail`` - send queued emails, those aren't successfully sent\n  will be marked as ``failed``. Accepts the following arguments:\n\n+---------------------------+--------------------------------------------------+\n| Argument                  | Description                                      |\n+---------------------------+--------------------------------------------------+\n| ``--processes`` or ``-p`` | Number of parallel processes to send email.      |\n|                           | Defaults to 1                                    |\n+---------------------------+--------------------------------------------------+\n| ``--lockfile`` or ``-L``  | Full path to file used as lock file. Defaults to |\n|                           | ``/tmp/post_office.lock``                        |\n+---------------------------+--------------------------------------------------+\n\n\n* ``cleanup_mail`` - delete all emails created before an X number of days\n  (defaults to 90).\n\n+---------------------------+--------------------------------------------------+\n| Argument                  | Description                                      |\n+---------------------------+--------------------------------------------------+\n| ``--days`` or ``-d``      | Email older than this argument will be deleted.  |\n|                           | Defaults to 90                                   |\n+---------------------------+--------------------------------------------------+\n| ``--delete-attachments``  | Flag to delete orphaned attachment records and   |\n|      or ``-da``           | files on disk. If flag does not exist,           |\n|                           | attachments will be ignored by the cleanup.      |\n+---------------------------+--------------------------------------------------+\n\n\nYou may want to set these up via cron to run regularly::\n\n    * * * * * (cd $PROJECT; python manage.py send_queued_mail --processes=1 >> $PROJECT/cron_mail.log 2>&1)\n    0 1 * * * (cd $PROJECT; python manage.py cleanup_mail --days=30 --delete-attachments >> $PROJECT/cron_mail_cleanup.log 2>&1)\n\n\nIntegration with Celery\n=======================\n\nIf your Django project runs in a Celery enabled configuration, you can use its worker to send out\nqueued emails. Compared to the solution with cron (see above), or the solution with uWSGI timers\n(see below) this setup has the big advantage that queued emails are send *immediately* after they\nhave been added to the mail queue. The delivery is still performed in a separate and asynchronous\ntask, which prevents sending emails during the request/response-cycle.\n\nIf you `configured Celery`_ in your project and started the `Celery worker`_,  you should see\nsomething such as:\n\n.. code-block:: text\n\n\t--------------- celery@halcyon.local v4.0 (latentcall)\n\t--- ***** -----\n\t-- ******* ---- [Configuration]\n\t- *** --- * --- . broker:      amqp://guest@localhost:5672//\n\t- ** ---------- . app:         __main__:0x1012d8590\n\t- ** ---------- . concurrency: 8 (processes)\n\t- ** ---------- . events:      OFF (enable -E to monitor this worker)\n\t- ** ----------\n\t- *** --- * --- [Queues]\n\t-- ******* ---- . celery:      exchange:celery(direct) binding:celery\n\t--- ***** -----\n\n\t[tasks]\n\t. post_office.tasks.cleanup_expired_mails\n\t. post_office.tasks.send_queued_mail\n\n\nEmails will now be delivered by the Celery worker, immediately after they have been queued. In order\nto make this happen, the project's ``celery.py`` setup shall invoke the autodiscover_tasks_\nfunction. There is no need to otherwise configure Post Office for integrating with Celery. However,\nin case of a temporary delivery failure, we might want retrying to send those emails by a periodic\ntask. This can be done by a simple `Celery beat configuration`_, for instance through\n\n.. code-block:: python\n\n\tapp.conf.beat_schedule = {\n\t    'send-queued-mail': {\n\t        'task': 'post_office.tasks.send_queued_mail',\n\t        'schedule': 600.0,\n\t    },\n\t}\n\nThis will send queued emails every 10 minutes. If you are using `Django Celery Beat`_ (which I\nhighly recommend), then use the Django-Admin backend and add a periodic taks for\n``post_office.tasks.send_queued_mail``.\n\nDepending on your policy, you may also want to remove expired emails from the queue. This can be\ndone by adding another periodic taks for ``post_office.tasks.cleanup_mail``, which may run once a\nweek or month.\n\n.. _configured Celery: https://docs.celeryproject.org/en/latest/userguide/application.html\n.. _Celery worker: https://docs.celeryproject.org/en/latest/userguide/workers.html\n.. _Celery beat configuration: https://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#entries\n.. _Django Celery Beat: https://django-celery-beat.readthedocs.io/en/latest/\n.. _autodiscover_tasks: https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.autodiscover_tasks\n\n\nIntegration with uWSGI\n======================\n\nIf setting up Celery is too daunting and you use uWSGI_ as application server, then uWSGI decorators\ncan act as a poor men's scheduler. Just add this short snipped  to the project's ``wsgi.py`` file:\n\n.. code-block:: python\n\n    from django.core.wsgi import get_wsgi_application\n\n    application = get_wsgi_application()\n\n    # add this block of code\n    try:\n        import uwsgidecorators\n        from django.core.management import call_command\n\n        @uwsgidecorators.timer(10)\n        def send_queued_mail(num):\n            \"\"\"Send queued mail every 10 seconds\"\"\"\n            call_command('send_queued_mail', processes=1)\n\n    except ImportError:\n        print(\"uwsgidecorators not found. Cron and timers are disabled\")\n\nAlternatively you can also use the decorator ``@uwsgidecorators.cron(minute, hour, day, month, weekday)``.\nThis will schedule a task at specific times. Use ``-1`` to signal any time, it corresponds to the ``*``\nin cron.\n\nPlease note that ``uwsgidecorators`` are available only, if the application has been started\nwith **uWSGI**. However, Django's internal ``./manange.py runserver`` also access this file,\ntherefore wrap the block into an exception handler as shown above.\n\nThis configuration can be useful in environments, such as Docker containers, where you\ndon't have a running cron-daemon.\n\n.. _uWSGI: https://uwsgi-docs.readthedocs.org/en/latest/\n\n\nSignals\n=======\n\nEach time an email is added to the mail queue, Post Office emits a special `Django signal`_.\nWhenever a third party application wants to be informed about this event, it shall connect a\ncallback function to the Post Office's signal handler ``email_queued``, for instance:\n\n.. code-block:: python\n\n\tfrom django.dispatch import receiver\n\tfrom post_office.signals import email_queued\n\n\t@receiver(email_queued)\n\tdef my_callback(sender, emails, **kwargs):\n\t    print(\"Added {} mails to the sending queue\".format(len(emails)))\n\n.. _Django signal: https://docs.djangoproject.com/en/stable/topics/signals/\n\nThe Emails objects added to the queue are passed as list to the callback handler.\n\n\nSettings\n========\n\nThis section outlines all the settings and configurations that you can put\nin Django's ``settings.py`` to fine tune ``post-office``'s behavior.\n\nBatch Size\n----------\n\nIf you may want to limit the number of emails sent in a batch (sometimes useful\nin a low memory environment), use the ``BATCH_SIZE`` argument to limit the\nnumber of queued emails fetched in one batch.\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'BATCH_SIZE': 50\n    }\n\n\nDefault Priority\n----------------\n\nThe default priority for emails is ``medium``, but this can be altered by\nsetting ``DEFAULT_PRIORITY``. Integration with asynchronous email backends\n(e.g. based on Celery) becomes trivial when set to ``now``.\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'DEFAULT_PRIORITY': 'now'\n    }\n\n\nOverride Recipients\n-------------------\n\nDefaults to ``None``. This option is useful if you want to redirect all emails to specified a few email for development purposes.\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'OVERRIDE_RECIPIENTS': ['to@example.com', 'to2@example.com']\n    }\n\n\nMessage-ID\n----------\n\nThe SMTP standard requires that each email contains a unique\n`Message-ID <https://tools.ietf.org/html/rfc2822#section-3.6.4>`_. Typically the Message-ID consists of two parts\nseparated by the ``@`` symbol: The left part is a generated pseudo random number. The right part is a constant string,\ntypically denoting the full qualified domain name of the sending server.\n\nBy default, **Django** generates such a Message-ID during email delivery. Since **django-post_office** keeps track of\nall delivered emails, it can be very useful to create and store this Message-ID while creating each email in the\ndatabase. This identifier then can be looked up in the Django admin backend.\n\nTo enable this feature, add this to your Post-Office settings:\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        ...\n        'MESSAGE_ID_ENABLED': True,\n    }\n\nIt can further be fine tuned, using for instance another full qualified domain name:\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        ...\n        'MESSAGE_ID_ENABLED': True,\n        'MESSAGE_ID_FQDN': 'example.com',\n    }\n\nOtherwise, if ``MESSAGE_ID_FQDN`` is unset (the default), **django-post_office** falls back to the DNS name of the\nserver, which is determined by the network settings of the host.\n\n\nMail Retry\n-------------------\n\nDefaults to Not Activated. Auto requeue failed email with time interval\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n     'MAX_RETRIES': 4\n     'RETRY_INTERVAL': datetime.timedelta(minutes=15)\n    }\n\n\nLog Level\n---------\n\nThe default log level is 2 (logs both successful and failed deliveries)\nThis behavior can be changed by setting ``LOG_LEVEL``.\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'LOG_LEVEL': 1 # Log only failed deliveries\n    }\n\nThe different options are:\n\n* ``0`` logs nothing\n* ``1`` logs only failed deliveries\n* ``2`` logs everything (both successful and failed delivery attempts)\n\n\nSending Order\n-------------\n\nThe default sending order for emails is ``-priority``, but this can be altered by\nsetting ``SENDING_ORDER``. For example, if you want to send queued emails in FIFO order :\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'SENDING_ORDER': ['created']\n    }\n\n\nContext Field Serializer\n------------------------\n\nIf you need to store complex Python objects for deferred rendering\n(i.e. setting ``render_on_delivery=True``), you can specify your own context\nfield class to store context variables. For example if you want to use\n`django-picklefield <https://github.com/gintas/django-picklefield/tree/master/src/picklefield>`_:\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'CONTEXT_FIELD_CLASS': 'picklefield.fields.PickledObjectField'\n    }\n\n``CONTEXT_FIELD_CLASS`` defaults to ``jsonfield.JSONField``.\n\n\nLogging\n-------\n\nYou can configure ``post-office``'s logging from Django's ``settings.py``. For\nexample:\n\n.. code-block:: python\n\n    LOGGING = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"formatters\": {\n            \"post_office\": {\n                \"format\": \"[%(levelname)s]%(asctime)s PID %(process)d: %(message)s\",\n                \"datefmt\": \"%d-%m-%Y %H:%M:%S\",\n            },\n        },\n        \"handlers\": {\n            \"post_office\": {\n                \"level\": \"DEBUG\",\n                \"class\": \"logging.StreamHandler\",\n                \"formatter\": \"post_office\"\n            },\n            # If you use sentry for logging\n            'sentry': {\n                'level': 'ERROR',\n                'class': 'raven.contrib.django.handlers.SentryHandler',\n            },\n        },\n        'loggers': {\n            \"post_office\": {\n                \"handlers\": [\"post_office\", \"sentry\"],\n                \"level\": \"INFO\"\n            },\n        },\n    }\n\n\nThreads\n-------\n\n``post-office`` >= 3.0 allows you to use multiple threads to dramatically speed up\nthe speed at which emails are sent. By default, ``post-office`` uses 5 threads per process.\nYou can tweak this setting by changing ``THREADS_PER_PROCESS`` setting.\n\nThis may dramatically increase the speed of bulk email delivery, depending on which email\nbackends you use. In my tests, multi threading speeds up email backends that use HTTP based\n(REST) delivery mechanisms but doesn't seem to help SMTP based backends.\n\n.. code-block:: python\n\n    # Put this in settings.py\n    POST_OFFICE = {\n        'THREADS_PER_PROCESS': 10\n    }\n\n\nPerformance\n===========\n\nCaching\n-------\n\nif Django's caching mechanism is configured, ``post_office`` will cache\n``EmailTemplate`` instances . If for some reason you want to disable caching,\nset ``POST_OFFICE_CACHE`` to ``False`` in ``settings.py``:\n\n.. code-block:: python\n\n    ## All cache key will be prefixed by post_office:template:\n    ## To turn OFF caching, you need to explicitly set POST_OFFICE_CACHE to False in settings\n    POST_OFFICE_CACHE = False\n\n    ## Optional: to use a non default cache backend, add a \"post_office\" entry in CACHES\n    CACHES = {\n        'post_office': {\n            'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',\n            'LOCATION': '127.0.0.1:11211',\n        }\n    }\n\n\nsend_many()\n-----------\n\n``send_many()`` is much more performant (generates less database queries) when\nsending a large number of emails. ``send_many()`` is almost identical to ``mail.send()``,\nwith the exception that it accepts a list of keyword arguments that you'd\nusually pass into ``mail.send()``:\n\n.. code-block:: python\n\n    from post_office import mail\n\n    first_email = {\n        'sender': 'from@example.com',\n        'recipients': ['alice@example.com'],\n        'subject': 'Hi!',\n        'message': 'Hi Alice!'\n    }\n    second_email = {\n        'sender': 'from@example.com',\n        'recipients': ['bob@example.com'],\n        'subject': 'Hi!',\n        'message': 'Hi Bob!'\n    }\n    kwargs_list = [first_email, second_email]\n\n    mail.send_many(kwargs_list)\n\nAttachments are not supported with ``mail.send_many()``.\n\n\nRunning Tests\n=============\n\nTo run the test suite::\n\n    `which django-admin.py` test post_office --settings=post_office.test_settings --pythonpath=.\n\nYou can run the full test suite with::\n\n    tox\n\nor::\n\n    python setup.py test\n\n\nChangelog\n=========\n\nFull changelog can be found `here <https://github.com/ui/django-post_office/blob/master/CHANGELOG.md>`_.\n\nCreated and maintained by the cool guys at `Stamps <https://stamps.co.id>`_,\nIndonesia's most elegant CRM/loyalty platform.\n\n\n.. |Build Status| image:: https://travis-ci.org/ui/django-post_office.png?branch=master\n   :target: https://travis-ci.org/ui/django-post_office\n\n.. |PyPI version| image:: https://img.shields.io/pypi/v/django-post_office.svg\n   :target: https://pypi.org/project/django-post_office/\n\n.. |Software license| image:: https://img.shields.io/pypi/l/django-post_office.svg\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ui/django-post_office",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-post-office",
    "package_url": "https://pypi.org/project/django-post-office/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-post-office/",
    "project_urls": {
      "Homepage": "https://github.com/ui/django-post_office"
    },
    "release_url": "https://pypi.org/project/django-post-office/3.5.0/",
    "requires_dist": [
      "django (>=2.2)",
      "jsonfield (>=3.0)",
      "bleach; extra == 'prevent-XSS'",
      "tox (>=2.3); extra == 'test'"
    ],
    "requires_python": "",
    "summary": "A Django app to monitor and send mail asynchronously, complete with template support.",
    "version": "3.5.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15548824,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e47d2b3e7c7f4022e8760f36fcda2218f4787694ea091d6cab1a3ccb549e5982",
        "md5": "045668ce0337e4d44b36977a5c618a1d",
        "sha256": "67e61635f49051aa6da43297fced5dd74f27c38d74918d58bf1d5c388b8a4327"
      },
      "downloads": -1,
      "filename": "django_post_office-3.5.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "045668ce0337e4d44b36977a5c618a1d",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 78094,
      "upload_time": "2020-10-31T09:29:18",
      "upload_time_iso_8601": "2020-10-31T09:29:18.141110Z",
      "url": "https://files.pythonhosted.org/packages/e4/7d/2b3e7c7f4022e8760f36fcda2218f4787694ea091d6cab1a3ccb549e5982/django_post_office-3.5.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c7721eddbf9e272fd4699cfccbba5c85f8062317084acd8ae5594d1f8c5dca8f",
        "md5": "ad0f30be246c87f90bfc70ca37fa2969",
        "sha256": "d0400542468a256c41074db35a49899ea7e86ece47a2450d638055d88874a656"
      },
      "downloads": -1,
      "filename": "django-post_office-3.5.0.tar.gz",
      "has_sig": false,
      "md5_digest": "ad0f30be246c87f90bfc70ca37fa2969",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 72953,
      "upload_time": "2020-10-31T09:29:22",
      "upload_time_iso_8601": "2020-10-31T09:29:22.874779Z",
      "url": "https://files.pythonhosted.org/packages/c7/72/1eddbf9e272fd4699cfccbba5c85f8062317084acd8ae5594d1f8c5dca8f/django-post_office-3.5.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}