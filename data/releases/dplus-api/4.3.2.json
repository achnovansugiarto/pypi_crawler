{
  "info": {
    "author": "Devora Witty",
    "author_email": "devorawitty@chelem.co.il",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "Academic License Agreement\n\nThe D+ software (\"Software\") has been developed by the contributing researchers from the group of Prof. Uri Raviv, (\"Developers\") of the Hebrew University of Jerusalem (\"HUJ\") and made available through HUJ for your internal, non-profit research use.\n\nHUJ and the Developers allow researchers at your institution to run, display, copy and modify Software on the following conditions:\n\nThe Software remains at your institution and is not published, distributed, or otherwise transferred or made available to other than institution employees and students involved in research under your supervision.\n\nYou agree to make results generated using Software available to other academic researchers for non-profit research purposes. If you wish to obtain Software for any commercial purposes, including fee-based service projects, you will need to execute a separate licensing agreement with Yissum Research Development Company of the Hebrew University of Jerusalem Ltd. and pay a fee. In that case, please contact: uri.raviv@mail.huji.ac.il or info@yissum.co.il.\n\nYou retain in Software and any modifications to Software, the copyright, trademark, or other notices pertaining to Software as provided by HUJ and the Developers.\n\nYou provide the Developers with feedback on the use of the Software in your research, and that the Developers and HUJ are permitted to use any information you provide in making changes to the Software. All bug reports and technical questions shall be sent to the email address: uri.raviv@mail.huji.ac.il.\n\nYou acknowledge that the Developers, HUJ and its licensees may develop modifications to the Software that may be substantially similar to your modifications of the Software, and that the Developers, HUJ and its licensees shall not be constrained in any way by you in Developer's, HUJ's or its licensees' use or management of such modifications. You acknowledge the right of the Developers and HUJ to prepare and publish modifications to the Software that may be substantially similar or functionally equivalent to your modifications and improvements, and if you obtain patent protection for any modification or improvement to the Software you agree not to allege infringement of your patent by the Developers, HUJ or by any of HUJ's or Yissum's licensees obtaining and using modifications or improvements to the Software from HUJ or the Developers or attempt to enjoin the use of such modifications or improvements to the Software.\n\nYou agree to acknowledge the contribution Developers and the Software make to your research, and cite appropriate references about the Software in your publications. In particular, please cite the paper: Ginsburg A, Ben-Nun T, Asor R, Shemesh A, Ringel I, Raviv U. Reciprocal grids: a hierarchical algorithm for computing solution x-ray scattering curves from supramolecular complexes at high resolution. Journal of chemical information and modeling. 2016; 56 (8) :1518-1527.\n\nYou and your institution assume all risk associated with using the Software at your institution. The Software is experimental in nature and is made available as a research courtesy \"AS IS,\" without obligation by HUJ or the Developers to provide accompanying services or support.\n\nHUJ AND THE DEVELOPERS EXPRESSLY DISCLAIM ANY AND ALL WARRANTIES REGARDING THE SOFTWARE, WHETHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES PERTAINING TO NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\n\nCustomer Service\nFor any questions, please contact Prof. Uri Raviv\nPhone: +972-2-6586030\nEmail: uri.raviv@mail.huji.ac.il\n\n\nDescription: ן»¿This document was last updated on April 2 2018, for version 4.3.1\n        \n        # The Dplus Python API\n        \n        \n        The D+ Python API allows using the D+ backend from Python, instead of the ordinary D+ application.\n        \n        The Python API works on both Windows and Linux.\n        \n        ## Installation\n        \n        Installing the Python API is done using PIP:\n        \n            pip install dplus-api\n            \n        The API was tested with Python 3.5 and newer. It *may* work with older versions of Python, although Python 2 \n        is probably not supported.\n        \n        ## Overview\n         \n        Some notes:\n         \n        Throughout the manual, code examples are given with filenames, such as \"mystate.state\".\n        To run the example code for yourself, these files must be located in the same directory as the script itself,\n         or alternately the code can be modified to contain the full path of the file's location.\n        \n        Throughout the manual, we mention \"state files\". A state file is a \n        JavaScript Object Notation (JSON) format file (https://www.json.org/), \n        which describes the parameter tree and calculation settings of the D+ computation.\n        \n        It is unnecessary to write a state file yourself. \n        State files can either be generated from within the python interface (with the function `export_all_parameters`),\n        or created from the D+ GUI (by selecting File>Export All Parameters from within the D+ GUI).\n        \n        **The overall flow of the Python API is as follows:**\n        \n        1. The data to be used for the calculation is built by the user in an instance of the `CalculationInput` class. \n        `CalculationInput` is a child class of the class `State`, which represents a program state. A `State` includes both program \n        preferences such as `DomainPreferences`, and a parameter tree composed of `Models`.\n        \n        2. The calculation input is then passed to a `CalculationRunner` class (either `LocalRunner` or `WebRunner`),\n        and the calculation function is called (`generate`, `generate_async`, `fit`, or `fit_async`).\n        \n        3. The `CalculationRunner` class returns an instance of a `CalculationResult` class, \n        either `FitResult` or `GenerateResult`.\n        \n        Here is a very simple example of what this might look like in main.py:\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        from dplus.CalculationRunner import LocalRunner\n        \n        calc_data = CalculationInput.load_from_state_file(\"mystate.state\")\n        runner = LocalRunner()\n        result = runner.generate(calc_data)\n        print(result.graph)\n        ```\n        \n        A detailed explanation of the class types and their usage follows.\n        \n        \n        ## CalculationRunner\n        \n        There are two kinds of `CalculationRunners`, Local and Web.\n        \n        The `LocalRunner` is intended for users who have the D+ executable files installed on their system. It takes two optional\n        initialization arguments:\n        \n        * `exe_directory` is the folder location of the D+ executables. \n        By default, its value is `None`. On Windows, a value of `None` will \n        lead to the python interface searching the registry for an installed D+ on its own, but on linux the executable \n        directory *must* be specified. \n        * `session_directory` is the folder where the arguments for the calculation are stored, as well as the output results,\n        Amplitude files, and protein data bank (PDB) files, from the C++ executable. \n        By default, its value is `None`, and an automatically generated \n        temporary folder will be used. \n        \n        ```\n        from dplus.CalculationRunner import LocalRunner\n        \n        exe_dir = r\"C:\\Program Files\\D+\\bin\"\n        sess_dir = r\"sessions\"\n        runner = LocalRunner(exe_dir, sess_dir)\n        #also possible:\n        #runner = LocalRunner()\n        #runner = LocalRunner(exe_dir)\n        #runner = LocalRunner(session_directory=sess_dir)\n        ```\n        \n        The WebRunner is intended for users accessing the D+ server. It takes two required initialization arguments, with no\n        default values:\n        \n        * `url` is the address of the server.\n        * `token` is the authentication token granting access to the server. \n        \n        ```\n        from dplus.CalculationRunner import WebRunner\n        \n        url = r'http://localhost:8000/'\n        token = '4bb25edc45acd905775443f44eae'\n        runner = WebRunner(url, token)\n        ```\n        \n        Both runner classes have the same four methods: \n        \n        `generate(calc_data)`, `generate_async(calc_data)`, `fit(calc_data)`, and `fit_async(calc_data)`.\n        \n        All four methods take the same single argument, `calc_data` - an instance of a `CalculationData` class.\n        \n        `generate` and `fit` return a `CalculationResult`.\n        \n        `generate_async` and `fit_async` return a `RunningJob`.\n        \n        When using `generate` or `fit` the program will wait until the call has finished and returned a result, before continuing. \n        Their asynchronous counterparts (`generate_async` and `fit_async`) allow D+ calculations to be run in the background \n        (for example, the user can call `generate_async`, tell the program to do other things, \n        and then return and check if the computation is finished). \n        \n        \n        #### RunningJob\n        \n        The user should not be initializing this class. When returned from an async function\n         (`generate_async` or `fit_async`) in `CalculationRunner`, the user can \n        use the following methods to interact with the `RunningJob` instance:\n        \n        * `get_status()`: get a JSON dictionary reporting the job's current status\n        * `get_result(calc_data)`: get a `CalculationResult`. Requires a copy of the `CalculationInput` used to create the job. \n        Should only be called when the job is completed. It is the user's responsibility to verify job completion with `get_status` \n        before calling. \n        * `abort()`: end a currently running job\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        from dplus.CalculationRunner import LocalRunner\n        \n         calc_data = CalculationInput.load_from_state_file(\"mystate.state\")\n         runner = LocalRunner()\n         job = runner.generate_async(calc_data)\n         start_time = datetime.datetime.now()\n         status = job.get_status()\n         while status['isRunning']:\n             status = job.get_status()\n             run_time = datetime.datetime.now() - start_time\n             if run_time > datetime.timedelta(seconds=50):\n                 job.abort()\n                 raise TimeoutError(\"Job took too long\")\n         result = job.get_result(calc_data)\n        ```\n        \n        ## Signal\n        \n        A class that represents a Signal.\n        With just X values and NaN for y values, it is an uninitialized signal- eg before running generate.\n        \n        |Property Name | Description|\n        |---|---|\n        |`x`|\tq values|\n        |`y`|\t intensity values|\n        |`q_max`| The max q value in x|\n        |`q_min`|\tThe min q value in x (bigger or equal to 0) |\n        |`generated_points`| The length of x vector |\n        \n        It has the methods:\n        * `graph` - returns order dictionary of x (q) points as keys and y points as values\n        * `create_x_vector` - receives qmax, qmin and generated_points and create signal instance that fit to those params\n        * `load_from_unordered_dictionary` - gets unordered dict of qs and their intensities and return signal instance that fit to the dict\n        * `load_from_unordered_pairs`- gets list of unordered pairs- qs and their intensities and return signal instance that fit to the list\n        * `read_from_file` - gets a file name and load the file as a Signal class \n        * `get_validated`- returns a signal with no negative intensity values (remove xs and ys when the ys are negative)\n        * `apply_resolution_function` - gets a sigma value and apply resolution on the y according to the sigma, returns signal instance with the new value\n        \n        ## State\n        The state class contains an instance of each of three classes: DomainPreferences, FittingPreferences, and Domain. \n        They are described in the upcoming sections.\n        \n        It has the methods:\n        \n        * `get_model`: get a model by either its `name` or its pointer, `model_ptr`.\n        * `get_models_by_type`: returns a list of `Models` with a given `type_name`, for example, `UniformHollowCylinder`.\n        * `get_mutable_params`: returns a list of `Parameters` in the state class, whose property `mutable` is `True`.\n        * `get_mutable_parameter_values`: returns a list of floats, matching the values of the mutable parameters.\n        * `set_mutable_parameter_values`: given a list of floats, sets the mutable parameters of the `State` (in the order given by \n        `get_mutable_parameter_values`).\n        * `export_all_parameters`: given a filename, will save the calculation `State` to that file.\n        * `add_model`: a convenience function to help add models to the parameter tree of a 'State'. It receives the model and optionally \n        a population index (default 0), and will insert that model into the population.\n        * `add_amplitude`: a convenience function specifically for adding instances of the `Amplitude` class, described below. \n        It creates an instance of an `AMP` class with the filename of the `Amplitude`. Then, in addition to calling `add_model` with that `AMP` instance, \n        it also changes the `DomainPreferences` of the `State` (specifically, `grid_size`, `q_max`, and `use_grid`), to match the properties of the `Amplitude`.\n        It returns the 'AMP' instance it created.\t\n        \n        State, _and every class and sub class contained within state_ (for example: preferences, models, parameters), all have the functions \n        `load_from_dictionary` and `serialize`.\n        \n        `load_from_dictionary` sets the values of the various fields within a class to match those contained within a suitable dictionary. \n        It can behave recursively as necessary, for example, with a model that has children.\n        \n        `serialize` saves the contents of a class to a dictionary. Note that there may be additional fields in the dictionary\n        beyond those described in this document, because some defunct (outdated, irrelevant, or not-yet-implemented) fields are \n        still saved in the serialized dictionary.\n        \n        \n        \n        #### DomainPreferences\n        The DomainPreferences class contains properties that are copied from the D+ interface. Their usage is explained in \n        the D+ documentation.\n        \n        We create a new instance of DomainPreferences by calling the python initialization function:\n        \n        `dom_pref= DomainPreferences()`\n        \n        There are no arguments given to the initialization function, and all the properties are set to default values:\n        \n        |Property Name | Default Value | Allowed values|\n        |---|---|---|\n        |`signal`|\t`an instance of signal class with qmin=0, qmax=7.5 and generated_points=800 `||\n        |`convergence`|\t0.001||\n        |`grid_size`|\t100|Even integer greater than 20|\n        |`orientation_iterations`|\t100||\n        |`orientation_method`|\t`\"Monte Carlo (Mersenne Twister)\"`|`\"Monte Carlo (Mersenne Twister)\", \"Adaptive (VEGAS) Monte Carlo\", \"Adaptive Gauss Kronrod\"`|\n        |`use_grid`|\t`False`| `True`, `False`|\n        |`q_max`|\t7.5|Positive number. The value comes from signal.q_max|\n        |`q_min`|\t0|Positive number. The value comes from signal.q_min|\n        |`generated_points`|\t800|Positive number. The value comes from signal.generated_points|\n        |`x`|\tlist of qs that fit to signal q_min, q_max and generated_point default values|list of qs. comes from signal.x|\n        |`y`|\twith no signal file - none |list of intensities. comes from signal.y |\n        \n        Any property can then be easily changed, for example, \n        \n        `dom_pref.use_grid= True`\n        \n        If the user tries to set a property to an invalid value (for example, setting q_max to something other than a positive number) they will get an error.\n        \n        \n        #### Fitting Preferences\n        The `FittingPreferences` class contains properties that are copied from the D+ interface. Their usage is explained in the D+ documentation.\n        \n        We create a new instance of FittingPreferences by calling the python initialization function:\n        \n        `fit_pref= FittingPreferences()`\n        \n        There are no arguments given to the initialization function, and all the properties are set to default values:\n        \n        |Property Name | Default Value |Allowed Values|Required when|\n        |---|---|---|---|\n        |`convergence`|\t0.1| Positive numbers||\n        |`der_eps`|\t0.1| Positive numbers||\n        |`fitting_iterations`|\t20|Positive integers||\n        |`step_size`|0.01| Positive numbers||\n        |`loss_function`|`\"Trivial Loss\"`| `\"Trivial Loss\",\"Huber Loss\",\"Soft L One Loss\",\"Cauchy Loss\",\"Arctan Loss\",\"Tolerant Loss\"`||\n        |`loss_func_param_one`|0.5|Number|Required for all `loss_function` values except \"Trivial Loss\"|\n        |`loss_func_param_two`|0.5|Number|Required when `loss_function` is \"Tolerant Loss\"|\n        |`x_ray_residuals_type`|`\"Normal Residuals\"`|`\"Normal Residuals\",\"Ratio Residuals\",\"Log Residuals\"`||\n        |`minimizer_type`|`\"Trust Region\"`|`\"Line Search\",\"Trust Region\"`||\n        |`trust_region_strategy_type`|`\"Dogleg\"`|`\"Levenberg-Marquardt\",\"Dogleg\"`|`minimizer_type` is `\"Trust Region\"`|\n        |`dogleg_type`|`\"Traditional Dogleg\"`|`\"Traditional Dogleg\",\"Subspace Dogleg\"`|`trust_region_strategy_type` is `\"Dogleg\"`|\n        |`line_search_type`|`\"Armijo\"`|`\"Armijo\",\"Wolfe\"`|`minimizer_type` is `\"Line Search\"`|\n        |`line_search_direction_type`|`\"Steepest Descent\"`|`\"Steepest Descent\",\"Nonlinear Conjugate Gradient\",\"L-BFGS\",\"BFGS\"`|`minimizer_type` is `\"Line Search\"`. if `line_search_type` is `\"Armijo\"`, cannot be `\"BFGS\"` or `\"L-BFGS\"`. |\n        |`nonlinear_conjugate_gradient_type`|`\"\"`|`\"Fletcher Reeves\",\"Polak Ribirere\",\"Hestenes Stiefel\"`|`linear_search_direction_type` is `\"Nonlinear Conjugate Gradient\"`|\n        \n        Any property can then be easily changed, for example,\n        \n        `fit_pref.convergence= 0.5`\n        \n        If the user tries to set a property to an invalid value they will get an error.\n        \n        \n        #### Domain\n        \n        The Domain class describes the parameter tree. \n        \n        The root of the tree is the `Domain` class. This class contains an array of `Population` classes. \n        Each `Population` can contain a number of `Model` classes. Some models have children, which are also models.\n        \n        ##### Models\n        \n        `Domain` and `Population` are two special kinds of models.\n        \n        The `Domain` model is the root of the parameter tree, which can contain multiple populations. \n        Populations can contain standard types of models.\n        \n        The available standard model classes are:\n        \n        * `UniformHollowCylinder`\n        * `Sphere`\n        * `SymmetricLayeredSlabs`\n        * `AsymmetricLayeredSlabs`\n        * `Helix`\n        * `DiscreteHelix`\n        * `SpacefillingSymmetry`\n        * `ManualSymmetry`\n        * `PDB`- a PDB file\n        * `AMP`- an amplitude grid file\n        \n        You can create any model by calling its initialization. \n        \n        Please note that models are dynamically loaded from those available in D+. \n        Therefore, your code editor may underline the model in red even if the model exists.\n        \n        All models have `location_params` (Location Parameters) and  `extra_params` (Extra Parameters). \n        Some models (that support layers) also contain `layer_params` (Layer Parameters).\n        These are all collection of instances of the `Parameter` class, and can be accessed from \n        `model.location_params`, `model.extra_params`, and `model.layer_params`, respectively.\n        \n        All of these can be modified. They are accessed using dictionaries.\n        Example:\n        \n        ```\n        from dplus.DataModels.models import UniformHollowCylinder\n        \n        uhc=UniformHollowCylinder()\n        uhc.layer_params[1][\"Radius\"].value=2.0\n        uhc.extra_params[\"Height\"].value=3.0\n        uhc.location_params[\"x\"].value=2\n        ```\n        \n        For additional information about which models have layers and what the various parameters available for each model are,\n        please consult the D+ User's Manual.\n        \n        ###### Parameters\n        \n        The `Parameter` class contains the following properties:\n        \n        `value`: a float whose default value is `0`\n        \n        `sigma`: a float whose default value is `0`\n        \n        `mutable`: a boolean whose default value is `False`\n        \n        `constraints`: an instance of the `Constraints` class, its default value is the default `Constraints`\n        \n        Usage:\n        \n        ```  \n        p=Parameter()  #creates a parameter with value: '0', sigma: '0', mutable: 'False', and the default constraints.\n        p=Parameter(7) #creates a parameter with value: '7', sigma: '0', mutable: 'False', and the default constraints.\n        p=Parameter(sigma=2) #creates a parameter with value: '0', sigma: '2', mutable: 'False', and the default constraints.\n        p.value= 4  #modifies the value to be 4.\n        p.mutable=True #modifies the value of mutable to be 'True'.\n        p.sigma=3 #modifies sigma to be 3.\n        p.constraints=Constraints(min_val=5) #sets constraints to a 'Constraints' instance whose minimum value (min_val) is 5.\n        ```\n        ###### Constraints\n        \n        The `Constraints` class contains the following properties:\n        \n        `MaxValue`: a float whose default value is `infinity`.\n        \n        `MinValue`: a float whose default value is `-infinity`.\n        \n        The usage is similar to 'Parameter' class, for example:\n        \n        ```\n        c=Constraints(min_val=5) #creates a 'Constraints' instance whose minimum value is 5 and whose maximum value is the default ('infinity').\n        ```\n        \n        ## CalculationInput\n        \n        The CalculationInput class inherits from the `State` class and therefore has access to all its functions and properties.\n        \n        In addition, it contains the following properties of its own:\n        \n        * `x`: an array of q values (self.DomainPreferences.x)\n        * `y`: an array of intensity values from a signal, optional. Used for running fitting. (self.DomainPreferences.y)\n        * `signal`: a signal class instance. (self.DomainPreferences.signal)\n        * `use_gpu`: a boolean whose default value is True, representing whether D+ should use the GPU\n        * `args`: a json dictionary of the arguments required to run generate.exe or fit.exe\n        \n        \n        A new instance of CalculationInput can be created simply by calling its constructor.\n        \n        An empty constructor will cause CalculationInput to be created with default values derived from the default State, and with use_gpu = True.\n        \n        In addition, CalculationInput has the following static methods to create an instance of GenerateInput:\n        \n        * `load_from_state_file` receives the location of a file that contains a serialized parameter tree (state)\n        * `load_from_PDB` receives the location of a PDB file, and automatically creates a guess at the best state parameters\n         based on the PDB \n         * `copy_from_state` returns a new `CalculationInput` based on an existing state or `CalculationInput`\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        gen_input=CalculationInput()\n        ```\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        gen_input=CalculationInput.load_from_state_file('sphere.state')\n        ```\n        \n        \n        ## CythonWrapping\n        \n        In module CythonWrapping there is one class CJacobianSphereGrid.\n        \n        CJacobianSphereGrid is a python wraper class to D+ cpp class JacobianSphereGrid.\n        It has a constractor that recieves qMax and gridSize and initialize the cpp class JacobianSphereGrid with those params\n        \n        It has the following properties (read only properties):\n        \n        |Property Name | Description|\n        |---|---|\n        |`q_max`|\tThe max q value of the grid|\n        |`grid_size`|\tThe grid size attribute from D+ UI |\n        |`step_size`| The difference between 2 q values |\n        \n        \n        \n        It has the methods:\n        * `index_from_indices` - calls the c++ function IndexFromIndices,  receives q, theta and phi indices \n         returns the index position of the amplitude value in the data array\n        * `indices_from_index` - calls the c++ function IndicesFromIndex, receives index position of an amplitude value in data array \n         returns q, theta and phi indices \n        * `get_data` - reads the data from c++ data array and returns a numpy array of amplitude values\n        * `get_param_json_string` - calls the c++ function GetParamJsonString, return the critical params of the grid as json string\n        * `fill` - a python function that receive pointer to function that calulate amplitude for model, and fill all the c++ data array with those values.\n        at the end this function runs calculate_splines.\n        * `calculate_splines` - calls the c++ function that calculate the splines on the data array (should be called after fill)\n        * `get_interpolant_coeffs` - reads the data from c++ interpolant coefficients array and returns a numpy array of interpolant coefficients values\n        * `interpolate_theta_phi_plane` - calls the c++ function InterpolateThetaPhiPlane, receives ri, theta and phi angels \n        returns the intepolation value \n         \n        \n        \n        \n        ## Amplitudes\n        \n        In the module `Amplitudes` there are 2 classes:\n        * `Grid` \n        * `Amplitude` which contains an instance of class PyJacobianSphereGrid.\n        \n        **Please note**: The class Amplitude is not similar to AMP from Dplus.DataModels.Models.\n        \n        The class `AMP` contains a filename pointing to an amplitude file, an extra parameter scale, a boolean centered, and it can be\n        serialized and sent as part of the Domain parameter tree to D+. \n        \n        The class `Amplitude`, by contrast, can be used to build an amplitude and then save that amplitude as an amplitude file,\n        which can then be opened in D+ (or sent in as class AMP) but it itself cannot be added directly to the Domain parameter tree.\n        If you want to add it, you must save the amplitude to a file first using the `save` method, \n        and then you can use the State's function `add_amplitude`, to add it to the tree.\n        \n        ### Grid\n        \n        The class `Grid` is initialized with `q_max` and `grid_size`. \n        \n        `Grid` is used to create/describe a grid of `q`, `theta`, `phi` angle values. \n        \n        These values can be described using two sets of indexing:\n        \n        1. The overall index `m`\n        2. The individual angle indices `i`, `j`, `k`\n        \n        The `Grid` is created in spherical coordinates in reciprocal space.\n        It has `N` shells, and the parameter `grid_size` is equal to `2N`.\n        The  index  `i` represents the shell number that is related to `q` , which is the magnitude of the scattering vector.\n        `q_max` is the largest `q`  value. The index `j` corresponds to the polar (`theta`) angle on the `i`th shell, and the index `k` corresponds to the azimuthal angle, `phi` , of the `j`th polar angle on the `i`th shell. The `Grid`  is nonuniform and the `i`th shell contains 6i(3i+1) points in its `theta`-`phi`  plane.\n        The index `m` is a single index that describe each point on the `Grid` .\n        The index starts at the origin of the `Grid`, where `m=0` , and continues to the next shells, whereas each shell is arranged in a `phi`-major storage order.\n        There is a one-to-one relation between the two  indexing methods.\n        \n        `Grid` has the following methods:\n        \n        * `create_grid`: a generator that returns `q`, `theta`, `phi` angles in `phi`-major order\n        * `indices_from_index`: receives an overall index `m`, and returns the individual `q`, `theta`, and `phi` indices: `i`, `j`, `k`\n        * `angles_from_index`: receives an overall index `m`, and returns the matching `q`, `theta`, and `phi` angle values\n        * `angles_from_indices`: receives angle indices `i`,`j`,`k` and returns their `q`, `theta`, and `phi` angle values\n        * `index_from_indices`: receives angle indices `i`,`j`,`k` and returns the overall index `m` that matches them\n        * `indices_from_angles`: receives angles `q`, `theta`, `phi`, ands returns the matching indices `i`,`j`,`k`\n        * `index_from_angles`: receives angles `q`, `theta`, `phi` and returns the matching overall index `m`\n        \n        \n        ```\n        from dplus.Amplitudes import Grid\n        \n        g = Grid(5, 100)\n        for q,theta,phi in g.create_grid():\n            print(g.index_from_angles(q, theta, phi))\n        ```\n        ### Amplitude\n        \n        The class Amplitude has an instance of CJacobianSphereGrid. It is a class intended to describe the amplitude of a model/function, and can\n        save these values to an amplitude file (that can be read by D+) and can also read amplitude files (like those created by D+)\n        \n        Amplitude is initialized with q_max and grid_size.\n        \n        Amplitude has the following properties:\n        * `values` - returns a numpy array from the c++ data array of the instance CJacobianSphereGrid ( call the function CJacobianSphereGrid.get_data()) \n        * `complex_amplitude_array` - returns a complex numpy array from  values - each pair data[idx], data[idx+1] are one complex number (data[idx] + j*data[idx+1]) when idx is even number\n        * `default_header` - build header list with the data of the new created amplitude\n        * `headers` - return default header is the amplitude is new, and return external_headers when the amplitude was loaded from a file\n        * `description` - an optional string the user can fill with data about the amplitude class (for example what the type of the model). The description property will be added to the headers.\n        \n        Amplitude also has the following methods:\n        * `save` - save the information in the Amplitude class to an Amplitude file which can then be \n        passed along to D+ to calculate its signal or perform fitting.\n        * `load` - Alternately, Amplitude has a static method, `load`,  which receives a filename of an Amplitude file, and returns an Amplitude instance\n        with the values from that file already loaded.\n        * `fill` - for a new amplitude, this function calculate the amplitude values for CJacobianSphereGrid data array (call CJacobianSphereGrid.fill())\n        * `interpolate_theta_phi_plane` - calls CJacobianSphereGrid.InterpolateThetaPhiPlane function, receives ri, theta and phi angels\n        returns the intepolation value  \n        \n        ```\n        from dplus.Amplitudes import Amplitude\n        my_amp = Amplitude.load(\"myamp.ampj\")\n        for c in my_amp.complex_amplitude_array:\n            print(c)\n        ```\n        \n        ```\n        from dplus.Amplitudes import Amplitude\n        \n        def my_func(q, theta, phi):\n        \treturn np.complex64(q+1 + 0.0j)\n        \n        a = Amplitude(7.5, 80)\n        a.description= \"An exmaple amplitude\"\t\t\t\t\t\t \n        a.fill(my_func)\n        a.save(\"myfile.ampj\")\n        ```\n        \n        There are examples of using Amplitudes to implement models similar to D+ in the additional examples section.\n        \n        The module Amplitudes also contains two convenience functions for converting between cartesian and spherical coordinates:\n        \n        * `sph2cart` receives r, theta, phi and returns x, y, z\n        * `cart2sph` receives x, y, z and returns r, theta, phi\n        \n        ```\n        from dplus.Amplitudes import sph2cart, cart2sph\n        \n        q, theta, phi = cart2sph(1,2,3)\n        x, y, z = sph2cart(q,theta,phi)\n        \n        ```\n        \n        In addition the module contains two functions that conert old \".amp\" file to \".ampj\" file and vice versa\n        * `amp_to_ampj_converter` - receives amp file and save it as ampj file, returns the new filename\n        * `ampj_to_amp_converter`- receives ampj file and save it as amp file, returns the new filename\n        \n        \n        ## CalculationResult\n        \n        The CalculationResult class is returned by the CalculationRunner. \n        The user should generally not be instantiating the class themselves. \n        \n        The base `CalculationResult` class is inherited by `GenerateResult` and `FitResult`\n        \n        `CalculationResult` has the following properties:\n        \n        * `graph`: an OrderedDict whose keys are x values and whose values are y values.\n        * `y`: The raw list of y values from the results JSON\n        * `error` : returns the JSON error report from the dplus run\n        \n        In addition, CalculationResults has the following functions:\n        \n        * `get_amp(model_ptr, destination_folder)`: returns the file location of the amplitude file for given `model_ptr`. \n        `destination_folder` has a default value of `None`, but if provided, the amplitude file will be copied to that location,\n        and then have its address returned. \n        * `get_amps(destionation_folder)`: returns an array of file locations for every amplitude file created during the D+\n        calculation process. `destination_folder` has a default value of `None`, but if provided, the amplitude files\n        will be copied to that location.  \n        * `get_pdb(mod_ptr, destination_folder)`: returns the file location of the PDB file for given `model_ptr`. \n        `destination_folder` has a default value of `None`, but if provided, the PDB file will be copied to that location,\n        and then have its address returned \n        * `save_to_out_file(filename)`: receives file name, and saves the results to the file.\n        \n        In addition to the above:\n         \n        `GenerateResult` has a property `headers`, created by D+ to describe \n        the job that was run. It is an Ordered Dictionary, whose keys are ModelPtrs and whose values are the header associated. \n        \n        `FitResult` has two additional properties,\n        * `parameter_tree`: A JSON of parameters (can be used to create a new `state` with state's `load_from_dictionary`). \n        Only present in fitting, not generate, results\n        * `result_state`: a `CalculationInput` whose `Domain` contains the optimized parameters obtained from the fitting\n        \n        \n        ## FileReaders\n        \n        The API contains a module FileReaders. \n        \n        The module contains the class NumpyHandlingEncoder.\n        \n        \n        ## Additional Usage examples\n        \n        \n        ***Example One***\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        from dplus.CalculationRunner import LocalRunner\n        \n        exe_directory = r\"C:\\Program Files\\D+\\bin\"\n        sess_directory = r\"session\"\n        runner= LocalRunner(exe_directory, sess_directory)\n        \n        input=CalculationInput.load_from_state_file('spherefit.state')\n        result=runner.fit(input)\n        print(result.graph)\n        ```\n        \n        Comments:\n        This program loads a state file from `spherefit.state`, runs fitting with the local runner, and print the graph of the result.\n        \n        ***Example Two***\n        \n        ```\n        from dplus.CalculationInput import CalculationInput\n        from dplus.CalculationRunner import LocalRunner\n        from dplus.DataModels import ModelFactory, Population\n        from dplus.State import State\n        from dplus.DataModels.models import UniformHollowCylinder\n        \n        sess_directory = r\"session\"\n        runner= LocalRunner(session_directory=sess_directory)\n        \n        uhc=UniformHollowCylinder()\n        caldata = CalculationInput()\n        caldata.Domain.populations[0].add_model(uhc)\n        \n        result=runner.generate(caldata)\n        print(result.graph)\n        ```\n        \n        ***Example Three***\n        \n        ```\n        from dplus.CalculationRunner import LocalRunner\n        from dplus.CalculationInput import CalculationInput\n        \n        runner=LocalRunner()\n        caldata=CalculationInput.load_from_PDB('1JFF.pdb', 5)\n        result=runner.generate(caldata)\n        print(result.graph)\n        ```\n        \n        ***Example Four***\n        \n        ```\n        from dplus.CalculationRunner import LocalRunner\n        from dplus.CalculationInput import CalculationInput\n        runner=LocalRunner()\n        input = CalculationInput.load_from_state_file(\"uhc.state\")\n        cylinder = input.get_model(\"test_cylinder\")\n        \n        print(\"Original radius is \", cylinder.layer_params[1]['Radius'].value)\n        result = runner.generate(input)\n        \n        input.signal = result.signal\n        cylinder = input.get_model(\"test_cylinder\")\n        cylinder.layer_params[1]['Radius'].value = 2\n        cylinder.layer_params[1]['Radius'].mutable = True\n        input.FittingPreferences.convergence = 0.5\n        input.use_gpu = True\n        fit_result = runner.fit(input)\n        optimized_input= fit_result.result_state\n        result_cylinder=optimized_input.get_model(\"test_cylinder\")\n        print(fit_result.parameter_tree)\n        print(\"Result radius is \", result_cylinder.layer_params[1]['Radius'].value)\n        \n        ```\n        \n        Comments: \n        `fit_result.result_state` is the optimized state (i.e. the optimized parameter tree) that is returned from the fitting (`runner.fit(input)`). You can fetch the cylinder whose name is \"test_cylinder\" from that parameter tree, to see what its new optimized parameters are.\n        \n        \n        ### Implementing Models using Amplitudes\n        \n        For the purpose of these exmaples the models are implemented with minimal default parameters, in a realistic usage \n        scenario the user would set those parameters as editable properties to be changed at his convenience.\n        \n        ```\n        from dplus.Amplitudes import Amplitude\n        import math\n        import numpy as np\n        \n        class UniformSphere:\n            def __init__(self):\n                self.extraParams=[1,0]\n                self.ED=[333, 400]\n                self.r=[0,1]\n        \n            @property\n            def nLayers(self):\n                return len(self.ED)\n        \n            def calculate(self, vq, vtheta, vphi):\n                cos = math.cos\n                sin = math.sin\n                nLayers = self.nLayers\n                ED = self.ED\n                extraParams = self.extraParams\n                r = self.r\n                def closeToZero(x):\n                    return (math.fabs(x) < 100.0 * 2.2204460492503131E-16)\n        \n                q = math.sqrt(math.pow(vq,2) + math.pow(vtheta,2) + math.pow(vphi,2))\n                if closeToZero(q):\n                    electrons = 0.0\n                    for i in range( 1, nLayers):\n                        electrons += (ED[i] - ED[0]) * (4.0 / 3.0) * math.pi * (r[i] ** 3 - r[i-1] ** 3)\n                    return np.complex64(electrons  * extraParams[0] + extraParams[1]+ 0.0j)\n        \n                res = 0.0\n        \n                for i in range(nLayers-1):\n                    res -= (ED[i] - ED[i + 1]) * (cos(q * r[i]) * q * r[i] - sin(q * r[i]))\n                res -= (ED[nLayers - 1] - ED[0]) * (cos(q * r[nLayers - 1]) * q * r[nLayers - 1] - sin(q * r[nLayers - 1]))\n        \n                res *= 4.0 * math.pi / (q*q * q)\n        \n                res *= extraParams[0] #Multiply by scale\n                res += extraParams[1] #Add background\n                return np.complex64(res + 0.0j)\n        \n        \n        sphere = UniformSphere()\n        a = Amplitude(7.5, 200)\n        a.fill(sphere.calculate)\n        a.save(\"sphere.ampj\")\n        \n        input = CalculationInput()\n        amp_model = input.add_amplitude(a)\n        amp_model.centered = True\n        runner = LocalRunner()\n        result = runner.generate(input)\n        ```\n        \n        ```\n        \n        class SymmetricSlab:\n            def __init__(self):\n                self.scale=1\n                self.background=0\n                self.xDomain=10\n                self.yDomain=10\n                self.ED=[333, 280]\n                self.width=[0,1]\n                self.OrganizeParameters()\n        \n            @property\n            def nLayers(self):\n                return len(self.ED)\n        \n            def OrganizeParameters(self):\n                self.width[0] = 0.0\n                self.xDomain *= 0.5\n                self.yDomain *= 0.5\n                for i in range(2, self.nLayers):\n                    self.width[i] += self.width[i - 1];\n        \n            def calculate(self, q, theta, phi):\n                def closeToZero(x):\n                    return (math.fabs(x) < 100.0 * 2.2204460492503131E-16)\n                from dplus.Amplitudes import sph2cart\n                from math import sin, cos\n                from numpy import sinc\n                import numpy as np\n                qx, qy, qz = sph2cart(q, theta, phi)\n                res= np.complex128(0+0j)\n                if(closeToZero(qz)):\n                    for i in range(self.nLayers):\n                        res += (self.ED[i] - self.ED[0]) * 2. * (self.width[i] - self.width[i - 1])\n                    return res * 4. * sinc(qx * self.xDomain) * self.xDomain * sinc(qy * self.yDomain) * self.yDomain\n        \n                prevSin = np.float64(0.0)\n                currSin=np.float64(0.0)\n                for i in range(1, self.nLayers):\n                    currSin = sin(self.width[i] * qz)\n                    res += (self.ED[i] - self.ED[0]) * 2. * (currSin - prevSin) / qz\n                    prevSin = currSin\n                res *= 4. * sinc((qx * self.xDomain)/np.pi) * self.xDomain * sinc((qy * self.yDomain)/np.pi) * self.yDomain\n                return res * self.scale + self.background #Multiply by scale and add background\n        \n        \n        \n        from dplus.Amplitudes import Amplitude\n        from dplus.State import State\n        from dplus.CalculationRunner import LocalRunner\n        from dplus.CalculationInput import CalculationInput\n        symSlab = SymmetricSlab()\n        a = Amplitude(7.5, 80)\n        a.create_grid(symSlab.calculate)\n        \n        ```\n        \n        ### Python Fitting\n        It is possible to fit a curve using the results from Generate and numpy's built in minimization/curve fitting functions.\n        All that is requires is wrapping the interface code so that it receives and returns parameters the way scipy expects (eg as numpy arrays)\n         \n        An example follows:\n        \n        ```\n        import numpy as np\n        from scipy import optimize\n        from dplus.CalculationInput import CalculationInput\n        from dplus.CalculationRunner import LocalRunner\n        \n        input=CalculationInput.load_from_state_file(r\"2_pops.state\")\n        generate_runner=LocalRunner()\n        \n        def run_generate(xdata, *params):\n            '''\n            scipy's optimization algorithms require a function that receives an x array and an array of parameters, and\n            returns a y array.\n            this function will be called repeatedly, until scipy's optimization has completed.\n            '''\n            input.set_mutable_parameter_values(params) #we take the parameters given by scipy and place them inside our parameter tree\n            generate_results=generate_runner.generate(input) #call generate\n            return np.array(generate_results.y) #return the results of the generate call\n        \n        x_data=input.x\n        y_data=input.y\n        p0 = input.get_mutable_parameter_values()\n        method='lm' #lenenberg-marquadt (see scipy documentation)\n        popt, pcov =optimize.curve_fit(run_generate, x_data, y_data, p0=p0, method=method)\n        \n        #popt is the optimized set of parameters from those we have indicated as mutable\n        #we can insert them back into our CalculationInput and create the optmized parameter tree\n        input.set_mutable_parameter_values(popt)\n        #we can run generate to get the results of generate with them\n        best_results=generate_runner.generate(input)\n        ```\n        \nPlatform: UNKNOWN\nClassifier: Development Status :: 4 - Beta\nClassifier: Environment :: Console\nClassifier: Intended Audience :: Science/Research\nClassifier: License :: Other/Proprietary License\nClassifier: Operating System :: OS Independent\nClassifier: Programming Language :: Python\nClassifier: Programming Language :: Python :: 3.4\nClassifier: Topic :: Scientific/Engineering :: Chemistry\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://scholars.huji.ac.il/uriraviv",
    "keywords": "",
    "license": "D+ Software",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dplus-api",
    "package_url": "https://pypi.org/project/dplus-api/",
    "platform": "",
    "project_url": "https://pypi.org/project/dplus-api/",
    "project_urls": {
      "Homepage": "https://scholars.huji.ac.il/uriraviv"
    },
    "release_url": "https://pypi.org/project/dplus-api/4.3.2/",
    "requires_dist": [
      "numpy (>=1.10)",
      "psutil (==5.2.2)",
      "requests (==2.10.0)"
    ],
    "requires_python": "",
    "summary": "Call the DPlus Calculation Backend",
    "version": "4.3.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14530274,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e864f6c416576a4974341230457abf33d5bb703c7ec2f0527726381ebdc726d8",
        "md5": "9600922093d816ddafa8123f8ef7b30f",
        "sha256": "b8106bdb23cd1f598c3e9b08f41cb438788540ab23b4fc6568a3daf06380482e"
      },
      "downloads": -1,
      "filename": "dplus_api-4.3.2-cp35-cp35m-win_amd64.whl",
      "has_sig": false,
      "md5_digest": "9600922093d816ddafa8123f8ef7b30f",
      "packagetype": "bdist_wheel",
      "python_version": "cp35",
      "requires_python": null,
      "size": 281870,
      "upload_time": "2019-04-08T08:19:05",
      "upload_time_iso_8601": "2019-04-08T08:19:05.339100Z",
      "url": "https://files.pythonhosted.org/packages/e8/64/f6c416576a4974341230457abf33d5bb703c7ec2f0527726381ebdc726d8/dplus_api-4.3.2-cp35-cp35m-win_amd64.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "86cf191bc73ed007e28dfca7e78bed1247d92121c17c9f6e9ebc1cb42f23dc50",
        "md5": "b1f8378b492d14012cc7b953eb230c8c",
        "sha256": "95b457944ba8df087ea73668ca1acf8ee967b6ee8e0689549c90d02d0815599b"
      },
      "downloads": -1,
      "filename": "dplus_api-4.3.2-cp36-cp36m-win_amd64.whl",
      "has_sig": false,
      "md5_digest": "b1f8378b492d14012cc7b953eb230c8c",
      "packagetype": "bdist_wheel",
      "python_version": "cp36",
      "requires_python": null,
      "size": 290793,
      "upload_time": "2019-04-03T11:15:58",
      "upload_time_iso_8601": "2019-04-03T11:15:58.294908Z",
      "url": "https://files.pythonhosted.org/packages/86/cf/191bc73ed007e28dfca7e78bed1247d92121c17c9f6e9ebc1cb42f23dc50/dplus_api-4.3.2-cp36-cp36m-win_amd64.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1e221865b206f62d496c3e7259aba113899aa4147054e6b8598b9ee203136d5b",
        "md5": "9d6be42165d43fd4b081ce839d97435d",
        "sha256": "7c00e3d5f8c2c0fb09f3e633d895a1392b97c4d35608f97c079b5f4dc1e3b60f"
      },
      "downloads": -1,
      "filename": "dplus-api-4.3.2.tar.gz",
      "has_sig": false,
      "md5_digest": "9d6be42165d43fd4b081ce839d97435d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 919711,
      "upload_time": "2019-04-03T11:16:05",
      "upload_time_iso_8601": "2019-04-03T11:16:05.612265Z",
      "url": "https://files.pythonhosted.org/packages/1e/22/1865b206f62d496c3e7259aba113899aa4147054e6b8598b9ee203136d5b/dplus-api-4.3.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}