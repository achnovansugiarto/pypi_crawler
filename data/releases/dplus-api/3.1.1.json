{
  "info": {
    "author": "Devora Witty",
    "author_email": "devorawitty@chelem.co.il",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Console",
      "Intended Audience :: Science/Research",
      "License :: Other/Proprietary License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.4",
      "Topic :: Scientific/Engineering :: Chemistry"
    ],
    "description": "This document was last updated on June 10 2018, for version 3.1.1\n\n#The Dplus Python API\n\n\nThe D+ Python API allows using the D+ backend from Python, instead of the ordinary D+ application.\n\nThe Python API works on both Windows and Linux.\n\n##Installation\n\nInstalling the Python API is done using PIP:\n\n    pip install dplus-api\n\nThe API was tested with Python 3.5 and newer. It *may* work with older versions of Python, although Python 2 is probably not supported.\n\n ##Overview\n\n Please note: \n\nThroughout the manual, code examples are given with filenames, such as \"mystate.state\".\nThese files must be located in the same directory as the script itself, or alternately the code can be modified to the contain the full path of the file's location.\n\nThe overall flow of the Python API is as follows:\n\n1. The data to be used for the calculation is built by the user in an instance of the `CalculationInput` class \n(either `GenerateInput` or `FitInput`). Inputs contain a program `State`, which includes both porgram preferences \nsuch as `DomainPreferences`, and `Models`.\n\n2. This calculation input is then passed to a `CalculationRunner` class (either `LocalRunner` or `WebRunner`),\nand the calculation function is called (`generate`, `generate_async`, `fit`, or `fit_async`)\n\n3. The `CalculationRunner` class returns a `CalculationResult` class.\n\nHere is a very simple example of what this might look line:\n\n```\nfrom dplus.CalculationInput import GenerateInput\nfrom dplus.CalculationRunner import LocalRunner\n\ncalc_data = GenerateInput.load_from_state_file(\"mystate.state\")\nrunner = LocalRunner()\nresult = runner.generate(calc_data)\nprint(result.graph)\n```\n\nA detailed explanation of the class types and their usage follows\n\n\n##CalculationRunner\n\nThere are two kinds of CalculationRunners, Local and Web.\n\nThe LocalRunner is intended for users who have the D+ executable files installed on their system. It takes two optional\ninitialization arguments:\n\n* `exe_directory` is the folder location of the D+ executables. By default, its value is None- on Windows, this will \nlead to the python interface searching the registry for an installed D+ on its own, but on linux the executable \ndirectory *must* be specified. \n* `session_directory` is the folder where the arguments for the calculation are stored, as well as the output results,\namplitude files, and pdb files, from the c++ executable. By default, its value is None, and an automatically generated \ntemporary folder will be used. \n\n```\nfrom dplus.CalculationRunner import LocalRunner\n\nexe_dir = r\"C:\\Program Files\\D+\\bin\"\nsess_dir = r\"sessions\"\nrunner = LocalRunner(exe_dir, sess_dir)\n#also possible:\n#runner = LocalRunner()\n#runner = LocalRunner(exe_dir)\n#runner = LocalRunner(session_directory=sess_dir)\n```\n\nThe WebRunner is intended for users accessing the D+ server. It takes two required initialization arguments, with no\ndefault values:\n\n* `url` is the address of the server.\n* `token` is the authentication token granting access to the server. \n\n```\nfrom dplus.CalculationRunner import WebRunner\n\nurl = r'http://localhost:8000/'\ntoken = '4bb25edc45acd905775443f44eae'\nrunner = WebRunner(url, token)\n```\n\nBoth runner classes have the same four methods: \n\ngenerate(calc_data), generate_async(calc_data), fit(calc_data), fit_async(calc_data)\n\nAll four methods take the same single argument, `calc_data` - an instance of a CalculationData class\n\ngenerate and fit return a `CalculationResult`\n\ngenerate_async and fit_async return a `RunningJob`\n\nThe methods generate and fit both wait until dplus has returned a result. Their asynchronous counterparts allow dplus \ncalculations to be run in the background.\n\n####RunningJob\n\nThe user should not be initializing this class. When returned from an async function in CalculationRunner, the user can \nuse the following methods to interact with the RunningJob:\n\n* `get_status()`: get a json dictionary reporting the job's current status\n* `get_result(calc_data)`: get a `CalculationResult`. Requires a copy of the CalculationInput used to create the job. \nshould only be called when job is completed. It is the user's responsibility to verify job completion with get_status \nbefore calling. \n* `abort()`: end a currently running job\n\n```\nfrom dplus.CalculationInput import GenerateInput\nfrom dplus.CalculationRunner import LocalRunner\n\n calc_data = GenerateInput.load_from_state_file(\"mystate.state\")\n runner = LocalRunner()\n job = runner.generate_async(calc_data)\n start_time = datetime.datetime.now()\n status = job.get_status()\n while status['isRunning']:\n     status = job.get_status()\n     run_time = datetime.datetime.now() - start_time\n     if run_time > datetime.timedelta(seconds=50):\n         job.abort()\n         raise TimeoutError(\"Job took too long\")\n result = job.get_result(calc_data)\n```\n\n##CalculationInput\n\nThere are two kinds of CalculationInput, FitInput and GenerateInput.\n\nGenerateInput contains an instance of a `State` class and an x vector. It is used to generate the signal of a given\nparameter tree (within the `State`).\n\nFitInput contains a `State` class, an x vector, and a y vector representing a signal to be fitted. \nIt is used to fit a parameter tree (within the `State`) to the signal.\n\nThe `State` class is described in the next section.\n\nThe x and y vectors are simply lists of floating point coordinates. They can be generated from parameters in the state \nclass or loaded from a file.\nCalculationInput has the following methods:\n\n* `get_model`: get a model by either its `name` or its `model_ptr`\n* `get_models_by_type`: returns a list of `Models` with a given `type_name`, e.g. UniformHollowCylinder\n* `get_mutable_params`: returns a list of `Parameters` in the state class, whose property `mutable` is True\n* `get_mutable_parameter_values`: returns a list of floats, matching the values of the mutable parameters\n* `set_mutable_parameter_values`: given a list of floats, sets the mutable parameters of the state (in the order given by \nget_mutable_parameter_values)\n\nIn addition, all CalculationInputs have the property `use_gpu`, which can be set to True or False (running fitting with\nuse_gpu set to False is not recommended).\n\nA new instance of GenerateInput can be created simply by calling its constructor with a state:\n\n```\nfrom dplus.CalculationInput import GenerateInput\ns=State()\ngen_input=GenerateInput(s)\n```\n\nIn addition, GenerateInput has the following static methods to create an instance of GenerateInput:\n\n* `load_from_state_file(filename)` receives the location of a file that contains a serialized parameter tree (state)\n* `load_from_PDB` receives the location of a PDB file, and automatically creates a guess at the best state parameters\n based on the pdb \n\n```\nfrom dplus.CalculationInput import GenerateInput\ngen_input=GenerateInput.load_from_state_file('sphere.state')\n```\n\nA new instance of StateInput can be created by calling its constructor, and either:\n\n 1. `x`, `y`: two arrays, an x array and a y array, or\n 2. `graph`: a single dictionary, with x values as keys for the y values\n\n```\nfrom dplus.CalculationInput import FitInput, load_x_and_y_from_file\n\nx,y=load_x_and_y_from_file(\"signal_file.out\")\nstate=State()\nfit_input=FitInput(state, x=x, y=y)\n```\n\nFitInput also has the following static method to create an instance of FitInput:\n\n* `load_from_state_file(filename)` receives the location of a file that contains a serialized parameter tree (state)\n\n```\nfrom dplus.CalculationInput import FitInput\nfit_input=FitInput.load_from_state_file('sphere.state')\n``` \n\n\n\n###State\n\nThe state class contains an instance of each of three classes: DomainPreferences, FittingPreferences, and Domain. \nThey are described in the upcoming sections.\n\nIt has the methods  `get_model`, `get_models_by_type`, `get_mutable_params`,  `get_mutable_parameter_values`, and\n`set_mutable_parameter_values`, just as CalculationInput does.\n\n(In fact, CalculationInput simply invokes these functions from within its State when they are called from CalculationInput)\n\nState, _and every class and sub class contained within state_ (ie preferences, models, parameters), all have the functions \n`load_from_dictionary` and `serialize`.\n\n`load_from_dictionary` sets the values of the various fields within a class to match those contained within a suitable dictionary. \nIt can behave recursively as necessary, for example with a model that has children.\n\n`serialize` saves the contents of a class to a dictionary. Note that there may be additional fields in the dictionary\nbeyond those described in this document, because some defunct (outdated, irrelevant, or not-yet-implemented) fields are \nstill saved in the serialized dictionary.\n\n\n####DomainPreferences\nThe DomainPreferences class contains properties that are copied from the D+ interface. Their usage is explained in \nthe D+ documentation.\n\nWe create a new instance of DomainPreferences by calling the python initialization function:\n\n`dom_pref= DomainPreferences()`\n\nThere are no arguments given to the initialization function, and all the properties are set to default values:\n\n|Property Name | Default Value | Allowed values|\n|---|---|---|\n|signal_file|\t\"\"|\"\", or a valid file location|\n|convergence|\t0.001||\n|grid_size|\t100|Even integer greater than 20|\n|orientation_iterations|\t100||\n|orientation_method|\t\"Monte Carlo (Mersenne Twister)\"|\"Monte Carlo (Mersenne Twister)\", \"Adaptive (VEGAS) Monte Carlo\", \"Adaptive Gauss Kronrod\"|\n|use_grid|\tFalse|True, False|\n|q_max|\t7.5|Positive number. If signal file is provided, must match highest x value|\n\nAny property can then be changed easily.\n\n`dom_pref.q_max= 10`\n\nIf the user tries to set a property to an invalid value (for example, setting q_max to something other than a positive number) they will get an error.\n\nIf a signal file is provided, the value of q_max will automatically be set to the highest x value in the signal file.\n\n\n####Fitting Preferences\nThe FittingPreferences class contains properties that are copied from the D+ interface. Their usage is explained in the D+ documentation.\n\nWe create a new instance of FittingPreferences by calling the python initialization function:\n\n`fit_pref= FittingPreferences()`\n\nThere are no arguments given to the initialization function, and all the properties are set to default values:\n\n|Property Name | Default Value |Allowed Values|Required when|\n|---|---|---|---|\n|convergence|\t0.1| Positive numbers||\n|der_eps|\t0.1| Positive numbers||\n|fitting_iterations|\t20|Positive integers||\n|step_size|0.01| Positive numbers||\n|loss_function|\"Trivial Loss\"| \"Trivial Loss\",\"Huber Loss\",\"Soft L One Loss\",\"Cauchy Loss\",\"Arctan Loss\",\"Tolerant Loss\"||\n|loss_func_param_one|0.5|Number|Required for all loss_function except \"Trivial Loss\"|\n|loss_func_param_two|0.5|Number|Required when loss_function is \"Tolerant Loss\"|\n|x_ray_residuals_type|\"Normal Residuals\"|\"Normal Residuals\",\"Ratio Residuals\",\"Log Residuals\"||\n|minimizer_type|\"Trust Region\"|\"Line Search\",\"Trust Region\"||\n|trust_region_strategy_type|\"Dogleg\"|\"Levenberg-Marquardt\",\"Dogleg\"|minimizer_type is \"Trust Region\"|\n|dogleg_type|\"Traditional Dogleg\"|\"Traditional Dogleg\",\"Subspace Dogleg\"|trust_region_strategy_type is \"Dogleg\"|\n|line_search_type|\"Armijo\"|\"Armijo\",\"Wolfe\"|minimizer_type is \"Line Search\"|\n|line_search_direction_type|\"Steepest Descent\"|\"Steepest Descent\",\"Nonlinear Conjugate Gradient\",\"L-BFGS\",\"BFGS\"|minimizer_type is \"Line Search\". if line_search_type is \"Armijo\", cannot be \"BFGS\" or \"L-BFGS\". |\n|nonlinear_conjugate_gradient_type|\"\"|\"Fletcher Reeves\",\"Polak Ribirere\",\"Hestenes Stiefel\"|linear_search_direction_type is \"Nonlinear Conjugate Gradient\"|\n\nAny property can then be changed easily.\n\n`fit_pref.convergence= 0.5`\n\nIf the user tries to set a property to an invalid value they will get an error.\n\n\n####Domain\n\nThe Domain class describes the parameter tree. \n\nThe root of the tree is the `Domain` class. This contains an array of `Population` classes. \nEach `Population` can contain a number of `Model` classes. Some models have children, also models.\n\n#####Models\n\nDomain and Population are two special kinds of models.\n\nThe Domain model is the root of the parameter tree, which can contain multiple populations. \nPopulations can contain standard types of models.\n\nThe available standard model classes are:\n\n* UniformHollowCylinder\n* Sphere\n* SymmetricLayeredSlabs\n* AsymmetricLayeredSlabs\n* Helix\n* DiscreteHelix\n* SpacefillingSymmetry\n* ManualSymmetry\n* PDB- a pdb file\n* AMP- an amplitude grid file\n\nYou can create any model by calling its initialization. \n\nPlease note that models are dynamically loaded from those available in DPlus. \nTherefore, your code editor may underline the model in red even if the model exists.\n\nAll models have Location Parameters and Extra Parameters. Some models (that support layers) also contain Layer Parameters.\nThese are all collection of instances of the `Parameter` class, and can be accessed from \n`model.location_params`, `model.extra_params`, and `model.layer_params`, respectively.\n\nAll of these can be modified. They are accessed using dictionaries.\nExample:\n\n```\nfrom dplus.DataModels.models import UniformHollowCylinder\n\nuhc=UniformHollowCylinder()\nuhc.layer_params[1][\"Radius\"].value=2.0\nuhc.extra_params[\"Height\"].value=3.0\nuhc.location_params[\"x\"].value=2\n```\n\nFor additional information about which models have layers and what the various parameters available for each model are,\nplease consult the DPlus manual.\n\n######Parameters\n\nThe Parameter class contains the following properties:\n\nvalue: a float whose default value is 0\n\nsigma: a float whose default value is 0\n\nmutable: a boolean whose default value is False\n\nconstraints: an instance of the Constraints class, by default it is the default Constraints\n\n`p=Parameter(4)`\n\n######Constraints\n\nThe Constraints class contains the following properties:\n\nMaxValue: a float whose default value is infinity\n\nMinValue: a float whose default value is -infinity\n\n`c=Constraints(min_val=5)`\n\n##CalculationResult\n\nThe CalculationResult class is returned by the CalculationRunner. \nThe user should generally not be instantiating the class themselves. \n\nThe class has the following properties accessible:\n\n* 'graph': an OrderedDict whose keys are x values and whose values are y values.\n* 'y': The raw list of y values from the results json\n* 'headers': an OrderDict of headers, whose keys are ModelPtrs and whose values are the header associated. \nThis property is not necessarily present in fitting results\n* 'parameter_tree': A json of parameters (can be used to create a new state with state's load_from_dictionary). Only present in fitting,\nnot generate, results\n* 'error' : returns the json error report from the dplus run\n\nIn addition, CalculationResults has the following public functions:\n\n* 'get_amp(model_ptr, destination_folder)': returns the file location of the amplitude file for given model_ptr. \ndestination_folder has a default value of None, but if provided, the amplitude file will be copied to that location,\nand then have its address returned \n* 'get_pdb(mod_ptr, destination_folder)': returns the file location of the pdb file for given model_ptr. \ndestination_folder has a default value of None, but if provided, the pdb file will be copied to that location,\nand then have its address returned \n* 'save_to_out_file(filename)': receives file name, and saves the results to the file.\n\n###Amplitude and FileReaders\n\nThe dplus api also contains a module FileReaders. \n\nIt contains `SignalFileReader`, which can be initialized with a path to a signal file (eg a .out or .dat file) \nand will read that file into its `x_vec`, `y_vec`, and `graph` properties.\n\nIt also contains `Amplitude`. \n\nAmplitude has a static method, `load`,  which receives a filename and qmax vvalue and creates an instance of the Amplitude class. \n\nAlternately one can create an empty instance  of Amplitude and then call the function `read_amp`, \nwhich accomplishes the same thing.  \n\nIn addition the class has the following functions:\n* q_indices - returns a generator that iterates over each amplitude item in the amplitude array and returns their [q, theta, phi]\n* num_indices - return the numbers of  trios [q, theta, phi] in Amplitude file\n* complex_amplitude_array - returns a complex array of amplitudes\n\nAll this functions assume that the user call 'load' or 'read_amp'.\nIn case the user didn't call them, the functions return None arrays/ 0 num of indices\n\nThe Amplitude class contains three properties, `amp_values` that stores the \nAmplitude values,  `headers`, which stores a list of headers and `step_size` - the \"step\" between q values.\n\nThe function `save` saves the contents of the Amplitude to a new .amp file\n\n```\nfrom dplus.FileReaders import Amplitude\nmy_amp=Amplitude.load('myamp.amp', qmax)\ncomplexes=my_amp.complex_amplitude_array()\nfor c in complexes:\n    #check that it's correct\n    pass\nfor q, theta, phi in my_amp.q_indices():\n    #check that it's correct\n    pass\nmy_amp.save('myamp-modified.amp')\n```\n\n##Additional Usage examples\n\nFrom the Dplus GUI it is possible to create a state file by selecting File>Export All Parameters.\nAlternately one can create a State by hand, by adding populations, models, fittingpreferences, etc.\nIn addition, there is an option for generating a pdb, load_from_pdb. It requires the address of the pdb file, and the value of q_max (the largest q value). It automatically populates the rest of the state with reasonable default values.\n\n\n***Example One***\n\n```\nfrom dplus.CalculationInput import FitInput\nfrom dplus.CalculationRunner import LocalRunner\n\nexe_directory = r\"C:\\Program Files\\D+\\bin\"\nsess_directory = r\"session\"\nrunner= LocalRunner(exe_directory, sess_directory)\n\ninput=FitInput.load_from_state_file('spherefit.state')\nresult=runner.fit(input)\nprint(result.graph)\n```\n\n***Example Two***\n\n```\nfrom dplus.CalculationInput import GenerateInput\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.DataModels import ModelFactory, Population\nfrom dplus.State import State\nfrom dplus.DataModels.models import UniformHollowCylinder\n\nsess_directory = r\"session\"\nrunner= LocalRunner(session_directory=sess_directory)\n\nuhc=UniformHollowCylinder()\ns=State()\ns.Domain.populations[0].add_model(uhc)\n\ncaldata = GenerateInput(s)\nresult=runner.generate(caldata)\nprint(result.graph)\n```\n\n***Example Three***\n\n```\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.CalculationInput import GenerateInput\n\nrunner=LocalRunner()\ncaldata=GenerateInput.load_from_PDB('1JFF.pdb', 5)\nresult=runner.generate(caldata)\nprint(result.graph)\n```\n\n***Example Four***\n\n```\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.CalculationInput import GenerateInput, FitInput\nAPI=LocalRunner()\ninput = GenerateInput.load_from_state_file(\"uhc.state\")\ncylinder = input.get_model(\"test_cylinder\")\n\nprint(\"Original radius is \", cylinder.layer_params[1]['Radius'].value)\nresult = API.generate(input)\n\nfit_input = FitInput(input.state, result.graph)\ncylinder = fit_input.get_model(\"test_cylinder\")\ncylinder.layer_params[1]['Radius'].value = 2\ncylinder.layer_params[1]['Radius'].mutable = True\n\nfit_result = API.fit(fit_input)\nprint(fit_result.parameter_tree)\nfit_input.combine_results(fit_result)\nprint(\"Result radius is \", cylinder.layer_params[1]['Radius'].value)\n```\n\n###Python Fitting\nIt is possible to fit a curve using the results from Generate and numpy's built in minimzation/curve fitting functions. This is a new functionality that is sill very much under development. An example follows:```\n\n```\nimport numpy as np\nfrom scipy import optimize\nfrom dplus.CalculationInput import GenerateInput, FitInput\nfrom dplus.CalculationRunner import LocalRunner\n\ninput=FitInput.load_from_state_file(r\"2_pops.state\")\ngenerate_runner=LocalRunner()\n\ndef run_generate(xdata, *params):\n    '''\n    scipy's optimization algorithms require a function that receives an x array and an array of parameters, and\n    returns a y array.\n    this function will be called repeatedly, until scipy's optimization has completed.\n    '''\n    input.set_mutable_parameter_values(params) #we take the parameters given by scipy and place them inside our parameter tree\n    generate_results=generate_runner.generate(input) #call generate\n    return np.array(generate_results.y) #return the results of the generate call\n\nx_data=input.x\ny_data=input.y\np0 = input.get_mutable_parameter_values()\nmethod='lm' #lenenberg-marquadt (see scipy documentation)\npopt, pcov =optimize.curve_fit(run_generate, x_data, y_data, p0=p0, method=method)\n\n#popt is the optimized set of parameters from those we have indicated as mutable\n#we can insert them back into our CalculationInput and create the optmized parameter tree\ninput.set_mutable_parameter_values(popt)\n#we can run generate to get the results of generate with them\nbest_results=generate_runner.generate(input)\n```\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://scholars.huji.ac.il/uriraviv",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dplus-api",
    "package_url": "https://pypi.org/project/dplus-api/",
    "platform": "",
    "project_url": "https://pypi.org/project/dplus-api/",
    "project_urls": {
      "Homepage": "https://scholars.huji.ac.il/uriraviv"
    },
    "release_url": "https://pypi.org/project/dplus-api/3.1.1/",
    "requires_dist": [
      "numpy (>=1.10)",
      "psutil (==5.2.2)",
      "requests (==2.10.0)"
    ],
    "requires_python": "",
    "summary": "Call the DPlus Calculation Backend",
    "version": "3.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14530274,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "697bc9bdc9a499b0968752024a254a746170a8225f3ed5d4b8bdc76b4bded113",
        "md5": "b28b1339ea1a5c8ea449c20ee1240067",
        "sha256": "291b73622fe301b7927abd9ff0e1ec3cde06cf1356002b4201b0d9b18646d1ad"
      },
      "downloads": -1,
      "filename": "dplus_api-3.1.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "b28b1339ea1a5c8ea449c20ee1240067",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 47030,
      "upload_time": "2018-06-10T09:47:08",
      "upload_time_iso_8601": "2018-06-10T09:47:08.697435Z",
      "url": "https://files.pythonhosted.org/packages/69/7b/c9bdc9a499b0968752024a254a746170a8225f3ed5d4b8bdc76b4bded113/dplus_api-3.1.1-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3b79c9560cc9cf304c532b5aed7c6ed9d6e4227cb102af4b9b28fd393a44b044",
        "md5": "4082cd5fd47d2dea3a65d2f0ee1e0ff6",
        "sha256": "8a2d3c0d3fb76e98139c18d8d1750f5fcd9addf83adcd2dbd428932667ae7dd8"
      },
      "downloads": -1,
      "filename": "dplus-api-3.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "4082cd5fd47d2dea3a65d2f0ee1e0ff6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 42951,
      "upload_time": "2018-06-10T09:47:12",
      "upload_time_iso_8601": "2018-06-10T09:47:12.135195Z",
      "url": "https://files.pythonhosted.org/packages/3b/79/c9560cc9cf304c532b5aed7c6ed9d6e4227cb102af4b9b28fd393a44b044/dplus-api-3.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}