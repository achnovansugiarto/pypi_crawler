{
  "info": {
    "author": "Devora Witty",
    "author_email": "devorawitty@chelem.co.il",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Console",
      "Intended Audience :: Science/Research",
      "License :: Other/Proprietary License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.4",
      "Topic :: Scientific/Engineering :: Chemistry"
    ],
    "description": "This document was last updated on July 16 2018, for version 3.1.3\n# The Dplus Python API\n\nThe D+ Python API allows using the D+ backend from Python, instead of the ordinary D+ application.\n\nThe Python API works on both Windows and Linux.\n\n## Installation\n\nInstalling the Python API is done using PIP:\n\n    pip install dplus-api\n\nThe API was tested with Python 3.5 and newer. It *may* work with older versions of Python, although Python 2 \nis probably not supported.\n\n## Overview\n\nSome notes:\nThroughout the manual, code examples are given with filenames, such as \"mystate.state\". \nTo run the example code for yourself, these files must be located in the same directory as the script itself, \nor alternately the code can be modified to contain the full path of the file's location.\n\nThroughout the manual, we mention \"`State` files\". A `state` file is a \nJavaScript Object Notation (JSON) format file (https://www.json.org/), \nwhich describes the parameter tree and calculation settings of the D+ computation.\n\nIt is unnecessary to write a `state` file yourself. \n`State` files can either be generated from within the python interface (with the function `export_all_parameters`),\nor created from the D+ GUI (by selecting `File`>`Export All Parameters` from within the D+ GUI).\n\n**The overall flow of the Python API is as follows:**\n\n1. The data to be used for the calculation is built by the user in an instance of the `CalculationInput` class. \n`CalculationInput` is a child class of the class `State`, which represents a program state. A `State` includes both \nprogram preferences such as `DomainPreferences`, and a parameter tree composed of `Models`.\n2. `CalculationInput` is then passed to a `CalculationRunner` class (either `LocalRunner` or `WebRunner`), \nand a calculation function is called (`generate`, `generate_async`, `fit`, or `fit_async`).\n\n3. The `CalculationRunner` class returns an instance of a `CalculationResult` class, \neither `FitResult` or `GenerateResult`.\nHere is a very simple example of what this might look like in main.py:\n\n```\nfrom dplus.CalculationInput import CalculationInput\nfrom dplus.CalculationRunner import LocalRunner\n\ncalc_data = CalculationInput.load_from_state_file(\"mystate.state\")\nrunner = LocalRunner()\nresult = runner.generate(calc_data)\nprint(result.graph)\n```\n\nA detailed explanation of the class types and their usage follows.\n\n\n## CalculationRunner\n\nThere are two kinds of `CalculationRunners`, Local and Web.\n\nThe `LocalRunner` is intended for users who have the D+ executable files installed on their system. \nIt takes two optional initialization arguments:\n\n* `exe_directory` is the folder location of the D+ executable. \nBy default, its value is `None`. On Windows, a value of `None` will \nlead to the python interface searching the registry for an installed D+ on its own, but on Linux the executable \ndirectory *must* be specified. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \n* `session_directory` is the folder where the arguments for the calculation are stored, as well as the output results, \nAmplitude files, and PDB files, from the C++ executable. \nBy default, its value is `None`, and an automatically generated temporary folder will be used. \n```\nfrom dplus.CalculationRunner import LocalRunner\n\nexe_dir = r\"C:\\Program Files\\D+\\bin\"\nsess_dir = r\"sessions\"\nrunner = LocalRunner(exe_dir, sess_dir)\n#also possible:\n#runner = LocalRunner()\n#runner = LocalRunner(exe_dir)\n#runner = LocalRunner(session_directory=sess_dir)\n#runner= LocalRunner(exe_directory=exe_dir, session_directory=sess_dir)\n```\nNote that `exe_dir`  and  `sess_dir` are variables in which paths are stored in. `exe_directory`  and `session_directory` are the names of the `LocalRunner` arguments, to which `exe_dir`  and  `sess_dir` are passing to, respectively. \n\nThe `WebRunner` is intended for users accessing the D+ server. It takes two required initialization arguments, with no \ndefault values:\n\n* `url` is the address of the server.\n* `token` is the authentication token granting access to the server. \n\n```\nfrom dplus.CalculationRunner import WebRunner\n\nurl = r'http://localhost:8000/'\ntoken = '4bb25edc45acd905775443f44eae'\nrunner = WebRunner(url, token)\n```\n\nBoth runner classes have the same four methods: \n\n`generate(calc_data)`, `generate_async(calc_data)`, `fit(calc_data)`, and `fit_async(calc_data)`.\n\nAll four methods take the same single argument, `calc_data` , which is an instance of a `CalculationData` class.\n\n`generate` and `fit` return a `CalculationResult`.\n\n`generate_async` and `fit_async` return a `RunningJob`.\n\nWhen using `generate` or `fit` the program will wait until the call has finished and returned a result, before continuing. \nTheir asynchronous counterparts (`generate_async` and `fit_async`) allow D+ calculations to be run in the background \n(for example, the user can call `generate_async`, tell the program to do other things, \nand then return and check if the computation is finished). \n#### RunningJob\n\nThe user should not be initializing this class. When returned from an async function\n(`generate_async` or `fit_async`) in `CalculationRunner`, the user can \nuse the following methods to interact with the `RunningJob` instance:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\n* `get_status()`: get a JSON dictionary reporting the job's current status\n* `get_result(calc_data)`: get a `CalculationResult`. Requires a copy of the `CalculationInput` used to create the job. \nIt should only be called when the job is completed. It is the user's responsibility to verify job completion with `get_status`, \nbefore calling. \t\t\t\t\n* `abort()`: end a currently running job\n\nHere is an example:\n```\nfrom dplus.CalculationInput import CalculationInput\nfrom dplus.CalculationRunner import LocalRunner\n\n calc_data = CalculationInput.load_from_state_file(\"mystate.state\")\n runner = LocalRunner()\n job = runner.generate_async(calc_data)\n start_time = datetime.datetime.now()\n status = job.get_status()\n while status['isRunning']:\n     status = job.get_status()\n     run_time = datetime.datetime.now() - start_time\n     if run_time > datetime.timedelta(seconds=50):\n         job.abort()\n         raise TimeoutError(\"Job took too long\")\n result = job.get_result(calc_data)\n```\n\n\n\n## State\nThe `State` class contains an instance of each of three classes: `DomainPreferences`, `FittingPreferences`, and `Domain`. The classes are described in the upcoming sections.\nThe `State` class has the methods:\n\n* `get_model`: get a model by either its `name` or its pointer, `model_ptr`.\n* `get_models_by_type`: returns a list of `Models` with a given `type_name`, for example, `UniformHollowCylinder`.\n* `get_mutable_params`: returns a list of `Parameters` in the `State` class, whose property `mutable` is `True`.\n* `get_mutable_parameter_values`: returns a list of floats, matching the values of the mutable parameters.\n* `set_mutable_parameter_values`: given a list of float numbers, sets the mutable parameters of the `State` \n(in the order given by `get_mutable_parameter_values`).\t\t\t\t\n* `export_all_parameters`: given a filename, will save the calculation `State` to that file.\n* `add_model`: a convenience function to help add models to the parameter tree of a `State`. It receives the model and, optionally, \na population index (default 0), and will insert that model into the population.\n* `add_amplitude`: a convenience function specifically for adding instances of the `Amplitude` class, described below. \nIt creates an instance of an `AMP` class with the filename of the `Amplitude`. Then, in addition to calling `add_model` with that `AMP` instance, \nit also changes the `DomainPreferences` of the `State` (specifically, `grid_size`, `q_max`, and `use_grid`), to match the properties of the `Amplitude`. \nIt returns the `AMP` instance it created.\t\n`State`, and every class and sub class contained within `State` (for example: `DomainPreferences`, `Model`, `Parameter`), all have the functions  `load_from_dictionary` and `serialize`.\n\n`load_from_dictionary` sets the values of the various fields within a class to match those contained within a suitable dictionary. It can behave recursively as necessary, for example, with a model that has children.\n\n`serialize` saves the contents of a class to a dictionary. Note that there may be additional fields in the dictionary beyond those described in this document, because some defunct (outdated, irrelevant, or not-yet-implemented) fields are \nstill saved in the serialized dictionary.\n\n#### DomainPreferences\nThe `DomainPreferences` class contains properties that are copied from the D+ interface. Their usage is explained in the D+ documentation.\n\nWe create a new instance of `DomainPreferences` by calling the python initialization function:\n\n`dom_pref= DomainPreferences()`\n\nThere are no arguments given to the initialization function, and all the properties are set to default values:\n\n|Property Name | Default Value | Allowed values|\n|---|---|---|\n|`signal_file`|\t`\"\"`|\"\", or a valid file location|\n|`convergence`|\t0.001||\n|`grid_size`|\t100|Even integer greater than 20|\n|`orientation_iterations`|\t100||\n|`orientation_method`|\t`\"Monte Carlo (Mersenne Twister)\"`|`\"Monte Carlo (Mersenne Twister)\", \"Adaptive (VEGAS) Monte Carlo\", \"Adaptive Gauss Kronrod\"`|\n|`use_grid`|\t`False`| `True`, `False`|\n|`q_max`|\t7.5|Positive number. If signal file is provided, must match highest x value|\n\nAny property can then be easily changed, for example, \n\n`dom_pref.q_max= 10`\n\nIf users try to set a property to an invalid value (for example, setting `q_max` to something other than a positive number) they will get an error.\n\nIf a `signal file` is provided, the value of `q_max` will automatically be set to the highest `x` value in the `signal file`.\n\n\n#### Fitting Preferences\nThe `FittingPreferences` class contains properties that are copied from the D+ interface. Their usage is explained in the D+ documentation.\n\nWe create a new instance of `FittingPreferences` by calling the python initialization function:\n\n`fit_pref= FittingPreferences()`\n\nThere are no arguments given to the initialization function, and all the properties are set to default values:\n\n|Property Name | Default Value |Allowed Values|Required when|\n|---|---|---|---|\n|`convergence`|\t0.1| Positive numbers||\n|`der_eps`|\t0.1| Positive numbers||\n|`fitting_iterations`|\t20|Positive integers||\n|`step_size`|0.01| Positive numbers||\n|`loss_function`|`\"Trivial Loss\"`| `\"Trivial Loss\",\"Huber Loss\",\"Soft L One Loss\",\"Cauchy Loss\",\"Arctan Loss\",\"Tolerant Loss\"`||\n|`loss_func_param_one`|0.5|Number|Required for all `loss_function` values except \"Trivial Loss\"|\n|`loss_func_param_two`|0.5|Number|Required when `loss_function` is \"Tolerant Loss\"|\n|`x_ray_residuals_type`|`\"Normal Residuals\"`|`\"Normal Residuals\",\"Ratio Residuals\",\"Log Residuals\"`||\n|`minimizer_type`|`\"Trust Region\"`|`\"Line Search\",\"Trust Region\"`||\n|`trust_region_strategy_type`|`\"Dogleg\"`|`\"Levenberg-Marquardt\",\"Dogleg\"`|`minimizer_type` is `\"Trust Region\"`|\n|`dogleg_type`|`\"Traditional Dogleg\"`|`\"Traditional Dogleg\",\"Subspace Dogleg\"`|`trust_region_strategy_type` is `\"Dogleg\"`|\n|`line_search_type`|`\"Armijo\"`|`\"Armijo\",\"Wolfe\"`|`minimizer_type` is `\"Line Search\"`|\n|`line_search_direction_type`|`\"Steepest Descent\"`|`\"Steepest Descent\",\"Nonlinear Conjugate Gradient\",\"L-BFGS\",\"BFGS\"`|`minimizer_type` is `\"Line Search\"`. if `line_search_type` is `\"Armijo\"`, cannot be `\"BFGS\"` or `\"L-BFGS\"`. |\n|`nonlinear_conjugate_gradient_type`|`\"\"`|`\"Fletcher Reeves\",\"Polak Ribirere\",\"Hestenes Stiefel\"`|`linear_search_direction_type` is `\"Nonlinear Conjugate Gradient\"`|\n\nAny property can then be easily changed, for example,\n\n`fit_pref.convergence= 0.5`\n\nIf the user tries to set a property to an invalid value they will get an error.\n\n\n#### Domain\n\nThe `Domain` class describes the parameter tree. \n\nThe root of the tree is the `Domain` class. This class contains an array of `Population` classes. \nEach `Population` can contain a number of `Model` classes. Some models have children, which are also models.\n\n##### Models\n\n`Domain` and `Population` are two special kinds of models.\n\nThe `Domain` model is the root of the parameter tree, which can contain multiple populations. \nPopulations can contain standard types of models.\n\nThe available standard model classes are:\n\n* `UniformHollowCylinder`\n* `Sphere`\n* `SymmetricLayeredSlabs`\n* `AsymmetricLayeredSlabs`\n* `Helix`\n* `DiscreteHelix`\n* `SpacefillingSymmetry`\n* `ManualSymmetry`\n* `PDB`- a PDB file\n* `AMP`- an amplitude grid file\n\nYou can create any `model` by calling its initialization. \n\nPlease note that models are dynamically loaded from those available in D+. \nTherefore, your code editor may underline the model in red even if the model exists.\n\nAll models have `location_params` (Location Parameters) and  `extra_params` (Extra Parameters). \nSome models (that support layers) also contain `layer_params` (Layer Parameters). \nThese are all collection of instances of the `Parameter` class, and can be accessed from\n`model.location_params`, `model.extra_params`, and `model.layer_params`, respectively. \n\nAll of these can be modified. They are accessed using dictionaries. \nHere is an example:\t\n\n```\nfrom dplus.DataModels.models import UniformHollowCylinder\n\nuhc=UniformHollowCylinder()\nuhc.layer_params[1][\"Radius\"].value=2.0\nuhc.extra_params[\"Height\"].value=3.0\nuhc.location_params[\"x\"].value=2\n```\n\nFor additional information about which models have layers and what the various parameters available for each model are, please consult the User's Manual of D+.\n\n###### Parameters\n\nThe `Parameter` class contains the following properties:\n\n`value`: a float whose default value is `0`\n\n`sigma`: a float whose default value is `0`\n\n`mutable`: a boolean whose default value is `False`\n\n`constraints`: an instance of the `Constraints` class, its default value is the default `Constraints`\n\nUsage:\n\n```  \np=Parameter()  # Creates a parameter with value: `0`, sigma: `0`, mutable: `False`, and the default constraints.\np=Parameter(7) # Creates a parameter with value: `7`, sigma: `0`, mutable: `False`, and the default constraints.\np=Parameter(sigma=2) # Creates a parameter with value: `0`, sigma: `2`, mutable: `False`, and the default constraints.\np.value= 4  # Modifies the value to be 4.\np.mutable=True # Modifies the value of mutable to be `True`.\np.sigma=3 # Modifies sigma to be 3.\np.constraints=Constraints(min_val=5) # Sets constraints to a `Constraints` instance whose minimum value (min_val) is 5.\n```\n###### Constraints\n\nThe `Constraints` class contains the following properties:\n\n`MaxValue`: a float whose default value is `infinity`.\n\n`MinValue`: a float whose default value is `-infinity`.\n\nThe usage is similar to `Parameter` class, for example:\n\n```\nc=Constraints(min_val=5) #creates a `Constraints` instance whose minimum value is 5 and whose maximum value is the default (`infinity`).\n```\n\n## CalculationInput\n\n`CalculationInput` class inherits from `State` class and therefore has access to all its functions and properties. \n\nIn addition, it contains the following properties of its own:\n\n* `x`: an array of q values\n* `y`: an array of intensity values from a signal, optional. Used for running fitting.\n* `use_gpu`: a boolean whose default value is `True`, representing whether D+ should use the GPU\n* `args`: a JSON dictionary of the arguments required to run `generate.exe` or `fit.exe`\n\nThe function `load_graph` can load `x` and `y` values from an ordered or unordered dictionary of `x:y` pairs.\nThe function `load_signal_file` can load `x` and `y` values from an existing `signal file`.\n\n\nA new instance of `CalculationInput` can be created simply by calling its constructor.\n\nAn empty constructor will cause `CalculationInput` to be created with default values derived from the default `State`.\n\nAlternately, the constructor can be called with either `graph` or `x` and/or `y` provided as arguments, and these will then be used to override the default values derived from the default `State`.\n\nIn addition, `CalculationInput` has the following static methods to create an instance of `GenerateInput`:\n\n* `load_from_state_file` receives the location of a file that contains a serialized parameter tree (`State`).\n* `load_from_PDB` receives the location of a PDB file, and automatically creates a guess of the best `State` parameters based on the PDB file.\n * `copy_from_state` returns a new `CalculationInput` based on an existing `state` or `CalculationInput`. \n\nHere is an example:\n\n```\nfrom dplus.CalculationInput import CalculationInput\ngen_input=CalculationInput()\n```\n\n`CalculationInput()` gets all of the default values of `State`  listed in the Tables of default values for `DomainPreferences` and `FittingPreferences`. The default `Domain` is a `DomainModel` with a single empty `Population`.\n\nIf no `x` vector is provided in the constructor, a default `x` vector is created automatically based on the default `DomainPreferences` value for for `q_min`, `q_max`, `generatedPoints`, as per the code below\n\n```\nqmax = float(self.q_max)  \nqmin = float(self.q_min)  \ngeneratedPoints = self.generated_points  \ngeneratedPoints += 1  \nqvec = []  \nfor i in range(generatedPoints):  \n    val = qmin + (((qmax - qmin) * float(i)) / (generatedPoints - 1))  \n    qvec.append(val)  \nreturn qvec\n```\n\nThe default `y` vector is an empty list.\n\nThe default value of `use_gpu` is `True`.\n\nSecond example:\n```\nfrom dplus.CalculationInput import CalculationInput\ngen_input=CalculationInput.load_from_state_file('sphere.state')\n```\nThis program loads `DomainPreferences`, `FittingPreferences`, and `DomainModel` from the `state` file. \nIt builds the `x` vector based on the `q_max`, `q_min`, `generatedPoints` (`res_steps`) in the `State` file. \nIf there is a signal file indicated in `DomainPreferences`, it loads both `x` and `y` vectors from that instead.\n\nThird example:\n```\nfrom dplus.CalculationInput import CalculationInput\nsignal = SignalFileReader(\"signal_file.out\")\nfit_input = CalculationInput(x=signal.x_vec, y=signal.y_vec)\n```\n\n\n## Amplitudes\n\nIn the module `Amplitudes` there is the class `Grid` and the class `Amplitude` which inherits from `Grid`.\n\n**Please note**: The class `Amplitude` is a purely Python class, not to be confused with the class `AMP` from `Dplus.DataModels.Models`\n\nThe class `AMP` contains a filename pointing to an `amplitude` file, an extra parameter `scale`, a Boolean `centered`, \nand it can be serialized and sent as part of the `Domain` parameter tree to D+. \n\nThe class `Amplitude`, by contrast, can be used to build an `amplitude` and then save that `amplitude` as an `amplitude` file, which can then be opened in D+ (or sent in a class `AMP`) but in itself cannot be added directly to the `Domain` parameter tree. \nIf you want to add it to the `tree`, you must save the amplitude to a file first, using the `save` method, and then you can use the `State`'s function, `add_amplitude`, to add it to the `tree`.\n\n\nThe class `Grid` is initialized with `q_max` in units of inverse nanometers and `grid_size`. \n\nIt is used to create (or describe) a `Grid` of `q`, `theta`, and `phi` values. \n\nThese values can be described using two sets of indexing:\n\n1. The overall index `m`\n2. The individual indices `i`, `j`, `k`\n\nThe reciprocal `Grid` structure is described in detail in the paper.\n\nIt has the following methods:\n\n* `create_grid`: a generator that returns `q`, `theta`, and `phi` in `phi`-major order.\n* `indices_from_index`: receives an overall index `m`, and returns the individual `q`, `theta`, and `phi`  indices: `i`, `j`, and `k`.\n* `angles_from_index`: receives an overall index `m`, and returns the matching `q`, `theta`, and `phi` values.\n* `angles_from_indices`: receives indices `i`, `j`, and `k`,  and returns their `q`, `theta`, and `phi`  values.\n* `index_from_indices`: receives indices `i`, `j`, and `k`, and returns the overall index `m` that matches them.\n* `indices_from_angles`: receives the values of `q`, `theta`, and `phi`, and returns the matching indices `i`, `j`, and `k`.\n* `index_from_angles`: receives angles `q`, `theta`, and `phi`, and returns the matching overall index `m`.\n\n\n```\nfrom dplus.Amplitudes import Grid\n\ng=Grid(5, 100)\nfor q,theta,phi in g.create_grid():\n    print(g.index_from_angles(q, theta, phi))\n```\n\nThe class `Amplitude` inherits from `Grid`. It is a class intended to describe the `amplitude` of a model/function, and can \nsave these values to an `amplitude` file (that can be read by D+) and can also read `amplitude` files (`AMP`), like those created by D+.\n\nLike `Grid`, `Amplitude` is initialized with `q_max` and `grid_size`.\n\n`Amplitude` overrides the `create_grid` method of `Grid`. `create_grid` of `Amplitude` requires a function as an argument. \nThis function must receive `q`, `theta`, and `phi`, and returns two values, representing the real and imaginary parts of the `amplitude`'s complex number. \nThe values can be returned as a tuple (a sequence of immutable Python objects), an array, or a Python complex number (A+Bj).\nThese values are then saved to the `Ampltiude`'s `values` property, and can also be accessed through the `complex_amplitudes_array` \nproperty as a `numpy` array of `numpy` complex types.\n\nAlternately, Amplitude has a static method, `load`,  which receives a filename of an `Amplitude` file, and returns an `Amplitude` instance \nwith the values from that file already loaded.\n\nFinally, there is the method `save`, which will save the information in the `Amplitude` class to an `Amplitude` file which can then be \npassed along to D+ to calculate its signal or perform fitting.\n\nIt has the following properties:\n\n* `headers`: a list that contains data about the class\n* `description`: an optional string the user can fill with data about the amplitude class (for example, what the type of the model). The description property will be added to the headers.\n\n```\nfrom dplus.Amplitudes import Amplitude\nmy_amp=Amplitude.load(\"myamp.amp\")\nfor c in my_amp.complex_amplitude_array:\n    print(c)\n```\n\n\n```\nfrom dplus.Amplitudes import Amplitude\n\ndef my_func(q, theta, phi):\n    return q+1, 0\n\na=Amplitude(7.5, 200)\na.description= \"An exmaple amplitude\"\t\t\t\t\t\t \na.create_grid(my_func)\na.save(\"myfile.amp\")\n```\n\nThere are examples of using Amplitudes to implement models similar to D+ in the additional examples section.\n\nThe module Amplitudes also contains two convenience functions for converting between cartesian and spherical coordinates:\n\n* `sph2cart` receives r, theta, phi and returns x, y, z\n* `cart2sph` receives x, y, z and returns r, theta, phi\n\n```\nfrom dplus.Amplitudes import sph2cart, cart2sph\n\nq, theta, phi = cart2sph(1,2,3)\nx, y, z = sph2cart(q,theta,phi)\n\n```\n\n## CalculationResult\n\nThe `CalculationResult` class is returned by the `CalculationRunner`. \nThe user should generally not be instantiating the class themselves. \n\nThe base `CalculationResult` class is inherited by `GenerateResult` and `FitResult`\n\n`CalculationResult` has the following properties:\n\n* `graph`: an OrderedDict (an ordered dictionary in which the order the items are inserted is remembered and used when creating an iterator), whose keys are `x` values and whose values are `y` values.\n* `y`: The raw list of `y` values from the JSON results.\n* `error` : returns the JSON error report from the run of D+.\n\nIn addition, `CalculationResults` has the following functions:\n\n* `get_amp(model_ptr, destination_folder)`: returns the file location of the `amplitude` file for a given `model_ptr`.  \nThe `destination_folder` has a default value of `None`, but if provided, the `amplitude` file will be copied to that location, \nand then its address is returned. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n* `get_pdb(model_ptr, destination_folder)`: returns the file location of the PDB file for given `model_ptr`. \nThe `destination_folder` has a default value of `None`, but if provided, the PDB file will be copied to that location,\n and then its address is returned. \t\t\t\t\t   \n* `save_to_out_file(filename)`: receives file name, and saves the results to the file.\n\nIn addition to the above:\n\n`GenerateResult` has a property `headers`, created by D+, to describe \nthe job that was run. It is an Ordered Dictionary, whose keys are `ModelPtr`s and whose values are the header associated. \n\n`FitResult` has two additional properties,\n* `parameter_tree`: A JSON of parameters (can be used to create a new `state` with state's `load_from_dictionary`). \nOnly present in fitting, not generate, results\n* `result_state`: a `CalculationInput` whose `Domain` contains the optimized parameters obtained from the fitting.\n\n\n## FileReaders\n\nThe API contains a module `FileReaders`. \n\nPresently all it contains is `SignalFileReader`, which can be initialized with a path to a signal file (eg a `.out` or `.dat` file), \nand will read that file into its `x_vec`, `y_vec`, and `graph` properties.\n\n\n## Additional Usage examples\n\n\n***Example One***\n\n```\nfrom dplus.CalculationInput import CalculationInput\nfrom dplus.CalculationRunner import LocalRunner\n\nexe_directory = r\"C:\\Program Files\\D+\\bin\"\nsess_directory = r\"session\"\nrunner= LocalRunner(exe_directory, sess_directory)\n\ninput=CalculationInput.load_from_state_file('spherefit.state')\nresult=runner.fit(input)\nprint(result.graph)\n```\n\n***Example Two***\n\n```\nfrom dplus.CalculationInput import CalculationInput\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.DataModels import ModelFactory, Population\nfrom dplus.State import State\nfrom dplus.DataModels.models import UniformHollowCylinder\n\nsess_directory = r\"session\"\nrunner= LocalRunner(session_directory=sess_directory)\n\nuhc=UniformHollowCylinder()\ncaldata = CalculationInput()\ncaldata.Domain.populations[0].add_model(uhc)\n\nresult=runner.generate(caldata)\nprint(result.graph)\n```\n\n***Example Three***\n\n```\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.CalculationInput import CalculationInput\n\nrunner=LocalRunner()\ncaldata=CalculationInput.load_from_PDB('1JFF.pdb', 5)\nresult=runner.generate(caldata)\nprint(result.graph)\n```\n\n***Example Four***\n\n```\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.CalculationInput import CalculationInput\nAPI=LocalRunner()\ninput = CalculationInput.load_from_state_file(\"uhc.state\")\ncylinder = input.get_model(\"test_cylinder\")\n\nprint(\"Original radius is \", cylinder.layer_params[1]['Radius'].value)\nresult = API.generate(input)\n\ninput.load_graph(result.graph)\ncylinder = input.get_model(\"test_cylinder\")\ncylinder.layer_params[1]['Radius'].value = 2\ncylinder.layer_params[1]['Radius'].mutable = True\ninput.FittingPreferences.convergence = 0.5\ninput.use_gpu = True\nfit_result = API.fit(input)\noptimized_input= fit_result.result_state\nresult_cylinder=optimized_input.get_model(\"test_cylinder\")\nprint(fit_result.parameter_tree)\nprint(\"Result radius is \", result_cylinder.layer_params[1]['Radius'].value)\n\n```\n\n### Implementing Models using Amplitudes\n\nFor the purpose of these examples, the models are implemented with minimal default parameters. \nIn a more realistic usage scenario, the user would set those parameters as editable properties to be changed at his convenience.\n\n```\nfrom dplus.Amplitudes import Amplitude\nimport math\n\nclass UniformSphere:\n    def __init__(self):\n        self.extraParams=[1,0]\n        self.ED=[333, 400]\n        self.r=[0,1]\n\n    @property\n    def nLayers(self):\n        return len(self.ED)\n\n    def calculate(self, q, theta, phi):\n        cos=math.cos\n        sin=math.sin\n        nLayers=self.nLayers\n        ED=self.ED\n        extraParams=self.extraParams\n        r=self.r\n        def closeToZero(x):\n            return (math.fabs(x) < 100.0 * 2.2204460492503131E-16)\n\n        if closeToZero(q):\n            electrons = 0.0\n            for i in range( 1, nLayers):\n                electrons += (ED[i] - ED[0]) * (4.0 / 3.0) * math.pi * (r[i] ** 3 - r[i-1] ** 3)\n            return (electrons  * extraParams[0] + extraParams[1], 0.0)\n\n        res = 0.0\n\n        for i in range(nLayers-1):\n            res -= (ED[i] - ED[i + 1]) * (cos(q * r[i]) * q * r[i] - sin(q * r[i]))\n        res -= (ED[nLayers - 1] - ED[0]) * (cos(q * r[nLayers - 1]) * q * r[nLayers - 1] - sin(q * r[nLayers - 1]))\n\n        res *= 4.0 * math.pi / (q*q * q)\n\n        res *= extraParams[0] #Multiply by scale\n        res += extraParams[1] #Add background\n\n        return (res, 0.0)\n\nsphere=UniformSphere()\na=Amplitude(7.5, 200)\na.create_grid(sphere.calculate)\na.save(\"sphere.amp\")\n\ninput = CalculationInput()\namp_model = input.add_amplitude(a)\namp_model.centered=True\nrunner=LocalRunner()\nresult=runner.generate(input)\n```\n\n```\n\nclass SymmetricSlab:\n    def __init__(self):\n        self.scale=1\n        self.background=0\n        self.xDomain=10\n        self.yDomain=10\n        self.ED=[333, 280]\n        self.width=[0,1]\n        self.OrganizeParameters()\n\n    @property\n    def nLayers(self):\n        return len(self.ED)\n\n    def OrganizeParameters(self):\n        self.width[0] = 0.0\n        self.xDomain *= 0.5\n        self.yDomain *= 0.5\n        for i in range(2, self.nLayers):\n            self.width[i] += self.width[i - 1];\n\n    def calculate(self, q, theta, phi):\n        def closeToZero(x):\n            return (math.fabs(x) < 100.0 * 2.2204460492503131E-16)\n        from dplus.Amplitudes import sph2cart\n        from math import sin, cos\n        from numpy import sinc\n        import numpy as np\n        qx, qy, qz = sph2cart(q, theta, phi)\n        res= np.complex128(0+0j)\n        if(closeToZero(qz)):\n            for i in range(self.nLayers):\n                res += (self.ED[i] - self.ED[0]) * 2. * (self.width[i] - self.width[i - 1])\n            return res * 4. * sinc(qx * self.xDomain) * self.xDomain * sinc(qy * self.yDomain) * self.yDomain\n\n        prevSin = np.float64(0.0)\n        currSin=np.float64(0.0)\n        for i in range(1, self.nLayers):\n            currSin = sin(self.width[i] * qz)\n            res += (self.ED[i] - self.ED[0]) * 2. * (currSin - prevSin) / qz\n            prevSin = currSin\n        res *= 4. * sinc((qx * self.xDomain)/np.pi) * self.xDomain * sinc((qy * self.yDomain)/np.pi) * self.yDomain\n        return res * self.scale + self.background #Multiply by scale and add background\n\n\n\nfrom dplus.Amplitudes import Amplitude\nfrom dplus.State import State\nfrom dplus.CalculationRunner import LocalRunner\nfrom dplus.CalculationInput import CalculationInput\nsphere = SymmetricSlab()\na = Amplitude(7.5, 80)\na.create_grid(sphere.calculate)\n\n```\n\n### Python Fitting\nIt is possible to fit a curve using the results from Generate and numpy's built in minimization/curve fitting functions.\nAll that is required is wrapping the interface code so that it receives and returns parameters the way scipy expects (as numpy arrays)\n\nAn example follows:\n\n```\nimport numpy as np\nfrom scipy import optimize\nfrom dplus.CalculationInput import CalculationInput\nfrom dplus.CalculationRunner import LocalRunner\n\ninput=CalculationInput.load_from_state_file(r\"2_pops.state\")\ngenerate_runner=LocalRunner()\n\ndef run_generate(xdata, *params):\n    '''\n    scipy's optimization algorithms require a function that receives an x array and an array of parameters, and\n    returns a y array.\n    this function will be called repeatedly, until scipy's optimization has completed.\n    '''\n    input.set_mutable_parameter_values(params) #we take the parameters given by scipy and place them inside our parameter tree\n    generate_results=generate_runner.generate(input) #call generate\n    return np.array(generate_results.y) #return the results of the generate call\n\nx_data=input.x\ny_data=input.y\np0 = input.get_mutable_parameter_values()\nmethod='lm' #lenenberg-marquadt (see scipy documentation)\npopt, pcov =optimize.curve_fit(run_generate, x_data, y_data, p0=p0, method=method)\n\n#popt is the optimized set of parameters from those we have indicated as mutable\n#we can insert them back into our CalculationInput and create the optmized parameter tree\ninput.set_mutable_parameter_values(popt)\n#we can run generate to get the results of generate with them\nbest_results=generate_runner.generate(input)\n```\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://scholars.huji.ac.il/uriraviv",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dplus-api",
    "package_url": "https://pypi.org/project/dplus-api/",
    "platform": "",
    "project_url": "https://pypi.org/project/dplus-api/",
    "project_urls": {
      "Homepage": "https://scholars.huji.ac.il/uriraviv"
    },
    "release_url": "https://pypi.org/project/dplus-api/3.1.3/",
    "requires_dist": [
      "numpy (>=1.10)",
      "psutil (==5.2.2)",
      "requests (==2.10.0)"
    ],
    "requires_python": "",
    "summary": "Call the DPlus Calculation Backend",
    "version": "3.1.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14530274,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2759d743d692bbf43a5c62d55d639712f43fbf2c8189a40721ad5741ad1bc6b3",
        "md5": "f3a39806d9ba5bd501ce96cb3b2230cd",
        "sha256": "f421e9d9a08ded99fa9431a5afc4c9dce3163c8c7fdfa215027293de0423cf93"
      },
      "downloads": -1,
      "filename": "dplus_api-3.1.3-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "f3a39806d9ba5bd501ce96cb3b2230cd",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 56781,
      "upload_time": "2018-07-17T07:47:19",
      "upload_time_iso_8601": "2018-07-17T07:47:19.698658Z",
      "url": "https://files.pythonhosted.org/packages/27/59/d743d692bbf43a5c62d55d639712f43fbf2c8189a40721ad5741ad1bc6b3/dplus_api-3.1.3-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d546d437f3119f5880eb01ebee58434f3a27aa7d2f87144f6f774ed20be661cd",
        "md5": "e30a268a5ff27d0d241e63dbad3ff4a9",
        "sha256": "d470d84be8087ab4d9d29dc43d809bbd8971704c6260ebf8bfc866586996d825"
      },
      "downloads": -1,
      "filename": "dplus-api-3.1.3.tar.gz",
      "has_sig": false,
      "md5_digest": "e30a268a5ff27d0d241e63dbad3ff4a9",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 60759,
      "upload_time": "2018-07-17T07:47:23",
      "upload_time_iso_8601": "2018-07-17T07:47:23.471892Z",
      "url": "https://files.pythonhosted.org/packages/d5/46/d437f3119f5880eb01ebee58434f3a27aa7d2f87144f6f774ed20be661cd/dplus-api-3.1.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}