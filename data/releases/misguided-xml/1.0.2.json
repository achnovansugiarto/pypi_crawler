{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "Note that you should probably use ElementTree rather than this. I wrote this while I was learning Python,for shits and giggles. Adding what I needed as I needed it. Turns out reinventing the wheel wasn't the best idea, particularly as I have an aversion regular expressions, meaning while there's searching, it's not XPATH.\r\nHome-page: https://bitbucket.org/daycoder/misguided_xml.git\r\nAuthor: Hywel Thomas\r\nAuthor-email: hywel.thomas@mac.com\r\nLicense: MIT\r\nDownload-URL: https://bitbucket.org/daycoder/misguided_xml.git/get/1.0.2.tar\r\nDescription: \r\n        # XML (source file)\r\n        \r\n        Classes to support reading, modifying and writing XML. Note that namespace support is unfinished, so don't use if you need that!\r\n                   \r\n             \r\n        \r\n        ## XMLDeclaration (Class)\r\n        \r\n        Validates the declaration and extracts and stores any atrributes. i.e. makes sure it looks like `<?xml attr1=\"attr1 value\" attrN=\"attrN value?>` and is on a single line.\r\n        \r\n        Used by XML.\r\n        \r\n        \r\n        ## XMLComment (Class)\r\n        \r\n        Stores the comment string.  When retrieved as a string, wraps the comment appropriately with opening and closing strings. i.e. stores `\"this is a comment\"`, regurgitates `\"\\<!--this is a comment-->\"`\r\n        \r\n        Used by XML.\r\n        \r\n        ## XMLCDATA (Class)\r\n        \r\n        Stores the CDATA string.  When retrieved as a string, wraps the comment appropriately with opening and closing strings. i.e. stores `\"A9043BC658EFBA6\"`, regurgitates `\"\\<![CDATA[[A9043BC658EFBA6]]>\"`\r\n        \r\n        Used by XML.\r\n        \r\n        \r\n        ## XML (Class)\r\n        \r\n        The XML extracts and stores any declaration, comments, values, CDATA and elements. namespaces are extracted, but aren't properly functional yet.\r\n        \r\n        Taking this element:\r\n        ```xml\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        \t<!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        \t<!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n        \t<MediaReferenceName>BL77318</MediaReferenceName>\r\n        </PhysicalAsset>\r\n        ```\r\n        We have an object with these values:\r\n        \r\n        Field         | Description\r\n        --------------|------------\r\n        `tag`         | `PhysicalAsset`\r\n        `attributes`  | `{\"assetName\" : \"CAS-CASBNU\"}`\r\n        `children`    | `[XMLComment, XMLComment, XMLElement]`\r\n        \r\n        The children have these values:\r\n        \r\n        Field         | Description\r\n        --------------|------------\r\n        `comment`     |  ` assetName = concatenation of <TypeofElement> and <FormatofElement> above `\r\n        \r\n        Field         | Description\r\n        --------------|------------\r\n        `comment`     |  ` From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  `\r\n        \r\n        Field         | Description\r\n        --------------|------------\r\n        `tag`         | `MediaReferenceName`\r\n        `value   `    | `BL77318`\r\n        \r\n        ### Useful methods:\r\n        \r\n        Note that a number of these methods should really be considered private, but I wasn't aware of the Python convention for indicating this when it was originally written (ditton use of camelCase).  It's probably worth marking these as private, e.g. rename `getTag` to `__getTag`.\r\n        \r\n        \r\n        #### find\r\n        \r\n        parameter         | Description\r\n        ------------------|------------\r\n        `element` | a dictionary containing search criteria\r\n        `value` | a dictionary containing search criteria\r\n        `attribute` | a dictionary containing search criteria\r\n        `element` | a dictionary containing search criteria\r\n        \r\n        \r\n        search_criteria dictionary:\r\n        ```python        \r\n        {'Element'   : \"\"\"Describes the path to the node of the XML tree\r\n                           e.g. <MediaRequest><VersionNumber>\r\n                           Attributes may also be added, which can help\r\n                           narrow the search when there are many elements\r\n                           of the same type at the same level.\r\n                           e.g. <MediaRequest><AudioTrack trackNumber=\"1\">\"\"\",\r\n                         \r\n         'Value'     : \"\"\"Only nodes with this value will be matched.\r\n                          This is useful for checking that a value\r\n                          is present.\"\"\",\r\n                         \r\n         'Attribute' : \"\"\"If a particular attribute of an element is\r\n                          what we're interested in rather than the\r\n                          whole element, then the named attribute\r\n                          value is returned.\"\"\"}\r\n        ```                        \r\n        \r\n        Examples:\r\n        \r\n        ```python\r\n        >>> element = XML.XMLElement(\"\"\"<MediaRequest OriginatingSystem=\"OSCAR\">\r\n        ...                                 <VersionNumber>12345</VersionNumber>\r\n        ...                                 <AudioTrack TrackNumber=\"1\">\r\n        ...                                     <Level>-23</Level>\r\n        ...                                 </AudioTrack>\r\n        ...                                 <AudioTrack TrackNumber=\"2\">\r\n        ...                                     <Level>-23</Level>\r\n        ...                                 </AudioTrack>\r\n        ...                             </MediaRequest>\"\"\")\r\n        >>> \r\n        >>> print element.search({'Element':'<MediaRequest><AudioTrack TrackNumber=\"1\">'})\r\n        <AudioTrack TrackNumber=\"1\">\r\n            <Level>-23</Level>\r\n        </AudioTrack>\r\n        >>> \r\n        >>> print element.search({'Element':'<MediaRequest><VersionNumber>',\r\n        ...                        'Value'  :'12345'})\r\n        <VersionNumber>12345</VersionNumber>\r\n        >>> \r\n        >>> print element.search({'Element':'<MediaRequest>',\r\n        ...                       'Attribute':'OriginatingSystem'})\r\n        OSCAR\r\n        ```\r\n        \r\n        #### exists\r\n        \r\n        parameter         | Description\r\n        ------------------|------------\r\n        `search_criteria` | See search\r\n        \r\n        Returns a True if there's a hit:\r\n        \r\n        ```python\r\n        >>> print element.exists({'Element':'<MediaRequest><VersionNumber>'})\r\n        True\r\n        >>> \r\n        >>> print element.exists({'Element':'<MediaRequest><SomethingMadeUp>'})\r\n        False \r\n        ```\r\n        \r\n        #### dictionary\r\n        \r\n        parameter           | Description\r\n        --------------------|------------\r\n        `include_first_tag` | Defaults to False. See below for an example. Usually, if you have an element, you know where you are in the tree, and the tag of the element is an inconvenience.\r\n        \r\n        This returns the XMLElement tree tags and value as a Python dictionary:\r\n        \r\n        ```python\r\n        >>> import XML\r\n        >>> import pprint\r\n        >>> \r\n        >>> xml = XML.XML(\"\"\"<?xml version = \"1.0\" encoding = \"UTF-8\"?>\r\n        ...                  <MediaRequest OriginatingSystem=\"OSCAR\" attribute2=\"OSCAR\">\r\n        ...                      <VersionNumber>12345</VersionNumber>\r\n        ...                      <AudioTrack TrackNumber=\"1\">\r\n        ...                          <Level someattr=\"x\">-1</Level>\r\n        ...                      </AudioTrack>\r\n        ...                      <AudioTrack TrackNumber=\"2\">\r\n        ...                          <Level>-2</Level>\r\n        ...                      </AudioTrack>\r\n        ...                      <AudioTrack TrackNumber=\"3\">\r\n        ...                          <Level>-3</Level>\r\n        ...                      </AudioTrack>\r\n        ...                  </MediaRequest>\"\"\")\r\n        >>> \r\n        >>> media_request = xml.find({'Element':'<MediaRequest>'})\r\n        >>> pprint.pprint(media_request.dictionary())\r\n        {'@OriginatingSystem': u'OSCAR',\r\n         '@attribute2': u'OSCAR',\r\n         u'AudioTrack': [{'@TrackNumber': u'1',\r\n                          u'Level': {'@someattr': u'x', u'Level': u'-1'}},\r\n                         {'@TrackNumber': u'2', u'Level': u'-2'},\r\n                         {'@TrackNumber': u'3', u'Level': u'-3'}],\r\n         u'VersionNumber': u'12345'}\r\n        >>> \r\n        >>> audio_track_1_element = xml.find({'Element':'<MediaRequest><AudioTrack TrackNumber=\"1\">'})\r\n        >>>\r\n        >>> pprint.pprint(audio_track_1_element.dictionary())\r\n        {'@TrackNumber': u'1', u'Level': {'@someattr': u'x', u'Level': u'-1'}}\r\n        >>>\r\n        >>> pprint.pprint(audio_track_1_element.dictionary(include_first_tag=True))\r\n        {u'AudioTrack': {'@TrackNumber': u'1',\r\n                         u'Level': {'@someattr': u'x', u'Level': u'-1'}}}\r\n        ```112\r\n        \r\n        If the element has attributes, they're added to the dictionary with an `'@'` prefix.  If it's a leaf node with a value and attributes, rather than just a value, a dictionary is created containing the attributes and value, with the key for the value being the tag.\r\n        \r\n        #### find\r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `path`       | a list of tags, which can include attributes\r\n        `whereValue` | a value to match.\r\n        \r\n        \r\n        Search for a matching element:\r\n        \r\n        ```python\r\n        $ python\r\n        Python 2.7.8 (v2.7.8:ee879c0ffa11, Jun 29 2014, 21:07:35) \r\n        [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin\r\n        Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n        >>>\r\n        >>> import XML\r\n        >>> element = XML.XMLElement(\"\"\"<PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        ...                                 <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        ...                                 <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n        ...                                 <MediaReferenceName>BL77318</MediaReferenceName>\r\n        ...                                 <Appendix>1</Appendix>\r\n        ...                                 <Appendix>2</Appendix>\r\n        ...                                 <Appendix>3</Appendix>\r\n        ...                                 <Appendix>4</Appendix>\r\n        ...                             </PhysicalAsset>\"\"\")\r\n        >>> element.find(path = [u'PhysicalAsset assetName=\"CAS-CASBNU\"',u'MediaReferenceName'])\r\n        <XML.XMLElement object at 0x1025e8c10>\r\n        >>> element.find(path = [u'PhysicalAsset assetName=\"CAS-CASBNU\"',u'MediaReferenceName']).value\r\n        u'BL77318'\r\n        >>>\r\n        ```\r\n        \r\n        `None` is returned if there are no matches:\r\n        ```python\r\n        >>> element.find(path = [u'PhysicalAsset assetName=\"TAPE\"',u'MediaReferenceName']) == None\r\n        True\r\n        ```\r\n        \r\n        A list of elements is returned if there are more than one match:\r\n        ```python\r\n        >>> element.find(path = [u'PhysicalAsset',u'Appendix'])\r\n        [<XML.XMLElement object at 0x1025e8b50>, <XML.XMLElement object at 0x1025e8c50>, <XML.XMLElement object at 0x1025e8c90>, <XML.XMLElement object at 0x1025e8cd0>]\r\n        >>> element.find(path = [u'PhysicalAsset',u'Appendix'])[2].value\r\n        u'3'\r\n        >>> \r\n        ```\r\n        \r\n        #### remove\r\n        \r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `path`       | a list of tags, which can include attributes\r\n        `value`      | a value to match.\r\n        \r\n        Performs a `find` and removes the found element or elements:\r\n        \r\n        ```python\r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <Appendix>1</Appendix>\r\n            <Appendix>2</Appendix>\r\n            <Appendix>3</Appendix>\r\n            <Appendix>4</Appendix>\r\n        </PhysicalAsset>\r\n        >>> \r\n        >>> element.remove(path=[u'PhysicalAsset assetName=\"CAS-CASBNU\"',u'Appendix'], value = '2')\r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <Appendix>1</Appendix>\r\n            <Appendix>3</Appendix>\r\n            <Appendix>4</Appendix>\r\n        </PhysicalAsset>\r\n        >>>\r\n        >>> element.remove(path=[u'PhysicalAsset assetName=\"CAS-CASBNU\"',u'Appendix'])\r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n        </PhysicalAsset>\r\n        ```\r\n        \r\n        #### add\r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `bytes`      | a string or a StringReader object\r\n        \r\n        Adds XML as a childe of the element:\r\n        \r\n        ```python\r\n        >>> \r\n        >>> element.add(\"\"\"<Appendices/>\"\"\")\r\n        >>> \r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <Appendices/>\r\n        </PhysicalAsset>\r\n        >>> \r\n        ```\r\n        \r\n        #### addAtPath\r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `path`       | a list of tags, which can include attributes\r\n        `bytes`      | a string or a StringReader object\r\n        \r\n        Adds XML as a childe of the element:\r\n        \r\n        ```python\r\n        >>> element.addAtPath(path  = [u'PhysicalAsset',u'Appendices'],\r\n        ...                   bytes = \"\"\"<title>Appendix 1</title>\"\"\")\r\n        >>> \r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <Appendices>\r\n                <title>Appendix 1</title>\r\n            </Appendices>\r\n        </PhysicalAsset>\r\n        ```\r\n        \r\n        #### replace\r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `bytes`      | a string or a StringReader object\r\n        `path`       | a list of tags, which can include attributes\r\n        `value`      | a value to match.\r\n        \r\n        Substitues an element for the new XML:\r\n        \r\n        ```python\r\n        >>> \r\n        >>> element.replace(bytes = \"\"\"<index>\r\n        ...                                <page>1</page>\r\n        ...                                <value>How to use XMLElement</value>\r\n        ...                             </index>\"\"\",\r\n        ...                 path  = [u'PhysicalAsset',u'Appendices'])\r\n        >>> print element\r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <index>\r\n                <page>1</page>\r\n                <value>How to use XMLElement</value>\r\n            </index>\r\n        </PhysicalAsset>\r\n        >>> \r\n        ```\r\n        \r\n        #### replaceValueAtPath\r\n        \r\n        parameter    | Description\r\n        -------------|------------\r\n        `path`       | a list of tags, which can include attributes\r\n        `whereValue` | (optional) a value to match.\r\n        `newValue`   | The new value. Optional. If `None`, will remove the element at the path.\r\n        \r\n        Replaces the value at the element found at the path with the new value.:\r\n        \r\n        ```python\r\n        >>> \r\n        >>> element.replaceValueAtPath(path     = [u'PhysicalAsset',u'index',u'value'],\r\n        ...                            newValue = \"Confessions of a Python Developer\")\r\n        >>> print element \r\n        <PhysicalAsset assetName=\"CAS-CASBNU\">\r\n        <!-- assetName = concatenation of <TypeofElement> and <FormatofElement> above -->\r\n        <!-- From spec: \"List of tape storage formats : BetaSp; DigiBeta; MiniDV; etc.\"  -->\r\n            <MediaReferenceName>BL77318</MediaReferenceName>\r\n            <index>\r\n                <page>1</page>\r\n                <value>Confessions of a Python Developer</value>\r\n            </index>\r\n        </PhysicalAsset>\r\n        ```\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        # [StringReader][StringReader]\r\n        \r\n        Used by XML to navigate the XML string, search for tags, extract data etc.\r\n        \r\n        You may see this class used occasionally in tests. That's no longer required. XML's initialisation used to require data in this form.  Now it tries to convert data to StringReader first.\r\n        \r\nKeywords: XML\r\nPlatform: UNKNOWN\r\nClassifier: Development Status :: 5 - Production/Stable\r\nClassifier: Intended Audience :: Developers\r\nClassifier: License :: OSI Approved :: MIT License\r\nClassifier: Programming Language :: Python :: 2\r\nClassifier: Programming Language :: Python :: 2.7\r\nClassifier: Topic :: Utilities\r\n",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "misguided-xml",
    "package_url": "https://pypi.org/project/misguided-xml/",
    "platform": "",
    "project_url": "https://pypi.org/project/misguided-xml/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/misguided-xml/1.0.2/",
    "requires_dist": [
      "fdutil (>=1.2.2)",
      "six (>=1.11.0)"
    ],
    "requires_python": "",
    "summary": "Read/Write/Create/Modify/Search/Format XML files..",
    "version": "1.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 4514374,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1ea008102e059776293cfa203255931152f223c5a79b5d6a5ae2f00837f15085",
        "md5": "d76bebc93fbf4c316d3cfd97920d7fae",
        "sha256": "cf538e0b2c549233c699e591530138d6ba4d306df02b2a60b66a4118aeca029c"
      },
      "downloads": -1,
      "filename": "misguided_xml-1.0.2-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "d76bebc93fbf4c316d3cfd97920d7fae",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 23046,
      "upload_time": "2017-11-03T19:19:48",
      "upload_time_iso_8601": "2017-11-03T19:19:48.061806Z",
      "url": "https://files.pythonhosted.org/packages/1e/a0/08102e059776293cfa203255931152f223c5a79b5d6a5ae2f00837f15085/misguided_xml-1.0.2-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c3c96cb646506812b0a4985c2fa40e6ca7c619ac1057bd657a00cfadba825ba0",
        "md5": "3635b640b7a818861d3653a6bc394641",
        "sha256": "4970a1120d9c178070ebb28f50ca28559634f6c76fbfd14f0daa4bfce9113c81"
      },
      "downloads": -1,
      "filename": "misguided_xml-1.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "3635b640b7a818861d3653a6bc394641",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 19662,
      "upload_time": "2017-11-03T19:19:49",
      "upload_time_iso_8601": "2017-11-03T19:19:49.496707Z",
      "url": "https://files.pythonhosted.org/packages/c3/c9/6cb646506812b0a4985c2fa40e6ca7c619ac1057bd657a00cfadba825ba0/misguided_xml-1.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}