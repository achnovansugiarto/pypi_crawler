{
  "info": {
    "author": "Naphat Amundsen",
    "author_email": "naphat@live.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "![badge](https://github.com/Napam/meny/actions/workflows/pushpull.yml/badge.svg)\n![badge](https://github.com/Napam/meny/actions/workflows/publish.yml/badge.svg)\n[![PyPI version](https://badge.fury.io/py/meny.svg)](https://badge.fury.io/py/meny)\n\n# Meny\n\nMeny is a super light weight framework for creating CLI menus\n\n![If you see this text, then the gif is broken](https://media.giphy.com/media/SKUrfvxzbXkQ80gdMM/giphy.gif)\n\n### Imagine this:\n1. You have implemented some functions in some Python file (regardless of the intention of creating a CLI menu).\n1. Then you realize it would be nice to have a CLI interface to call said functions.\n\nToday is your lucky day! Because Meny is especially designed for this scenario! (which I have encountered surprisingly many times, hence this package). Just install and import `meny` and do\n```\nmeny yourfile.py\n```\nYou can also use `meny` programmatically as a python package, of which this README will cover most of its usage.\n\n### But why exactly this package?\nThere already exists python packages to do so, but seemingly all of them require you to *refactor* your code in order to use them, and you need to *learn* how to use their APIs, which is kind of annoying since you just want an convenient interface for your functions. You don't want to spend even more to time to learn yet another library, let alone refactor your code for a CLI menu. With `meny` you can use the command `meny` or add `meny.menu(locals())` to the bottom of your Python file and you are good to go.\n\nOf course, this package can do much more which you can see below, but its intention is to cover the \"It would be nice to just have a cli menu for my functions now, but its too much effort to make / learn another library\" scenario, which I believe it does well.\n\nAlso, you can define the menus as JSONs!\n## Table of contents\n\n1. <a href=\"#_meny_setup\">How to setup</a>\n2. <a href=\"#_meny_noteWindows\">Note for Windows users</a>\n3. <a href=\"#_meny_terminalinterface\">Terminal interface</a>\n    1. <a href=\"#_meny_onJsonFiles\">On JSON files</a>\n4. <a href=\"#_meny_usage\">Usage</a>\n5. <a href=\"#_meny_programmaticInterface\">Programmatic interface</a>\n    1. <a href=\"#_meny_simpleExamples\">Simple examples</a>\n    2. <a href=\"#_meny_caseNames\">Case names</a>\n    3. <a href=\"#_meny_frontend\">Choosing frontends</a>\n    4. <a href=\"#_meny_specialCases\">Special cases</a>\n    5. <a href=\"#_meny_arguments\">Arguments</a>\n    6. <a href=\"#_meny_progArguments\">Programmatic Arguments</a>\n    7. <a href=\"#_meny_nested\">Nested cases</a>\n    8. <a href=\"#_meny_return\">Return values</a>\n    9. <a href=\"#_meny_ignore\">What if I want to define functions without having them displayed in the menu?</a>\n    10. <a href=\"#_meny_decorator\">Optional: Decorator</a>\n6. <a href=\"#_meny_realExamples\">Real examples</a>\n\n# How to setup <a id=\"_meny_setup\"></a>\n\nFirst install the package with the command (make sure you have Python 3.7 or higher)\n\n```\npip install meny\n```\n\nThen you can import `meny` in Python. This will make `meny` available in your shell. For programmatic use the most central functions in this package are **`meny.menu`** and **`meny.title`**, which will be covered below.\n\nThis package has been tested on Windows 10, Windows 11, MacOS (idk which version that was), and Ubuntu (18.04, 20.04, 22.04) with Python 3.7, 3.8, 3.9, 3.10\n\n## Note for Windows users <a id=\"_meny_noteWindows\"></a>\n\nTL;DR: If you want to have the fancy frontend (like in the gif) do\n\n```\npip install windows-curses\n```\n\nAn original goal for this package was to rely on built-in Python packages only, which it does, for Linux and Mac. This package requires the `curses` library to use the fancy frontend. It is built-in with CPython for Linux and Mac installations but not in Windows. `meny` will still work without `curses` as it also ships with a simple frontend that only uses the built-in `print` function.\n\nA way to get `curses` for Windows is to install `windows-curses`:\n`pip install windows-curses`\n\nI use Windows personally and `windows-curses` has worked fine so far. The `windows-curses` source code is availabe on github and [can be found here](https://github.com/zephyrproject-rtos/windows-curses).\n\n# Terminal interface <a id=\"_meny_terminalinterface\"></a>\nAs mentioned above, you can do `meny your_python_file.py` in your terminal and it will parse the file and present its functions. For example you have the file `os_example.py`:\n```python\nimport platform\n\ndef print_os():\n    operating_system = platform.system()\n    print(f\"Your operating is {platform.system()}\")\n    return operating_system\n```\nThen you can do\n```\nmeny print_os\n```\nand you will see\n```\n---- Functions in os_example.py ----\n1. print_os\n```\nIf you select `print_os`, the function will be executed and you will see its output and also return value in your terminal:\n```\nYour operating system is Linux\n'Linux'\n```\n\n## On JSON files <a id=\"_meny_onJsonFiles\"></a>\nYou can also define your menu as a JSON! The JSON will define the case names along with a terminal command. There is an example file in the repository called `readme_examples.json`:\n```json\n{\n  \"English greeting\": \"echo Hello @name! It is very nice to meet you!\",\n  \"Japanese greeting using braced syntax\": \"echo Konichiwa @{namae}san! Hajimemashite!\",\n  \"Spanish introduction with default argument\": \"echo Hola! Me llamo @{nombre=John Wick}!\",\n  \"Weather menu\": {\n    \"Get weather in current location\": \"curl wttr.in?0\",\n    \"Get weather in given location\": \"curl wttr.in/@place?0\"\n  }\n}\n```\nYou can simply run the following command in your shell (assuming you are in the examples directory):\n```\nmeny readme_examples.json\n```\nThen it will create the following menu:\n<video src='https://user-images.githubusercontent.com/47104226/214406989-5cf3c818-4346-4de3-a893-014398375128.mp4'>\n\nAs you can see it is possible to specify parameters in the json by using `@thisSyntax` or `@{thisSyntax}`, and even parameters with default arguments like `@{this=123}`. The braced syntax is usefull when you want an argument to be directly adjacent to other letters as you see in the Japanese greeting example.\n\n# Usage <a id=\"_meny_usage\"></a>\nIt easiest to explain the fundamental idea with the simple frontend, which will look something like this:\n```\n---- Title ----\n1. functionA\n2. functionB\n\ninput:\n```\n- To select a case you specify its number on the left. For example to run `functionA`, type `1` then press enter.\n- To go back press enter without any input\n- Enter `h` to see usage\n\nWhen you use the fancy frontend you can traverse the options using your arrow keys (which will save the hassle of typing which function you want to run). You can find how to switch between fancy and simple frontend <a href=\"#_meny_frontend\">here</a>.\n\n# Programmatic Interface <a id=\"_meny_programmaticInterface\"></a>\n\nSimply implement the menu cases (as functions) in a Python file, then to initialize the interface you simply call the `menu` function after you have defined your functions.\n\n```python\nfrom meny import menu\n\n            .\n            .\n            .\n\nmenu(locals(), title=' Main menu title here ')\n```\n\nThe `locals()` function is a Python built-in function that returns a dictionary with variable names as keys and the corresponding objects as values from the local scope. You can import whatever modules, classes, and functions you want in the file without them interfering with the functions defined in your file. The order of the cases is by definition order.\n\nThe function signature of `menu` along with its docstring is as follows:\nFactory function for the CLI class. This function initializes a menu.\n<a id=\"_meny_docstring\"></a>\n\n> <br/>\n>\n> ```python\n> def menu(\n>    cases: Union[Iterable[FunctionType], Dict[str, FunctionType], ModuleType],\n>    title: Optional[str] = None,\n>    *,\n>    case_args: Optional[Dict[FunctionType, tuple]] = None,\n>    case_kwargs: Optional[Dict[FunctionType, dict]] = None,\n>    decorator: Optional[FunctionType] = None,\n>    frontend: Optional[str] = None,\n>    on_blank: Optional[str] = None,\n>    on_kbinterrupt: Optional[str] = None,\n>    once: Optional[bool] = None,\n>    return_mode: Optional[str] = None,\n> ) -> Dict[str, Any]:\n> ```\n>\n> ## Parameters\n>\n> -   `cases`: can be\n>\n>     -   `Dict[str, FunctionType]`: a dictionary where keys are functions names and values are functions\n>     -   `Iterable[FunctionType]` an iterable of functions\n>     -   `ModuleType`: a module containing functions\n>\n> -   `title`: title of menu\n>\n> -   `cases_args`: dictionary with function as key and tuple of positional arguments as values\n>\n> -   `cases_kwargs`: dictionary with function as key and dict of keyword arguments as values\n>\n> -   `once`: If you want menu to return after a a single choice.\n>\n> -   `on_blank`: What to do the when given blank input. Available options are:\n>\n>     -   `\"return\"`, will return to parent menu\n>     -   `\"pass\"`, does nothing. This should only be used for the root menu.\n>\n> -   `on_kbinterrupt`: Behavior when encountering KeyboardInterrupt exception when the menu is running.\n>     If `\"raise\"`, then will raise `KeyboardInterrupt`, if `\"return\"` the menu returns.\n>\n> -   `decorator`: Decorator to applied for all case functions.\n>\n> -   `frontend`: specify desired frontend:\n>\n>     -   `\"auto\"`: Will try to use fancy frontend if curses module is available, else\n>         use simple frontend (default)\n>     -   `\"fancy\"`: Use fancy front end (if on Windows, install\n>         windows-curses first or Python will not be able to find the required\n>         `\"curses\"` package that the fancy frontend uses)\n>     -   `\"simple\"`: Use the simple (but compatible with basically everything) frontend\n>\n> -   `return_mode`: the dictionary structure to be returned after the menu is done running. Only effective\n>     menu is root menu, as nested menus will use root's. Return mode options are:\n>     -   `\"flat\"`: This is the default. Returns dictionary with function names (as `str`)\n>         as keys, and their return values as values (if they have been called), if not their names\n>         will not be in the dictionary (see examples). The downside of this return mode is if you have\n>         nested menus, where the nested menus reuse function names in from parent menus. The\n>         parent menus may overwrite the return values from the nested menus.\n>     -   `\"tree\"`: Returns a nested dictionary structure, representing the structure of nested menus\n>         (if you have that).\n>\n> ## Returns\n>\n> `Dict[str, Any]`: Dictionary where functions names are keys, and values are anything. Represents return\n> values of case functions.\n>\n> ## Examples\n>\n> ```python\n> >>> def returnsOne():\n> ...     def returnsOne():\n> ...         return \"1\"\n> ...     menu(locals())\n> ...     return 1\n> ...\n> >>> def returnsTwo():\n> ...     return 2\n> ...\n> >>> returns = menu(locals(), return_mode=\"flat\") # Assume we have entered all cases and returned\n> { \"returnsOne\": 1, \"returnsTwo\": 2, }\n> >>> returns = menu(locals(), return_mode=\"tree\") # Assume we have entered all cases and returned\n> {\n>    \"returnsOne\": {\n>        \"returnsOne\": {\n>            \"return\": \"1\"\n>        },\n>        \"return\": 1\n>    },\n>    \"returnsTwo\": {\n>        \"returns\": 2\n>    },\n> }\n> >>> returns[\"returnsOne\"][\"returnsOne\"][\"return\"]\n> '1'\n> ```\n>\n> <br/>\n\n## Simple examples <a id=\"_meny_simpleExamples\"></a>\n\nSay we are editing `console.py`\n\n```python\nfrom random import randint\nfrom time import sleep\nimport meny\n\n# fizzbuzz() and random_integer() are just examples, you can make whatever you want :)\n\ndef fizzbuzz():\n    for i in range(21):\n        stringy = ''\n\n        fizz = i % 3 == 0\n        buzz = i % 5 == 0\n\n        if fizz:\n            stringy = stringy + 'Fizz'\n        if buzz:\n            stringy = stringy + 'Buzz'\n        if not (fizz or buzz):\n            stringy = i\n\n        print(stringy)\n        sleep(0.1)\n\ndef random_integer():\n    print(randint(0,9))\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nwill result with this when running: `python console.py`:\n\n```\n-------------- Main menu ---------------\n1. fizzbuzz\n2. random_integer\n\nInput:\n```\n\nYou then specify which case you want to run by entering the input number as the first token. The tokens after (delimited by space) will be passed to the case function as positional arguments. The argument tokens will be evaluated as Python literals.\n\n## Choosing frontends <a id=\"_meny_frontend\"></a>\nThere are two frontends implemented; the simple frontend and the fancy frontend. The selection of frontend will be selected based on the detected operating system. One can pass the choice of frontend: `menu(..., frontend=\"auto\")`. The possible choices are\n\n-   `auto`: Will try to use the fancy front end (using `curses`) by checking if the `curses` module is available, else use simple frontend.\n-   `simple`: Use simple frontend, should work on all systems since it is completely based on the built-in print function. Use by typing the corresponding key (e.g. 1) to the displayed cases and press enter.\n-   `fancy`: Use fancy frontend, will raise `ImportError` if `curses` is unavailable. The fancy frontend is \"fancy\" as in it gives visual indicators on what you are doing, and also adds the ability to traverse the options using the **arrow keys** such that you don't have to type the number yourself.\n\nIt is possible to override the default frontend throughout the Python program by doing\n\n```python\nimport meny\nmeny.set_default_frontend(\"auto\") # auto, fancy, or simple\n```\n\nas opposed to specifying the choice of frontend for every `meny.menu(..., frontend=\"...\")` call.\n\n## Case names <a id=\"_meny_caseNames\"></a>\n\nBy default, it will use the function names as the case names. However, you can use the `meny.title` decorator to apply a title that will be used instead:\n\n```python\nfrom random import randint\nfrom time import sleep\nimport meny\n\n# fizzbuzz() and random_integer() are just example functions, you can make anything you want.\n\n@meny.title(\"FizzBuzz!\")\ndef fizzbuzz():\n    for i in range(21):\n        stringy = ''\n\n        fizz = i % 3 == 0\n        buzz = i % 5 == 0\n\n        if fizz:\n            stringy = stringy + 'Fizz'\n        if buzz:\n            stringy = stringy + 'Buzz'\n        if not (fizz or buzz):\n            stringy = i\n\n        print(stringy)\n        sleep(0.1)\n\n@meny.title(\"Get random integer\")\ndef random_integer():\n    print(randint(0,9))\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nWhich will produce:\n\n```\n-------------- Main menu ---------------\n1. FizzBuzz!\n2. Get random integer\n\nInput:\n```\n\n## Special cases <a id=\"_meny_specialCases\"></a>\n\nEntering `..` is equivalent to just pressing enter with an empty input. I implemented this because I just had\na habit of writing `..` to \"change directory\" to the previous directory.\n\nEntering `q` will exit the menu interface.\n\nEntering `h` will display this text that explains the special cases.\n\nEnter `-1` or any integer will \"reverse\" the choices, such that you take the last choice. This is inspired by Python lists where you can index like `list[-1]`\n\nEntering `r` will restart the *whole* Python program. This is usefull when debugging such that one can easily refresh code changes.\n\n## Arguments <a id=\"_meny_arguments\"></a>\n\nThe cases can take arguments as well!\n\n```python\nimport meny\nfrom time import sleep\n\ndef addints(a, b):\n    print(a+b)\n    sleep(1)\n\ndef appendstrings(a, b):\n    print(a+b)\n    sleep(1)\n\n# Type hints won't interfere with meny, and will actually be displayed when using the fancy frontend\n@meny.title(\"Print elements and their types\")\ndef displaylist(a: list):\n    [print(f'Element {i}: {elem}, type: {type(elem)}') for i, elem in enumerate(a)]\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nThen simply give the arguments along with the choice:\n\n```\n-------------- Main menu ---------------\n1. addints\n2. appendstrings\n3. Print elements and their types\n\n\nInput: 1 60 9\n\n69\n```\n\n```\nInput: 2 \"cat and dog\" mathemathics\n\ncat and dogmathemathics\n```\n\n```\nInput: 3 ['cat', 69, 420.0]\n\nElement 0: cat, type: <class 'str'>\nElement 1: 69, type: <class 'int'>\nElement 2: 420.0, type: <class 'float'>\n```\n\n## Programmatic Arguments <a id=\"_meny_progArguments\"></a>\n\nYou can supply arguments programmtically to your case functions:\n\n```python\nimport meny\n\ndef programmatic_args(a, b, c, d):\n    print(a, b, c, d)\n    sleep(1)\n\ncase_args = {programmatic_args: (1, 2)}\ncase_kwargs = {programmatic_args: {\"d\": 4, \"c\": 3}}\nmeny.menu(locals(), case_args=case_args, case_kwargs=case_kwargs)\n```\n\nFunctions that takes arguments programmatically cannot take arguments through the cli, that is you cannot both supply programmatic arguments as well as arguments through the cli. In that case the menu will raisa a MenuError.\n\n## Nested cases <a id=\"_meny_nested\"></a>\n\nIf you want to implement nested cases, then you can simply reuse the menu function in the function scope.\n\n```python\nfrom meny import menu\n\ndef parent():\n    def child1():\n        pass\n\n    def child2():\n        pass\n\n    menu(locals(), title= ' Title here ')\nmenu(locals(), title=' Main menu ')\n```\n\nYou can create another module for the other cases and pass them as well:\n\n```python\nfrom meny import menu\nimport other_cases\n\ndef samplecase():\n    '''Foo'''\n    menu(other_cases, title= ' Title here ')\nmenu(other_cases, title= ' Main menu ')\n```\n\nor you can give a list of functions, which will enable you to force the ordering of the cases as well:\n\n```python\nimport meny\n\ndef parent2():\n    def child1():\n        pass\n\n    def child2():\n        pass\n\n    meny.menu([subcase2, subcase1], title= ' Title here ')\nmeny.menu(locals(), title=' Main menu ')\n```\n\n## Return values <a id=\"_meny_return\"></a>\n\nThe menu will store the return values of the case functions (if you have entered the cases). The usage\nis explained in the <a href=\"#_meny_docstring\">docstring</a>.\n\n## What if I want to define functions without having them displayed in the menu? <a id=\"_meny_ignore\"></a>\n\nEasy! Simply apply the `meny.ignore` decorator on functions to make `meny` ignore them. You can also create a class of static methods to hide functions within a class since classes will be ignored by `meny` anyways. This problem is also naturally avoided if just specifies the functions manually either using a `dict` or `list`.\n\n```python\nimport meny\n@meny.ignore\ndef ignored():\n    pass\n```\n\n## Optional: Decorator <a id=\"_meny_decorator\"></a>\n\nTo enforce a common behavior when entering and leaving a case within a menu, you give a decorator to the `menu` function. However, it is important that the decorator implements the `__wrapped__` attribute (this is to handle docstrings of wrappers as arguments for wrapped functions). Generally, it should look like this\n\n```python\nimport sleep\nfrom functools import wraps\n\ndef case_decorator(func):\n    '''Decorator to enforce commmon behavior for cases'''\n    @wraps(func) # VERY IMPORTANT TO WRAP FUNCTIONS TO ENSURE THAT\n                 # case_wrapper.__wrapped__ is set properly\n    def case_wrapper(*args, **kwargs):\n        '''Verbosity wrapper'''\n        print('Yeah! Going in!')\n        sleep(1)\n        retobj = func(*args, **kwargs)\n        print('Woah! Going out!')\n        sleep(1)\n        return retobj\n    return case_wrapper\n```\n\nIt can then easily be applied to all functions like so:\n\n```python\nfrom meny import menu\nfrom case_decorator import case_decorator\n\n# A lot of cases here\n\nmenu(locals(), decorator=case_decorator)\n```\n\n# Real examples <a id=\"_meny_realExamples\"></a>\nHere are some applications that I have implemented using `meny`:\n\n## Stock data pipeline\n\nData scraping and data cleaning pipeline for stock data\n\n```\n------------- Mulababy420 --------------\n1. Update all data\n2. Obtain Oslo Bors quotes and returns\n3. Scrape Oslo bors HTML files\n4. Scrape Yahoo Finance\n5. Backup current data\n6. Exit program\nEnter choice:\n```\n\nSometimes I don't want to run everything at once. Maybe I just want to backup data instead of doing all everything. `meny` will enable a very quick implementation of a console.\nWithout the console I would need to find the right file to run (and maybe comment things out first as well). The console organizes everything into one place.\n\n## Database interface\n\n```\n------BergenDB------\n1. Log rent\n2. Log power\n3. Print table\n4. Plot table\n5. Commit changes\n6. Discard changes\n7. Exit\n```\n\nI log my rent and power bills in a SQL database. I have made a Python API to manage the database, and I just do everything through the interface. No need to script anything or write any SQL queries.\n\n## Control your Google Compute VM\n\n```\n----------------GCE-----------------\n1. SSH to personal instance\n2. SSH to project instance\n3. start/stop personal instance (0 to stop, 1 to start, 2 to restart)\n4. start/stop project instance (0 to stop, 1 to start, 2 to restart)\n5. Get status personal instance\n6. Get status project instance\n7. Other instance control\n\nEntering blank returns to parent menu\nInput:\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Napam/meny",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "meny",
    "package_url": "https://pypi.org/project/meny/",
    "platform": null,
    "project_url": "https://pypi.org/project/meny/",
    "project_urls": {
      "Homepage": "https://github.com/Napam/meny"
    },
    "release_url": "https://pypi.org/project/meny/1.1.0/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Simple and sexy console interface",
    "version": "1.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16928651,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "afb5c0d210ed6ec567b3be4f59c284ec8c9da95eb07c3f7d62856f34d172d1c9",
        "md5": "c91538a477eec8dc1f386f540358320b",
        "sha256": "2afcc75b267be4623653f4f37a6a5573e80b2fe2eedfc90653a0e2e71f2721ba"
      },
      "downloads": -1,
      "filename": "meny-1.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "c91538a477eec8dc1f386f540358320b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 27973,
      "upload_time": "2023-01-26T20:57:47",
      "upload_time_iso_8601": "2023-01-26T20:57:47.370417Z",
      "url": "https://files.pythonhosted.org/packages/af/b5/c0d210ed6ec567b3be4f59c284ec8c9da95eb07c3f7d62856f34d172d1c9/meny-1.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "84f40f9d33f5353fff4fce9e5d2ba7e326e9d322e48086f463582ed911a3e8c4",
        "md5": "d6a0ff99296d535d07b69c3db2698bea",
        "sha256": "7e775f46025d7d2631cc7ebb93457a985ae7c62f7bbdd43bd07b5436e0d157c9"
      },
      "downloads": -1,
      "filename": "meny-1.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "d6a0ff99296d535d07b69c3db2698bea",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 29703,
      "upload_time": "2023-01-26T20:57:48",
      "upload_time_iso_8601": "2023-01-26T20:57:48.790617Z",
      "url": "https://files.pythonhosted.org/packages/84/f4/0f9d33f5353fff4fce9e5d2ba7e326e9d322e48086f463582ed911a3e8c4/meny-1.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}