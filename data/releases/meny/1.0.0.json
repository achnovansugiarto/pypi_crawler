{
  "info": {
    "author": "Naphat Amundsen",
    "author_email": "naphat@live.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "![badge](https://github.com/Napam/meny/actions/workflows/pushpull.yml/badge.svg)\n![badge](https://github.com/Napam/meny/actions/workflows/publish.yml/badge.svg)\n[![PyPI version](https://badge.fury.io/py/meny.svg)](https://badge.fury.io/py/meny)\n\n# Meny\n\nMeny is a super light weight framework for creating CLI menus. (the gif is a bit outdated at the moment)\n\n![If you see this text, then the gif is broken](https://media.giphy.com/media/SKUrfvxzbXkQ80gdMM/giphy.gif)\n\n### Imagine this:\n1. You have implemented some functions in some Python file(regardless of the intention of creating a CLI menu). \n1. Then you realize it would be nice to have a CLI interface to call said functions.\n\nToday is your lucky day! Because Meny is especially designed for this scenario! (which I have encountered surprisingly many times, hence this package). just install and import `meny` and add \n```python\nmeny.menu(locals())\n``` \nto the end your file. That is really it!\n\n### But why exactly this package?\nThere already exists python packages to do so, but all of them require you to *refactor* your code in order to use them, and you need to *learn* how to use their APIs, which is kind of annoying since you just want an convenient interface for your functions. You don't wanna spend even more to time to learn yet another library, let alone refactor your code for a CLI menu. With `meny` you can literally just add `meny.menu(locals())` to the bottom of your Python file and you are literally good to go. \n\nOf course, this package can do much more which you can see below, but its intention is to cover the \"It would be nice to just have a cli menu for my functions now, but its too much effort to make / learn another library\" scenario, which I believe it does the best of all I have seen.\n\n## Table of contents\n\n1. <a href=\"#_meny_setup\">How to setup</a>\n1. <a href=\"#_meny_noteWindows\">Note for Windows users</a>\n1. <a href=\"#_meny_howTo\">How to implement</a>\n    1. <a href=\"#_meny_simpleExamples\">Simple examples</a>\n    1. <a href=\"#_meny_caseNames\">Case names</a>\n    1. <a href=\"#_meny_frontend\">Frontend and usage</a>\n    1. <a href=\"#_meny_specialCases\">Special cases</a>\n    1. <a href=\"#_meny_arguments\">Arguments</a>\n    1. <a href=\"#_meny_progArguments\">Programmatic Arguments</a>\n    1. <a href=\"#_meny_nested\">Nested cases</a>\n    1. <a href=\"#_meny_return\">Return values</a>\n    1. <a href=\"#_meny_ignore\">What if I want to define functions without having them displayed in the menu?</a>\n    1. <a href=\"#_meny_decorator\">Optional: Decorator</a>\n1. <a href=\"#_meny_realExamples\">Real examples</a>\n\n# How to setup <a id=\"_meny_setup\"></a>\n\nFirst install the package with the command (make sure you have Python 3.7 or higher)\n\n```\npip install meny\n```\n\nThen you can import `meny` in Python. The most central functions in this package are **`meny.menu`** and **`meny.title`**, which will be covered below.\n\nThis package has only been tested on Windows 10 and Ubuntu (18.04, 20.04) with Python 3.7, 3.8, and 3.9\n\n## Note for Windows users <a id=\"_meny_noteWindows\"></a>\n\nTL;DR: If you want to have the fancy frontend (like in the gif) do\n\n```\npip install windows-curses\n```\n\nAn original goal for this package was to rely on built-in Python packages only, which it does, for Linux and Mac. This package requires the `curses` library to use the fancy frontend. It is built-in with CPython for Linux and Mac installations but not in Windows. meny will still work without `curses` as it also ships with a simple frontend that only uses the built-in `print` function.\n\nA way to get `curses` for Windows is to install `windows-curses`:\n`pip install windows-curses`\n\nI use Windows personally and `windows-curses` has worked fine so far. The `windows-curses` source code is availabe on github and [can be found here](https://github.com/zephyrproject-rtos/windows-curses).\n\n# How to implement <a id=\"_meny_howTo\"></a>\n\nSimply implement the menu cases (as functions) in a Python file, then to initialize the interface you simply call the `menu` function after you have defined your functions.\n\n```python\nfrom meny import menu\n\n            .\n            .\n            .\n\nmenu(locals(), title=' Main menu title here ')\n```\n\nThe `locals()` function is a Python built-in function that returns a dictionary with variable names as keys and the corresponding objects as values from the local scope. You can import whatever modules, classes, and functions you want in the file without them interfering with the functions defined in your file. The order of the cases is by definition order.\n\nThe function signature of `menu` along with its docstring is as follows:\nFactory function for the CLI class. This function initializes a menu.\n<a id=\"_meny_docstring\"></a>\n\n> <br/>\n>\n> ```python\n> def menu(\n>    cases: Union[Iterable[FunctionType], Dict[str, FunctionType], ModuleType],\n>    title: Optional[str] = None,\n>    *,\n>    case_args: Optional[Dict[FunctionType, tuple]] = None,\n>    case_kwargs: Optional[Dict[FunctionType, dict]] = None,\n>    decorator: Optional[FunctionType] = None,\n>    frontend: Optional[str] = None,\n>    on_blank: Optional[str] = None,\n>    on_kbinterrupt: Optional[str] = None,\n>    once: Optional[bool] = None,\n>    return_mode: Optional[bool] = None,\n> ) -> Dict[str, Any]:\n> ```\n>\n> ## Parameters\n>\n> -   `cases`: can be\n>\n>     -   `Dict[str, FunctionType]`: a dictionary where keys are functions names and values are functions\n>     -   `Iterable[FunctionType]` an iterable of functions\n>     -   `ModuleType`: a module containing functions\n>\n> -   `title`: title of menu\n>\n> -   `cases_args`: dictionary with function as key and tuple of positional arguments as values\n>\n> -   `cases_kwargs`: dictionary with function as key and dict of keyword arguments as values\n>\n> -   `once`: If you want menu to return after a a single choice.\n>\n> -   `on_blank`: What to do the when given blank input. Available options are:\n>\n>     -   `\"return\"`, will return to parent menu\n>     -   `\"pass\"`, does nothing. This should only be used for the root menu.\n>\n> -   `on_kbinterrupt`: Behavior when encountering KeyboardInterrupt exception when the menu is running.\n>     If `\"raise\"`, then will raise `KeyboardInterrupt`, if `\"return\"` the menu returns.\n>\n> -   `decorator`: Decorator to applied for all case functions.\n>\n> -   `frontend`: specify desired frontend:\n>\n>     -   `\"auto\"`: Will try to use fancy frontend if curses module is available, else\n>         use simple frontend (default)\n>     -   `\"fancy\"`: Use fancy front end (if on Windows, install\n>         windows-curses first or Python will not be able to find the required\n>         `\"curses\"` package that the fancy frontend uses)\n>     -   `\"simple\"`: Use the simple (but compatible with basically everything) frontend\n>\n> -   `return_mode`: the dictionary structure to be returned after the menu is done running. Only effective\n>     menu is root menu, as nested menus will use root's. Return mode options are:\n>     -   `\"flat\"`: This is the default. Returns dictionary with function names (as `str`)\n>         as keys, and their return values as values (if they have been called), if not their names\n>         will not be in the dictionary (see examples). The downside of this return mode is if you have\n>         nested menus, where the nested menus reuse function names in from parent menus. The\n>         parent menus may overwrite the return values from the nested menus.\n>     -   `\"tree\"`: Returns a nested dictionary structure, representing the structure of nested menus\n>         (if you have that).\n>\n> ## Returns\n>\n> `Dict[str, Any]`: Dictionary where functions names are keys, and values are anything. Represents return\n> values of case functions.\n>\n> ## Examples\n>\n> ```python\n> >>> def returnsOne():\n> ...     def returnsOne():\n> ...         return \"1\"\n> ...     menu(locals())\n> ...     return 1\n> ...\n> >>> def returnsTwo():\n> ...     return 2\n> ...\n> >>> returns = menu(locals(), return_mode=\"flat\") # Assume we have entered all cases and returned\n> { \"returnsOne\": 1, \"returnsTwo\": 2, }\n> >>> returns = menu(locals(), return_mode=\"tree\") # Assume we have entered all cases and returned\n> {\n>    \"returnsOne\": {\n>        \"returnsOne\": {\n>            \"return\": \"1\"\n>        },\n>        \"return\": 1\n>    },\n>    \"returnsTwo\": {\n>        \"returns\": 2\n>    },\n> }\n> >>> returns[\"returnsOne\"][\"returnsOne\"][\"return\"]\n> '1'\n> ```\n>\n> <br/>\n\n## Simple examples <a id=\"_meny_simpleExamples\"></a>\n\nSay we are editing `console.py`\n\n```python\nfrom random import randint\nfrom time import sleep\nimport meny\n\n# fizzbuzz() and random_integer() are just examples, you can make whatever you want :)\n\ndef fizzbuzz():\n    for i in range(21):\n        stringy = ''\n\n        fizz = i % 3 == 0\n        buzz = i % 5 == 0\n\n        if fizz:\n            stringy = stringy + 'Fizz'\n        if buzz:\n            stringy = stringy + 'Buzz'\n        if not (fizz or buzz):\n            stringy = i\n\n        print(stringy)\n        sleep(0.1)\n\ndef random_integer():\n    print(randint(0,9))\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nwill result with this when running: `python console.py`:\n\n```\n-------------- Main menu ---------------\n1. fizzbuzz\n2. random_integer\n\nInput:\n```\n\nYou then specify which case you want to run by entering the input number as the first token. The tokens after (delimited by space) will be passed to the case function as positional arguments. The argument tokens will be evaluated as Python literals.\n\n## Frontend and usage <a id=\"_meny_frontend\"></a>\n\nThere are two frontends implemented; the simple frontend and the fancy frontend. The selection of frontend will be selected based on the detected operating system. One can pass the choice of frontend: `menu(..., frontend=\"auto\")`. The possible choices are\n\n-   `auto`: Will try to use the fancy front end (using `curses`) by checking if the `curses` module is available, else use simple frontend.\n-   `simple`: Use simple frontend, should work on all systems since it is completely based on the built-in print function. Use by typing the corresponding key (e.g. 1) to the displayed cases and press enter.\n-   `fancy`: Use fancy frontend, will raise `ImportError` if `curses` is unavailable. The fancy frontend is \"fancy\" as in it gives visual indicators on what you are doing, and also adds the ability to traverse the options using the **arrow keys**.\n\nIt is possible to override the default frontend throughout the Python program by doing\n\n```python\nimport meny\nmeny.set_default_frontend(\"auto\") # auto, fancy, or simple\n```\n\nas opposed to specifying the choice of frontend for every `meny.menu(..., frontend=\"...\")` call.\n\n## Case names <a id=\"_meny_caseNames\"></a>\n\nBy default, it will use the function names as the case names. However, you can use the `meny.title` decorator to apply a title that will be used instead:\n\n```python\nfrom random import randint\nfrom time import sleep\nimport meny\n\n# fizzbuzz() and random_integer() are just example functions, you can make anything you want.\n\n@meny.title(\"FizzBuzz!\")\ndef fizzbuzz():\n    for i in range(21):\n        stringy = ''\n\n        fizz = i % 3 == 0\n        buzz = i % 5 == 0\n\n        if fizz:\n            stringy = stringy + 'Fizz'\n        if buzz:\n            stringy = stringy + 'Buzz'\n        if not (fizz or buzz):\n            stringy = i\n\n        print(stringy)\n        sleep(0.1)\n\n@meny.title(\"Get random integer\")\ndef random_integer():\n    print(randint(0,9))\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nWhich will produce:\n\n```\n-------------- Main menu ---------------\n1. FizzBuzz!\n2. Get random integer\n\nInput:\n```\n\n## Special cases <a id=\"_meny_specialCases\"></a>\n\nEntering `..` is equivalent to just pressing enter with an empty input. I implemented this because I just had\na habit of writing `..` to \"change directory\" to the previous directory.\n\nEntering `q` will exit the menu interface.\n\nEntering `h` will display this text that explains the special cases.\n\nEnter `-1` or any integer will \"reverse\" the choices, such that you take the last choice. This is inspired by Python lists where you can index like `list[-1]`\n\nEntering `r` will restart the *whole* Python program. This is usefull when debugging such that one can easily refresh code changes.\n\n## Arguments <a id=\"_meny_arguments\"></a>\n\nThe cases can take arguments as well!\n\n```python\nimport meny\nfrom time import sleep\n\ndef addints(a, b):\n    print(a+b)\n    sleep(1)\n\ndef appendstrings(a, b):\n    print(a+b)\n    sleep(1)\n\n# Type hints won't interfere with meny, and will actually be displayed when using the fancy frontend\n@meny.title(\"Print elements and their types\")\ndef displaylist(a: list):\n    [print(f'Element {i}: {elem}, type: {type(elem)}') for i, elem in enumerate(a)]\n    sleep(1)\n\nmeny.menu(locals(), title=' Main menu ')\n```\n\nThen simply give the arguments along with the choice:\n\n```\n-------------- Main menu ---------------\n1. addints\n2. appendstrings\n3. Print elements and their types\n\n\nInput: 1 60 9\n\n69\n```\n\n```\nInput: 2 \"cat and dog\" mathemathics\n\ncat and dogmathemathics\n```\n\n```\nInput: 3 ['cat', 69, 420.0]\n\nElement 0: cat, type: <class 'str'>\nElement 1: 69, type: <class 'int'>\nElement 2: 420.0, type: <class 'float'>\n```\n\n## Programmatic Arguments <a id=\"_meny_progArguments\"></a>\n\nYou can supply arguments programmtically to your case functions:\n\n```python\nimport meny\n\ndef programmatic_args(a, b, c, d):\n    print(a, b, c, d)\n    sleep(1)\n\ncase_args = {programmatic_args: (1, 2)}\ncase_kwargs = {programmatic_args: {\"d\": 4, \"c\": 3}}\nmeny.menu(locals(), case_args=case_args, case_kwargs=case_kwargs)\n```\n\nFunctions that takes arguments programmatically cannot take arguments through the cli, that is you cannot both supply programmatic arguments as well as arguments through the cli. In that case the menu will raisa a MenuError.\n\n## Nested cases <a id=\"_meny_nested\"></a>\n\nIf you want to implement nested cases, then you can simply reuse the menu function in the function scope.\n\n```python\nfrom meny import menu\n\ndef parent():\n    def child1():\n        pass\n\n    def child2():\n        pass\n\n    menu(locals(), title= ' Title here ')\nmenu(locals(), title=' Main menu ')\n```\n\nYou can create another module for the other cases and pass them as well:\n\n```python\nfrom meny import menu\nimport other_cases\n\ndef samplecase():\n    '''Foo'''\n    menu(other_cases, title= ' Title here ')\nmenu(other_cases, title= ' Main menu ')\n```\n\nor you can give a list of functions, which will enable you to force the ordering of the cases as well:\n\n```python\nimport meny\n\ndef parent2():\n    def child1():\n        pass\n\n    def child2():\n        pass\n\n    meny.menu([subcase2, subcase1], title= ' Title here ')\nmeny.menu(locals(), title=' Main menu ')\n```\n\n## Return values <a id=\"_meny_return\"></a>\n\nThe menu will store the return values of the case functions (if you have entered the cases). The usage\nis explained in the <a href=\"#_meny_docstring\">docstring</a>.\n\n## What if I want to define functions without having them displayed in the menu? <a id=\"_meny_ignore\"></a>\n\nEasy! Simply apply the `meny.ignore` decorator on functions to make `meny` ignore them. You can also create a class of static methods to hide functions within a class since classes will be ignored by `meny` anyways. This problem is also naturally avoided if just specifies the functions manually either using a `dict` or `list`.\n\n```python\nimport meny\n@meny.ignore\ndef ignored():\n    pass\n```\n\n## Optional: Decorator <a id=\"_meny_decorator\"></a>\n\nTo enforce a common behavior when entering and leaving a case within a menu, you give a decorator to the `menu` function. However, it is important that the decorator implements the `__wrapped__` attribute (this is to handle docstrings of wrappers as arguments for wrapped functions). Generally, it should look like this\n\n```python\nimport sleep\nfrom functools import wraps\n\ndef case_decorator(func):\n    '''Decorator to enforce commmon behavior for cases'''\n    @wraps(func) # VERY IMPORTANT TO WRAP FUNCTIONS TO ENSURE THAT\n                 # case_wrapper.__wrapped__ is set properly\n    def case_wrapper(*args, **kwargs):\n        '''Verbosity wrapper'''\n        print('Yeah! Going in!')\n        sleep(1)\n        retobj = func(*args, **kwargs)\n        print('Woah! Going out!')\n        sleep(1)\n        return retobj\n    return case_wrapper\n```\n\nIt can then easily be applied to all functions like so:\n\n```python\nfrom meny import menu\nfrom case_decorator import case_decorator\n\n# A lot of cases here\n\nmenu(locals(), decorator=case_decorator)\n```\n\n# Real examples <a id=\"_meny_realExamples\"></a>\nHere are some applications that I have implemented using `meny`:\n\n## Stock data pipeline\n\nData scraping and data cleaning pipeline for stock data\n\n```\n------------- Mulababy420 --------------\n1. Update all data\n2. Obtain Oslo Bors quotes and returns\n3. Scrape Oslo bors HTML files\n4. Scrape Yahoo Finance\n5. Backup current data\n6. Exit program\nEnter choice:\n```\n\nSometimes I don't want to run everything at once. Maybe I just want to backup data instead of doing all everything. `meny` will enable a very quick implementation of a console.\nWithout the console I would need to find the right file to run (and maybe comment things out first as well). The console organizes everything into one place.\n\n## Database interface\n\n```\n------BergenDB------\n1. Log rent\n2. Log power\n3. Print table\n4. Plot table\n5. Commit changes\n6. Discard changes\n7. Exit\n```\n\nI log my rent and power bills in a SQL database. I have made a Python API to manage the database, and I just do everything through the interface. No need to script anything or write any SQL queries.\n\n## Control your Google Compute VM\n\n```\n----------------GCE-----------------\n1. SSH to personal instance\n2. SSH to project instance\n3. start/stop personal instance (0 to stop, 1 to start, 2 to restart)\n4. start/stop project instance (0 to stop, 1 to start, 2 to restart)\n5. Get status personal instance\n6. Get status project instance\n7. Other instance control\n\nEntering blank returns to parent menu\nInput:\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Napam/meny",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "meny",
    "package_url": "https://pypi.org/project/meny/",
    "platform": null,
    "project_url": "https://pypi.org/project/meny/",
    "project_urls": {
      "Homepage": "https://github.com/Napam/meny"
    },
    "release_url": "https://pypi.org/project/meny/1.0.0/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Simple and sexy console interface",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16928651,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8aed7a7065025ede0fb37350d665d26d0c0e7b622d021482d44f70aad829142a",
        "md5": "2a58617436e860a20f4ad3cf5e1bb060",
        "sha256": "5b1008f1e29df19bd67c42af3dc7915d567a4f310046b0cd59d207e8b6eb618f"
      },
      "downloads": -1,
      "filename": "meny-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2a58617436e860a20f4ad3cf5e1bb060",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 25303,
      "upload_time": "2022-08-14T11:24:14",
      "upload_time_iso_8601": "2022-08-14T11:24:14.911280Z",
      "url": "https://files.pythonhosted.org/packages/8a/ed/7a7065025ede0fb37350d665d26d0c0e7b622d021482d44f70aad829142a/meny-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8f613feb19add12214bfcd9f6e25aec535cc85b80f6ee004e8366af433c0d267",
        "md5": "318c107d7ddd78f93c9a27550faa76fe",
        "sha256": "475832b248e7f5157b85fec7422fee088ca34b8a156ff99771d44215bb23979a"
      },
      "downloads": -1,
      "filename": "meny-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "318c107d7ddd78f93c9a27550faa76fe",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 25904,
      "upload_time": "2022-08-14T11:24:16",
      "upload_time_iso_8601": "2022-08-14T11:24:16.476180Z",
      "url": "https://files.pythonhosted.org/packages/8f/61/3feb19add12214bfcd9f6e25aec535cc85b80f6ee004e8366af433c0d267/meny-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}