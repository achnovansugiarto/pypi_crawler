{
  "info": {
    "author": "Souheil Chelfouh",
    "author_email": "trollfot@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Environment :: Web Environment",
      "Framework :: Zope3",
      "Intended Audience :: Other Audience",
      "License :: OSI Approved :: GNU General Public License (GPL)",
      "Operating System :: OS Independent",
      "Programming Language :: Python"
    ],
    "description": "=================\ndolmen.forms.base\n=================\n\n`dolmen.forms.base` is a package in charge of providing basic\nfunctionalities to work with `zeam.form` Forms.\n\n\nFrom the form to the field\n==========================\n\n``dolmen.forms.base`` provides few functions dedicated to the task of\napplying dict datas to object fields and to trigger events in order to\ninform handlers of the updates\n\nApplying values\n---------------\n\nWe create our test model::\n\n  >>> from zope.schema import TextLine, Choice\n  >>> from zope.interface import Interface, implements\n\n  >>> class ICaveman(Interface):\n  ...    name = TextLine(title=u'a name')\n  ...    weapon = Choice(title=u'a weapon',\n  ...                    values=[u'none', u'a club', u'a spear'])\n\n  >>> class Neanderthal(object):\n  ...    implements(ICaveman)\n  ...    def __init__(self):\n  ...       self.name = u\"no name\"\n  ...       self.weapon = u\"none\"\n\n  >>> moshe = Neanderthal()\n  >>> moshe.name\n  u'no name'\n  >>> moshe.weapon\n  u'none'\n\nWe can now use the first function, `set_fields_data`. It takes the\nfields list, extracted thanks to the `Fields` collection, the content\nand the data dictionnary. The result of this call is a dictionnary,\nwith the interface in which the field is defined and the field\nidentifier as a value::\n\n  >>> from dolmen.forms.base import Fields, set_fields_data\n\n  >>> fields = Fields(ICaveman)\n  >>> for field in fields: print field\n  <TextLineField a name>\n  <ChoiceField a weapon>\n\n  >>> data = {u'name': u'Grok', u'weapon': u'a club'}\n\n  >>> changes = set_fields_data(fields, moshe, data)\n  >>> print changes\n  {<InterfaceClass __builtin__.ICaveman>: [u'weapon', u'name']}\n\n  >>> moshe.name\n  u'Grok'\n  >>> moshe.weapon\n  u'a club'\n\nValues of the data dict can contain markers, to warn of a possible\nspecial case : the value is missing or there are no changes. In these\ntwo cases, the value assignation is skipped::\n\n  >>> from dolmen.forms.base import NO_VALUE, NO_CHANGE\n  >>> data = {u'name': NO_VALUE, u'weapon': NO_CHANGE}\n\n  >>> changes = set_fields_data(fields, moshe, data)\n  >>> print changes\n  {}\n\nGenerating changes Attributes for events\n----------------------------------------\n\nOne advantage of generating a dict of changes is that you can trigger\nevent that are aware of a certain format of changes. The\nIObjectModifiedEvent, for exemple, uses the changes log to trigger the\nreindexation of the modified fields. The function `notify_changes` is\ndedicated to notifying a given event of the applied changes. It takes\nthe content, the changes dict and an event as arguments. If the event\nargument is omitted, ObjectModifiedEvent is used by default.\n\nWe first generate a changes dict::\n\n  >>> data = {u'name': u'Grok', u'weapon': u'a club'}\n  >>> changes = set_fields_data(fields, moshe, data)\n  >>> print changes\n  {<InterfaceClass __builtin__.ICaveman>: [u'weapon', u'name']}\n\nWe can now set a logger for the IObjectModifiedEvent, in order to\ncheck if the changes are being broadcasted::\n\n  >>> from zope.component import adapter, provideHandler\n  >>> from zope.lifecycleevent import IObjectModifiedEvent\n  >>> from zope.event import subscribers\n\n\n  >>> logger = []\n\n  >>> @adapter(ICaveman, IObjectModifiedEvent)\n  ... def changes_broadcasted(content, event):\n  ...    logger.append(event.descriptions)\n\n  >>> provideHandler(changes_broadcasted)\n\nWe can now feed it to the function::\n\n  >>> from dolmen.forms.base import notify_changes\n  >>> change_log = notify_changes(moshe, changes)\n\nThe logger must have been trigged. We can check its value::\n\n  >>> logger\n  [(<zope.lifecycleevent.Attributes object at ...>,)]\n\n  >>> for attrs in logger[0]:\n  ...     print attrs.interface, attrs.attributes\n  <InterfaceClass __builtin__.ICaveman> (u'weapon', u'name')\n\n\nField update event\n==================\n\n`dolmen.forms.base` also proposes the definition of a new component that\ncan be used to atomize the updating process of an object: `IFieldUpdate`.\n\nTo demonstrate this `IFieldUpdate`, we are going to implement a simple\nusecase where we instanciate a content, change a value and notify the\n`IFieldUpdate` components. For that, we'll use a basic logger object::\n\n  >>> logger = []\n\nOnce this is done, we can define two `IFieldUpdate` components. We\nimplement them as named adapters. We'll retrieve them thanks to a\n\"getAdapters\" call::\n\n  >>> from zope.interface import implementer\n  >>> from dolmen.forms.base import IFieldUpdate\n\n  >>> @implementer(IFieldUpdate)\n  ... @adapter(TextLine, ICaveman)\n  ... def updated_title(field, context):\n  ...    if field.__name__ == u\"name\":\n  ...       logger.append('Name updated on %r with `%s`' %\n  ...                     (context, getattr(context, field.__name__)))\n\n  >>> @implementer(IFieldUpdate)\n  ... @adapter(TextLine, Interface)\n  ... def updated_textfield(field, context):\n  ...    logger.append('A text field has been updated')\n\n\nThe components need to be named since they are adapters: we don't want\nthem to override each other. For the example, we want them both. let's\nregister them::\n\n  >>> from zope.component import provideAdapter\n  >>> provideAdapter(updated_title, name=\"updatetitle\")\n  >>> provideAdapter(updated_textfield, name=\"updatetext\")\n\nNow, we develop the small scenarii : we instanciate a Content,\nadd a value for the `name` attribute and call the adapters::\n\n  >>> manfred = Neanderthal()\n  >>> manfred.name = u\"Manfred the Mighty\"\n\n  >>> from zope.component import getAdapters\n  >>> adapters = getAdapters((ICaveman['name'], manfred), IFieldUpdate)\n  >>> for adapter in adapters:\n  ...   # We run through the generator\n  ...   pass\n\n  >>> for line in logger: print line\n  Name updated on <Neanderthal object at ...> with `Manfred the Mighty`\n  A text field has been updated\n\n\nThe form model\n==============\n\n``dolmen.forms.base`` provides a form baseclass defining several\nuseful methods and overriding some default behavior from\n``zeam.form``.\n\n  >>> from zope.interface import implementedBy\n  >>> from dolmen.forms.base import ApplicationForm\n\nThe provided component, `ApplicationForm`, inherits from the base\n``zeam.form`` components and implements some extra methods, allowing\nit to fit into your application, such as `flash`, to emit messages\nto given sources. It's also layout aware::\n\n  >>> for interface in implementedBy(ApplicationForm):\n  ...     print interface\n  <InterfaceClass megrok.layout.interfaces.IPage>\n  <InterfaceClass zeam.form.base.interfaces.ISimpleForm>\n  <InterfaceClass zeam.form.base.interfaces.ISimpleFormCanvas>\n  <InterfaceClass zeam.form.base.interfaces.IGrokViewSupport>\n  <InterfaceClass zeam.form.base.interfaces.IFormData>\n  <InterfaceClass zope.publisher.interfaces.browser.IBrowserPage>\n  <InterfaceClass zope.browser.interfaces.IBrowserView>\n  <InterfaceClass zope.location.interfaces.ILocation>\n\nAs ``zeam.form`` uses Chameleon as a template engine, it is import we\nare able to compute the current request locale, in order to get the\nright translation environment::\n\n  >>> from grokcore.component import Context\n  >>> from zope.publisher.browser import TestRequest\n\n  >>> item = Context()\n  >>> request = TestRequest()\n\n  >>> form = ApplicationForm(item, request)\n  >>> print form.i18nLanguage\n  None\n\n  >>> request = TestRequest(environ={'HTTP_ACCEPT_LANGUAGE': \"en,fr\"})\n  >>> form = ApplicationForm(item, request)\n  >>> print form.i18nLanguage\n  en\n\nFurther more, the `ApplicationForm` overrides the ``extractData``\nmethod from the ``zeam.form`` Form in order to compute the interfaces\ninvariants.\n\n\nDeclaring the invariants\n------------------------\n\n  >>> from zope.schema import Password\n  >>> from zope.interface import invariant, Interface\n  >>> from zope.interface.exceptions import Invalid\n\n  >>> class IPasswords(Interface):\n  ...     passwd = Password(\n  ...         title=u\"Password\",\n  ...         description=u\"Type the password.\",\n  ...         required=True)\n  ...\n  ...     verify = Password(\n  ...         title=u\"Password checking\",\n  ...         description=u\"Retype the password.\",\n  ...         required=True)\n  ...\n  ...     @invariant\n  ...     def check_pass(data):\n  ...         if data.passwd != data.verify:\n  ...             raise Invalid(u\"Mismatching passwords!\")\n\n  >>> from zeam.form.base import Fields\n  >>> from grokcore.component import testing\n\n  >>> class MyForm(ApplicationForm):\n  ...     ignoreContent = True\n  ...     ignoreRequest = False\n  ...     fields = Fields(IPasswords)\n\n\nDefault behavior\n----------------\n\n  >>> form = MyForm(item, request)\n  >>> form.update()\n  >>> form.updateForm()\n  >>> data, errors = form.extractData()\n\n  >>> print data\n  {'passwd': <Marker NO_VALUE>, 'verify': <Marker NO_VALUE>}\n\n  >>> for error in errors:\n  ...     print error.title\n  Missing required value.\n  Missing required value.\n  There were errors.\n\n  >>> for error in form.formErrors:\n  ...     print error.title\n  There were errors.\n\n\nErrors computing\n----------------\n\n  >>> post = TestRequest(form = {'form.field.passwd': u'test',\n  ...                            'form.field.verify': u'fail'})\n  >>> form = MyForm(item, post)\n  >>> form.update()\n  >>> form.updateForm()\n  >>> data, errors = form.extractData()\n\n  >>> print data\n  {'passwd': u'test', 'verify': u'fail'}\n\nThe returned error is a collection of Error components. Using the form\nprefix as an identifier, it logically wraps all the errors created by\nthe invariants validation::\n\n  >>> for error in form.formErrors:\n  ...     print error.title\n  Mismatching passwords!\n\n  >>> form.errors.get(form.prefix) == form.formErrors[0]\n  True\n\n\nMixed Fields\n------------\n\nThere are two types of fields, one from ``zeam.form.base``, the other\nfrom ``zope.schema``. They are both useable in a form, separately or\nmixed::\n\n  >>> from zeam.form.base import Field\n  >>> from dolmen.forms.base import Fields\n  >>> class MixedForm(ApplicationForm):\n  ...     ignoreContent = True\n  ...     ignoreRequest = False\n  ...     fields = Fields(IPasswords) + Field(u'Name')\n\n  >>> mixedform = MixedForm(item, post)\n  >>> mixedform.update()\n  >>> [x.title for x in mixedform.fields]\n  [u'Password', u'Password checking', u'Name']\n\n  >>> mixedform.updateForm()\n  >>> data, errors = mixedform.extractData()\n\n  >>> print form.formErrors\n  [<Error Mismatching passwords!>]\n\n  >>> for error in form.formErrors:\n  ...     print error.title\n  Mismatching passwords!\n\n\nChangelog\n=========\n\n1.0 (2012-10-24)\n----------------\n\n* Fixed the new dependencies and changes in the related packages.\n\n\n1.0b3 (2010-10-27)\n------------------\n\n* Util method ``set_fields_data`` now makes sure that, even if a data\n  entry doesn't have a corresponding field, it doesn't raise an error,\n  as it was supposed to do.\n\n\n1.0b2 (2010-10-20)\n------------------\n\n* Both ``zeam.form`` and ``zope.schema`` Fields are useable in a Form,\n  now. The changes have been made in the inline validation, to take\n  care of both types.\n\n* Now we are using formErrors from ``zeam.form.base`` Form instead of our\n  own formError method.\n\n* The `InvariantsValidation` is now declared thanks to the\n  ``dataValidators`` mechanism introduces by ``zeam.form.base`` 1.0.\n\n* The package is now tested under Grok 1.2.\n\n\n1.0b1 (2010-06-25)\n------------------\n\n* The package now uses the latest version of ``zeam.form.base``, that\n  separates the `extractData` from the `validateData`. It allows to\n  validate invariants in a cleaner way, without overriding generic\n  code.\n\n* The DeprecationWarning in invariants validation is gone. It now uses\n  the representation of the exception and no longer the `message`\n  attribute.\n\n* The package now exposes the base ``zeam.form`` markers.\n\n\n1.0a2 (2010-06-25)\n------------------\n\n* `ApplicationForm` now validates interfaces invariants.\n\n* `ApplicationForm` is now localized, since it provides a contextual\n  i18nLanguage attribute.\n\n* Added tests\n\n\n1.0a1 (2010-06-02)\n------------------\n\n* Added a base Form model : `ApplicationForm`\n\n* ``dolmen.forms.base`` no longer uses ``z3c.form`` but is now based\n  on the ``zeam.form`` Form framework\n\n* Added several helpers functions, to extract changes Attributes and\n  notify events\n\n* Added tests\n\n\n0.1 (2009-10-25)\n----------------\n\n* Initial release",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "UNKNOWN",
    "keywords": "Dolmen Forms",
    "license": "GPL",
    "maintainer": null,
    "maintainer_email": null,
    "name": "dolmen.forms.base",
    "package_url": "https://pypi.org/project/dolmen.forms.base/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/dolmen.forms.base/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "UNKNOWN"
    },
    "release_url": "https://pypi.org/project/dolmen.forms.base/1.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Form utilities for Dolmen and zeam.form",
    "version": "1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1314313,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b4e70562db919d180fcb9897abb5a8b671ac16079614f57e1c2ff16cb7b50879",
        "md5": "29ea6512383baed075f14ed3a4f8727a",
        "sha256": "7cbe226b1c465639fd927375d81837c4014d8a97fbbfc6ae243260e3916cad03"
      },
      "downloads": -1,
      "filename": "dolmen.forms.base-1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "29ea6512383baed075f14ed3a4f8727a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 10745,
      "upload_time": "2012-10-24T08:26:49",
      "upload_time_iso_8601": "2012-10-24T08:26:49.251747Z",
      "url": "https://files.pythonhosted.org/packages/b4/e7/0562db919d180fcb9897abb5a8b671ac16079614f57e1c2ff16cb7b50879/dolmen.forms.base-1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}