{
  "info": {
    "author": "Radoslaw Kolasinski",
    "author_email": "koolas at gmail com",
    "bugtrack_url": null,
    "classifiers": [
      "Topic :: Software Development",
      "Topic :: Software Development :: Compilers",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Quality Assurance",
      "Topic :: System"
    ],
    "description": "Allows seamless integration of .NET (e.g. C#) code with Python (CPython, Anaconda).\n\nIt runs as hybrid native code and CLR code. The CLR instance is created once you import dotnet module into your Python code. Then you can load assemblies and import namespaces and types directly into Python code, and use as Python objects. This all runs within Python process, and no IPC is used to accomplish this. Boost.Python has been used to write C++ layer, which glues Python and Managed (.NET/CLR/C#) code.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "https://bitbucket.org/pydotnet/pydotnet/downloads/dotnet-1.1.7-cp35.win-amd64-py3.5.msi",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/pydotnet/pydotnet",
    "keywords": "csharp",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dotnet",
    "package_url": "https://pypi.org/project/dotnet/",
    "platform": "Windows (x86 and x64).",
    "project_url": "https://pypi.org/project/dotnet/",
    "project_urls": {
      "Download": "https://bitbucket.org/pydotnet/pydotnet/downloads/dotnet-1.1.7-cp35.win-amd64-py3.5.msi",
      "Homepage": "https://bitbucket.org/pydotnet/pydotnet"
    },
    "release_url": "https://pypi.org/project/dotnet/1.1.7/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Python Interoperability with the Microsoft .NET Framework",
    "version": "1.1.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11882019,
  "urls": [],
  "vulnerabilities": []
}