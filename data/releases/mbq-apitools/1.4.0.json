{
  "info": {
    "author": "Managed by Q, Inc.",
    "author_email": "open-source@managedbyq.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries"
    ],
    "description": "# mbq.apitools\n\n`mbq.apitools` is a python library for writing endpoints in Django. It provides a view decorator and view class that allow for strict typing of incoming query parameters and payloads, as well as consistent response shapes and status codes on the way out.\n\nSome nice things about `mbq.apitools`:\n* All fields specified in a param or payload schema are required by default, and can be marked as optional by providing a `default=` argument to the field class. The framework will automatically return a 400 response for all requests which do not conform to the specified schema. Details for each nonconforming field will be included in the response.\n* The parsed parameters and payloads end up as rich types on the request. If a field is marked as `fields.DateTime`, then it will be on `request.payload` as a `datetime` object.\n* Pagination is handled entirely by the framework. Simply include `paginated=True` when you define the view, return a `PaginatedResponse`, and voila!\n* All success responses have a 200 status code.\n* All list and paginated responses contain the list of resources under the key `\"objects\"`.\n* All error responses have the same shape (an `\"error_code\"` and `\"detail\"` key).\n\n## Example\n\n```python\nfrom mbq.api_tools import fields, responses\nfrom mbq.api_tools.views import View, view\n\n@view(\n    \"GET\",\n    permissions=[SomeDRFPermissionClass],\n    params={\n        \"product_ids\": fields.Int(default=None, many=True),\n        \"zipcode\": fields.String(),\n    }\n)\ndef get_categories(request):\n    categories = Category.objects.filter(zipcode=request.params.zipcode)\n\n    if request.product_ids:\n        categories = categories.filter(product_id__in=request.params.product_ids)\n\n    categories = CategorySerializer(categories, many=True).data\n\n    return responses.ListResponse(categories)\n\n\nclass OrdersView(View):\n\n    @view.method(\"POST\", payload={\"company_id\": fields.Int()})\n    def create_order(self, request):\n        order = create_order(request.payload.company_id)\n        return responses.DetailResponse(OrderSerializer(order).data))\n\n    @view.method(\"GET\", permissions=[SomeDRFPermission], paginated=True)\n    def get_orders(self, request):\n        orders = Order.objects.all()\n        return responses.PaginatedResponse(orders, OrderSerializer, request)\n```\n## Views\n\n### @view\n\nUse the `@view` decorator for all function based views. It accepts the following arguments:\n* `http_method_name`\n\t* GET, POST, PATCH, PUT, DELETE\n\t* Defaults to GET\n* `permissions`\n\t* A list of DRF permission classes _or_ functions that take in a request object and return `True` if authorized, `False` if unauthorized.\n* `params`\n\t* Schema for validating incoming query parameters. The query parameters will be available at `request.params`.\n* `payload`\n\t* Schema for validating incoming payloads. The payload will be available at `request.payload`.\n* `paginated`\n\t* Boolean indicating if the response will be paginated or not. Defaults to `False`.\n* `page_size`\n\t* Integer specifying the page size for a paginated response. This should only be used to override the default page size.\n* `on_unknown_field`\n\t* `\"raise\"` or `\"exclude\"`. By default all endpoints will 400 if they receive an unknown query parameter or payload. This argument allows you to override the default behavior on a per view basis.\n\n### View\n\nUse the `View` class when you need to support multiple HTTP verbs for the same URL pattern.\nThe class exposes an `as_view()` method to use in `urls.py`.\n\nAll view methods on the class need to be marked with `@view.method(...)`, which supports the exact same interface as `@view`. (Note that unlike Django and DRF, since the verb is specified in the decorator you can name the view methods whatever you want.)\n\n## Responses\n\nStatus codes are predefined by the different response classes. Status codes will _never_ be specified in a view.\n\n### Success Responses\n\nAll success responses return a 200 status code.\n\n#### `DetailResponse`\n\n```python\nresponses.DetailResponse({\"foo\": \"bar\", \"age\": 10})\n```\nwill generate:\n```json\n{\"foo\": \"bar\", \"age\": 10}\n```\n\n#### `ListResponse`\n`ListResponse` accepts any iterable of JSON serializable python objects and will nest them under an `\"objects\"` key in the response.\n```python\nresponses.ListResponse([{\"foo\": \"bar\"}])\n```\nwill generate:\n```json\n{\"objects\": [{\"foo\": \"bar\"}]}\n```\n\n#### `PaginatedResponse`\n`PaginatedResponse` accepts a `QuerySet`, a serializer, and a request. It will return a properly paginated response (according to the pagination params on the request) with the data under `\"objects\"` and a `\"pagination\"` key containing the pagination information.\n```python\nresponses.PaginatedResponse(some_queryset, SomeDRFSerializer, request)\n```\nwill generate:\n```\n{\n    \"objects\": [{id: 1}, {id: 2}, {id: 3}, ... ],\n    \"pagination\": {\n        \"page\": 1,\n        \"page_size\": 20,\n        \"num_pages\": 5,\n        \"total_objects\": 89,\n        \"next_page\": \"/api/v1/orders?page=2&page_size=20\",\n        \"previous_page\": null\n    }\n}\n```\nAlternatively, instead of a DRF Serializer class, you can pass in a function that takes in a list of objects and returns a list of serialized objects,\n```python\nresponses.PaginatedResponse(\n    some_queryset,\n    lambda objs: [obj.to_dict() for obj in objs],\n    request,\n)\n```\nSee the `Pagination` section for more details.\n\n### Error Responses\n\nAll error responses will have the following shape:\n```json\n{\"error_code\": \"some_unique_error_string\", \"detail\": \"More details about the error...\"}\n```\nSome allow the `error_code` and `detail` to be specified, while others have them hard-coded.\n\n#### `UnauthorizedResponse`\n* 403\n* `error_code`\n\t* `\"unauthorized\"`\n* `detail`\n\t* `\"Unauthorized to access this resource\"`\n\n#### `NotFoundResponse`\n* 404\n* `error_code`\n\t* `\"not_found\"`\n* `detail`\n\t* `\"Resource not found\"`\n\n\n#### `ServerErrorResponse`\n* 500\n* `error_code`\n  * `\"server_error\"`\n* `detail`\n  * `\"An unexpected error occurred\"`\n\n#### `ClientErrorResponse`\n* 400\n* To be used when the client made an error it could have avoided.\n* `error_code` and `detail` must be specified.\n```python\nresponses.ClientErrorResponse(\"quote_state_error\", \"Cannot approve an already approved quote\")\n```\n\n#### `ServerValidationErrorResponse`\n* 422\n* To be used when a validation error occurs that could only be detected by the server.\n* `error_code` and `detail` must be specified.\n ```python\nresponses.ClientErrorResponse(\"email_already_taken\", \"The email you have provided is already in use\")\n```\n\n## Exceptions\n\n### ValidationError\nUse sparingly. If raised, the framework will catch it and return generate a `ClientErrorResponse`, with `\"validation_error\"` as the `error_code` and the error message as `detail`. However, in most cases you should just catch your own errors and return `ClientErrorResponse`.\n\n### ImmediateResponseError\nThis exception takes in a response instance and, when raised, the framework will catch it and return the response it was instantiated with. This is useful when you have some shared function between two view functions and want to quickly bail in the shared function.\n```python\nclass SomeObjView(View):\n    def _get_some_obj(self, id):\n        try:\n            return SomeObj.objects.get(id=id)\n        except:\n            raise exceptions.ImmediateResponseError(responses.NotFoundResponse())\n\n    @view.method(\"GET\")\n    def get_some_obj(request, id=None):\n        obj = self._get_some_obj(id)\n        ...\n\n    @view.method(\"PATCH\")\n    def patch_some_obj(request, id=None):\n        obj = self._get_some_obj(id)\n        ...\n```\n## Schemas & Fields\n\nSchemas and Fields use the Marshmallow library under the hood.\n\nAll schema fields support the following arguments:\n* `default`\n\t* All fields in a schema are required by default. Use the `default` argument to both mark a field as optional and specify the default value to use if the field is not received.\n\t* If you would like the field to be left out entirely of the parsed params/payload, you can do `default=fields.OMIT`\n*  `allow_none`\n\t* Defaults to `False`. Pass in `True` if you would like to accept `None` (`null`) as a passed in value.\n* `validate`\n\t* Function that takes in the value and returns `True` or `False` appropriately.\n* `transform`\n\t* Function that takes in the value and returns a value of the same type. This will run _before_ validation.\n* `many`\n\t* Defaults to `False`. Pass in `True` if multiple values are allowed for the field. `many=True` will result in a list of values on the parsed params/payload.\n\t* For query parameters, this will support both comma separated values under a single arg (`?order_ids=1,2`) and multiple instances of the arg `(?order_ids=1&order_ids=2)`.\n\t* For payloads, a list of values is expected.\n\t* When used with `validate` and/or `transform`, these functions will be applied to each individual value.\n* `param_name`\n\t* Use sparingly. It's to be used if the incoming query parameter will have a different name than the field name in the schema. For example, if the incoming query parameter will be specified as `?state=foo`, but you would like it to be `order_state` under `request.params`, you would do: `{\"order_state\": fields.String(param_name=\"state\")}`\n\nThe available fields and their custom arguments are:\n* `Bool`\n* `DateTime`\n* `Date`\n* `Time`\n* `Int`\n\t* `min_val`\n\t* `max_val`\n* `String`\n\t* `min_length`\n\t* `max_length`\n\t* `allow_empty`\n\t\t* Defaults to `False`. If you would like to accept empty strings as valid values passed in, do `allow_empty=True`.\n* `Enum`\n\t* `choices`\n\t\t* List of acceptable string values\n* `UUID`\n* `Float`\n* `Decimal`\n\t* `max_digits`\n    * `min_val`\n    * `max_val`\n* `Email`\n* `Dict`\n\t* Use sparingly. Allows for any arbitrary dictionary to be passed in.\n\n### Nested schemas\n\nTo nest a schema, do:\n```python\n@view(payload={\n    \"id\": fields.Int(),\n    \"nested_object\": fields.Nested({\n        \"name\": fields.String()\n    })\n})\n```\n`Nested` fields accept all of the same arguments as the other fields.\n\n### What about PATCH?\n\nIf you would like to support traditional PATCH behavior (where the client only sends down the fields to be updated), and need to know which fields were sent down or not, then doing something like `default=None` is not going to work for you. Normally, a field is either required, or has a default value and will appear on the parsed data with the default value if it was not sent down. Luckily, you can pass `default=fields.OMIT` to the field and it will be left out of the parsed data if it wasn't sent down. Here's an example:\n```python\n@view(\n    \"PATCH\",\n    payload={\n       \"first_name\": fields.String(default=fields.OMIT),\n        \"last_name\": fields.String(default=fields.OMIT)\n    }\n)\ndef update_person(request, id=None):\n    person = Person.objects.get(id=id)\n\n    data = request.payload.as_dict()\n\n    if \"first_name\" in data:\n        person.first_name = data[\"first_name\"]\n    if \"last_name\" in data:\n        person.last_name = data[\"last_name\"]\n\n    person.save()\n\n    return responses.DetailResponse()\n\n```\n\n## Pagination\n\nThe pagination mechanics are fully managed by the framework. All you have to do is specify `paginated=True` in the decorator, and return a `PaginatedResponse` object.\n\nThe expected query parameters when `paginated=True` are `page` and `page_size`.\n\n`page` obviously defaults to `1`, and `page_size` defaults to `20`, but the client is more than welcome to send down a different value for `page_size`.\n\nYou can globally override the default `page_size` via the `API_TOOLS[\"DEFAULT_PAGE_SIZE\"]` setting. You can override a particular view's default page size via the `page_size` argument to the decorator.\n\nThe pagination data returned in the response under the `pagination` key looks like:\n```json\n{\n    \"page\": 1,\n    \"page_size\": 20,\n    \"num_pages\": 5,\n    \"total_objects\": 89,\n    \"next_page\": \"/api/v1/orders?page=2&page_size=20\",\n    \"previous_page\": null\n}\n```\nAn empty page will be returned if the first page is requested and there is no data. Otherwise, if a non-existent page is requested, a 400 response will be returned.\n\n## Requests\n\nIf `params` or `payload` is specified in the decorator, then the parsed query parameters will be at `request.params` or `request.payload`. This will be an immutable object. If you would like it in the form of a dictionary, you can do `request.params.as_dict()`.\n\n## Permissions\n\nPermissions are required. A non-empty list must be passed into the decorator. If you would like to write an unauthorized endpoint, you can do:\n```python\nfrom mbq.api_tools import permissions\n\n@view(permissions=[permissions.NoAuthorization])\ndef my_view(request):\n    pass\n````\n\n## Settings\nThe default settings are:\n```python\nAPI_TOOLS = {\n    \"DEFAULT_PAGE_SIZE\": 20,\n    \"UNKNOWN_PAYLOAD_FIELDS\": \"raise\",\n    \"UNKNOWN_PARAM_FIELDS\": \"raise\",\n}\n```\nOverride as you see fit.",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/managedbyq/mbq.apitools",
    "keywords": "",
    "license": "Apache 2.0",
    "maintainer": "Managed by Q, Inc.",
    "maintainer_email": "open-source@managedbyq.com",
    "name": "mbq.apitools",
    "package_url": "https://pypi.org/project/mbq.apitools/",
    "platform": "",
    "project_url": "https://pypi.org/project/mbq.apitools/",
    "project_urls": {
      "Homepage": "https://github.com/managedbyq/mbq.apitools"
    },
    "release_url": "https://pypi.org/project/mbq.apitools/1.4.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "MBQ APITools",
    "version": "1.4.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5782182,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c8ae12711ae8726b6f2cfb07867648c6b14fe4c8b1c0db0998e353989a30c208",
        "md5": "578bf84315166ddc72f5c9a0911e2546",
        "sha256": "f8c873a1f2ae257062b79f094c2a314487e3bb4bb985a2f1f4f2e312b0da5154"
      },
      "downloads": -1,
      "filename": "mbq.apitools-1.4.0.tar.gz",
      "has_sig": false,
      "md5_digest": "578bf84315166ddc72f5c9a0911e2546",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 24157,
      "upload_time": "2019-07-29T20:41:39",
      "upload_time_iso_8601": "2019-07-29T20:41:39.485543Z",
      "url": "https://files.pythonhosted.org/packages/c8/ae/12711ae8726b6f2cfb07867648c6b14fe4c8b1c0db0998e353989a30c208/mbq.apitools-1.4.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}