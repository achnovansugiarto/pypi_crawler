{
  "info": {
    "author": "DecimalTeam",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Decimal Python SDK\n\nCheck out these links:\n- [Decimal SDK docs](https://help.decimalchain.com/api-sdk/).\n- [Decimal Console site](https://console.decimalchain.com/).\n\n## Wallet API\n### Generate new wallet\n```python\nfrom dsc_sdk import Wallet\n\nwallet = Wallet()\n```\n### Generate wallet from mnemonic*\n*if no mnemonic provided Wallet() will create instance with autogenerated mnemonic\n\n```python\nfrom dsc_sdk import Wallet\n\nwallet = Wallet('erase august mask elevator sand picture north there apple equal anchor target...')\n```\n### Get wallet address\n```python\nfrom dsc_sdk import Wallet\n\nwallet = Wallet()\nwallet.get_address() # returns wallet address\nwallet.get_mnemonic() # returns wallet mnemonic\n```\n\n## Get DecimalAPI to perform transactions\nTo initiate api you have to pass address of the gateway for network you will work with \n```python\nfrom dsc_sdk import DscAPI\n# or you can use dsc_sdk.MAINNET_GATE, TESTNET_GATE, DEVNET_GATE\napi = DscAPI(\"https://devnet-gate.decimalchain.com/api\")\n\n# read chain id & base coin denomination\napi.get_parameters()\nprint(api.get_chain_id())\nprint(api.get_base_denom())\n```\n\n## API usage\nAfter you initialized api instance, you can use its` broadcast() method to send prepared transaction.\nTransaction creation examples can be found in this file.\n\n```python\nfrom dsc_sdk import DscAPI\napi = DscAPI(\"https://devnet-gate.decimalchain.com/api\")\napi.broadcast(prepared_transaction_bytes)\n```\n\n## Build and send transaction\n\n```python\n\n# all Msg* functions is defined in tx_types.py\nfrom dsc_sdk import DscAPI, Wallet, Transaction, MsgSendCoin, ...\n# helper functions to convert integer values to valid blockchain amounts\nfrom dsc_sdk import ether_to_wei, finney_to_wei\n\n##### 1. initialize api\n# You can also use constants\n# MAINNET_GATE, TESTNET_GATE, DEVNET_GATE and MAINNET_WEB3, TESTNET_WEB3, DEVNET_WEB3\napi = DscAPI(\"https://devnet-gate.decimalchain.com/api\", \"https://devnet-val.decimalchain.com/web3/\")\n# or, if you don't want to use web3 from API\napi = DscAPI(\"https://devnet-gate.decimalchain.com/api\")\napi.get_parameters()\n\n##### 2. create wallet and bind it to current blockchain\nwallet = Wallet(mnemonic1)\nan, seq = api.get_account_number_and_sequence(wallet.get_address())\nwallet.set_account_number(an)\nwallet.set_sequence(seq)\nwallet.set_chain_id(api.get_chain_id())\n\n##### 3. create and sign transaction\n\n# create transaction message\n# sender and recipient must be valid bech32 address\n# like d01...\nmsg = MsgSendCoin(sender, recipient, coin_denom, ether_to_wei(1))\ntx = Transaction.build_tx(msg)\n\n# optional: set memo, set custom coin fee...\ntx.set_memo(\"hello from python\")\ntx.set_fee(\"initiald\", ether_to_wei(1))\n# calculate_fee calculates fee in specified denom and set it\n# wallet is used for signing and for right transaction length\ntx.calculate_fee(wallet, \"initiald\", api)\n\n# sign transaction and get transaction bytes to send\ntx_bytes = tx.sign(wallet)\n\n##### 4. send transaction and examine result\ntxres = api.broadcast(tx_bytes)\nprint(txres.hash, txres.code, txres.codespace)\n\n```\n\n## Known transaction message types (constructors)\n\nNOTE:\n- `sender` and `recipient` must be valid bech32 addresses with `d0` prefix\n- `validator...` must be valid bech32 addresses with `d0valoper` prefix\n- `amount` must be integer value in string representation\n\n### Coin module contructors\n- `MsgCreateCoin(sender: str, denom: str, title: str, crr: int, initial_volume: str, initial_reserve: str, limit_volume: str,     identity: str)` (Message to create custom coin)\n    - `denom` - short ticket for coin, first symbol must be letter, others must be letters and digits, up to 10 symbols\n    - `crr` - constant reserve ratio, integer value between 10 and 100\n    - `initial_volume`, `initial_reserve`, `limit_volume` - big integers as string, inital amount of custom coin, initial reserve in base coin, limit for custom coin amount\n- `MsgUpdateCoin(sender: str, denom: str, limit_volume: str, identity: str)` (Message to update custom coin limit volume and identity, only creator can update coin, limit must be greater than current volume)\n- `MsgBuyCoin(sender: str, denom_to_buy: str, amount_to_buy: str, denom_to_sell: str, max_amount_to_sell: str)` (Message to buy coin)\n- `MsgSellCoin(sender: str, denom_to_sell: str, amount_to_sell: str, denom_to_buy: str, min_amount_to_buy: str)` (Message to sell coin)\n- `MsgSendCoin(sender: str, recipient: str, denom: str, amount: str)` (Message to send coin from sender to recipient)\n- `MsgMultiSendCoin(sender: str, sends: List[coin_tx.MultiSendEntry]), MultiSendEntry(recipient: str, denom: str, amount: str)` (Message to send possible different coins for sender to multiple recipients)\n- `MsgBurnCoin(sender: str, denom: str, amount: str)` (Message to burn coin volume (not reserve), coin will be substracted from sender balance)\n- `MsgRedeemCheck(sender: str, check: str, proof: str)` (Message to redeem check)\n    - `check` - base58 encoded check bytes\n    - `proof` - password for check\n\nhelper to send all coins\n- `BuildSendAllCoin(signer: Wallet, api, recipient: str, coin_denom: str) -> bytes` (return signed transaction bytes)\n\n### Multisig module contructors\n- `MsgCreateWallet(sender: str, owners: List[str], weights: List[int], threshold: int)` (Message to create multisig wallet)\n    - `owners` - list of valid account addresses\n    - `weights` - voting weights of owners\n    - `threshold` - threshold level to execute transaction\n- `MsgCreateTransaction(sender: str, wallet: str, msg)` (Message to create multisig transaction, sender must be one of wallets owner)\n    - `msg` - result of any Msg* constructor\n- `MsgSignTransaction(sender: str, id: str)` (Message to sign, sender must be one of wallets owner)\n    - `id` - multisig transaction id, bech32 value with prefix `d0mstx`\n\n### NFT module constructors\n- `MsgMintToken(sender: str, denom: str, token_id: str, token_uri: str, allow_mint: bool, recipient: str, quantity: int, reserve_denom: str, reserve_amount: str)` (Message to mint NFT token)\n    - `denom` - name of NFT collection\n    - `token_id` - blockchain unique token identifier\n    - `token_uri` - blockchain unique URI\n    - `allow_mint` - allow to mint subtoken\n    - `recipient` - recipient of NFT subtokens\n    - `quantity` - amount of NFT subtokens to mint\n    - `reserve_denom` - denom of coin to reserve subtokens\n    - `reserve_amount` - amount of coin to reserve subtokens PER ONE SUBTOKEN\n- `MsgUpdateToken(sender: str, token_id: str, token_uri: str)` (Message to update token URI, only creator can do that)\n- `MsgUpdateReserve(sender: str, token_id: str, sub_token_ids: List[int], reserve_denom: str, reserve_amount: str)` (Message to update subtokens reserve, only creator can do that)\n- `MsgSendToken(sender: str, recipient: str, token_id: str, sub_token_ids: List[int])` (Message to send subtokens from sender to recipient)\n- `MsgBurnToken(sender: str, token_id: str, sub_token_ids: List[int])` (Message to burn subtokens, only creator can do that, subtokens reserve will be return to creator)\n\n### Swap module constructors\n- `MsgInitializeSwap(sender: str, recipient: str, amount: str, token_symbol: str, transaction_number: str, from_chain: int, dest_chain: int)` (Message to initialize coin swap from one blockchain to other)\n    - `recipient` - address in other blockchain\n    - `amount` - amount of coin/token\n    - `token_symbol` - coin denom/token symbol\n    - `transaction number` - unique transaction number\n    - `from_chain` - source blockchain id in swap chains records\n    - `dest_chain` - desctination blockchain id in swap chains records\n\n### Validator module constructors\n- `MsgCreateValidator(operator_address: str, reward_address: str, pubkey: bytes, moniker: str, identity: str, website: str, security_contact: str, details: str, commission: str, stake_denom: str, stake_amount: str)` (Message to create validator)\n    - `operator_address` - sender address encoded as bech32 with prefix `d0valoper`\n    - `reward_address` - address to receive validator rewards, bech32 address with prefix `d0`\n    - `pubkey` - node public key bytes\n    - `moniker, indentity, website, security_contact, details` - validator description\n    - `commission` - part of rewards to send to `reward_address`, must be string representation of floating point value between 0.0 and 1.0\n    - `stake_denom, stake_amount` - creator initial coin stake\n- `MsgEditValidator(operator_address: str, reward_address: str, moniker: str, identity: str, website: str, security_contact: str, details: str)` (Message to change validator reward address, description)\n- `MsgSetOnline(validator: str)` (Message to set validator online)\n- `MsgSetOffline(validator: str)` (Message to set validator offline)\n- `MsgDelegate(delegator: str, validator: str, coin_denom: str, coin_amount: str)` (Message to delegate coin to validator)\n- `MsgDelegateNFT(delegator: str, validator: str, token_id: str, sub_token_ids: List[int])` (Message to delegate NFT subtokens to validator)\n- `MsgRedelegate(delegator: str, validator_src: str, validator_dst: str, coin_denom: str, coin_amount: str)` (Message to redelegate coins from one validator to other)\n- `MsgRedelegateNFT(delegator: str, validator_src: str, validator_dst: str, token_id: str, sub_token_ids: List[int])` (Message to redelegate NFT subtokens from one validator to other)\n- `MsgUndelegate(delegator: str, validator: str, coin_denom: str, coin_amount: str)` (Message to undelegate coin from validator)\n- `MsgUndelegateNFT(delegator: str, validator: str, token_id: str, sub_token_ids: List[int])` (Message to undelegate NFT subtokens from validator)\n- `MsgCancelRedelegation(delegator: str, validator_src: str, validator_dst: str, creation_height: int, coin_denom: str, coin_amount: str)` (Message to cancel coin redelegation)\n- `MsgCancelRedelegationNFT(delegator: str, validator_src: str, validator_dst: str, creation_height: int, token_id: str, sub_token_ids: List[int])` (Message to cancel NFT subtoken redelegation)\n- `MsgCancelUndelegation(delegator: str, validator: str, creation_height: int, coin_denom: str, coin_amount: str)` (Message to cancel coin undelegation)\n- `MsgCancelUndelegationNFT(delegator: str, validator: str, creation_height: int, token_id: str, sub_token_ids: List[int])` (Message to cancel NFT subtokens undelegation)\n\n## Known API query methods\n\n```\nget_account_balances(self, address: str) -> Dict[str, str]\n\nget_account_erc_balances(self, hex_address: str) -> List[ERCBalance]\n\nget_erc20_tokens(self, limit=10, offset=0)\n\nget_nft_tokens(self, address: str, limit=10, offset=0)\n\n```\n\n## Helper functions\n\n- `ether_to_wei` : convert integer value to valid amount representation ( * 10^18)\n- `finney_to_wei` : convert integer value to valid amount representation ( * 10^15)\n- `wei_to_ether` : convert amount string representation to float value ( / 10^18)\n- `check_address_validity` : check bech32 address; return true if it's valid bech32 representation \n- `d0_to_hex`, `hex_to_d0` : convert DSC address ith prefix d0 to/from Ethereum hex presentation\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/decimalteam/dsc-python-sdk",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dsc-python-sdk",
    "package_url": "https://pypi.org/project/dsc-python-sdk/",
    "platform": null,
    "project_url": "https://pypi.org/project/dsc-python-sdk/",
    "project_urls": {
      "Homepage": "https://bitbucket.org/decimalteam/dsc-python-sdk"
    },
    "release_url": "https://pypi.org/project/dsc-python-sdk/1.1.0/",
    "requires_dist": [
      "asn1crypto (==1.5.1)",
      "base58 (==2.0.0)",
      "base58check (==1.0.2)",
      "bech32 (==1.2.0)",
      "bip32 (==3.3)",
      "cached-property (==1.5.2)",
      "cffi (==1.14.3)",
      "chardet (==3.0.4)",
      "coincurve (==17.0.0)",
      "ecdsa (==0.16.1)",
      "eth-hash (==0.3.1)",
      "eth-typing (==2.2.2)",
      "eth-utils (==1.10.0)",
      "ethereum (==2.3.2)",
      "future (==0.18.2)",
      "idna (==2.10)",
      "mnemonic (==0.20)",
      "mypy-extensions (==0.4.3)",
      "pbkdf2 (==1.3)",
      "protobuf (==3.19.5)",
      "py-ecc (==5.1.0)",
      "pyaes (==1.6.1)",
      "pycparser (==2.20)",
      "pycryptodome (==3.15.0)",
      "pycryptodomex (==3.15.0)",
      "pyethash (==0.1.27)",
      "requests (==2.25.0)",
      "web3 (==5.31.1)"
    ],
    "requires_python": ">=3.6",
    "summary": "",
    "version": "1.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17337641,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "75a0a490ab79c6e882761c0fccabd684eb1405fab67ab446d94ab526667e277b",
        "md5": "fe5e3fb26543093800117c0591e8a157",
        "sha256": "20671aaede74ed2435df2fe7bf42f178fd803d793ebc723d087018e02f6fb760"
      },
      "downloads": -1,
      "filename": "dsc_python_sdk-1.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "fe5e3fb26543093800117c0591e8a157",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 415761,
      "upload_time": "2022-12-22T02:17:48",
      "upload_time_iso_8601": "2022-12-22T02:17:48.748588Z",
      "url": "https://files.pythonhosted.org/packages/75/a0/a490ab79c6e882761c0fccabd684eb1405fab67ab446d94ab526667e277b/dsc_python_sdk-1.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}