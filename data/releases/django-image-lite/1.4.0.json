{
  "info": {
    "author": null,
    "author_email": "robert crowther <rw.crowther@gmail.com>",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# ImageLite\nNB: Version 1, because incompatible change behind API: filters now generate subfolders, not use prefix naming (I never used the feature, don't believe anyone else is)\n\nAn app for local filesystem image storage. In truth, it's not 'Lite', with custom repository creation from an abstract base, an easy to configure and massively capable filter stack, enhanced upload options, and powerful template tags for rendering. But it's a reduction of a more general app, to avoid Django annoyances, so 'Lite'.\n\nThis is [a rewrite of Wagtail's Image app](#credits).\n\n## Why you would not want to use this app\n- It's (currently) written for local filesystem storage only (no remote)\n- Raster image files only, no SVG, movie files, documents, etc.\n- Filters can not be applied to individual images\n- No effort to present filters to users, either admin or visitors\n- The user must manage filenames (see below)\n- No builtin categorisation and/or tagging\n\n\n\n## Why you would want to use this app\n- Abstract base allows any number of repositories with custom configurations\n- If you want to scale beyond the app, the data is unobtrusive and needs no rebuilding\n- Auto-generates filtered images\n- Filter declarations can travel with apps (like CSS)\n- Two (primary) template tags\n\n\n \n## The key point about this app---please read\nIf you wish to associate files with pages, the app can do this. But the app is not designed to use a Foreign field. It is designed to avoid use of foreign fields. \n\nSo, if you have a model of, say, a product, how do you associate uploaded images with the model? You use a URL. The product is called 'BansheeX4000'. So an image of this product must have the filename 'BansheeX4000.png' (the URLs are easily configurable, but this is the most likely scheme).\n\nThere are downsides to this approach,\n- It puts the burden on the user to create filenames as intended. A solution using foreign keys could upload any image, then automatically make the connection\n- Since the models do not know (much) about the attached images, editing of uploaded images is pushed back onto management commands \n- Django admin for the models can not display the upload form (no model field to render). \n\nBut there are upsides,\n- Django admin displays for foreign fields are very limited. As default they are select boxes. ImageLite's URL system is more pleasant.\n- Without foreign fields, the system is easier to scale. If you wish to move image handling out of Django, there are no foreign fields to remove, and image data is naturally organised\n\n \n## Overview\nThere is a base model called AbstractImage. From this, sub-models can be constructed. Each sub-model is an image repository. Sub-models track uploads in a database table, and store files in a location. Locations are in subfolders of MEDIA_ROOT.\n\nEach original image can generate derivative images. Derivative images are untracked and generated on a successful upload. The derivative images are called 'reforms' and are generated by filters. Reforms can be thumbnails, watermarked etc. \n\nImage delivery is by template tag. The tags write HTML elements with an appropriate URL. The model tag constructs the URL by asking the model instances they receive.\n\n## If you have done this before\n- [subclass the base model for Image](#custom-image-repositories) to create a repository. Tweak settings.\n- Migrate custom repository tables\n- Set an [admin](#admin)\n- Create an 'image_filters.py' file in the app, then [subclass a few filters](#filters)\n- Insert [template tags](#rendering) into relevant templates\n\n\n## Quickstart\n### Dependencies\nPillow,\n\n    pip install pillow\n\n[Pillow](https://pillow.readthedocs.io/en/stable/index.html)\n\n\n#### Optional\nTo use Wand filters, on Debian-based distros,\n\n    sudo apt-get install libmagickwand-dev\n\nThen,\n\n    pip install wand\n\n\n### Install\nPyPi,\n\n    pip install django-imagelite\n\nOr download the app code to Django.\n\nDeclare in Django settings,\n\n        INSTALLED_APPS = [\n            ...\n            'image.apps.ImageLiteConfig',\n        ]\n\nMigrate,\n\n    ./manage.py makemigrations image_lite\n    ./manage.py migrate image_lite\n\nNow you need to [declare a repository](#custom-image-repositories). Further examples assume the example repository created there.\n\n\n### Make some filters\nIn the repository, create a file image_filters.py. Paste this into it,\n\n    from image_lite import filters_pillow, register\n\n    @register()\n    class Thumb(filters_pillow.Resize):\n        width=64\n        height=64\n        format='png'\n\nChange as you wish.\n\n### Upload some images\nIn Django admin, upload a few images.\n\nI don't know about you, but if I have a new app I like to try with real data. If you have a collection of test images somewhere, try this management command,\n\n    ./manage.py image_create_bulk news_article_images.NewsArticleImage pathToMyDirectory\n\nNote you need to give a path to a Model. You can create, meaning upload and register, fifteen or twenty images in a few seconds.\n\n### View some images\nOk, let's see an image. Find a web view template. Nearly any template will do (maybe not a JSON REST interface, something visible).\n\nAdd this tag to the template,\n\n    {% load img_tags %}\n    ...\n    {% image_fixed news_images.NewsImage riverbank-enforcement Thumb %}\n\n\n'news_images.NewsImage' is the path to the repository model. 'riverbank-enforcement' is the filename. 'Thumb' is the filter we made earlier. \n\nVisit the page. You should see a thumbnail of the 'riverbank-enforcement' image.\n\n\n## QuickStop\nDon't like what you see?\n\n- Remove any temporary code.\n- Migrate backwards ('./manage.py migrate imagelite zero')\n- Remove from 'apps.py'\n- Remove the two media directories. Defaults are '/media/originals/' and '/media/reforms/'\n- Remove the app folder, or uninstall\n\nThat's it, gone.\n\n## Full documentation\nIndex, \n- [Image Repository Models](#image-repository-models)\n- [Model Fields](#model-fields)\n- [Auto Delete](#auto-delete)\n- [Filters](#filters)\n- [Admin](#admin)\n- [Rendering](#rendering)\n- [Management Commands](#management-commands)\n\n\n## Installation\nFor most users, PiPy. The ImageLite core has no migrations, users build custom models for image repositories. However, you must declare the app core in settings, otherwise the app will not be able to find image filters, so you'll get a stream of nasty ''module not found' errors,\n \n        INSTALLED_APPS = [\n            ...\n            'image.apps.ImageLiteConfig',\n        ]\n\nAlso, you may want to cross-check or declare in settings.py where images will go,\n\n    MEDIA_ROOT = BASE_DIR / 'files_upload'\n    MEDIA_URL = '/images/'\n\nAnd there are a couple of configuration options for searching for filters (SEARCH_APP_DIRS=True is default, anyway),\n\n    IMAGES = [\n        {\n            'SEARCH_APP_DIRS': True,\n            'SEARCH_MODULES': [\n            ],\n        },\n    ]\n\n\n## Image Repository models\n### Overview\nNew repositories can be made by subclassing the the core model. Reasons you may want to customise repositories,\n\n#### Repository behaviour\nCustom repositories have new DB tables, and can operate with new configurations such as storing files in different directories, auto-deleting original files, not limiting filename sizes and more.\n\n#### Associate data with images\nYou may want to associate data with an image. Many people's first thought would be to add a title (ImageLite does not provide titles by default). But other kinds of information can be attached to an image such as captions, credits, dates, and/or data for semantic/SEO rendering.\n\n#### Split needs\nFor example, you may want an image repository attached to a main Article model, but also an image pool for general site use such as banners or icons. \n \n\n### Subclassing AbstractImage \nCustom Image repository code is placed in 'models.py' files and migrated. You decide how you want your namespacing to work. The code can be placed in an app handling one kind of model or, for general use, in a separate app. Or you can have one seperate app, called for example ''site_images'. handling several repositories (I'm fond of this level of encapsulation).\n\nFor a separate app,\n\n    ./manage.py startapp news_article_images\n\nDeclare the app in settings.py,\n\n        INSTALLED_APPS = [\n            ...\n            'image.apps.ImageConfig',\n            'news_article_images.apps.NewsArticleImagesConfig',\n        ]\n\nHere is a minimal subclass. In a 'models.py' file, do this,\n\n    from django.db import models\n    from image_lite.models import AbstractImage\n\n\n    class NewsArticleImage(AbstractImage):\n        upload_dir='news_originals'\n        reform_dir='news_reforms'\n\n        # AbstractImage has a file and upload_date\n        # but add whatever new fields you want e.g.\n        caption = models.CharField(_('Caption'),\n            max_length=255,\n        )\n\n        author = models.CharField(_('Author'),\n            max_length=255,\n            db_index=True\n        )\n\n        etc.\n\nMigrate,\n\n    ./manage.py makemigrations news_article_images\n    ./manage.py migrate news_article_images\n\nYou now have a new image upload app. It has it's own DB table. You can change it's configuration (see next section).\n\n\n### Attributes\nSubclasses accept some attributes. Note that some of these settings are radical alterations to a model class. To be sure a model setting will take effect, it is best to migrate the class.\n\nAn expanded version of the above,\n\n    from image.models import AbstractImage, AbstractReform\n\n    class NewsArticleImage(AbstractImage):\n        upload_dir='news_originals'\n        filepath_length=55\n        form_limit_filepath_length=True\n        accept_formats = ['png']\n        max_upload_size=2\n        auto_delete_upload_file=True\n        filters=[]\n        reform_dir='news_reforms'\n        ...\n\nI hope what these attributes do is easy to understand. None of them are available through standard Django or, not in this simple way.\n\nThe 'filters' attribute may need a little explanation. You provide an 'image_filters' file with each app, which implements image-lite. By default, the code will apply all the 'image_filters' to any uploaded file. This is awkward if there is two or more repositories in one app, because they all apply the same filters. In this case, you can set filters to a list of filter names, which will be the only filters used for that model/repository.\n\nMultiple filters will generate subdirectories for filters after the first. The subdirectories are named from a lowercase version of the filter name. \n\nSince they are easy to create, I usually have many image repositories in every project, Each one usually has a single general filter, such as a ResizeFill and watermark. Further filters, generating subdirectories are there for format variations, like thumbnails. The repositories are categorising for me, and I have no need of further namespacing.\n\nMigrate, and you are up and running.\n\n### Blocking file renaming\nIt is impossible to have two files in the same directory with the same name (this applies also to remote storage). The default behaviour of Django uploading is to enable uploads if possible, so the standard FileSystemStorage module will rename duplicate filenames. It does this by adding a pseudo-random sequence of codepoints to the filename. \n\nFor the general outlook of ImageLite, this is not always what is wanted. If a user has uploaded an image called 'Spin_X9000CA', a later attempt to add a  'Spin_X9000CA' image should be blocked, or replace the first image (standard behaviour would be to generate a new filename such as 'Spin_X9000CA_WEN42HDOE5'). \n\nOnly you can decide if blocking is more appropriate than renaming. There is a builtin way to block duplicate filenames, using a mixin,\n\n    ...\n    from image_lite import ModelUniqueFilenameMixin\n\n        class RevImage(ModelUniqueFilenameMixin, AbstractImage):\n            ...\nIf an image repository uses this mixin, attempts to upload  duplicate filenames cause a ValidationError. The user sees a message 'filename already exists'.\n\n\n### Inheritance! Can I build repositories using OOP techniques?\nNo! Python has been cautious about this kind of programming, and Django's solutions are a workround. Do not stack models or you will create unusable migrations.\n\n\n### Can I create different repositories, then point them at the same storage paths?\nNo, you risk duplicate entries.\n\n\n### Things to consider when subclassing models\n#### Auto delete of files\nGood to decide a deletion policy from the start. See [Auto Delete](#auto-delete)\n \n#### Add Meta information\nYou may want to configure a Meta class. If you added titles or slugs, for example, you may be interested in making them into unique constrained groups, or adding indexes,\n\n    class NewssArticleImage(AbstractImage):\n        upload_dir='news_originals'\n        filepath_length=100\n\n        etc.\n\n        class Meta:\n            verbose_name = _('news_image')\n            verbose_name_plural = _('news_images')\n            indexes = [\n                models.Index(fields=['author']),\n            ]\n            constraints = [\n                models.UniqueConstraint(\n                    fields=['title', 'author'], \n                    name='unique_newsarticle_reform_src'\n                )\n            indexes = [\n                models.Index(fields=['upload_time']),\n            ]\n\nNote that the base Image does not apply an index to upload_time, so if you want that, you must specify it.\n\n## Auto-delete\n### Overview\nI read somewhere that a long time ago, Django auto-deleted files. This probably happened in model fields. This behaviour is not true now. If objects and fields are deleted, files are left in the host system. However, it suits this application, and some of it's intended uses, to auto-delete files.\n\nImageLite deletes from the 'post-delete' signal. That means it will remove the DB record, then attempt file deletion. If file-deletion fails, it will leave files orphaned. For the purpose of ImageLite, this is seen to be preferable to the alternative, which would block admin forms because file deletion failed.\n\n### Reforms\nImageLite treats reforms as cache. They can expire, be created, moved and deleted as necessary. So, when an image is deleted, ImageLite always attempts to delete the reforms. It may not succeed, because if you have rebuilt filters or changed filter settings it will not know where to look. But ImageLite will try. If it fails, it fails silently. ImageLite works from a signal, so will always try, for bulk deletes also.\n\n#### Auto-delete Image files\nTo auto-delete, set the Image model attribute 'auto_delete_upload_file=True'.  This action is triggered by a signal, so will work for bulk deletes also. The code will then attempt to remove both the original image and reforms. \n\n\n## Filters\n### Overview\nFilters are used to describe how an uploaded image should be modified for display. On upload, the app will automatically generate reformed images.\n \nYou can use the provided filters. but if you want to pass some time with image-processing code, you can add filters to generate ''PuddingColour' and other effects.\n\n### Filter placement and registration\nFiles of filter definitions should be placed in a repository app. Create a file called 'image_filters.py' and off you go.\n\n\n### Base filters\nThe filter code is a stack of inherited classes. There are some base filters, which you can configure. These are centre-anchored, If you only need different image sizes, you only need to configure these.. Smpling is usually default BILINEAR (because choosing the filter for the material is more important. If you must, make your own filter).\n\n#### ResizeForce\nReshape the image to the given size.\n\n#### Crop\nCrop within boundaries of a given size. If the image is small, nothing happens, which may leave gaps.\n \n#### Resize\nResize within boundaries of a given size. Aspect ratio preserved, which may leave gaps.\n\n#### CropFill\nCrop within boundaries of a given size. If the image is small, space filled with given background color.\n\n#### ResizeFill\nResize within boundaries of a given size. Aspect ratio preserved, space filled with given background color.\n\n\n\n### Filter declarations\nAll builtin filter bases accept these attributes,\n\n- width\n- height\n- format\n\nMost filter code demands 'width' and 'height' and 'format'.'format' defaults to 'jpg'. Formats accepted are conservative,\n\n    bmp, gif, ico, jpg, png, rgb, tiff, webp \n\nwhich should be written as above (lowercase, and 'jpg', not 'jpeg'). So,\n\n    from image import Resize, registry\n\n    class MediumImage(Resize)\n        width=260\n        height=350\n        format='png'\n        #fill_color=\"Coral\"\n        #jpeg_quality=28\n        # optional effects\n\n    registry.register(MediumImage)\n\n\n### 'Fill' filters\nCrop and Resize will preserve aspect ratio. This I think is desired behaviour in many situations. However, it will leave gaps if the aspect ratio of the original does not match that given to reshape to.\n\nSometimes it may be preferable that the image become the exact size given. One way is to distort the image ('Force' filters). Another way is the Fill filters. These make the image fit bounding dimensions, then fill surplus area with a fill colour,\n\n    from image import ResizeFill, registry\n\n    class MediumImage(ResizeFill):\n        width=260\n        height=350\n        format='jpg'\n        fill_color=\"Coral\"\n\n    registry.register(MediumImage)\n\nFill color is defined however the image library handles it. Both Pillow and Wand can handle CSS style hex e.g. '#00FF00' (green), and HTML colour-names e.g. 'AliceWhite'.\n\n\n### Registering filters\nFilters need to be registered. Registration style is like ModelAdmin, templates etc. Registration is to 'image.registry' (this is how templatetags find them).\n\nYou can use an explicit declaration,\n\n    from image_lite import ResizeFill, registry\n\n    ...\n\n    registry.register(single_or_list_of_filters)\n\nOr use the decorator,\n\n    from image_lite import register, ResizeFill\n\n    @register()\n    class MediumImage(ResizeFill):\n        width=260\n        height=350\n        format='jpg'\n        fill_color=\"Coral\"\n\n\n### Wand filters\nThe base filters in the Wand filter set have more attributes available. The 'wand' code needs Wand to be installed on the host computer. Assuming that, you gain these effects,\n\n    from image import filters_wand, register\n\n    @register()\n    class Medium(filters_wand.ResizeFill):\n        width=260\n        height=350\n        format='jpg'\n        pop=False\n        greyscale=False\n        night=False\n        warm=False\n        strong=False\n        no=False\n        watermark='image/watermark.png'\n\n\n\nIf you enable more than one effect, they will chain, though you have no control over order.\n\nI lost my way with the Wand effects. There is no 'blur', no 'rotate', no 'waves'. But there is,\n\n<dl>\n    <dt>pop</dt>\n    <dd>\n        Tightens leveling of black and white\n    </dd>\n    <dt>greyscale</dt>\n    <dd>\n        A fast imitation\n    </dd>\n    <dt>night</dt>\n    <dd>\n        Pretend the picture is from a movie\n    </dd>\n    <dt>warm</dt>\n    <dd>\n        A small shift in hue to compensate for a common photography white-balance issue. \n    </dd>\n    <dt>strong</dt>\n    <dd>\n        Oversaturate image colors (like everyone does on the web). Unlike 'pop' this will not stress contrast so flatten blacks and whites. You may or may not prefer this. \n    </dd>\n    <dt>no</dt>\n    <dd>\n        Draw a red cross over the image\n    </dd>\n    <dt>watermark</dt>\n    <dd>Accepts a URL to a watermark image template.\n    </dd>\n</dl>\n\nWatermark deserves some explanation. This does not draw on the image, as text metrics are tricky to handle. You configure a URL stub to an image, here's a builtin,\n\n    watermark = 'image/watermark.png'\n\nThe URL is Django static-aware, but will pass untouched if you give it a web-scheme URL (like the URLs in Django Media). The template is scaled to the image-to-be-watermarked, then composited over the main image by 'dissolve'. So the watermark is customisable, can be used on most sizes of image, and is usually readable since aspect ratio is preserved.\n\nIt is probably worth saying again that you can not change the parameters, so the strengths of these effects, without creating a new filter.\n\n\n### Writing custom filter code\nFirst bear in mind that Image uses fixed parameters. So your filter must work with fixed parameters across a broad range of uploaded images. I don't want anyone to dive into code, put in hours of work, then ask me how they can create an online image-editing app. Not going to happen.\n\nHowever, while I can't make a case for 'waves' or 'pudding-colour' filters, I can see uses. For example, Wagtail CMS uses the OpenCV library to generate images that auto-focus on facial imagery (i.e. not centrally crop). There are uses for that.\n\nSecond, bear in mind that image editing is lunging into another world, rather like creating Django Forms without using models and classes. It will take time. But there is help available. Inherit from 'image.Filter'. You will need to provide a 'process' method, which takes an open Python File and returns a ByteBufferIO and a file extension.\n\nIf you want the filter to work with the Pillow or Wand libraries, you can inherit from the PillowMixin or WandMixin. These cover filehandling for those libraries. Then you can provide a 'modify' method, which alters then returns an image in the format of those libraries.\n\nSee the code for details.\n\n\n### Why can filters not be chained or given parameters?\nBecause it makes life easy for coders and users. If you want to produce a front-end that can adjust filters, or chain them, that is another step. This is not that app.\n\n\n## Admin\n### Overview\nRepository models start with stock Django admin. However, this is not always suited to the app, it's intended or possible uses. So there is a pre-configured admin.\n\n#### ImageLiteAdmin\nSignificant changes from stock admin,\n\n- changelist is tidier and includes filenames not paths\n- changelist includes 'view' and 'delete' links\n- changelist has searchable filenames\n\nEasy as this,\n\n    from django.contrib import admin\n    from image_lite.admins import ImageLiteAdmin\n    from news_images.models import NewsImage\n\n \n    # Register your models here.\n    class NewsImageAdmin(ImageLiteAdmin):\n        pass\n    \n    \n    admin.site.register(NewsImage, NewsImageAdmin)\n\n##### Notes and alternatives for ImageLiteAdmin\nYou may provide no admin at all. You can use the './manage.py' commands to do maintenance. The stock admin is provided to get you started.\n\nIf you prefer your own admin, look at the code for ImageLiteAdmin in '/image/admins.py'. It provides some clues about how to do formfield overrides and other customisation. You may find it more maintainable to build new admin code, rather than import and override.\n\n\n## Rendering\n### Overview\nYou can render the images in HTML. Since filenaming is controlled, this will often be easy,\n\n    <img src=\"/media/reforms/logo.png\" alt=\"image of logo\" class=\"main-logo\">\n\nor use template tags.\n\n### Template Tags\nCurrently, the app has two template tags. Both build a full HTML 'img' tag. Both accept keyword parameters which become HTML attributes.\n\n#### The 'image' tag\nThe main tag. It depends on calling a model to construct a URL. So you need a callable on the page model (not the image model). This callable is usually very simple, and must return the entire reform filename. You can make a few callables, one for every image reform you want to use e.g.\n\n    class NewsArticle():  \n        ...\n        def image_main_url(self):\n            url = self.title + '-Stock.png' \n            return url\n\n        def image_teaser_url(self):\n            url = self.title + '-Teaser.png' \n            return url\n\n\nOk, let's call the method from a template, with the image repository, template main variable, and callable name as parameters,\n\n    {% load img_tags %}\n\n    {% image news_images.NewsImage newsartricle image_main_url class=\"framed\" %}\n \nthen visit the page. Should see the image? As HTML it should render something like,\n\n    <img src=\"/media/reforms/eoy-report-Stock.png\" alt=\"image of eoy-report\" class=\"framed\">\n\n\n#### The 'image-fixed' tag\nThe above tag is mainly to retrieve images associated with page data. This tag lets you call by filename. Add this to template code, with the image repository, filename, and filtername as parameters,\n\n    {% load img_tags %}\n\n    {% image_fixed news_images.NewsImage forest_fire Stock class=\"ruled\" %}\n\n\nthen visit the page. Should see the image.\n\n## Management Commands\nThey are,\n\n- image_create_bulk\n- image delete_bulk\n- image_list\n- image_sync\n- reform_create\n- reform_delete\n- reform_list\n\nAll management commands must be pointed at subclasses of Image. Several have a common switch -c/--contains, which makes a basic string match. 'image_sync' can be particularly useful for half-broken repositories, it will attempt to make models for orphaned files, or delete orphaned files, or delete models with missing files. Use the -h/--help switch to discover what each command can do.\n\n\n\n## Tests\nI've not found a way to test this app without Python ducktape. There should be tests, but I don't expect them.\n\n\n## Credits\nThis is a rewrite of the Image app from Wagtail CMS. It is now distant from that app, and would not work in the Wagtail system. However, some core ideas remain, such as the replicable repositories.\n\n[Wagtail documentation](https://docs.wagtail.io/en/v2.8.1/advanced_topics/images/index.html)\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": null,
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": null,
    "keywords": null,
    "license": null,
    "maintainer": null,
    "maintainer_email": null,
    "name": "django_image_lite",
    "package_url": "https://pypi.org/project/django_image_lite/",
    "platform": null,
    "project_url": "https://pypi.org/project/django_image_lite/",
    "project_urls": {
      "Documentation": "https://github.com/rcrowther/django-image-lite"
    },
    "release_url": "https://pypi.org/project/django_image_lite/1.4.0/",
    "requires_dist": [
      "pillow"
    ],
    "requires_python": null,
    "summary": "Local image handling for Django. Unobtusive, with multiple repositories, powerful filter system and scaleable data.",
    "version": "1.4.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16757697,
  "urls": [
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "0f88cf7943a6b21e3ec5043f6282d2f094ac6d2d6f580394cc28cb4e06255e28",
        "md5": "5e434028b10f679b0c0e1fa987169423",
        "sha256": "f6d6b68b7f4ae05123518daf051ab00de2225930613d7784046ac4c108e46f86"
      },
      "downloads": -1,
      "filename": "django_image_lite-1.4.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "5e434028b10f679b0c0e1fa987169423",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 53441,
      "upload_time": "2023-01-24T07:36:08",
      "upload_time_iso_8601": "2023-01-24T07:36:08.149311Z",
      "url": "https://files.pythonhosted.org/packages/0f/88/cf7943a6b21e3ec5043f6282d2f094ac6d2d6f580394cc28cb4e06255e28/django_image_lite-1.4.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "c7b127a1ff48b13bb0dc0ad4acb28f7a5aeb8bf42dcbed1d9a1d5bd57813cb6d",
        "md5": "26c2a1eef694d40fe19fa6fa2644a86c",
        "sha256": "c95bf4d4262db9e083030f7635a4d7faf9fc5f8ce7fd79fbf73a6baa14f69357"
      },
      "downloads": -1,
      "filename": "django_image_lite-1.4.0.tar.gz",
      "has_sig": false,
      "md5_digest": "26c2a1eef694d40fe19fa6fa2644a86c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 49981,
      "upload_time": "2023-01-24T07:36:11",
      "upload_time_iso_8601": "2023-01-24T07:36:11.327537Z",
      "url": "https://files.pythonhosted.org/packages/c7/b1/27a1ff48b13bb0dc0ad4acb28f7a5aeb8bf42dcbed1d9a1d5bd57813cb6d/django_image_lite-1.4.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}