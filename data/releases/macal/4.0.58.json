{
  "info": {
    "author": "",
    "author_email": "Marco Caspers <marco.caspers@westcon.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# macal\n\n[![PyPI - Version](https://img.shields.io/pypi/v/macal.svg)](https://pypi.org/project/macal)\n[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/macal.svg)](https://pypi.org/project/macal)\n\n-----\n\n**Table of Contents**\n\n- [Installation](#Installation)\n- [License](#License)\n- [About](#About)\n- [Howto](#Howto)\n- [Variables](#Variables)\n- [Strings](#Strings)\n- [Libraries](#Libraries)\n- [Creating variables](#Creating)\n- [If, elif, else](#If)\n- [Functions](#Functions)\n- [Foreach](#Foreach)\n- [Select](#Select)\n- [Break](#Break)\n- [Halt](#Halt)\n- [Continue](#Continue)\n- [Csv Library](#CsvLibrary)\n- [Io Library](#IoLibrary)\n- [Math Library](#MathLibrary)\n- [Strings library](#strings-library)\n- [Syslog Library](#Syslog-library)\n- [System Library](#System-library)\n- [Time Library](#Time-library)\n- [Creating an addon library](#Creating-an-addon-library)\n\n## Installation\n\n\n```console\npip install macal\n```\n\n\n## License\n\n\n`macal` is distributed under the terms of the [MIT](https://spdx.org/licenses/MIT.html) license.\n\n\n\n## About\n\n\nMacal is a special purpose scripting language for Python.\nIt's main function is to read, transform and output data using an SQL like SELECT statement.\nThere are only a few instructions in the instruction set, but the language does support functions \nand 'libraries' so it can be extended.\nIn fact some basic 'libraries' are included in the package.\n\nFor those wondering where the name came from: Macal is the name of a river in Belize.\nMacal is about controlling the flow in \"the river of data\".\n\nThe following chapters will contain code examples.\nIt will only show the code examples, the output is not provided in this document, although it is described sometimes.\nMacal comes with its own \"test\" utility, that is pretty much the code in the Howto chapter.\nThe test utility will run the code in .mcl files that are also provided.\nThe format of the file name of these files is: test<number>.mcl\nYou can run a test as follows:\n\n```console\npython3 test.py <number>\n```\n\n\n## Howto\n\n\nThe following code is needed to use macal in a project:\n\n```console\nimport macal\n\nlang = macal.Macal()\ntry:\n\tlang.run_from_file(\"./test2.mcl\"); # loads the file and executes it.\n\t# alternatively you can use: lang.run_from_string('just put the code here');\n\t# Run_from_file uses this after having loaded the file.\nexcept macal.LexError as ex:\n\tprint(ex)\nexcept macal.SyntaxError as ex:\n\tprint(ex)\nexcept macal.RuntimeError as ex:\n\tprint(ex)\n```\n\n\n## Libraries\n\n\nThere are several libraries included in the macal package.\n\n- csv\n- io\n- math\n- strings\n- syslog\n- system\n- time\n\nTo use a library it needs to be included in the source:\n\n```console\ninclude system;\n\nconsole(\"Hello World!\");\n```\n\nInclude can have multiple libraries separated by comma's.\n\n\n\n## Variables\n\n\nA variable is a 'container' for data values.\nVariables can have a type, but this is an inferred type. It is not explicitly defined in code\n\nThe following data types are recognized:\n- string\n- integer\n- float (this is actually a double)\n- boolean\n- nil\n- array\n- record\n- function\n- params\n- variable\n\nA variable consists of a name and a value. Before you can use a variable you have to assign a value to it.\n\n```console\ninclude system;\n\nvar1 = 42;\nvar2 = 3.14;\nvar3 = \"Hello World!\";\nvar4 = true;\nvar5 = nil;\nvar6 = array;\nvar7 = record;\n\nconsole($\"{}, {}, {}, {}, {}, {}, {}\", var1, var2, var3, var4, var5, var6, var7);\n```\n\nThis will show the value of each variable on a single line, where variables 6 and 7 an \nempty array and record depicted by [] and {} respectively.\n\nnil is special here because it is both a type and a value.\narray and record are special because they are types as well as initializers.\n\nThe function type is assigned to a variable that is assigned a function.\n\n```console\ninclude system;\n\nparamtest => () {\n\tconsole(\"test\");\n}\nvar = paramtest;\nconsole(type(var));\n```\n\nThe above example will display FUNCTION because that is the type of the value of the variable var.\nIn this example you could also pass the function paramtest itself as an argument to the type function with the same result.\n\nParams is special as it is both a type and a keyword.\nAs a keyword it is used in a function definition to indicate that an argument is to be considered a params type argument.\nWith this set, all arguments provided in a call to this function will be put into the params argument as if it was an array.\n\n```console\ninclude system, math;\n\nparamtest => (params val) {\n\tconsole(type(val));\n\tforeach val {\n\t\tconsole(it);\n\t}\n}\nparamtest(PI, 'PI');\n```\n\nThe above example will display PARAMS wich is the type of the argument val, followed by the value of the system variable PI as well as the string 'PI'.\nA params argument has to be the first and only argument in a function definition.\n\nVariable like params is also both a type and a keyword and used in a function definition.\nThis makes that the argument that is passed into the function call is required to be a variable. You can't pass any literals like a string or an integer.\nYou can of course pass a variable that is a string or an integer.\n\nExample:\n\n```console\ninclude system, math;\n\nvartest => (variable var) {\n\tconsole(type(var));\n}\n\nvartest(PI);\nvartest('PI');\n```\nIn the example above, the first call to vartest will display VARIABLE, which is the type of the argument.\nGetting the value of the variable that was passed as an argument requires however the use of a the special function getValue(variable)\nGetting the type of the value of the variable that was passed as an argument requires the use of the special function getType(variable)\n\n\n\n## Strings\n\n\nA string is a literal value containing text.\nWhen assigning a string it can span over multiple lines, however, any new line also inserts the new line character in the string.\n\nExample:\n\n```console\ninclude system;\n\nstr = \"This is a string\nMulti line\nstring.\";\n\nconsole(str);\n```\n\nThis example will show 3 lines of text:\n```console\nThis is a string\nMulti line\nstring.\n```\n\nConcatenation of strings is handled by the + operator.\n\nExample:\n```console\ninclude system;\n\nstr_a = \"string a \";\nstr_b = \"string b\";\n\nvar = str_a + str_b;\nconsole(var)\n```\n\nThis will display a single string.\n\nWhile variables of various types can be converted to a string with the to_string(var) function \nfrom the strings library, there is a more powerfull way to put values of variables into strings.\n\nThis is string interpolation.\n\nAn example is:\n\n```console\na=1;\nb=2;\n\nstr= $\"{b} = {a} * 2\";\n```\n\nThe value of the variables a and b will be put into string str.\nMacal also supports function calls and expressions inside the curley brackets ({}).\n\n\n\n## Creating Variables\n\n\nThere is no specific command to declare a variable.\nA variable is created when a value is assigned to it.\n\n```console\ninclude system;\n\nx = 42;\ny = 1.1;\nhello = \"Hello World\";\ntest = true;\nundefined = nil;\ndata = array;\ndata[] = 10;\ndata[] = 1.1;\nmoredata = record;\nmoredata[\"test\"] = 1;\nmoredata[\"hitchhikers\"] = \"guidetothegalaxy\";\n\n// Display the values:\nconsole(x, \" \", y);\nconsole(hello);\nconsole(test);\nconsole(undefined);\nconsole(data[0], \" : \", data[1]);\nconsole(moredata[\"test\"]);\nconsole(moredata[\"hitchhikers\"]);\n```\n\n\n\n## If, elif, else\n\n\nIf and elif are conditional branching statements.\nElse is the final branch taken if previous conditions are not met.\n\nThe if statement can be used on it's own, or followed by one or more elif statements, \nand finally followed by an optional else statement.\n\nThe conditions can be made from logical mathematical equasions like == for equals, != for not equal, > for greater than etc.\n\nIt is not required to enclose the condition with brackets ().\nIf you are mixing mathematical equasions and boolean equasons then you should use brackets.\nFor example with \"(a == 1) and (b == 2)\". \nIf you don't supply brackets there, the equivalent of this gets processed: \"a == (1 and b) == 2\", which is something completely different.\n\n```console\na = 1;\n\nif a == 1 {\n\tconsole(\"Hello World!\");\t\n}\nelif a == 2 {\n\tconsole(\"Change a = 1 to 2 to be able to see this message.\");\n}\nelse {\n\tconsole(\"This should show up only if a is not 1 or 2.\");\n}\n```\n\n\n\n## Functions\n\n\nFunctions are \"first class\" in Macal. Which means you can assign functions to variables, and functions can be returned from functions.\nFunctions can also be passed in as arguments to other functions.\n\nFunction arguments are of \"type\" any, which means you can pass anything you want into a function parameter.\nIf your code relies on parameters being a certain type, you should test that.\nThe System library has several \"isXXX\" functions that you can use to determine the type of the variable/parameter that you pass in.\n\nThe resulting value that is returned by the function using the return statement will have the type specific to the value that is provided after the return statement.\n\n\n```console\nprint => (arg) {\n    c = arg();\n    return c; \n}\n\nfourty_two => () {\n  return 42;\n}\n\nresult = print(fourty_two);\nconsole(result);\n```\n\nAbove example shows a two functions being defined (print and forty_two) and then one function is passed as a parameter to the other function.\nFinally the result is displayed: 42.\n\nIt is not required to provide a value in the return statement.\n\n```console\ndef => (){\n\ta = 1;\n\tif a == 1 {\n\t\tconsole(\"a is 1.\");\n\t\treturn;\n\t}\n\tconsole(\"a was not 1\");\n}\n\ndef();\n```\n\nThe result of return in the above example is that the function will stop execution.\nThe console statement after return is never reached.\n\n\nThere are two special keywords that can change the way that Macal processes arguments passed into a function.\n\nThe first is the params keyword.\nConsider the function definition:  fncname => (param1, param2, param3) {...}\n\nThis function fncname has 3 arguments, param1, param2 and param3.\nThese arguments can be used inside the function as if they were variables.\nWhen this function is called, 3 arguments are required to be provided.\n\nHowever for some functions, like a print function, need the ability to have a dynamic amount of arguments.\nThe params keyword helps with this.\n\nThe definition for the function fncname with params becomes:\nfncname => (params args) {...}\n\nThe function can still be called with 3 arguments: fncname(param1, param2, param3);\n\nHowever, now inside the code block of the function definition the arguments aren't accessed individually anymore.\nTheir values are consolidated in the args argument which acts like an array of arguments.\nPlease note that it's perfectly legal that zero arguments are passed into such a function.\nWith the len function from the strings library the number of arguments in the args argument can be retrieved.\n\nThe second special keyword is variable.\nFor a normal function definition any type of variable, literal or function can be passed into the function arguments.\n\nWith the variable keyword the type of the argument always has to be a variable or a function.\nExamples for these are given in the variables chapter.\n\n\n\n## Foreach\n\n\nForeach is an iterative statement, which means it will iterate over a record, an array or even a string and it will \nrepeat it's block of statements as many times as there are \"items\".\n\nIt's only parameter is the object that it will iterate over. Within it's scope there is a variable called 'it' that contains the current 'item' value.\n\nThe following code will populate a variable in a array/record structure and is used as the base for other examples in this chapter and the next.\n\n```console\ninclude system;\n\nvar  = array;\nvar[] = record;\nvar[] = record;\nvar[] = record;\nvar[] = record;\nvar[0][\"id\"] = 1;\nvar[1][\"id\"] = 2;\nvar[2][\"id\"] = 3;\nvar[3][\"id\"] = 4;\nvar[0][\"title\"] = \"The Hobbit\";\nvar[1][\"title\"] = \"Foundation\";\nvar[2][\"title\"] = \"The Hitch Hikers Guide to the Galaxy\";\nvar[3][\"title\"] = \"The Lord of The Rings\";\nvar[0][\"author\"] = \"J.R.R. Tolkien\";\nvar[1][\"author\"] = \"Isaac Asimov\";\nvar[2][\"author\"] = \"Douglas Adams\";\nvar[3][\"author\"] = \"J.R.R. Tolkien\";\n```\n\nUsing the above code to populate the variable, lets see some examples of foreach:\n\n```console\n\nforeach var {\n\tconsole(it)\n}\n\n```\nThis will iterate over the records in var and output them on the console.\n\nWhen iterating over a record, the 'it' variable will contain the key index of the record.\nThis is much like Python's for .. in dict construction.\n\n\n```console\n\nforeach var[1] {\n\tconsole($\"'{}' : {}\", it, var[1][it]);\n}\n```\n\nThis will display the items of the 2nd record in the array.\nIt is the equivalent of this:\n\n```console\n\nforeach keys(var[1]) {\n\tconsole($\"'{}' : {}\", it, var[1][it]);\n}\n```\nIn the above example you explicitly extract the keys of the record into an array and iterate over that resulting array.\n\n\nThe following example is testing to iterate over a string.\n```console\nforeach \"Runtime\" {\n\tconsole(it);\n}\n```\nAs you can see you can pass the string as a literal instead of having it in a variable.\n\n\nThe next example shows you that you can also use functions that return a value as an operand for foreach:\n\n```console\ntest => () {\n\treturn \"test\";\n}\n\nforeach test() {\n\tconsole(it);\n}\n```\n\nWhen you are iterating over a record, you can need to have both the key as well as the value of each item in the record.\nYou can do this with the special function items() that is in the system library, combined with the special functions key and value.\n\n```console\nforeach items(var[2]) {\n\tconsole($\"Key: {}, Value: {}\", key(it), value(it));\n}\n```\n\nThe items function returns the record as an array of key/value pairs.\nWith the key function you get the key part and with the value function you get the value part of that key/value pair.\n\n\n\n## Select\n\n\nThe select statement lies at the core of the Macal language.\nIt can be used to retrieve data from a data source much like an SQL statement would in a database.\nThe difference with SQL is that Macal's select statement has variables and functions as data source \ninstead of just the database.\n\n\nIt is possible to write a function/library that allows retrieving data from a database and use that function in this select statement as a data source.\nAn example of how to write a simple library is provided in another chapter.\n\nThe output of the select statement is either a record or an array of records.\n\nThe way to ensure that the output is always a record is to use the distinct keyword after select.\nWhere a normal select statement would return an array of records, with distinct only the fist record is returned.\n\nTo select all fields the * symbol is used.\nTo select individual fields (keys in a record), use the name of that field.\nFor multiple fields use a comma to separate them.\nThe name of the field in the resulting record can be changed by using the as keyword.\n\nTo filter data based on a specific condition use the where keyword.\n\nThe variable name after the into keyword indicates into which variable the result of the select statement is stored.\n\nBelow are the examples of using the select statement.\nThe examples all use the same starting template as mentioned in the previous chapter.\n\n```console\nselect * from var into y;\n\nforeach y {\n\tconsole(it);\n}\n```\n\nThe above is the most simple form of the select statement and would be equivalent to: y = var.\n\nA more advanced and interresting form is the following:\n\n```console\nselect author as Author, title as Title from var where author == 'J.R.R. Tolkien' into y;\n\nforeach y {\n\tconsole(it);\n}\n```\n\nThe above select statement selects the author and title fields of the record and renames them with a capital letter first.\nIt will also filter the result to only contain those records for which the value of the author field is J.R.R. Tolkien.\n\n\n```console\nselect distinct author as Author, title as Title from var where author == 'J.R.R. Tolkien' into y;\nconsole(y);\n```\n\nWith the distinct method the output is limited to just a record.\nIn the previous example you see that the output of the query without distinct is a list of 2 records.\nIn this example only the first record will be returned.\n\nIt is possible to combine the results of multiple select statements together by using the merge keyword.\n\n```console\nselect distinct author as Author, title as Title from var where author == 'J.R.R. Tolkien' into y;\nselect distinct author as Author, title as Title from var where author == 'Douglas Adams' merge into y;\n\nforeach y {\n\tconsole(it);\n}\n```\n\nThis will result in y containing an array of 2 records, one from each of the two select statements.\n\nPlease note that merge ensures a record is added.\nConsider this example:\n\n```console\nselect distinct author as Author, title as Title from var where author == 'J.R.R. Tolkien' into y;\nselect distinct author as Author, title as Title from var where author == 'Douglas Adam' merge into y;\n```\n\nNotice that the second select has an error in the author's name.\nThis would result in the record from the first select and an empty record where the field values are nil.\n\n\nThe same is true for fields.\nIf you provide a list of fields in the select statement, the resulting record(s) will always have all of those fields.\nEven so, if the fields don't actually exist in the data source. The value of non existing fields that are returned is nil.\n\n\n\n## Break\n\n\nBreak is used to stop the execution of a foreach loop.\n\nThe following example uses the same setup code as the ones in the foreach chapter.\n\n```console\nforeach var {\n\tconsole(it[\"title\"]);\n\tbreak;\n\tconsole(\"this doesnâ€™t show\");\n}\n\n```\n\nThe text \"this doesn't show\" is not displayed. Also only 1 title is shown.\n\nThe break statement is usually combined with a condition.\n\n```console\nforeach var {\n\tconsole(it[\"title\"]);\n\tif it[\"title\"] == \"Foundation\" {\n\t\tbreak;\n\t}\n\tconsole(\"this only shows once\");\n}\nconsole(\"This line will show.\")\n```\n\nThe above example would result in two book titles being displayed, separated by the line \"this only shows once.\"\nThe line \"This line will show\" will be displayed because break doesn't stop the application from running, it only stops the loop.\n\n\n\n## Halt\n\n\nThe halt statement is used to stop execution of the application.\nUnlike the break statement that only stops a loop, halt stops everything.\nAlso halt requires an integer value as an argument.\nThis is to set the 'exit' variable of the application to a value other than it's default value.\n\n```console\nvar = \"a\";\nif var == \"a\" {\n\tconsole(\"This is shown.\");\n\thalt 1;\n\tconsole(\"This does not show.\");\n}\nconsole(\"This also is not shown.\");\n```\n\nIn above example the only text that is displayed is \"This is shown.\"\nThe rest is not shown as the application is terminated at the halt instruction, setting the exit variable (on the root scope) to 1.\n\n\n\n## Continue\n\n\nThe continue statement is used in a loop to skip the rest of the loop block and continue with the next iteration.\n\nAn example:\n\n```console\nlst = list('item 1', 'item 2', 'item 3', false, 'item 4', 'item 5');\n\nforeach lst {\n\tif it == false { continue; }\n\tconsole(it);\n}\n```\n\nThe above example will show all elements in the array, with the exception of the element that has false as value.\n\n\n\n\n## Csv library\n\n\nheadersToCsv(record)\n\nReturns the keys of the record (records are key/value pairs) as a CSV string.\n\nvalueToCsv(record)\n\nReturns the values of the record as a CSV string.\n\narrayToCsv(array)\n\nReturns the element values of the array as a CSV string.\n\n\n\n## Io library\n\n\nload(filename)\n\nLoads a text file returns it as a string.\n\n\nReadJSON(filename)\n\nReads a JSON file and returns it as the apropriate type (record/array).\n\n\nexists(filename)\n\nReturns true if the file/path exists, otherwise false.\n\n\nsave(filename, content)\n\nSaves the content into the file.\nReturns true if successfull, otherwise raises RuntimeError.\n\n\nWriteJSON(filename, content)\n\nWrite the content into a json file.\nReturns true if successfull, otherwise raises RuntimeError.\n\n\nget_last_run(org_name, iso_now)\n\nChecks the /temp for a file (org_name) and loads it, returns the iso timestamp in that file.\nIf the file doesn't exist returns iso_now\nThis is handy when you deal with data that collects over time (a log file for example) so you \nknow from which point on you have to start processing.\n\n\nset_last_run(org_name, iso_now)\n\nStores the iso_now timestamp into a file (org_name) in /temp\n\n\n## Math library\n\n\nThe math library contains functions and constants that are mathematical in origin.\n\nconstant: E \t\nconstant: PI\nconstant: TAU\n\nround(arg, digits)\n\nIf no digits are supplied:\nreturns arg rounded to the nearest integer (<.5 rounds down, >= .5 rounds up).\nIf digits are supplied:\nreturns arg rounded to the nearest float with digits number of digits.\n\nPlease note that the number of digits should fall within the range that a double can represent. Giving a larger number can give undesirable effects.\n\nceil(arg)\n\nreturns arg rounded up to the next whole number.\n\nfloor(arg)\n\nreturns arg rounded down to the next whole number.\n\ncos(x)\n\nreturns cosinus of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\nsin(x)\n\nreturns sinus of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\ntan(x)\n\nreturns tangent of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\nacos(x)\n\nreturns arc cosinus of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\nasin(x)\n\nreturns arc sinus of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\natan(x)\n\nreturns arc tangent of x where x is a numberic value between between -PI/2 and PI/2  radians.\n\npow(x, y)\n\nreturns x to the power of y.\n\nsqrt(x)\n\nreturns the square root of x.\n\nlog(x)\n\nreturns the natural logarithm of x.\n\nlog2(x)\n\nreturns the base 2 logarithm of x.\n\nlog10(x)\n\nreturns the base 10 logarithm of x.\n\nexp(x)\n\nreturns E raised to the power of x.\n\nexpm1(x)\n\nreturns E raised to the power of x minus 1.\nThis function is more accurate than calling exp(x) and subtracting 1.\n\n\n\n## Strings library\n\n\nlen(x)\n\nReturns the length of x, where x can be an array, a record or a string.\nFor an array it returns the number of elements. For a record it returns the number of key/value pairs.\nFor a string it returns the number of characters.\n\n\nleft(str, length)\n\nReturns the left length characters of the string.\n\n\nmid(str, start, length)\n\nReturns length characters from starting character start of the string.\n\n\ntostring(arg)\n\nConverts an integer or a float to a string.\n\n\nformat(format, arg)\n\nLike Python's format but unlike that it can only have a single arg value not multiple.\n\ncontains(needle, haystack)\n\nReturns true if needle is in haystack, otherwise false.\n\n\nreplace(var, from, with)\n\nReturns a string from the original with from replaced by with.\n\n\nstartswith(str, first)\n\nReturns true if the string starts with first, false if not.\n\n\nremoveNonAscii(str)\n\nRemoves all non-ascii characters from the string, but tries to replace these with ascii characters where possible.\n\n\nreplaceEx(var, repl, by)\n\nThe same as replace, but repl is an array of strings.\n\npadLeft(string, char, amount)\n\nreturns string padded on the left side with amount number of char.\n\npadRight(string, char, amount)\n\nreturns string padded on the right side with amount number of char.\n\n\n\n## Syslog library\n\n\n\nsyslog_init(remote)\n\nInitializes the syslog functionality. Remote indicates if the syslog server is supposed to be running on localhost or elsewhere.\n\nsyslog_set_address(address, port)\n\nSet the IP address/Host name and Port number for the syslog server if it is a remote server.\n\n\nsyslog(level, message)\n\nSends the message to the syslog server with the given level (debug, info, warn, error, critical)\n\n\n\n## System library\n\n\nconsole(params)\n\nOutputs given argument(s) to the console. Multiple arguments are separated by a comma.\nString interpolation is also supported, albeit that it's limited to substitution, it does not include formatting.\nBecause Macal has 2 string terminator types (' and \") it is possible to have a string interpolation inside a string interpolation.\n\nExample:\n\n\n```console\ninclude system;\n\na = 7;\nb = 6;\nc = 42;\n\nconsole($\"This example shows interpolation. {a}*{b}={c}.\");\n\n```\n\nlist(params)\n\nAlternate way to define an array. Returns an array of elements made of the arguments given to this function.\n\n```console\ninclude system;\n\nlst = list('item1'. 2, 'item3', 'the fourth item');\n\nconsole(lst);\n\n```\n\n\nrecord_has_field(record, fieldname)\n\nReturns true if the record has a key fieldname, otherwise returns false.\n\n\ntype(variable)\n\nReturns the variable type of var.\n\n\nisString(variable)\n\nReturns true if var is a string, false otherwise.\n\nisInt(variable)\n\nReturns true if var is an integer, false otherwise.\n\nisFloat(variable)\n\nReturns true if var is a float, false otherwise.\n\nisBool(variable)\n\nReturns true if var is a boolean, false otherwise.\n\nisArray(variable)\n\nReturns true if var is an array, false otherwise.\n\nisRecord(variable)\n\nReturns true if var is a record, false otherwise.\n\nisFunction(variable)\n\nReturns true if var is a function, false otherwise.\n\nisNil(variable)\n\nReturns true if var has a nil value, false otherwise.\n\nplatform()\n\nReturns the current platform the application is running on (Linux, Windows).\n\nShowVersion()\n\nPrints the version info, author and credits to the console.\n\nitems(record)\n\nReturns the items of the record as an array of key/value pairs.\nIs to be used in conjunction with key and value functions.\n\nkey(keyvalueitem)\n\nreturns the key of a key/value pair. Key/value pair aray is generated with the items function.\n\nvalue(keyvalueitem)\n\nreturns the value of a key/value pair. Key/value pair array is generated with the items function.\n\nkeys(record)\n\nreturns all the keys in the record as an array.\n\nvalues(record)\n\nreturns all the values in the record as an array.\n\ngetValue(variable)\n\nSpecial function only to be used in a function definition, only for getting the value of the variable that was passed into  variable argument.\n\ngetType(variable)\n\nSpecial function only to be used in a function definition, only for getting the type of a the value of the variable that was passed into the variable argument.\n\n\n\n## Time library\n\n\nutcnow()\n\nReturns the current utc date/time.\n\nutcisonow()\n\nReturns the current utc date/time in iso format.\n\nisonow()\n\nReturns the current local date/time in iso format.\n\n\nnow()\n\nReturns the current local date/time.\n\n\ndate_to_unix(date_str)\n\nReturns the unix representation (# of seconds) of the given date string.\n\n\niso_to_unix(isodate_str)\n\nReturns the unix representation of the given iso formatted date string.\n\n\ndate_from_unix(seconds)\n\nReturns a date string from the given unix representation.\n\niso_from_unix(secods)\n\nReturns an iso formatted date string from the given unix representation.\n\n\nperf_counter()\n\nReturns the value of the system performance counter.\nCan be used for a simple stopwatch.\n\n\n\n## Creating an addon Library\n\n\nCreating a new \"library\" is pretty much the same as creating a normal .mcl file.\nIn the below example a library test is implemented.\nIt consists of 2 files: demolib.mcl and demolib.py.\n\nTest.mcl contains the definition of the function print.\nThe external keyword is used to indicate that this function is implemented in an external python file, specifically in the function Print.\n\nThe actual implementation of the function is in the demolib.py python file in the function Print.\n\n\nFile: demolib.mcl\n```console\n\n/*\n Author: Marco Caspers\n \n The Demo library is a demonstration on how to create a library for macal.\n*/\n\nDEMOCONST = 'The Demo constant.';\n\nprint => (text) external \"demolib\", \"Print\";\n\n```\n\nFile: demolib.py\n```console\n\n# demolib\n# Author: Marco Caspers\n# Demo Library implementation\n\nimport macal\n\n\ndef Print(func: macal.MacalFunction, name: str, params: list, scope: macal.MacalScope):\n\t\"\"\"Implementation of print function for demolib.\"\"\"\n\tmacal.ValidateFunction(name, func, scope)\n\tmacal.ValidateParams(name=name, params=params, scope=scope, func=func, allow_literal=True)\n\ttext  = macal.GetParamValue(params=params, name=\"text\")\n\tttext = macal.GetParamType(params=params, name=\"text\")\n\tprint(f\"The value of the argument is: {text}\")\n\tprint(f\"The Type of the argument is: {ttext}\")\n\tscope.SetReturnValue(True, macal.VariableTypes.BOOL)\n\n```\n\nAny function that is callable from a macal library via external has to conform to the interface as shown above.\n\nThe ValidateFunction is not strictly needed, but what it does is validate the name of the function that is defined in \nthe .mcl script against the name that the interpreter has determined to have been called.\n\nThe ValidateParams function is also not required, but recommended.\nThis function validates the number of arguments provided and the \"type\" of their values.\nIf the function requires that literals are to be passed as an argument then the allow_literal flag has to be set to true.\nIf not provided the default is false, which would cause a runtime error to be thrown when a literal was encountered.\n\nGetParamValue retrieves the value of the argument that was provided. The name of the argument as defined in the macal function has to be provided.\nGetParamType retrieves the type of the value of the argument that was provided.\n\nSetReturnValue sets the return value of the function to the specified value and type.\nThe following variable types are recognized:\n\tANY\n\tARRAY\n\tBOOL\n\tFLOAT\n\tFUNCTION\n\tINT\n\tNIL\n\tPARAMS\n\tRECORD\n\tSTRING\n\tVARIABLE\n\nWhile VariableTypes.ANY and VariableTypes.PARAMS are valid types they can't be used as a return type.\nSetting any of these types will result in a runtime error.\n\nPlease note that when setting VariableTypes.NIL as the return type, the value that needs to be provided is also NIL.\n(scope.SetReturnValue(NIL, macal.VariableTypes.NIL))\nNIL is a constant representing the nil or null value as defined in other programming languages.\n\nThe following demo shows how to use the demo library in code:\n\n```console\n/*\n\nAuthor: Marco Caspers\nThis demo shows how to use the demolib library.\n\n*/\n\ninclude demolib;\n\nvar = print(DEMOCONST);\nprint(\"A literal string.\");\nprint(var);\n\n```\n\nNotice that the constant and the literal string will both have the type string.\nWhile seemingly the same, if you would set allow_literal to False in the python code, a runtime error would be raised as internally Macal can recognize the difference between the two.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "macal",
    "package_url": "https://pypi.org/project/macal/",
    "platform": null,
    "project_url": "https://pypi.org/project/macal/",
    "project_urls": {
      "Homepage": "https://github.com/Sama-Developer/macal"
    },
    "release_url": "https://pypi.org/project/macal/4.0.58/",
    "requires_dist": [
      "unidecode"
    ],
    "requires_python": ">=3.8",
    "summary": "A proprietary scripting language",
    "version": "4.0.58",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17194842,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "368dafcdb6114b9032c80c217b058679f8fd8b63a1b684fe2bc5d1d0cc7d9f70",
        "md5": "57ea30e743c0890bd6e280bd78581afa",
        "sha256": "cf74868bc92b160137287d6f749b0a51582db53c5043165fd77a403c8fc36896"
      },
      "downloads": -1,
      "filename": "macal-4.0.58-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "57ea30e743c0890bd6e280bd78581afa",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 68432,
      "upload_time": "2022-10-16T00:19:31",
      "upload_time_iso_8601": "2022-10-16T00:19:31.940131Z",
      "url": "https://files.pythonhosted.org/packages/36/8d/afcdb6114b9032c80c217b058679f8fd8b63a1b684fe2bc5d1d0cc7d9f70/macal-4.0.58-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c329c7a0a8edb3cff83db82379704fe27453222bd749675ac0c48b7a6492250f",
        "md5": "e9e01a19306e03f9eb0319738753ae11",
        "sha256": "0ee71ccf3e7dcd273da29427ba09f62bed843530f31cd64c0ecc58b66547f64a"
      },
      "downloads": -1,
      "filename": "macal-4.0.58.tar.gz",
      "has_sig": false,
      "md5_digest": "e9e01a19306e03f9eb0319738753ae11",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 60964,
      "upload_time": "2022-10-16T00:19:33",
      "upload_time_iso_8601": "2022-10-16T00:19:33.810746Z",
      "url": "https://files.pythonhosted.org/packages/c3/29/c7a0a8edb3cff83db82379704fe27453222bd749675ac0c48b7a6492250f/macal-4.0.58.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}