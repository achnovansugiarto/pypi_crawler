{
  "info": {
    "author": "Chris McDonough",
    "author_email": "chrism@plope.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Intended Audience :: Developers",
      "Operating System :: POSIX",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.5",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.2",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Topic :: Text Processing :: Markup :: HTML"
    ],
    "description": "meld3\n\nOverview\n\n  meld3 is an HTML/XML templating system for Python 2.3+ which keeps\n  template markup and dynamic rendering logic separate from one\n  another.  See http://www.entrian.com/PyMeld for a treatise on the\n  benefits of this pattern.\n\n  meld3 can deal with HTML or XML/XHTML input and can output\n  well-formed HTML or XML/XHTML.\n\n  meld3 is a variation of Paul Winkler's Meld2, which is itself a\n  variation of Richie Hindle's PyMeld.\n\n  meld3 uses Frederik Lundh's ElementTree library.\n\nRequirements\n\n  On Python 3, meld3 requires Python 3.2 or later.\n\n  On Python 2, meld3 requires Python 2.5 or later.\n\nInstallation\n\n  Run 'python setup.py install'.\n\nDifferences from PyMeld\n\n  - Templates created for use under PyMeld will not work under meld3\n    due to differences in meld tag identification (meld3's id\n    attributes are in a nondefault XML namespace, PyMeld's are not).\n    Rationale: it should be possible to look at a template and have a\n    good shot at figuring out which pieces of it might get replaced\n    with dynamic content.  XML ids are required for other things like\n    CSS styles, so you can't assume if you see an XML id in a template\n    that it was put in there to be a meld identifier.  In the worst\n    case scenario, if XML ids were used instead of namespaced id's,\n    and an unused id was present in the source document, the designer\n    would leave it in there even if he wasn't using it because he\n    would think it was a meld id and the programmer would leave it in\n    there even if he wasn't using it because he would think it was\n    being used by the designer's stylesheets.  Menawhile, nobody's\n    actually using it and it's just cluttering up the template.  Also,\n    having a separate namespace helps the programmer not stomp on the\n    designer by changing identifiers (or needing to grep stylesheets),\n    and lets them avoid fighting over what to call elements.\n\n  - The \"id\" attribute used to mark up is in the a separate namespace\n    (aka. xmlns=\"http://www.plope.com/software/meld3\").  So instead of\n    marking up a tag like this: '<div id=\"thediv\"></div>', meld3\n    requires that you qualify the \"id\" attribute with a \"meld\"\n    namespace element, like this: '<div meld:id=\"thediv\"></div>'.  As\n    per the XML namespace specification, the \"meld\" name is completely\n    optional, and must only represent the\n    \"http://www.plope.com/software/meld3\" namespace identifier, so\n    '<div xmlns:foo=\"http://www.plope.com/software/meld3\"\n    foo:id=\"thediv\"/>' is just as valid as as '<div\n    meld:id=\"thediv\"/>'\n\n  - Output documents by default do not include any meld3 namespace id\n    attributes.  If you wish to preserve meld3 ids (for instance, in\n    order to do pipelining of meld3 templates), you can preserve meld\n    ids by passing a \"pipeline\" option to a \"write\" function\n    (e.g. write_xml, wwrite_xhtml).\n\n  - Output can be performed in \"XML mode\", \"XHTML mode\" and \"HTML\n    mode\".  HTML output follows recommendations for HTML 4.01, while\n    XML and XHTML output outputs valid XML If you create an empty\n    textarea element and output it in XML and XHTML mode the output\n    will be rendered <'textarea/>'.  In HTML mode, it will be rendered\n    as '<textarea></textarea>'.  In HTML mode, various other tags like\n    'img' aren't \"balanced\" with an ending tag, and so forth.  You can\n    decide how you wish to render your templates by passing an 'html'\n    flag to the meld 'writer'.\n\n  - meld3 elements are instances of ElementTree elements and support\n    the \"ElementTree _ElementInterface\n    API\":http://effbot.org/zone/pythondoc-elementtree-ElementTree.htm#elementtree.ElementTree._ElementInterface-class)\n    instead of the PyMeld node API.  The ElementTree _ElementInterface\n    API has been extended by meld3 to perform various functions\n    specific to meld3.\n\n  - meld3 elements do not support the __mod__ method with a sequence\n    argument; they do support the __mod__ method with a dictionary\n    argument, however.\n\n  - meld3 elements support various ZPT-alike methods like \"repeat\",\n    \"content\", \"attributes\", and \"replace\" that are meant to work like\n    their ZPT counterparts.\n\nExamples\n\n  A valid example meld3 template is as\n  follows::\n\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\"\n          xmlns:meld=\"http://www.plope.com/software/meld3\"\n          xmlns:bar=\"http://foo/bar\">\n      <head>\n        <meta content=\"text/html; charset=ISO-8859-1\" http-equiv=\"content-type\" />\n        <title meld:id=\"title\">This is the title</title>\n      </head> \n      <body>\n        <div/> <!-- empty tag -->\n        <div meld:id=\"content_well\">\n          <form meld:id=\"form1\" action=\".\" method=\"POST\">\n          <table border=\"0\" meld:id=\"table1\">\n            <tbody meld:id=\"tbody\">\n              <tr>\n                <th>Name</th>\n                <th>Description</th>\n              </tr>\n              <tr meld:id=\"tr\" class=\"foo\">\n                <td meld:id=\"td1\">Name</td>\n                <td meld:id=\"td2\">Description</td>\n              </tr>\n            </tbody>\n          </table>\n          <input type=\"submit\" name=\"next\" value=\" Next \"/>\n          </form>\n        </div>\n      </body>\n    </html>\n\n  Note that the script contains no logic, only \"meld:id\" identifiers.\n  All \"meld:id\" identifiers in a single document must be unique for a\n  meld template to be parseable.\n\n  A script which parses the above template and does some\n  transformations is below.  Consider the variable \"xml\" below bound\n  to a string representing the XHTML above::\n\n    from meld3 import parse_xmlstring\n    from meld3 import parse_htmlstring\n    from StringIO import StringIO\n    import sys\n\n    root = parse_xmlstring(xml)\n    root.findmeld('title').content('My document')\n    root.findmeld('form1').attributes(action='./handler')\n    data = (\n        {'name':'Boys',\n         'description':'Ugly'},\n        {'name':'Girls',\n         'description':'Pretty'},\n        )\n    iterator = root.findmeld('tr').repeat(data)\n    for element, item in iterator:\n        element.findmeld('td1').content(item['name'])\n        element.findmeld('td2').content(item['description'])\n\n  You used the \"parse_xmlstring\" function to transform the XML into a\n  tree of nodes above.  This was possible because the input was\n  well-formed XML.  If it had not been, you would have needed to use\n  the \"parse_htmlstring\" function instead.\n\n  To output the result of the transformations to stdout as XML, we use\n  the 'write' method of any element.  Below, we use the root element\n  (consider it bound to the value of \"root\" in the above script)::\n\n    import sys\n    root.write_xml(sys.stdout)\n    ...\n    <?xml version=\"1.0\"?>\n    <html:html xmlns:html=\"http://www.w3.org/1999/xhtml\">\n      <html:head>\n        <html:meta content=\"text/html; charset=ISO-8859-1\" http-equiv=\"content-type\" />\n        <html:title>My document</html:title>\n      </html:head>\n      <html:body>\n        <html:div /> <!--  empty tag  -->\n        <html:div>\n          <html:form action=\"./handler\" method=\"POST\">\n          <html:table border=\"0\">\n            <html:tbody>\n              <html:tr>\n                <html:th>Name</html:th>\n                <html:th>Description</html:th>\n              </html:tr>\n              <html:tr class=\"foo\">\n                <html:td>Boys</html:td>\n                <html:td>Ugly</html:td>\n              </html:tr>\n            <html:tr class=\"foo\">\n                <html:td>Girls</html:td>\n                <html:td>Pretty</html:td>\n              </html:tr>\n            </html:tbody>\n          </html:table>\n          <html:input name=\"next\" type=\"submit\" value=\" Next \" />\n          </html:form>\n        </html:div>\n      </html:body>\n    </html:html>\n\n  We can also serialize our element tree as well-formed XHTML, which\n  is largely like rendering to XML except it by default doesn't emit\n  the XML declaration and it removes all \"html\" namespace declarations\n  from the output.  It also emits a XHTML 'loose' doctype declaration\n  near the top of the document::\n\n    import sys\n    root.write_xhtml(sys.stdout)\n    ...\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n    <html>\n      <head>\n        <meta content=\"text/html; charset=ISO-8859-1\" http-equiv=\"content-type\" />\n        <title>My document</title>\n      </head>\n      <body>\n        <div /> <!--  empty tag  -->\n        <div>\n          <form action=\"./handler\" method=\"POST\">\n          <table border=\"0\">\n            <tbody>\n              <tr>\n                <th>Name</th>\n                <th>Description</th>\n              </tr>\n              <tr class=\"foo\">\n                <td>Boys</td>\n                <td>Ugly</td>\n              </tr>\n            <tr class=\"foo\">\n                <td>Girls</td>\n                <td>Pretty</td>\n              </tr>\n            </tbody>\n          </table>\n          <input name=\"next\" type=\"submit\" value=\" Next \" />\n          </form>\n        </div>\n      </body>\n    </html>\n\n  We can also output text in HTML mode, This serializes the node and\n  its children to HTML (this feature was inspired by and based on code\n  Ian Bicking).  By default, the serialization will include a 'loose'\n  HTML DTD doctype (this can be overridden with the doctype=\n  argument).  \"Empty\" shortcut elements such as '<div/>' will be\n  converted to a balanced pair of tags e.g. '<div></div>'.  But some\n  HTML tags (defined as per the HTML 4 spec as area, base, basefont,\n  br, col, frame, hr, img, input, isindex, link, meta, param) will not\n  be followed with a balanced ending tag; only the beginning tag will\n  be output.  Additionally, \"boolean\" tag attributes will not be\n  followed with any value.  The \"boolean\" tags are selected, checked,\n  compact, declare, defer, disabled, ismap, multiple, nohref,\n  noresize, noshade, and nowrap.  So the XML input '<input\n  type=\"checkbox\" checked=\"checked\"/>' will be turned into '<input\n  type=\"checkbox\" checked>'.  Additionally, 'script' and 'style' tags\n  will not have their contents escaped (e.g. so \"&\" will not be turned\n  into '&amp;' when it's iside the textual content of a script or\n  style tag.)::\n\n    import sys\n    root.write_html(sys.stdout)\n    ...\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n    <html>\n      <head>\n        <meta content=\"text/html; charset=ISO-8859-1\" http-equiv=\"content-type\">\n        <title>My document</title>\n      </head>\n      <body>\n        <div></div> <!--  empty tag  -->\n        <div>\n          <form action=\"./handler\" method=\"POST\">\n          <table border=\"0\">\n            <tbody>\n              <tr>\n                <th>Name</th>\n                <th>Description</th>\n              </tr>\n              <tr class=\"foo\">\n                <td>Boys</td>\n                <td>Ugly</td>\n              </tr>\n            <tr class=\"foo\">\n                <td>Girls</td>\n                <td>Pretty</td>\n              </tr>\n            </tbody>\n          </table>\n          <input name=\"next\" type=\"submit\" value=\" Next \">\n          </form>\n        </div>\n      </body>\n    </html>\n\nElement API\n\n  meld3 elements support all of the \"ElementTree _ElementInterface\n  API\":http://effbot.org/zone/pythondoc-elementtree-ElementTree.htm#elementtree.ElementTree._ElementInterface-class\n  .  Other meld-specific methods of elements are as follows::\n\n    \"clone(parent=None)\": clones a node and all of its children via a\n    recursive copy.  If parent is passed in, append the clone to the\n    parent node.\n\n    \"findmeld(name, default=None)\": searches the this element and its\n    children for elements that have a 'meld:id' attribute that matches\n    \"name\"; if no element can be found, return the default.\n\n    \"meldid()\": Returns the \"meld id\" of the element or None if the element\n    has no meld id.\n\n    \"repeat(iterable, childname=None)\": repeats an element with values\n    from an iterable.  If 'childname' is not None, repeat the element on\n    which repeat was called, otherwise find the child element with a\n    'meld:id' matching 'childname' and repeat that.  The element is\n    repeated within its parent element.  This method returns an\n    iterable; the value of each iteration is a two-sequence in the form\n    (newelement, data).  'newelement' is a clone of the template element\n    (including clones of its children) which has already been seated in\n    its parent element in the template. 'data' is a value from the\n    passed in iterable.  Changing 'newelement' (typically based on\n    values from 'data') mutates the element \"in place\".\n\n    \"replace(text, structure=False)\": (ala ZPT's 'replace' comnand)\n    Replace this element in our parent with a 'Replace' node\n    representing the text 'text'.  Return the index of the index\n    position in our parent that was replaced.  If 'structure' is true,\n    at rendering time, the outputted text will not be escaped in the\n    serialization.  If we have no parent, do nothing, and return None.\n    This method leaves a special kind of node in the element tree (a\n    'Replace' node) to represent the replacement.  NOTE: This command\n    has the potential to cause a non-well-formed XML/HTML\n    serialization at render time if \"structure\" is True.\n\n    \"content(text, structure=False)\": (ala ZPT's 'content' command)\n    Delete every child element in this element and append a Replace\n    node that contains 'text'.  Always return None.  If 'structure' is\n    true, at rendering time, the outputted text will not be escaped in\n    the serialization.  If we have no parent, do nothing, and return\n    None.  NOTE: This command has the potential to cause a\n    non-well-formed XML/HTML serialization at render time if\n    \"structure\" is True.\n\n    \"attributes(**kw)\": (ala ZPT's 'attributes' command) For each key\n    value pair in the kw list, add an attribute to this node where the\n    attribute's name is 'key' and the attributes value is 'value'.\n    Keys and values must be string or unicode types, else a ValueError\n    is raised.  Returns None.\n\n    \"__mod__(other)\": Fill in the text values of meld nodes in this\n    element and children recursively; only support dictionarylike\n    \"other\" operand (sequence operand doesn't seem to make sense here).\n    \n    \"fillmelds(**kw)\":Fill in the text values of meld nodes in this\n    element and children recursively.  Return the names of keys in the\n    **kw dictionary that could not be found anywhere in the tree.  Never\n    raise an exception.\n\n    \"write_xml(file, encoding=None, doctype=None, fragment=False, \n    declaration=True, pipeline=False)\":\n    Write XML to 'file' (which can be a filename or filelike object)\n    encoding    -- encoding string (if None, 'utf-8' encoding is assumed)\n                   Must be a recognizable Python encoding type.\n    doctype     -- 3-tuple indicating name, pubid, system of doctype.\n                   The default is to prevent a doctype from being emitted.\n    fragment    -- True if a 'fragment' should be emitted for this node (no\n                   declaration, no doctype).  This causes both the\n                   'declaration' and 'doctype' parameters to become ignored\n                   if provided.\n    declaration -- emit an xml declaration header (including an encoding\n                   if it's not None).  The default is to emit the\n                   doctype.\n    pipeline    -- preserve 'meld' namespace identifiers in output\n                   for use in pipelining\n\n    \"write_xhtml(self, file, encoding=None, doctype=doctype.xhtml,\n    fragment=False, declaration=False, pipeline=False)\":\n    Write XHTML to 'file' (which can be a filename or filelike object)\n\n    encoding    -- encoding string (if None, 'utf-8' encoding is assumed)\n                   Must be a recognizable Python encoding type.\n    doctype     -- 3-tuple indicating name, pubid, system of doctype.\n                   The default is the value of doctype.xhtml (XHTML\n                   'loose').\n    fragment    -- True if a 'fragment' should be emitted for this node (no\n                   declaration, no doctype).  This causes both the\n                   'declaration' and 'doctype' parameters to be ignored.\n    declaration -- emit an xml declaration header (including an encoding\n                   string if 'encoding' is not None)\n    pipeline    -- preserve 'meld' namespace identifiers in output\n                   for use in pipelining\n\n    Note that despite the fact that you can tell meld which doctype to\n    serve, meld does no semantic or syntactical validation of\n    attributes or elements when serving content in XHTML mode; you as\n    a programmer are still responsible for ensuring that your\n    rendering does not include font tags, for instance.\n\n    Rationale for defaults: By default, 'write_xhtml' doesn't emit an\n    XML declaration because versions of IE before 7 apparently go into\n    \"quirks\" layout mode when they see an XML declaration, instead of\n    sniffing the DOCTYPE like they do when the xml declaration is not\n    present to determine the layout mode.  (see\n    http://hsivonen.iki.fi/doctype/ and\n    http://blogs.msdn.com/ie/archive/2005/09/15/467901.aspx).\n    'write_xhtml' emits a 'loose' XHTML doctype by default instead of\n    a 'strict' XHTML doctype because 'tidy' emits a 'loose' doctye by\n    default when you convert an HTML document into XHTML via\n    '-asxhtml', and I couldn't think of a good reason to contradict\n    that precedent.\n\n    A note about emitting the proper Content-Type header when serving\n    pages rendered with write_xhtml: you can sometimes use the\n    content-type 'application/xhtml+xml' (see\n    \"http://www.w3.org/TR/xhtml-media-types/#application-xhtml-xml\").\n    The official specification calls for this.  But not all browsers\n    support this content type (notably, no version of IE supports it,\n    nor apparently does Safari).  So these pages *may* be served using\n    the 'text/html' content type and most browsers will attempt to do\n    doctype sniffing to figure out if the document is actually XHTML.\n    It appears that you can use the Accepts header in the request to\n    figure out if the user agent accepts 'application/xhtml+xml' if\n    you're a stickler for correctness.  In practice, this seems like\n    the right thing to do.  See\n    \"http://keystonewebsites.com/articles/mime_type.php\" for more\n    information on serving up the correct content type header.\n\n    \"write_html(self, file, encoding=None, doctype=doctype.html,fragment=False)\":\n    Write HTML to 'file' (which can be a filename or filelike object)\n    encoding    -- encoding string (if None, 'utf-8' encoding is assumed).\n                   Unlike XML output, this is not used in a declaration,\n                   but it is used to do actual character encoding during\n                   output.  Must be a recognizable Python encoding type.\n    doctype     -- 3-tuple indicating name, pubid, system of doctype.\n                   The default is the value of doctype.html (HTML 4.0\n                   'loose')\n    fragment    -- True if a \"fragment\" should be omitted (no doctype).\n                   This overrides any provided \"doctype\" parameter if\n                   provided.\n    Namespace'd elements and attributes have their namespaces removed\n    during output when writing HTML, so pipelining cannot be performed.\n    HTML is not valid XML, so an XML declaration header is never emitted.\n\n    In general: For all output methods, comments are preserved in\n    output.  They are also present in the ElementTree node tree (as\n    Comment elements), so beware. Processing instructions (e.g. '<?xml\n    version=\"1.0\">') are completely thrown away at parse time and do\n    not exist anywhere in the element tree or in the output (use the\n    declaration= parameter to emit a declaration processing\n    instruction).\n\nParsing API\n\n  XML source text is turned into element trees using the\n  \"parse_xmlstring\" function (demonstrated in examples above).  A\n  function that accepts a filename or a filelike object instead of a\n  string, but which performs the same function is named \"parse_xml\",\n  e.g.::\n\n    from meld3 import parse_xml\n    from meld3 import parse_xmlstring\n\n  HTML source text is turned into element trees using the\n  \"parse_htmlstring\" function.  A function that accepts a filename or\n  a filelike object instead of a string, but which performs the same\n  function is named \"parse_html\", e.g.::\n\n    from meld3 import parse_html\n    from meld3 import parse_htmlstring\n\n  Using duplicate meld identifiers on separate elements in the source\n  document causes a ValueError to be raised at parse time.\n\n  When using parse_xml and parse_xmlstring, documents which contain\n  entity references (e.g. '&nbsp;') must have the entities defined in\n  the source document or must have a DOCTYPE declaration that allows\n  those entities to be resolved by the expat parser.\n\n  When using parse_xml and parse_xmlstring, input documents must\n  include the meld3 namespace declaration (conventionally on the root\n  element).  For example, '<html\n  xmlns:meld=\"http://www.plope.com/software/meld3\">...</html>'\n\n  parse_html and parse_htmlstring take an optional \"encoding\" argument\n  which specifies the document source encoding.\n\nTo Do\n\n  This implementation depends on classes internal to ElementTree and\n  hasn't been tested with cElementTree or lxml, and almost certainly\n  won't work with either due to this.\n\n  See TODO.txt for more to-do items.\n\n",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/supervisor/meld3",
    "keywords": null,
    "license": "BSD-derived (http://www.repoze.org/LICENSE.txt)",
    "maintainer": null,
    "maintainer_email": null,
    "name": "meld3",
    "package_url": "https://pypi.org/project/meld3/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/meld3/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/supervisor/meld3"
    },
    "release_url": "https://pypi.org/project/meld3/1.0.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "meld3 is an HTML/XML templating engine.",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 6980368,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "33fbd93e08f13aa96a9cd5e75178af45e3f11fb57a3addb3955dcd49472d8c9b",
        "md5": "ca270506dd4ecb20ae26fa72fbd9b0be",
        "sha256": "57b41eebbb5a82d4a928608962616442e239ec6d611fe6f46343e765e36f0b2b"
      },
      "downloads": -1,
      "filename": "meld3-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "ca270506dd4ecb20ae26fa72fbd9b0be",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 36232,
      "upload_time": "2014-04-10T20:11:51",
      "upload_time_iso_8601": "2014-04-10T20:11:51.795444Z",
      "url": "https://files.pythonhosted.org/packages/33/fb/d93e08f13aa96a9cd5e75178af45e3f11fb57a3addb3955dcd49472d8c9b/meld3-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}