{
  "info": {
    "author": "johnrm174",
    "author_email": "johnrm17418@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "# model-railway-signalling\nA model railway signalling library written in Python for the Raspberry Pi with a DCC control of Signals and Points and train \ndetection via the GPIO ports on the Pi. For details of the \"Public\" API - scroll down the page\n\nA simple interface to the Pi-SPROG-3 DCC Command station enables DCC control of the signals and points out on the layout. \nThe GPIO interface allows external train detectors such as the BlockSignalling BOD2-NS to be connected in via opto-isolators.\n\nAll of the functions for creating and managing 'signals', 'points', 'sections' and 'sensors' have been developed as a Python Package \nto promote re-use across other layouts. This includes functions to support the interlocking of signals and points to enable \nfully prototypical signalling schemes to be developed. The signals and points opjects can be easily mapped to one or more DCC \naddresses in a manner that should be compatible with the majority of DCC signal/points decoders currently on the market. \nTrack sensors can also be easily integrated (via the Raspberry Pi's GPIO interface) to enable full automatic control.\n\nMost types of colour light signals, semaphore signals, ground position light signals and ground disc signals are supported.\n\nNote that I have tried to make the package platform independent so you can use it to develop your own layout signalling schemes \nwithout a Raspberry Pi or the associated Pi-SPROG-3 DCC Command station (track sensors can be manually 'triggered' via the\nlayout schematic to ensure your code is doing what its supposed to do). Full logging is provided to help you develop/debug \nyour own schemes - just set the log level to INFO to see what the package is doing 'under the hood'. And when you do enable\nthe DCC control aspects, a log level of DEBUG will show you the commands being sent out to the Pi-SPROG-3\n\nComments and suggestions welcome - but please be kind - the last time I coded anything it was in Ada96 ;)\n\n![Example Screenshot](https://github.com/johnrm174/model-railway-signalling/blob/main/README_screenshot1.png)\n\n## Installation\nFor a first time installation use:\n<pre>\n$ python3 -m pip install model-railway-signals \n</pre>\nTo upgrade to the latest version use:\n<pre>\n$ python3 -m pip install --upgrade model-railway-signals \n</pre>\nYou may need to ensure you have the latest version of pip installed:\n<pre>\n$ python3 -m pip install --upgrade pip\n</pre>\n\n## Using the package\n\nTo use the \"public\" functions for developing your own layout signalling system:\n<code> from model_railway_signals import * </code>\n\nSome examples are included in the repository: https://github.com/johnrm174/model-railway-signalling:\n\n<pre>\n'test_simple_example.py' - a simple example of how to use the \"signals\" and \"points\" modules to create a\n           basic track schematic with interlocked signals/points. Also includes DCC Mapping examples\n           (signals and points) and external track sensors to provide \"signal passed\" events.\n\n'test_semaphore_example.py' - effectively the same example as above, but using sempahore signals. \n           Includes DCC Mapping examples for the Semaphore signals (different to colour lights).\n\n'test_approach_control.py' - an example of using automated \"approach control\" for junction signals. This \n           is where a signal displays a more restrictive aspect (either red or yellow) when a lower-speed \n           divergent route is set, forcing the approaching train to slow down and be prepared to stop. As \n           the train approaches, the signal is \"released\", allowing the train to proceed past the signal \n           and onto the divergent route. Examples of \"Approach on Red\" and \"Approach on Yellow\" are provided. \n           For \"Approach on yellow\", the signals behind will show the correct flashing yellow aspects.\n\n'test_semaphore_approach_control' - Similar to the above, but this simulates/automates the series of \n           signals within a block section (e.g. outer home, inner home, starter, advanced starter etc). \n           In this scenario, the distant and home signals should never be cleared for an approaching train \n           if a subsequent home signal (in the same 'Block Section') is set to DANGER. In this case each \n           preceding home signal (and the distant) would remain ON to slow down the train on the approach\n           to the first home signal. As the signal is approached, the signal would then be cleared to \n           enable the train to continue (at low speed) towards the next home signal.\n\n'test_harman-signalist_sc1.py'- developed primarily for testing using the Harmann Signallist SC1 decoder. \n           Enables the various modes to be selected (includes programming of CVs) and then tested. I used \n           this decoder as it provided the most flexibility for some of my more complex signal types.\n           Note that some of the modes will be similar/identical to other manufacturer's DCC signals.\n\n'test_colour_light_signals.py'- developed primarily for testing, but it does provide an example of every \n           signal type and all the control features currently supported.\n\n'test_semaphore_signals.py'- similar to the above developed primarily for testing, but it does provide  \n           an example of every signal type and all the control features currently supported.\n\n</pre>\n\nOr alternatively, go to https://github.com/johnrm174/layout-signalling-scheme to see the scheme for my layout\n\n## Point Functions\n<pre>\npoint_type (use when creating points)\n  point_type.RH\n  point_type.LH\n\npoint_callback_type (tells the calling program what has triggered the callback):\n  point_callback_type.point_switched (point has been switched)\n  point_callback_type.fpl_switched (facing point lock has been switched)\n\ncreate_point - Creates a point object and returns a list of the tkinter drawing objects (lines) that \n               make up the point (so calling programs can later update them if required (e.g. change \n               the colour of the lines to represent the route that has been set up)\n               Returned list comprises: [straight blade, switched blade, straight route ,switched route]\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      point_id:int - The ID for the point - also displayed on the point button\n      pointtype:point_type - either point_type.RH or point_type.LH\n      x:int, y:int - Position of the point on the canvas (in pixels)\n      colour:str - Any tkinter colour can be specified as a string\n  Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      point_callback - The function to call when a point button is pressed - default is no callback\n                        Note that the callback function returns (item_id, callback type)\n      reverse:bool - If the switching logic is to be reversed - Default is False\n      fpl:bool - If the point is to have a Facing point lock (FPL) - Default is False (no FPL)\n      also_switch:int - the Id of another point to automatically switch with this point - Default none\n      auto:bool - If the point is to be fully automatic (e.g switched by another point) - Default False.\n\nlock_point(*point_id) - use for point/signal interlocking (multiple Point_IDs can be specified)\n\nunlock_point(*point_id) - use for point/signal interlocking (multiple Point_IDs can be specified)\n\ntoggle_point(point_id) - use for route setting (can use 'point_switched' to find the state first)\n\ntoggle_fpl(point_id) - use for route setting (can use 'fpl_active' to find the state first)\n\npoint_switched (point_id) - returns the state of the point (True/False) - to support point/signal interlocking\n\nfpl_active (point_id) - returns the state of the FPL (True/False) - to support point/signal interlocking\n                      - Will always return True if the point does not have a Facing point Lock - to enable full \n                      - interlocking logic to be written for layouts but then inhibited for simplified control \n</pre>\n\n## Signal Functions\n<pre>\nCurrently supported signal types:\n\n    Colour Light Signals - 3 or 4 aspect or 2 aspect (home, distant or red/ylw)\n          - with or without a position light subsidary signal\n          - with or without route indication feathers (maximum of 5)\n          - with or without a theatre type route indicator\n          - With or without a \"Signal Passed\" Button\n          - With or without a \"Approach Release\" Button\n          - Main signal manual or fully automatic\n    Semaphore Signals - Home or Distant\n          - with or without junction arms (RH and LH arms supported)\n          - with or without subsidaries (Main, LH or RH arms supported - for Home signals only)\n          - with or without a theatre type route indicator (for Home signals only)\n          - With or without a \"Approach Release\" Button\n          - Main signal manual or fully automatic\n    Ground Position Light Signals\n          - normal ground position light or shunt ahead position light\n          - either early or modern (post 1996) types\n    Ground Disc Signals\n          - normal ground disc (red banner) or shunt ahead ground disc (yellow banner)\n\nSummary of features supported by each signal type:\n\n    Colour Light signals\n           - set_route_indication (Route Type and theatre text)\n           - update_signal (based on a signal Ahead) - apart from 2 Aspect Home and Red/Yellow\n           - toggle_signal / toggle_subsidary\n           - lock_subsidary / unlock_subsidary\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - set_approach_control (Release on Red or Yellow) / clear_approach_control\n           - trigger_timed_signal\n           - query signal state (signal_clear, subsidary_clear, signal_overridden, approach_control_set)\n    Semaphore signals:\n           - set_route_indication (Route Type and theatre text)\n           - update_signal (based on a signal Ahead) - for home signals with a secondary distant arm\n           - toggle_signal / toggle_subsidary\n           - lock_subsidary / unlock_subsidary\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - set_approach_control (Release on Red only) / clear_approach_control\n           - trigger_timed_signal\n           - query signal state (signal_clear, subsidary_clear, signal_overridden, approach_control_set)\n    Ground Position Colour Light signals:\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - query signal state (signal_clear, signal_overridden)\n    Ground Disc signals\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - query signal state (signal_clear, signal_overridden)\n\nPublic types and functions:\n\nsignal_sub_type (use when creating colour light signals):\n  signal_sub_type.home         (2 aspect - Red/Green)\n  signal_sub_type.distant      (2 aspect - Yellow/Green\n  signal_sub_type.red_ylw      (2 aspect - Red/Yellow\n  signal_sub_type.three_aspect (3 aspect - Red/Yellow/Green)\n  signal_sub_type.four_aspect  (4 aspect - Red/Yellow/Double-Yellow/Green)\n\nroute_type (use for specifying the route):\n  route_type.NONE   (no route indication - i.e. not used)\n  route_type.MAIN   (main route)\n  route_type.LH1    (immediate left)\n  route_type.LH2    (far left)\n  route_type.RH1    (immediate right)\n  route_type.RH2    (rar right)\nThese equate to the colour light signal route feathers or the Sempahore junction \"arms\"\n\nsig_callback_type (tells the calling program what has triggered the callback):\n    sig_callback_type.sig_switched (signal has been switched)\n    sig_callback_type.sub_switched (subsidary signal has been switched)\n    sig_callback_type.sig_passed (\"signal passed\" button / sensor event - or triggered by Timed signal)\n    sig_callback_type.sig_updated (signal aspect has been updated as part of a timed sequence)\n    sig_callback_type.sig_released (signal \"approach release\" button / sensor event)\n\ncreate_colour_light_signal - Creates a colour light signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the point on the canvas (in pixels) \n  Optional Parameters:\n      signal_subtype:sig_sub_type - type of signal to create - Default is signal_sub_type.four_aspect\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      sig_callback:name - Function to call when a signal event happens - Default is no callback\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button for automatic control - Default False\n      approach_release_button:bool - Creates an \"Approach Release\" button - Default False\n      position_light:bool - Creates a subsidary position light signal - Default False\n      lhfeather45:bool - Creates a LH route indication feather at 45 degrees - Default False\n      lhfeather90:bool - Creates a LH route indication feather at 90 degrees - Default False\n      rhfeather45:bool - Creates a RH route indication feather at 45 degrees - Default False\n      rhfeather90:bool - Creates a RH route indication feather at 90 degrees - Default False\n      mainfeather:bool - Creates a MAIN route indication feather - Default False\n      theatre_route_indicator:bool -  Creates a Theatre Type route indicator - Default False\n      refresh_immediately:bool - When set to False the signal aspects will NOT be automaticall updated \n                when the signal is changed and the external programme will need to call the seperate \n                'update_signal' function. Primarily intended for use with 3/4 aspect signals, where the\n                displayed aspect will depend on the signal ahead if the signal is clear - Default True \n      fully_automatic:bool - Creates a signal without a manual control button - Default False\n\ncreate_semaphore_signal - Creates a Semaphore signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the point on the canvas (in pixels) \n  Optional Parameters:\n      distant:bool - Set to True for a Distant signal - False for a Home signal - default False\n      orientation:int - Orientation in degrees (0 or 180) - Default is zero\n      sig_callback:name - Function to call when a signal event happens - Default is no callback\n                          Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button for automatic control - Default False\n      approach_release_button:bool - Creates an \"Approach Release\" button - Default False\n      lh1_signal:bool - To create a LH1 post with a main (junction) signal - default False\n      lh2_signal:bool - To create a LH2 post with a main (junction) signal - default False\n      rh1_signal:bool - To create a RH1 post with a main (junction) signal - default False\n      rh2_signal:bool - To create a RH2 post with a main (junction) signal - default False\n      main_subsidary:bool - To create a subsidary signal under the \"main\" signal - default False\n      lh1_subsidary:bool - To create a LH1 post with a subsidary signal - default False\n      lh2_subsidary:bool - To create a LH2 post with a subsidary signal - default False\n      rh1_subsidary:bool - To create a RH1 post with a subsidary signal - default False\n      rh2_subsidary:bool - To create a RH2 post with a subsidary signal - default False\n      main_distant:bool - To create a secondary distant signal (for the signal ahead) - default False\n      lh1_distant:bool - To create a LH1 secondary distant signal (for the signal ahead) - default False\n      lh2_distant:bool - To create a LH2 secondary distant signal (for the signal ahead) - default False\n      rh1_distant:bool - To create a RH1 secondary distant signal (for the signal ahead) - default False\n      rh2_distant:bool - To create a RH2 secondary distant signal (for the signal ahead) - default False\n      theatre_route_indicator:bool -  Creates a Theatre Type route indicator - Default False\n      refresh_immediately:bool - When set to False the signal aspects will NOT be automaticall updated \n                when the signal is changed and the external programme will need to call the seperate \n                'update_signal' function. Primarily intended for use with home signals that have a\n                secondary distant arm, which will reflect the state of the signal ahead (i.e. if the\n                signal ahead is at DANGER then the secondary distant arm will be ON) - Default True \n      fully_automatic:bool - Creates a signal without a manual control button - Default False\n\ncreate_ground_position_signal - create a ground position light signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the point on the canvas (in pixels) \n  Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      sig_callback:name - Function to call when a signal event happens - Default is no callback\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button for automatic control - Default False\n      shunt_ahead:bool - Specifies a shunt ahead signal (yellow/white aspect) - default False\n      modern_type: bool - Specifies a modern type ground position signal (post 1996) - Default False\n\ncreate_ground_disc_signal - Creates a ground disc type signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the point on the canvas (in pixels) \n Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      sig_callback:name - Function to call when a signal event happens - Default is no callback\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button for automatic control - Default False\n      shunt_ahead:bool - Specifies a shunt ahead signal (yellow banner) - default False (red banner)\n\nset_route - Set (and change) the route indication (either feathers or theatre text)\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      route:signals_common.route_type - MAIN, LH1, LH2, RH1 or RH2 - default 'NONE'\n      theatre_text:str  - The text to display in the theatre route indicator - default \"NONE\"\n\nupdate_signal - update the aspect of a signal ( based on the aspect of a signal ahead)\n              - intended for 3 and 4 aspect and 2 aspect distant colour light signals\n              - also for semaphore home signals created with with secondary distant arms\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      sig_ahead_id:int - The ID for the signal \"ahead\" of the one to be updated\n\ntoggle_signal(sig_id) - use for route setting (can use 'signal_clear' to find the state first)\n\ntoggle_subsidary(sig_id) - use for route setting (can use 'subsidary_clear' to find the state first)\n\nlock_signal(*sig_id) - use for point/signal interlocking (multiple Signal_IDs can be specified)\n\nunlock_signal(*sig_id) - use for point/signal interlocking (multiple Signal_IDs can be specified)\n\nlock_subsidary(*sig_id) - use for point/signal interlocking (multiple Signal_IDs can be specified)\n\nunlock_subsidary(*sig_id) use for point/signal interlocking (multiple Signal_IDs can be specified)\n\nsignal_clear(sig_id) - returns the signal state (True='clear') - to support interlocking\n\nsubsidary_clear(sig_id) - returns the subsidary state (True='clear') - to support interlocking\n\nsignal_overridden (sig_id) - returns the signal override state (True='overridden') - to support interlocking\n\napproach_control_set (sig_id) - returns the approach control state (True='active') - to support interlocking\n\nset_signal_override (sig_id*) - Overrides the signal and sets it to DANGER (multiple Signals can be specified)\n\nclear_signal_override (sig_id*) - Reverts the signal to its controlled state (multiple Signals can be specified)\n\ntrigger_timed_signal - Sets the signal to DANGER and then cycles through the aspects back to PROCEED\n                      - If a start delay >0 is specified then a 'sig_passed' callback event is generated\n                      - when the signal is changed to DANGER - For each subsequent aspect change (all the\n                      - way back to PROCEED) a 'sig_updated' callback event will be generated\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      start_delay:int - Delay (in seconds) before changing to DANGER (default=5)\n      time_delay:int - Delay (in seconds) for cycling through the aspects (default=5)\n\nset_approach_control - Puts the signal into \"Approach Control\" Mode where the signal will display a particular\n                       aspect/state (either Red or Yellow) to approaching trains. As the Train approaches the\n                       signal, the signal should then be \"released\" to display the normal aspect. Normally used\n                       for diverging routes which have a lower speed restriction to the main line. When a signal\n                       is set in \"approach control\" mode then the signals behind will display the appropriate\n                       aspects when updated (based on the signal ahead). for \"Release on Red\" these would be \n                       the normal aspects. For \"Release on Yellow\", assuming 4 aspect signals, the signals  \n                       behind will display flashing single yellow and flashing double yellow aspects.\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      release_on_yellow:Bool - True = Yellow Approach aspect, False = Red Approach aspect (default=False)\n\nclear_approach_control - This \"releases\" the signal to display the normal aspect and should be called when\n                           a train is approaching the signal (so the signal clears in front of the driver)\n                           Note that signals can also be released when the \"release control button\" is activated\n                           (which is displayed just in front of the signal if specified at signal creation time)\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n</pre>\n\n## Track Occupancy Functions\n<pre>\nsection_callback_type (tells the calling program what has triggered the callback):\n    section_callback_type.section_switched - The section has been toggled (occupied/clear) by the user\n\ncreate_section - Creates a Track Occupancy section object\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the section is to be displayed\n      section_id:int - The ID to be used for the section \n      x:int, y:int - Position of the section on the canvas (in pixels)\n  Optional Parameters:\n      section_callback - The function to call if the section is manually toggled - default: null\n                        Note that the callback function returns (item_id, callback type)\n      label - The label to display on the section when occupied - default: \"Train On Line\"\n\nsection_occupied (section_id)- Returns the current state of the section (True=Occupied, False=Clear)\n\nset_section_occupied (section_id) - Sets the specified section to \"occupied\"\n\nclear_section_occupied (section_id)- Sets the specified section to \"clear\"\n</pre>\n\n## Track Sensor Functions\n<pre>\nsensor_callback_type (tells the calling program what has triggered the callback):\n    track_sensor_callback_type.sensor_triggered - The section has been toggled by the user\n\ncreate_sensor - Creates a sensor object\n  Mandatory Parameters:\n      sensor_id:int - The ID to be used for the sensor \n      gpio_channel:int - The GPIO port number  to use for the sensor (not the physical pin number):\n  Optional Parameters:\n      sensor_timeout:float - The time period during which further triggers are ignored - default = 3.0 secs\n      trigger_period:float - Duration that the sensor needs to remain active before triggering - default = 0.001 secs\n      signal_passed:int    - Raise a \"signal passed\" event for the specified signal ID when triggered - default = None\n      signal_approach:int  - Raise an \"approach release\" event for the specified signal ID when triggered - default = None\n      sensor_callback      - The function to call when triggered (if signal events have not been specified) - default = None\n                                  Note that the callback function returns (item_id, callback type)\n\n\nsensor_active (sensor_id) - Returns the current state of the sensor (True/False)\n</pre>\n\n## DCC Address Mapping Functions\n\nThese functions provide the means to map the signals and points on the layout to the series of DCC \ncommands needed to control them.\n\nFor the main signal aspects, either \"Truth Table\" or \"Event Driven\" mappings can be defined\nThe \"Event Driven\" mapping uses a single dcc command (address/state) to change the signal to \nthe required aspect - as used by the TrainTech DCC signals. The \"Truth Table\" mapping provides\nmaximum flexibility for commanding DCC Signals as each \"led\" can either be controlled individually \n(i.e. Each LED of the signal is controlled via its own individual address) or via a \"Truth Table\" \n(where the displayed aspect will depend on the binary \"code\" written to 2 or more DCC addresses)\nThis has been successfully tested with the Harman Signallist SC1 DCC Decoder in various modes\n\n\"Truth Table\" or \"Event Driven\" mappings can alos be defined for the Route indications supported by\nthe signal (feathers or theatre). If the signal has a subsidary associated with it, this is always\nmapped to a single DCC address.\n\nNot all signals/points that exist on the layout need to have a DCC Mapping configured - If no DCC mapping \nhas been defined, then no DCC commands will be sent. This provides flexibility for including signals on the \nschematic which are \"off scene\" or for progressively \"working up\" the signalling scheme for a layout.\n<pre>\nmap_dcc_signal - Map a signal to one or more DCC Addresses\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n   Optional Parameters:\n      auto_route_inhibit:bool - If the signal inhibits route indications at DANGER (default=False)\n      proceed[[add:int,state:bool],] - List of DCC addresses/states (default = no mapping)\n      danger [[add:int,state:bool],] - List of DCC addresses/states (default = No mapping)\n      caution[[add:int,state:bool],] - List of DCC addresses/states (default = No mapping)\n      prelim_caution[[add:int,state:bool],] - List of DCC addresses/states (default = No mapping)\n      LH1[[add:int,state:bool],] - List of DCC addresses/states for \"LH45\" (default = No Mapping)\n      LH2[[add:int,state:bool],] - List of DCC addresses/states for \"LH90\" (default = No Mapping)\n      RH1[[add:int,state:bool],] - List of DCC addresses/states for \"RH45\" (default = No Mapping)\n      RH2[[add:int,state:bool],] - List of DCC addresses/states for \"RH90\" (default = No Mapping)\n      MAIN[[add:int,state:bool],] - List of DCC addresses/states for \"MAIN\" (default = No Mapping)\n      NONE[[add:int,state:bool],] - List of DCC addresses/states to inhibit routes (default = No Mapping)\n              Note that you should ALWAYS provide mappings for NONE if you are using feather route indications\n              unless the DCC signal automatically inhibits route indications when displaying a DANGER aspect\n      THEATRE[[\"character\",[add:int,state:bool],],] - List of possible theatre indicator states (default = No Mapping)\n              Each entry comprises the \"character\" and the associated list of DCC addresses/states\n              \"#\" is a special character - which means inhibit all indications (when signal is at danger)\n              Note that you should ALWAYS provide mappings for '#' if you are using a theatre route indicator\n              unless the DCC signal itself inhibits route indications when displaying a DANGER aspect\n      subsidary:int - Single DCC address for the \"position light\" indication (default = No Mapping)\n\n    An example DCC mapping for a  Signalist SC1 decoder with a base address of 1 (CV1=5) is included below.\n    This assumes the decoder is configured in \"8 individual output\" Mode (CV38=8). In this example we are using\n    outputs A,B,C,D to drive our signal with E & F driving the feather indications. The Signallist SC1 uses 8 \n    consecutive addresses in total (which equate to DCC addresses 1 to 8 for this example). The DCC addresses for\n    each LED are: RED = 1, Green = 2, YELLOW1 = 3, YELLOW2 = 4, Feather1 = 5, Feather2 = 6.\n\n           map_dcc_signal (sig_id = 2,\n                danger = [[1,True],[2,False],[3,False],[4,False]],\n                proceed = [[1,False],[2,True],[3,False],[4,False]],\n                caution = [[1,False],[2,False],[3,True],[4,False]],\n                prelim_caution = [[1,False],[2,False],[3,True],[4,True]],\n                LH1 = [[5,True],[6,False]], \n                MAIN = [[6,True],[5,False]], \n                NONE = [[5,False],[6,False]] )\n\n     A second example DCC mapping, but this time with a Feather Route Indication, is shown below. In this case,\n     the main signal aspects are configured identically to the first example. The only difference is the THEATRE\n     mapping - where a display of \"1\" is enabled by DCC Address 5 and \"2\" by DCC Address 6. Note the special \"#\"\n     character mapping - which defines the DCC commands that need to be sent to inhibit the theatre display.\n\n            map_dcc_signal (sig_id = 2,\n                danger = [[1,True],[2,False],[3,False],[4,False]],\n                proceed = [[1,False],[2,True],[3,False],[4,False]],\n                caution = [[1,False],[2,False],[3,True],[4,False]],\n                prelim_caution = [[1,False],[2,False],[3,True],[4,True]],\n                THEATRE = [ [\"#\",[[5,False],[6,False]]],\n                            [\"1\",[[6,False],[5,True]]],\n                            [\"2\",[[5,False],[6,True]]]  ] )\n\nmap_traintech_signal - Generate the mappings for a TrainTech signal\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n      base_address:int - The base address of the signal (the signal will take 4 consecutive addresses)\n   Optional Parameters:\n      route_address:int - The address for the route indicator (Feather or Theatre) - Default = 0 (no indicator)\n      theatre_route:str - The character to be associated with the Theartre display - Default = \"NONE\" (no Text)\n      feather_route:route_type - The route to be associated with the feather - Default = NONE (no route)\n\nmap_semaphore_signal - Generate the mappings for a semaphore signal (DCC address mapped to each arm)\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n      main_signal:int     - single DCC address for the main signal arm (default = No Mapping)\n   Optional Parameters:\n      main_subsidary:int  - single DCC address for the main subsidary arm (default = No Mapping)\n      main_distant:int    - single DCC address for the main secondary distant arm (default = No Mapping)\n      lh1_signal:int      - single DCC address for the LH1 signal arm (default = No Mapping)\n      lh1_subsidary:int   - single DCC address for the LH1 subsidary arm (default = No Mapping)\n      lh1_distant:int     - single DCC address for the LH1 secondary distant arm (default = No Mapping)\n      lh2_signal:int      - single DCC address for the LH2 signal arm (default = No Mapping)\n      lh2_subsidary:int   - single DCC address for the LH2 subsidary arm (default = No Mapping)\n      lh2_distant:int     - single DCC address for the LH2 secondary distant arm (default = No Mapping)\n      rh1_signal:int      - single DCC address for the RH1 signal arm  (default = No Mapping)\n      rh1_subsidary:int   - single DCC address for the RH1 subsidary arm (default = No Mapping)\n      rh1_distant:int     - single DCC address for the RH1 secondary distant arm (default = No Mapping)\n      rh2_signal:int      - single DCC address for the RH2 signal arm  (default = No Mapping)\n      rh2_subsidary:int   - single DCC address for the RH2 subsidary arm (default = No Mapping)\n      rh2_distant:int     - single DCC address for the RH2 secondary distant arm (default = No Mapping)\n      THEATRE[[\"character\",[add:int,state:bool],],] - List of possible theatre indicator states (default = No Mapping)\n              Each entry comprises the \"character\" and the associated list of DCC addresses/states\n              \"#\" is a special character - which means inhibit all indications (when signal is at danger)\n              Note that you should ALWAYS provide mappings for '#' if you are using a theatre route indicator\n              unless the DCC signal itself inhibits route indications when displaying a DANGER aspect\n\n     Semaphore signal DCC mappings assume that each main/subsidary signal arm is mapped to a seperate DCC address.\n     In this example, we are mapping a signal with MAIN and LH signal arms and a subsidary arm for the MAIN route.\n     Note that if the semaphore signal had a theatre type route indication, then this would be mapped in exactly\n     the same was as for the Colour Light Signal example above)\n\n           map_semaphore_signal (sig_id = 2, \n                        main_signal = 1 , \n                        lh1_signal = 2 , \n                        main_subsidary = 3)\n\nmap_dcc_point\n   Mandatory Parameters:\n      point_id:int - The ID for the point to create a DCC mapping for\n      address:int - the single DCC address for the point\n   Optional Parameters:\n      state_reversed:bool - Set to True to reverse the DCC logic (default = false)\n</pre>\n\n## Pi-Sprog Interface Functions\n\nThis provides a basic CBUS interface fpor communicating with the Pi-SPROG3 via the Raspberry Pi UART. It does not provide\na fully-functional interface for all DCC command and control functions - just the minimum set needed to support the driving\nof signals and points via a selection of common DCC Accessory decoders. Basic CV Programming is also supported - primarily \nas an aid to testing. For full decoder programming the recommendation is to use JRMI DecoderPro.\n<pre>\ninitialise_pi_sprog - Open and configures the serial comms port to the Pi Sprog\n   Optional Parameters:\n      port_name:str - The Serial port to use for communicating with the Pi-SPROG 3 - Default=\"/dev/serial0\",\n      baud_rate:int - The baud rate to use for the serial port - Default = 115200,\n      dcc_debug_mode:bool - Set to True to log the CBUS commands being sent to the Pi-SPROG (default = False). \n                          - If set to True, this initialisation function will also Request and report the \n                            command station status (from the Pi-SPROG-3)\n\nservice_mode_write_cv - programmes a CV in direct bit mode and waits for response\n                      (events are only sent if we think the track power is currently switched on)\n                      (if acknowledgement isn't received within 5 seconds then the request times out)\n   Mandatory Parameters:\n      cv:int - The CV (Configuration Variable) to be programmed\n      value:int - The value to programme\n\nrequest_dcc_power_on - sends a request to switch on the track power and waits for acknowledgement\n                     (requests are only sent if the Pi Sprog Comms Port has been successfully opened/configured)\n       returns True if we have received acknowledgement that Track Power has been turned on\n       returns False if acknowledgement isn't received within 5 seconds (i.e. request timeout)\n\nrequest_dcc_power_off - sends a request to switch off the track power and waits for acknowledgement\n                     (requests are only sent if the Pi Sprog Comms Port has been successfully opened/configured)\n       returns True if we have received acknowledgement that Track Power has been turned off\n       returns False if acknowledgement isn't received within 5 seconds (i.e. request timeout)\n</pre>\n\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/johnrm174/model-railway-signalling",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "model-railway-signals",
    "package_url": "https://pypi.org/project/model-railway-signals/",
    "platform": "",
    "project_url": "https://pypi.org/project/model-railway-signals/",
    "project_urls": {
      "Homepage": "https://github.com/johnrm174/model-railway-signalling"
    },
    "release_url": "https://pypi.org/project/model-railway-signals/2.2.0/",
    "requires_dist": [
      "pyserial"
    ],
    "requires_python": "",
    "summary": "Create your own DCC model railway signalling scheme",
    "version": "2.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16064626,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3268ffff07a138bceb959a83a6e380b345bd5ccfbf54a280d0f10a9c3f0f8ac9",
        "md5": "9eb01159d505fdec770ade8e0c1e0480",
        "sha256": "9cc33f8bd6a3a341104f6ce2d0ab551cc7a3aa31ff160db05191d4d8314e1a58"
      },
      "downloads": -1,
      "filename": "model_railway_signals-2.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9eb01159d505fdec770ade8e0c1e0480",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 65929,
      "upload_time": "2021-09-17T08:58:27",
      "upload_time_iso_8601": "2021-09-17T08:58:27.047812Z",
      "url": "https://files.pythonhosted.org/packages/32/68/ffff07a138bceb959a83a6e380b345bd5ccfbf54a280d0f10a9c3f0f8ac9/model_railway_signals-2.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "541b3664380a553d822fc2d91512818e4e247702df436278010fc2a1c839f95c",
        "md5": "26e046b1b8bd7c266c40aa2ab5c3f229",
        "sha256": "c49d331ad8b59f3db5f207cd59e609d1be7fea982a517d78a5b0ea592da4a570"
      },
      "downloads": -1,
      "filename": "model-railway-signals-2.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "26e046b1b8bd7c266c40aa2ab5c3f229",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 71836,
      "upload_time": "2021-09-17T08:58:29",
      "upload_time_iso_8601": "2021-09-17T08:58:29.015224Z",
      "url": "https://files.pythonhosted.org/packages/54/1b/3664380a553d822fc2d91512818e4e247702df436278010fc2a1c839f95c/model-railway-signals-2.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}