{
  "info": {
    "author": "johnrm174",
    "author_email": "johnrm17418@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "# model-railway-signalling\nA model railway signalling library written in Python. Primarily intended for the Raspberry Pi, but will also run on other platforms \n(albeit without some of the Raspberry-Pi specific interfacing functions). \n\nFor details of the \"Public\" API - scroll down the page.\n\n![Example Screenshot](https://github.com/johnrm174/model-railway-signalling/blob/main/README_screenshot1.png)\n\nAll of the functions for creating and managing 'signals', 'points', 'sections', 'sensors' and 'block instruments' have \nbeen developed as a Python Package to promote re-use across other layouts. This includes functions to support the interlocking \nof signals, points and block instruments to enable fully prototypical signalling schemes to be developed. \nMost types of colour light signals, semaphore signals, ground position light signals and ground disc signals are supported.\n\nAn interface to \nthe Pi-SPROG-3 DCC Command station enables DCC control of the signals and points out on the layout. The signals and points \nobjects can be mapped to one or more DCC addresses in a manner that should be compatible with the majority of DCC signal/points \ndecoders currently on the market. A GPIO interface allows external train detectors such as the BlockSignalling BOD2-NS to be \nconnected in via opto-isolators. These sensors can be configured to trigger 'signal approached' or 'signal passed' events, \nenabling full automatic control of the layout signalling. A MQTT interface enables multiple signalling applications to be \nnetworked together so that complex layouts can be split into different signalling sections/areas, with communication between them.\n\nNote that I have tried to make the package platform independent so you can use it to develop your own layout signalling schemes \nwithout a Raspberry Pi or the associated Pi-SPROG-3 DCC Command station (track sensors can be manually 'triggered' via the\nlayout schematic to ensure your code is doing what its supposed to do). Full logging is provided to help you develop/debug \nyour own schemes - just set the log level to INFO to see what the package is doing 'under the hood'. And when you do enable\nthe DCC control aspects, a log level of DEBUG will show you the commands being sent out to the Pi-SPROG-3. Finally, the \nsoftware supports load (on application startup) and save (on application quit) to preserve the current \"state\" of the layout \nbetween running sessions.\n\nComments and suggestions welcome - but please be kind - the last time I coded anything it was in Ada96 ;)\n\n![Example Screenshot](https://github.com/johnrm174/model-railway-signalling/blob/main/README_screenshot2.png)\n\n## Installation\nFor a first time installation use:\n<pre>\n$ python3 -m pip install model-railway-signals \n</pre>\nTo upgrade to the latest version use:\n<pre>\n$ python3 -m pip install --upgrade model-railway-signals \n</pre>\nIf you want to use Block Instruments with full sound enabled (bell rings and telegraph key sounds)\nthen you will also need to install the 'simpleaudio' package. Note that for Windows it has a dependency \non Microsoft Visual C++ 14.0 or greater (so you will need to ensure Visual Studio 2015 is installed first).\nIf 'simpleaudio' is not installed then the software will still function correctly (just without sound).\n<pre>\n$ python3 -m pip install simpleaudio\n</pre>\n\n## Using the package\n\nTo use the \"public\" functions for developing your own layout signalling system:\n\n<code> from model_railway_signals import * </code>\n\nSome examples are included in the repository: https://github.com/johnrm174/model-railway-signalling:\n\n<pre>\n'test_simple_example.py' - an example of how to use the \"signals\", \"points\", \"sections\" and \n           \"sensors\" modules to create a basic track schematic with interlocked signals/points \n           and semi-automation of signals using external sensors to provide \"signal passed\" \n           events as the train progresses across the schematic. Also includes DCC Mapping \n           examples (for both signals and points).\n\n'test_semaphore_example.py' - effectively the same example as above, but using sempahore signals. \n           Includes DCC Mapping examples for the Semaphore signals (different to colour lights).\n\n'test_approach_control.py' - an example of using \"approach control\" for junction signals. Signals \n           subject to \"approach control\" display a more restrictive aspect (either red or yellow) \n           when a lower-speed divergent route is set, forcing the approaching train to slow down \n           and be prepared to stop. As the train approaches, the signal is \"released\", allowing \n           the train to proceed past the signal and onto the divergent route. For Colour light \n           signals, examples of \"Approach on Red\" and \"Approach on Yellow\" are provided (for \n           \"Approach on yellow\", the signals behind will show the correct flashing yellow \n           aspects). For Semaphore signals, an example of using approach control for semi\n           automating all the home signals within a block section is provided.\n\n'test_networking_1/2.py' - an example of how to network multiple signalling applications \n           (potentially hosted on seperate computers) together via an external MQTT broker. This \n           demonstrates how signal states, \"signal passed\" events and track occupancy information \n           can be shared between applications and how block instruments can be configured to\n           provide a prototypical method of communication between the applications.\n\n'test_harman-signalist_sc1.py'- developed primarily for testing using the Harmann Signallist SC1 \n           decoder. Enables the various modes to be selected (includes programming of CVs) and \n           then tested. I used this decoder as it provided the most flexibility for some of my \n           more complex signal types. Note that some of the modes will be similar/identical to \n           other manufacturer's DCC signals.\n\n'test_colour_light_signals.py'- developed primarily for testing, but it does provide an example \n           of every signal type and the control features currently supported.\n\n'test_semaphore_signals.py'- similar to the above developed primarily for testing, but it does \n           provide an example of every signal type and the control features supported.\n\n</pre>\n\nOr alternatively, go to https://github.com/johnrm174/layout-signalling-scheme to see the scheme \nfor my layout (still very much work in progress).\n\n## Point Functions\n<pre>\nPublic Types and Functions:\n\npoint_type (use when creating points)\n  point_type.RH\n  point_type.LH\n\npoint_callback_type (tells the calling program what has triggered the callback):\n  point_callback_type.point_switched (point has been switched)\n  point_callback_type.fpl_switched (facing point lock has been switched)\n\ncreate_point - Creates a point object and returns a list of the tkinter drawing objects (lines) \n               that make up the point so calling programs can later update them if required \n               (e.g. change the colour of the lines to represent the route that has been set up)\n             - Returns: [straight blade, switched blade, straight route ,switched route]\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the point is to be displayed\n      point_id:int - The ID for the point - also displayed on the point button\n      pointtype:point_type - either point_type.RH or point_type.LH\n      x:int, y:int - Position of the point on the canvas (in pixels)\n      colour:str - Any tkinter colour can be specified as a string\n  Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      point_callback - The function to call when the point is changed - default = no callback\n                       Note that the callback function returns (item_id, callback type)\n      reverse:bool - If the switching logic is to be reversed - Default = False\n      fpl:bool - If the point is to have a Facing point lock - Default = False (no FPL)\n      also_switch:int - the Id of another point to switch with this point - Default = None\n      auto:bool - Point is fully automatic (i.e. no point control buttons) - Default = False.\n\nlock_point(*point_id:int) - use for point/signal interlocking (multiple IDs can be specified)\n\nunlock_point(*point_id:int) - use for point/signal interlocking (multiple IDs can be specified)\n\ntoggle_point(point_id:int) - use for route setting (use 'point_switched' to find state first)\n\ntoggle_fpl(point_id:int) - use for route setting (use 'fpl_active' to find state first)\n\npoint_switched (point_id:int) - returns the point state (True/False) - to support interlocking\n\nfpl_active (point_id:int) - returns the FPL state (True/False) - to support interlocking\n                          - Will return True if the point does not have a Facing point Lock \n</pre>\n\n## Signal Functions\n<pre>\nCurrently supported signal types:\n\n    Colour Light Signals - 3 or 4 aspect or 2 aspect (home, distant or red/ylw)\n          - with / without a position light subsidary signal\n          - with / without route indication feathers (maximum of 5)\n          - with / without a theatre type route indicator\n          - With / without a \"Signal Passed\" Button\n          - With / without a \"Approach Release\" Button\n          - With / without control buttons (manual / fully automatic)\n    Semaphore Signals - Home or Distant\n          - with / without junction arms (RH1, RH2, LH1, LH2)\n          - with / without subsidary arms (Main, LH1, LH2, RH1, RH2) (Home signals only)\n          - with / without a theatre type route indicator (Home signals only)\n          - With / without a \"Signal Passed\" Button\n          - With / without a \"Approach Release\" Button\n          - With / without control buttons (manual / fully automatic)\n      - Home and Distant signals can be co-located\n    Ground Position Light Signals\n          - normal ground position light or shunt ahead position light\n          - either early or modern (post 1996) types\n    Ground Disc Signals\n          - normal ground disc (red banner) or shunt ahead ground disc (yellow banner)\n\nSummary of features supported by each signal type:\n\n    Colour Light signals\n           - set_route_indication (Route Type and theatre text)\n           - update_signal (based on a signal Ahead) - not 2 Aspect Home or Red/Yellow\n           - toggle_signal / toggle_subsidary\n           - lock_subsidary / unlock_subsidary\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - set_approach_control (Release on Red or Yellow) / clear_approach_control\n           - trigger_timed_signal\n           - query signal state (signal_clear, signal_state, subsidary_clear)\n    Semaphore signals:\n           - set_route_indication (Route Type and theatre text)\n           - update_signal (based on a signal Ahead) - (distant signals only)\n           - toggle_signal / toggle_subsidary\n           - lock_subsidary / unlock_subsidary\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - set_approach_control (Release on Red only) / clear_approach_control\n           - trigger_timed_signal\n           - query signal state (signal_clear, signal_state, subsidary_clear)\n    Ground Position Colour Light signals:\n           - toggle_signal\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - query signal state (signal_clear, signal_state)\n    Ground Disc signals\n           - toggle_signal\n           - lock_signal / unlock_signal\n           - set_signal_override / clear_signal_override\n           - query signal state (signal_clear, signal_state)\n\nPublic types and functions:\n\nsignal_sub_type (use when creating colour light signals):\n    signal_sub_type.home         (2 aspect - Red/Green)\n    signal_sub_type.distant      (2 aspect - Yellow/Green\n    signal_sub_type.red_ylw      (2 aspect - Red/Yellow\n    signal_sub_type.three_aspect (3 aspect - Red/Yellow/Green)\n    signal_sub_type.four_aspect  (4 aspect - Red/Yellow/Double-Yellow/Green)\n\nroute_type (use for specifying the route):\n    route_type.NONE   (no route indication)\n    route_type.MAIN   (main route)\n    route_type.LH1    (immediate left)\n    route_type.LH2    (far left)\n    route_type.RH1    (immediate right)\n    route_type.RH2    (rar right)\nThese equate to the feathers for colour light signals or the Sempahore junction \"arms\"\n\nsignal_state_type(enum.Enum):\n    DANGER               (colour light & semaphore signals)\n    PROCEED              (colour light & semaphore signals)\n    CAUTION              (colour light & semaphore signals)\n    PRELIM_CAUTION       (colour light signals only)\n    CAUTION_APP_CNTL     (colour light signals only - CAUTION but subject to RELEASE ON YELLOW)\n    FLASH_CAUTION        (colour light signals only- when the signal ahead is CAUTION_APP_CNTL)\n    FLASH_PRELIM_CAUTION (colour light signals only- when the signal ahead is FLASH_CAUTION)\n\nsig_callback_type (tells the calling program what has triggered the callback):\n    sig_callback_type.sig_switched (signal has been switched)\n    sig_callback_type.sub_switched (subsidary signal has been switched)\n    sig_callback_type.sig_passed (\"signal passed\" event - or triggered by a Timed signal)\n    sig_callback_type.sig_updated (signal aspect updated as part of a timed sequence)\n    sig_callback_type.sig_released (signal \"approach release\" event)\n\ncreate_colour_light_signal - Creates a colour light signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the signal is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the signal on the canvas (in pixels) \n  Optional Parameters:\n      signal_subtype:sig_sub_type - type of signal to create - Default = four_aspect\n      orientation:int- Orientation in degrees (0 or 180) - Default = zero\n      sig_callback:name - Function to call when a signal event happens - Default = None\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button - Default = False\n      approach_release_button:bool - Creates an \"Approach Release\" button - Default = False\n      position_light:bool - Creates a subsidary position light signal - Default = False\n      lhfeather45:bool - Creates a LH route feather at 45 degrees - Default = False\n      lhfeather90:bool - Creates a LH route feather at 90 degrees - Default = False\n      rhfeather45:bool - Creates a RH route feather at 45 degrees - Default = False\n      rhfeather90:bool - Creates a RH route feather at 90 degrees - Default = False\n      mainfeather:bool - Creates a MAIN route feather - Default = False\n      theatre_route_indicator:bool -  Creates a Theatre route indicator - Default = False\n      refresh_immediately:bool - When set to False the signal aspects will NOT be automatically\n                updated when the signal is changed and the external programme will need to call \n                the seperate 'update_signal' function. Primarily intended for use with 3/4 \n                aspect signals, where the displayed aspect will depend on the displayed aspect \n                of the signal ahead if the signal is clear - Default = True \n      fully_automatic:bool - Creates a signal without a manual controls - Default = False\n\ncreate_semaphore_signal - Creates a Semaphore signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the signal is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the signal on the canvas (in pixels) \n  Optional Parameters:\n      distant:bool - True for a Distant signal - False for a Home signal - default = False\n      associated_home:int - Option only valid when creating distant signals - Provide the ID of\n                            a previously created home signal (and use the same x and y coords)\n                            to create the distant signal on the same post as the home signal \n                            with appropriate \"slotting\" between the signal arms - Default = False  \n      orientation:int - Orientation in degrees (0 or 180) - Default = zero\n      sig_callback:name - Function to call when a signal event happens - Default = None\n                          Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button - Default = False\n      approach_release_button:bool - Creates an \"Approach Release\" button - Default = False\n      main_signal:bool - To create a signal arm for the main route - default = True\n                         (Only set this to False when creating an \"associated\" distant signal\n                         for a situation where a distant arm for the main route is not required)\n      lh1_signal:bool - create a LH1 post with a main (junction) arm - default = False\n      lh2_signal:bool - create a LH2 post with a main (junction) arm - default = False\n      rh1_signal:bool - create a RH1 post with a main (junction) arm - default = False\n      rh2_signal:bool - create a RH2 post with a main (junction) arm - default = False\n      main_subsidary:bool - create a subsidary signal under the \"main\" signal - default = False\n      lh1_subsidary:bool - create a LH1 post with a subsidary arm - default = False\n      lh2_subsidary:bool - create a LH2 post with a subsidary arm - default = False\n      rh1_subsidary:bool - create a RH1 post with a subsidary arm - default = False\n      rh2_subsidary:bool - create a RH2 post with a subsidary arm - default = False\n      theatre_route_indicator:bool -  Creates a Theatre route indicator - Default = False\n      refresh_immediately:bool - When set to False the signal aspects will NOT be automatically\n                updated when the signal is changed and the external programme will need to call \n                the seperate 'update_signal' function. Primarily intended for fully automatic\n                distant signals to reflect the state of the home signal ahead - Default = True \n      fully_automatic:bool - Creates a signal without a manual control button - Default = False\n\ncreate_ground_position_signal - create a ground position light signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the signal is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the signal on the canvas (in pixels) \n  Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - default is zero\n      sig_callback:name - Function to call when a signal event happens - default = None\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button - default =False\n      shunt_ahead:bool - Specifies a shunt ahead signal (yellow/white aspect) - default = False\n      modern_type: bool - Specifies a modern type ground signal (post 1996) - default = False\n\ncreate_ground_disc_signal - Creates a ground disc type signal\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the signal is to be displayed\n      sig_id:int - The ID for the signal - also displayed on the signal button\n      x:int, y:int - Position of the signal on the canvas (in pixels) \n Optional Parameters:\n      orientation:int- Orientation in degrees (0 or 180) - Default is zero\n      sig_callback:name - Function to call when a signal event happens - Default = none\n                        Note that the callback function returns (item_id, callback type)\n      sig_passed_button:bool - Creates a \"signal Passed\" button - Default = False\n      shunt_ahead:bool - Specifies a shunt ahead signal (yellow banner) - default = False\n\nset_route - Set (and change) the route indication (either feathers or theatre text)\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      route:signals_common.route_type - MAIN, LH1, LH2, RH1 or RH2 - default = 'NONE'\n      theatre_text:str - The text to display in the theatre indicator - default = \"NONE\"\n\nupdate_signal - update the signal aspect based on the aspect of a signal ahead - Primarily\n                intended for 3/4 aspect colour light signals but can also be used to update \n                2-aspect distant signals (semaphore or colour light) on the home signal ahead\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      sig_ahead_id:int/str - The ID for the signal \"ahead\" of the one we want to update.\n               Either an integer representing the ID of the signal created on our schematic,\n               or a string representing the compound identifier of a remote signal on an \n               external MQTT node. Default = \"None\" (no signal ahead to take into account)\n\ntoggle_signal(sig_id:int) - for route setting (use 'signal_clear' to find the state)\n\ntoggle_subsidary(sig_id:int) - forroute setting (use 'subsidary_clear' to find the state)\n\nlock_signal(*sig_id:int) - for interlocking (multiple Signal_IDs can be specified)\n\nunlock_signal(*sig_id:int) - for interlocking (multiple Signal_IDs can be specified)\n\nlock_subsidary(*sig_id:int) - for interlocking (multiple Signal_IDs can be specified)\n\nunlock_subsidary(*sig_id:int) - for interlocking (multiple Signal_IDs can be specified)\n\nsignal_clear(sig_id:int) - returns the SWITCHED state of the signal - i.e the state of the \n                           signal manual control button (True='OFF', False = 'ON'). To enable\n                           external point/signal interlocking functions\n\nsubsidary_clear(sig_id:int) - returns the SWITCHED state of the subsidary  i.e the state of the \n                           signal manual control button (True='OFF', False = 'ON'). To enable\n                           external point/signal interlocking functions\n\nsignal_state(sig_id:int/str) - returns the DISPLAYED state of the signal. This can be different \n                      to the SWITCHED state if the signal is OVERRIDDEN or subject to APPROACH\n                      CONTROL. Use this function when you need to get the actual state (in terms\n                      of aspect) that the signal is displaying - returns 'signal_state_type'.\n                      - Note that for this function, the sig_id can be specified either as an \n                      integer (representing the ID of a signal on the local schematic), or a \n                      string (representing the identifier of an signal on an external MQTT node)\n\nset_signal_override (sig_id*:int) - Overrides the signal to DANGER (can specify multiple sig_ids)\n\nclear_signal_override (sig_id*:int) - Clears the siganl Override (can specify multiple sig_ids)\n\ntrigger_timed_signal - Sets the signal to DANGER and cycles through the aspects back to PROCEED.\n                      If start delay > 0 then a 'sig_passed' callback event is generated when\n                      the signal is changed to DANGER - For each subsequent aspect change \n                      (back to PROCEED) a 'sig_updated' callback event will be generated.\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      start_delay:int - Delay (in seconds) before changing to DANGER (default = 5)\n      time_delay:int - Delay (in seconds) for cycling through the aspects (default = 5)\n\nset_approach_control - Normally used when a diverging route has a lower speed restriction.\n            Puts the signal into \"Approach Control\" Mode where the signal will display a more \n            restrictive aspect/state (either DANGER or CAUTION) to approaching trains. As the\n            Train approaches, the signal will then be \"released\" to display its \"normal\" aspect.\n            When a signal is in \"approach control\" mode the signals behind will display the \n            appropriate aspects (when updated based on the signal ahead). These would be the\n            normal aspects for \"Release on Red\" but for \"Release on Yellow\", the colour light \n            signals behind would show flashing yellow / double-yellow aspects as appropriate.\n  Mandatory Parameters:\n      sig_id:int - The ID for the signal\n  Optional Parameters:\n      release_on_yellow:Bool - True for Release on Yellow - default = False (Release on Red)\n\nclear_approach_control (sig_id:int) - This \"releases\" the signal to display the normal aspect. \n            Signals are also automatically released when the\"release button\" (displayed just \n            in front of the signal if specified when the signal was created) is activated,\n            either manually or via an external sensor event.\n\nsignal_overridden (sig_id:int) - returns the signal override state (True='overridden')\n                                 Function DEPRECATED (will be removed from future releases)\n                                 use \"signal_state\" function to get the state of the signal\n\napproach_control_set (sig_id:int) - returns the signal approach control state (True='active')\n                                 Function DEPRECATED (will be removed from future releases)\n                                 use \"signal_state\" function to get the state of the signal\n</pre>\n\n## Track Occupancy Functions\n<pre>\nPublic types and functions:\n\nsection_callback_type (tells the calling program what has triggered the callback):\n     section_callback_type.section_updated - The section has been updated by the user\n\ncreate_section - Creates a Track Occupancy section object\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the section is to be displayed\n      section_id:int - The ID to be used for the section \n      x:int, y:int - Position of the section on the canvas (in pixels)\n  Optional Parameters:\n      section_callback - The function to call if the section is updated - default = None\n                        Note that the callback function returns (item_id, callback type)\n      editable:bool - If the section can be manually toggled and/or edited (default = True)\n      label:str - The label to display on the section when occupied - default: \"OCCUPIED\"\n\nsection_occupied (section_id:int/str)- Returns the section state (True=Occupied, False=Clear)\n               The Section ID can either be specified as an integer representing the ID of a \n               section created on our schematic, or a string representing the compound \n               identifier of a section on an remote MQTT network node.\n\nsection_label (section_id:int/str)- Returns the 'label' of the section (as a string)\n               The Section ID can either be specified as an integer representing the ID of a \n               section created on our schematic, or a string representing the compound \n               identifier of a section on an remote MQTT network node.\n\nset_section_occupied - Sets the section to \"OCCUPIED\" (and updates the 'label' if required)\n  Mandatory Parameters:\n      section_id:int - The ID to be used for the section \n  Optional Parameters:\n      label:str - An updated label to display when occupied (Default = No Change)\n\nclear_section_occupied (section_id:int) - Sets the specified section to \"CLEAR\"\n                  Returns the current value of the Section Lable (as a string) to allow this\n                  to be 'passed' to the next section (via the set_section_occupied function)  \n</pre>\n\n## Track Sensor Functions\n<pre>\nPublic types and functions:\n\nsensor_callback_type (tells the calling program what has triggered the callback):\n    track_sensor_callback_type.sensor_triggered - The external sensor has been triggered\n\ncreate_sensor - Creates a sensor object\n  Mandatory Parameters:\n      sensor_id:int - The ID to be used for the sensor \n      gpio_channel:int - The GPIO port number for the sensor (not the physical pin number)\n  Optional Parameters:\n      sensor_timeout:float - Time period for ignoring further triggers - default = 3.0 secs\n      trigger_period:float - Active duration for sensor before triggering - default = 0.001 secs\n      signal_passed:int    - Raise a \"signal passed\" event for a signal ID - default = None\n      signal_approach:int  - Raise an \"approach release\" event for a signal ID - default = None\n      sensor_callback      - Function to call when a sensor has been triggered (if signal events \n                             have not been specified) - default = None\n                             Note that the callback function returns (item_id, callback type)\n\nsensor_active (sensor_id:int) - Returns the current state of the sensor (True/False)\n</pre>\n\n## Block Instrument Functions\n\nIf you want to use Block Instruments with full sound enabled (bell rings and telegraph key sounds)\nthen you will also need to install the 'simpleaudio' package. Note that for Windows it has a dependency \non Microsoft Visual C++ 14.0 or greater (so you will need to ensure Visual Studio 2015 is installed first).\nIf 'simpleaudio' is not installed then the software will still function correctly (just without sound).\n\n<pre>\nPublic types and functions: \n\nblock_callback_type (tells the calling program what has triggered the callback)\n    block_section_ahead_updated - The block section AHEAD of our block section has been updated\n                            (i.e. the block section state represented by the Repeater indicator)\n\ncreate_block_instrument - Creates a Block Section Instrument on the schematic\n  Mandatory Parameters:\n      Canvas - The Tkinter Drawing canvas on which the instrument is to be displayed\n      block_id:int - The local identifier to be used for the Block Instrument \n      x:int, y:int - Position of the instrument on the canvas (in pixels)\n  Optional Parameters:\n      block_callback - The function to call when the repeater indicator on our instrument has been\n                       updated (i.e. the block changed on the linked instrument) - default: null\n                       Note that the callback function returns (item_id, callback type)\n      single_line:bool - for a single line instrument(created without a repeater) - default: False\n      bell_sound_file:str - The filename of the soundfile (in the local package resources\n                          folder) to use for the bell sound (default \"bell-ring-01.wav\" - other\n\t\t\t  options are \"bell-ring-02.wav\", \"bell-ring-03.wav\", \"bell-ring-04.wav\")\n      telegraph_sound_file:str - The filename of the soundfile (in the local package resources)\n                          to use for the Telegraph key sound (default \"telegraph-key-01.wav\")\n      linked_to:int/str - the identifier for the \"paired\" block instrument - can be specified\n                          either as an integer (representing the ID of a Block Instrument on the\n                          the local schematic), or a string representing a Block Instrument \n                          running on a remote node - see MQTT networking (default = None)\n\nNote that the Block Instruments feature is primarily intended to provide a prototypical means of\ncommunication between signallers working their respective signal boxes. As such, MQTT networking\nis \"built in\" - If a remote instrument identifier is specified for the \"linked_to\" instrument\nand the MQTT network has been configured then this function will automatically configured the\nblock instrument to publish its state and telegraph key clicks to the remote instrument and\nwill also subscribe to state updates and telegraph clicks from the remote instrument.\n\nblock_section_ahead_clear(block_id:int) - Returns the state of the ASSOCIATED block instrument\n          (i.e. the linked instrument controlling the state of the block section ahead of ours)\n          This can be used to implement full interlocking of the Starter signal in our section\n          (i.e. signal locked at danger until the box ahead sets their instrument to LINE-CLEAR)\n          Returned state is: True = LINE-CLEAR, False = LINE-BLOCKED or TRAIN-ON-LINE\n</pre>\n\n## DCC Address Mapping Functions\n\nThese functions provide the means to map the signals and points on the layout to the series of DCC \ncommands needed to control them.\n\nFor the main signal aspects, either \"Truth Table\" or \"Event Driven\" mappings can be defined\nThe \"Event Driven\" mapping uses a single dcc command (address/state) to change the signal to \nthe required aspect - as used by the TrainTech DCC signals. The \"Truth Table\" mapping provides\nmaximum flexibility for commanding DCC Signals as each \"led\" can either be controlled individually \n(i.e. Each LED of the signal is controlled via its own individual address) or via a \"Truth Table\" \n(where the displayed aspect will depend on the binary \"code\" written to 2 or more DCC addresses)\nThis has been successfully tested with the Harman Signallist SC1 DCC Decoder in various modes\n\n\"Truth Table\" or \"Event Driven\" mappings can alos be defined for the Route indications supported\nby the signal (feathers or theatre). If the signal has a subsidary associated with it, this is \nalways mapped to a single DCC address.\n\nNot all signals/points that exist on the layout need to have a DCC Mapping configured - If no DCC mapping \nhas been defined, then no DCC commands will be sent. This provides flexibility for including signals on the \nschematic which are \"off scene\" or for progressively \"working up\" the signalling scheme for a layout.\n<pre>\nPublic types and functions:\n\nmap_dcc_signal - Map a signal to one or more DCC Addresses\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n   Optional Parameters:\n      auto_route_inhibit:bool - If signal inhibits route indication at DANGER (default=False)\n      proceed[[add:int,state:bool],] -  DCC addresses/states (default = no mapping)\n      danger [[add:int,state:bool],] - DCC addresses/states (default = No mapping)\n      caution[[add:int,state:bool],] - DCC addresses/states (default = No mapping)\n      prelim_caution[[add:int,state:bool],] - DCC addresses/states (default = No mapping)\n      LH1[[add:int,state:bool],] - DCC addresses/states for \"LH45\" (default = No Mapping)\n      LH2[[add:int,state:bool],] - DCC addresses/states for \"LH90\" (default = No Mapping)\n      RH1[[add:int,state:bool],] - DCC addresses/states for \"RH45\" (default = No Mapping)\n      RH2[[add:int,state:bool],] - DCC addresses/states for \"RH90\" (default = No Mapping)\n      MAIN[[add:int,state:bool],] - DCC addresses/states for \"MAIN\" (default = No Mapping)\n      NONE[[add:int,state:bool],] - DCC addresses/states to inhibit the route indication when \n              the signal is displaying DANGER - unless the DCC signal automatically inhibits\n              route indications (see auto_route_inhibit flag above) - Default = None\n      THEATRE[[\"char\",[add:int,state:bool],],] - list of theatre states (default = No Mapping)\n              Each entry comprises the \"char\" and the associated list of DCC addresses/states\n              that need to be sent to get the theatre indicator to display that character.\n              \"#\" is a special character - which means inhibit all indications (when signal \n              is at danger). You should ALWAYS provide mappings for '#' if you are using a \n              theatre indicator unless the signal automatically inhibits route indications.\n      subsidary:int - Single DCC address for the \"subsidary\" signal (default = No Mapping)\n\n    An example mapping for a  Signalist SC1 decoder with a base address of 1 (CV1=5) is included\n    below. This assumes the decoder is configured in \"8 individual output\" Mode (CV38=8). In this\n    example we are using outputs A,B,C,D to drive our signal with E & F each driving a feather \n    indication. The Signallist SC1 uses 8 consecutive addresses in total (which equate to DCC \n    addresses 1 to 8 for this example). The DCC addresses for each LED are: RED = 1, Green = 2, \n    YELLOW1 = 3, YELLOW2 = 4, Feather1 = 5, Feather2 = 6.\n\n           map_dcc_signal (sig_id = 2,\n                danger = [[1,True],[2,False],[3,False],[4,False]],\n                proceed = [[1,False],[2,True],[3,False],[4,False]],\n                caution = [[1,False],[2,False],[3,True],[4,False]],\n                prelim_caution = [[1,False],[2,False],[3,True],[4,True]],\n                LH1 = [[5,True],[6,False]], \n                MAIN = [[6,True],[5,False]], \n                NONE = [[5,False],[6,False]] )\n\n     A second example DCC mapping, but this time with a Feather Route Indication, is shown below. \n     In this case, the main signal aspects are configured identically to the first example, the\n     only difference being the THEATRE mapping - where a display of \"1\" is enabled by DCC Address\n     5 and \"2\" by DCC Address 6. Note the special \"#\" character mapping - which defines the DCC \n     commands that need to be sent to inhibit the theatre display.\n\n            map_dcc_signal (sig_id = 2,\n                danger = [[1,True],[2,False],[3,False],[4,False]],\n                proceed = [[1,False],[2,True],[3,False],[4,False]],\n                caution = [[1,False],[2,False],[3,True],[4,False]],\n                prelim_caution = [[1,False],[2,False],[3,True],[4,True]],\n                THEATRE = [ [\"#\",[[5,False],[6,False]]],\n                            [\"1\",[[6,False],[5,True]]],\n                            [\"2\",[[5,False],[6,True]]]  ] )\n\nmap_traintech_signal - Generate the mappings for a TrainTech signal\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n      base_address:int - Base address of signal (the signal will take 4 consecutive addresses)\n   Optional Parameters:\n      route_address:int - Address for the route indicator - Default = 0 (no indicator)\n      theatre_route:str - Char to be associated with the Theartre - Default = \"NONE\" (no Text)\n      feather_route:route_type - Route to be associated with feather - Default = NONE (no route)\n\nmap_semaphore_signal - Generate mappings for a semaphore signal (DCC address mapped to each arm)\n   Mandatory Parameters:\n      sig_id:int - The ID for the signal to create a DCC mapping for\n      main_signal:int     - DCC address for the main signal arm (default = No Mapping)\n   Optional Parameters:\n      main_subsidary:int  - DCC address for main subsidary arm (default = No Mapping)\n      lh1_signal:int      - DCC address for LH1 signal arm (default = No Mapping)\n      lh1_subsidary:int   - DCC address for LH1 subsidary arm (default = No Mapping)\n      lh2_signal:int      - DCC address for LH2 signal arm (default = No Mapping)\n      lh2_subsidary:int   - DCC address for LH2 subsidary arm (default = No Mapping)\n      rh1_signal:int      - DCC address for RH1 signal arm  (default = No Mapping)\n      rh1_subsidary:int   - DCC address for RH1 subsidary arm (default = No Mapping)\n      rh2_signal:int      - DCC address for RH2 signal arm  (default = No Mapping)\n      rh2_subsidary:int   - DCC address for RH2 subsidary arm (default = No Mapping)\n      THEATRE[[\"char\",[add:int,state:bool],],] - list of theatre states (default = No Mapping)\n              Each entry comprises the \"char\" and the associated list of DCC addresses/states\n              that need to be sent to get the theatre indicator to display that character.\n              \"#\" is a special character - which means inhibit all indications (when signal \n              is at danger). You should ALWAYS provide mappings for '#' if you are using a \n              theatre indicator unless the signal automatically inhibits route indications.\n\n     Semaphore signal DCC mappings assume that each main/subsidary signal arm is mapped to a \n     seperate DCC address. In this example, we are mapping a signal with MAIN and LH signal \n     arms and a subsidary arm for the MAIN route. Note that if the semaphore signal had a\n     theatre type route indication, then this would be mapped in exactly the same was as for\n     the Colour Light Signal example (above).\n\n           map_semaphore_signal (sig_id = 2, \n                                 main_signal = 1 , \n                                 lh1_signal = 2 , \n                                 main_subsidary = 3)\n\nmap_dcc_point\n   Mandatory Parameters:\n      point_id:int - The ID for the point to create a DCC mapping for\n      address:int - the single DCC address to use for the point\n   Optional Parameters:\n      state_reversed:bool - Set to True to reverse the DCC logic (default = false)\n</pre>\n\n## Loading and Saving Layout State\n\nThis enables the current configuration of the signals, points and sections on the layout to be \n\"saved\" when the application is closed and then \"loaded\" when the application is re-loaded \n(ready for the next running session)\n<pre>\nPublic Types and Functions:\n\nload_layout_state - Loads the initial state for all 'points', 'signals' and 'sections' from file\n                    and enables the save of the current layout state to file on application quit.\n                    If load is \"cancelled\" or \"file not found\" then the default state will be used.\n   Optional Parameters:\n      file_name:str - to load/save - default = None (will default to 'main-python-script.sig')\n      load_file_dialog:bool - Opens a 'load file' dialog to select a file - default = False\n      save_file_dialog:bool - Opens a 'save file' dialog on application quit - default = False\n</pre>\n\n## Pi-Sprog Interface Functions\n\nThis provides a basic CBUS interface fpor communicating with the Pi-SPROG3 via the Raspberry Pi \nUART. It does not provide a fully-functional interface for all DCC command and control functions,\njust the minimum set needed to support the driving of signals and points via a selection of common\nDCC Accessory decoders. Basic CV Programming is also supported - primarily as an aid to testing. \nFor full decoder programming the recommendation is to use JRMI DecoderPro or similar.\n<pre>\nPublic Types and Functions:\n\ninitialise_pi_sprog - Open and configures the serial comms port to the Pi Sprog\n   Optional Parameters:\n      port_name:str - The serial port to use for the Pi-SPROG 3 - Default=\"/dev/serial0\",\n      baud_rate:int - The baud rate to use for the serial port - Default = 115200,\n      dcc_debug_mode:bool - Set to 'True' to log the CBUS commands being sent to the Pi-SPROG\n                            If 'True' this initialisation function will also Request and report\n                            the command station status from the Pi-SPROG-3 (default = False). \n\nservice_mode_write_cv - programmes a CV in direct bit mode and waits for response\n                      (events are only sent if the track power is currently switched on)\n                      (request times out after 5 secs if the request was unsuccessful)\n   Mandatory Parameters:\n      cv:int - The CV (Configuration Variable) to be programmed\n      value:int - The value to programme\n\nrequest_dcc_power_on - sends request to switch on the power and waits for acknowledgement\n                 (requests only sent if the Comms Port has been successfully opened/configured)\n       returns True - if we have  acknowledgement that Track Power has been turned on\n       returns False - if the request times out (after 5 seconds)\n\nrequest_dcc_power_off - sends request to switch off the power and waits for acknowledgement\n                 (requests only sent if the Comms Port has been successfully opened/configured)\n       returns True - if we have  acknowledgement that Track Power has been turned off\n       returns False - if the request times out (after 5 seconds)\n</pre>\n\n## MQTT Networking Functions\n\nThese functions provides a basic MQTT Client interface for the Model Railway Signalling Package, \nallowing multiple signalling applications (running on different computers) to share a single \nPi-Sprog DCC interface and to share layout state and events across a MQTT broker network.\n\nFor example, you could run one signalling application on a computer without a Pi-Sprog (e.g. \na Windows Laptop), configure that node to \"publish\" its DCC command feed to the network and \nthen configure another node (this time hosted on a Raspberry Pi) to \"subscribe\" to the same \nDCC command feed and then forwarded to its local pi-Sprog DCC interface.\n\nYou can also use these features to split larger layouts into multiple signalling areas whilst \nstill being able to implement a level of automation between them. Functions are provided to \npublishing and subscribing to the \"state\" of signals (for updating signals based on the one \nahead), the \"state\" of track occupancy sections (for \"passing\" trains between signalling \napplications) and \"signal passed\" events (also for track occupancy). MQTT networking is also \nat the heart of the Block Instruments feature - allowing the different \"signalling areas\" to\ncommunicate prototypically via signalbox bell codes and block section status.\n\nTo use these networking functions, you can either set up a local MQTT broker on one of the host \ncomputers on your local network or alternatively use an 'open source' broker out there on the \ninternet - I've been using a test broker at \"mqtt.eclipseprojects.io\" (note this has no security \nor authentication).\n\nIf you do intend using an internet-based broker then it is important to configure it with an \nappropriate level of security. This package does support basic username/password authentication \nfor connecting in to the broker but note that these are NOT ENCRYPTED when sending over the \ninternet unless you are also using a SSL connection.\n<pre>\nPublic types and functions:\n\nconfigure_networking - Configures the local client and opens a connection to the MQTT broker\n  Mandatory Parameters:\n      broker_host:str - The name/IP address of the MQTT broker host to be used\n      network_identifier:str - The name to use for this signalling network (any string)\n      node_identifier:str - The name to use for this node on the network (can be any string)\n  Optional Parameters:\n      broker_port:int - The network port for the broker host (default = 1883)\n      broker_username:str - the username to log into the MQTT Broker (default = None)\n      broker_password:str - the password to log into the MQTT Broker (default = None)\n      publish_dcc_commands - NO LONGER SUPPORTED - use 'set_node_to_publish_dcc_commands'\n      mqtt_enhanced_debugging:bool - 'True' to enable additional debug logging (default = False)\n\nset_node_to_publish_dcc_commands - Enables publishing of DCC commands to other network nodes\n  Optional Parameters:\n      publish_dcc_commands:bool - 'True' to Publish / 'False' to stop publishing (default=False)\n\nsubscribe_to_dcc_command_feed - Subcribes to DCC command feed from another node on the network.\n          All received DCC commands are automatically forwarded to the local Pi-Sprog interface.\n  Mandatory Parameters:\n      *nodes:str - The name of the node publishing the feed (multiple nodes can be specified)\n\nsubscribe_to_section_updates - Subscribe to section updates from another node on the network \n  Mandatory Parameters:\n      node:str - The name of the node publishing the track section update feed\n      sec_callback:name - Function to call when an update is received from the remote node\n               Callback returns (item_identifier, section_callback_type.section_updated)\n               item_identifier is a string in the following format \"node_id-section_id\"\n      *sec_ids:int - The sections to subscribe to (multiple Section_IDs can be specified)\n\nsubscribe_to_signal_updates - Subscribe to signal updates from another node on the network \n  Mandatory Parameters:\n      node:str - The name of the node publishing the signal state feed\n      sig_callback:name - Function to call when an update is received from the remote node\n               Callback returns (item_identifier, sig_callback_type.sig_updated)\n               Item Identifier is a string in the following format \"node_id-signal_id\"\n      *sig_ids:int - The signals to subscribe to (multiple Signal_IDs can be specified)\n\nsubscribe_to_signal_passed_events  - Subscribe to signal passed events from another node  \n  Mandatory Parameters:\n      node:str - The name of the node publishing the signal passed event feed\n      sig_callback:name - Function to call when a signal passed event is received\n               Callback returns (item_identifier, sig_callback_type.sig_passed)\n               Item Identifier is a string in the following format \"node_id-signal_id\"\n      *sig_ids:int - The signals to subscribe to (multiple Signal_IDs can be specified)\n\nset_sections_to_publish_state - Enable the publication of state updates for track sections.\n               All subsequent changes will be automatically published to remote subscribers\n  Mandatory Parameters:\n      *sec_ids:int - The track sections to publish (multiple Section_IDs can be specified)\n\nset_signals_to_publish_state - Enable the publication of state updates for signals.\n               All subsequent changes will be automatically published to remote subscribers\n  Mandatory Parameters:\n      *sig_ids:int - The signals to publish (multiple Signal_IDs can be specified)\n\nset_signals_to_publish_passed_events - Enable the publication of signal passed events.\n               All subsequent events will be automatically published to remote subscribers\n  Mandatory Parameters:\n      *sig_ids:int - The signals to publish (multiple Signal_IDs can be specified)\n</pre>\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/johnrm174/model-railway-signalling",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "model-railway-signals",
    "package_url": "https://pypi.org/project/model-railway-signals/",
    "platform": "",
    "project_url": "https://pypi.org/project/model-railway-signals/",
    "project_urls": {
      "Homepage": "https://github.com/johnrm174/model-railway-signalling"
    },
    "release_url": "https://pypi.org/project/model-railway-signals/2.6.1/",
    "requires_dist": [
      "paho-mqtt",
      "pyserial"
    ],
    "requires_python": "",
    "summary": "Create your own DCC model railway signalling scheme",
    "version": "2.6.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16064626,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c8e4796fe935ff8897207c8120473223a1c097b1405ffa1de5a86d0958ca3065",
        "md5": "f6426bc817782a0def1746d5336631d7",
        "sha256": "551cd455e15c0f36482a468352a38a99e554c8eb9771d5c9b9ff7cd831c39e34"
      },
      "downloads": -1,
      "filename": "model_railway_signals-2.6.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "f6426bc817782a0def1746d5336631d7",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 97290,
      "upload_time": "2022-01-22T11:15:38",
      "upload_time_iso_8601": "2022-01-22T11:15:38.109147Z",
      "url": "https://files.pythonhosted.org/packages/c8/e4/796fe935ff8897207c8120473223a1c097b1405ffa1de5a86d0958ca3065/model_railway_signals-2.6.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "31afa858ff78efefd9f1089705315ee43e19148e72b75ac5de95e1b29bb860f7",
        "md5": "e1c140803bbb6bf6cc64c20761f69f79",
        "sha256": "da552b2d3641065b5f01a206107793e99533b85368dbdc449e31c890cbce8c83"
      },
      "downloads": -1,
      "filename": "model-railway-signals-2.6.1.tar.gz",
      "has_sig": false,
      "md5_digest": "e1c140803bbb6bf6cc64c20761f69f79",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 107590,
      "upload_time": "2022-01-22T11:15:41",
      "upload_time_iso_8601": "2022-01-22T11:15:41.080369Z",
      "url": "https://files.pythonhosted.org/packages/31/af/a858ff78efefd9f1089705315ee43e19148e72b75ac5de95e1b29bb860f7/model-railway-signals-2.6.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}