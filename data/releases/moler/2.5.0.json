{
  "info": {
    "author": "Nokia",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Environment :: Console",
      "Intended Audience :: Developers",
      "Intended Audience :: System Administrators",
      "Intended Audience :: Telecommunications Industry",
      "License :: OSI Approved :: BSD License",
      "Operating System :: POSIX",
      "Operating System :: Unix",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Software Development",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Testing",
      "Topic :: System :: Networking"
    ],
    "description": "[![image](https://img.shields.io/badge/pypi-v2.1.0-blue.svg)](https://pypi.org/project/moler/)\n[![image](https://img.shields.io/badge/python-2.7%20%7C%203.6%20%7C%203.7%20%7C%203.8-blue.svg)](https://pypi.org/project/moler/)\n[![Build Status](https://travis-ci.org/nokia/moler.svg?branch=master)](https://travis-ci.org/nokia/moler)\n[![Coverage Status](https://coveralls.io/repos/github/nokia/moler/badge.svg?branch=master)](https://coveralls.io/github/nokia/moler?branch=master)\n[![BCH compliance](https://bettercodehub.com/edge/badge/nokia/moler?branch=master)](https://bettercodehub.com/)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/355afc9110f34d549b7c08c33961827c)](https://www.codacy.com/app/mplichta/moler?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=nokia/moler&amp;utm_campaign=Badge_Grade)\n[![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](./LICENSE)\n\n# Table of Contents\n1. [Changelog](#changelog)\n2. [Moler info](#moler)\n3. [Moler usage examples](#moler-usage-examples)\n4. [API design reasoning](#api-design-reasoning)\n5. [Designed API](#designed-api)\n\n# Changelog\nView our [chronological list](./CHANGELOG.md) of user-facing changes, large and small, made to the Moler project.\n\n![moler logo](https://i.imgur.com/mkPutdC.png)\n# Moler\nMoler ([name origin](https://github.com/nokia/moler/wiki#moler-name-origin)) is Python library\nthat provides \"bricks\" for building  automated tests.\nAll these \"bricks\" have clearly defined responsibilities, have similar API,\nfollow same construction pattern (so new ones are easy to create).\n\nHere they are:\n* Commands as self-reliant object\n  * to allow for command triggering and parsing encapsulated in single object (lower maintenance cost)\n* Event observers & callbacks (alarms are events example)\n  * to allow for online reaction (not offline postprocessing)\n* Run observers/commands in the background\n  * to allow for test logic decomposition into multiple commands running in parallel\n  * to allow for handling unexpected system behavior (reboots, alarms)\n* State machines -> automatic auto-connecting after dropped connection\n  * to increase framework auto-recovery and help in troubleshooting \"what went wrong\"\n* Automatic logging of all connections towards devices used by tests\n  * to decrease investigation time by having logs focused on different parts of system under test\n\n# Moler usage examples\nLet's see Moler in action. Here is hypothetical use case: \"find PIDs of all python processes\":\n\n```python\n\n    from moler.config import load_config\n    from moler.device.device import DeviceFactory\n\n    load_config(config='my_devices.yml')                    # description of available devices\n    my_unix = DeviceFactory.get_device(name='MyMachine')    # take specific device out of available ones\n    ps_cmd = my_unix.get_cmd(cmd_name=\"ps\",                 # take command of that device\n                             cmd_params={\"options\": \"-ef\"})\n\n    processes_info = ps_cmd()                               # run the command, it returns result\n    for proc_info in processes_info:\n        if 'python' in proc_info['CMD']:\n            print(\"PID: {info[PID]} CMD: {info[CMD]}\".format(info=proc_info))\n```\n\n* To have command we ask device \"give me such command\".\n* To run command we just call it as function (command object is callable)\n* What command returns is usually dict or list of dicts - easy to process\n\nAbove code displays:\n\n```bash\n\n    PID: 1817 CMD: /usr/bin/python /usr/share/system-config-printer/applet.py\n    PID: 21825 CMD: /usr/bin/python /home/gl/moler/examples/command/unix_ps.py\n```\n\nHow does it know what `'MyMachine'` means? Code loads definition from `my_devices.yml` configuration file:\n\n```yaml\n\n    DEVICES:\n\n      MyMachine:\n        DEVICE_CLASS: moler.device.unixlocal.UnixLocal\n\n      RebexTestMachine:\n        DEVICE_CLASS: moler.device.unixremote.UnixRemote\n        CONNECTION_HOPS:\n          UNIX_LOCAL:                # from state\n            UNIX_REMOTE:             # to state\n              execute_command: ssh   # via command\n              command_params:        # with params\n                expected_prompt: demo@\n                host: test.rebex.net\n                login: demo\n                password: password\n                set_timeout: False   # remote doesn't support: export TMOUT\n```\n\nWe have remote machine in our config. Let's check if there is 'readme.txt' file\non that machine (and some info about the file):\n\n```python\n\n    remote_unix = DeviceFactory.get_device(name='RebexTestMachine')  # it starts in local shell\n    remote_unix.goto_state(state=\"UNIX_REMOTE\")                      # make it go to remote shell\n\n    ls_cmd = remote_unix.get_cmd(cmd_name=\"ls\", cmd_params={\"options\": \"-l\"})\n\n    remote_files = ls_cmd()\n\n    if 'readme.txt' in remote_files['files']:\n        print(\"readme.txt file:\")\n        readme_file_info = remote_files['files']['readme.txt']\n        for attr in readme_file_info:\n            print(\"  {:<18}: {}\".format(attr, readme_file_info[attr]))\n```\n\nAs you may noticed device is state machine. State transitions are defined inside\nconfiguration file under `CONNECTION_HOPS`. Please note, that it is only config file who\nknows \"I need to use ssh to be on remote\" - client code just says \"go to remote\".\nThanks to that you can exchange \"how to reach remote\" without any change in main code.\n\nAbove code displays:\n\n```bash\n\n    readme.txt file:\n      permissions       : -rw-------\n      hard_links_count  : 1\n      owner             : demo\n      group             : users\n      size_raw          : 403\n      size_bytes        : 403\n      date              : Apr 08  2014\n      name              : readme.txt\n```\n\nHow about doing multiple things in parallel. Let's ping google\nwhile asking test.rebex.net about readme.txt file:\n\n```python\nmy_unix = DeviceFactory.get_device(name='MyMachine')\nhost = 'www.google.com'\nping_cmd = my_unix.get_cmd(cmd_name=\"ping\", cmd_params={\"destination\": host, \"options\": \"-w 6\"})\n\nremote_unix = DeviceFactory.get_device(name='RebexTestMachine')\nremote_unix.goto_state(state=\"UNIX_REMOTE\")\nls_cmd = remote_unix.get_cmd(cmd_name=\"ls\", cmd_params={\"options\": \"-l\"})\n\nprint(\"Start pinging {} ...\".format(host))\nping_cmd.start()                                # run command in background\nprint(\"Let's check readme.txt at {} while pinging {} ...\".format(remote_unix.name, host))\n\nremote_files = ls_cmd()                         # foreground \"run in the meantime\"\nfile_info = remote_files['files']['readme.txt']\nprint(\"readme.txt file: owner={fi[owner]}, size={fi[size_bytes]}\".format(fi=file_info))\n\nping_stats = ping_cmd.await_done(timeout=6)     # await background command\nprint(\"ping {}: {}={}, {}={} [{}]\".format(host,'packet_loss',\n                                          ping_stats['packet_loss'],\n                                          'time_avg',\n                                          ping_stats['time_avg'],\n                                          ping_stats['time_unit']))\n```\n\n```log\nStart pinging www.google.com ...\nLet's check readme.txt at RebexTestMachine while pinging www.google.com ...\nreadme.txt file: owner=demo, size=403\nping www.google.com: packet_loss=0, time_avg=35.251 [ms]\n```\n\nBesides being callable command-object works as \"Future\" (result promise).\nYou can start it in background and later await till it is done to grab result.\n\nIf we enhance our configuration with logging related info:\n\n```yaml\n    LOGGER:\n      PATH: ./logs\n      DATE_FORMAT: \"%H:%M:%S\"\n```\n\nthen above code will automatically create Molers' main log (`moler.log`)\nwhich shows activity on all devices:\n\n```log\n22:30:19.723 INFO       moler               |More logs in: ./logs\n22:30:19.747 INFO       MyMachine           |Connection to: 'MyMachine' has been opened.\n22:30:19.748 INFO       MyMachine           |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'\n22:30:19.866 INFO       MyMachine           |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.\n22:30:19.901 INFO       RebexTestMachine    |Connection to: 'RebexTestMachine' has been opened.\n22:30:19.901 INFO       RebexTestMachine    |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'\n22:30:19.919 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('demo@')]' started.\n22:30:19.920 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.\n22:30:19.921 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ssh.Ssh':'TERM=xterm-mono ssh -l demo test.rebex.net' started.\n22:30:19.921 INFO       RebexTestMachine    |TERM=xterm-mono ssh -l demo test.rebex.net\n22:30:20.763 INFO       RebexTestMachine    |*********\n22:30:20.909 INFO       RebexTestMachine    |Changed state from 'UNIX_LOCAL' into 'UNIX_REMOTE'\n22:30:20.917 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ssh.Ssh' finished.\n22:30:20.919 INFO       MyMachine           |Command 'moler.cmd.unix.ping.Ping':'ping www.google.com -w 6' started.\n22:30:20.920 INFO       MyMachine           |ping www.google.com -w 6\n22:30:20.920 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ls.Ls':'ls -l' started.\n22:30:20.922 INFO       RebexTestMachine    |ls -l\n22:30:20.985 INFO       RebexTestMachine    |Command 'moler.cmd.unix.ls.Ls' finished.\n22:30:26.968 INFO       MyMachine           |Command 'moler.cmd.unix.ping.Ping' finished.\n22:30:26.992 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.\n22:30:27.011 INFO       RebexTestMachine    |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('demo@')]' finished.\n22:30:27.032 INFO       MyMachine           |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.\n\n```\n\nAs you may noticed main log shows code progress from high-level view - data\non connections are not visible, just activity of commands running on devices.\n\nIf you want to see in details what has happened on each device - you have it in device logs.\nMoler creates log per each device\n`moler.RebexTestMachine.log`:\n\n```log\n22:30:19.901  |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'\n22:30:19.902 <|\n22:30:19.919  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('demo@')]' started.\n22:30:19.920  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.\n22:30:19.921  |Command 'moler.cmd.unix.ssh.Ssh':'TERM=xterm-mono ssh -l demo test.rebex.net' started.\n22:30:19.921 >|TERM=xterm-mono ssh -l demo test.rebex.net\n\n22:30:19.924 <|TERM=xterm-mono ssh -l demo test.rebex.net\n\n22:30:20.762 <|Password:\n22:30:20.763 >|*********\n22:30:20.763 <|\n\n22:30:20.908 <|Welcome to Rebex Virtual Shell!\n              |For a list of supported commands, type 'help'.\n              |demo@ETNA:/$\n22:30:20.909  |Changed state from 'UNIX_LOCAL' into 'UNIX_REMOTE'\n22:30:20.917  |Command 'moler.cmd.unix.ssh.Ssh' finished.\n22:30:20.920  |Command 'moler.cmd.unix.ls.Ls':'ls -l' started.\n22:30:20.922 >|ls -l\n\n22:30:20.974 <|ls -l\n\n22:30:20.978 <|drwx------ 2 demo users          0 Jul 26  2017 .\n\n22:30:20.979 <|drwx------ 2 demo users          0 Jul 26  2017 ..\n              |drwx------ 2 demo users          0 Dec 03  2015 aspnet_client\n              |drwx------ 2 demo users          0 Oct 27  2015 pub\n              |-rw------- 1 demo users        403 Apr 08  2014 readme.txt\n              |demo@ETNA:/$\n22:30:20.985  |Command 'moler.cmd.unix.ls.Ls' finished.\n22:30:26.992  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.\n22:30:27.011  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('demo@')]' finished.\n```\n\nand `moler.MyMachine.log`:\n\n```log\n22:30:19.748  |Changed state from 'NOT_CONNECTED' into 'UNIX_LOCAL'\n22:30:19.748 <|\n22:30:19.866  |Event 'moler.events.unix.wait4prompt.Wait4prompt':'[re.compile('^moler_bash#')]' started.\n22:30:20.919  |Command 'moler.cmd.unix.ping.Ping':'ping www.google.com -w 6' started.\n22:30:20.920 >|ping www.google.com -w 6\n\n22:30:20.921 <|ping www.google.com -w 6\n\n22:30:20.959 <|PING www.google.com (216.58.215.68) 56(84) bytes of data.\n22:30:20.960 <|\n\n22:30:21.000 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=1 ttl=51 time=40.1 ms\n22:30:21.001 <|\n\n22:30:21.992 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=2 ttl=51 time=31.0 ms\n\n22:30:22.999 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=3 ttl=51 time=36.5 ms\n\n22:30:23.996 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=4 ttl=51 time=31.4 ms\n\n22:30:24.996 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=5 ttl=51 time=29.8 ms\n\n22:30:26.010 <|64 bytes from waw02s16-in-f4.1e100.net (216.58.215.68): icmp_seq=6 ttl=51 time=42.4 ms\n\n22:30:26.960 <|\n              |--- www.google.com ping statistics ---\n              |6 packets transmitted, 6 received, 0% packet loss, time 5007ms\n              |rtt min/avg/max/mdev = 29.888/35.251/42.405/4.786 ms\n              |moler_bash#\n22:30:26.968  |Command 'moler.cmd.unix.ping.Ping' finished.\n22:30:27.032  |Event 'moler.events.unix.wait4prompt.Wait4prompt': '[re.compile('^moler_bash#')]' finished.\n```\n\nIf the log files are too large you can split files.\n\nThe log files can be split by size. For example let's assume we want split log files by 5 MB (5242880 bytes) and we want\nto keep maximum 999 files:\n```yaml\n    LOGGER:\n      PATH: ./logs\n      DATE_FORMAT: \"%H:%M:%S\"\n      LOG_ROTATION:\n        KIND: size\n        INTERVAL: 5242880\n        BACKUP_COUNT: 999  # Default value\n\n\n```\n\nThe log files can be split by time. For example let's assume we want split log files every 30 minutes (1800 seconds)\n and we want to keep maximum 999 files (default value):\n\n```yaml\n    LOGGER:\n      PATH: ./logs\n      DATE_FORMAT: \"%H:%M:%S\"\n      LOG_ROTATION:\n        KIND: time\n        INTERVAL: 1800\n        BACKUP_COUNT: 999  # Default value\n```\n\nFor space saving Moler can compress the logs after rotation. The external tool is used. Let's use the above examples\nto show how to compress logs:\n\n```yaml\n    LOGGER:\n      PATH: ./logs\n      DATE_FORMAT: \"%H:%M:%S\"\n      LOG_ROTATION:\n        KIND: size\n        INTERVAL: 5242880\n        BACKUP_COUNT: 999  # Default value\n        COMPRESS_AFTER_ROTATION: True  # Default is False\n        COMPRESS_COMMAND: \"zip -9mq {compressed} {log_input}\"  # Default value\n        COMPRESSED_FILE_EXTENSION: \".zip\"  # Default value\n\n\n```\n\n```yaml\n    LOGGER:\n      PATH: ./logs\n      DATE_FORMAT: \"%H:%M:%S\"\n      LOG_ROTATION:\n        KIND: time\n        INTERVAL: 1800\n        BACKUP_COUNT: 999  # Default value\n        COMPRESS_COMMAND: \"zip -9mq {compressed} {log_input}\"  # Default value      \n        COMPRESSED_FILE_EXTENSION: \".zip\"  # Default value\n```\n\nIn a script we can also disable logging from device. Please use it very carefully. Investigation any issue may be\n impossible if we don't have full logs.\n\n```python\nmy_unix = DeviceFactory.get_device(name='MyMachine')\n\nmy_unix.disbale_logging()  # to disable logging on device\n\nmy_unix.enable_logging()  # to enable logging on device\n```\n\nIn a script you can add suffix to all log files or only to files for specific devices. with disable logging from device. \n\n```python\nfrom moler.config.loggers import change_logging_suffix\nchange_logging_suffix(\".suffix1\")  # all log files with suffix\nchange_logging_suffix(None)  # all log files without suffx\n\nmy_unix = DeviceFactory.get_device(name='MyMachine')\n\nmy_unix.set_logging_suffix(\"device_suffix\")  # to add suffix to filename with logs\n\nmy_unix.set_suffix(None)  # to remove suffix from filename with logs\n```\n\nPrevious examples ask device to create command. We can also create command ourselves\ngiving it connection to operate on:\n\n```python\n\n    import time\n    from moler.cmd.unix.ping import Ping\n    from moler.connection_factory import get_connection\n\n    host = 'www.google.com'\n    terminal = get_connection(io_type='terminal', variant='threaded')  # take connection\n    with terminal.open():\n        ping_cmd = Ping(connection=terminal.moler_connection,\n                        destination=host, options=\"-w 6\")\n        print(\"Start pinging {} ...\".format(host))\n        ping_cmd.start()\n        print(\"Doing other stuff while pinging {} ...\".format(host))\n        time.sleep(3)\n        ping_stats = ping_cmd.await_done(timeout=4)\n        print(\"ping {}: {}={}, {}={} [{}]\".format(host,'packet_loss',\n                                                  ping_stats['packet_loss'],\n                                                  'time_avg',\n                                                  ping_stats['time_avg'],\n                                                  ping_stats['time_unit']))\n```\n\nPlease note also that connection is context manager doing open/close actions.\n\n\n```bash\n\n    Start pinging www.google.com ...\n    Doing other stuff while pinging www.google.com ...\n    ping www.google.com: packet_loss=0, time_avg=50.000 [ms]\n```\n\n## Reuse freedom\nLibrary gives you freedom which part you want to reuse. We are fan's of \"take what you need only\".\n* You may use configuration files or configure things by Python calls.\n\n   ```python\n   load_config(config={'DEVICES': {'MyMachine': {'DEVICE_CLASS': 'moler.device.unixlocal.UnixLocal'}}})\n   ```\n* You may use devices or create commands manually\n* You can take connection or build it yourself:\n\n   ```python\n   from moler.threaded_moler_connection import ThreadedMolerConnection\n   from moler.io.raw.terminal import ThreadedTerminal\n\n   terminal_connection = ThreadedTerminal(moler_connection=ThreadedMolerConnection())\n   ```\n* You can even install your own implementation in place of default implementation per connection type\n\n# API design reasoning\nThe main goal of command is its usage simplicity: just run it and give me back its result.\n\nCommand hides from its caller:\n* a way how it realizes \"runs\"\n* how it gets data of output to be parsed\n* how it parses that data\n\nCommand shows to its caller:\n* API to start/stop it or await for its completion\n* API to query for its result or result readiness\n\nCommand works as [Futures and promises](https://en.wikipedia.org/wiki/Futures_and_promises)\n\nAfter starting, we await for its result which is parsed out command output provided usually as dict.\nRunning that command and parsing its output may take some time, so till that point result computation is yet incomplete.\n\n## Command as future\n* it starts some command on device/shell over connection\n  (as future-function starts it's execution)\n* it parses data incoming over such connection\n  (as future-function does it's processing)\n* it stores result of that parsing\n  (as future-function concludes in calculation result)\n* it provides means to return that result\n  (as future-function does via 'return' or 'yield' statement)\n* it's result is not ready \"just-after\" calling command\n  (as it is with future in contrast to function)\n\nSo command should have future API.\n\nQuote from **_\"Professional Python\"_** by **Luke Sneeringer**:\n> The Future is a standalone object. It is independent of the actual function that is running.\n> It does nothing but store the state and result information.\n\nCommand differs in that it is both:\n* function-like object performing computation\n* future-like object storing result of that computation.\n\n## Command vs. Connection-observer\nCommand is just \"active version\" of connection observer.\n\nConnection observer is passive since it just observes connection for some data;\ndata that may just asynchronously appear (alarms, reboots or anything you want).\nIntention here is split of responsibility: one observer is looking for alarms,\nanother one for reboots.\n\nCommand is active since it actively triggers some output on connection\nby sending command-string over that connection. So, it activates some action\non device-behind-connection. That action is \"command\" in device terminology.\nLike `ping` on bash console/device. And it produces that \"command\" output.\nThat output is what Moler's Command as connection-observer is looking for.\n\n## Most well known Python's futures\n* [concurrent.futures.Future](https://docs.python.org/3/library/concurrent.futures.html)\n* [asyncio.Future](https://docs.python.org/3/library/asyncio-task.html#future)\n\n| API                     | concurrent.futures.Future                   | asyncio.Future                                      |\n| :---------------------- | :------------------------------------------ | :-------------------------------------------------- |\n| storing result          | :white_check_mark: `set_result()`           | :white_check_mark: `set_result()`                   |\n| result retrieval        | :white_check_mark: `result()`               | :white_check_mark: `result()`                       |\n| storing failure cause   | :white_check_mark: `set_exception()`        | :white_check_mark: `set_exception()`                |\n| failure cause retrieval | :white_check_mark: `exception()`            | :white_check_mark: `exception()`                    |\n| stopping                | :white_check_mark: `cancel()`               | :white_check_mark: `cancel()`                       |\n| check if stopped        | :white_check_mark: `cancelled()`            | :white_check_mark: `cancelled()`                    |\n| check if running        | :white_check_mark: `running()`              | :no_entry_sign: `(but AbstractEventLoop.running())` |\n| check if completed      | :white_check_mark: `done()`                 | :white_check_mark: `done()`                         |\n| subscribe completion    | :white_check_mark: `add_done_callback()`    | :white_check_mark: `add_done_callback()`            |\n| unsubscribe completion  | :no_entry_sign:                             | :white_check_mark: `remove_done_callback()`         |\n\nStarting callable to be run \"as future\" is done by entities external to future-object\n\n| API              | concurrent.futures<br>start via Executor objects (thread/proc) | asyncio<br>start via module-lvl functions or ev-loop |\n| ---------------- | ---------------------------------------- | ---------------------------------------------- |\n| start callable   | submit(fn, *args, **kwargs)<br>Schedules callable to be executed as<br>fn(*args **kwargs) -> Future | ensure_future(coro_or_future) -> Task<br>future = run_coroutine_threadsafe(coro, loop) |\n| start same callable<br>on data iterator | map(fn, *iterables, timeout) -> iterator | join_future = asyncio.gather(*map(f, iterable))<br>loop.run_until_complete(join_future)|\n\nAwaiting completion of future is done by entities external to future-object\n\n| API               | concurrent.futures<br>awaiting by module level functions | asyncio<br>awaiting by module-lvl functions or ev-loop |\n| ----------------- | ------------------------------------------ | -------------------------------------------- |\n| await completion  |  done, not_done = wait(futures, timeout) -> futures | done, not_done = await wait(futures)<br>results = await gather(futures)<br>result = await future<br>result = yield from future<br>result = await coroutine<br>result = yield from coroutine<br>result = yield from wait_for(future, timeout)<br>loop.run_until_complete(future) -> blocking run |\n| process as they<br>complete | for done in as_completed(futures, timeout) -> futures | for done in as_completed(futures, timeout) -> futures |\n\n## Fundamental difference of command\nContrary to **concurrent.futures** and **asyncio** we don't want command to be run by some external entity.\nWe want it to be self-executable for usage simplicity.\nWe want to take command and just say to it:\n* **\"run\"** or **\"run in background\"**\n* and not **\"Hi, external runner, would you run/run-background that command for me\"**\n\n# Designed API\n1. create command object\n``` python\ncommand = Command()\n```\n\n2. run it synchronously/blocking and get result in one shot behaves like function call since Command is callable.\n\nRun-as-callable gives big advantage since it fits well in python ecosystem.\n``` python\nresult = command()\n```\nfunction example:\n``` python\nmap(ping_cmd, all_machines_to_validate_reachability)\n```\n\n3. run it asynchronously/nonblocking\n``` python\ncommand_as_future = command.start()\n```\n\n4. shift from background to foreground\n\n**asyncio:** variant looks like:\n``` python\nresult = await future\ndone_futures, pending = yield from asyncio.wait(futures)\nresult = yield from asyncio.wait_for(future, 60.0)\n```\nand **concurrent.futures** variant looks like:\n``` python\ndone_futures, pending = wait(futures)\n```\nMoler's API maps to above well-known API\n``` python\nresult = command.await_done(timeout)\n```\n* it is \"internal\" to command \"Hi command, that is what I want from you\" (above APIs say \"Hi you there, that is what I want you to do with command\")\n* it directly (Zen of Python) shows what we are awaiting for\n* timeout is required parameter (not as in concurrent.futures) since we don't expect endless execution of command (user must know what is worst case timeout to await command completion)\n\n# Video introduction\nYou can [watch videos how to use Moler on YouTube](https://www.youtube.com/channel/UCgToo2qq8kLMyEgzd4btM9g). \n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/nokia/moler",
    "keywords": "testing development",
    "license": "BSD 3-Clause",
    "maintainer": "",
    "maintainer_email": "",
    "name": "moler",
    "package_url": "https://pypi.org/project/moler/",
    "platform": null,
    "project_url": "https://pypi.org/project/moler/",
    "project_urls": {
      "Bug Reports": "https://github.com/nokia/moler/issues",
      "Homepage": "https://github.com/nokia/moler",
      "Source": "https://github.com/nokia/moler"
    },
    "release_url": "https://pypi.org/project/moler/2.5.0/",
    "requires_dist": [
      "pyyaml (>=5.1)",
      "six",
      "transitions",
      "psutil",
      "python-dateutil",
      "pyserial",
      "cryptography",
      "paramiko",
      "ptyprocess ; platform_system != \"Windows\"",
      "apscheduler (==3.8.1) ; python_version < \"3\"",
      "trollius ; python_version < \"3\"",
      "deepdiff (==3.3.0) ; python_version < \"3.5\"",
      "futures (>=3.0.0) ; python_version == \"2.7\"",
      "apscheduler ; python_version > \"3\"",
      "deepdiff (==5.0.2) ; python_version >= \"3.5\" and python_version < \"3.6\"",
      "deepdiff (==5.7.0) ; python_version >= \"3.6\" and python_version < \"3.7\"",
      "deepdiff ; python_version >= \"3.7\""
    ],
    "requires_python": "",
    "summary": "Moler is library to help in building automated tests",
    "version": "2.5.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16957170,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "111c031a1ca507b750dbf12174c82ee14105f0289266087c3e2ca6e3408452a1",
        "md5": "232e3117ec43d9f90a06cdfb9ffcbbce",
        "sha256": "7e8a85b38b478835408e5c85c59bc111136fd8aeead21649eb7db918de07b70b"
      },
      "downloads": -1,
      "filename": "moler-2.5.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "232e3117ec43d9f90a06cdfb9ffcbbce",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 544705,
      "upload_time": "2022-10-03T07:00:32",
      "upload_time_iso_8601": "2022-10-03T07:00:32.948960Z",
      "url": "https://files.pythonhosted.org/packages/11/1c/031a1ca507b750dbf12174c82ee14105f0289266087c3e2ca6e3408452a1/moler-2.5.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "789ff7d0a60358a661ddc14ee0e61ffb2b88687cc01285d78c4537d462104e7e",
        "md5": "459049569ff391fa3e1d9cd59040ff8f",
        "sha256": "44a30605ec989e40b305b58d11f81245b6c6824ac0c2f05abd94613ad3497b44"
      },
      "downloads": -1,
      "filename": "moler-2.5.0.tar.gz",
      "has_sig": false,
      "md5_digest": "459049569ff391fa3e1d9cd59040ff8f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 394714,
      "upload_time": "2022-10-03T07:00:36",
      "upload_time_iso_8601": "2022-10-03T07:00:36.196376Z",
      "url": "https://files.pythonhosted.org/packages/78/9f/f7d0a60358a661ddc14ee0e61ffb2b88687cc01285d78c4537d462104e7e/moler-2.5.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}