{
  "info": {
    "author": "Przemyslaw Wirkus, Azim Khan, Stefan Gutmann",
    "author_email": "Przemyslaw.Wirkus@arm.com, Azim.Khan@arm.com, Stefan.Gutmann@arm.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "[![Circle CI](https://circleci.com/gh/ARMmbed/htrun.svg?style=svg)](https://circleci.com/gh/ARMmbed/htrun)\n[![Coverage Status](https://coveralls.io/repos/github/ARMmbed/htrun/badge.svg?branch=master)](https://coveralls.io/github/ARMmbed/htrun?branch=master)\n[![PyPI version](https://badge.fury.io/py/mbed-host-tests.svg)](https://badge.fury.io/py/mbed-host-tests)\n\n# Table of contents\n\n* [Table of contents](#table-of-contents)\n* [Quickstart](#quickstart)\n  * [Command line overview](#command-line-overview)\n  * [Useful command line end-to-end examples](#useful-command-line-end-to-end-examples)\n    * [Flashing phase operations](#flashing-phase-operations)\n    * [DUT-host communication and reset phase](#dut-host-communication-and-reset-phase)\n    * [Global Resource Manager connection](#global-resource-manager-connection)\n    * [Miscellaneous](#miscellaneous)\n* [Installation](#installation)\n  * [Installation from PyPI (Python Package Index)](#installation-from-pypi-python-package-index)\n  * [Installation from Python sources](#installation-from-python-sources)\n    * [Checking installation](#checking-installation)\n* [mbed-host-tests](#mbed-host-tests)\n  * [Key-value protocol overview](#key-value-protocol-overview)\n  * [Design draft](#design-draft)\n* [Greentea client API](#greentea-client-api)\n* [Key-value transport protocol sequence](#key-value-transport-protocol-sequence)\n  * [Handshake](#handshake)\n  * [Preamble exchange](#preamble-exchange)\n  * [Event exchange](#event-exchange)\n* [DUT - host test case workflow](#dut---host-test-case-workflow)\n  * [DUT implementation](#dut-implementation)\n  * [Example of corresponding host test](#example-of-corresponding-host-test)\n* [Host test examples](#host-test-examples)\n  * [Return result after __exit](#return-result-after-__exit)\n* [Writing DUT test suite (slave side)](#writing-dut-test-suite-slave-side)\n  * [DUT test suite with single test case](#dut-test-suite-with-single-test-case)\n    * [DUT always finishes execution](#dut-always-finishes-execution)\n    * [DUT test suite never finishes execution](#dut-test-suite-never-finishes-execution)\n    * [DUT test suite with ```utest``` harness](#dut-test-suite-with-utest-harness)\n* [Writing host tests (master side)](#writing-host-tests-master-side)\n  * [Callbacks](#callbacks)\n    * [Callback registration in setup() method](#callback-registration-in-setup-method)\n    * [Callback decorator definition](#callback-decorator-definition)\n    * [Parsing text received from DUT (line by line)](#parsing-text-received-from-dut-line-by-line)\n      * [Before Greentea v0.2.0](#before-greentea-v020)\n      * [Using __rdx_line event](#using-__rdx_line-event)\n  * [ ```htrun``` new log format:](#-htrun-new-log-format)\n    * [Log example](#log-example)\n* [End-to-end examples](#end-to-end-examples)\n\n# Quickstart\n\n`htrun` has extensive command line. In most cases `htrun` (or its command line avatar `mbedhtrun`) will be run in background:\n* driving test binary flashing,\n* device reset and\n* test execution.\n\nDefault binary flashing method is one supported by [mbed-enabled](https://www.mbed.com/en/about-mbed/mbed-enabled/) devices: binary file is copied on mbed-enabled DUT (Device Under Test) mounted drive (MSD). This procedure will automatically flash device with given binary file content.\n\nDefault DUT reset method is one supported by [mbed-enabled](https://www.mbed.com/en/about-mbed/mbed-enabled/) devices: serial port (CDC) \"*sendBreak*\" command resets target MCU on mbed-enabled platform.\n\nTest execution phase will consist of:\n* Opening connection between host computer and DUT,\n* DUT will send to host preamble with test runner information such as:\n  * test environment version,\n  * test timeout,\n  * preferred host test script (Python script which is used to supervise/instrument test execution),\n* Host will spawn host test script and test execution will be instrumented\n* Exchange data (in most cases text) between host and DUT,\n\n\n## Command line overview\n\nThis chapter will present few examples of how you can use `mbedhtrun` command line to execute tests. In most cases test automation tools such as [Greentea](https://github.com/ARMmbed/greentea) will execute `mbedhtrun` implicitly. There are cases when we want to execute `mbedhtrun` independently. Mostly in situation when we want to:\n* debug our code and have binary + host test instrumentation on,\n* prototype or\n* just want to replace test runner in another OS with one compatible with mbed-enabled devices.\n\nAll `mbedhtrun` needs is name of the binary you want to flash and method of flashing!\n\n## Useful command line end-to-end examples\n\n### Flashing phase operations\n\nFlash binary file `/path/to/file/binary.bin` using mount point `D:`. Use serial port `COM4` to communicate with DUT:\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4\n```\n\nFlash (use shell command `copy`) binary file `/path/to/file/binary.bin` using mount point `D:`. Use serial port `COM4` to communicate with DUT:\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4 -c copy\n```\n\nSkip flashing phase (e.g. you've already flashed this device with `/path/to/file/binary.bin` binary). Use serial port `COM4` to communicate with DUT:\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4 --skip-flashing\n```\n\n### DUT-host communication and reset phase\n\nFlash binary file `/path/to/file/binary.bin` using mount point `D:`. Use serial port `COM4` with baudrate `115200` to communicate with DUT:\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4:115200\n```\n\nAs above but we will skip reset phase (non so common but in some cases can be used to suppress reset phase for some reasons):\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4:115200 --skip-reset\n```\n\nFlash binary file `/path/to/file/binary.bin` using mount point `D:`. Use serial port `COM4` with default baudrate to communicate with DUT. Do not send `__sync` key-value protocol synchronization packet to DUT before preamble read:\n```\n$ mbedhtrun -f /path/to/file/binary.bin -d D: -p COM4 --sync=0\n```\n\n**Note**: Sync packet management allows you to manipulate the way `htrun` sends `__sync` packet(s) to DUT. With current settings we can force on `htrun` to send `__sync` packets in this manner:\n* `--sync=0` - No sync packets will be sent to DUT.\n* `--sync=-1`- `__sync` packets will be sent unless we will reach timeout or proper response is sent from DUT.\n* `--sync=N` - Where N is integer > 0. Send up to N `__sync` packets to target platform. Response is sent unless we get response from target platform or timeout occurs.\n\n### Global Resource Manager connection\n\nFlash local file `/path/to/file/binary.bin` to remote device resource (platform `K64F`) provided by `remote_client` GRM service available on IP address `10.2.203.31` and port: `8000`. Force serial port connection to remote device `9600` with baudrate:\n```\n$ mbedhtrun -p :9600 -f /path/to/file/binary.bin -m K64F --grm remote_client:10.2.203.31:8000\n```\n\nCommand line switch `--grm` has format: `<module_name>:<IP_address>:<port_number>`.\n  * `<module_name>` - name of Python module to load as remote resource manager.\n  * `<IP_address>` and `<port_number>` - IP address and port of remote resource manager.\n\n**Note**: Switch -m <platform_name> is required to tell Global Resource Management which platform to request.\n**Note**: Command line switch `--grm` implicitly forces `--skip-flashing` and `--skip-reset` because both flags are used for locally available DUTs.\n\n### Miscellaneous\n\nList available host tests names, class names and origin:\n```\n$ mbedhtrun --list\n```\n\nList available host tests names, class names and origin. Load additional host tests from `/path/to/host_tests` directory:\n```\n$ mbedhtrun --list -e /path/to/host_tests\n```\n\nList available reset and flashing plugins:\n```\n$ mbedhtrun --plugins\n```\n\n# Installation\n\n`htrun` is redistributed with sources, as Python 2.7 compatible module called `mbed-host-tests` and command line tool called `mbedhtrun`.\n\n## Installation from PyPI (Python Package Index)\n`mbed-host-tests` module is redistributed via PyPI. We recommend you use the [application pip](https://pip.pypa.io/en/latest/installing.html#install-pip).\n\n**Note:** Python 2.7.9 onwards include ```pip``` by default, so you may have ```pip``` already.\n**Note:** `mbed-host-tests` module is redistributed with `mbed-greentea` module as a dependency. So if you've already installed Greentea `mbed-host-tests` should be there!\n\nTo install mbed-ls from [PyPI](https://pypi.python.org/pypi/mbed-host-tests) use command:\n```\n$ pip install mbed-host-tests --upgrade\n```\n\n## Installation from Python sources\nTo install the mbed test suite, first clone the `htrun` repository:\n```\n$ git clone https://github.com/ARMmbed/htrun.git\n```\n\nChange the directory to the `htrun` directory:\n```\n$ cd htrun\n```\n\nNow you are ready to install `htrun`:\n```\n$ python setup.py install\n```\n\nOn Linux, if you have a problem with permissions, use `sudo`:\n```\n$ sudo python setup.py install\n```\n\n### Checking installation\nTo check whether the installation was successful try running the ```mbedgt --help``` command and check that it returns information (you may need to restart your terminal first):\n```\n$ mbedhtrun --help\nUsage: mbedgt-script.py [options]\n\nFlash, reset and perform host supervised tests on mbed platforms\n\nOptions:\n  -h, --help            show this help message and exit\n```\n\n# mbed-host-tests\n\nmbed's test suite (codenamed ```Greentea```) supports the *test supervisor* concept. This concept is realized by this module. ```mbed-host-tests``` is a collection of host tests. Host test is script written in Python, which is executed in parallel with the test suite runner (a binary running on the target hardware / device under test) to monitor the test execution's progress or to control the test flow (interaction with the mbed device under test - DUT). The host test is also responsible for grabbing the test result, or deducing it from the test runner's behavior.\n\nKey-value protocol was developed and is used to provide communication layer between DUT (device under test) and host computer. Key-value protocol defined host computer as master and DUT as slave.\n* Slave side APIs and key-value protocol implementation is encapsulated in [greentea-client](https://github.com/ARMmbed/greentea-client) module. ```greentea-client``` is also available as [yotta module](https://yotta.mbed.com/#/module/greentea-client/1.0.0).\n* Master side APIs and key-value protocol is encapsulated in  ```mbed-host-tests```.\n\n```mbed-host-tests``` responsibilities are:\n* Flash mbed device with given binary.\n* Reset mbed device after flashing to start test suite execution.\n* Use key-value protocol to handshake with device and make sure correct host test script is executed to supervise test suite execution.\n* Run key-value protocol state machine and execute event callbacks.\n* Monitor serial port traffic to parse valid key-value protocol events.\n* Make decision if test test suite passed / failed / returned error.\n* Provide command line tool interface, command: ```mbedhtrun``` after module installation (on host).\n* Provide few basic host test implementations which can be used out of the box for test development. For example the basic host test (called ```default``` or ```default_auto```) just parses events from DUT and finished host test execution when ```end``` event is received. Other included in this module host tests can help you to test timers or RTC.\n\n## Key-value protocol overview\n\n* Text based protocol, format ```{{KEY;VALUE}}}```.\n* Master-slave mode where host is master and DUT is slave.\n\n## Design draft\n* Simple key-value protocol is introduced. It is used to communicate between DUT and host. Protocol main features:\n* Protocol introduced is master-slave protocol, where master is host and slave is device under test.\n* Transport layer consist of simple ```{{ KEY ; VALUE }} \\n``` text messages sent by slave (DUT). Both key and value are strings with allowed character set limitations (to simplify parsing and protocol parser itself). Message ends with required by DUT K-V parser `\\n` character.\n* DUT always (except for handshake phase) initializes communication by sending key-value message to host.\n* To avoid miscommunication between master and slave simple handshake protocol is introduces:\n    * Master (host) sends sync packet: ```{{__sync;UUID-STRING}}}``` with message value containing random UUID string.\n    * DUT waits for ```{{__sync;...}}``` message in input stream and replies with the same packer ```{{__sync;...}}```.\n    * After correct sync packet is received by master, messages ```{{__timeout;%d}}``` and ```{{__host_test_name}}``` are expected.\n  * Host parses DUTs tx stream and generates events sent to host test.\n  * Each event is a tuple of ```(key, value, timestamp)```, where key and value are extracted from message and\n* Host tests are now driven by simple async feature. Event state machine on master side is used to process events from DUT. Each host test is capable of registering callbacks, functions which will be executed when event occur. Event name is identical with KEY in key-value pair send as event from/to DUT.\n* DUT slave side uses simple parser to parse key-value pairs from stream. All non key-value data will be ignored. Blocking wait for an event API is provided: This implies usage of master-slave exchange between DUT and host where DUT uses non-blocking send event API to send to host (master) event and can wait for response. Master implements corresponding response after receiving event and processing data.\n  * Message parsing transforms key-value string message to Python event in this order:\n    * ```{{key;value}}``` string captured on DUT output.\n   * key-value data becomes a recognizable message with key (string) and value (string) payload.\n   * Event is formed in host test, a tuple of ```key``` (string), ```value``` (string), ```timestamp``` where ```timestamp``` is time of message reception in Python [time.time()](https://docs.python.org/2/library/time.html#time.time) format (float, time in seconds since the epoch as a floating point number.).\n* Each host test registers callbacks for available events.\n* Few keys' names in key-value messaging protocol are promoted to be considered \"system events\". Their names are used by event loop mechanism to communicate between DUT, host and various internal components. Please do not use restricted even names for your own private events. What's more:\n    * User can't register callbacks to \"system events\" with few exceptions.\n    * Reserved event/message keys have leading ```__``` in name:\n      * ```__sync``` - sync message, used by master and DUT to handshake.\n      * ```__timeout``` - timeout in sec, sent by DUT after ```{{sync;UUID}}``` is received.\n      * ```__version``` - ```greentea-client``` version send from DUT to host.\n      * ```__host_test_name``` - host test name, sent by DUT after ```{{sync;UUID}}``` is received.\n      * ```__notify_prn``` - sent by host test to print log message.\n      * ```__notify_conn_lost``` - sent by host test's connection process to notify serial port connection lost.\n      * ```__notify_complete``` - sent by DUT, async notificaion about test case result (true, false, none).\n      * ```__coverage_start``` - sent by DUT, coverage data.\n      * ```__testcase_start``` - sent by DUT, test case start data.\n      * ```__testcase_finish``` - sent by DUT, test case result.\n      * ```__exit``` - sent by DUT, test suite execution finished.\n      * ```__exit_event_queue``` - sent by host test, indicating no more events expected.\n  * Non-Reserved event/message keys have leading ```__``` in name:\n    * ```__rxd_line``` - Event triggered when ```\\n``` was found on DUT RXD channel. It can be overridden (```self.register_callback('__rxd_line', <callback_function>)```) and used by user. Event is sent by host test to notify a new line of text was received on RXD channel. ```__rxd_line``` event payload (value) in a line of text received from DUT over RXD.\n* Each host test (master side) has four functions used by async framework:\n  * ```setup()``` used to initialize host test and register callbacks.\n  * ```result()``` used to return test case result when ```notify_complete()``` is not called.\n  * ```teardown()``` used to finalize and resource freeing. It is guaranteed that ```teardown()``` will be always called after timeout or async test completion().\n  * ```notify_complete(result : bool)``` used by host test to notify test case result. This result will be read after test suite ```TIMEOUT```s or after DUT send ```__exit``` message (test suite execution finished event).\n  * ```self.send_kv(key : string, value : string)``` - send key-value message to DUT.\n  * ```self.log(text : string)``` - send event ```__notify_prn``` with text as payload (value). Your message will be printed in log.\n* Result returned from host test is a test suite result. Test cases results are reported by DUT, usually using modified ```utest``` framework.\n\n# Greentea client API\n\nDUT test API was first introduced in ```mbedmicro/mbed``` project [here](https://github.com/mbedmicro/mbed/tree/master/libraries/tests/mbed/env). After refactoring this functionality was copied and improved in [greentea-client](https://github.com/ARMmbed/greentea-client) module.\n\n* Slave side key-value protocol API, see [here](https://github.com/ARMmbed/greentea-client/blob/master/greentea-client/test_env.h) for details.\n```c++\n// Send key-value pairs from slave to master\nvoid greentea_send_kv(const char *, const char *);\nvoid greentea_send_kv(const char *, const int);\nvoid greentea_send_kv(const char *, const int, const int);\nvoid greentea_send_kv(const char *, const char *, const int);\nvoid greentea_send_kv(const char *, const char *, const int, const int);\n\n// Blocking, receive key-value message from master\nint greentea_parse_kv(char *, char *, const int, const int);\n```\nFunctions are used to send key-string or key-integer value messages to master. This functions should replace typical ```printf()``` calls with payload/control data to host.\n\n* **Blocking** wait for key-value pair message in input stream:\n```c++\nint greentea_parse_kv(char *out_key, char *out_value, const int out_key_len, const int out_value_len);\n```\nThis function should replace ```scanf()``` used to check for incoming messages from master.\nFunction parses input and if key-value message is found load to ```out_key```, ```out_value``` key-value pair. Use ```out_key_size``` and ```out_value_size```` to define out buffers max size (including trailing zero).\n\n# Key-value transport protocol sequence\n\nKey-value protocol has few parts:\n* **Handshake** - synchronize master and slave.\n* **Preamble exchange** - DUT informs host about test parameters such as client version, test suite timeout, requested host test name etc. After this part is finished master will create requested host test and attach callbacks to user events.\n* **Event exchange** - key-value event exchange between slave and master. In this exchange in general slave (DUT) will initialize communication. This part may end with ending pair of events ```end``` and ```__exit``` where ```end``` event carries test suite result returned by DUT and ```__exit``` event marks test suite ended and exited. After ```__exit``` event is received there will be no more communication between DUT and host test.\n\n## Handshake\nHanshake between DUT and host is a sequence of ```__sync``` events send between host (master) and DUT (slave). This is currently only situation when master initiates communication first. Handshake should provide synchronization point where master and slave are starting the same session.\n\nAfter reset:\n* DUT calls function ```GREENTEA_SETUP(timeout, \"host test name\");``` which\n* calls immediately ```greentea_parse_kv``` (blocking parse of input serial port for event ```{{__sync;UUID}}```).\n* When ```__sync``` packet is parsed in the stream DUT sends back (echoes) ```__sync``` event with the same [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_3_.28MD5_hash_.26_namespace.29) as payload. UUID is a random value e.g.  ```5f8dbbd2-199a-449c-b286-343a57da7a37```.\n\n```plain\n                           DUT (slave)        host (master)\n                             -----               -----\n                               |                   |\n                DUT reset ---> |                   |\n                               |                   |\ngreentea_parse_kv(key,value)   |                   |\n-------[ blocking ]----------->|                   |\n                               |                   |\n                               .                   .\n                               .                   .\n                               |                   |  self.send_kv(\"__sync\", UUID)\n                               |  {{__sync;UUID}}  |<-----------------------------\n                               |<------------------|\n                               |                   |\n                               |                   |\ngreentea_parse_kv              |  {{__sync;UUID}}  |\nechoes __sync event with       |------------------>|\nthe same UUID to master        |                   |\n                               |                   |\n```\n\nExample of handshake from ```htrun``` log:\n\n* DUT code:\n```c\n// GREENTEA_SETUP pseudo-code\nvoid GREENTEA_SETUP(const int timeout, const char *host_test_name) {\n\t// Wait for SYNC and echo it back\n        char _key[8] = {0};\n\tchar _value[48] = {0};\n\twhile (1) {\n        greentea_parse_kv(_key, _value, sizeof(_key), sizeof(_value));\n        if (strcmp(_key, GREENTEA_TEST_ENV_SYNC) == 0) {\n            // Found correct __sunc message\n            greentea_send_kv(_key, _value);\n            break;\n        }\n    }\n\n    // Send PREAMBLE: client version, test suite timeout and requested host test\n    greentea_send_kv(GREENTEA_TEST_ENV_HOST_TEST_VERSION, \"0.1.8\");\n    greentea_send_kv(GREENTEA_TEST_ENV_TIMEOUT, timeout);\n    greentea_send_kv(GREENTEA_TEST_ENV_HOST_TEST_NAME, host_test_name);\n}\n\n```\n* Corresponding log:\n```\n[1458565465.35][SERI][INF] reset device using 'default' plugin...\n[1458565465.60][SERI][INF] wait for it...\n[1458565466.60][CONN][INF] sending preamble '2f554b1c-bbbf-4b1b-b1f0-f45493282f2c'\n[1458565466.60][SERI][TXD] mbedmbedmbedmbedmbedmbedmbedmbedmbedmbed\n[1458565466.60][SERI][TXD] {{__sync;2f554b1c-bbbf-4b1b-b1f0-f45493282f2c}}\n[1458565466.74][CONN][INF] found SYNC in stream: {{__sync;2f554b1c-bbbf-4b1b-b1f0-f45493282f2c}}, queued...\n[1458565466.74][HTST][INF] sync KV found, uuid=2f554b1c-bbbf-4b1b-b1f0-f45493282f2c, timestamp=1458565466.743000\n[1458565466.74][CONN][RXD] {{__sync;2f554b1c-bbbf-4b1b-b1f0-f45493282f2c}}\n```\n\n## Preamble exchange\n\nThis phase comes just after handshake phase. DUT informs host about test parameters such as client version, timeout, requested host test name etc. After this part is finished master will create requested host test and attach callbacks to user events.\nThis phase is ended with ```__host_test_name``` being received by host. After ```__host_test_name``` event is received\n\n```\nDUT (slave)              host (master)\n  -----                     -----\n    |                         |\n    |    {{__version;%s}}     |\n    |------------------------>|\n    |                         |\n    |    {{__timeout;%d}}     |\n    |------------------------>|\n    |                         |\n    | {{__host_test_name;%s}} |\n    |------------------------>|\n    |                         |\n```\n\nExample of handshake from ```htrun``` log:\n\n* DUT code:\n```c\nvoid main() {\n    GREENTEA_CLIENT(5, \"default_auto\");\n    // ...\n}\n```\n* Corresponding log:\n```\n[1458565466.76][CONN][INF] found KV pair in stream: {{__version;0.1.8}}, queued...\n[1458565466.76][CONN][RXD] {{__version;0.1.8}}\n[1458565466.76][HTST][INF] DUT greentea-client version: 0.1.8\n[1458565466.77][CONN][INF] found KV pair in stream: {{__timeout;5}}, queued...\n[1458565466.77][HTST][INF] setting timeout to: 5 sec\n[1458565466.78][CONN][RXD] {{__timeout;5}}\n[1458565466.81][CONN][INF] found KV pair in stream: {{__host_test_name;default_auto}}, queued...\n[1458565466.81][HTST][INF] host test setup() call...\n[1458565466.81][HTST][INF] CALLBACKs updated\n[1458565466.81][HTST][INF] host test detected: default_auto\n[1458565466.81][CONN][RXD] {{__host_test_name;default_auto}}\n```\n\n## Event exchange\n\nIn this phase DUT and host exchange events and host side is calling callbacks registered to each of the events sent from DUT. DUT can use function ```greentea_parse_kv``` to parse input stream for next incoming key-value event.\nAfter ```__host_test_name``` event is received and before any event is consumed during this stage:\n* Host state machine loads host test object by name provided in payload of ```__host_test_name``` event.E.g. event ```{{____host_test_name;default_auto}} will load host test named \"*default_auto*\".\n* Host state machine loads callbacks registered by user in host test setup phase and hooks them to event machine.\nNow host is ready to handle test suite test execution. From this moment each event sent from DUT will be handled by corresponding callback registered by user in host test setup. Unknown events will not be handled and warning will be printed in log.\n\n```\n\nDUT (slave)      host (master)\n  -----             -----\n    |                 |\n    |                 |        Host Test\n    |                 |         -----\n    |                 |  create   |\n    |                 |---------->|\n    |                 |           |\n    |                 |           |\n    | {{key1;value}}  |           |\n    |---------------->|           |          ht.setup()\n    |       .         |           |<---[ user register callbacks ]---\n    |       .         |           |\n    |       .         |           |  host.callbacks.update(ht.get_callbacks())\n    |       .         |           |<---[ host state machine ]------------------\n    | {{key2;value}}  |           |\n    |---------------->|           |\n    |                 |           |\n    |                 |           |\n    |                 |           | ht.callbacks[key1](key, value, timestamp)\n    |                 |           |<------------------------------------------\n    |                 |           | ht.callbacks[key2](key, value, timestamp)\n    |                 |           |<------------------------------------------\n    |                 |           |\n    |                 |           |\n    -  - - - - - - - -  - - - -     - -\n          TEST CASE FLOW CONTINUES\n    -  - - - - - - - -  - - - -     - -\n    |                 |           |\n    |                 |           | ht.notify_complete(true)\n    |                 |           | (sets test suite 'result' to true\n    |                 |           |<----------------\n    |                 |           |\n    |                 |           |\n    | {{end;success}} |           |\n    |---------------->|           |\n    |                 |           |\n    | {{__exit;%d}}   |           |\n    |---------------->|           |\n    |                 |           |\n    |                 |           | result = ht.result()\n    |                 |           |<----------------\n    |                 |           |\n    |                 |           | ht.teardown()\n    |                 |           |<----------------\n    |                 |           |\n    |                 |           |\n\n```\n* After DUT send ```__exit``` or after timeout it is guaranteed that host test ```teardown()``` function will be called. This call is blocking, please make sure your tear down function finishes.\n\n# DUT - host test case workflow\n## DUT implementation\n```c++\nint main() {\n    // 1. Handshake between DUT and host and\n    // 2. Send test case related data\n    GREENTEA_SETUP(15, \"gimme_auto\");  // __timeout, __host_test_name\n\n    // ...\n    // Send to master {{gimme_something; some_stuff}}\n    greentea_send_kv(\"gimme_something\", \"some_stuff\");\n\n    char key[16] = {0};\n    char value[32] = {0};\n    // Blocking wait for master response for {{gimme_something; some_stuff}}\n    greentea_parse_kv(key, value, sizeof(key), sizeof(value));\n    // ...\n    fprintf(stderr, \"Received from master %s, %s\", key, value);\n    // ...\n\n    GREENTEA_TSUITE_RESULT(true);    // __exit\n}\n```\n## Example of corresponding host test\n```python\nclass GimmeAuto(BaseHostTest):\n    \"\"\" Simple, basic host test's test runner waiting for serial port\n        output from MUT, no supervision over test running in MUT is executed.\n    \"\"\"\n\n    __result = None\n    name = \"gimme_auto\"\n\n    def _callback_gimme_something(self, key, value, timestamp):\n        # You've received {{gimme_something;*}}\n\n        # We will send DUT some data back...\n        # And now decide about test case result\n        if value == 'some_stuff':\n            # Message payload/value was 'some_stuff'\n            # We can for example return true from test\n            self.send_kv(\"print_this\", \"This is what I wanted %s\"% value)\n            self.notify_complete(True)\n        else:\n            self.send_kv(\"print_this\", \"This not what I wanted :(\")\n            self.notify_complete(False)\n\n    def setup(self):\n        # Register callback for message 'gimme_something' from DUT\n        self.register_callback(\"gimme_something\", self._callback_gimme_something)\n\n        # Initialize your host test here\n        # ...\n\n    def result(self):\n        # Define your test result here\n        # Or use self.notify_complete(bool) to pass result anytime!\n        return self.__result\n\n    def teardown(self):\n        # Release resources here after test is completed\n        pass\n```\nLog:\n```\n[1454926794.22][HTST][INF] copy image onto target...\n        1 file(s) copied.\n[1454926801.48][HTST][INF] starting host test process...\n[1454926802.01][CONN][INF] starting connection process...\n[1454926802.01][CONN][INF] initializing serial port listener...\n[1454926802.01][SERI][INF] serial(port=COM188, baudrate=9600)\n[1454926802.02][SERI][INF] reset device using 'default' plugin...\n[1454926802.27][SERI][INF] wait for it...\n[1454926803.27][CONN][INF] sending preamble '9caa42a0-28a0-4b80-ba1d-befb4e43a4c1'...\n[1454926803.27][SERI][TXD] mbedmbedmbedmbedmbedmbedmbedmbedmbedmbed\n[1454926803.27][SERI][TXD] {{__sync;9caa42a0-28a0-4b80-ba1d-befb4e43a4c1}}\n[1454926803.40][CONN][RXD] {{__sync;9caa42a0-28a0-4b80-ba1d-befb4e43a4c1}}\n[1454926803.40][CONN][INF] found SYNC in stream: {{__sync;9caa42a0-28a0-4b80-ba1d-befb4e43a4c1}}, queued...\n[1454926803.40][HTST][INF] sync KV found, uuid=9caa42a0-28a0-4b80-ba1d-befb4e43a4c1, timestamp=1454926803.405000\n[1454926803.42][CONN][RXD] {{__timeout;15}}\n[1454926803.42][CONN][INF] found KV pair in stream: {{__timeout;15}}, queued...\n[1454926803.42][HTST][INF] setting timeout to: 15 sec\n[1454926803.45][CONN][RXD] {{__host_test_name;gimme_auto}}\n[1454926803.45][CONN][INF] found KV pair in stream: {{__host_test_name;gimme_auto}}, queued...\n[1454926803.45][HTST][INF] host test setup() call...\n[1454926803.45][HTST][INF] CALLBACKs updated\n[1454926803.45][HTST][INF] host test detected: gimme_auto\n[1454926803.48][CONN][RXD] {{gimme_something;some_stuff}}\n[1454926803.48][CONN][INF] found KV pair in stream: {{gimme_something;some_stuff}}, queued...\n[1454926803.48][SERI][TXD] {{print_this;This is what I wanted some_stuff}}\n[1454926803.48][HTST][INF] __notify_complete(True)\n[1454926803.62][CONN][RXD] Received from master print_this, This is what I wanted some_stuf\n[1454926803.62][CONN][RXD] {{end;success}}\n[1454926803.62][CONN][INF] found KV pair in stream: {{end;success}}, queued...\n[1454926803.62][HTST][ERR] orphan event in main phase: {{end;success}}, timestamp=1454926803.625000\n[1454926803.63][CONN][RXD] {{__exit;0}}\n[1454926803.63][CONN][INF] found KV pair in stream: {{__exit;0}}, queued...\n[1454926803.63][HTST][INF] __exit(0)\n[1454926803.63][HTST][INF] test suite run finished after 0.21 sec...\n[1454926803.63][HTST][INF] exited with code: None\n[1454926803.63][HTST][INF] 0 events in queue\n[1454926803.63][HTST][INF] stopped consuming events\n[1454926803.63][HTST][INF] host test result() skipped, received: True\n[1454926803.63][HTST][INF] calling blocking teardown()\n[1454926803.63][HTST][INF] teardown() finished\n[1454926803.63][HTST][INF] {{result;success}}\nmbedgt: mbed-host-test-runner: stopped\nmbedgt: mbed-host-test-runner: returned 'OK'\nmbedgt: test on hardware with target id: 02400226d94b0e770000000000000000000000002492f3cf\nmbedgt: test suite 'mbed-drivers-test-gimme' ......................................................... OK in 10.02 sec\nmbedgt: shuffle seed: 0.3631708941\nmbedgt: test suite report:\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\n| target        | platform_name | test suite              | result | elapsed_time (sec) | copy_method |\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\n| frdm-k64f-gcc | K64F          | mbed-drivers-test-gimme | OK     | 10.02              | shell       |\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\nmbedgt: test suite results: 1 OK\n```\n\n# Host test examples\n## Return result after __exit\n```python\nclass GimmeAuto(BaseHostTest):\n    \"\"\" Simple, basic host test's test runner waiting for serial port\n        output from MUT, no supervision over test running in MUT is executed.\n    \"\"\"\n\n    __result = None\n    name = \"gimme_auto\"\n\n    def _callback_gimme_something(self, key, value, timestamp):\n        # You've received {{gimme_something;*}}\n\n        # We will send DUT some data back...\n        # And now decide about test case result\n        if value == 'some_stuff':\n            # Message payload/value was 'some_stuff'\n            # We can for example return true from test\n            self.send_kv(\"print_this\", \"This is what I wanted %s\"% value)\n            self.__result = True\n        else:\n            self.send_kv(\"print_this\", \"This not what I wanted :(\")\n            self.__result = False\n\n    def setup(self):\n        # Register callback for message 'gimme_something' from DUT\n        self.register_callback(\"gimme_something\", self._callback_gimme_something)\n\n        # Initialize your host test here\n        # ...\n\n    def result(self):\n        # Define your test result here\n        # Or use self.notify_complete(bool) to pass result anytime!\n        return self.__result\n\n    def teardown(self):\n        # Release resources here after test is completed\n        pass\n```\nCorresponding log:\n```\n[1454926627.11][HTST][INF] copy image onto target...\n        1 file(s) copied.\n[1454926634.38][HTST][INF] starting host test process...\n[1454926634.93][CONN][INF] starting connection process...\n[1454926634.93][CONN][INF] initializing serial port listener...\n[1454926634.93][SERI][INF] serial(port=COM188, baudrate=9600)\n[1454926634.94][SERI][INF] reset device using 'default' plugin...\n[1454926635.19][SERI][INF] wait for it...\n[1454926636.19][CONN][INF] sending preamble '9a743ff3-45e6-44cf-9e2a-9a83e6205184'...\n[1454926636.19][SERI][TXD] mbedmbedmbedmbedmbedmbedmbedmbedmbedmbed\n[1454926636.19][SERI][TXD] {{__sync;9a743ff3-45e6-44cf-9e2a-9a83e6205184}}\n[1454926636.33][CONN][RXD] {{__sync;9a743ff3-45e6-44cf-9e2a-9a83e6205184}}\n[1454926636.33][CONN][INF] found SYNC in stream: {{__sync;9a743ff3-45e6-44cf-9e2a-9a83e6205184}}, queued...\n[1454926636.33][HTST][INF] sync KV found, uuid=9a743ff3-45e6-44cf-9e2a-9a83e6205184, timestamp=1454926636.331000\n[1454926636.34][CONN][RXD] {{__timeout;15}}\n[1454926636.34][CONN][INF] found KV pair in stream: {{__timeout;15}}, queued...\n[1454926636.34][HTST][INF] setting timeout to: 15 sec\n[1454926636.38][CONN][RXD] {{__host_test_name;gimme_auto}}\n[1454926636.38][CONN][INF] found KV pair in stream: {{__host_test_name;gimme_auto}}, queued...\n[1454926636.38][HTST][INF] host test setup() call...\n[1454926636.38][HTST][INF] CALLBACKs updated\n[1454926636.38][HTST][INF] host test detected: gimme_auto\n[1454926636.41][CONN][RXD] {{gimme_something;some_stuff}}\n[1454926636.41][CONN][INF] found KV pair in stream: {{gimme_something;some_stuff}}, queued...\n[1454926636.41][SERI][TXD] {{print_this;This is what I wanted some_stuff}}\n[1454926636.54][CONN][RXD] Received from master print_this, This is what I wanted some_stuf\n[1454926636.54][CONN][RXD] {{end;success}}\n[1454926636.54][CONN][INF] found KV pair in stream: {{end;success}}, queued...\n[1454926636.55][HTST][ERR] orphan event in main phase: {{end;success}}, timestamp=1454926636.541000\n[1454926636.56][CONN][RXD] {{__exit;0}}\n[1454926636.56][CONN][INF] found KV pair in stream: {{__exit;0}}, queued...\n[1454926636.56][HTST][INF] __exit(0)\n[1454926636.56][HTST][INF] test suite run finished after 0.22 sec...\n[1454926636.56][HTST][INF] exited with code: None\n[1454926636.56][HTST][INF] 0 events in queue\n[1454926636.56][HTST][INF] stopped consuming events\n[1454926636.56][HTST][INF] host test result(): True\n[1454926636.56][HTST][INF] calling blocking teardown()\n[1454926636.56][HTST][INF] teardown() finished\n[1454926636.56][HTST][INF] {{result;success}}\nmbedgt: mbed-host-test-runner: stopped\nmbedgt: mbed-host-test-runner: returned 'OK'\nmbedgt: test on hardware with target id: 02400226d94b0e770000000000000000000000002492f3cf\nmbedgt: test suite 'mbed-drivers-test-gimme' ......................................................... OK in 10.04 sec\nmbedgt: shuffle seed: 0.3866075474\nmbedgt: test suite report:\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\n| target        | platform_name | test suite              | result | elapsed_time (sec) | copy_method |\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\n| frdm-k64f-gcc | K64F          | mbed-drivers-test-gimme | OK     | 10.04              | shell       |\n+---------------+---------------+-------------------------+--------+--------------------+-------------+\nmbedgt: test suite results: 1 OK\n```\n\n# Writing DUT test suite (slave side)\n\n## DUT test suite with single test case\n\nWe can use few methods to structure out test suite and test cases. Simpliest would be to use ```greentea-client``` API and wrap one test case inside out test suite. This way of creating test suite is useful when you want to:\n* write only one test case inside test suite,\n* make example application (example as a test) or\n* when your test suite is calling blocking forever function. For example all types of UDP/TCP servers which run in forever loop are in this category. In this case we do not expect from DUT ```__exit``` event at all and host test should be designed in such a way that it always return result.\n\n### DUT always finishes execution\n\nIn this example DUT code uses ```greentea-client``` to sync (```GREENTEA_SETUP```) and pass result (```GREENTEA_TESTSUITE_RESULT```) to ```Greentea```. This is very simple example of how you can write tests. Note that in this example test suite only implements one test case. Actually test suite is test case at the same time. Result passed to ```GREENTEA_TESTSUITE_RESULT``` will be at the same time test case result.\n\n* DUT implementation:\n```c++\n#include \"greentea-client/test_env.h\"\n#include \"unity/unity.h\"    // Optional: unity ASSERTs\n\nint app_start(int, char*[]) {\n\n    bool result = true;\n    GREENTEA_SETUP(15, \"default_auto\");\n\n    // test case execution and assertions\n\n    GREENTEA_TESTSUITE_RESULT(result);\n    return 0;\n}\n```\n\n### DUT test suite never finishes execution\n\nTest suite is implemented so that it will never exit / finish its execution. For example ```main()``` or ```app_start()``` functions are implemented using infinite (endless) loop. This property have for example UDP/TCP servers (listening forever), all sorts of echo servers etc.\n\nIn this example DUT code uses ```greentea-client``` to sync (```GREENTEA_SETUP```) with ```Greentea```. We are not calling ```GREENTEA_TESTSUITE_RESULT(result)``` at any time. In this example host test is responsible for providing test suite result using ```self.notify_complete()``` API or ```self.result()``` function.\n\nYou need to write and specify by name your custom host test:\n* DUT side uses second argument of ```GREENTEA_SETUP(timeout, host_test_name)``` function:\n```c++\nGREENTEA_SETUP(15, \"wait_us_auto\");\n```\n* You need to place your custom host test in ```<module>/test/host_tests``` directory.\n  * Do not forget to name host test accordingly. See below example host test ```name``` class member.\n\n* DUT implementation using ```my_host_test``` custom host test:\n```c++\n#include \"greentea-client/test_env.h\"\n#include \"unity/unity.h\"\n\nvoid recv() {\n    // receive from client\n}\n\nint app_start(int, char*[]) {\n\n    Ethernet eth(TCP_SERVER, PORT, recv);\n    GREENTEA_SETUP(15, \"my_host_test\");\n\n    eth.listen();   // Blocking forever\n\n    return 0;\n}\n```\n\n* Example host test template:\n```python\nfrom mbed_host_tests import BaseHostTest\n\nclass YourCustomHostTest(BaseHostTest):\n\n    name = \"my_host_test\"   # Host test names used by GREENTEA_CLIENT(..., host_test_name)\n\n    __result = False    # Result in case of timeout!\n\n    def _callback_for_event(self, key, value, timestamp):\n        #\n        # Host test API:\n        #\n        # self.notify_complete(result : bool)\n        #\n        # \"\"\"! Notify main even loop that host test finished processing\n        #      @param result True for success, False failure. If None - no action in main even loop\n        # \"\"\"\n        #\n        # self.send_kv(key : string, value : string)\n        #\n        # \"\"\"! Send Key-Value data to DUT\n        #      @param key Event key\n        #      @param value Event payload\n        # \"\"\"\n        #\n        # self.log(text : string)\n        #\n        # \"\"\"! Send log message to main event loop\n        #      @param text log message\n        # \"\"\"\n        pass\n\n    def setup(self):\n        # TODO:\n        # * Initialize your resources\n        # * Register callbacks:\n        #\n        # Host test API:\n        #\n        # self.register_callback(event_name, callable, force=False)\n        #\n        # \"\"\"! Register callback for a specific event (key: event name)\n        #     @param key String with name of the event\n        #     @param callback Callable which will be registered for event \"key\"\n        #     @param force God mode, if set to True you can add callback on any system event\n        # \"\"\"\n        pass\n\n    def teardown(self):\n        # Destroy all resources used by host test.\n        # For example open sockets, open files, auxiliary threads and processes.\n        pass\n\n    def result(self):\n        # Returns host test result (True, False or None)\n        # This function will be called when test suite ends (also timeout).\n        # Use when you want to pass result after host state machine stops.\n        return __result\n```\n\n### DUT test suite with ```utest``` harness\n\n```utest``` harness allows you to define multiple test cases inside your test suite. This feature is supported by ```Greentea``` test tools.\n\n* DUT implementation:\n```c++\n#include \"greentea-client/test_env.h\"\n#include \"unity/unity.h\"\n#include \"utest/utest.h\"\n\nstatus_t greentea_failure_handler(const Case *const source, const failure_t reason) {\n    // Continue with next test case if it fails\n    greentea_case_failure_abort_handler(source, reason);\n    return STATUS_CONTINUE;\n}\n\nvoid test_uninitialised_array() {\n    // TEst case code...\n}\n\nvoid test_repeated_init() {\n    // TEst case code...\n}\n\nvoid test_data_types() {\n    // TEst case code...\n}\n\nconst Case cases[] = {\n    Case(\"Test uninitialised array\", test_uninitialised_array, greentea_failure_handler),\n    Case(\"Test repeated array initialisation\", test_repeated_init, greentea_failure_handler),\n    Case(\"Test basic data type arrays\", test_data_types, greentea_failure_handler)\n    // ...\n};\n\nstatus_t greentea_setup(const size_t number_of_cases) {\n    GREENTEA_SETUP(5, \"default_auto\");\n    return greentea_test_setup_handler(number_of_cases);\n}\n\nint app_start(int, char*[]) {\n\n   // Run the test cases\n    Harness::run(specification);\n}\n```\n\n# Writing host tests (master side)\nWhen writing a new host test for your module please bear in mind that:\n* You own the host test and you should write it the way so it can coexist with the same host tests ran by other processes such as Continuous Integration systems or other host users.\n  * Note: If you work in isolation and your test environment if fully controlled by you (for example you queue all tasks calling host tests, or use global host unique socket port numbers) this rule doesn’t apply to you.\n* When writing host test using OS resources such as sockets, files, serial ports, peripheral devices like for example multi-meters / scopes. remember that those resources are indivisible!\n  * For example if you hardcode in your host test UDP port 32123 and use it for UDP server implementation  of your host test bear in mind that this port may be already used. It is your responsibility to react for this event and implement means to overcome it (if possible).\n\n## Callbacks\nYou can register callbacks in ```setup()``` phase or decorate callback functions using ```@event_callback``` decorator.\n\n### Callback registration in setup() method\n```python\nfrom mbed_host_tests import BaseHostTest\n\nclass DetectRuntimeError(BaseHostTest):\n\n    __result = False\n\n    def callback_some_event(self, key, value, timeout):\n        # Do something with 'some_event'\n        pass\n\n    def setup(self):\n        # Reagister call back for 'some_event' event\n        self.register_callback('some_event', self.callback_some_event)\n\n    def result(self):\n        # Do some return calculations\n        return self.__result\n```\nBelow the same callback registered using decorator:\n\n### Callback decorator definition\n```python\nfrom mbed_host_tests import BaseHostTest\n\nclass DetectRuntimeError(BaseHostTest):\n\n    __result = False\n\n    @event_callback('some_event')\n    def callback_some_event(self, key, value, timeout):\n        # Do something with 'some_event'\n        pass\n\n    def setup(self):\n        # Do some extra setup if required\n        # You can also register here callbacks using self.register_callback(...) method\n        pass\n\n    def result(self):\n        # Do some return calculations\n        return self.__result\n```\n\n### Parsing text received from DUT (line by line)\nExample of host test expecting ```Runtime error ... CallbackNode ... ``` string in DUT output.\nWe will use allowed to override ```__rxd_line``` event to hook to DUT RXD channel lines of text.\n\n#### Before Greentea v0.2.0\n```python\nfrom sys import stdout\nfrom mbed_host_tests import BaseHostTest\n\nclass DetectRuntimeError(BaseHostTest):\n\n    name = 'detect_runtime_error'\n\n    def test(self, selftest):\n        result = selftest.RESULT_FAILURE\n        try:\n            while True:\n                line = selftest.mbed.serial_readline()\n\n                if line is None:\n                    return selftest.RESULT_IO_SERIAL\n\n                stdout.write(line)\n                stdout.flush()\n\n                line = line.strip()\n\n                if line.startswith(\"Runtime error\") and line.find(\"CallbackNode\") != -1:\n                    result = selftest.RESULT_SUCCESS\n                    break\n\n        except KeyboardInterrupt, _:\n            selftest.notify(\"\\r\\n[CTRL+C] exit\")\n            result = selftest.RESULT_ERROR\n\n        return result\n```\n\n#### Using __rdx_line event\n```python\nfrom mbed_host_tests import BaseHostTest\n\nclass DetectRuntimeError(BaseHostTest):\n    \"\"\"! We _expect_ to detect 'Runtime error' \"\"\"\n\n    __result = False\n\n    def callback__rxd_line(self, key, value, timeout):\n        #\n        # Parse line of text received over e.g. serial from DUT\n        #\n        line = value.strip()\n        if line.startswith(\"Runtime error\") and \"CallbackNode\" in line:\n            # We've found exepcted \"Runtime error\" string in DUTs output stream\n            self.notify_complete(True)\n\n    def setup(self):\n        # Force, we force callback registration even it is a restricted one (starts with '__')\n        self.register_callback('__rxd_line', self.callback__rxd_line, force=True)\n\n    def result(self):\n        # We will return here (False) when we reach timeout of the test\n        return self.__result\n\n    def teardown(self):\n        pass\n```\n\n##  ```htrun``` new log format:\n  * ```[timestamp][source][level]``` - new log format, where:\n    * ```timestamp``` - returned by Python's ```time.time()```.\n    * ```source``` - log source.\n      * ```CONN``` - connection process (pooling for connection source e.g. serial port),\n      * ```SERI``` - serial port wrapper with standard read, write, flush interface,\n      * ```HTST``` - host test object, HostTestBase derived object,\n      * ```PLGN``` - host test plugins, type `BasePlugin` of the plugin,\n      * ```COPY``` - host test plugins, type `CopyMethod` of the plugin,\n      * ```REST``` - host test plugins, type `ResetMethod` of the plugin,\n    * ```level``` - logging level:\n      * ```INF``` (info),\n      * ```WRN``` (warning),\n      * ```ERR``` (error).\n      * ```TXD``` (host's TX channel, to DUT).\n      * ```RXD``` (host's RX channel, from DUT).\n\n### Log example\n* ```[1455218713.87][CONN][RXD] {{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}```:\n* Logged from ```CONN``` (connection process).\n* ```RXD``` channel emitted ```{{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}```.\n* Time stamp: ```2016-02-11 19:53:27```, see below:\n\n# End-to-end examples\n\nHere you can find references to modules and repositories contain examples of test suites and test cases written using ```greentea-client```, ```utest``` and ```unity```:\n* ```utest``` module contains [test cases](https://github.com/ARMmbed/utest/tree/master/test) written using ```utest``` itself.\n* ```minar``` module contains [test cases](https://github.com/ARMmbed/minar/tree/master/test) written without ```utest```. Note: ```utest``` may use ```minar``` for callback scheduling and can't be use to test ```minar``` itself.\n* ```mbed-drivers``` module contains [test cases](https://github.com/ARMmbed/mbed-drivers/tree/master/test) written with and without ```utest``` harness. Currently all ```mbed-drivers``` tests are using [build-in to ```htrun``` host tests](https://github.com/ARMmbed/htrun/tree/master/mbed_host_tests/host_tests).\n* And finally ```sockets``` module contains [test cases](https://github.com/ARMmbed/sockets/tree/master/test) with [custom host tests](https://github.com/ARMmbed/sockets/tree/master/test/host_tests).",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ARMmbed/htrun",
    "keywords": null,
    "license": "Apache-2.0",
    "maintainer": null,
    "maintainer_email": null,
    "name": "mbed-host-tests",
    "package_url": "https://pypi.org/project/mbed-host-tests/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/mbed-host-tests/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/ARMmbed/htrun"
    },
    "release_url": "https://pypi.org/project/mbed-host-tests/1.1.4/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "mbed tools used to flash, reset and supervise test execution for mbed-enabled devices",
    "version": "1.1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16560433,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7ba3db2bf9765b44f4964b8eb4c56be776809b244e0316066feeb28a4673880e",
        "md5": "e80bdf8f33f8d2ef06e5a97d8371746e",
        "sha256": "9bcc9a9b665645f4b47cf201262dad5719b3c7ebd468c99c925a2f83c5c277b8"
      },
      "downloads": -1,
      "filename": "mbed-host-tests-1.1.4.zip",
      "has_sig": false,
      "md5_digest": "e80bdf8f33f8d2ef06e5a97d8371746e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 128126,
      "upload_time": "2016-10-20T18:31:08",
      "upload_time_iso_8601": "2016-10-20T18:31:08.496637Z",
      "url": "https://files.pythonhosted.org/packages/7b/a3/db2bf9765b44f4964b8eb4c56be776809b244e0316066feeb28a4673880e/mbed-host-tests-1.1.4.zip",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}