{
  "info": {
    "author": "Bruno Rocha",
    "author_email": "rochacbruno@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Django",
      "Framework :: Flask",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Utilities"
    ],
    "description": "```\n██████╗ ██╗   ██╗███╗   ██╗ █████╗  ██████╗ ██████╗ ███╗   ██╗███████╗\n██╔══██╗╚██╗ ██╔╝████╗  ██║██╔══██╗██╔════╝██╔═══██╗████╗  ██║██╔════╝\n██║  ██║ ╚████╔╝ ██╔██╗ ██║███████║██║     ██║   ██║██╔██╗ ██║█████╗\n██║  ██║  ╚██╔╝  ██║╚██╗██║██╔══██║██║     ██║   ██║██║╚██╗██║██╔══╝\n██████╔╝   ██║   ██║ ╚████║██║  ██║╚██████╗╚██████╔╝██║ ╚████║██║\n╚═════╝    ╚═╝   ╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝\n```\n\n> **dynaconf** - The **dyna**mic **conf**igurator for your Python Project\n\n[![MIT License](https://img.shields.io/badge/license-MIT-007EC7.svg?style=flat-square)](/LICENSE) [![PyPI](https://img.shields.io/pypi/v/dynaconf.svg)](https://pypi.python.org/pypi/dynaconf) [![PyPI](https://img.shields.io/pypi/pyversions/dynaconf.svg)]() [![Travis CI](http://img.shields.io/travis/rochacbruno/dynaconf.svg)](https://travis-ci.org/rochacbruno/dynaconf) [![codecov](https://codecov.io/gh/rochacbruno/dynaconf/branch/master/graph/badge.svg)](https://codecov.io/gh/rochacbruno/dynaconf) [![Codacy grade](https://img.shields.io/codacy/grade/5074f5d870a24ddea79def463453545b.svg)](https://www.codacy.com/app/rochacbruno/dynaconf/dashboard)\n\n**dynaconf** a layered configuration system for Python applications - \nwith strong support for [12-factor applications](https://12factor.net/config) \nand extensions for **Flask** and **Django**.\n\n**Documentation**: http://dynaconf.readthedocs.io/\n\n## Features\n\n- Strict separation of settings from code (following [12-factor applications](https://12factor.net/config) Guide).\n- Define comprehensive default values.\n- Store parameters in multiple file formats (**toml** recommended and json, yaml, ini and py also supported).\n- Sensitive **secrets** like tokens and passwords can be stored in safe places like `.secrets` or `vault server`.\n- Parameters can optionally be stored in external services like Redis server.\n- Simple **feature flag** system.\n- Layered **[environment]** system.\n- Environment variables can be used to override parameters.\n- Support for `.env` files to automate the export of environment variables.\n- Correct data types (even for environment variables).\n- Have **only one** canonical settings module to rule all your instances.\n- Drop in extension for **Flask** `app.config` object.\n- Drop in extension for **Django** `conf.settings` object.\n- Powerful **$ dynaconf** CLI to help you manage your settings.\n- Customizable Validation System to ensure correct config parameters.\n- Allow the change of **dyna**mic parameters on the fly without the need to redeploy your application.\n\n## install Dynaconf\n\n> Python 3.x is required\n\n```bash\n# Default installation supports .py, .toml, .json file formats\n# and also reading from environment variables (.env supported)\npip3 install dynaconf\n```\n\n## Getting Started\n\n\n### Accessing config variables in your Python application\n\nIn your Python program wherever you need to access a settings variable do:\n\n```python\n# Example of program to connect to some database\nfrom someorm import connect\nfrom dynaconf import settings  # import `dynaconf.settings` canonical settings object\n\ncon = connect(\n    username=settings.USERNAME,             # attribute style access\n    password=settings.get('PASSWORD'),      # dict get style access\n    port=settings['PORT'],                  # dict item style access\n    timeout=settings.as_int('TIMEOUT'),     # Forcing casting if needed\n    host=settings.get('HOST', 'localhost')  # Providing defaults if key not defined\n)\n```\n\n### Where the settings values are stored?\n\nDynaconf aims to have a flexible and usable configuration system. Your applications can be configured via a **configuration files**, through **environment variables**, or both. Configurations are separated into environments: **[development], [staging], [testing] and [production]**. The working environment is selected via an environment variable.\n\n**Sensitive data** like tokens, secret keys and password can be stored in `.secrets.*` files and/or external storages like `Redis` or `vault` secrets server.\n\nBesides the built-in optional support to **redis** as settings storage dynaconf allows you to create **custom loaders** and store the data wherever you want e.g: databases, memory storages, other file formats, nosql databases etc. \n\n### environments\n\nAt any point in time, your application is operating in a given configuration environment. By default there are four such environments:\n\n- [development]\n- [staging]\n- [testing]\n- [production]\n\n> You can also define **[custom environment]** and use the pseudo-envs **[default]** to provide comprehensive default values and **[global]** to provide global values to overrride in any other environment.\n\nWithout any action, your applications by default run in the **[development]** environment. The environment can be changed via the `ÈNV_FOR_DYNACONF` environment variable. For example, to launch an application in the **[staging]** environment, we can run:\n\n```bash\nexport ENV_FOR_DYNACONF=staging\n```\n\nor\n\n```bash\nENV_FOR_DYNACONF=staging python yourapp.py\n```\n\n## The settings files\n\nAn optional `settings.{toml|py|json|ini|yaml}` file can be used to specify the configuration parameters for each environment. If it is not present, only the values from **environment variables** are used (**.env** file is also supported). Dynaconf searches for the file starting at the current working directory. If it is not found there, Dynaconf checks the parent directory. Dynaconf continues checking parent directories until the root is reached.\n\nThe recommended file format is **TOML** but you can choose to use any of **.{toml|py|json|ini|yaml}**.\n\nThe file must be a series of sections, at most one for **[default]**, optionally one for each **[environment]**, and an optional **[global]** section. Each section contains **key-value** pairs corresponding to configuration parameters for that **[environment]**. If a configuration parameter is missing, the value from **[default]** is used. The following is a complete `settings.toml` file, where every standard configuration parameter is specified within the **[default]** section:\n\n```toml\n[default]\nusername = \"admin\"\nport = 5000\nhost = \"localhost\"\nmessage = \"default message\"\nvalue = \"default value\"\n\n[development]\nusername = \"devuser\"\n\n[staging]\nhost = \"staging.server.com\"\n\n[testing]\nhost = \"testing.server.com\"\n\n[production]\nhost = \"server.com\"\n\n[awesomeenv]\nvalue = \"this value is set for custom [awesomeenv]\"\n\n[global]\nmessage = \"This value overrides message of default and other envs\"\n```\n\nThe **[global]** pseudo-environment can be used to set and/or override configuration parameters globally. A parameter defined in a **[global]** section sets, or overrides if already present, that parameter in every environment. For example, given the following `settings.toml` file, the value of address will be **\"1.2.3.4\"** in every environment:\n\n```toml\n[global]\naddress = \"1.2.3.4\"\n\n[development]\naddress = \"localhost\"\n\n[production]\naddress = \"0.0.0.0\"\n```\n\n> **NOTE**: The **[env]** name and first level variables are case insensitive as internally dynaconf will always use upper case, that means **[development]** and **[DEVELOPMENT]** are equivalent and **address** and **ADDRESS** are also equivalent. This rule does not apply for inner data structures as dictionaries and arrays.\n\n### Settings file supported formats\n\nBy default **toml** is the recommended format to store your configuration, however you can switch to a different supported format.\n\n```bash\n# If you wish to include support for more sources\npip3 install dynaconf[yaml|ini|redis|vault]\n\n# for a complete installation\npip3 install dynaconf[all]\n```\n\nOnce the support is installed no extra configuration is needed to load data from those files, dynaconf will search for settings files in\nthe root directory of your application looking for the following files in the exact order below:\n\n```python\n[\n 'settings.py', '.secrets.py',\n 'settings.toml', 'settings.tml', '.secrets.toml', '.secrets.tml',\n 'settings.yaml', 'settings.yml', '.secrets.yaml', '.secrets.yml',\n 'settings.ini', 'settings.conf', 'settings.properties',\n '.secrets.ini', '.secrets.conf', '.secrets.properties',\n 'settings.json', '.secrets.json',\n # redis server if REDIS_FOR_DYNACONF_ENABLED=true\n # vault server if VAULT_FOR_DYNACONF_ENABLED=true\n # other sources if custom loaders are defined\n # All environment variables prefixed with DYNACONF_\n]\n```\n\n> **NOTE:** Dynaconf works in an **override** mode based on the above order, so if you have multiple file formats with conflicting keys defined, the precedence will be based on the loading order.\n\nTake a look at the [example](/example) folder to see some examples of use with different file formats.\n\n## Storing sensitive secrets\n\nTo safely store sensitive data Dynaconf also searches for a `.secrets.{toml|py|json|ini|yaml}` file to look for data like tokens and passwords.\n\nexample `.secrets.toml`:\n\n```toml\n[default]\npassword = \"sek@987342$\"\n```\n\nThe secrets file supports all the **environment** definitions supported in the **settings** file.\n\n> **IMPORTANT**: The reason to use a `.secrets.*` file is the ability to omit this file when commiting to the repository so a recommended `.gitignore` should include `.secrets.*` line. \n\n## Scafolding\n\nDynaconf provides a **CLI** to easily configure your application configuration, once dynaconf is installed go to the root directory of your application and run:\n\n```bash\n$ dynaconf init -v key=value -v otherkey=othervalue -s token=1234 -e production\n```\n\nThe above command will create in the current directory\n\n\n `settings.toml` \n\n```toml\n[default]\nKEY = \"default\"\nOTHERKEY = \"default\"\n\n[production]\nKEY = \"value\"\nOTHERKEY = \"othervalue\"\n```\n\nalso `.secrets.toml`\n\n```toml\n[default]\nTOKEN = \"default\"\n\n[production]\nTOKEN = \"1234\"\n```\n\nThe command will also create a `.env` setting the working environment to **[production]**\n\n```bash\nENV_FOR_DYNACONF=\"PRODUCTION\"\n```\n\nAnd will include the `.secrets.toml` in the `.gitignore`\n\n```conf\n# Ignore dynaconf secret files\n.secrets.*\n```\n\n> **NOTE**: refer to the documentation to see more **CLI** commands to manage your configuration files such as **dynaconf list** and **dynaconf write**\n\n**For sensitive data in production is recommended using http://vaultproject.io as dynaconf supports reading and writing values to vault servers, see `vault loader` documentation**\n\n## Environment variables\n\nAll configuration parameters, including **custom** envs and ***_FOR_DYNACONF** settings, can be overridden through environment variables. To override the configuration parameter **{param}**, use an environment variable named **DYNACONF_{PARAM}**. For instance, to override the **\"host\"** configuration parameter, you can run your application with:\n\n```bash\nDYNACONF_HOST=other.com python yourapp.py\n```\n\n### .env files\n\nIf you don't want to declare the variables on every program call you can `export DYNACONF_*` variables or put the values in `.env` files located in the same directory as your settings files.\n\n### Configuration FOR_DYNACONF\n\nThe **DYNACONF_** prefix is set by **GLOBAL_ENV_FOR_DYNACONF** and serves only to be used in environment variables to override config values.\n\nThis prefix itself can be changed to something more significant for your application, however we recommend kepping **DYNACONF_** as your global env prefix.\n\n> **NOTE**: See the `Configuring Dynaconf` section in documentation to learn more on how to use `.env` variables to configure dynaconf behavior.\n\n### Environment variables precedence and casting\n\nEnvironment variables take precedence over all other configuration sources: if the variable is set, it will be used as the value for the parameter. Variable values are parsed as if they were **TOML** syntax. As illustration, consider the following examples:\n\n```bash\nDYNACONF_INTEGER=1\nDYNACONF_FLOAT=3.14\nDYNACONF_STRING=Hello\n# Use extra quotes to force a string from other type\nDYNACONF_STRING=\"'42'\"\nDYNACONF_STRING=\"'true'\"\nDYNACONF_STRING=\"Hello\"\n# booleans\nDYNACONF_BOOL=true\nDYNACONF_BOOL=false\n# Arrays must be homogenous in toml syntax\nDYNACONF_ARRAY=[1, 2, 3]\nDYNACONF_ARRAY=[1.1, 2.2, 3.3]\nDYNACONF_ARRAY=['a', 'b', 'c']\nDYNACONF_DICT={key=\"abc\",val=123}\n# toml syntax does not allow `None/null` values so use\nDYNACONF_NONE='@none None'\n```\n\n> **NOTE**: Older versions of Dynaconf used the casting prefixes for env vars like `export DYNACONF_INTEGER='@int 123'` still works but this casting is deprecated in favor of using TOML syntax described above. To disable the `@type` casting `export AUTO_CAST_FOR_DYNACONF=false`\n\n#### Boxed values\n\nIn Dynaconf values are Boxed, it means the dot notation can also be used to access dictionary members, example:\n\nsettings.toml\n\n```toml\n[default]\nmysql = {host=\"server.com\", port=3600, auth={user=\"admin\", passwd=1234}}\n```\n\nYou can now access\n\n```python\nfrom dynaconf import settings\n\nconnect(\n    host=settings.MYSQL.host,\n    port=settings.MYSQL.port,\n    username=settings.MYSQL.auth.user,\n    passwd=settings.MYSQL.auth.get('passwd'),\n)\n```\n\n# External storages\n\n## Using Hashicorp Vault to store secrets\n\nThe https://www.vaultproject.io/ is a key:value store for secrets and Dynaconf can load\nvariables from a Vault secret.\n\n1. Run a vault server\nRun a Vault server installed or via docker:\n\n```bash\ndocker run -e 'VAULT_DEV_ROOT_TOKEN_ID=myroot' -p 8200:8200 vault\n```\n\n2. Install support for vault in dynaconf\n\n```bash\npip install dynaconf[vault]\n```\n\n3. In your `.env` file or in environment variables do:\n\n```bash\nVAULT_FOR_DYNACONF_ENABLED=true\nVAULT_FOR_DYNACONF_URL=\"http://localhost:8200\"\nVAULT_FOR_DYNACONF_TOKEN=\"myroot\"\n```\n\nNow you can have keys like `PASSWORD` and `TOKEN` defined in the vault and\ndynaconf will read it.\n\nTo write a new secret you can use http://localhost:8200 web admin and write keys\nunder the `/secret/dynaconf` secret database.\n\nYou can also use the Dynaconf writer via console\n\n```bash\n$ dynaconf write vault -s password=123456\n```\n\n## Using REDIS\n\n\n1  Add the configuration for redis client in your `.env` or export envvars\n\n```bash\nREDIS_FOR_DYNACONF_ENABLED=true\nREDIS_FOR_DYNACONF_HOST=localhost\nREDIS_FOR_DYNACONF_PORT=6379\n```\n\nYou can now write variables direct in to a redis hash named `DYNACONF_< env >`\n\nYou can also use the redis writer\n\n```bash\n$ dynaconf write redis -v name=Bruno -v database=localhost -v port=1234\n```\n\nThe above data will be recorded in redis as a hash:\n\n```\nDYNACONF_DYNACONF {\n    NAME='Bruno'\n    DATABASE='localhost'\n    PORT='@int 1234'\n}\n```\n\n> if you want to skip type casting, write as string intead of PORT=1234 use PORT=\"'1234'\".\n\nData is read from redis and another loaders only once when `dynaconf.settings` is first accessed\nor when `.setenv()` or `using_env()` are invoked. \n\nYou can access the fresh value using **settings.get_fresh(key)**\n\nThere is also the **fresh** context manager\n\n```python\nfrom dynaconf import settings\n\nprint(settings.FOO)  # this data was loaded once on import\n\nwith settings.fresh():\n    print(settings.FOO)  # this data is being freshly reloaded from source\n```\n\nAnd you can also force some variables to be **fresh** setting in your setting file\n\n```python\nFRESH_VARS_FOR_DYNACONF = ['MYSQL_HOST']\n```\n\nor using env vars\n\n```bash\nexport FRESH_VARS_FOR_DYNACONF='[\"MYSQL_HOST\", \"OTHERVAR\"]'\n```\n\nThen\n\n```python\nfrom dynaconf import settings\n\nprint(settings.FOO)         # This data was loaded once on import\n\nprint(settings.MYSQL_HOST)  # This data is being read from redis imediatelly!\n```\n\n# Using programatically\n\nSometimes you want to override settings for your existing Package or Framework\nlets say you have a **conf** module exposing a **config** object and used to do:\n\n```python\nfrom myprogram.conf import config\n```\n\nNow you want to use Dynaconf, open that `conf.py` or `conf/__init__.py` and do:\n\n```python\n# coding: utf-8\nfrom dynaconf import LazySettings\n\nconfig = LazySettings(GLOBAL_ENV_FOR_DYNACONF=\"MYPROGRAM\")\n```\n\nNow you can use `export MYPROGRAM_FOO=bar` instead of `DYNACONF_FOO=bar`\n\n\n## Switching working environments\n\nTo switch the `environment` programatically you can use `setenv` or `using_env`.\n\nUsing context manager\n\n```python\nfrom dynaconf import settings\n\nwith settings.using_env('envname'):\n    # now values comes from [envmane] section of config\n    assert settings.HOST == 'host.com\n```\n\nUsing env setter\n\n```python\nfrom dynaconf import settings\n\nsettings.setenv('envname')\n# now values comes from [envmane] section of config\nassert settings.HOST == 'host.com'\n\nsettings.setenv()\n# now working env are back to previous\n```\n\n\n## Feature flag system (feature toggles)\n\nFeature flagging is a system to dynamically toggle features in your\napplication based in some settings value.\n\nLearn more at: https://martinfowler.com/articles/feature-toggles.html\n\nExample:\n\nwrite flags to redis\n```\n$ dynaconf write redis -s NEWDASHBOARD=1 -e premiumuser\n```\n\nmeaning: Any premium user has NEWDASHBOARD feature enabled!\n\nIn your program do:\n\n```python\nusertype = 'premiumuser'  # assume you loaded it from your database\n\n# user has access to new dashboard?\nif settings.flag('newdashboard', usertype):\n    activate_new_dashboard()\nelse:\n    # User will have old dashboard if not a premiumuser\n    activate_old_dashboard()\n```\n\nThe value is ensured to be loaded fresh from redis server so features can be enabled or \ndisabled at any time without the need to redeploy.\n\nIt also works with file settings but the recommended is redis\nas the data can be loaded once it is updated.\n\n\n# Framework Extensions\n\n## Flask Extension\n\nDynaconf providesa drop in replacement for `app.config` \nThis an extension makes your `app.config` in Flask to be a `dynaconf` instance.\n\n```python\nfrom flask import Flask\nfrom dynaconf import FlaskDynaconf\n\napp = Flask(__name__)\nFlaskDynaconf(app)\n```\n\nNow the `app.config` will work as a `dynaconf.settings` and **FLASK_** will be the\nglobal prefix for exporting environment variables.\n\n```bash\nexport FLASK_DEBUG=true\nexport FLASK_INTVALUE=1\n```\n\nThe working environment will also respect the `FLASK_ENV` variable, so `FLASK_ENV=development` to work \nin development mode or `FLASK_ENV=production` to switch to production.\n\n> **NOTE**: To use `$ dynaconf` CLI the `FLASK_APP` must be defined.\n\n\n## Django Extension\n\nDynaconf a drop in replacement to `django.conf.settings` \nThis an extension makes your `app.config` in Flask to be a `dynaconf` instance.\n\n\nIn your django project's `settings.py` include:\n\n```python\nINSTALLED_APPS = [\n    'dynaconf.contrib.django_dynaconf',\n    ...\n]\n```\n\n> **NOTE**: The extension must be included as the first INSTALLED_APP of the list\n\nNow create your `settings.{py|yaml|toml|ini|json}` in your project's root directory\n(the same folder where `manage.py` is located)\n\nNow **django.conf.settings** will work as a `dynaconf.settings` instance and **DJANGO_** will\nbe the global prefix to export environment variables.\n\n```bash\nexport DJANGO_DEBUG=true\nexport DJANGO_INTVALUE=1\n```\n\nIt is recommended that all the **django's** internal config vars should be kept\nin the `settings.py` of your project, then application specific values your can \nplace in dynaconf's `settings.toml` in the root (same folder as manage.py).\nYou can override settings.py values in the dynaconf settings file.\n\n> **NOTE**: To use `$ dynaconf` CLI the `DJANGO_SETTINGS_MODULE` must be defined and the cli must be called\n> from the same directory where manage.py is placed.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rochacbruno/dynaconf",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dynaconf",
    "package_url": "https://pypi.org/project/dynaconf/",
    "platform": "any",
    "project_url": "https://pypi.org/project/dynaconf/",
    "project_urls": {
      "Homepage": "https://github.com/rochacbruno/dynaconf"
    },
    "release_url": "https://pypi.org/project/dynaconf/1.0.0/",
    "requires_dist": [
      "six",
      "python-box",
      "python-dotenv",
      "toml",
      "click",
      "redis; extra == 'all'",
      "PyYAML; extra == 'all'",
      "configobj; extra == 'all'",
      "hvac; extra == 'all'",
      "configobj; extra == 'configobj'",
      "configobj; extra == 'ini'",
      "redis; extra == 'redis'",
      "toml; extra == 'toml'",
      "hvac; extra == 'vault'",
      "PyYAML; extra == 'yaml'"
    ],
    "requires_python": "",
    "summary": "The dynamic configurator for your Python Project",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17128873,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4ed12d9c6d0e3f34fdf7c0d4f26f1f09c8890106f4c0581e421f592e1e9f9b17",
        "md5": "948cdaeafd67658829c3be0a3ee5aae1",
        "sha256": "a0393ddf59ad4272fb41136b553360bd61ef40e3de238baf22af9cfe60e784aa"
      },
      "downloads": -1,
      "filename": "dynaconf-1.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "948cdaeafd67658829c3be0a3ee5aae1",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 66199,
      "upload_time": "2018-05-28T05:59:19",
      "upload_time_iso_8601": "2018-05-28T05:59:19.224389Z",
      "url": "https://files.pythonhosted.org/packages/4e/d1/2d9c6d0e3f34fdf7c0d4f26f1f09c8890106f4c0581e421f592e1e9f9b17/dynaconf-1.0.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "46d51ce47ebd7df9fc3f96ad3cd8f63161909778c0ab2f4d6b134c360629ecb3",
        "md5": "f050d832086083dd6279698e3f1b2cb7",
        "sha256": "60d5f8830d5952fac7ac490f6173c4ae0d0e6d5cc7c297d533608d640a80c9fe"
      },
      "downloads": -1,
      "filename": "dynaconf-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "f050d832086083dd6279698e3f1b2cb7",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 60963,
      "upload_time": "2018-05-28T05:59:21",
      "upload_time_iso_8601": "2018-05-28T05:59:21.374152Z",
      "url": "https://files.pythonhosted.org/packages/46/d5/1ce47ebd7df9fc3f96ad3cd8f63161909778c0ab2f4d6b134c360629ecb3/dynaconf-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}