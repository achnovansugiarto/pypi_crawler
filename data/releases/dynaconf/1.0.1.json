{
  "info": {
    "author": "Bruno Rocha",
    "author_email": "rochacbruno@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Django",
      "Framework :: Flask",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Utilities"
    ],
    "description": "```\n██████╗ ██╗   ██╗███╗   ██╗ █████╗  ██████╗ ██████╗ ███╗   ██╗███████╗\n██╔══██╗╚██╗ ██╔╝████╗  ██║██╔══██╗██╔════╝██╔═══██╗████╗  ██║██╔════╝\n██║  ██║ ╚████╔╝ ██╔██╗ ██║███████║██║     ██║   ██║██╔██╗ ██║█████╗\n██║  ██║  ╚██╔╝  ██║╚██╗██║██╔══██║██║     ██║   ██║██║╚██╗██║██╔══╝\n██████╔╝   ██║   ██║ ╚████║██║  ██║╚██████╗╚██████╔╝██║ ╚████║██║\n╚═════╝    ╚═╝   ╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝\n```\n\n> **dynaconf** - The **dyna**mic **conf**igurator for your Python Project\n\n[![MIT License](https://img.shields.io/badge/license-MIT-007EC7.svg?style=flat-square)](/LICENSE) [![PyPI](https://img.shields.io/pypi/v/dynaconf.svg)](https://pypi.python.org/pypi/dynaconf) [![PyPI](https://img.shields.io/pypi/pyversions/dynaconf.svg)]() [![Travis CI](http://img.shields.io/travis/rochacbruno/dynaconf.svg)](https://travis-ci.org/rochacbruno/dynaconf) [![codecov](https://codecov.io/gh/rochacbruno/dynaconf/branch/master/graph/badge.svg)](https://codecov.io/gh/rochacbruno/dynaconf) [![Codacy grade](https://img.shields.io/codacy/grade/5074f5d870a24ddea79def463453545b.svg)](https://www.codacy.com/app/rochacbruno/dynaconf/dashboard)\n\n**dynaconf** a layered configuration system for Python applications -\nwith strong support for [12-factor applications](https://12factor.net/config)\nand extensions for **Flask** and **Django**.\n\n**Documentation**: http://dynaconf.readthedocs.io/\n\n# Features\n\n- Strict separation of settings from code (following [12-factor applications](https://12factor.net/config) Guide).\n- Define comprehensive default values.\n- Store parameters in multiple file formats (**.toml**, .json, .yaml, .ini and .py).\n- Sensitive **secrets** like tokens and passwords can be stored in safe places like `.secrets` file or `vault server`.\n- Parameters can optionally be stored in external services like Redis server.\n- Simple **feature flag** system.\n- Layered **[environment]** system.\n- Environment variables can be used to override parameters.\n- Support for `.env` files to automate the export of environment variables.\n- Correct data types (even for environment variables).\n- Have **only one** canonical settings module to rule all your instances.\n- Drop in extension for **Flask** `app.config` object.\n- Drop in extension for **Django** `conf.settings` object.\n- Powerful **$ dynaconf** CLI to help you manage your settings via console.\n- Customizable **Validation** System to ensure correct config parameters.\n- Allow the change of **dyna**mic parameters on the fly without the need to redeploy your application.\n\n## install Dynaconf\n\n> Python 3.x is required\n\n```bash\n# Default installation supports .toml, .py and .json file formats\n# and also overriding from environment variables (.env supported)\n$ pip3 install dynaconf\n```\n\n## Getting Started\n\n### Accessing config variables in your Python application\n\nIn your Python program wherever you need to access a settings variable you use the canonical object `from dynaconf import settings`:\n\n#### Example of program to connect to some database\n\n```python\nfrom some.db import Client\nfrom dynaconf import settings  # import `dynaconf.settings` canonical settings object\n\nconn = Client(\n    username=settings.USERNAME,             # attribute style access\n    password=settings.get('PASSWORD'),      # dict get style access\n    port=settings['PORT'],                  # dict item style access\n    timeout=settings.as_int('TIMEOUT'),     # Forcing casting if needed\n    host=settings.get('HOST', 'localhost')  # Providing defaults if key is not defined\n)\n```\n\n### Where the settings values are stored\n\nDynaconf aims to have a flexible and usable configuration system. Your applications can be configured via a **configuration files**, through **environment variables**, or both. Configurations are separated into environments: **[development], [staging], [testing] and [production]**. The working environment is selected via an environment variable.\n\n**Sensitive data** like tokens, secret keys and password can be stored in `.secrets.*` files and/or external storages like `Redis` or `vault` secrets server.\n\nBesides the built-in optional support to **redis** as settings storage dynaconf allows you to create **custom loaders** and store the data wherever you want e.g: databases, memory storages, other file formats, nosql databases etc.\n\n### environments\n\nAt any point in time, your application is operating in a given configuration environment. By default there are four such environments:\n\n- [development]\n- [staging]\n- [testing]\n- [production]\n\n> You can also define **[custom environment]** and use the pseudo-envs **[default]** to provide comprehensive default values and **[global]** to provide global values to overrride in any other environment.\n\nWithout any action, your applications by default run in the **[development]** environment. The environment can be changed via the `ÈNV_FOR_DYNACONF` environment variable. For example, to launch an application in the **[staging]** environment, we can run:\n\n```bash\nexport ENV_FOR_DYNACONF=staging\n```\n\nor\n\n```bash\nENV_FOR_DYNACONF=staging python yourapp.py\n```\n\n## The settings files\n\nAn optional `settings.{toml|py|json|ini|yaml}` file can be used to specify the configuration parameters for each environment. If it is not present, only the values from **environment variables** are used (**.env** file is also supported). Dynaconf searches for the file starting at the current working directory. If it is not found there, Dynaconf checks the parent directory. Dynaconf continues checking parent directories until the root is reached.\n\nThe recommended file format is **TOML** but you can choose to use any of **.{toml|py|json|ini|yaml}**.\n\nThe file must be a series of sections, at most one for **[default]**, optionally one for each **[environment]**, and an optional **[global]** section. Each section contains **key-value** pairs corresponding to configuration parameters for that **[environment]**. If a configuration parameter is missing, the value from **[default]** is used. The following is a complete `settings.toml` file, where every standard configuration parameter is specified within the **[default]** section:\n\n> **NOTE**: if the file format choosen is `.py` as it does not support sections you can create multiple files like `settings.py` for [default], `development_settings.py`, `production_settings.py` and `global_settings.py`. **ATTENTION** using `.py` is not recommended for configuration use **TOML**!\n\n\n```toml\n[default]\nusername = \"admin\"\nport = 5000\nhost = \"localhost\"\nmessage = \"default message\"\nvalue = \"default value\"\n\n[development]\nusername = \"devuser\"\n\n[staging]\nhost = \"staging.server.com\"\n\n[testing]\nhost = \"testing.server.com\"\n\n[production]\nhost = \"server.com\"\n\n[awesomeenv]\nvalue = \"this value is set for custom [awesomeenv]\"\n\n[global]\nmessage = \"This value overrides message of default and other envs\"\n```\n\nThe **[global]** pseudo-environment can be used to set and/or override configuration parameters globally. A parameter defined in a **[global]** section sets, or overrides if already present, that parameter in every environment. For example, given the following `settings.toml` file, the value of address will be **\"1.2.3.4\"** in every environment:\n\n```toml\n[global]\naddress = \"1.2.3.4\"\n\n[development]\naddress = \"localhost\"\n\n[production]\naddress = \"0.0.0.0\"\n```\n\n> **NOTE**: The **[env]** name and first level variables are case insensitive as internally dynaconf will always use upper case, that means **[development]** and **[DEVELOPMENT]** are equivalent and **address** and **ADDRESS** are also equivalent. This rule does not apply for inner data structures as dictionaries and arrays.\n\n### Settings file supported formats\n\nBy default **toml** is the recommended format to store your configuration, however you can switch to a different supported format.\n\n```bash\n# If you wish to include support for more sources\npip3 install dynaconf[yaml|ini|redis|vault]\n\n# for a complete installation\npip3 install dynaconf[all]\n```\n\nOnce the support is installed no extra configuration is needed to load data from those files, dynaconf will search for settings files in\nthe root directory of your application looking for the following files in the exact order below:\n\n```python\nDYNACONF_LOADING_ORDER = [\n 'settings.py',\n '.secrets.py',\n 'settings.toml',\n '.secrets.toml',\n 'settings.yaml',\n '.secrets.yaml',\n 'settings.ini',\n '.secrets.ini',\n 'settings.json',\n '.secrets.json',\n # redis server if REDIS_ENABLED_FOR_DYNACONF=true\n # vault server if VAULT_ENABLED_FOR_DYNACONF=true\n # other sources if custom loaders are defined\n # All environment variables prefixed with DYNACONF_\n]\n```\n\n> **NOTE:** Dynaconf works in an **layered override** mode based on the above order, so if you have multiple file formats with conflicting keys defined, the precedence will be based on the loading order.\n\nTake a look at the [example](/example) folder to see some examples of use with different file formats.\n\n## Storing sensitive secrets\n\nTo safely store sensitive data Dynaconf also searches for a `.secrets.{toml|py|json|ini|yaml}` file to look for data like tokens and passwords.\n\nexample `.secrets.toml`:\n\n```toml\n[default]\npassword = \"sek@987342$\"\n```\n\nThe secrets file supports all the **environment** definitions supported in the **settings** file.\n\n> **IMPORTANT**: The reason to use a `.secrets.*` file is the ability to omit this file when commiting to the repository so a recommended `.gitignore` should include `.secrets.*` line.\n\n## Scafolding\n\nDynaconf provides a **CLI** to easily configure your application configuration, once dynaconf is installed go to the root directory of your application and run:\n\n```bash\n# creates settings files in current directory\n$ dynaconf init -v key=value -v otherkey=othervalue -s token=1234 -e production\n```\n\nThe above command will create in the current directory\n\n`settings.toml`\n\n```toml\n[default]\nKEY = \"default\"\nOTHERKEY = \"default\"\n\n[production]\nKEY = \"value\"\nOTHERKEY = \"othervalue\"\n```\n\nalso `.secrets.toml`\n\n```toml\n[default]\nTOKEN = \"default\"\n\n[production]\nTOKEN = \"1234\"\n```\n\nThe command will also create a `.env` setting the working environment to **[production]**\n\n```bash\nENV_FOR_DYNACONF=\"PRODUCTION\"\n```\n\nAnd will include the `.secrets.toml` in the `.gitignore`\n\n```conf\n# Ignore dynaconf secret files\n.secrets.*\n```\n\n> **NOTE**: refer to the documentation to see more **CLI** commands to manage your configuration files such as **dynaconf list** and **dynaconf write**\n\n**For sensitive data in production is recommended using http://vaultproject.io as dynaconf supports reading and writing values to vault servers, see `vault loader` documentation**\n\n## Environment variables\n\nAll configuration parameters, including **custom** envs and ***_FOR_DYNACONF** settings, can be overridden through environment variables. To override the configuration parameter **{param}**, use an environment variable named **DYNACONF_{PARAM}**. For instance, to override the **\"host\"** configuration parameter, you can run your application with:\n\n```bash\nDYNACONF_HOST=other.com python yourapp.py\n```\n\n### .env files\n\nIf you don't want to declare the variables on every program call you can `export DYNACONF_*` variables or put the values in `.env` files located in the same directory as your settings files.\n\n### Configuration FOR_DYNACONF\n\nThe **DYNACONF_** prefix is set by **GLOBAL_ENV_FOR_DYNACONF** and serves only to be used in environment variables to override config values.\n\nThis prefix itself can be changed to something more significant for your application, however we recommend kepping **DYNACONF_** as your global env prefix.\n\n> **NOTE**: See the `Configuring Dynaconf` section in documentation to learn more on how to use `.env` variables to configure dynaconf behavior.\n\n### Environment variables precedence and casting\n\nEnvironment variables take precedence over all other configuration sources: if the variable is set, it will be used as the value for the parameter. Variable values are parsed as if they were **TOML** syntax. As illustration, consider the following examples:\n\n```bash\nDYNACONF_INTEGER=42\nDYNACONF_FLOAT=3.14\nDYNACONF_STRING=Hello\nDYNACONF_STRING=\"Hello\"\n\n# booleans\nDYNACONF_BOOL=true\nDYNACONF_BOOL=false\n\n# Use extra quotes to force a string from other type\nDYNACONF_STRING=\"'42'\"\nDYNACONF_STRING=\"'true'\"\n\n# Arrays must be homogenous in toml syntax\nDYNACONF_ARRAY=[1, 2, 3]\nDYNACONF_ARRAY=[1.1, 2.2, 3.3]\nDYNACONF_ARRAY=['a', 'b', 'c']\nDYNACONF_DICT={key=\"abc\",val=123}\n\n# toml syntax does not allow `None/null` values so use @none\nDYNACONF_NONE='@none None'\n\n# toml syntax does not allow mixed type arrays so use @json\nDYNACONF_ARRAY='@json [42, 3.14, \"hello\", true, [\"otherarray\"], {\"foo\": \"bar\"}]'\n```\n\n> **NOTE**: Older versions of Dynaconf used the `@casting` prefixes for env vars like `export DYNACONF_INTEGER='@int 123'` still works but this casting is deprecated in favor of using TOML syntax described above. To disable the `@casting` do `export AUTO_CAST_FOR_DYNACONF=false`\n\n#### Boxed values\n\nIn Dynaconf values are Boxed, it means the dot notation can also be used to access dictionary members, example:\n\nsettings.toml\n\n```toml\n[default]\nmysql = {host=\"server.com\", port=3600, auth={user=\"admin\", passwd=1234}}\n```\n\nYou can now access\n\n```python\nfrom dynaconf import settings\n\nconnect(\n    host=settings.MYSQL.host,\n    port=settings.MYSQL.port,\n    username=settings.MYSQL.auth.user,\n    passwd=settings.MYSQL.auth.get('passwd'),\n)\n```\n\n# External storages\n\n## Using Hashicorp Vault to store secrets\n\nThe https://www.vaultproject.io/ is a key:value store for secrets and Dynaconf can load\nvariables from a Vault secret.\n\n1. Run a vault server\n\nRun a Vault server installed or via docker:\n\n```bash\n$ docker run -d -e 'VAULT_DEV_ROOT_TOKEN_ID=myroot' -p 8200:8200 vault\n```\n\n2. Install support for vault in dynaconf\n\n```bash\n$ pip install dynaconf[vault]\n```\n\n3. In your `.env` file or in exported environment variables define:\n\n```bash\nVAULT_ENABLED_FOR_DYNACONF=true\nVAULT_URL_FOR_DYNACONF=\"http://localhost:8200\"\nVAULT_TOKEN_FOR_DYNACONF=\"myroot\"\n```\n\nNow you can have keys like `PASSWORD` and `TOKEN` defined in the vault and\ndynaconf will read it.\n\nTo write a new secret you can use http://localhost:8200 web admin and write keys\nunder the `/secret/dynaconf` secret database.\n\nYou can also use the Dynaconf writer via console\n\n```bash\n$ dynaconf write vault -s password=123456\n```\n\n## Using REDIS\n\n1. Run a Redis server installed or via docker:\n\n```bash\n$ docker run -d -p 6379:6379 redis\n```\n\n2. Install support for redis in dynaconf\n\n```bash\n$ pip install dynaconf[redis]\n```\n\n3. In your `.env` file or in exported environment variables define:\n\n```bash\nREDIS_ENABLED_FOR_DYNACONF=true\nREDIS_HOST_FOR_DYNACONF=localhost\nREDIS_PORT_FOR_DYNACONF=6379\n```\n\nYou can now write variables direct in to a redis hash named `DYNACONF_< env >`\n\nYou can also use the redis writer\n\n```bash\n$ dynaconf write redis -v name=Bruno -v database=localhost -v port=1234\n```\n\nThe above data will be recorded in redis as a hash:\n\n```\nDYNACONF_DYNACONF {\n    NAME='Bruno'\n    DATABASE='localhost'\n    PORT='@int 1234'\n}\n```\n\n> if you want to skip type casting, write as string intead of PORT=1234 use PORT=\"'1234'\".\n\nData is read from redis and another loaders only once when `dynaconf.settings` is first accessed\nor when `.setenv()` or `using_env()` are invoked.\n\nYou can access the fresh value using **settings.get_fresh(key)**\n\nThere is also the **fresh** context manager\n\n```python\nfrom dynaconf import settings\n\nprint(settings.FOO)  # this data was loaded once on import\n\nwith settings.fresh():\n    print(settings.FOO)  # this data is being freshly reloaded from source\n```\n\nAnd you can also force some variables to be **fresh** setting in your setting file\n\n```python\nFRESH_VARS_FOR_DYNACONF = ['MYSQL_HOST']\n```\n\nor using env vars\n\n```bash\nexport FRESH_VARS_FOR_DYNACONF='[\"MYSQL_HOST\", \"OTHERVAR\"]'\n```\n\nThen\n\n```python\nfrom dynaconf import settings\n\nprint(settings.FOO)         # This data was loaded once on import\n\nprint(settings.MYSQL_HOST)  # This data is being read from redis imediatelly!\n```\n\n# Using programatically\n\nSometimes you want to override settings for your existing Package or Framework\nlets say you have a **conf** module exposing a **config** object and used to do:\n\n```python\nfrom myprogram.conf import config\n```\n\nNow you want to use Dynaconf, open that `conf.py` or `conf/__init__.py` and do:\n\n```python\n# coding: utf-8\nfrom dynaconf import LazySettings\n\nconfig = LazySettings(GLOBAL_ENV_FOR_DYNACONF=\"MYPROGRAM\")\n```\n\nNow you can use `export MYPROGRAM_FOO=bar` instead of `DYNACONF_FOO=bar`\n\n\n## Switching working environments\n\nTo switch the `environment` programatically you can use `setenv` or `using_env`.\n\nUsing context manager\n\n```python\nfrom dynaconf import settings\n\nwith settings.using_env('envname'):\n    # now values comes from [envmane] section of config\n    assert settings.HOST == 'host.com\n```\n\nUsing env setter\n\n```python\nfrom dynaconf import settings\n\nsettings.setenv('envname')\n# now values comes from [envmane] section of config\nassert settings.HOST == 'host.com'\n\nsettings.setenv()\n# now working env are back to previous\n```\n\n\n## Feature flag system (feature toggles)\n\nFeature flagging is a system to dynamically toggle features in your\napplication based in some settings value.\n\nLearn more at: https://martinfowler.com/articles/feature-toggles.html\n\nExample:\n\nwrite flags to redis\n```\n$ dynaconf write redis -s NEWDASHBOARD=1 -e premiumuser\n```\n\nmeaning: Any premium user has NEWDASHBOARD feature enabled!\n\nIn your program do:\n\n```python\nusertype = 'premiumuser'  # assume you loaded it from your database\n\n# user has access to new dashboard?\nif settings.flag('newdashboard', usertype):\n    activate_new_dashboard()\nelse:\n    # User will have old dashboard if not a premiumuser\n    activate_old_dashboard()\n```\n\nThe value is ensured to be loaded fresh from redis server so features can be enabled or \ndisabled at any time without the need to redeploy.\n\nIt also works with file settings but the recommended is redis\nas the data can be loaded once it is updated.\n\n\n# Framework Extensions\n\n## Flask Extension\n\nDynaconf providesa drop in replacement for `app.config` \nThis an extension makes your `app.config` in Flask to be a `dynaconf` instance.\n\n```python\nfrom flask import Flask\nfrom dynaconf import FlaskDynaconf\n\napp = Flask(__name__)\nFlaskDynaconf(app)\n```\n\nNow the `app.config` will work as a `dynaconf.settings` and **FLASK_** will be the\nglobal prefix for exporting environment variables.\n\n```bash\nexport FLASK_DEBUG=true\nexport FLASK_INTVALUE=1\n```\n\nThe working environment will also respect the `FLASK_ENV` variable, so `FLASK_ENV=development` to work \nin development mode or `FLASK_ENV=production` to switch to production.\n\n> **NOTE**: To use `$ dynaconf` CLI the `FLASK_APP` must be defined.\n\n\n## Django Extension\n\nDynaconf a drop in replacement to `django.conf.settings` \nThis an extension makes your `app.config` in Flask to be a `dynaconf` instance.\n\n\nIn your django project's `settings.py` include:\n\n```python\nINSTALLED_APPS = [\n    'dynaconf.contrib.django_dynaconf',\n    ...\n]\n```\n\n> **NOTE**: The extension must be included as the first INSTALLED_APP of the list\n\nNow create your `settings.{py|yaml|toml|ini|json}` in your project's root directory\n(the same folder where `manage.py` is located)\n\nNow **django.conf.settings** will work as a `dynaconf.settings` instance and **DJANGO_** will\nbe the global prefix to export environment variables.\n\n```bash\nexport DJANGO_DEBUG=true\nexport DJANGO_INTVALUE=1\n```\n\nIt is recommended that all the **django's** internal config vars should be kept\nin the `settings.py` of your project, then application specific values your can \nplace in dynaconf's `settings.toml` in the root (same folder as manage.py).\nYou can override settings.py values in the dynaconf settings file.\n\n> **NOTE**: To use `$ dynaconf` CLI the `DJANGO_SETTINGS_MODULE` must be defined and the cli must be called\n> from the same directory where manage.py is placed.\n\n## DEBUGGING\n\nBy default Dynaconf only outputs the `ERROR` level of logs and you can change it:\n\n```bash\nexport DEBUG_LEVEL_FOR_DYNACONF=DEBUG\n```\n\n## Customizing the loaders\n\nIn your project i.e called `myprogram` create your custom loader.\n\n`myprogram/my_custom_loader.py`\n\n```python\ndef load(obj, env=None, silent=True, key=None, filename=None):\n    \"\"\"\n    Reads and loads in to \"obj\" a single key or all keys from source\n    :param obj: the settings instance\n    :param env: settings current env default='development'\n    :param silent: if errors should raise\n    :param key: if defined load a single key, else load all in env\n    :param filename: Custom filename to load\n    :return: None\n    \"\"\"\n    # Load data from your custom data source (file, database, memory etc)\n    # use `obj.set` or `obj.update` to include the data in dynaconf\n```\n\nIn the `.env` file or exporting the envvar define:\n\n```bash\nLOADERS_FOR_DYNACONF=['myprogram.my_custom_loader', 'dynaconf.loaders.env_loader']\n```\n\nDynaconf will import your `myprogram.my_custom_loader.load` and call it.\n\n> **IMPORTANT**: the `'dynaconf.loaders.env_loader'` must be the last in the loaders list\n> if you want to keep the behavior of having envvars to override parameters.\n\nIn case you need to disable all external loaders and ue only the `settings.*` file loaders define:\n\n```bash\nLOADERS_FOR_DYNACONF=false\n```\n\n## Testing and mocking\n\nFor testing it is recommended to just switch to `testing` environment and read the same config files.\nBut it is common in unit tests to `mock` some objects and you may need in rare cases to mock the `dynaconf.settings` when running your tests.\n\n```python\nfrom dynaconf.utils import DynaconfDict\nmocked_settings = DynaconfDict({'FOO': 'BAR'})\n```\n\nDynaconfDict is a dict like obj that can be populated from a file:\n\n```python\nfrom dynaconf.loaders import toml_loader\ntoml_loader.load(mocked_settings, filename='my_file.toml', env='testing')\n```\n\n## Validation\n\nDynaconf allows the validation of settings parameters, in some cases you may want to validate the settings before starting the program.\n\nLets say you have `settings.toml`\n\n```toml\n[default]\nversion = \"1.0.0\"\nage = 35\nname = \"Bruno\"\n\n[production]\nPROJECT = \"This is not hello_world\"\n```\n\nAt any point of your program you can do:\n\n```python\nfrom dynaconf import settings, Validator\n\n# Register validators\nsettings.validators.register(\n    # Ensure some parameters exists (are required)\n    Validator('VERSION', 'AGE', 'NAME', must_exist=True),\n\n    # Ensure some password cannot exist\n    Validator('PASSWORD', must_exist=False),\n\n    # Ensure some parameter mets a condition\n    # conditions: (eq, ne, lt, gt, lte, gte, identity, is_type_of, is_in, is_not_in)\n    Validator('AGE', lte=30, gte=10),\n\n    # validate a value is eq in specific env\n    Validator('PROJECT', eq='hello_world', env='production'),\n)\n\n# Fire the validator\nsettings.validators.validate()\n```\n\nThe above will raise `dynaconf.validators.ValidationError(\"AGE must be lte=30 but it is 35 in env DEVELOPMENT\")` and `dynaconf.validators.ValidationError(\"PROJECT must be eq='hello_world' but it is 'This is not hello_world' in env PRODUCTION\")`\n\n### Using dynaconf_validators.toml\n\n> **NEW in 1.0.1**\n\nStarting on version 1.0.1 it is possible to define validators in **TOML** file called **dynaconf_validators.toml** placed in the same fodler as your settings files.\n\n`dynaconf_validators.toml` equivalent to program above\n\n```toml\n[default]\n\nversion = {must_exist=true}\nname = {must_exist=true}\npassword = {must_exist=false}\n\n  [default.age]\n  must_exist = true\n  lte = 30\n  gte = 10\n\n[production]\nproject = {eq=\"hello_world\"}\n```\n\nThen to fire the validation use:\n\n```bash\n$ dynaconf validate\n```\n\n## The dynaconf CLI\n\nThe `$ dynaconf` cli provides some useful commands\n\n```bash\nUsage: dynaconf [OPTIONS] COMMAND [ARGS]...\n\n  Dynaconf - Command Line Interface\n\nOptions:\n  --version  Show dynaconf version\n  --docs     Open documentation in browser\n  --help     Show this message and exit.\n\nCommands:\n  banner    Shows dynaconf awesome banner\n  init      Inits a dynaconf project By default it...\n  list      Lists all defined config values\n  write     Writes data to specific source\n  validate  Validates based on dynaconf_validators.toml file\n```\n\n## More examples\n\nTake a look at [example/](/example) for more.\n\n## Credits\n\n- Dynaconf is inspired by `flask.config` and `django.conf.settings`\n- Some ideas also taken from Rust `config` crate\n- Environments definitions ideas taken from Rust `rocket` framework\n\n## Alternatives\n\nDynaconf tries to define standard and good practices for config and aims to have flexibility and 100% of test coverage for Python 3.x.\n\nDynaconf implements the best parts of the alternatives below, to implement Dynaconf lots of configuration libraties have been tested and studied.\n\nBut if you are still looking for something different take a look at the following excellent alternatives.\n\n- [Python Decouple](https://github.com/henriquebastos/python-decouple)\n- [PrettyConf](https://github.com/osantana/prettyconf)\n- [Profig](https://bitbucket.org/dhagrow/profig)\n- [Everett](https://github.com/willkg/everett)\n- [Configman](https://configman.readthedocs.io/en/latest/)\n- [PyMLconf](https://pypi.org/project/pymlconf/)\n- [AnyConfig](https://github.com/ssato/python-anyconfig)\n- [Config](https://pypi.org/project/config/)\n- [Conman](https://github.com/the-gigi/conman)\n\n```\n██████╗ ██╗   ██╗███╗   ██╗ █████╗  ██████╗ ██████╗ ███╗   ██╗███████╗\n██╔══██╗╚██╗ ██╔╝████╗  ██║██╔══██╗██╔════╝██╔═══██╗████╗  ██║██╔════╝\n██║  ██║ ╚████╔╝ ██╔██╗ ██║███████║██║     ██║   ██║██╔██╗ ██║█████╗\n██║  ██║  ╚██╔╝  ██║╚██╗██║██╔══██║██║     ██║   ██║██║╚██╗██║██╔══╝\n██████╔╝   ██║   ██║ ╚████║██║  ██║╚██████╗╚██████╔╝██║ ╚████║██║\n╚═════╝    ╚═╝   ╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝\n```\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rochacbruno/dynaconf",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dynaconf",
    "package_url": "https://pypi.org/project/dynaconf/",
    "platform": "any",
    "project_url": "https://pypi.org/project/dynaconf/",
    "project_urls": {
      "Homepage": "https://github.com/rochacbruno/dynaconf"
    },
    "release_url": "https://pypi.org/project/dynaconf/1.0.1/",
    "requires_dist": [
      "six",
      "python-box",
      "python-dotenv",
      "toml",
      "click",
      "redis; extra == 'all'",
      "PyYAML; extra == 'all'",
      "configobj; extra == 'all'",
      "hvac; extra == 'all'",
      "configobj; extra == 'configobj'",
      "configobj; extra == 'ini'",
      "redis; extra == 'redis'",
      "toml; extra == 'toml'",
      "hvac; extra == 'vault'",
      "PyYAML; extra == 'yaml'"
    ],
    "requires_python": "",
    "summary": "The dynamic configurator for your Python Project",
    "version": "1.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17128873,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0455862724e8fda11b11121055df1e22227bbda4c047785f9ca0c1141b122a76",
        "md5": "aa2bfea60d2a7471294e2b0e20c49baa",
        "sha256": "1134a6ca56ed6f19622fcada360d66e02e14fc4537d5a717484cdfd7dbab8ce0"
      },
      "downloads": -1,
      "filename": "dynaconf-1.0.1-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "aa2bfea60d2a7471294e2b0e20c49baa",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 77757,
      "upload_time": "2018-05-30T01:40:34",
      "upload_time_iso_8601": "2018-05-30T01:40:34.927296Z",
      "url": "https://files.pythonhosted.org/packages/04/55/862724e8fda11b11121055df1e22227bbda4c047785f9ca0c1141b122a76/dynaconf-1.0.1-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3935075d8a21a2f39095c1967dc17976c8b2ea4260d8eb71e4b58a8730161f1e",
        "md5": "0738bbf0e46f02bcd7f9d090c8fafcee",
        "sha256": "bf22ca0320c25e0beda791eb1cef42ee440be712d8c2546e9d495f26b98a9b07"
      },
      "downloads": -1,
      "filename": "dynaconf-1.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "0738bbf0e46f02bcd7f9d090c8fafcee",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 68488,
      "upload_time": "2018-05-30T01:40:37",
      "upload_time_iso_8601": "2018-05-30T01:40:37.481382Z",
      "url": "https://files.pythonhosted.org/packages/39/35/075d8a21a2f39095c1967dc17976c8b2ea4260d8eb71e4b58a8730161f1e/dynaconf-1.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}