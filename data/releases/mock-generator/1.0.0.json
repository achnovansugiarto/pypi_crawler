{
  "info": {
    "author": "Peter Kogan",
    "author_email": "kogan.peter@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "# Mock Generator\n![](https://github.com/pksol/mock_autogen/workflows/CI/badge.svg?branch=master)\n![](https://img.shields.io/pypi/v/mock-generator.svg)\n![](https://img.shields.io/pypi/pyversions/mock-generator.svg)\n![](https://codecov.io/gh/pksol/mock_autogen/branch/master/graph/badge.svg)\n![](https://img.shields.io/powershellgallery/p/DNS.1.1.1.1)\n![](https://img.shields.io/pypi/l/mock-generator.svg)\n\nA tool to generate the basic mocks and asserts for faster unit testing. \n\n## Introduction\nA typical unit test looks like this (AAA pattern):\n* Arrange – Setup and prepare the various objects and prerequisites.\n* Act – Invoke the tested code by calling the tested function for example.\n* Assert – Verify the outcome. This can be the return value of the tested \nfunction and/or some side effects.\n\nAs it turns out, much of the time spent on doing unit tests is wasted on wiring\nthe various modules and functions and only a fraction of the time is spent on\nthe actual logic of the test. The `Arrange` and `Assert` sections are notorious\nin that regard. \n\nThis tool is meant to save you much of the time and effort of generating \nboilerplates, by generating the `Arrange` and `Assert` sections. \nThe generated code can then be used as is, or altered according to your needs.\n\n## Usage\nNote: All examples assume the \n[pytest-mock](https://pypi.org/project/pytest-mock/) which is a fixture for\n[pytest](https://pypi.org/project/pytest/). \n\n### Simple example\nLet's start with a simple code example. Say you have a module `os_wrapper.py`:\n```python\nimport os \n\ndef os_remove_wrap(filename):\n    os.remove(filename)\n```\nYou would like to test that the `os.remove` function is called with the same\nvalue sent to your wrapping function. The test would look something like this:\n```python\ndef test_os_remove_wrap(mocker):\n    # Arrange: setup any mocks to avoid deleting actual files\n\n    # Act: invoking the tested code\n    os_wrapper.os_remove_wrap('/my/path/to/file.txt')\n\n    # Assert: verifying that the original os.remove function was called\n```\n\n#### Generating the Arrange section\nThe following code sends the tested module to the tool, along with instructions \nwhich indicate the desired testing framework and which mocks to generate\n(we would like to use pytest-mock fixture and only mock the referenced \nmodules):   \n\n```python\nimport os_wrapper\nfrom mock_autogen.pytest_mocker import PytestMocker\n\ngenerated_mocks = PytestMocker(os_wrapper).mock_modules().generate() \n```\nThe `generated_mocks` variable now has the desired code: \n```python\n# mocked modules\nmock_os = mocker.MagicMock(name='os')\nmocker.patch('os_wrapper.os', new=mock_os)\n```\nSimply copy the code and place it in your test, before the `Act` section: \n```python\nimport os_wrapper\n\ndef test_os_remove_wrap(mocker):\n    # Arrange: setup any mocks to avoid deleting actual files\n    # auto generated code\n    # mocked modules\n    mock_os = mocker.MagicMock(name='os')\n    mocker.patch('os_wrapper.os', new=mock_os)\n\n    # Act: invoking the tested code\n    os_wrapper.os_remove_wrap('/my/path/to/file.txt')\n\n    # Assert: verifying that the original os.remove function was called\n```\n\n#### Generating the Assert section\nNow it's time to add the asserts. Add the following code right after the Act \nstep:\n```python\nimport mock_autogen\n\ngenerated_asserts = mock_autogen.generator.generate_asserts(mock_os)\n```\nThe `mock_os` is the mocked object you created earlier.\n\nThe `generated_asserts` variable now has the desired code: \n```python\nmock_os.remove.assert_called_once_with('/my/path/to/file.txt')\n```\nPlace that code right after the act phase and you're done!\n\nThe complete test function:\n```python\nimport os_wrapper\n\ndef test_os_remove_wrap(mocker):\n    # Arrange: setup any mocks to avoid deleting actual files\n    # auto generated code\n    # mocked modules\n    mock_os = mocker.MagicMock(name='os')\n    mocker.patch('os_wrapper.os', new=mock_os)\n\n    # Act: invoking the tested code\n    os_wrapper.os_remove_wrap('/my/path/to/file.txt')\n\n    # Assert: verifying that the original os.remove function was called\n    # auto generated code\n    mock_os.remove.assert_called_once_with('/my/path/to/file.txt')\n```\nAs can be seen, most of the code was autogenerated so you can focus on the Act.\n\n### Complex example\nThe previous example was meant to demonstrate how to use the tool. If you have\nexperience with pytest-mock than you could have probably come up with the same\nboilerplate code by yourself in a reasonable time. The next example requires \nthe exact same steps to invoke the tool as before, but the benefit is much \ngreater.  \n\nLet's assume you have a module `zip_writer.py` which holds a function to\nprocess a string sent to it and then add it to a zip file:\n```python\nimport zipfile\n\ndef process_and_zip(zip_path, file_name, contents):\n    processed_contents = \"processed \" + contents  # some complex logic\n    with zipfile.ZipFile(zip_path, 'w') as zip_container:\n        zip_container.writestr(file_name, processed_contents)\n```\nAlthough this is a very short function, which does not do anything complex, \nwriting the test code takes a lot of time. It's the fact that the function uses\na context manager makes the testing more complex than it should be. \n\nSince the process of generating the test code is the same as in the previous \nexample, there is no need to repeat it. Let's look at the complete code:\n```python\nimport zip_writer\n\ndef test_process_and_zip(mocker):\n    # Arrange: auto generated code \n    mock_zipfile = mocker.MagicMock(name='zipfile')\n    mocker.patch('tests.sample.code.tested_module.zipfile', new=mock_zipfile)\n\n    # Act: invoking the tested code\n    zip_writer.process_and_zip('/path/to.zip', 'in_zip.txt', 'foo bar')\n\n    # Assert: auto generated code\n    mock_zipfile.ZipFile.assert_called_once_with('/path/to.zip', 'w')\n    mock_zipfile.ZipFile.return_value.__enter__.assert_called_once_with()\n    mock_zipfile.ZipFile.return_value.__enter__.return_value.writestr. \\\n        assert_called_once_with('in_zip.txt', 'processed foo bar')\n    mock_zipfile.ZipFile.return_value.__exit__. \\\n        assert_called_once_with(None, None, None)\n```\nLook at all the asserts. They are very useful: \n* Checking that we opened the zip file with the right parameters.\n* Checking that we wrote the correct data to the proper file.\n* And finally, ensuring that `__enter__` and `__exit__` are called, so there \nare no open file handles which could cause problems.\n\nCan you imagine the time it would have taken you to code this on your own?\n\n### What's Next\n#### Mocking Everything\nAfter you have followed through this example, you can use the Mock Generator \nto **mock everything**. This way you can see all the possibilities of mocks. You \ncan also print the result right away, to avoid having to inspect variables. \nIt can look something like this:\n```python\nimport os_wrapper\nfrom mock_autogen.pytest_mocker import PytestMocker\n\nprint(PytestMocker(os_wrapper).mock_everything().generate()) \n```\nWhat you would get is:\n```python\n# mocked modules\nmock_os = mocker.MagicMock(name='os')\nmocker.patch('os_wrapper.os', new=mock_os)\n# mocked functions\nmock_os_remove_wrap = mocker.MagicMock(name='os_remove_wrap')\nmocker.patch('os_wrapper.os_remove', new=mock_os_remove_wrap)\n# calls to generate_asserts, put this after the 'act'\nimport mock_autogen\nprint(mock_autogen.generator.generate_asserts(mock_os, name='mock_os'))\nprint(mock_autogen.generator.generate_asserts(mock_os_remove_wrap, name='mock_os_remove_wrap'))\n```\nNotice the mocked functions section, it allows you to mock functions in\nthat model. This is useful when you're testing a function which uses\nanother function you would like to mock.\n\nYou even get the calls to generate the asserts prepared for you, place\nthis code after the act section as shown in the simple example. \n\n#### Asserting Existing Mocks\nAt times, you may be editing a legacy code already containing mocks, or\nyou may choose to write the mocks yourself, to gain some extra control.\n\nYou can use the mock generator to generate the asserts for you, for\nany given `Mock` or `MagicMock`, like so (replace `mockObj`): \n```python\n# calls to generate_asserts, put this after the 'act'\nimport mock_autogen.generator\nprint(mock_autogen.generator.generate_asserts(mockObj))\n```\n\n## Wrapping up\nI hope that by now you were convinced that this tool can save you a lot of \ntime. \n\nSee `tests` folder for additional usage examples like mocking classes and \ninstances, using fixtures to share mocks between tests and much more.\n\nIf you would like to contribute, I'm accepting pull requests :)\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/pksol/mock_autogen",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mock-generator",
    "package_url": "https://pypi.org/project/mock-generator/",
    "platform": "",
    "project_url": "https://pypi.org/project/mock-generator/",
    "project_urls": {
      "Homepage": "https://github.com/pksol/mock_autogen"
    },
    "release_url": "https://pypi.org/project/mock-generator/1.0.0/",
    "requires_dist": [
      "mock (==3.0.5)"
    ],
    "requires_python": ">=3.5",
    "summary": "Generate python mocks and assertions quickly",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13825478,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e1a2500dba31e167e28c136a974e2261b1051d7b156f6c6efa67ae417185615c",
        "md5": "48f4d59253f085087dac81ce9f2033a4",
        "sha256": "bbc6b9d611ef4fe578b4bc9712cf2d7b2ee6253e07845eb049f57482a545de2c"
      },
      "downloads": -1,
      "filename": "mock_generator-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "48f4d59253f085087dac81ce9f2033a4",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.5",
      "size": 17323,
      "upload_time": "2020-04-16T07:36:14",
      "upload_time_iso_8601": "2020-04-16T07:36:14.479976Z",
      "url": "https://files.pythonhosted.org/packages/e1/a2/500dba31e167e28c136a974e2261b1051d7b156f6c6efa67ae417185615c/mock_generator-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "06642917fa52f425c8e6062f7908b222efbe81b77d60fbc543cdfd4f0103d9b6",
        "md5": "940bcda3f613fb221b85b82fac4cad9e",
        "sha256": "015469ba12b69b069f5acbe635cc9ef8f330e17ed19e223a12d69c404814d85f"
      },
      "downloads": -1,
      "filename": "mock-generator-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "940bcda3f613fb221b85b82fac4cad9e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 14428,
      "upload_time": "2020-04-16T07:36:15",
      "upload_time_iso_8601": "2020-04-16T07:36:15.751331Z",
      "url": "https://files.pythonhosted.org/packages/06/64/2917fa52f425c8e6062f7908b222efbe81b77d60fbc543cdfd4f0103d9b6/mock-generator-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}