{
  "info": {
    "author": "Robin Neville",
    "author_email": "robin.m.neville@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Django Rest Framework Versioning\n\n## Project description \nThis project aims to make it easy to support many different API versions in a Django REST Framework (DRF) project.\n\nDRF [supports several versioning schemes](https://www.django-rest-framework.org/api-guide/versioning/) but (perhaps wisely) completely sidesteps the issue of how to deal with the different versions in your code. To quote the docs: \"How you vary the API behavior is up to you\". \n\nDjango Rest Framework Versioning aims to provide some out-of-the box tools to handle versioning in the code. It is inspired by Stripe's API version \"compatibility layer\", as described in blog posts by [Brandur Leach](https://stripe.com/blog/api-versioning) and [Amber Feng](https://amberonrails.com/move-fast-dont-break-your-api). I used [Ryan Kaneshiro's](https://rescale.com/blog/api-versioning-with-the-django-rest-framework/) excellent Django sketch as a starting point. \n\n## Installation quick start\n\nThis section is intended for those who want to install DRF Versioning into an existing Django project.\n\n**1. Create a versioning module: `./manage.py startapp versioning` or `mkdir versioning`**\n\nSuggested structure:\n\n```\n└── versioning\n    ├── __init__.py\n    ├── version_list.py    # maintain the list of supported Versions here\n    └── versions.py        # define your Version instances here\n```\n\nwith `versions.py` containing:\n\n```python\nfrom drf_versioning.versions import Version\n\nVERSION_1_0_0 = Version(\n    \"1.0.0\",\n    notes=[\"Initial version\"],\n)\n```\n\nand `version_list.py` containing:\n\n```python\nfrom . import versions\n\nVERSIONS = [\n    versions.VERSION_1_0_0,\n]\n```\n\n**2. Update project settings**\n\nIn your project `settings.py` add:\n\n```python\nREST_FRAMEWORK = {\n    ...,  # any other rest_framework settings\n    \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\",\n}\n\nDRF_VERSIONING_SETTINGS = {\n    \"VERSION_LIST\": \"versioning.version_list.VERSIONS\",\n    \"DEFAULT_VERSION\": \"latest\",\n}\n```\n\n**3. (Optional) add versioning urls**\n\nIn your project `urls.py`:\n\n```python\nurlpatterns = [\n    ...,  # your other urls\n    path(\"version/\", include(\"drf_versioning.urls\")),\n]\n```\n\n## Tutorial\n\n### Django project setup\n\nTo showcase the features of this library, we will set up a basic Django Rest Framework project. If you want to install DRF Versioning into an existing project, feel free to skip to the **[DRF versioning installation](#drf-versioning-installation)** section. The [Django tutorial](https://docs.djangoproject.com/en/4.1/intro/tutorial01/) may also be helpful if you are doing this for the first time.\n\n[Create a project directory and a virtual environment](https://realpython.com/python-virtual-environments-a-primer/), and inside it create `requirements.txt` with the following contents:\n\n```\ndjango\ndjangorestframework\ndjangorestframework-versioning\n```\n\nand run\n\n```shell\npip install -r requirements.txt\n```\n\n```shell\ndjango-admin startproject mysite\n```\n\nstart doggies app\n\n```shell\n./manage.py startapp doggies\n```\n\nAdd `\"doggies\"` to `settings.INSTALLED_APPS`\n\nCreate `doggies/models.py` with contents:\n\n```python\nfrom django.db import models\nfrom datetime import date\n\n\nclass Dog(models.Model):\n    name = models.CharField(max_length=50)\n    birthday = models.DateField(default=date.today)\n\n    def __str__(self):\n        return self.name.title()\n```\n\nCreate `doggies/serializers.py` with contents:\n\n```python\nfrom rest_framework import serializers\n\nfrom doggies.models import Dog\n\n\nclass DogSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n        )\n```\n\nCreate `doggies/admin.py` with contents:\n\n```python\nfrom django.contrib import admin\nfrom doggies.models import Dog\n\n\n@admin.register(Dog)\nclass DogAdmin(admin.ModelAdmin):\n    pass\n```\n\nCreate `doggies/views.py` with contents:\n\n```python\nfrom rest_framework import viewsets, mixins\n\nfrom doggies.models import Dog\nfrom doggies.serializers import DogSerializer\n\n\nclass DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin):\n    serializer_class = DogSerializer\n    queryset = Dog.objects.all()\n```\n\nCreate `doggies/urls.py` with contents:\n\n```python\nfrom rest_framework.routers import DefaultRouter\nfrom . import views\n\nrouter = DefaultRouter()\n\nrouter.register(\"\", views.DoggieViewSet, basename=\"doggies\")\n\nurlpatterns = router.urls\n```\n\nRegister our doggies app urls in the global project urls `mysite/urls.py`:\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"doggies/\", include(\"doggies.urls\")),\n]\n```\n\nYour project directory should now look like this:\n\n```\n├── db.sqlite3\n├── doggies\n│   ├── admin.py\n│   ├── apps.py\n│   ├── __init__.py\n│   ├── migrations\n│   │   ├── 0001_initial.py\n│   │   └──  __init__.py\n│   ├── models.py\n│   ├── serializers.py\n│   ├── tests.py\n│   ├── urls.py\n│   └── views.py\n├── manage.py\n├── mysite\n│   ├── asgi.py\n│   ├── __init__.py\n│   ├── settings.py\n│   ├── urls.py\n│   └── wsgi.py\n└── requirements.txt\n```\n\nCreate the new Dog table in the database:\n\n```shell\n./manage.py makemigrations\n```\n\n```shell\n./manage.py migrate\n```\n\ncreate superuser\n\n```shell\n./manage.py createsuperuser\n```\n\ncreate some dogs in the admin site\n\nNow if we navigate to `localhost:8000/doggies/` we should see the following output:\n\n### DRF versioning installation\n\nCreate a versioning module. This can be a django app, but it doesn't have to be, since we don't require any models.\n\nIn the project root, do:\n\n```shell\nmkdir versioning\n```\n\nIn `versioning/versions.py`:\n\n```python\nfrom drf_versioning.versions import Version\n\nVERSION_1_0_0 = Version(\n    \"1.0.0\",\n    notes=[\"Initial version :)\"],\n)\n```\n\nin `versioning.version_list.py`:\n\n```python\nfrom . import versions\n\nVERSIONS = [\n    versions.VERSION_1_0_0,\n]\n```\n\nAdd the following line to your `mysite/settings.py`.\n\n```python\n# Here we are telling rest_framework to use drf_versioning's AcceptHeaderVersioning class. It\n# inherits from rest_framework's AcceptHeaderVersioning class, and does almost the same thing,\n# but it adds the ability to choose a default version if the version is not specified in the\n# request.\nREST_FRAMEWORK = {\n    \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\",\n}\n\n# Here we are telling drf_versioning where to find our list of supported versions (\n# `VERSION_LIST`). We also specify a default version that we would like to attach to requests\n# that do not specify a version. We have selected \"latest\" which will use the most recent Version\n# it can find in the supported versions list. Other acceptable values are \"earliest\" or a version\n# string e.g. \"1.0.0\"\nDRF_VERSIONING_SETTINGS = {\n    \"VERSION_LIST\": \"versioning.version_list.VERSIONS\",\n    \"DEFAULT_VERSION\": \"latest\",\n}\n```\n\nIn `mysite/urls.py`, add `drf_versioning`s default urls. Your `urlpatterns` should now look like this:\n\n```python\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"doggies/\", include(\"doggies.urls\")),\n    path(\"version/\", include(\"drf_versioning.urls\")),\n]\n```\n\nIf we navigate to `http://localhost:8000/version/`, we should see a list of available versions, with a description of the changes in each version. The `notes` that we passed to the Version instance are also serialized here.\n\n```json\n[\n  {\n    \"version\": \"1.0.0\",\n    \"notes\": [\n      \"Initial version :)\"\n    ],\n    \"models\": [],\n    \"views\": {\n      \"endpoints_introduced\": [],\n      \"endpoints_removed\": [],\n      \"actions_introduced\": [],\n      \"actions_removed\": []\n    }\n  }\n]\n```\n\nIf we navigate to `http://localhost:8000/version/my_version/`, we should see which version was assigned to our request. Since we did not specify a versoin, we have been assigned the latest version -- 1.0.0 (which is also the only version).\n\n```json\n{\n  \"version\": \"1.0.0\",\n  \"notes\": [\n    \"Initial version :)\"\n  ],\n  \"models\": [],\n  \"views\": {\n    \"endpoints_introduced\": [],\n    \"endpoints_removed\": [],\n    \"actions_introduced\": [],\n    \"actions_removed\": []\n  }\n}\n```\n\n### The tutorial begins in earnest\n\nNow that we have completed the setup, we can start the interesting part -- making changes to our API and supporting multiple versions!\n\n#### Versioning views\n\n##### View actions / methods\n\nLet's say we want to add a new action to the Dogs viewset -- a view for individual dogs. Paste the following code into your `doggies/views.py`:\n\n```python\nfrom drf_versioning.decorators import versioned_view\nfrom rest_framework import viewsets, mixins\n\nfrom doggies.models import Dog\nfrom doggies.serializers import DogSerializer\nfrom versioning import versions\n\n\nclass DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin, mixins.RetrieveModelMixin):\n    serializer_class = DogSerializer\n    queryset = Dog.objects.all()\n\n    @versioned_view(introduced_in=versions.VERSION_2_0_0)\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n```\n\nHere we have\n\n- Added the RetrieveModelMixin to the viewset, which allows us to see the detail view at `/doggies/<dog-id>/`\n- Overridden the `retrieve` method and applied the `versioned_view` decorator, specifying the version from which this view should become available.\n\nVersion 2.0.0 doesn't exist yet, so let's create it. Add this to your `versioning/versions.py`:\n\n```python\nVERSION_2_0_0 = Version(\n    \"2.0.0\",\n    notes=[\"Added doggie detail view\"],\n)\n```\n\nand add it to the list of supported versions in `versioning/version_list.py`:\n\n```python\nVERSIONS = [\n    versions.VERSION_2_0_0,\n    versions.VERSION_1_0_0,\n]\n```\n\nNow if we ping the `/version/` endpoint, we should see the new Version. Note that in addition to the `notes` which we added to the Version instance by hand, the `versioned_view` decorator has also informed the Version instance about the new view, and it is described in the `views.actions_introduced` list.\n\n```json\n[\n  {\n    \"version\": \"2.0.0\",\n    \"notes\": [\n      \"Added doggie detail view\"\n    ],\n    \"models\": [],\n    \"views\": {\n      \"endpoints_introduced\": [],\n      \"endpoints_removed\": [],\n      \"actions_introduced\": [\n        \"DoggieViewSet.retrieve\"\n      ],\n      \"actions_removed\": []\n    }\n  },\n  {\n    \"version\": \"1.0.0\",\n    \"notes\": [\n      \"Initial version :)\"\n    ],\n    \"models\": [],\n    \"views\": {\n      \"endpoints_introduced\": [],\n      \"endpoints_removed\": [],\n      \"actions_introduced\": [],\n      \"actions_removed\": []\n    }\n  }\n]\n```\n\nThe `versioned_view` decorator hides the view for requests with version < 2.0.0. We can demonstrate this by requesting `GET /doggies/1/` with `Accept: application/json; version=1.0.0` in Postman. We get a 404 response with the following body:\n\n```json\n{\n  \"detail\": \"Not found.\"\n}\n```\n\nIf we repeat the same request with `Accept: application/json; version=2.0.0`, we are given access to the view:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2023-01-30\"\n}\n```\n\nThe `versioned_view` decorator also accepts a `removed_in` argument. If this is present, the view will be hidden for all requests whose version is greater.\n\n##### ViewSets\n\nIf we want to introduce / remove a whole endpoint, we can achieve this by inheriting from the `VersionedViewSet` class. In this case the `introduced_in` and `removed_in` versions are set as class attributes, which also apply to any of the ViewSet's methods:\n\n```python\nclass CatViewSet(VersionedViewSet, viewsets.ReadOnlyModelViewSet):\n    serializer_class = CatSerializer\n    queryset = Cat.objects.all()\n    introduced_in = versions.VERSION_1_0_0\n    removed_in = versions.VERSION_5_0_0\n\n    @versioned_view(introduced_in=versions.VERSION_3_0_0)\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n\n    @versioned_view(removed_in=versions.VERSION_4_0_0)\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n```\n\nHowever, individual methods can be further limited by using the `versioned_view` decorator. The most restrictive combination of viewset / method versions will be chosen. In this example this results in:\n\n- `CatViewSet` is available from 1.0.0 to 5.0.0\n- `retrieve` is available from 3.0.0 to 5.0.0\n- `list` is available from 1.0.0 to 4.0.0\n\nThe `VersionedViewSet` class also informs the relevant Version instances about its introduction and removal. It appears under `views.endpoints_introduced` / `views.endpoints_removed` in a serialized Version:\n\n```json\n{\n  \"version\": \"1.0.0\",\n  \"notes\": [\n    \"Initial version :)\"\n  ],\n  \"models\": [],\n  \"views\": {\n    \"endpoints_introduced\": [\n      \"CatViewSet\"\n    ],\n    \"endpoints_removed\": [],\n    \"actions_introduced\": [],\n    \"actions_removed\": []\n  }\n}\n```\n\n#### Versioning models / serializers\n\nAt some point we will need to make changes to our models in order to add new features. But we also want to keep supporting older API versions.\n\ndrf_versioning acts as a \"versioning layer\" in this regard (TODO: link Stripe article).\n\n##### Adding a new field\n\nLet's add a new `age` property to the Dog model.\n\n```python\nfrom django.db import models\nfrom datetime import date\n\nfrom django.utils import timezone\n\n\nclass Dog(models.Model):\n    name = models.CharField(max_length=50)\n    birthday = models.DateField(default=date.today)\n\n    def __str__(self):\n        return self.name.title()\n\n    @property\n    def age(self):\n        return (timezone.now().date() - self.birthday).days // 365\n```\n\nAnd add the `age` field to the `DogSerializer` in `doggies/serializers.py`:\n\n```python\nclass DogSerializer(serializers.ModelSerializer):\n    age = serializers.IntegerField()\n\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n            \"age\",\n        )\n```\n\nBut we don't want to break old API versions with this unexpected new field. So we create a new Version and only serialize this field if the request.version is greater.\n\nin `versions.py`:\n\n```python\nVERSION_2_1_0 = Version(\n    \"2.1.0\",\n    notes=[\"Added Dog.age property\"],\n)\n```\n\nNow create a new file `doggies/transforms.py`, with the following content:\n\n```python\nfrom drf_versioning.transforms import Transform\n\nfrom versioning import versions\n\n\nclass AddAge(Transform):\n    version = versions.VERSION_2_1_0\n    description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\"\n\n    def to_representation(self, data: dict, request, instance):\n        \"\"\"\n        Here we downgrade the serializer's output data to make it match older API versions.\n        In this case that means removing the new 'age' field.\n        \"\"\"\n        data.pop(\"age\", None)\n        return data\n\n    def to_internal_value(self, data: dict, request):\n        \"\"\"\n        Here we upgrade the request.data to make it match the latest API version.\n        In this case the 'age' field is read-only, so no action is required.\n        \"\"\"\n        pass\n```\n\nAnd update the `DogSerializer` in `doggies/serializers.py`:\n\n```python\nfrom drf_versioning.serializers import VersionedSerializer\nfrom rest_framework import serializers\n\nfrom doggies.models import Dog\nfrom . import transforms\n\n\nclass DogSerializer(VersionedSerializer, serializers.ModelSerializer):\n    age = serializers.IntegerField()\n\n    transforms = (\n        transforms.AddAge,\n    )\n\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n            \"age\",\n        )\n```\n\nHere we have done:\n\n- DogSerializer now inherits from VersionedSerializer\n- We have declared a tuple of Transform objects that apply to this serializer\n- The serializer code reflects the latest behaviour\n- The Transforms downgrade the output for older request versions\n\nIn Postman: `GET /doggies/1/` with version = 2.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\"\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 2.1.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": 8\n}\n```\n\nBecause adding a new field is bound to a relatively common operation, DRF Versioning provides a special AddField class. Instead of our Transform subclass above, we could also have done this:\n\n```python\nfrom drf_versioning.transforms import AddField\n\nfrom versioning import versions\n\n\nclass AddAge(AddField):\n    version = versions.VERSION_2_1_0\n    field_name = \"age\"\n    description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\"\n```\n\nand it would have had the same effect.\n\nThe Transform object adds its `description` field to the Version instance's `models` changelog:\n\n```json\n    {\n  \"version\": \"2.1.0\",\n  \"notes\": [],\n  \"models\": [\n    \"Added Dog.age which is auto-calculated based on the Dog's birthday.\"\n  ],\n  \"views\": {\n    \"endpoints_introduced\": [],\n    \"endpoints_removed\": [],\n    \"actions_introduced\": [],\n    \"actions_removed\": []\n  }\n},\n```\n\n##### Mutating fields\n\nLet's say we want to update the Dog model to provide a `dog_years` property:\n\n```python\nclass Dog(models.Model):\n    ...\n\n    @property\n    def dog_years(self):\n        return self.age * 7\n```\n\nand we want to group this together with the `age` property like this:\n\n```json\n{\n  \"age\": {\n    \"human_years\": 8,\n    \"dog_years\": 56\n  }\n}\n```\n\nFirst let's update the serializers in `doggies/serializers.py`:\n\n```python\nfrom drf_versioning.serializers import VersionedSerializer\nfrom rest_framework import serializers\n\nfrom doggies.models import Dog\nfrom . import transforms\n\n\nclass DogAgeSerializer(serializers.Serializer):\n    def to_representation(self, instance):\n        return {\"human_years\": instance.age, \"dog_years\": instance.dog_years}\n\n\nclass DogSerializer(VersionedSerializer, serializers.ModelSerializer):\n    age = DogAgeSerializer(source=\"*\")\n\n    transforms = (\n        transforms.AddAge,\n    )\n\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n            \"age\",\n        )\n```\n\nOur serializer now produces the desired output:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": {\n    \"human_years\": 8,\n    \"dog_years\": 56\n  }\n}\n```\n\nBut we need a transform to downgrade this data for older API versions. In `doggies/transforms.py`, we add:\n\n```python\nclass GroupAgeAndDogYears(Transform):\n    version = versions.VERSION_3_0_0\n    description = (\n        \"Added Dog.dog_years and grouped Dog.age and Dog.dog_years into one 'age' property\"\n    )\n\n    def to_representation(self, data: dict, request, instance):\n        \"\"\"\n        Here we downgrade the serializer's output data to make it match older API versions.\n        In this case that means returning the Dog.age value instead of the whole\n        {\"human_years\": 1, \"dog_years\": 7} dict.\n        \"\"\"\n        data[\"age\"] = data[\"age\"][\"human_years\"]\n        return data\n\n    def to_internal_value(self, data: dict, request):\n        \"\"\"\n        Here we upgrade the request.data to make it match the latest API version.\n        In this case the 'age' field is read-only, so no action is required.\n        \"\"\"\n        pass\n```\n\nWe add this transform to the DogSerializer:\n\n```python\nclass DogSerializer(VersionedSerializer, serializers.ModelSerializer):\n    age = DogAgeSerializer(source=\"*\")\n\n    transforms = (\n        transforms.AddAge,\n        transforms.GroupAgeAndDogYears,\n    )\n\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n            \"age\",\n        )\n```\n\nLet's test the endpoint's behaviour.\n\nIn Postman: `GET /doggies/1/` with version = 2.1.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": 8\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 3.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": {\n    \"human_years\": 8,\n    \"dog_years\": 56\n  }\n}\n```\n\n##### Removing a field\n\nLet's say we've decided to remove the age field altogether, and let the API consumer work it out for themselves based on the birthday field.\n\nIn `doggies/transforms.py`:\n\n```python\nclass RemoveAge(Transform):\n    version = versions.VERSION_4_0_0\n    description = \"Removed Dog.age field\"\n\n    def to_representation(self, data: dict, request, instance):\n        \"\"\"\n        Here we downgrade the serializer's output data to make it match older API versions.\n        We have removed the field, but older versions are still expecting it. So we add it to the\n        serializer output for older versions here.\n        \"\"\"\n        data[\"age\"] = {\n            \"human_years\": instance.age,\n            \"dog_years\": instance.dog_years,\n        }\n        return data\n```\n\nIn `doggies/serializers.py`:\n\n```python\nfrom drf_versioning.serializers import VersionedSerializer\nfrom rest_framework import serializers\n\nfrom doggies.models import Dog\nfrom . import transforms\n\n\nclass DogSerializer(VersionedSerializer, serializers.ModelSerializer):\n    transforms = (\n        transforms.AddAge,\n        transforms.GroupAgeAndDogYears,\n        transforms.RemoveAge,\n    )\n\n    class Meta:\n        model = Dog\n        fields = (\n            \"id\",\n            \"name\",\n            \"birthday\",\n            # \"age\",  # <---- remove this field \n        )\n```\n\nThe resulting behaviour of the API is:\n\nIn Postman: `GET /doggies/1/` with version = 3.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": {\n    \"human_years\": 8,\n    \"dog_years\": 56\n  }\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 4.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\"\n}\n```\n\nIn this example, we still have access to the `Dog.age` and `Dog.dog_years` properties, so we can continue serializing real values for older request versions.\n\nBut let's say the property has been removed, and we completely lose access to the source data. We can no longer serialize the dog's age for older versions. In this case we can instead serialize a \"null value\" that satisfies the type and structure that the older version is expecting. For Dog.age, we could use `-1`, for example.\n\nDRF Versioning provides another built in Transform subclass for this case: `RemoveField`. We can recreate the behaviour of our `RemoveAge` transform like this:\n\n```python\nclass RemoveAge(RemoveField):\n    version = versions.VERSION_4_0_0\n    field_name = \"age\"\n    description = \"Removed Dog.age field\"\n    null_value = {\"human_years\": -1, \"dog_years\": -1}\n```\n\nNow is a good time to check that our Transforms correctly cascade their changes through all API versions.\n\nIn Postman: `GET /doggies/1/` with version = 1.0.0:\n\n```json\n{\n  \"detail\": \"Not found.\"\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 2.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\"\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 2.1.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": -1\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 3.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\",\n  \"age\": {\n    \"human_years\": -1,\n    \"dog_years\": -1\n  }\n}\n```\n\nIn Postman: `GET /doggies/1/` with version = 4.0.0:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Biko\",\n  \"birthday\": \"2014-05-06\"\n}\n```\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/binnev/djangorestframework_versioning",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "djangorestframework-versioning",
    "package_url": "https://pypi.org/project/djangorestframework-versioning/",
    "platform": null,
    "project_url": "https://pypi.org/project/djangorestframework-versioning/",
    "project_urls": {
      "Bug Tracker": "https://github.com/binnev/djangorestframework_versioning/issues",
      "Homepage": "https://github.com/binnev/djangorestframework_versioning"
    },
    "release_url": "https://pypi.org/project/djangorestframework-versioning/2.0.5/",
    "requires_dist": [
      "django (>=3.2)",
      "djangorestframework (>=3.13.1)",
      "typing (>=3.7.4.3)",
      "packaging (>=3.0.9)"
    ],
    "requires_python": ">=3.9",
    "summary": "Versioning tools for use with Django Rest Framework",
    "version": "2.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16667959,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "cfef97e6c43d43d5a2432e41a8e0f2755f4075b6036b78e077bcce71cebc76a2",
        "md5": "e0b6d856f5cebccb91ed5fde9c38b1ca",
        "sha256": "17d32ecb2ac348c721df61ebc9158bed835d69f18bf61be631194b18a2870c0f"
      },
      "downloads": -1,
      "filename": "djangorestframework_versioning-2.0.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "e0b6d856f5cebccb91ed5fde9c38b1ca",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.9",
      "size": 19183,
      "upload_time": "2023-01-30T20:30:47",
      "upload_time_iso_8601": "2023-01-30T20:30:47.858118Z",
      "url": "https://files.pythonhosted.org/packages/cf/ef/97e6c43d43d5a2432e41a8e0f2755f4075b6036b78e077bcce71cebc76a2/djangorestframework_versioning-2.0.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "80523ee8d5399af977b3d5b33e2450f2027fe4afeb2c951ce10a115c88073b57",
        "md5": "3e86c913719e9d1e907c13954345b8a0",
        "sha256": "0e535353a3e4f1467b5d3a197f1643aaec9df1266da4d5ad6eacfddaa9771751"
      },
      "downloads": -1,
      "filename": "djangorestframework_versioning-2.0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "3e86c913719e9d1e907c13954345b8a0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.9",
      "size": 15134,
      "upload_time": "2023-01-30T20:30:50",
      "upload_time_iso_8601": "2023-01-30T20:30:50.042585Z",
      "url": "https://files.pythonhosted.org/packages/80/52/3ee8d5399af977b3d5b33e2450f2027fe4afeb2c951ce10a115c88073b57/djangorestframework_versioning-2.0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}