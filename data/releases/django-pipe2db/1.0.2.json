{
  "info": {
    "author": "HS Moon",
    "author_email": "pbr112@naver.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Communications :: Email"
    ],
    "description": "# django-pipe2db\r\n\r\n\r\n## Contents\r\n- [django-pipe2db](#django-pipe2db)\r\n  - [Contents](#contents)\r\n  - [Concepts](#concepts)\r\n  - [Features](#features)\r\n  - [Install and Import](#install-and-import)\r\n  - [Quick Start](#quick-start)\r\n    - [1. Using django orm as standalone](#1-using-django-orm-as-standalone)\r\n    - [2. Using with django project](#2-using-with-django-project)\r\n  - [Useage](#useage)\r\n    - [Argument of pipe decorator as context](#argument-of-pipe-decorator-as-context)\r\n      - [model](#model)\r\n      - [unique_key](#unique_key)\r\n      - [method](#method)\r\n      - [rename_fields](#rename_fields)\r\n      - [exclude_fields](#exclude_fields)\r\n      - [foreignkey_fields](#foreignkey_fields)\r\n      - [manytomany_fields](#manytomany_fields)\r\n  - [- See complicate context and data nested level example](#--see-complicate-context-and-data-nested-level-example)\r\n      - [contentfile_fields](#contentfile_fields)\r\n\r\n\r\n\r\n## Concepts\r\n- A decorator that written by wrapping orm method of django models\r\n- It maps the relationship between the models and data via nested dictionary\r\n\r\n---\r\n## Features\r\n- It bridges Python functions and django models\r\n- Create and update data to database via models\r\n- Automatically create and modify tables by wrapping manage.py commands from django as makemigrations and migrate\r\n- Load minimum django settings for can use django orm as standalone that without using the django project\r\n- Insertion of data with the same relationship as foreignkey and manytomany fields\r\n- Inserting a content file object as an image field\r\n\r\n---\r\n## Install and Import\r\n\r\n```bash\r\npip install django-pipe2db\r\n```\r\n```python\r\n# crawler.py\r\nfrom pipe2db import pipe\r\nfrom pipe2db import setupdb\r\n```\r\n---\r\n## Quick Start\r\n\r\n\r\n### 1. Using django orm as standalone\r\n- Create models.py in the directory that will be used as the Django app\r\n- example for minimum project directory structure. [see](https://github.com/zwolf21/django-pipe2db/tree/master/test)\r\n```bash\r\nProject\r\n│  __main__.py\r\n│\r\n└─bookstore\r\n    │  insert.py\r\n    │  \r\n    └─db\r\n          models.py\r\n```\r\n\r\n```python\r\n# models.py\r\nfrom django.db import models\r\n\r\n\r\nclass Author(models.Model):\r\n    email = models.EmailField('Email', unique=True)\r\n    first_name = models.CharField(max_length=100)\r\n    last_name = models.CharField(max_length=100)\r\n    date_of_birth = models.DateField(null=True, blank=True)\r\n    date_of_death = models.DateField('Died', null=True, blank=True)\r\n\r\n    class Meta:\r\n        db_table = 'author'\r\n```\r\n```python\r\n# insert.py\r\nfrom pipe2db import pipe, setupdb\r\n\r\n\r\nsetupdb() # find models automatically\r\n# setupdb('bookstore.db') # or more explicitly \r\n\r\n# The key of the data and the field names of the model are matched\r\nauthor1 = {\r\n    'email': 'xman1@google.com',\r\n    'first_name': 'charse',\r\n    'last_name': 'javie',\r\n    'date_of_birth': '1975-07-25',\r\n    'date_of_death': '1995-07-11'\r\n}\r\nauthor2 = {\r\n    'email': 'yman1@google.com',\r\n    'first_name': 'jin',\r\n    'last_name': 'gray',\r\n    'date_of_birth': '1925-07-25',\r\n    'date_of_death': '1999-01-21'\r\n}\r\n\r\n\r\n@pipe({\r\n    'model': 'db.Author', \r\n    'unique_key': 'email', # unique values of table as pk\r\n    # 'method': 'update' # If uncomment, works in update mode\r\n})\r\ndef insert(*args, Author, **kwargs):\r\n    # You Can get model class via argumenting at generator function\r\n\r\n    # from django.apps import apps # or via get_model method of django\r\n    # Author = apps.get_model('db.Author') \r\n\r\n    queryset = Author.objects.all()\r\n\r\n    yield from [author1, author2, author3]\r\n\r\n```\r\n\r\n- run examples\r\n```bash\r\npython bookstore/insert.py\r\n```\r\n\r\n\r\n### 2. Using with django project\r\n- Since DJANGO_SETTINGS_MODULE is already setted, it's not need to call setupdb\r\n- [django site example](https://github.com/zwolf21/django-pipe2db/tree/master/testsite/bookstore)\r\n\r\n> run via shell which excuted by 'python manage.py shell' command of django manage\r\n> ```bash\r\n> python manage.py shell\r\n> ```\r\n>```python\r\n>In [1]: from yourpackage.insert import insert\r\n>In [2]: insert()\r\n>```\r\n\r\n\r\n|id|email|first_name|last_name|date_of_birth|date_of_death|\r\n|--|--|--|--|--|--|\r\n|1|xman1@google.com\t|charse|javie|1975-07-25|1995-07-11|\r\n|2|yman1@google.com\t|jin|gray|1925-07-25|1999-01-21|\r\n|3|batman1@google.com|wolverin|jack|1988-07-25|NULL|\r\n\r\n\r\n\r\n--- \r\n## Useage\r\n\r\n### Argument of pipe decorator as context\r\n- A context is a dictionary that describes the relationship between the model and the data\r\n- In the following examples, the elements that make up the context are explained step by step\r\n\r\n#### model\r\n- django model to pipe data written as string literals\r\n```python\r\n# some_crawler.py\r\nfrom pip2db import pipe\r\n\r\n@pipe({\r\n    'model': 'db.Author'\r\n    # 'model': 'yourapp.YourModel' on django project\r\n})\r\ndef abc_crawler():\r\n    ...\r\n    yield row\r\n```\r\n> It is also a good way to assign and use a variable to increase reusability\r\n> When expressing nested relationships in relational data, not assigning them as variables can result in repeatedly creating the same context.\r\n```python\r\n# assign to variable crawler.py\r\n\r\n# It seems to better way\r\ncontext_author = {\r\n    'model': 'db.Author'\r\n}\r\n\r\n@pipe(context_author)\r\ndef abcd_crawler(*args, **kwargs):\r\n    yield ..\r\n```\r\n\r\n- It is also possible to specify the model by directly importing it, but in the case of standalone, you must declare setupdb before importing the model\r\n  \r\n```python\r\n# dose not look good.py\r\n\r\nfrom pipe2db import setupdb, pipe\r\n\r\nsetupdb()\r\nfrom .db.models import Author\r\n\r\ncontext_author = {'model': Author}\r\n\r\n@pipe(context_author)\r\ndef abc():\r\n    yield ..\r\n```\r\n\r\n> Another way to refer to the model class\r\n> 1. Using Django's apps module\r\n>   ```python\r\n>   from django.apps import apps\r\n>\r\n>   Author = apps.get_model('db.Author')\r\n>   ```\r\n> 2. Specify the model name as an argument to the generator function\r\n>   ```python   \r\n>   # An example of controlling a generator based on data in a database\r\n>   @pipe(context_author)\r\n>   def abc_crawler(rows, response, Author):\r\n>       visited = Author.objects.values_list('review_id', flat=True)\r\n>       for row in rows:\r\n>           if row['id'] in visited:\r\n>               break\r\n>           yield row\r\n>   ```\r\n\r\n#### unique_key\r\n- key to identify data like as primary key\r\n- If you don't specify it, creating data will be duplicated\r\n- To identify data with one or several keys as unique_together\r\n\r\n```python\r\n# models.py\r\n\r\n# unique key model\r\nclass Author(models.Model):\r\n    ...\r\n    first_name = models.CharField(max_length=100, unique=True)\r\n    ...\r\n```\r\n\r\n```python\r\n# uniqufy_by_one.py\r\n\r\ncontext_author = {\r\n    'model': 'db.Author',\r\n    'unique_key': 'first_name'\r\n}\r\n```\r\n\r\n> If uniqueness is not guaranteed with one key, add another\r\n>```python\r\n># models.py\r\n>\r\n># unique together model\r\n>class Author(models.Model):\r\n>    ...\r\n>    first_name = models.CharField(max_length=100)\r\n>    last_name = models.CharField(max_length=100)\r\n>\r\n>    class Meta:\r\n>        unique_together = ['first_name', 'last_name']\r\n>    ...\r\n>```\r\n>```python\r\n>#unique_together.py\r\n>\r\n>context_author = {\r\n>    'model': 'db.Author',\r\n>    'unique_key': ['first_name', 'last_name']\r\n>}\r\n>```\r\n\r\n\r\n#### method\r\n- Creates or updates data with a unique key specified\r\n- Defaults is create\r\n- In create mode, data is inserted based on unique.\r\n- In update mode as wrapper update_or_create of django method, creates records if they don't exist, otherwise modifies existing records\r\n\r\n\r\n```python\r\n# incorrect create.py\r\nfrom pipe2db import pipe\r\n\r\nauthor_incorrect = {\r\n    'email': 'batman1@google.com',\r\n    'first_name': 'who', # incorrect\r\n    'last_name': 'jackman',\r\n    'date_of_birth': '1988-07-25', # incorrect\r\n    'date_of_death': None\r\n}\r\n\r\ncontext = {\r\n    'model': 'db.Author',\r\n    'unique_key': 'email',\r\n    # 'method': 'create' no need to specify if create\r\n}\r\n\r\n@pipe(context)\r\ndef gen_author(...):\r\n    yield author_incorrect\r\n```\r\n> result table\r\n>\r\n>|id|email|first_name|last_name|date_of_birth|date_of_death|\r\n>|--|--|--|--|--|--|\r\n>|3|batman1@google.com|who|jackman|1988-07-25|NULL|\r\n\r\n\r\n```python\r\n# correct as update.py\r\nfrom pipe2db import pipe\r\n\r\nauthor_corrected = {\r\n    'email': 'batman1@google.com',\r\n    'first_name': 'Hugh', # correct\r\n    'last_name': 'jackman',\r\n    'date_of_birth': '1968-10-12', # correct\r\n    'date_of_death': None\r\n}\r\n\r\ncontext = {\r\n    'model': 'db.Author',\r\n    'unique_key': 'email',\r\n    'method': 'update', # for update record by corrected data\r\n}\r\n\r\n@pipe(context)\r\ndef gen_author(...):\r\n    yield author_corrected\r\n```\r\n> result table\r\n>\r\n>|id|email|first_name|last_name|date_of_birth|date_of_death|\r\n>|--|--|--|--|--|--|\r\n>|3|batman1@google.com|Hugh|jackman|1968-10-12|NULL|\r\n\r\n\r\n#### rename_fields\r\n- Dictionary of between data and model as key:field mapping\r\n- Used when the data key and the model field name are different\r\n\r\n```python\r\n# models.py\r\nfrom django.db import models\r\n\r\n\r\nclass Author(models.Models):\r\n    ...\r\n    ...\r\n\r\nclass Book(models.Model):\r\n    title = models.CharField(max_length=200) \r\n    isbn = models.CharField('ISBN', max_length=13, unique=True)\r\n\r\n    class Meta:\r\n        db_table = 'book'\r\n```\r\n\r\n```python\r\n# book_crawler.py\r\n\r\ncontext = {\r\n    'model': 'db.Book',\r\n    'unique_key': 'isbn',\r\n    'rename_fields': {\r\n        'header' : 'title', \r\n        'book_id': 'isbn',\r\n    }\r\n}\r\n# map header -> title, book_id -> isbn\r\n\r\n@pipe(context)\r\ndef book_crawler(abc, defg, jkl=None):\r\n    book_list = [\r\n        {\r\n            'header': 'oh happy day', # header to title\r\n            'book_id': '1234640841',\r\n        },\r\n        {\r\n            'header': 'oh happy day',\r\n            'book_id': '9214644250',\r\n        },\r\n    ]\r\n    yield from book_list\r\n```\r\n\r\n#### exclude_fields\r\n- List of keys to excluds\r\n- Used when the data has a key that is not in the field names in the model\r\n- Filter too much information from data that model cannot consume\r\n  \r\n```python\r\n# bookcrawler.py\r\nfrom pipe2db import pipe\r\n...\r\n...\r\n\r\ncontext = {\r\n    'model': 'db.Book',\r\n    'unique_key': 'isbn',\r\n    'rename_fields': {\r\n        'header' : 'title', \r\n        'book_id': 'isbn',\r\n    },\r\n    'exclude_fields': ['status'] # exclude\r\n}\r\n\r\n@pipe(context)\r\ndef book_crawler(abc, defg, jkl=None):\r\n    book_list = [\r\n        {\r\n            'header': 'oh happy day', # header to title\r\n            'book_id': '1234640841',\r\n            'status': 'on sales', # status is not needed in Book model\r\n        },\r\n        {\r\n            'header': 'oh happy day',\r\n            'book_id': '9214644250',\r\n            'sstatus': 'no stock',\r\n        },\r\n    ]\r\n    yield from book_list\r\n\r\n```\r\n\r\n--- \r\nMapping of Relative Data\r\n\r\n#### foreignkey_fields\r\n- Creat records by generation according to the foreign key relationship between tables\r\n- Recursively nest parent dict to children dict\r\n- There are two way of create relationship data\r\n\r\n```python\r\n# models.py\r\n# two models of related with foreign key\r\nfrom django.db import models\r\n\r\n\r\nclass Author(models.Model):\r\n    email = models.EmailField('Email', unique=True)\r\n    name = models.CharField(max_length=100)\r\n\r\n    class Meta:\r\n        db_table = 'author'\r\n\r\n\r\nclass Book(models.Model):\r\n    author = models.ForeignKey('Author', on_delete=models.CASCADE, null=True) # fk\r\n    isbn = models.CharField('ISBN', max_length=13, unique=True)\r\n    title = models.CharField(max_length=200)\r\n\r\n    class Meta:\r\n        db_table = 'book'\r\n```\r\n\r\n```python\r\n# some crawler.py\r\nfrom pipe2db import pipe\r\n\r\n# 1. Generate data of book author nested\r\n\r\ncontext_author = {\r\n    'model': 'db.Author',\r\n    'unique_key': 'email',\r\n    'method': 'update'\r\n}\r\n\r\ncontext_book = {\r\n    'model': 'db.Book',\r\n    'unique_key': 'isbn',\r\n    'foreignkey_fields': {\r\n        'book': context_author\r\n    }\r\n}\r\n\r\n# author data is nested in book data\r\n@pipe(context_book)\r\ndef parse_book():\r\n    author1 = {\r\n        'email': 'pbr112@naver.com',\r\n        'name': 'hs moon',\r\n    }\r\n    book = {\r\n        'author': author1,\r\n        'title': 'django-pipe2db',\r\n        'isbn': '291803928123'\r\n    }\r\n    yield book\r\n\r\n```\r\n\r\n```python\r\n# some crawler.py \r\nfrom pipe2db import pipe\r\n\r\n# 2. Generate data of author and book sequentially\r\n\r\n@pipe(context_author)\r\ndef parse_author():\r\n    author1 = {\r\n        'email': 'pbr112@naver.com',\r\n        'name': 'hs moon',\r\n    }\r\n    yield author1\r\n\r\n# create author first\r\nauthor1 = parse_author()\r\n\r\n# create book after and connect fk relation to author\r\n@pipe(context_book)\r\ndef parse_book():\r\n    book = {\r\n        'author': author1['email'], # Since the author has already been created, it possible to pass email as pk of author only\r\n        # 'author': author1, # or same as above\r\n        'title': 'django-pipe2db',\r\n        'isbn': '291803928123'\r\n    }\r\n    yield book\r\n```\r\n\r\n#### manytomany_fields\r\n- Create data for manytomany relationships\r\n- Generate data with nesting the children m2m data in the parent data key in the form of a list\r\n\r\n```python\r\n# models.py \r\nfrom django.db import models\r\n\r\n\r\nclass Book(models.Model):\r\n    title = models.CharField(max_length=200)\r\n    isbn = models.CharField('ISBN', max_length=13, unique=True)\r\n\r\n    genre = models.ManyToManyField('db.Genre')\r\n\r\n    class Meta:\r\n        db_table = 'book'\r\n\r\n\r\nclass Genre(models.Model):\r\n    name = models.CharField(max_length=200, unique=True)\r\n\r\n    class Meta:\r\n        db_table = 'genre'\r\n\r\n```\r\n\r\n```python\r\n# m2m_generator.py\r\nfrom pipe2db import pipe\r\n\r\ncontext_genre = {\r\n    'model': 'db.Genre',\r\n    'unique_key': 'name'\r\n}\r\n\r\ncontext_book = {\r\n    'model': 'db.Book',\r\n    'unique_key': 'isbn',\r\n    'manytomany_fields': {\r\n        'genre': context_genre\r\n    }\r\n}\r\n\r\n@pipe(context_book)\r\ndef gen_book_with_genre():\r\n    genre1 = {'name': 'action'}\r\n    genre2 = {'name': 'fantasy'}\r\n\r\n    book1 = {\r\n        'title': 'oh happy day', 'isbn': '2828233644', 'genre': [genre2], # nest genres to list\r\n    }\r\n    book2 = {\r\n        'title': 'python', 'isbn': '9875230846', 'genre': [genre1, genre2],\r\n    }\r\n    book3 = {\r\n        'title': 'java', 'isbn': '1234640841', # has no genre\r\n    }\r\n    yield from [book1, book2, book3]\r\n```\r\n\r\n- [See complicate context and data nested level example](https://github.com/zwolf21/django-pipe2db/blob/master/testsite/bookstore/scraper.py)\r\n---\r\n\r\nCreate record with contentfiles\r\n\r\n#### contentfile_fields\r\n- Saving file via ContentFile class from django.core.files module\r\n- source_url_field is specified as meta data for determinding file name\r\n\r\n```python\r\n# models.py\r\nfrom django.db import models\r\n\r\nclass BookImage(models.Model):\r\n    img = models.ImageField()\r\n\r\n    class Meta:\r\n        db_table = 'bookimage'\r\n\r\n```\r\n\r\n```python\r\nfrom pipe2db import pipe\r\n\r\n@pipe({\r\n    'model': 'db.BookImage',\r\n    'contentfile_fields': {\r\n        'img': {\r\n            'source_url_field': 'src',\r\n        }\r\n    },\r\n    'exclude_fields': ['src'] # when model dose not need src data\r\n})\r\ndef image_crawler(response):\r\n    image_data = {\r\n        'img': 'response_content',\r\n        'src': response.url #  needed for extracting filename as source_url_field\r\n    }\r\n    yield image_data\r\n```\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/zwolf21/django-pipe2db",
    "keywords": "pipe2db,django-pipe2db,django orm,standalone django,standalone django orm",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-pipe2db",
    "package_url": "https://pypi.org/project/django-pipe2db/",
    "platform": null,
    "project_url": "https://pypi.org/project/django-pipe2db/",
    "project_urls": {
      "Homepage": "https://github.com/zwolf21/django-pipe2db"
    },
    "release_url": "https://pypi.org/project/django-pipe2db/1.0.2/",
    "requires_dist": null,
    "requires_python": ">=3.8",
    "summary": "A decorator that connects django model and data generator function",
    "version": "1.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14629133,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "eca81baf72bdbaa4db911e8542bf928641ffdcfc5a9327cc0f41574935852d0b",
        "md5": "f53500045e24494070542d656e68a7f4",
        "sha256": "74c61d87cf3a176f089e7ea011cd9632cb65938752b72680e654d5688f50b0e9"
      },
      "downloads": -1,
      "filename": "django-pipe2db-1.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "f53500045e24494070542d656e68a7f4",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 12780,
      "upload_time": "2022-07-26T19:43:11",
      "upload_time_iso_8601": "2022-07-26T19:43:11.263275Z",
      "url": "https://files.pythonhosted.org/packages/ec/a8/1baf72bdbaa4db911e8542bf928641ffdcfc5a9327cc0f41574935852d0b/django-pipe2db-1.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}