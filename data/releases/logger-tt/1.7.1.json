{
  "info": {
    "author": "Nguyen Ba Duc Tin",
    "author_email": "nguyenbaduc.tin@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Software Development :: Debuggers",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: System :: Hardware :: Symmetric Multi-processing",
      "Topic :: System :: Logging"
    ],
    "description": "# Logger_tt\r\nMake configuring logging simpler and log even exceptions that you forgot to catch. <br>\r\nEven multiprocessing logging becomes a breeze.\r\n\r\n[![Downloads](https://pepy.tech/badge/logger-tt)](https://pepy.tech/project/logger-tt)\r\n[![PyPI version](https://badge.fury.io/py/logger-tt.svg)](https://pypi.org/project/logger-tt/)\r\n[![GitHub license](https://img.shields.io/github/license/Dragon2fly/logger_tt)](https://github.com/Dragon2fly/logger_tt/blob/master/LICENSE)\r\n\r\n## Table of contents\r\n\r\n* [Install](#install)\r\n* [Overview](#overview)\r\n* [Usage](#usage)\r\n  * [Overwrite the default log path](#1-overwrite-the-default-log-path)\r\n  * [Provide your config file](#2-provide-your-config-file)\r\n  * [Capture stdout](#3-capture-stdout)\r\n  * [Exception logging](#4-exception-logging)\r\n  * [try-except exception logging](#5-try-except-exception-logging)\r\n  * [Silent unwanted loggers](#6-silent-unwanted-loggers)\r\n  * [Logging in multiprocessing](#7-logging-in-multiprocessing)\r\n  * [Temporary disable logging](#8-temporary-disable-logging)\r\n  * [Limit traceback line length](#9-limit-traceback-lines-length)\r\n  * [Analyze `raise` exception line](#10-analyze-raise-exception-line)\r\n  * [StreamHandler with buffer](#11-streamhandler-with-buffer)\r\n  * [TelegramHandler](#12-telegram-handler)\r\n    \r\n* [Sample config](#sample-config)\r\n  * [YAML format](#1-yaml-format)\r\n  * [JSON format](#2-json-format)\r\n* [Changelog](#changelog)\r\n\r\n## Install\r\n* From PYPI: `pip install logger_tt`\r\n* From Github: clone or download this repo then `python setup.py install` \r\n    \r\n## Overview:\r\n\r\nIn the most simple case, add the following code into your main python script of your project:\r\n\r\n```python\r\nfrom logger_tt import setup_logging    \r\n\r\nsetup_logging(full_context=1)\r\n```\r\n\r\nThen from any of your modules, you just need to get a `logger` and start logging.\r\nThere are two ways that you could obtain a logger.\r\n\r\n* **Conventional way**: as you have always done it that way\r\n\r\n  ```python\r\n  from logging import getLogger\r\n  \r\n  logger = getLogger(__name__)\r\n  ```\r\n\r\n* **Convenient way**: use a pre-made logger named `logger_tt` from this package.\r\n\r\n  ```python\r\n  from logger_tt import logger\r\n  ```\r\n\r\nAfter that, you start logging as usual:\r\n\r\n```python\r\nlogger.debug('Module is initialized')\r\nlogger.info('Making connection ...')\r\n\r\n# output\r\n[2020-07-21 11:24:19] [__main__:5 DEBUG] Module is initialized\r\n[2020-07-21 11:24:19] [__main__:6 INFO] Making connection ...\r\n```\r\n  \r\nBoth ways give you the same output except the line number, obviously.<br>\r\nThe pre-made logger also has an advantage that it will automatically inject \r\n`threadName` and `processName` to the output in case of multithreading or multiprocessing. \r\n\r\nBoth ways will provide your project with the following **default** log behaviors:\r\n\r\n* **log file**: Assume that your `working directory` is `project_root`,\r\n log.txt is stored at your `project_root/logs/` folder. <br>\r\nIf the log path doesn't exist, it will be created. <br>\r\nThe log file is time rotated at midnight. A maximum of 15 dates of logs will be kept.\r\nThis log file's `level` is `DEBUG`.<br>\r\nThe log format is `[%(asctime)s] [%(name)s:%(lineno)d %(levelname)s] %(message)s`, <br> \r\nwhere the time format is `%Y-%m-%d %H:%M:%S`.<br>\r\n*Example*: `[2020-05-09 00:31:33] [myproject.mymodule:26 DEBUG] Module is initialized`\r\n\r\n* **console**: log records with level `INFO` and above will be printed to `stdout` of the console. <br>\r\nThe format for console log is simpler: `[%(asctime)s] %(levelname)s: %(message)s`. <br>\r\n*Example*: `[2020-05-09 00:31:34] INFO: Making connection ...`\r\n\r\n* `urllib3` logger: this ready-made logger is to silent unwanted messages from `requests` library.\r\n* suppressed logger: `exchangelib`. This sets logging level of `exchangelib` logger to `WARNING`.<br>\r\nThis is another way to silent unwanted messages from other module, read below for details.\r\n\r\n* `root` logger: if there is no logger initialized in your module, this logger will be used with the above behaviors.\r\nThis logger is also used to log **uncaught exception** in your project. Example:\r\n\r\n  ```python\r\n  raise RecursionError\r\n  ```\r\n  \r\n  ```python\r\n  # log.txt\r\n  [2020-05-31 19:16:01] [root ERROR] Uncaught exception\r\n  Traceback (most recent call last):\r\n    File \"D:/MyProject/Echelon/eyes.py\", line 13, in <module>\r\n      raise RecursionError\r\n      => var_in = Customer(name='John', member_id=123456)\r\n      => arg = (456, 789)\r\n      => kwargs = {'my_kw': 'hello', 'another_kw': 'world'}\r\n  RecursionError\r\n  ```\r\n\r\n* context logging: When an exception occur, variables used in the line of error are also logged.<br>\r\nTo log full local variables of current function scope, pass `full_context=1` to `setup_logging`.<br>\r\nIf you need the outer scope too, set `full_context` to `2`, `3` and so on...\r\n\r\n\r\n## Usage:\r\nAll configs are done through `setup_logging` function:\r\n```python\r\nsetup_logging(config_path=\"\", log_path=\"\", \r\n              capture_print=False, strict=False, guess_level=False,\r\n              full_context=False,\r\n              suppress_level_below=logging.WARNING,\r\n              use_multiprocessing=False,\r\n              limit_line_length=1000, \r\n              analyze_raise_statement=False,\r\n              host=\"\",\r\n              port=0,\r\n              )\r\n```\r\n\r\nThis function also return a `LogConfig` object. \r\nExcept `config_path`, `log_path`, `use_multiprocessing`, `host` and `port`, \r\nother parameters are attributes of this object and can be changed on the fly.\r\n\r\nExcept `config_path`, `log_path`, all other parameters can be defined in `logger_tt` section in the config file\r\n(see `Sample config` chapter below). \r\nParameter with the same name passed in `setup_logging` function will override the one in the config file. \r\n\r\n\r\n\r\n### 1. Overwrite the default log path:\r\n   Instead of `./logs/logs.txt`, you can overwrite with your own as follows\r\n    \r\n   ```python\r\n   setup_logging(log_path='new/path/to/your_log.txt')\r\n   ```\r\n   If you have multiple handlers and want each of them log to different destinations, \r\n   you can pass in a dict of `\"handler_name\": \"log_path\"`. \r\n   The handler names must match what is defined in the config file.   \r\n\r\n   ```python\r\n   setup_logging(log_path={'error_file_handler': 'log/error.txt',\r\n                           'info_file_handler': 'log/info_and_above.txt',\r\n                           }\r\n                 )\r\n   ```\r\n\r\n### 2. Provide your config file:\r\n   You can config your own logger and handler by providing either `yaml` or `json` config file as follows:\r\n    \r\n   ```python\r\n   setup_logging(config_path='path/to/.yaml_or_.json')\r\n   ```\r\n\r\n   Without providing a config file, the default config file with the above **default** log behavior is used.\r\n   You could copy `log_conf.yaml` or `log_conf.json` shipped with this package to start making your version.\r\n\r\n   **Warning**: To process `.yaml` config file, you either need `pyyaml` or `ruamel.yaml` package installed. \r\n\r\n### 3. Capture stdout:\r\n\r\n   If you have an old code base with a lot of `print(msg)` or `sys.stdout.write(msg)` and \r\n   don't have access or time to refactor them into something like `logger.info(msg)`, \r\n   you can capture these `msg` and log them to file, too.\r\n   \r\n   To capture only `msg` that is printed out by `print(msg)`, simply do as follows: \r\n    \r\n   ```python\r\n   setup_logging(capture_print=True)\r\n   ```\r\n   \r\n   Example:\r\n   ```python\r\n   print('To be or not to be')\r\n   sys.stdout.write('That is the question')\r\n   ```\r\n   \r\n   ```\r\n   # log.txt\r\n   [2020-05-09 11:42:08] [PrintCapture INFO] To be or not to be\r\n   ```\r\n   \r\n   <hr>\r\n   \r\n   Yes, `That is the question` is not captured. \r\n   Some libraries may directly use `sys.stdout.write` to draw on the screen (eg. progress bar) or do something quirk.\r\n   This kind of information is usually not useful for users. But when you do need it, you can capture it as follows:\r\n   \r\n   ```python\r\n   setup_logging(capture_print=True, strict=True)\r\n   ```\r\n   \r\n   Example:\r\n   ```python\r\n   sys.stdout.write('The plane VJ-723 has been delayed')\r\n   sys.stdout.write('New departure time has not been scheduled')\r\n   ```\r\n   \r\n   ```\r\n   # log.txt\r\n   [2020-05-09 11:42:08] [PrintCapture INFO] The plane VJ-723 has been delayed\r\n   [2020-05-09 11:42:08] [PrintCapture INFO] New departure time has not been scheduled\r\n   ```\r\n  \r\n   <hr>\r\n   \r\n   As you have seen, the log level of the captured message is `INFO` . \r\n   What if the code base prints something like `An error has occurred. Abort operation.` and you want to log it as `Error`?\r\n   Just add `guess_level=True` to `setup_logging()`.\r\n   \r\n   ```python\r\n   setup_logging(capture_print=True, guess_level=True)\r\n   ```\r\n   \r\n   Example:\r\n   ```python\r\n   print('An error has occurred. Abort operation.')\r\n   print('A critical error has occurred during making request to database')\r\n   ```\r\n   \r\n   ```\r\n   # log.txt\r\n   [2020-05-09 11:42:08] [PrintCapture ERROR] An error has occurred. Abort operation.\r\n   [2020-05-09 11:42:08] [PrintCapture CRITICAL] A critical error has occurred during making request to database\r\n   ```\r\n   \r\n   **Note**: Capturing stdout ignores messages of `blank line`. \r\n   That means messages like `\\n\\n` or `  `(spaces) will not appear in the log. \r\n   But messages that contain blank line(s) and other characters will be fully logged.\r\n   For example, `\\nTo day is a beautiful day\\n` will be logged as is.  \r\n\r\n### 4. Exception logging:\r\n   \r\n   Consider the following error code snippet:\r\n   \r\n   ```python\r\n   API_KEY = \"asdjhfbhbsdf82340hsdf09u3ionf98230234ilsfd\"\r\n   TIMEOUT = 60\r\n   \r\n   class MyProfile:\r\n       def __init__(self, name):\r\n           self.my_boss = None\r\n           self.name = name\r\n\r\n   def my_faulty_func(my_var, *args, **kwargs):\r\n       new_var = 'local scope variable'\r\n       me = MyProfile('John Wick')\r\n       boss = MyProfile('Winston')\r\n       me.my_boss = boss\r\n       print(f'Information: {var} and {me.my_boss.name}' \r\n              ' at {me.my_boss.location} with {API_KEY}')\r\n   \r\n   if __name__ == '__main__':\r\n       cpu_no = 4\r\n       max_concurrent_processes = 3\r\n       my_faulty_func(max_concurrent_processes, 'ryzen 7', freq=3.4)\r\n   ```\r\n   \r\n   In our hypothetical code above,`print` function will raise an exception. \r\n   This exception, by default, will not only be logged but also analyzed with objects that appeared in the line:\r\n   \r\n   ```python\r\n   [2020-06-06 09:36:01] ERROR: Uncaught exception:\r\n   Traceback (most recent call last):\r\n     File \"D:/MyProject/AutoBanking/main.py\", line 31, in <module>\r\n       my_faulty_func(max_concurrent_processes, 'ryzen 7', freq=3.4)\r\n        |-> my_faulty_func = <function my_faulty_func at 0x0000023770C6A288>\r\n        |-> max_concurrent_processes = 3\r\n   \r\n     File \"D:/MyProject/AutoBanking/main.py\", line 25, in my_faulty_func\r\n       print(f'Information: {var} and {me.my_boss.name}'\r\n              ' at {me.my_boss.location} with {API_KEY}')\r\n        |-> me.my_boss.name = 'Winston'\r\n        |-> me.my_boss.location = '!!! Not Exists'\r\n        |-> (outer) API_KEY = 'asdjhfbhbsdf82340hsdf09u3ionf98230234ilsfd'\r\n   NameError: name 'var' is not defined\r\n   ```\r\n   \r\n   **Note**: look at the `print(f'Information...` line, \r\n   `logger-tt` print this error line different from normal python traceback!\r\n   With normal traceback, multi-line python statement has its only first line printed out.\r\n   With `logger-tt`, a full statement is grabbed for you.\r\n   \r\n   For each level in the stack, any object that appears in the error line is shown with its `readable representation`.\r\n   This representation may not necessarily be `__repr__`. The choice between `__str__` and `__repr__` are as follows:\r\n   * `__str__` : `__str__` is present, and the object class's `__repr__` is default with `<class name at Address>`.\r\n   * `__repr__`: `__str__` is present, but the object class's `__repr__` is anything else, such as `ClassName(var=value)`.<br>\r\n   Also, when `__str__` is missing, even if `__repr__` is `<class name at Address>`, it is used.\r\n   \r\n   Currently, if an object doesn't exist and is directly accessed, as `var` in this case, it will not be shown up.\r\n   But if it is attribute accessed with dot `.`, as `location` in `me.my_boss.location`, \r\n   then its value is an explicit string `'!!! Not Exists'`.\r\n   \r\n   As you may have noticed, a variable `API_KEY` has its name prefixed with `outer`. <br>\r\n   This tells you that the variable is defined in the outer scope, not local. \r\n   \r\n   More often than not, only objects in the error line are not sufficient to diagnose what has happened.\r\n   You want to know what the inputs of the function were. You want to know what the intermediate \r\n   calculated results were. You want to know other objects that appeared during runtime,\r\n   not only local but also outer scope. In other words, you want to know the full context of what has happened.\r\n   `logger-tt` is here with you:\r\n   \r\n   ```python\r\n   setup_logging(full_context=2)\r\n   ```\r\n   \r\n   With the above hypothetical code snippet, the error log becomes the following:\r\n   \r\n   ```python\r\n   [2020-06-06 10:35:21] ERROR: Uncaught exception:\r\n   Traceback (most recent call last):\r\n     File \"D:/MyProject/AutoBanking/main.py\", line 31, in <module>\r\n       my_faulty_func(max_concurrent_processes, 'ryzen 7', freq=3.4)\r\n        |-> my_faulty_func = <function my_faulty_func at 0x0000019E3599A288>\r\n        |-> max_concurrent_processes = 3\r\n        => __name__ = '__main__'\r\n        => __doc__ = None\r\n        => __package__ = None\r\n        => __loader__ = <_frozen_importlib_external.SourceFileLoader object at 0x0000019E35840E48>\r\n        => __spec__ = None\r\n        => __annotations__ = {}\r\n        => __builtins__ = <module 'builtins' (built-in)>\r\n        => __file__ = 'D:/MyProject/AutoBanking/main.py'\r\n        => __cached__ = None\r\n        => setup_logging = <function setup_logging at 0x0000019E35D111F8>\r\n        => getLogger = <function getLogger at 0x0000019E35BC7C18>\r\n        => logger = <Logger __main__ (DEBUG)>\r\n        => API_KEY = 'asdjhfbhbsdf82340hsdf09u3ionf98230234ilsfd'\r\n        => TIMEOUT = 60\r\n        => MyProfile = <class '__main__.MyProfile'>\r\n        => cpu_no = 4\r\n   \r\n     File \"D:/MyProject/AutoBanking/main.py\", line 25, in my_faulty_func\r\n       print(f'Information: {var} and {me.my_boss.name} at {me.my_boss.location} with {API_KEY}')\r\n        |-> me.my_boss.name = 'Winston'\r\n        |-> me.my_boss.location = '!!! Not Exists'\r\n        |-> (outer) API_KEY = 'asdjhfbhbsdf82340hsdf09u3ionf98230234ilsfd'\r\n        => my_var = 3\r\n        => args = ('ryzen 7',)\r\n        => kwargs = {'freq': 3.4}\r\n        => new_var = 'local scope variable'\r\n        => me = <__main__.MyProfile object at 0x0000019E35D3BA48>\r\n        => boss = <__main__.MyProfile object at 0x0000019E35D3B9C8>\r\n   NameError: name 'var' is not defined\r\n   ```\r\n   \r\n   Additional objects that not appear in the error line are prefixed with `=>`.\r\n\r\n   **Note**: from version 1.6, uncaught exception happened in child thread of a multithreading \r\n    program will also be caught by `logger-tt` and logged normally. \r\n   If you are using python 3.8+, the new `threading.excepthook` won't be called as the uncaught exception\r\n    has been handled by `logger-tt`. \r\n   \r\n### 5. `try-except` exception logging:\r\n   \r\n   `exception context` logging also applies for `try-except` block.\r\n    This means that if you call `logger.exception()` inside `except` block, \r\n    you would have all variables' value at the line of exception. For example,\r\n    \r\n   ```python\r\n   def my_faulty_func():\r\n       a = 10\r\n       b = 0\r\n       c = a/b\r\n       return c\r\n   \r\n   def my_main():\r\n       try:\r\n           my_faulty_func()\r\n       except Exception as e:\r\n           logger.exception('some error has occured')\r\n           print('Clean up resource')\r\n   \r\n   my_main()\r\n   ``` \r\n   \r\n   Then the log will show up as follows:\r\n   \r\n   ```python\r\n   [2020-06-12 21:37:00] ERROR: some error has occured\r\n   Traceback (most recent call last):\r\n     File \"D:/MyProject/exception_log.py\", line 19, in my_main\r\n       my_faulty_func()\r\n        |-> my_faulty_func = <function my_faulty_func at 0x000001875DD4B168>\r\n   \r\n     File \"D:/MyProject/exception_log.py\", line 13, in my_faulty_func\r\n       c = a / b\r\n        |-> a = 10\r\n        |-> b = 0\r\n   ZeroDivisionError: division by zero\r\n   Clean up resource\r\n   ```\r\n   \r\n   **Note**: As in python's [logging document](https://docs.python.org/3/library/logging.html#logging.Logger.exception),\r\n    `logger.exception()` should only be called from an exception handler, eg. inside `except` block.\r\n   \r\n   You don't need to pass `exception object` to `logger.exception()`. \r\n   It already knows how to get a traceback internally. \r\n   This enable you to pass any string in as a hint or a short description of what may have happened.  \r\n   Otherwise, passing `exception object`, as `logger.exception(e)`, \r\n   will cause the first line of error report to be the message of exception. \r\n   In the case of the above example, it would be come `[2020-06-12 21:37:00] ERROR: division by zero`.\r\n\r\n### 6. Silent unwanted loggers:\r\n   \r\n   Third party modules also have loggers, and their messages are usually not related to your code.\r\n   A bunch of unwanted messages may hide the one that come from your own module. \r\n   To prevent that and also reduce log file size, we need to silent unwanted loggers.\r\n   \r\n   By config file, there are two ways to silent a logger:\r\n   \r\n   * Create a new logger: in `logger` section of the config file, \r\n   add a new logger whose name is the same with the one you want to silent. \r\n   Set it level to `WARNING` or above. If you add `handlers`, you should also set `propagate` to `no` or `False`.\r\n   Otherwise, the same message may be logged multiple times. Ex:\r\n          \r\n         urllib3:\r\n           level: WARNING\r\n           handlers: [console, error_file_handler]\r\n           propagate: no\r\n   \r\n     Above setting only allow messages with level `WARNING` and above to be processed. \r\n     Usually that is enough to silent most of unwanted messages. If you need to silent more messages,\r\n     try `ERROR` or `CRITICAL`.\r\n   \r\n   * Add logger's name to `suppress list`: Then a new logger with level default to `WARNING` will be \r\n   automatically created for you. Ex:\r\n   \r\n         suppress: [exchangelib, urllib3]\r\n   \r\n     If you need to suppress at even higher level, use `suppress_level_below` in `setup_logging`.\r\n     For example suppress any message below `ERROR` level that comes from loggers in `suppress list`:\r\n     \r\n         setup_logging(suppress_level_below=logging.ERROR)\r\n   \r\n   You could also suppress loggers directly by `setup_logging`:\r\n   \r\n   ```python\r\n   from logger_tt import setup_logging    \r\n\r\n   setup_logging(suppress=['urllib3', 'exchangelib'])\r\n   ```\r\n   \r\n### 7. Logging in multiprocessing:\r\n    \r\n   This is archived by using multiprocessing queues or a socket server.\r\n   \r\n   For linux, copy-on-write while forking carries over logger's information. \r\n   So `multiprocess.Queue` is enough in this case. \r\n   \r\n   For Windows, it is important that `setup_logging()` must be call out side of `if __name__ == '__main__':` guard block.\r\n   Because child processes run from scratch and re-import `__main__`, by re-executing `setup_logging()`, \r\n   logger `SocketHandler` can be setup automatically. \r\n   \r\n   This also means that the same config can work with both `multiprocessing.Process` and `multiprocessing.Pool` \r\n   magically without user doing anything special.\r\n   \r\n   Below is a minimal example:\r\n    \r\n```python\r\nimport time\r\nfrom random import randint\r\nfrom multiprocessing import Process\r\n\r\nfrom logger_tt import setup_logging, logger\r\n\r\n\r\nsetup_logging(use_multiprocessing=True)        # for Windows, this line must be outside of guard block\r\n\r\n\r\ndef worker(arg):\r\n    logger.info(f'child process {arg}: started')\r\n    time.sleep(randint(1,10))                  # imitate time consuming process\r\n    logger.info(f'child process {arg}: stopped')\r\n\r\n\r\nif __name__ == '__main__':\r\n    all_processes = []\r\n    logger.info('Parent process is ready to spawn child')\r\n    for i in range(3):\r\n        p = Process(target=worker, args=(i,))\r\n        all_processes.append(p)\r\n        p.daemon = True\r\n        p.start()\r\n\r\n    for p in all_processes:\r\n        p.join()\r\n```\r\n\r\nThe content of `log.txt` should be similar to below:\r\n\r\n```text\r\n[2020-10-28 20:39:14] [root:129 DEBUG] _________________New log started__________________\r\n[2020-10-28 20:39:17] [root:130 DEBUG] Log config file: D:\\my_project\\log_config.json\r\n[2020-10-28 20:39:17] [root:131 DEBUG] Logging server started!\r\n[2020-10-28 20:39:22] [__main__:28 INFO] Parent process is ready to spawn child\r\n[2020-10-28 20:39:22] [__mp_main__:16 INFO] Process-3 child process 2: started\r\n[2020-10-28 20:39:22] [__mp_main__:16 INFO] Process-2 child process 1: started\r\n[2020-10-28 20:39:22] [__mp_main__:16 INFO] Process-1 child process 0: started\r\n[2020-10-28 20:39:23] [__mp_main__:18 INFO] Process-2 child process 1: stopped\r\n[2020-10-28 20:39:23] [__mp_main__:18 INFO] Process-3 child process 2: stopped\r\n[2020-10-28 20:39:24] [__mp_main__:18 INFO] Process-1 child process 0: stopped\r\n```\r\n\r\n   **Note**: Under linux, to use `queueHandler`, you must pass `use_multiprocessing=\"fork\"` to `setup_logging`.<br>\r\n   Other options `True`, `spawn`, `forkserver` will use `socketHandler` by default.<br> \r\n   This is to prevent you `set_start_method` as `spawn` under linux and thus `queueHandler` won't work.\r\n\r\n\r\n   **Socket Address**: `socketHandler` will use tcp `localhost` and port `9020` by default. \r\n   In the rare cases where you run multiple multiprocessing applications with `logger_tt`, \r\n   the `Address already in use` error will be raised. In such cases, you have to set the address manually.\r\n\r\n```python\r\nsetup_logging(host='localhost', port=6789)\r\n```\r\n   You can omit the `host` if you use `\"localhost\"`. \r\n   You can also set this in the log config file for each application. \r\n\r\n   \r\n### 8. Temporary disable logging:\r\n\r\n   Some block of code contain critical information, such as password processing, that should not be logged.\r\n   You can disable logging for that block with a `logging_disabled` context:\r\n  \r\n```python\r\nfrom logger_tt import logging_disabled, getLogger\r\n\r\nlogger = getLogger(__name__) \r\n\r\n\r\nlogger.debug('Begin a secret process')\r\nwith logging_disabled():\r\n    logger.info('This will not appear in any log')\r\n\r\nlogger.debug('Finish')\r\n```\r\n\r\n### 9. Limit traceback line's length:\r\n   Sometimes the variable on the exception line can hold enormous amount of data, \r\n   such as content of some huge json file or html. In this case, printing out the whole content\r\n   of the variable is quite point less and hinders debugging process as it hides away exception line.\r\n    \r\n   So we should limit the character to be printed out in each line of the traceback.\r\n   And we can do it as simple as follow:\r\n\r\n    setup_logging(limit_line_length=1000)\r\n\r\n   The default limit is 1000 characters. All left characters will be replaced with `...`. \r\n   `limit_line_length=0` means no limit at all, prints the content of variable as is.  \r\n\r\n   **Note**: if you input a `float`, it will be round down to nearest `int`. \r\n   A negative input is treated as inputting `0`.\r\n\r\n   For demonstration purpose, the example below will limit to `100` characters:\r\n   ```python\r\nfrom logger_tt import setup_logging\r\n\r\nsetup_logging(limit_line_length=100)\r\n\r\ndef will_fail():\r\n    loren_ipsum = \"On the other hand, we denounce with righteous indignation and dislike men who are so beguiled and \" \\\r\n                  \"demoralized by the charms of pleasure of the moment, so blinded by desire, that they cannot \" \\\r\n                  \"foresee the pain and trouble that are bound to ensue; and equal blame belongs to those who fail in \" \\\r\n                  \"their duty through weakness of will, which is the same as saying through shrinking from toil and \" \\\r\n                  \"pain. These cases are perfectly simple and easy to distinguish. In a free hour, when our power of \" \\\r\n                  \"choice is untrammelled and when nothing prevents our being able to do what we like best, \" \\\r\n                  \"every pleasure is to be welcomed and every pain avoided. But in certain circumstances and owing to \" \\\r\n                  \"the claims of duty or the obligations of business it will frequently occur that pleasures have to \" \\\r\n                  \"be repudiated and annoyances accepted. The wise man therefore always holds in these matters to \" \\\r\n                  \"this principle of selection: he rejects pleasures to secure other greater pleasures, or else he \" \\\r\n                  \"endures pains to avoid worse pains. \"\r\n\r\n    print(f'Below is the {random} text used as a standard to test font: \\n{loren_ipsum}')\r\n\r\nif __name__ == '__main__':\r\n    will_fail()\r\n   ```\r\n\r\nIt will output the follow traceback. Pay attention to the `loren_ipsum` variable.\r\n```python\r\n[2021-06-19 17:40:39] ERROR: Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"D:\\my_project\\long_line.py\", line 21, in <module>\r\n    will_fail()\r\n\r\n  File \"D:\\my_project\\long_line.py\", line 18, in will_fail\r\n    print(f'Below is the {random} text used as a standard to test font: \\n{loren_ipsum}')\r\n     |-> loren_ipsum = 'On the other hand, we denounce with righteous indignation and dislike men wh... (922 characters more)\r\nNameError: name 'random' is not defined\r\n```\r\n\r\n### 10. Analyze `raise` exception line:\r\n   If the code explicitly `raise` an exception, in most cases, \r\n   the variables on the line are substituted and printed out at the end of traceback.\r\n   With `logger-tt` analyzing the `raise` statement, these variables are printed again too.\r\n\r\n```python\r\n[2021-06-19 18:15:01] ERROR: Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"D:\\my_project\\module.py\", line 9, in <module>\r\n    raise RuntimeError(f'Too much laughing with a={a} and b={b}')\r\n     |-> a = 'haha'\r\n     |-> b = 'hihi'\r\nRuntimeError: Too much laughing with a=haha and b=hihi\r\n```\r\n\r\n   The duplication is unnecessary, so from version `1.6.1`, `raise` exception line will not be analyzed as default.\r\n   This resulted in a much cleaner log:\r\n\r\n```python\r\n[2021-06-19 18:15:30] ERROR: Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"D:\\my_project\\module.py\", line 9, in <module>\r\n    raise RuntimeError(f'Too much laughing with a={a} and b={b}')\r\nRuntimeError: Too much laughing with a=haha and b=hihi\r\n```\r\n\r\n   If the `raise` exception line in turn, raise another exception, and you want to analyze it,\r\n   you could turn it back on as below:\r\n\r\n    setup_logging(analyze_raise_statement=True)\r\n\r\n\r\n### 11. StreamHandler with buffer:\r\n   This handler is mainly to solve the problem of outputting a tremendous amount of logs to GUI applications in real-time.\r\n   \r\n   GUI applications use threading to display content while listening for user input (button click, key pressing, mouse scroll).\r\n   But since cpython actually running only one thread at a time due to the GIL (global interpreter lock), \r\n   processing to display a tremendous amount of logs to the GUI widget will lock a thread for quite a long time. \r\n   During this time, no user input will be handled and the app seems unresponsive.\r\n\r\n   The answer to this problem is to cache the log and output them at once after some interval or a number of cached lines reached a threshold.\r\n   This significantly reduces the overhead on the widget side and makes the app responsive. \r\n   The solution is implemented in the new `StreamHandlerWithBuffer` which is inside `logger_tt.handlers`. \r\n   There are 2 steps to use this handler.\r\n     \r\n   * config the handler in the `log_config` file.\r\n\r\n     ```yaml\r\n     handlers:\r\n       buffer_stream_handler:\r\n         class: logger_tt.handlers.StreamHandlerWithBuffer\r\n         level: DEBUG\r\n         formatter: brief\r\n         stream: ext://sys.stdout\r\n         buffer_time: 0.5\r\n         buffer_lines: 0\r\n         debug: False\r\n     \r\n     root:\r\n       level: DEBUG\r\n       handlers: [console, error_file_handler, buffer_stream_handler]\r\n     ```\r\n     \r\n     Its parameters look exactly like the `console` handler except the last 3 ones.\r\n     * `buffer_time`: the cache time interval in **seconds** before it flush the log out \r\n     * `buffer_line`: the **number of line** to cache before it flush the log out\r\n     * `debug`: log the time that it flush the log out or not<br>\r\n     \r\n     For `buffer_line`, to avoid the last lines of log not printed out as the number of line is below threshold, \r\n     you should set `buffer_time` to a certain number too.  \r\n\r\n     Then, you need to add this handler to the `root` logger's `handlers` list.\r\n\r\n\r\n   * replace the `stream`:\r\n     you need to replace the `stdout` with your GUI widget stream.\r\n     You cannot do this in the config file since your widget is only appear during runtime. \r\n     You have to do this in the code.\r\n\r\n     ```python\r\n     config = setup_logging(config_path='log_config.json')\r\n     config.replace_handler_stream(index=HANDLER_INDEX, stream=WIDGET_STREAM)\r\n     ```\r\n     Setup your logging as usual with your config file, \r\n     then call `replace_handler_stream` to replace the with your widget's stream.\r\n     * `index`: the index of the handler, in the root logger' `handlers` list, that you want to replace the stream\r\n     * `stream`: the stream that you want to put into this handler.\r\n   \r\n\r\n   Below is the example with `PySimpleGUI v4.57.0` with the above config.\r\n   ```python\r\nimport time\r\nfrom threading import Thread\r\n\r\nimport PySimpleGUI as sg\r\nfrom logger_tt import setup_logging, logger\r\n\r\nstop_flag = False\r\n\r\n# GUI config\r\nsg.theme('DarkAmber')\r\nlayout = [\r\n    [[sg.Button(\"Show Log\", key=\"-show_log-\"),\r\n     sg.Button(\"stop\", key=\"-stop-\", button_color='red')],\r\n     sg.Multiline(size=(80, 30), font='Courier 10', key='log', autoscroll=True)]\r\n]\r\nwindow = sg.Window('Logging tool', layout, finalize=True)\r\n\r\n# logging config\r\nconfig = setup_logging(config_path='log_config.json')\r\nconfig.replace_handler_stream(index=2, stream=window[\"log\"])\r\n\r\n\r\ndef my_func():\r\n    \"\"\"long running task in the background\"\"\"\r\n    while not stop_flag:\r\n        for i in range(1000):\r\n            logger.warning(f\" {i} Function is empty\")\r\n        time.sleep(1)\r\n\r\n\r\nwhile True:\r\n    event, values = window.read()\r\n    if event == sg.WINDOW_CLOSED:\r\n        break\r\n    if event == \"-show_log-\":\r\n        logger.info(__name__)\r\n        Thread(target=my_func).start()\r\n    if event == \"-stop-\":\r\n        stop_flag = True\r\n        logger.info(f\"stop button pressed\")\r\n\r\nwindow.close()\r\n   ```\r\n   You could set `index=0` to use the normal `StreamHandler` and \r\n   see the difference while clicking the `stop` button for yourself.\r\n\r\n### 12. Telegram Handler:\r\n   This handler enables you to send log messages directly to telegram users or groups. \r\n   For telegram groups, you can specify a certain `topic` to send to, too.\r\n   This handler uses web API, so there is no third-party dependency.\r\n   \r\n   To set up this handler, you need the following information:\r\n     * Your bot `token`: if you don't have one, create a new bot with https://t.me/botfather.\r\n     * Destination `unique_id`: a `chat_id` (user id or group id) and optionally \r\n       `message_thread_id`of a topic in that group. You can chat with or add @RawDataBot to your group to get these ids.\r\n     * Log level to be sent: above a level or only a specific level.\r\n   \r\n     \r\n   From here you have 2 options, put the `token` and `unique_id` directly in the config file or in the environment.\r\n   If you specify both ways, if the data exists in the environment variables, \r\n   it will replace the one specified in the config file. The default environment variable names are:\r\n   * token: `TELEGRAM_BOT_LOG_TOKEN`\r\n   * unique_ids: `TELEGRAM_BOT_LOG_DEST`\r\n   \r\n   These above names are specified in `env_token_key` and `env_unique_ids_key` in the default config file. \r\n   You may edit them to suit your environment.\r\n   \r\n   For the values, `unique_ids` accepts the format `[name:]chat_id[@message_thread_id]`, \r\n   multiple values must be separated by a semicolon (space after a semicolon will be ignored). \r\n   Which means the following examples are possible:\r\n   * a single chat_id: `123456789` (user id) or `-987654321` (group id)\r\n   * a specified topic within a group: `-987654321@2`\r\n   * multiple values: `123456789; 102345678; -987654321@2; -987654322@4`\r\n   * multiple values with names: `Alex:123456789; Bob:102345678; support:-987654321@2; admin:-987654322@4`\r\n   \r\n   After having all needed information, the next step is configuring the handler and adding it into the `root` logger.\r\n   ```yaml\r\n   handlers:\r\n     telegram_handler:\r\n     class: logger_tt.handlers.TelegramHandler\r\n     level: NOTICE\r\n     formatter: brief\r\n     debug: False\r\n     token: \"\"\r\n     unique_ids: \"\"\r\n     env_token_key: \"TELEGRAM_BOT_LOG_TOKEN\",\r\n     env_unique_ids_key: \"TELEGRAM_BOT_LOG_DEST\"\r\n     \r\n   root:\r\n     level: DEBUG\r\n     handlers: [console, error_file_handler, telegram_handler]\r\n   ```\r\n\r\n   From here, it should already work. \r\n   If you need certain messages to go to a certain people/group, besides adding a new handler, \r\n   you can add a filter that adds the `dest_name` attribute to the log `record`. \r\n   \r\n```python\r\ndef telegram_filter(record):\r\n    if 'over threshold' in record.msg:\r\n        record.dest_name = 'support'\r\n    elif 'unauthorized' in record.msg:\r\n        record.dest_name = 'admin'\r\n    elif 'Alex' in record.msg:\r\n        record.dest_name = 'Alex'\r\n    else:\r\n        pass\r\n\r\nlog_config = setup_logging()\r\nlog_config.set_context_injector(telegram_filter)\r\n\r\nlogger.warning(f'Memory usage is over threshold')\r\nlogger.error(f'This deleting action is unauthorized')\r\nlogger.notice(f\"Alex's files are ready to be collected\")\r\n```\r\n   `dest_name` should be only one name that has been registered in `unique_ids`. \r\n   If the name is not registered, the log record is simply ignored totally. \r\n   If you want to send to multiple people, create a telegram group for them and registered the group name.\r\n\r\n\r\n# Sample config:\r\nBelow are default config files that used by `logger-tt`. You can copy and modify them as needed. \r\n## 1. Yaml format:\r\n   \r\n   log_config.yaml:\r\n   \r\n```yaml\r\n# This is an example of config file\r\n# In case of no config provided, log_config.json file will be loaded\r\n# If you need a yaml file, install pyyaml or ruamel.yaml package and copy this file\r\nversion: 1\r\ndisable_existing_loggers: False\r\nformatters:\r\n  simple:\r\n    format: \"[%(asctime)s] [%(name)s:%(lineno)d %(levelname)s] %(message)s\"\r\n    datefmt: \"%Y-%m-%d %H:%M:%S\"\r\n  brief:\r\n    format: \"[%(asctime)s] %(levelname)s: %(message)s\"\r\n    datefmt: \"%Y-%m-%d %H:%M:%S\"\r\n\r\nhandlers:\r\n  console:\r\n    class: logging.StreamHandler\r\n    level: INFO\r\n    formatter: brief\r\n    stream: ext://sys.stdout\r\n\r\n  error_file_handler:\r\n    class: logging.handlers.TimedRotatingFileHandler\r\n    level: DEBUG\r\n    formatter: simple\r\n    filename: logs/log.txt\r\n    backupCount: 15\r\n    encoding: utf8\r\n    when: midnight\r\n  \r\n  buffer_stream_handler:\r\n    class: logger_tt.handlers.StreamHandlerWithBuffer\r\n    level: DEBUG\r\n    formatter: brief\r\n    stream: ext://sys.stdout\r\n    buffer_time: 0.5\r\n    buffer_lines: 0\r\n    debug: False\r\n    \r\n  telegram_handler:\r\n    class: logger_tt.handlers.TelegramHandler\r\n    level: NOTICE\r\n    formatter: brief\r\n    debug: False\r\n    token: \"your bot token here or set the below env key to fetch from environ for better security\"\r\n    unique_ids: \"semicolon separated of [name:]chat_id[@message_thread_id]\"\r\n    env_token_key: \"TELEGRAM_BOT_LOG_TOKEN\"\r\n    env_unique_ids_key: \"TELEGRAM_BOT_LOG_DEST\"\r\n\r\nloggers:\r\n  urllib3:\r\n    level: WARNING\r\n    handlers: [console, error_file_handler]\r\n    propagate: no\r\n\r\nroot:\r\n  level: DEBUG\r\n  handlers: [console, error_file_handler]\r\n\r\nlogger_tt:\r\n  suppress: [\"exchangelib\"]\r\n  suppress_level_below: \"WARNING\"\r\n  capture_print: False\r\n  strict: False\r\n  guess_level: False\r\n  full_context: 0\r\n  use_multiprocessing: False\r\n  limit_line_length: 1000\r\n  analyze_raise_statement: False\r\n  default_logger_formats:\r\n    normal: [\"%(name)s\", \"%(filename)s\"]\r\n    thread: [\"%(message)s\", \"%(threadName)s %(message)s\"]\r\n    multiprocess: [\"%(message)s\", \"%(processName)s %(message)s\"]\r\n    both: [\"%(message)s\", \"%(processName)s %(threadName)s %(message)s\"]\r\n```\r\n\r\n## 2. Json format:\r\n\r\n   log_config.json:\r\n   \r\n```json\r\n{\r\n \"version\": 1,\r\n \"disable_existing_loggers\": false,\r\n \"formatters\": {\r\n   \"simple\": {\r\n     \"format\": \"[%(asctime)s] [%(name)s:%(lineno)d %(levelname)s] %(message)s\",\r\n     \"datefmt\": \"%Y-%m-%d %H:%M:%S\"\r\n   },\r\n   \"brief\": {\r\n     \"format\": \"[%(asctime)s] %(levelname)s: %(message)s\",\r\n     \"datefmt\": \"%Y-%m-%d %H:%M:%S\"\r\n   }\r\n },\r\n\r\n \"handlers\": {\r\n   \"console\": {\r\n     \"class\": \"logging.StreamHandler\",\r\n     \"level\": \"INFO\",\r\n     \"formatter\": \"brief\",\r\n     \"stream\": \"ext://sys.stdout\"\r\n   },\r\n\r\n   \"error_file_handler\": {\r\n     \"class\": \"logging.handlers.TimedRotatingFileHandler\",\r\n     \"level\": \"DEBUG\",\r\n     \"formatter\": \"simple\",\r\n     \"filename\": \"logs/log.txt\",\r\n     \"backupCount\": 15,\r\n     \"encoding\": \"utf8\",\r\n     \"when\": \"midnight\"\r\n   },\r\n\r\n   \"buffer_stream_handler\": {\r\n     \"class\": \"logger_tt.handlers.StreamHandlerWithBuffer\",\r\n     \"level\": \"INFO\",\r\n     \"formatter\": \"simple\",\r\n     \"stream\": \"ext://sys.stdout\",\r\n     \"buffer_time\": 0.5,\r\n     \"buffer_lines\": 0,\r\n     \"debug\": false\r\n    }, \r\n     \r\n   \"telegram_handler\": {\r\n     \"class\": \"logger_tt.handlers.TelegramHandler\",\r\n     \"level\": \"NOTICE\",\r\n     \"formatter\": \"brief\",\r\n     \"debug\": false,\r\n     \"token\": \"your bot token here or set the below env key to fetch from environ for better security\",\r\n     \"unique_ids\": \"semicolon separated of [name:]chat_id[@message_thread_id]\",\r\n     \"env_token_key\": \"TELEGRAM_BOT_LOG_TOKEN\",\r\n     \"env_unique_ids_key\": \"TELEGRAM_BOT_LOG_DEST\"\r\n    }\r\n },\r\n\r\n \"loggers\": {\r\n   \"urllib3\": {\r\n     \"level\": \"ERROR\",\r\n     \"handlers\": [\"console\", \"error_file_handler\"],\r\n     \"propagate\": false\r\n   }\r\n },\r\n\r\n \"root\": {\r\n   \"level\": \"DEBUG\",\r\n   \"handlers\": [\"console\", \"error_file_handler\"]\r\n },\r\n\r\n \"logger_tt\": {\r\n   \"suppress\": [\"exchangelib\"],\r\n   \"suppress_level_below\": \"WARNING\",\r\n   \"capture_print\": false,\r\n   \"strict\": false,\r\n   \"guess_level\": false,\r\n   \"full_context\": 0,\r\n   \"use_multiprocessing\": false,\r\n   \"limit_line_length\": 1000,\r\n   \"analyze_raise_statement\": false,\r\n   \"default_logger_formats\": {\r\n      \"normal\": [\"%(name)s\", \"%(filename)s\"],\r\n      \"thread\": [\"%(message)s\", \"%(threadName)s %(message)s\"],\r\n      \"multiprocess\": [\"%(message)s\", \"%(processName)s %(message)s\"],\r\n      \"both\": [\"%(message)s\", \"%(processName)s %(threadName)s %(message)s\"]\r\n   }\r\n }\r\n}\r\n```\r\n\r\n# Changelog\r\n## 1.7.1\r\n* Fixed: exception raised while handling another exception is now shown correctly (thank ZeroRin). \r\n* New functionality: \r\n  * Added `TelegramHandler`. Now you can send log directly to telegram users/groups.\r\n  * Support Python 3.11 `Fine-grained error locations` in tracebacks.\r\n* Usability: \r\n  * Added level NOTICE = INFO + 5. You can do `logger.notice(\"your message\")`.\r\n  * Add set/remove `context injector` methods. \r\n    You can add additional information to the log record before it is actually handled. \r\n    Refer the `TelegramHandler` for usage sample.\r\n  * You can now set different log paths for different handlers by passing a dict to `setup_logging` (thank ZeroRin). \r\n\r\n## 1.7.0\r\n* Fixed: \r\n  * multiprocessing: log file rollover fails as child process keep opening the file.\r\n  * multiprocessing: if the log path is set by a variable with time, \r\n    child process creates a new redundant log path.\r\n  \r\n* New functionality: Added `StreamHandlerWithBuffer`. Buffer the log output by time or by line number.\r\n    GUI app could use this handler to keep the app responsive while having a tremendous log output.\r\n\r\n* Usability: In multiprocessing logging, \r\n  users can set the log server address themselves through `setup_logging` or log config file.\r\n\r\n## 1.6.1\r\n* Added `limit_line_length` parameter: log only maximum `n` characters for each traceback line. \r\n  This prevents dumping the whole huge content of the variable into the log. `n=1000` by default.\r\n  \r\n* Added `analyze_raise_statement` parameter: \r\n  `logger-tt` no longer analyze the `raise` statement by default. \r\n  This avoids logging value of variables on the `raise` statement two time, especially when the content \r\n  of these variables are huge.\r\n\r\n## 1.6.0\r\n* Fixed: If an exception happened on the multiline statement,\r\n py3.6 and py3.7 return the last line while py3.9 returns the first line. \r\n  Plus the `tokenize` module's behavior has changed, so it made grabbing the \r\n  all the lines of the statement inconsistent and sometime buggy.\r\n  Now `logger-tt` only grabs maximum of 10 lines and grabs more accurately, \r\n  more consistent between different python version.\r\n  \r\n* Added support for `ruamel.yaml` package. If you already have it installed, \r\n  you don't need to install `pyyaml` to use `config.yaml` file \r\n  \r\n* New feature: Uncaught exception happened in child thread of multi-threading \r\n program will also be logged. For python 3.8+, `threading.excepthook` will not run\r\n  as the exception is already caught by `logger-tt`.\r\n\r\n\r\n## 1.5.2\r\n**Improved the pre-made logger named `logger_tt`** \r\n\r\n* `logger_tt` now can detect the qualified `__name__` of the module that calls it.\r\n Instead of `filename`, output log line will have the `__name__` as regular logger.\r\n \r\n  For example:\r\n \r\n      [2020-07-21 11:24:19] [my_module.py:5 DEBUG] Module is initialized\r\n      [2020-07-21 11:24:19] [sub_module.py:15 DEBUG] Entering sub module\r\n    \r\n  Now becomes\r\n \r\n      [2020-07-21 11:24:19] [__main__:5 DEBUG] Module is initialized\r\n      [2020-07-21 11:24:19] [my_module.submodule:15 DEBUG] Entering sub module\r\n \r\n* Suppressing loggers also works with log records output by `logger_tt` by using the qualified `__name__` too.\r\n For example, suppressing `my_module.submodule` will tell `logger_tt` not to output the second line.\r\n \r\n  This is much better than suppressing `logger_tt` if you use this same logger in other modules too. \r\n\r\n* You now can define fields of log record for `logger_tt` in the log config file too. \r\n Just looks for `default_logger_formats` section. \r\n It works by replacing the field in the formatters that are used by any handler of the root logger.\r\n\r\n**Pre-existing loggers:**<br> \r\nBefore this version, if you import submodules before importing `logger_tt` and \r\nthere are loggers in submodules, these loggers do not inspect exception when you call `logger.exception()`. \r\nThat is because there class was different from the loggers created after importing `logger_tt`.\r\nNow all loggers have the same new class regardless the point of importing `logger_tt`.\r\n\r\n**setup_logging()**: This function should only be called once. \r\nAdd a warning if it is called more than one time.\r\n\r\n## 1.5.1\r\n* Use `socketHandler` as default for multiprocessing.\r\n Under linux, to use `queueHandler`, user must pass `use_multiprocessing=\"fork\"` to `setup_logging` \r\n* Expose `logging_disabled` function to user: `from logger_tt import logging_disabled`. \r\nThen this function can be used as a context with `with` statement. \r\n* For convenient, user can import a pre-made `logger` from `logger_tt` to use right away in sub modules.\r\nThe built-in `getLogger` function can be imported from `logger_tt`, too.\r\n* Added line number to a default `simple` log record formatter in the config file.\r\n* Most parameters of `setup_logging()` function can be specified in the config file, too.\r\nIf the same parameter is specified in both `setup_logging()` function and in the config file,\r\nthe parameter passed in `setup_logging()` will be used.\r\n\r\n## 1.5.0\r\n* Logging is off-loaded to another thread and uses Queue to communicate. \r\n  This allow critical thread can do there job why time-consuming logging can be done later or in parallel. \r\n* Support for multiprocessing logging. For linux, a multiprocessing queue is used. \r\n  For Windows and macOS, a socket server is used instead.  \r\n* `setup_logging` now return a `LogConfig` object. \r\n   You can set/change parameters of this object instead of passing arguments directly to `setup_logging`.<br>\r\n   Only `config_path`, `log_path` and `use_multiprocessing` argument must be set with `setup_logging`.\r\n\r\n__Behaviors changed__:\r\n\r\n  * `full_context` is now an `int` that indicate the depth level from the bottom,\r\n       where surrounding variables should be parsed. \r\n  * Turned off parsing full context for `raise` exception since many exception names are enough to understand the problem.\r\n  * `log_config` file: move `suppress` section into `logger_tt` section. \r\n    Future settings will also be put into this section for the sake of managing. \r\n    If you need to hanging the logging framework, you just need to delete this section and move on. \r\n\r\n## 1.4.2\r\nTo prevent exception during logging, the following actions have been applied:\r\n* Catch exception while parsing for object's value (property of a class)\r\n* Catch exception while evaluating `__repr__` and `__str__` of object\r\n* Disable logging while inspecting objects' value and representation\r\n* Disable logging after an uncaught exception is logged. \r\n  Because the interpreter is shutting down, objects get deleted. \r\n  Logging put inside magic function `__del__` will raise error.\r\n\r\n## 1.4.1\r\n* Fix `print_capture` ignoring `print()` line in global scope due to lacking `code_context` frame\r\n* If `__str__` of an object has multiple lines, also indent the second line and so on accordingly.\r\n* If there is an exception during getting object's representation, \r\nreturn `!!! Attribute error` instead of `Error in sys.excepthook`\r\n\r\n## 1.4.0\r\n* Add an extra field `suppress` in config file. \r\nAny logger's name appeared in this list will have its messages suppressed.\r\n\r\n## 1.3.2\r\n* change extended ascii dash ` ─ ` to normal dash `-` \r\nso that it is displayed consistently in different encoding \r\n\r\n## 1.3.1\r\n* change extended ascii vertical bar ` ├ ` to normal bar `|` \r\nso that it is displayed consistently in different encoding \r\n\r\n## 1.3.0\r\n* Exception analyzing now fetch full multi-line python statement. \r\nThis means that variables lie at seconds and below of the same statement can also be seen \r\nwithout the need of `full_context=True`.\r\n\r\n## 1.2.1\r\n* Extend logging context to `logger.exception()` as well. \r\nNow you can do `try-except` a block of code and still have a full context at error line. \r\n\r\n## 1.2.0\r\n* Add logging context for uncaught exception. Now automatically log variables surrounding the error line, too.\r\n* Add test cases for logging exception\r\n\r\n## 1.1.1\r\n* Fixed typos and grammar\r\n* Add config file sample to README\r\n* using full name `log_config.json` instead of `log_conf.json`, the same for yaml file \r\n* add test cases for `capture print`\r\n\r\n## 1.1.0\r\n* Add `capture print` functionality with `guess level` for the message.\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Dragon2fly/logger_tt",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "logger-tt",
    "package_url": "https://pypi.org/project/logger-tt/",
    "platform": "Any platform -- don't need Windows",
    "project_url": "https://pypi.org/project/logger-tt/",
    "project_urls": {
      "Homepage": "https://github.com/Dragon2fly/logger_tt"
    },
    "release_url": "https://pypi.org/project/logger-tt/1.7.1/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Make logging simple, log even exception that you forgot to catch. Make multiprocessing logging becomes a breeze",
    "version": "1.7.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17161471,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "57f738ae914eb0bbc313384c79daebc682fc65de47af4b969ce494b26e1e48d8",
        "md5": "8c5c679b2559397d73f6db64a4caab86",
        "sha256": "7c1cdf8708fb44ef01bfcf2e5c29b899add863fce30cb321e1b932b541361829"
      },
      "downloads": -1,
      "filename": "logger_tt-1.7.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "8c5c679b2559397d73f6db64a4caab86",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 35469,
      "upload_time": "2023-01-08T06:46:48",
      "upload_time_iso_8601": "2023-01-08T06:46:48.559335Z",
      "url": "https://files.pythonhosted.org/packages/57/f7/38ae914eb0bbc313384c79daebc682fc65de47af4b969ce494b26e1e48d8/logger_tt-1.7.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "38066b92f7b9d7265e0e9ae59619c47632be4f72f5fdfc236acdf030e91f7bc4",
        "md5": "f6ede03f4f14a72f62623bc5af5ca749",
        "sha256": "306df23fe296f39c3af7c3b8a54651c05d46d438b6a34911e3c34609cd8fcd37"
      },
      "downloads": -1,
      "filename": "logger_tt-1.7.1.tar.gz",
      "has_sig": false,
      "md5_digest": "f6ede03f4f14a72f62623bc5af5ca749",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 73018,
      "upload_time": "2023-01-08T06:46:50",
      "upload_time_iso_8601": "2023-01-08T06:46:50.480509Z",
      "url": "https://files.pythonhosted.org/packages/38/06/6b92f7b9d7265e0e9ae59619c47632be4f72f5fdfc236acdf030e91f7bc4/logger_tt-1.7.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}