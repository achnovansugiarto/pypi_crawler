{
  "info": {
    "author": "Yauhen Yakimovich",
    "author_email": "eugeny.yakimovitch@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "Mlab is a high-level python to Matlab bridge that lets Matlab look like a normal python library.\nThis python library is based on the work of original mlabwrap project\nhttp://mlabwrap.sourceforge.net/\nand Dani Valevski (from Dana Pe'er's lab):\nhttp://code.google.com/p/danapeerlab/source/browse/trunk/freecell/depends/common/python/matlabpipe.py\nPrimer\n\nQuick installation:\n\npip install mlab\n\nStart working with the library by picking a MATLAB release that you have locally installed:\n\nfrom mlab.releases import latest_release\nfrom matlab import matlabroot\n\nprint matlabroot()\n\nwhere latest_release is a MlabWrap instance, matlabroot is wrapper around MATLAB function.\nPlease note that matlab module is dynamically created instance, which is in this case referencing\nlatest_release object.\n\nMATLAB installation discovery mechanism is implemented by mlab.releases module in such a way, that\nyou have to specify the release version you want to use first, by importing it. Only then you can\nimport from matlab module:\n\nfrom mlab.releases import R2010b\nfrom matlab import matlabroot\n\nAlso see mlab.releases.get_available_releases().\n\nContents\n\nPrimer\n\nDescription\n\nRelated\n\nNews\n\nLicense\n\nDownload\n\nInstallation\n\nLinux\n\nWindows\n\nDocumentation\n\nTutorial\n\nComparison to other existing modules\n\nWhat's Missing?\n\nImplementation Notes\n\nTroubleshooting\n\nStrange hangs under Matlab R2008a\n\nmatlab not in path\n\n\"Can't open engine\"\n\n\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)\n\nOld Matlab version\n\nOS X\n\nNotes on running\n\nWindows\n\nFunction Handles and callbacks into python\n\nDirectly manipulating variables in Matlab space\n\nSupport and Feedback\n\nCredits\nDescription\n\nMlabwrap is a high-level python to Matlab bridge that lets Matlab look\nlike a normal python library.\n\nThanks for your terrific work on this very-useful Python tool!\n\nGeorge A. Blaha, Senior Systems Engineer,\nRaytheon Integrated Defense Systems\n\nmlab is a repackaging effort to make things up-to-date.\n\n\nRelated\n\nThereis is a copy of mlabwrap v1.1-pre (http://mlabwrap.sourceforge.net/) patched\nas described here:\nhttp://sourceforge.net/mailarchive/message.php?msg_id=27312822\n\nwith a patch fixing the error:\n\nmlabraw.cpp:225: *error*: invalid conversion from const mwSize* to const int*\n\nAlso note that in Ubuntu you need to sudo apt-get install csh\n\nFor details see\nhttp://github.com/aweinstein/mlabwrap\nNews\n\n2013-07-26 1.1.1 Repacking a library as mlab project. Including code\nfor Windows (matlabraw.cpp is off for now).\n\n2009-10-26 1.1 fixes an incorrect declaration in mlabraw.cpp\nthat caused compilation problems for some users and incorporates a\nsetup.py fix for windows suggested by Alan Brooks. More significantly\nthere is a new spiffy logo!\n\n2009-09-14 1.1-pre finally brings N-D array support, thanks to Vivek\nRathod who joined the project! Also fixed a missing import for saveVarsInMat\n(thanks to Nicolas Pinto).\n\nSince a few people have run into problems that appear to relate to compiling\nMatlab C-extensions in general and aren't mlabwrap-specific, I should probably\nstress that in case of any problems that look C-related, verifying whether\nengdemo.c works is a great litmus test (see Troubleshooting ).\n\n2009-03-23 1.0.1 is finally out. This is a minor release that fixes some\nannoying but mostly minor bugs in mlabwrap (it also slightly improves the\nindexing support for proxy-objects, but the exact semantics are still subject\nto change.)\n\ninstallation is now easier, in particularly LD_LIBRARY_PATH no longer\nneeds to be set and some quoting issues with the matlab call during\ninstallation have been addressed.\n\nsparse Matlab matrices are now handled correctly\n(mlab.sparse([0,0,0,0]) will now return a proxy for a sparse double\nmatrix, rather than incorrectly treat at as plain double array and return\njunk or crash).\n\nreplaced the (optional) use of the outdated netcdf package for the\nunit-tests with homegrown matlab helper class.\n\nseveral bugs squashed (length of mlabraw.eval'ed strings is checked, better\nerror-messages etc.) and some small documentation improvements and quite a\nfew code clean-ups.\n\nMany thanks to Iain Murray at Toronto and Nicolas Pinto at MIT for letting\nthemselves be roped into helping me test my stupidly broken release\ncandidates.\nLicense\n\nmlab (and mlabwrap) is under MIT license, see LICENSE.txt. mlabraw is under a BSD-style\nlicense, see the mlabraw.cpp.\nDownload\n\n<http://github.com/ewiger/mlab>\nInstallation\n\nmlab should work with python>=2.7 (downto python 2.2, with minor coaxing) and\neither numpy (recommended) or Numeric (obsolete) installed and Matlab 6, 6.5,\n7.x and 8.x under Linux, OS X and Windows (see OS X) on 32- or 64-bit\nmachines.\n\nLinux\n\nIf you're lucky (linux, Matlab binary in PATH):\n\npython setup.py install\n\n(As usual, if you want to install just in your homedir add --prefix=$HOME;\nand make sure your PYTHONPATH is set accordingly.)\n\nIf things do go awry, see Troubleshooting.\n\nWindows\n\nAssuming you have python 2.7.5 (e.g. C:Python27) and setuptools\n(\"easy_install.exe\") installed and on your PATH.\n\n1) Download and install numpy package. You can use packages provided by\nChristoph Gohlke: http://www.lfd.uci.edu/~gohlke/pythonlibs/ Also see official\nSciPy website for latest status, it might that:\n\neasy_install.exe numpy\n\nwould do the trick.\n\nYou would also need The PyWin32 module by Mark Hammond:\n\n<string>:172: (WARNING/2) Literal block expected; none found.\n\n<string>:170: (INFO/1) Enumerated list start value not ordinal-1: \"2\" (ordinal 2)\n\neasy_install.exe pywin32\n\nalso see Windows in Troubleshooting.\nDocumentation\n\nfor lazy people\n\n>>> from mlab.releases import latest_release as matlab\n>>> matlab.plot([1,2,3],'-o')\n\nugly-plot\n\na slightly prettier example\n\n>>> from mlab.releases import latest_release as matlab\n>>> from numpy import *\n>>> xx = arange(-2*pi, 2*pi, 0.2)\n>>> mlab.surf(subtract.outer(sin(xx),cos(xx)))\n\nsurface-plot\n\nfor a complete description:\nJust run pydoc mlab.\n\nfor people who like tutorials:\nsee below\n\nTutorial\n\n[This is adapted from an email I wrote someone who asked me about mlabwrap.\nCompatibility Note: Since matlab is becoming increasingly less\ndouble-centric, the default conversion rules might change in post 1.0\nmlabwrap; so whilst using mlab.plot([1,2,3]) rather than\nmlab.plot(array([1.,2.,3.])) is fine for interactive use as in the\ntutorial below, the latter is recommended for production code.]\n\nLegend: [...] = omitted output\n\nLet's say you want to do use Matlab to calculate the singular value\ndecomposition of a matrix.  So first you import the mlab pseudo-module and\nNumeric:\n\n>>> from mlab import mlab\n>>> import numpy\n\nNow you want to find out what the right function is, so you simply do:\n\n>>> mlab.lookfor('singular value')\nGSVD   Generalized Singular Value Decompostion.\nSVD    Singular value decomposition.\n[...]\n\nThen you look up what svd actually does, just as you'd look up the\ndocstring of a python function:\n\n>>> help(mlab.svd)\nmlab_command(*args, **kwargs)\n SVD    Singular value decomposition.\n    [U,S,V] = SVD(X) produces a diagonal matrix S, of the same\n    dimension as X and with nonnegative diagonal elements in\n[...]\n\nThen you try it out:\n\n>>> mlab.svd(array([[1,2], [1,3]]))\narray([[ 3.86432845],\n      [ 0.25877718]])\n\nNotice that we only got 'U' back -- that's because python hasn't got something\nlike Matlab's multiple value return. Since Matlab functions can have\ncompletely different behavior depending on how many output parameters are\nrequested, you have to specify explicitly if you want more than 1. So to get\n'U' and also 'S' and 'V' you'd do:\n\n>>> U, S, V = mlab.svd([[1,2],[1,3]], nout=3)\n\nThe only other possible catch is that Matlab (to a good approximation)\nbasically represents everything as a double matrix. So there are no\nscalars, or 'flat' vectors. They correspond to 1x1 and 1xN matrices\nrespectively. So, when you pass a flat vector or a scalar to a\nmlab-function, it is autoconverted. Also, integer values are automatically\nconverted to double floats. Here is an example:\n\n>>> mlab.abs(-1)\narray([       [ 1.]])\n\nStrings also work as expected:\n\n>>> mlab.upper('abcde')\n'ABCDE'\n\nHowever, although matrices and strings should cover most needs and can be\ndirectly converted, Matlab functions can also return structs or indeed\nclasses and other types that cannot be converted into python\nequivalents. However, rather than just giving up, mlabwrap just hides\nthis fact from the user by using proxies:\nE.g. to create a netlab neural net with 2 input, 3 hidden and 1 output node:\n\n>>> net = mlab.mlp(2,3,1,'logistic')\n\nLooking at net reveals that is a proxy:\n\n>>> net\n<MLabObjectProxy of matlab-class: 'struct'; internal name: 'PROXY_VAL0__';\nhas parent: no>\n    type: 'mlp'\n     nin: 3\n nhidden: 3\n    nout: 3\n    nwts: 24\n   outfn: 'linear'\n      w1: [3x3 double]\n      b1: [0.0873 -0.0934 0.3629]\n      w2: [3x3 double]\n      b2: [-0.6681 0.3572 0.8118]\n\nWhen net or other proxy objects a passed to mlab functions, they are\nautomatically converted into the corresponding Matlab-objects. So to obtain\na trained network on the 'xor'-problem, one can simply do:\n\n>>> net = mlab.mlptrain(net, [[1,1], [0,0], [1,0], [0,1]], [0,0,1,1], 1000)\n\nAnd test with:\n\n>>> mlab.mlpfwd(net2, [[1,0]])\narray([       [ 1.]])\n>>> mlab.mlpfwd(net2, [[1,1]])\narray([       [  7.53175454e-09]])\n\nAs previously mentioned, normally you shouldn't notice at all when you are\nworking with proxy objects; they can even be pickled (!), although that is\nstill somewhat experimental.\n\nmlabwrap also offers proper error handling and exceptions! So trying to\npass only one input to a net with 2 input nodes raises an Exception:\n\n>>> mlab.mlpfwd(net2, 1)\nTraceback (most recent call last):\n[...]\nmlabraw.error: Error using ==> mlpfwd\nDimension of inputs 1 does not match number of model inputs 2\n\nWarning messages (and messages to stdout) are also displayed:\n\n>>> mlab.log(0)\nWarning: Log of zero.\narray([       [             -inf]])\n\nComparison to other existing modules\n\nTo get a vague impression just how high-level all this, consider attempting to\ndo something similar to the first example with pymat (upon which the\nunderlying mlabraw interface to Matlab is based).\n\nthis:\n\n>>> A, B, C = mlab.svd([[1,2],[1,3]], 0, nout=3)\n\nbecomes this:\n\n>>> session = pymat.open()\n>>> pymat.put(session, \"X\", [[1,2], [1,3]])\n>>> pymat.put(session, \"cheap\", 0)\n>>> pymat.eval(session, '[A, B, C] = svd(X, cheap)')\n>>> A = pymat.get(session, 'A')\n>>> B = pymat.get(session, 'B')\n>>> C = pymat.get(session, 'C')\n\nPlus, there is virtually no error-reporting at all, if something goes wrong in\nthe eval step, you'll only notice because the subsequent get mysteriously\nfails. And of course something more fancy like the netlab example above (which\nuses proxies to represent matlab class instances in python) would be\nimpossible to accomplish in pymat in a similar manner.\n\nHowever should you need low-level access, then that is equally available\n(and with error reporting); basically just replace pymat with\nmlabraw above and use mlab._session as session), i.e\n\n>>> from mlab import mlab\n>>> import mlabraw\n>>> mlabraw.put(mlab._session, \"X\", [[1,2], [1,3]])\n[...]\n\nBefore you resort to this you should ask yourself if it's really a good idea;\nthe inherent overhead associated with Matlab's C interface appears to be quite\nhigh, so the additional python overhead shouldn't normally matter much -- if\nefficiency becomes an issue it's probably better to try to chunk together\nseveral matlab commands in an .m-file in order to reduce the number of\nmatlab calls. If you're looking for a way to execute \"raw\" matlab for specific\npurposes, mlab._do is probably a better idea. The low-level mlabraw\nAPI is much more likely to change in completely backwards incompatible ways in\nfuture versions of mlabwrap. You've been warned.\n\nWhat's Missing?\n\nHandling of as arrays of (array) rank 3 or more as well as\nnon-double/complex arrays (currently everything is converted to\ndouble/complex for passing to Matlab and passing non-double/complex from\nMatlab is not not supported). Both should be reasonably easy to implement,\nbut not that many people have asked for it and I haven't got around to it\nyet.\n\nBetter support for cells.\n\nThread-safety. If you think there's a need please let me know (on the\nStackOverflow tagged query); at the moment you can /probably/ get away with\nusing one seperate MlabWrap object per thread without implementing your own\nlocking, but even that hasn't been tested.\n\nImplementation Notes\n\nSo how does it all work?\n\nI've got a C extension module (a heavily bug-fixed and somewhat modified\nversion of pymat, an open-source, low-level python-matlab interface) to take\ncare of opening Matlab sessions, sending Matlab commands as strings to a\nrunning Matlab session and and converting Numeric arrays (and sequences and\nstrings...) to Matlab matrices and vice versa. On top of this I then built a\npure python module that with various bells and whistles gives the impression\nof providing a Matlab \"module\".\n\nThis is done by a class that manages a single Matlab session (of which mlab\nis an instance) and creates methods with docstrings on-the-fly. Thus, on the\nfirst call of mlab.abs(1), the wrapper looks whether there already is a\nmatching function in the cache. If not, the docstring for abs is looked up\nin Matlab and Matlab's flimsy introspection abilities are used to determine\nthe number of output arguments (0 or more), then a function with the right\ndocstring is dynamically created and assigned to mlab.abs. This function\ntakes care of the conversion of all input parameters and the return values,\nusing proxies where necessary. Proxy are a bit more involved and the proxy\npickling scheme uses Matlab's save command to create a binary version of\nthe proxy's contents which is then pickled, together with the proxy object by\npython itself. Hope that gives a vague idea, for more info study the source.\n\nTroubleshooting\n\nStrange hangs under Matlab R2008a\n\nIt looks like this particular version of matlab might be broken (I was able to\nreproduced the problem with just a stripped down engdemo.c under 64-bit\nlinux). R2008b is reported to be working correctly (as are several earlier\nversions).\n\nmatlab not in path\n\nsetup.py will call matlab in an attempt to query the version and other\ninformation relevant for installation, so it has to be in your PATH\nunless you specify everything by hand in setup.py. Of course to be able\nto use mlabwrap in any way matlab will have to be in your path anyway\n(unless that is you set the environment variable MLABRAW_CMD_STR that\nspecifies how exactly Matlab should be called).\n\n\"Can't open engine\"\n\nIf you see something like mlabraw.error: Unable to start MATLAB(TM) engine\nthen you may be using an incompatible C++ compiler (or version), or if you're\nusing unix you might not have csh installed under /bin/csh, see below.\nTry if you can get the engdemo.c file to work that comes with your Matlab\ninstallation -- engdemo provides detailed instructions, but in a nutshell:\ncopy it to a directory where you have write access and do\n(assuming Matlab is installed in /opt/MatlabR14 and you're running unix,\notherwise modify as requird):\n\nmex -f /opt/MatlabR14/bin/engopts.sh engdemo.c\n./engdemo\n\nif you get Can't start MATLAB engine chances are you're trying to use a\ncompiler version that's not in Mathworks's list of compatible compilers or\nsomething else with your compiler/Matlab installation is broken that needs to\nbe resolved before you can successfully build mlabwrap. Chances are that you\nor you institution pays a lot of money to the Mathworks, so they should be\nhappy to give you some tech support. Here's what some user who recently\n(2007-02-04) got Matlab 7.04's mex support to work under Ubuntu Edgy after an\nexchange with support reported back; apart from installing gcc-3.2.3, he did\nthe following:\n\nThe code I'd run (from within Matlab) is...\n> mex -setup;     # then select: 2 - gcc Mex options\n> optsfile = [matlabroot '/bin/engopts.sh'];\n> mex -v -f optsfile 'engdemo.c';\n> !./engdemo;\n\nUpdate John Bender reports that under unix csh needs to be installed in\n/bin/csh for the matlab external engine to work -- since many linux\ndistros don't install csh by default, you might have to do something like\nsudo apt-get install csh (e.g. under ubuntu or other debian-based\nsystems). He also pointed out this helpful engdemo troubleshooting page at\nthe Mathworks(tm) site.\n\n\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)\n\nAs above, first try to see if you can get engdemo.c to work, because\nas long as even the examples that come with Matlab don't compile,\nchances of mlabwrap compiling are rather slim. On the plus-side\nif the problem isn't mlabwrap specific, The Mathworks and/or\nMatlab-specific support forums should be able to help.\n\nOld Matlab version\n\nIf you get something like this on python setup.py install:\n\nmlabraw.cpp:634: `engGetVariable' undeclared (first use this function)\n\nThen you're presumably using an old version of Matlab (i.e. < 6.5);\nsetup.py ought to have detected this though (try adjusting\nMATLAB_VERSION by hand and write me a bug report).\n\nOS X\n\nJosh Marshall tried it under OS X and sent me the following notes (thanks!).\n\nNotes on running\n\nBefore running python, run:\n\nexport  DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH$:/Applications/MATLAB701/bin/mac/\nexport MLABRAW_CMD_STR=/Applications/MATLAB701/bin/matlab\n\n[Edit: I'm not sure DYLD_LIBRARY_PATH modification is still necessary.]\n\nAs far as graphics commands go, the python interpreter will need to  be run\nfrom within the X11 xterm to be able to display anything to the  screen.\nie, the command for lazy people\n\n>>> from mlabwrap import mlab; mlab.plot([1,2,3],'-o')\n\nwon't work unless python is run from an xterm, and the matlab startup\nstring is\nchanged to:\n\nexport MLABRAW_CMD_STR=\"/Applications/MATLAB701/bin/matlab -nodesktop\"\n\nWindows\n\n<string>:526: (INFO/1) Duplicate implicit target name: \"windows\".\n\nI'm thankfully not using windows myself, but I try to keep mlabwrap working\nunder windows, for which I depend on the feedback from windows users.\n\nSince there are several popular C++ compilers under windows, you might have to\ntell setup.py which one you'd like to use (unless it's VC 7).\n\nGeorge A. Blaha sent me a patch for Borland C++ support; search for \"Borland\nC++\" in setup.py and follow the instructions.\n\nDylan T Walker writes mingw32 will also work fine, but for some reason\n(distuils glitch?) the following invocation is required:\n\n> setup.py build --compiler=mingw32\n> setup.py install --skip-build\n\nFunction Handles and callbacks into python\n\nPeople sometimes try to pass a python function to a matlab function (e.g.\nmlab.fzero(lambda x: x**2-2, 0)) which will result in an error messages\nbecause callbacks into python are not implemented (I'm not even it would even\nbe feasible). Whilst there is no general workaround, in some cases you can\njust create an equivalent matlab function on the fly, e.g. do something like\nthis: mlab.fzero(mlab.eval('@(x) x^2-2', 0)).\n\nDirectly manipulating variables in Matlab space\n\nIn certain (rare!) certain cases it might be necessary to directly access or\nset a global variable in matlab. In these cases you can use mlab._get('SOME_VAR')\nand mlab._set('SOME_VAR', somevalue).\nSupport and Feedback\n\nPost your questions directly on Stack overflow with tags matlab, mlab\nand python\n\n\nCredits\n\nAlejandro Weinstein for patches of 1.1pre\nhttps://github.com/aweinstein/mlabwrap\n\nAlexander Schmolck and Vivek Rathod for mlabwrap:\nhttp://mlabwrap.sourceforge.net/\n\nAndrew Sterian for writing pymat without which this module would never have\nexisted.\n\nMatthew Brett contributed numpy compatibility and nice setup.py improvements\n(which I adapted a bit) to further reduce the need for manual user\nintervention for installation.\n\nI'm only using linux myself -- so I gratefully acknowledge the help of Windows\nand OS X users to get things running smoothly under these OSes as well;\nparticularly those who provided patches to setup.py or mlabraw.cpp (Joris van\nZwieten, George A. Blaha and others).\n\nMatlab is a registered trademark of The Mathworks.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "https://github.com/ewiger/mlab/tarball/master",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ewiger/mlab",
    "keywords": null,
    "license": "MIT",
    "maintainer": null,
    "maintainer_email": null,
    "name": "mlab",
    "package_url": "https://pypi.org/project/mlab/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/mlab/",
    "project_urls": {
      "Download": "https://github.com/ewiger/mlab/tarball/master",
      "Homepage": "https://github.com/ewiger/mlab"
    },
    "release_url": "https://pypi.org/project/mlab/1.1.2/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Mlab is a high-level python to Matlab bridge that lets Matlab look like a normal python library",
    "version": "1.1.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1203073,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b9fb146276a9a7444e1984724948cbfcfd4a846ca10d7630e98a63ed08261701",
        "md5": "597eceab3219b9c4aa339fd57896c599",
        "sha256": "ebfbe5d31925c34ae904da7b3d1a6dd0fadf73c944bd793428ffedc41d989b03"
      },
      "downloads": -1,
      "filename": "mlab-1.1.2.tar.gz",
      "has_sig": false,
      "md5_digest": "597eceab3219b9c4aa339fd57896c599",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 58237,
      "upload_time": "2013-08-18T23:54:25",
      "upload_time_iso_8601": "2013-08-18T23:54:25.965692Z",
      "url": "https://files.pythonhosted.org/packages/b9/fb/146276a9a7444e1984724948cbfcfd4a846ca10d7630e98a63ed08261701/mlab-1.1.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}