{
  "info": {
    "author": "brainelectronics",
    "author_email": "info@brainelectronics.de",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License"
    ],
    "description": "# MicroPython modules\n\n[![Downloads](https://pepy.tech/badge/micropython-brainelectronics-helpers)](https://pepy.tech/project/micropython-brainelectronics-helpers)\n![Release](https://img.shields.io/github/v/release/brainelectronics/micropython-modules?include_prereleases&color=success)\n![MicroPython](https://img.shields.io/badge/micropython-Ok-green.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nCustom brainelectronics MicroPython helpers, modules and wrappers\n\n---------------\n\n## About\n\nThis is a collection of MicroPython modules required for the BE32-01 and other\nbrainelectronics projects.\n\n## Available generators\n\nFor the individual usage of a helper, module or wrapper read the brief\ndescription and usage instructions of each module.\n\n<!-- TOC -->\n - [Generic Helper](#generic-helper)\n - [LED Helper](#led-helper)\n     - [Onboard LED](#onboard-led)\n     - [Neopixel](#neopixel)\n - [Modbus TCP-RTU bridge](#modbus-bridge)\n - [Path Helper](#path-helper)\n - [Time Helper](#time-helper)\n - [WiFi Helper](#wifi-helper)\n\n## Setup\n### Install package with pip\n\nConnect to a network and install this lib on the MicroPython device like this\n\n```python\nimport upip\nupip.install('micropython-brainelectronics-helpers')\n# its dependencies will be installed alongside\n```\n\n### Manually\n\nCopy the module(s) to the MicroPython board and import them as shown below\nusing [Remote MicroPython shell][ref-remote-upy-shell]\n\n```bash\nmkdir /pyboard/lib\nmkdir /pyboard/lib/be_helpers\ncp be_helpers/* /pyboard/lib/be_helpers\n```\n\nInstall required dependencies (requires network connection, see may use the\n[`WifiHelper`][ref-wifi-helper])\n\n```python\nimport upip\nupip.install('micropython-ulogging')\n```\n\n### Generic Helper\n\nGeneric helper class with different usecases and functions.\n\n```python\nfrom be_helpers.generic_helper import GenericHelper\n\n# get a random value between zero and 100 (inclusive)\nGenericHelper.get_random_value(0, 100)\n# >>> 72\n\n# get amount of free disk space in kilobytes\nGenericHelper.df(path='/', unit='kb')\n# >>> '1984.000 kB'\n\n# get dict of free RAM with total, free and percentage used\nGenericHelper.get_free_memory()\n# >>> {'percentage': '99.76%', 'total': 4098240, 'free': 4088400}\n\n# get detailed info (full == True) RAM informations\nGenericHelper.free(full=True)\n# >>> 'Total: 4006.1 kB, Free: 3992.56 kB (99.76%)'\n\n# interpret a string as dictionary\nsome_string = \"{'klaus': 123}\"\nd = GenericHelper.str_to_dict(data=some_string)\ntype(d)\n# >>> <class 'dict'>\n\n# save a dictionary as JSON file\nGenericHelper.save_json(path='/test.json', data=d)\n\n# load a JSON file as dictionary\nread_back_dict = GenericHelper.load_json(path='/test.json')\nread_back_dict\n# >>> {'klaus': 123}\n\nread_back_dict == d\n# >>> True\n\n# save a string to file in non binary mode\nGenericHelper.save_file(path='/test.txt', data=some_string, mode='w')\n\n# load the content of a file in non binary mode\nread_back_str = GenericHelper.load_file(path='/test.txt', mode='r')\nread_back_str\n# >>> \"{'klaus': 123}\"\n\nread_back_str == some_string\n# >>> True\n```\n\n### LED Helper\n\nHandle the onbaord LED on a BE32-01, ESP32 or ESP8266 as well as Neopixel LEDs.\n\n#### Onboard LED\n\nThis example demonstrates how to interact with the onboard LED on the BE32-01\n\n##### Basics\n\nThe onboard LED is availabe on Pin 4 on the BE32-01 board in inverted mode.\n\n```python\nfrom be_helpers.led_helper import Led\n\n# Onboard LED is availabe on Pin 4 on BE32-01 in inverted mode\nled = Led()\nprint('Onboard LED is ON: {}'.format(led.on))\n# Onboard LED is ON: False\n\n# turn onboard LED on\nled.state = True\n\n# alternative way to turn onboard LED on\nled.turn_on()\n\n# turn onboard LED off\nled.state = False\n\n# alternative way to turn onboard LED off\nled.turn_off()\n\n# flash LED for 5 times, with 100ms delay between on and off states\n# this is blocking other actions until flashing operation finished\nled.flash(amount=5, delay_ms=100)\n```\n\n##### Advanced\n\nOther (LED) pins can be used by specifiying them at the beginning\n\n```python\nfrom be_helpers.led_helper import Led\n\n# LED at pin 12 will be active if pin is HIGH\nled = Led(led_pin=12, inverted=False)\nprint('LED is ON: {}'.format(led.on))\n```\n\n```python\nfrom be_helpers.led_helper import Led\n\n# Onboard LED is availabe on Pin 4 on BE32-01\nled = Led()\nprint('LED is ON: {}'.format(led.on))\n\n# let LED blink in a seperate thread with 100ms between on and off\nled.blink(delay_ms=100)\nprint('LED is blinking: {}'.format(led.blinking))\n# LED is blinking: True\n\n# stop the LED blinking\nled.blinking = False\n\n# set different blinking delay\nprint('Current blinking delay: {}ms'.format(led.blink_delay))\n# Current blinking delay: 100ms\nled.blink_delay = 50\n\n# start blinking again (with 50ms delay)\nled.blinking = True\n```\n\n#### Neopixel\n\nThis example demonstrates how to interact with the Neopixel LED on the BE32-01.\n\n##### Basics\n\nThe one Neopixel LED is availabe on Pin 27 on the BE32-01 board.\n\n```python\nfrom be_helpers.led_helper import Neopixel\n\n# Neopixel is by default attached to Pin 27 on BE32-01\npixel = Neopixel()\nprint('Neopixel is active: {}'.format(pixel.active))\n\n# turn Neopixel red with 50/255 intensity\npixel.red(50)\n# pixel.green(50)\n# pixel.blue(50)\n\npixel.active = False\n# turn Neopixel off\n\n# get the current Neopixel color\nprint('Neopixel color (RGB): {}'.format(pixel.color))\n# Neopixel color (RGB): [50, 0, 0]\n\n# get all available neopixel colors\npixel.colors\n# >>> {'red': [30, 0, 0], 'green': [0, 30, 0], ...}\n\n# turn Neopixel yellow\npixel.color = 'yellow'\n\n# get current intensity of Neopixel\nprint('Neopixel intensity: {}/255'.format(pixel.intensity))\n# Neopixel intensity: 30/255\n\n# reduce Neopixel intensity to 10/255\npixel.intensity = 10\n\n# turn Neopixel off, but remember last active color\npixel.clear()\n```\n\n##### Advanced\n\nOther Neopixel pin can be used by specifiying them at the beginning\n\n```python\nfrom be_helpers.led_helper import Neopixel\n\n# Neopixel at pin 37 will be active if pin is HIGH\npixel = Neopixel(neopixel_pin=37, neopixels=3)\nprint('Neopixel is active: {}'.format(pixel.active))\n```\n\n```python\nfrom be_helpers.led_helper import Neopixel\n\n# Neopixel is by default attached to Pin 27 on BE32-01\npixel = Neopixel()\n\n# set custom RGB color\npixel.set(rgb=[10, 20, 30])\n\n# let Neopixel fade the currently set color in a seperate thread with 100ms\n# between intensity changes, 50ms is default and quite smooth\npixel.fade(delay_ms=100)\n\n# stop the Neopixel fading\npixel.fading = False\n\n# set different fading delay\nprint('Current fading delay: {}ms'.format(pixel.fade_delay))\n# Current fading delay: 100ms\npixel.fade_delay = 50\n\n# start fading again (with 50ms delay)\npixel.fading = True\n\n# stop the Neopixel fading\npixel.fading = False\n\n# define a custom color and set the Neopixel to it\npixel.colors = {'DarlingColor': [26, 3, 18]}\npixel.color = 'DarlingColor'\n```\n\n### Modbus Bridge\n\nThis requires [brainelectronics MicroPython Modbus][ref-be-upy-modbus]. Forked\nand extended from [SFERALABS Exo Sense Py][ref-sferalabs-exo-sense].\n\nConnect the board to a network and install the package like this\n\n```python\nimport upip\nupip.install('micropython-modbus')\n```\n\n```python\nimport time\nimport machine\n\nfrom be_helpers.modbus_bridge import ModbusBridge\n\nregister_file = 'registers/modbusRegisters-MyEVSE.json'\nrtu_pins = (25, 26)     # (TX, RX)\ntcp_port = 180          # TCP port for Modbus connection\nrun_time = 60           # run this example for this amount of seconds\n\n# default level is 'warning', may use custom logger to get initial log data\nmb_bridge = ModbusBridge(register_file=register_file)\n\n# define and apply Modbus TCP host settings\nhost_settings = {\n    'type': 'tcp',\n    'unit': tcp_port,\n    'address': -1,\n    'baudrate': -1,\n    'mode': 'master'\n}\nmb_bridge.connection_settings_host = host_settings\n\n# setup Modbus connections to host and client\nmb_bridge.setup_connection(pins=rtu_pins)   # (TX, RX)\n\nprint('Modbus instances:')\nprint('\\t Act as Host: {} on {}'.format(mb_bridge.host, mb_bridge.host_unit))\nprint('\\t Act as Client: {} on {}'.format(mb_bridge.client, mb_bridge.client_unit))\n\n# readout the client registers once manually\n# mb_bridge.read_all_registers()\n\n# start collecting latest RTU client data in thread and TCP data provision\nmb_bridge.collecting_client_data = True\nmb_bridge.provisioning_host_data = True\n\nprint('Run client and host for {} seconds'.format(run_time))\nprint('Collect latest client data every {} seconds'.format(mb_bridge.collection_interval))\nprint('Synchronize Host-Client every {} seconds'.format(mb_bridge.synchronisation_interval))\n\nstart_time = time.time()\nwhile time.time() < (start_time + run_time):\n    try:\n        machine.idle()\n    except KeyboardInterrupt:\n        print('KeyboardInterrupt, stop collection + provisioning after {}'.\n              format(time.time() - start_time))\n        break\n    except Exception as e:\n        print('Exception: {}'.format(e))\n\n# stop collecting latest client data in thread and data provision via TCP\nmb_bridge.collecting_client_data = False\nmb_bridge.provisioning_host_data = False\n\n# wait for 5 more seconds to safely finish the may still running threads\ntime.sleep(5)\n```\n\n### Path Helper\n\nMicroPython does not have an `os.path.exists()` function. This small module\nadds this function.\n\n```python\nfrom be_helpers.path_helper import PathHelper\n\npath = 'registers/modbusRegisters.json'\nresult = PathHelper.exists(path=path)\nprint('File at path \"{}\" does exist: {}'.format(path, result))\n```\n\n### Time Helper\n\n```python\nfrom be_helpers.time_helper import TimeHelper\n\n# set the timezone offset to +2, default is +1\nth = TimeHelper(tz=2)\n\n# sync the RTC with the NTP server (valid network connection required)\nth.sync_time()\n\n# get current timestamp in ISO8601 format\nth.current_timestamp_iso8601\n# >>> '21:23:55 2021-10-04'\n\n# get current hour from RTC\nth.hour\n# >>> 21\n```\n\n### WiFi Helper\n\n```python\nfrom be_helpers.wifi_helper import WifiHelper\n\n# connect to the network 'MyNet' and it's password 'realPassword1'\nresult = WifiHelper.connect(ssid='MyNet', password='realPassword1', timedout=3)\nprint('Connection result is: {}'.format(result))\n\n# create an accesspoint named 'MyAP' with a password 'wpa_wpa2_valid_pw'\nresult = WifiHelper.create_ap(ssid='MyAP', password='wpa_wpa2_valid_pw', channel=10)\nprint('AP creation result is: {}'.format(result))\n\nwh = WifiHelper()\nfound_networks = wh.get_wifi_networks_sorted(scan_if_empty=True)\nprint('Found these networks: {}'.format(found_networks))\n\n# after a scan the networks are available as list of NamedTuple\nstrongest_net = wh.networks[0].ssid\nprint('SSID of strongest network: {}'.format(strongest_net))\n\n# convert dBm (RRSI) to quality index in percent\nquality = WifiHelper.dbm_to_quality(dBm=wh.networks[0].RSSI)\nprint('Quality of strongest network {}: {}%'.format(strongest_net, quality))\n```\n\n## Create a PyPi (micropython) package\n\n### Setup\n\nInstall the required python package with the following command in a virtual\nenvironment to avoid any conflicts with other packages installed on your local\nsystem.\n\n```bash\npython3 -m venv .venv\nsource .venv/bin/activate\n\npip install twine\n```\n\n### Create a distribution\n\nThis module overrides distutils (also compatible with setuptools) `sdist`\ncommand to perform pre- and post-processing as required for MicroPython's\nupip package manager. This script is taken from\n[pfalcon's picoweb][ref-pfalcon-picoweb-sdist-upip] and updated to be PEP8\nconform.\n\n```bash\npython setup.py sdist\n```\n\nA new folder `dist` will be created. The [`sdist_upip`](sdist_upip.py) will be\nused to create everything necessary.\n\n### Upload to PyPi\n\n**Be aware: [pypi.org][ref-pypi] and [test.pypi.org][ref-test-pypi] are different**\n\nYou can **NOT** login to [test.pypi.org][ref-test-pypi] with the\n[pypi.org][ref-pypi] account unless you created the same on the other. See\n[invalid auth help page of **test** pypi][ref-invalid-auth-test-pypi]\n\nAfter testing remove the `--repository testpypi` to no longer upload it to\n[test.pypi.org][ref-test-pypi] but [pypi.org][ref-pypi]. Once created releases\ncan not be overwritten or replaced with the same version.\n\n```bash\ntwine upload dist/micropython-brainelectronics-helpers-*.tar.gz --repository testpypi -u PYPI_USERNAME -p PYPI_PASSWORD\n```\n\n<!-- Links -->\n[ref-remote-upy-shell]: https://github.com/dhylands/rshell\n[ref-wifi-helper]: wifi_helper.py\n[ref-be-upy-modbus]: https://github.com/brainelectronics/micropython-modbus\n[ref-sferalabs-exo-sense]: https://github.com/sfera-labs/exo-sense-py-modbus",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/brainelectronics/micropython-modules",
    "keywords": "micropython,brainelectronics,modules,library",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "micropython-brainelectronics-helpers",
    "package_url": "https://pypi.org/project/micropython-brainelectronics-helpers/",
    "platform": null,
    "project_url": "https://pypi.org/project/micropython-brainelectronics-helpers/",
    "project_urls": {
      "Bug Reports": "https://github.com/brainelectronics/micropython-modules/issues",
      "Homepage": "https://github.com/brainelectronics/micropython-modules",
      "Source": "https://github.com/brainelectronics/micropython-modules"
    },
    "release_url": "https://pypi.org/project/micropython-brainelectronics-helpers/1.2.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "MicroPython brainelectronics helpers library",
    "version": "1.2.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16608484,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6c34822fbff262b7fcbdcac205bea3a0668327a85409bb2f1400ab13bc431ecf",
        "md5": "259941ba8c0fbba26ad0561697b4d33f",
        "sha256": "806618df11b73c5bfe3f2be1d9c76b3703c9eebc660caa1ca28f3c0e439255ff"
      },
      "downloads": -1,
      "filename": "micropython-brainelectronics-helpers-1.2.1.tar.gz",
      "has_sig": false,
      "md5_digest": "259941ba8c0fbba26ad0561697b4d33f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 29841,
      "upload_time": "2022-03-07T10:31:34",
      "upload_time_iso_8601": "2022-03-07T10:31:34.300712Z",
      "url": "https://files.pythonhosted.org/packages/6c/34/822fbff262b7fcbdcac205bea3a0668327a85409bb2f1400ab13bc431ecf/micropython-brainelectronics-helpers-1.2.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}