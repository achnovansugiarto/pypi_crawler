{
  "info": {
    "author": "Robert Singer",
    "author_email": "robertgsinger@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.2",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "# Django REST - FlexFields\n\n[![Package version](https://badge.fury.io/py/drf-flex-fields.svg)](https://pypi.python.org/pypi/drf-flex-fields)\n[![Python versions](https://img.shields.io/pypi/status/drf-flex-fields.svg)](https://img.shields.io/pypi/status/django-lifecycle.svg/)\n\nFlexible, dynamic fields and nested models for Django REST Framework serializers.\n\n# Overview\n\nFlexFields (DRF-FF) for [Django REST Framework](https://django-rest-framework.org) is a package designed to provide a common baseline of functionality for dynamically setting fields and nested models within DRF serializers. This package is designed for simplicity, with minimal magic and entanglement with DRF's foundational classes.\n\nKey benefits:\n\n- Easily set up fields that be expanded to their fully serialized counterparts via query parameters (`users/?expand=organization,friends`)\n- Select a subset of fields by either:\n  - specifying which ones should be included (`users/?fields=id,first_name`)\n  - specifying which ones should be excluded (`users/?omit=id,first_name`)\n- Use dot notation to dynamically modify fields at arbitrary depths (`users/?expand=organization.owner.roles`)\n- Flexible API - options can also be passed directly to a serializer: `UserSerializer(obj, expand=['organization'])`\n\n# Quick Start\n\n```python\nfrom rest_flex_fields import FlexFieldsModelSerializer\n\nclass StateSerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = State\n        fields = ('id', 'name')\n\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ('id', 'name', 'population', 'states')\n        expandable_fields = {\n          'states': (StateSerializer, {'many': True})\n        }\n\nclass PersonSerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Person\n        fields = ('id', 'name', 'country', 'occupation')\n        expandable_fields = {'country': CountrySerializer}\n```\n\n```\nGET /people/142/\n```\n\n```json\n{\n  \"id\": 142,\n  \"name\": \"Jim Halpert\",\n  \"country\": 1\n}\n```\n\n```\nGET /people/142/?expand=country.states\n```\n\n```json\n{\n  \"id\": 142,\n  \"name\": \"Jim Halpert\",\n  \"country\": {\n    \"id\": 1,\n    \"name\": \"United States\",\n    \"states\": [\n      {\n        \"id\": 23,\n        \"name\": \"Ohio\"\n      },\n      {\n        \"id\": 2,\n        \"name\": \"Pennsylvania\"\n      }\n    ]\n  }\n}\n```\n\n# Table of Contents:\n\n- [Django REST - FlexFields](#django-rest---flexfields)\n- [Overview](#overview)\n- [Quick Start](#quick-start)\n- [Table of Contents:](#table-of-contents)\n- [Setup](#setup)\n- [Usage](#usage)\n  - [Dynamic Field Expansion](#dynamic-field-expansion)\n  - [Deferred Fields](#deferred-fields)\n  - [Deep, Nested Expansion](#deep-nested-expansion)\n  - [Field Expansion on \"List\" Views <a id=\"list-views\"></a>](#field-expansion-on-list-views-)\n  - [Expanding a \"Many\" Relationship <a id=\"expanding-many\"></a>](#expanding-a-many-relationship-)\n  - [Dynamically Setting Fields (Sparse Fields) <a id=\"dynamically-setting-fields\"></a>](#dynamically-setting-fields-sparse-fields-)\n  - [Reference serializer as a string (lazy evaluation) <a id=\"lazy-ref\"></a>](#reference-serializer-as-a-string-lazy-evaluation-)\n  - [Increased re-usability of serializers <a id=\"increased-reuse\"></a>](#increased-re-usability-of-serializers-)\n- [Serializer Options](#serializer-options)\n- [Advanced](#advanced)\n  - [Customization](#customization)\n  - [Serializer Introspection](#serializer-introspection)\n  - [Use Wildcards to Match Multiple Fields](#wildcards)\n  - [Combining Sparse Fields and Field Expansion <a id=\"combining-sparse-and-expanded\"></a>](#combining-sparse-fields-and-field-expansion-)\n  - [Utility Functions <a id=\"utils\"></a>](#utility-functions-)\n    - [rest_flex_fields.is_expanded(request, field: str)](#rest_flex_fieldsis_expandedrequest-field-str)\n    - [rest_flex_fields.is_included(request, field: str)](#rest_flex_fieldsis_includedrequest-field-str)\n  - [Query optimization (experimental)](#query-optimization-experimental)\n- [Changelog <a id=\"changelog\"></a>](#changelog-)\n- [Testing](#testing)\n- [License](#license)\n\n# Setup\n\nFirst install:\n\n```\npip install drf-flex-fields\n```\n\nThen have your serializers subclass `FlexFieldsModelSerializer`:\n\n```python\nfrom rest_flex_fields import FlexFieldsModelSerializer\n\nclass StateSerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ('id', 'name')\n\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ('id', 'name', 'population', 'states')\n        expandable_fields = {\n          'states': (StateSerializer, {'many': True})\n        }\n```\n\nAlternatively, you can add the `FlexFieldsSerializerMixin` mixin to a model serializer.\n\n# Usage\n\n## Dynamic Field Expansion\n\nTo define expandable fields, add an `expandable_fields` dictionary to your serializer's `Meta` class. Key the dictionary with the name of the field that you want to dynamically expand, and set its value to either the expanded serializer or a tuple where the first element is the serializer and the second is a dictionary of options that will be used to instantiate the serializer.\n\n```python\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ['name', 'population']\n\n\nclass PersonSerializer(FlexFieldsModelSerializer):\n    country = serializers.PrimaryKeyRelatedField(read_only=True)\n\n    class Meta:\n        model = Person\n        fields = ['id', 'name', 'country', 'occupation']\n\n        expandable_fields = {\n            'country': CountrySerializer\n        }\n```\n\nIf the default serialized response is the following:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": 12,\n  \"occupation\": \"Programmer\"\n}\n```\n\nWhen you do a `GET /person/13322?expand=country`, the response will change to:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"name\": \"United States\",\n    \"population\": 330000000\n  },\n  \"occupation\": \"Programmer\"\n}\n```\n\n## Deferred Fields\n\nAlternatively, you could treat `country` as a \"deferred\" field by not defining it among the default fields. To make a field deferred, only define it within the serializer's `expandable_fields`.\n\n## Deep, Nested Expansion\n\nLet's say you add `StateSerializer` as a serializer nested inside the country serializer above:\n\n```python\nclass StateSerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = State\n        fields = ['name', 'population']\n\n\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ['name', 'population']\n\n        expandable_fields = {\n            'states': (StateSerializer, {'many': True})\n        }\n\nclass PersonSerializer(FlexFieldsModelSerializer):\n    country = serializers.PrimaryKeyRelatedField(read_only=True)\n\n    class Meta:\n        model = Person\n        fields = ['id', 'name', 'country', 'occupation']\n\n        expandable_fields = {\n            'country': CountrySerializer\n        }\n```\n\nYour default serialized response might be the following for `person` and `country`, respectively:\n\n```json\n{\n  \"id\" : 13322,\n  \"name\" : \"John Doe\",\n  \"country\" : 12,\n  \"occupation\" : \"Programmer\",\n}\n\n{\n  \"id\" : 12,\n  \"name\" : \"United States\",\n  \"states\" : \"http://www.api.com/countries/12/states\"\n}\n```\n\nBut if you do a `GET /person/13322?expand=country.states`, it would be:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"occupation\": \"Programmer\",\n  \"country\": {\n    \"id\": 12,\n    \"name\": \"United States\",\n    \"states\": [\n      {\n        \"name\": \"Ohio\",\n        \"population\": 11000000\n      }\n    ]\n  }\n}\n```\n\nPlease be kind to your database, as this could incur many additional queries. Though, you can mitigate this impact through judicious use of `prefetch_related` and `select_related` when defining the queryset for your viewset.\n\n## Field Expansion on \"List\" Views <a id=\"list-views\"></a>\n\nIf you request many objects, expanding fields could lead to many additional database queries. Subclass `FlexFieldsModelViewSet` if you want to prevent expanding fields by default when calling a ViewSet's `list` method. Place those fields that you would like to expand in a `permit_list_expands` property on the ViewSet:\n\n```python\nfrom rest_flex_fields import is_expanded\n\nclass PersonViewSet(FlexFieldsModelViewSet):\n    permit_list_expands = ['employer']\n    serializer_class = PersonSerializer\n\n    def get_queryset(self):\n        queryset = models.Person.objects.all()\n        if is_expanded(self.request, 'employer'):\n            queryset = queryset.select_related('employer')\n        return queryset\n```\n\nNotice how this example is using the `is_expanded` utility method as well as `select_related` and `prefetch_related` to efficiently query the database if the field is expanded.\n\n## Expanding a \"Many\" Relationship <a id=\"expanding-many\"></a>\n\nSet `many` to `True` in the serializer options to make sure \"to many\" fields are expanded correctly.\n\n```python\nclass StateSerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = State\n        fields = ['name', 'population']\n\n\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ['name', 'population']\n\n        expandable_fields = {\n            'states': (StateSerializer, {'many': True})\n        }\n```\n\nA request to `GET /countries?expand=states` will return:\n\n```python\n{\n    \"id\" : 12,\n    \"name\" : \"United States\",\n    \"states\" : [\n      {\n        \"name\" : \"Alabama\",\n        \"population\": 11000000\n      },\n      //... more states ... //\n      {\n        \"name\" : \"Ohio\",\n        \"population\": 11000000\n      }\n    ]\n}\n```\n\n## Dynamically Setting Fields (Sparse Fields) <a id=\"dynamically-setting-fields\"></a>\n\nYou can use either the `fields` or `omit` keywords to declare only the fields you want to include or to specify fields that should be excluded.\n\nConsider this as a default serialized response:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"name\": \"United States\",\n    \"population\": 330000000\n  },\n  \"occupation\": \"Programmer\",\n  \"hobbies\": [\"rock climbing\", \"sipping coffee\"]\n}\n```\n\nTo whittle down the fields via URL parameters, simply add `?fields=id,name,country` to your requests to get back:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"name\": \"United States\",\n    \"population\": 330000000\n  }\n}\n```\n\nOr, for more specificity, you can use dot-notation, `?fields=id,name,country.name`:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"name\": \"United States\"\n  }\n}\n```\n\nOr, if you want to leave out the nested country object, do `?omit=country`:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"occupation\": \"Programmer\",\n  \"hobbies\": [\"rock climbing\", \"sipping coffee\"]\n}\n```\n\n## Reference serializer as a string (lazy evaluation) <a id=\"lazy-ref\"></a>\n\nTo avoid circular import problems, it's possible to lazily evaluate a string reference to you serializer class using this syntax:\n\n```python\nexpandable_fields = {\n    'record_set': ('<module_path_to_serializer_class>.RelatedSerializer', {'many': True})\n}\n```\n\n**Note**:\nPrior to version `0.9.0`, it was assumed your serializer classes would be in a module with the following path:\n`<app_name>.serializers`.\n\nThis import style will still work, but you can also now specify fully-qualified import paths to any locations.\n\n## Increased re-usability of serializers <a id=\"increased-reuse\"></a>\n\nThe `omit` and `fields` options can be passed directly to serializers. Rather than defining a separate, slimmer version of a regular serializer, you can re-use the same serializer and declare which fields you want.\n\n```python\nfrom rest_flex_fields import FlexFieldsModelSerializer\n\nclass CountrySerializer(FlexFieldsModelSerializer):\n    class Meta:\n        model = Country\n        fields = ['id', 'name', 'population', 'capital', 'square_miles']\n\nclass PersonSerializer(FlexFieldsModelSerializer):\n    country = CountrySerializer(fields=['id', 'name'])\n\n    class Meta:\n        model = Person\n        fields = ['id', 'name', 'country']\n\n\nserializer = PersonSerializer(person)\nprint(serializer.data)\n\n>>>{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"id\": 1,\n    \"name\": \"United States\",\n  }\n}\n```\n\n# Serializer Options\n\nDynamic field options can be passed in the following ways:\n\n- from the request's query parameters; separate multiple values with a commma\n- as keyword arguments directly to the serializer class when its constructed\n- from a dictionary placed as the second element in a tuple when defining `expandable_fields`\n\nApproach #1\n\n```\nGET /people?expand=friends.hobbies,employer&omit=age\n```\n\nApproach #2\n\n```python\nserializer = PersonSerializer(\n  person,\n  expand=[\"friends.hobbies\", \"employer\"],\n  omit=\"friends.age\"\n)\n```\n\nApproach #3\n\n```python\n\nclass PersonSerializer(FlexFieldsModelSerializer):\n  // Your field definitions\n\n  class Meta:\n    model = Person\n    fields = [\"age\", \"hobbies\", \"name\"]\n    expandable_fields = {\n      'friends': (\n        'serializer.FriendSerializer',\n        {'many': True, \"expand\": [\"hobbies\"], \"omit\": [\"age\"]}\n      )\n    }\n```\n\n| Option |                                 Description                                  |\n| ------ | :--------------------------------------------------------------------------: |\n| expand | Fields to expand; must be configured in the serializer's `expandable_fields` |\n| fields |         Fields that should be included; all others will be excluded          |\n| omit   |         Fields that should be excluded; all others will be included          |\n\n# Advanced\n\n## Customization\n\nParameter names and wildcard values can be configured within a Django setting, named `REST_FLEX_FIELDS`.\n\n| Option          |                                                                                                                                                                                                                                                                         Description                                                                                                                                                                                                                                                                          | Default         |\n| --------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | --------------- |\n| EXPAND_PARAM    |                                                                                                                                                                                                                                                   The name of the parameter with the fields to be expanded                                                                                                                                                                                                                                                   | `\"expand\"`      |\n| FIELDS_PARAM    |                                                                                                                                                                                                                                      The name of the parameter with the fields to be included (others will be omitted)                                                                                                                                                                                                                                       | `\"fields\"`      |\n| OMIT_PARAM      |                                                                                                                                                                                                                                                   The name of the parameter with the fields to be omitted                                                                                                                                                                                                                                                    | `\"omit\"`        |\n| WILDCARD_VALUES | List of values that stand in for all field names. Can be used with the `fields` and `expand` parameters. <br><br>When used with `expand`, a wildcard value will trigger the expansion of all `expandable_fields` at a given level.<br><br>When used with `fields`, all fields are included at a given level. For example, you could pass `fields=name,state.*` if you have a city resource with a nested state in order to expand only the city's name field and all of the state's fields. <br><br>To disable use of wildcards, set this setting to `None`. | `[\"*\", \"~all\"]` |\n\nFor example, if you want your API to work a bit more like [JSON API](https://jsonapi.org/format/#fetching-includes), you could do:\n\n```python\nREST_FLEX_FIELDS = {\"EXPAND_PARAM\": \"include\"}\n```\n\n## Serializer Introspection\n\nWhen using an instance of `FlexFieldsModelSerializer`, you can examine the property `expanded_fields` to discover which fields, if any, have been dynamically expanded.\n\n## Use of Wildcard to Match All Fields <a id=\"wildcards\"></a>\n\nYou can pass `expand=*` ([or another value of your choosing](#customization)) to automatically expand all fields that are available for expansion at a given level. To refer to nested resources, you can use dot-notation. For example, requesting `expand=menu.sections` for a restaurant resource would expand its nested `menu` resource, as well as that menu's nested `sections` resource.\n\nOr, when requesting sparse fields, you can pass `fields=*` to include only the specified fields at a given level. To refer to nested resources, you can use dot-notation. For example, if you have an `order` resource, you could request all of its fields as well as only two fields on its nested `restaurant` resource with the following: `fields=*,restaurent.name,restaurant.address&expand=restaurant`.\n\n## Combining Sparse Fields and Field Expansion <a id=\"combining-sparse-and-expanded\"></a>\n\nYou may be wondering how things work if you use both the `expand` and `fields` option, and there is overlap. For example, your serialized person model may look like the following by default:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\",\n  \"country\": {\n    \"name\": \"United States\"\n  }\n}\n```\n\nHowever, you make the following request `HTTP GET /person/13322?include=id,name&expand=country`. You will get the following back:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"John Doe\"\n}\n```\n\nThe `fields` parameter takes precedence over `expand`. That is, if a field is not among the set that is explicitly alllowed, it cannot be expanded. If such a conflict occurs, you will not pay for the extra database queries - the expanded field will be silently abandoned.\n\n## Utility Functions <a id=\"utils\"></a>\n\n### rest_flex_fields.is_expanded(request, field: str)\n\nChecks whether a field has been expanded via the request's query parameters.\n\n**Parameters**\n\n- **request**: The request object\n- **field**: The name of the field to check\n\n### rest_flex_fields.is_included(request, field: str)\n\nChecks whether a field has NOT been excluded via either the `omit` parameter or the `fields` parameter.\n\n**Parameters**\n\n- **request**: The request object\n- **field**: The name of the field to check\n\n## Query optimization (experimental)\n\nAn experimental filter backend is available to help you automatically reduce the number of SQL queries and their transfer size. _This feature has not been tested thorougly and any help testing and reporting bugs is greatly appreciated._ You can add FlexFieldFilterBackend to `DEFAULT_FILTER_BACKENDS` in the settings:\n\n```python\n# settings.py\n\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': (\n        'rest_flex_fields.filter_backends.FlexFieldsFilterBackend',\n        # ...\n    ),\n    # ...\n}\n```\n\nIt will automatically call `select_related` and `prefetch_related` on the current QuerySet by determining which fields are needed from many-to-many and foreign key-related models. For sparse fields requests (`?omit=fieldX,fieldY` or `?fields=fieldX,fieldY`), the backend will automatically call `only(*field_names)` using only the fields needed for serialization.\n\n**WARNING:** The optimization currently works only for one nesting level.\n\n# Changelog <a id=\"changelog\"></a>\n\n## 1.0.1 (March 2023)\n\n- Various bug fixes. Thanks @michaelschem, @andruten, and @erielias!\n\n## 1.0.0 (August 2022)\n\n- Improvements to the filter backends for generic foreign key handling and docs generation. Thanks @KrYpTeD974 and @michaelschem!\n\n## 0.9.9 (July 2022)\n\n- Fixes bug in `FlexFieldsFilterBackend`. Thanks @michaelschem!\n- Adds `FlexFieldsDocsFilterBackend` for schema population. Thanks @Rjevski!\n\n## 0.9.8 (April 2022)\n\n- Set expandable fields as the default example for expand query parameters in `coreapi.Field`. Thanks @JasperSui!\n\n## 0.9.7 (January 2022)\n\n- Includes m2m in prefetch_related clause even if they're not expanded. Thanks @pablolmedorado and @ADR-007!\n\n## 0.9.6 (November 2021)\n\n- Make it possible to use wildcard values with sparse fields requests.\n\n## 0.9.5 (October 2021)\n\n- Adds OpenAPI support. Thanks @soroush-tabesh!\n- Updates tests for Django 3.2 and fixes deprecation warning. Thanks @giovannicimolin!\n\n## 0.9.3 (August 2021)\n\n- Fixes bug where custom parameter names were not passed when constructing nested serializers. Thanks @Kandeel4411!\n\n## 0.9.2 (June 2021)\n\n- Ensures `context` dict is passed down to expanded serializers. Thanks @nikeshyad!\n\n## 0.9.1 (June 2021)\n\n- No longer auto removes `source` argument if it's equal to the field name.\n\n## 0.9.0 (April 2021)\n\n- Allows fully qualified import strings for lazy serializer classes.\n\n## 0.8.9 (February 2021)\n\n- Adds OpenAPI support to experimental filter backend. Thanks @LukasBerka!\n\n## 0.8.8 (September 2020)\n\n- Django 3.1.1 fix. Thansks @NiyazNz!\n- Docs typo fix. Thanks @zakjholt!\n\n## 0.8.6 (September 2020)\n\n- Adds `is_included` utility function.\n\n## 0.8.5 (May 2020)\n\n- Adds options to customize parameter names and wildcard values. Closes #10.\n\n## 0.8.1 (May 2020)\n\n- Fixes #44, related to the experimental filter backend. Thanks @jsatt!\n\n## 0.8.0 (April 2020)\n\n- Adds support for `expand`, `omit` and `fields` query parameters for non-GET requests.\n  - The common use case is creating/updating a model instance and returning a serialized response with expanded fields\n  - Thanks @kotepillar for raising the issue (#25) and @Crocmagnon for the idea of delaying field modification to `to_representation()`.\n\n## 0.7.5 (February 2020)\n\n- Simplifies declaration of `expandable_fields`\n  - If using a tuple, the second element - to define the serializer settings - is now optional.\n  - Instead of a tuple, you can now just use the serializer class or a string to lazily reference that class.\n  - Updates documentation.\n\n## 0.7.0 (February 2020)\n\n- Adds support for different ways of passing arrays in query strings. Thanks @sentyaev!\n- Fixes attribute error when map is supplied to split levels utility function. Thanks @hemache!\n\n## 0.6.1 (September 2019)\n\n- Adds experimental support for automatically SQL query optimization via a `FlexFieldsFilterBackend`. Thanks ADR-007!\n- Adds CircleCI config file. Thanks mikeIFTS!\n- Moves declaration of `expandable_fields` to `Meta` class on serialzer for consistency with DRF (will continue to support declaration as class property)\n- Python 2 is no longer supported. If you need Python 2 support, you can continue to use older versions of this package.\n\n## 0.5.0 (April 2019)\n\n- Added support for `omit` keyword for field exclusion. Code clean up and improved test coverage.\n\n## 0.3.4 (May 2018)\n\n- Handle case where `request` is `None` when accessing request object from serializer. Thanks @jsatt!\n\n## 0.3.3 (April 2018)\n\n- Exposes `FlexFieldsSerializerMixin` in addition to `FlexFieldsModelSerializer`. Thanks @jsatt!\n\n# Testing\n\nTests are found in a simplified DRF project in the `/tests` folder. Install the project requirements and do `./manage.py test` to run them.\n\n# License\n\nSee [License](LICENSE.md).\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rsinger86/drf-flex-fields",
    "keywords": "django rest api dynamic fields",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "drf-flex-fields",
    "package_url": "https://pypi.org/project/drf-flex-fields/",
    "platform": null,
    "project_url": "https://pypi.org/project/drf-flex-fields/",
    "project_urls": {
      "Homepage": "https://github.com/rsinger86/drf-flex-fields"
    },
    "release_url": "https://pypi.org/project/drf-flex-fields/1.0.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Flexible, dynamic fields and nested resources for Django REST Framework serializers.",
    "version": "1.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17253348,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fb1f8304469453c8f248fd2e8f9d92063f2c100e56c84dc8649f551639923ebd",
        "md5": "0d1ed82ab88122db840d19efe8c22cd3",
        "sha256": "bee9794dcb507e6baefcbe4490ceb4fc5ca034676966bfcd90a19eeef2f2266b"
      },
      "downloads": -1,
      "filename": "drf-flex-fields-1.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "0d1ed82ab88122db840d19efe8c22cd3",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 28736,
      "upload_time": "2023-03-03T07:03:27",
      "upload_time_iso_8601": "2023-03-03T07:03:27.223142Z",
      "url": "https://files.pythonhosted.org/packages/fb/1f/8304469453c8f248fd2e8f9d92063f2c100e56c84dc8649f551639923ebd/drf-flex-fields-1.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}