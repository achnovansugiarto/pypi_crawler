{
  "info": {
    "author": "Diego Quintero",
    "author_email": "daquinterop@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# DSSATTools package\n## Installation:\nYou can install the library using Python pip.\n```\npip install DSSATTools\n```\n## Documentation\n[https://py-dssattools.readthedocs.io/en/latest/index.html](https://py-dssattools.readthedocs.io/en/latest/index.html)\n## Example Notebooks\nYou'll find example notebooks in this repo:[https://github.com/daquinterop/DSSATTools_notebooks](https://github.com/daquinterop/DSSATTools_notebooks). I'll keep uploading examples as some new feature is introduced.\n## Module contents\n\nDSSAT library is a collection of classes that allows the user to create low-code scripts to run simulations with DSSAT model. The library structure allows to execute DSSAT model based on four input classes: Crop, SoilProfile, WeatherStation and Management.\n\nThe simulation environment is represented by the DSSAT Class. There are three stages for the simulation to be excecuted: 1. Initialize a DSSAT instance; 2. setup the simulation environment by using the DSSAT.setup method; 3. run the simulation using the DSSAT.run method.\n\nDuring the environment setup (DSSAT.setup) a directory is created and all the static files required to run DSSAT are copied in that directory. This directory will be removed when the DSSAT.close method is called. After the environment has been set up, the DSSAT.run method can be called as many times as you want.\n\nAll of the parameters and attributes of the four basic clases have the same name you find in the DSSAT files (Take a look at the .CDE files in [https://github.com/DSSAT/dssat-csm-os/tree/develop/Data](https://github.com/DSSAT/dssat-csm-os/tree/develop/Data)).\n\n**At the moment Only the next crops and models are implemented:**\n| Crop         | Model               |\n|--------------|---------------------|\n| Maize        | CERES               |\n| Millet       | CERES               |\n| Rice         | CERES               |\n| Sugarbeet    | CERES               |\n| Sorghum      | CERES               |\n| Sweetcorn    | CERES               |\n| Alfalfa      | FORAGE-Alfalfa      |\n| Bermudagrass | FORAGE-Bermudagrass |\n| Soybean      | CROPGRO             |\n| Canola       | CROPGRO             |\n| Sunflower    | CROPGRO             |\n| Potato       | SUBSTOR             |\n\nMore crops and models will be added later.\n\nIf you're interested in contributing to this project, don't hesitate in sending me an email (daquinterop@gmail.com). Of course, if you want to contribute then I'll have to create a Developer's guide to the project.\n\nAll the Classes can be imported as:\n```python\nfrom DSSATTools import (\n    Crop, SoilProfile, WeatherData, WeatherStation,\n    Management, DSSAT\n)\n```\nor \n```python\nfrom DSSATTools import *\n```\n## DSSATTools.crop module\n\nBasic crop class. It initializes a crop instances based on the crop name and\ncrop file if provided.\n\nCrop class is the only needed class to initialize a Crop instance. You need\nto specify the crop name (Those can be checked at DSSATTools.crop.CROPS_MODULES\nobject), and you can also specify a .SPE file to initialize the instance. If no\n.SPE file is passed as argument, then default .SPE, .ECO and .CUL are used.\n\nPlease, take into account that if you initialize the instance with a custom\nSpecies file the three files (.SPE, .ECO, .CUL) must be in the same directory \nas the passed Species file.\n\nThe only method implemented is set_parameter, that of course is used to set\nthe value of any crop parameter. Crop class inherits from the BaseCrop class\nof the specified crop. BaseCrop is composed by sections, each of the included\nin the Species file, and one section for Cultivar and Ecotype respectively.\n\nThe usage of the Crop class is explaied by this example. In here we initialize\na Crop instance, modify a parameter and write the cropfile (All of them).\n\n```python\n>>> crop = Crop('maize')\n>>> crop.set_parameter(\n        par_name = 'TBASE',\n        par_value = 30.,\n        row_loc = 'IB0002'\n    )\n>>> crop.write('crop_test')\n```\n\n\n### _class_ DSSATTools.crop.Crop(crop_name: str = 'Maize', spe_file: Optional[str] = None)\nInitializes a crop instance based on the default DSSAT Crop files, or \non a custom crop file provided as a cultivar.\n\n##### Arguments\n```\ncrop: str\n    Crop name, available at the moment:  Maize, Millet, Sugarbeet, Rice, Sorghum, Sweetcorn, Alfalfa and Bermudagrass\n\nspe_file: str\n    Optional. Path to the species file to initialize the instance.\n\n```\n#### set_parameter(par_name: str, par_value, row_loc=0)\nSet the value of one parameter in the Crop class.\n##### Arguments\n```\npar_name: str\n    name of the parameter. Parameter’s names are in the Crop.parameters \n    attribute.\n\npar_value: str, int, float\n    Value of the parameter to set.\n\nrow_loc: int, str\n    id for the element to modify. This applies to parameters defined in \n    cols, such as cultivar or ecotype parameters. For example:\n\n    @ECO#  ECONAME………  TBASE  TOPT ROPT   P20  \n    IB0001 GENERIC MIDWEST1    8.0 34.0  34.0  12.5 \n    IB0002 GENERIC MIDWEST2    8.0 34.0  34.0  12.5\n\n    for this set of parameters (ecotype), the column ECO# is the id to\n    be passed as row_loc argument.\n```\n\n## DSSATTools.management module\n\nManagement class includes all the information related to management. There are\nmultiple arguments to initialize a Management instance, however, the only \nmandatory arguments are cultivar (cultivar id, of course it has to be included\nin the cultivars list of the Crop object you’ll be passing to DSSAT.run) and\nplanting_date. Simulation start is calculated as the day before the planting \ndate, emergence_date is assumed to 5 days after planting, and the initial soil\nwater content is assumed to be 50% of the total available water \n(PWP + 0.5(FC-PWP))\n\nManagement class has one attribute per management section. Up to date not all\nof the sections have been implemented and the next sections are available: \nfields, cultivars, initial conditions, planting details, irrigation, \nfertilizers, harvest details, simulation controls, automatic management. All of\nthe sections have dict object as base, so you can modify the parameters by\njust reassigning the value as you would do it on a dict. Some of the sections\nare defined as tables, so you can modify the values of those tabular sections\nthe same as you would modify a pandas.Dataframe.\n\nIn the next example a Management object is created, and two of its sections\nare modified.\n\n```python\n>>> man = Management(\n        cultivar='IB0001',\n        planting_date=datetime(2020, 1, 1),\n    )\n>>> man.harvest_details['table'].loc[0, ['HDATE', 'HPC']] = \\\n        [datetime(2020, 7, 1).strftime('%y%j'), 100]\n>>> man.simulation_controls['IRRIG'] = 'A'\n```\n\n### _class_ DSSATTools.management.Management(cultivar: str, planting_date: datetime, sim_start: Optional[datetime] = None, emergence_date: Optional[datetime] = None, initial_swc: float = 0.5, irrigation='R', fertilization='R', harvest='M')\nInitializes a management instance.\n\n##### Arguments\n```\ncultivar: str\n    Code of the cultivar. That code must match one of the codes in the\n    Crop instance used when runing the model.\n\nplanting_date: datetime\n    Planting date.\n\nsim_start: datetime\n    Date for start of the simulation. If None, it’ll be calculated as\n    the previous day to the planting date.\n\nemergence_date: datetime\n    Emergence date. If None, I’ll be calculated as 5 days after \n    planting.\n\ninitial_swc: int\n    Fraction of the total available water (FC - PWP) at the start of the \n    simulation. .5(50%) is the default value.\n\nirrigation: str\n    Default ‘R’. Irrigation management option, options available are:\n\n        A        Automatic when required\n        N        Not irrigated\n        F        Fixed amount automatic\n        R        On reported dates\n        D        Days after planting\n        P        As reported through last day, then automatic to re-fill (A)\n        W        As reported through last day, then automatic with fixed amount (F)\n\nharvest: str\n    Default ‘M’. Harvest management options. available options are:\n        A        Automatic      \n        M        At maturity\n        R        On reported date(s)\n        D        Days after planting\n\nfertilization: str\n    Default ‘R’. Fertilization management options. available options are:\n        N        Not fertilized\n        R        On reported dates\n        D        Days after planting\n```\n\n## DSSATTools.run module\n\nThis module hosts the DSSAT class. That class is the simulation environment, so per each\nDscsm instance there’s a directory where all the necesary files to run the model\nare allocated. To run the model there are 3 basic steps:\n\n> \n> 1. Create a new Dscsm instance.\n\n\n> 2. Initialize the environment by running the setup() method.\n\n\n> 3. Run the model by running the run() method.\n\nYou can close the simulation environment by running the close() method.\n\nThe model outputs are storage in the outputs attribute. Up to date the only\nmodel output parsed into outputs is ‘PlantGro’.\n\nIn the next example all the 4 required objects to run the DSSAT model are\ncreated, an a simulation is run.\n\n```python\n>>> # Create random weather data\n>>> df = pd.DataFrame(\n    {\n    'tn': np.random.gamma(10, 1, N),\n    'rad': np.random.gamma(10, 1.5, N),\n    'prec': np.round(np.random.gamma(.4, 10, N), 1),\n    'rh': 100 * np.random.beta(1.5, 1.15, N),\n    },\n    index=DATES,\n)\n>>> df['TMAX'] = df.tn + np.random.gamma(5., .5, N)\n>>> # Create a WeatherData instance\n>>> WTH_DATA = WeatherData(\n    df,\n    variables={\n        'tn': 'TMIN', 'TMAX': 'TMAX',\n        'prec': 'RAIN', 'rad': 'SRAD',\n        'rh': 'RHUM'\n    }\n)\n>>> # Create a WheaterStation instance\n>>> wth = WeatherStation(\n    WTH_DATA, \n    {'ELEV': 33, 'LAT': 0, 'LON': 0, 'INSI': 'dpoes'}\n)\n>>> # Initialize soil, crop and management instances.\n>>> soil = SoilProfile(default_class='SIL')\n>>> crop = Crop('maize')\n>>> man = Management(\n    cultivar='IB0001',\n    planting_date=DATES[10],\n)\n>>> man.harvest_details['table'].loc[0, ['HDATE', 'HPC']] =         [DATES[190].strftime('%y%j'), 100]\n>>> # Initialize Dscsm instance and run.\n>>> dssat = Dscsm()\n>>> dssat.setup(cwd='/tmp/dssattest')\n>>> dssat.run(\n    soil=soil, weather=wth, crop=crop, management=man,\n)\n>>> # Get output\n>>> PlantGro = dssat.outputs['PlantGro']\n>>> dssat.close() # Terminate the simulation environment\n```\n\n\n### _class_ DSSATTools.run.DSSAT()\n\nClass that represents the simulation environment. When initializing and \nseting up the environment, a new folder is created (usually in the tmp \nfolder), and all of the necesary files to run the model are copied into it.\n\n#### close()\nRemoves the simulation environment (tmp folder and files).\n\n\n#### run(soil: SoilProfile, weather: WeatherStation, crop: Crop, management: Management)\nStart the simulation and runs until the end or failure.\n##### Arguments\n```\nsoil: DSSATTools.soil.Soil\n    SoilProfile instance\n\nweather: DSSATTools.weather.WeatherStation\n    WeatherStation instance\n\ncrop: DSSATTools.crop.Crop\n    Crop instance\n\nmanagment: DSSATTools.management.Management\n    Management instance\n```\n\n#### setup(cwd=None)\nSetup a simulation environment.\nCreates a tmp folder to run the simulations and move all the required\nfiles to run the model. Some rguments are optional, if those aren’t provided,\nthen standard files location will be used.\n##### Arguments\n```\ncwd: str\n    Working directory. All the model files would be moved to that directory.\n    If None, then a tmp directory will be created.\n```\n\n## DSSATTools.soil module\n\nsoil module includes the basic soil class SoilProfile. This class contains\nall the soil information necessary to run the DSSAT model. Each of the layers\nof the soil profile is a SoilLayer instance. After a SoilProfile instance\nis created, a new layer can added by calling the SoilProfile.add_layer method\npassing a SoilLayer object as argument. You can also use the \nSoilProfile.drop_layer to drop the layer at the specified depth.\n\nSoilLayer class represents each layer in the soil profile. The layer is \ninitialized by passing the layer base depth and a dict with the parameteters as \nargument. Clay fraction (SLCL) and Silt fraction (SLSI) are the only mandatory\nparameters when creating a layer, the rest of the parameters are estimated.\n\nThere are three basic ways of creating a SoilProfile object:\n\n1. Specify a .SOL file and Soil id. Of course, the soil id must match one \nof the profiles in the .SOL file.\n\n```python\n>>> soilprofile = SoilProfile(\n    file='SOIL.SOL',\n    profile='IBBN910030'\n)\n```\n\n2. Passing a string code of one the available default soils.\n\n```python\n>>> soilprofile = SoilProfile(\n    default_class='SCL', # Silty Clay Loam\n)\n```\n\n3. Pasing a dict with the profile parameters (different from the layer \npars). DSSAT.soil.list_profile_parameters function prints a detailed list \nof the layer parameters. And empty dict can be pased as none of the \nparameters is mandatory.\n\n```python\n>>> soilprofile = SoilProfile(\n    pars={\n        'SALB': 0.25, # Albedo\n        'SLU1': 6, # Stage 1 Evaporation (mm)\n        'SLPF': 0.8 # Soil fertility factor\n    }\n)\n>>> layers = [\n    soil.SoilLayer(20, {'SLCL': 50, 'SLSI': 45}),\n    soil.SoilLayer(50, {'SLCL': 30, 'SLSI': 30}),\n    soil.SoilLayer(100, {'SLCL': 30, 'SLSI': 35}),\n    soil.SoilLayer(180, {'SLCL': 20, 'SLSI': 30})\n]\n>>> for layer in layers: soilprofile.add_layer(layer)\n```\n\nThat layer must be initialized with the texture information (‘SLCL’ and ‘SLSI’ \nparameters), or the hydraulic soil parameters (‘SLLL’, ‘SDUL’, ‘SSAT’, ‘SRGF’, \n‘SSKS’, ‘SBDM’, ‘SLOC’). If a soil hydraulic parameter is not defined, then it’s\nestimated from soil texture using Pedo-transfer Functions. The previous\nparameters are the mandatory ones, but all the available parameters can be \nincludedin the pars dict.\n\nIf you want to save your soil profile in .SOL a file, you can use the \nSoilProfile.write method. The only argument of this method is the filename.\n\nFor both classes any of the parameters can be modified after the initialization\nas each parameter is also an attribute of the instance.\n\n```python\n>>> soilprofile = SoilProfile(\n    pars={\n        'SALB': 0.25, # Albedo\n        'SLU1': 6, # Stage 1 Evaporation (mm)\n        'SLPF': 0.8 # Soil fertility factor\n    }\n>>> # Modify the albedo of the created instance\n>>> soilprofile.SALB = 0.36\n```\n\n\n### _class_ DSSATTools.soil.SoilLayer(base_depth: int, pars: dict)\n\nInitialize a soil layer instance.\n##### Arguments\n```\nbase_depth: int\n    Depth to the bottom of that layer (cm)\n\npars: dict\n    Dict including the parameter values to initialize the instance. Layer\n    parameters include: \n    ‘SLMH’,  ‘SLLL’,  ‘SDUL’,  ‘SSAT’,  ‘SRGF’,  ‘SSKS’,  ‘SBDM’,  ‘SLOC’,\n    ‘SLCL’,  ‘SLSI’,  ‘SLCF’,  ‘SLNI’,  ‘SLHW’,  ‘SLHB’,  ‘SCEC’,  ‘SADC’\n    ‘SLPX’,  ‘SLPT’,  ‘SLPO’, ‘CACO3’,  ‘SLAL’,  ‘SLFE’,  ‘SLMN’,  ‘SLBS’,\n    ‘SLPA’,  ‘SLPB’,  ‘SLKE’,  ‘SLMG’,  ‘SLNA’,  ‘SLSU’,  ‘SLEC’,  ‘SLCA’\n    Only mandatory parameters are ‘SLCL’ and ‘SLSI’. The rest of the basic\n    parameters can be calculated from the texture.\n\n    SCOM is optional, and it can be passed as an string referencing the color,\n    or a tupple with CIELAB coordinates (L, a, b). The string can be one of\n    these:\n\n    > BLK: Black (10YR 2/1)\n    > YBR: Yellowish Brown (7.5YR 5/6)\n    > RBR: Redish Brown (10R 4/8)\n    > DBR: Dark Brown (2.5YR 3/4) \n    > GRE: Grey (10YR 6/1)\n    > YLW: Yellow (10YR 7/8)\n\n```\n\n### _class_ DSSATTools.soil.SoilProfile(file: Optional[str] = None, profile: Optional[str] = None, default_class: Optional[str] = None, pars: dict = {})\n\nSoil Profile class. It can be initialized from an existing file. It also can \nbe initialized from scratch.  If a file is provided, then the soil is \ninitialized as the soil profile with the matching profile id in the file.\n##### Arguments\n```\nfile: str\n    Optional. Path to the soil file.\n\nprofile: str\n    Optional. Must be passed if file argument is passed. It’s the \n    id of the profile within the file.\n\npars: dict\n    Dict with the non-layer soil parameters.\n\ndefault_class: str\n    Optional. It’s a string defining a DSSAT default soil class. If not \n    None, then the SoilClass instance is initialized with the paremeters \n    of the specified default_class.\n    default_class must match any of the next codes:\n    > Sand            |  S \n    > Loamy Sand      |  LS  \n    > Sandy Loam      |  SL \n    > Loam            |  L \n    > Silty Loam      |  SIL \n    > Silt            |  SI \n    > Sandy Clay Loam |  SCL \n    > Clay Loam       |  CL \n    > Silty Clay Loam |  SICL \n    > Sandy Clay      |  SC \n    > Silty Clay      |  SIC \n    > Clay            |  C\n\n```\n\n#### add_layer(layer: SoilLayer)\nAdd a new layer to the Soil.\n##### Arguments\n```\nlayer: DSSATTools.soil.SoilLayer\n    Soil Layer object\n```\n\n#### drop_layer(layer: int)\nDrop the layer at the specified depth\n\n\n#### set_parameter(parameter, value)\nSet the value of a soil parameter.\n##### Arguments\n```\nparameter: str\n    Parameter name. You can use the DSSATTools.soil.list_parameters \n    function\n    to have a list of the parameters and their description.\n\nvalue: int, float, str\n    Value for that parameter\n```\n\n#### write(filename: str = 'SOIL.SOL')\nIt’s called by the DSSATTools.run.Dscsm.run() method to write the file.\n##### Arguments\n```\nfilename: str\n    Path to the file to write\n```\n\n### DSSATTools.soil.list_layer_parameters()\nPrint a list of the soil parameters\n\n\n### DSSATTools.soil.list_profile_parameters()\nPrint a list of the soil parameters\n\n\n## DSSATTools.weather module\n\nThis module includes two basic classes to create a weather station. The \nWeatherStation class is the one that storages all the station info and the \nweather data. The WeatherData class inherits all the methods of a \npandas.DataFrame, and it’s the one that includes the weather data.\n\nIn the next example we’ll create synthetic data and we’ll create a\nWeatherStation object.\n\n```python\n>>> DATES = pd.date_range('2000-01-01', '2010-12-31')\n>>> df = pd.DataFrame(\n        {\n        'tn': np.random.gamma(10, 1, N),\n        'rad': np.random.gamma(10, 1.5, N),\n        'prec': np.round(np.random.gamma(.4, 10, N), 1),\n        'rh': 100 * np.random.beta(1.5, 1.15, N),\n        },\n        index=DATES,\n    )\n>>> df['TMAX'] = df.tn + np.random.gamma(5., .5, N)\n>>> # Create a WeatherData instance\n>>> WTH_DATA = WeatherData(\n        df,\n        variables={\n            'tn': 'TMIN', 'TMAX': 'TMAX',\n            'prec': 'RAIN', 'rad': 'SRAD',\n            'rh': 'RHUM'\n        }\n    )\n>>> Create a WheaterStation instance\n>>> wth = WeatherStation(\n        WTH_DATA, \n        {'ELEV': 33, 'LAT': 0, 'LON': 0, 'INSI': 'dpoes'}\n    )\n>>> wth.data.head() # To check the data first 5 records\n```\n\n\n### _class_ DSSATTools.weather.WeatherData(data: DataFrame, variables: dict = {})\n\nWeatherData class.\nCreates a WeatherData instance. That instance is the one that contains\nthe records for the Weather Station.\n##### Arguments\n```\ndata: pd.Dataframe\n    A DataFrame containg the the weather data.\n\nvariables: dict\n    A dict to map the columns of the dataframe, to the DSSAT Weather \n    variables. Use list_weather_parameters function to have a detailed\n    description of the DSSAT weather variables.\n```\n\n### _class_ DSSATTools.weather.WeatherStation(wthdata: WeatherData, pars: dict, description='Weather Station')\n\nWeatherStation Class.\nInitialize a Weather station instance.\n\n##### Arguments\n```\npars: dict\n    dict with the Weather station parameters. list_station_parameters\n    provides a list with the parameters and their description. Only LAT,\n    LON and ELEV parameters are mandatory.\n\ndescription: str\n    An string with the description of the weather station\n```\n\n### DSSATTools.weather.list_station_parameters()\nPrint a list of the weather station parameters\n\n\n### DSSATTools.weather.list_weather_parameters()\nPrint a list of the weather data parameters\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/daquinterop/Py_DSSATTools",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "DSSATTools",
    "package_url": "https://pypi.org/project/DSSATTools/",
    "platform": null,
    "project_url": "https://pypi.org/project/DSSATTools/",
    "project_urls": {
      "Bug Tracker": "https://github.com/daquinterop/Py_DSSATTools/issues",
      "Documentation": "https://py-dssattools.readthedocs.io/en/latest/",
      "Homepage": "https://github.com/daquinterop/Py_DSSATTools"
    },
    "release_url": "https://pypi.org/project/DSSATTools/2.0.1/",
    "requires_dist": [
      "attrs",
      "certifi",
      "chardet",
      "charset-normalizer",
      "coverage",
      "fortranformat",
      "idna",
      "iniconfig",
      "numpy",
      "packaging",
      "pandas",
      "pluggy",
      "py",
      "pyparsing",
      "pytest",
      "pytest-cov",
      "python-dateutil",
      "python-magic",
      "pytz",
      "requests",
      "rosetta-soil",
      "six",
      "toml",
      "tomli"
    ],
    "requires_python": ">=3.6",
    "summary": "A DSSAT's Python implementation",
    "version": "2.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16458491,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9cef5fe861216d839bff30c89f36ca563d4b4f6789ed469f39bed12155c0b522",
        "md5": "2301f84c6fe34c39b48be0de18a97f8a",
        "sha256": "67d5007b1925d0213d04d999bca457ac4463fe63c67b7c6f7804aa03a53dfd92"
      },
      "downloads": -1,
      "filename": "DSSATTools-2.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2301f84c6fe34c39b48be0de18a97f8a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 6267647,
      "upload_time": "2022-10-30T01:10:50",
      "upload_time_iso_8601": "2022-10-30T01:10:50.500779Z",
      "url": "https://files.pythonhosted.org/packages/9c/ef/5fe861216d839bff30c89f36ca563d4b4f6789ed469f39bed12155c0b522/DSSATTools-2.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ceba7731e012854f98dfeed7c134711d01aa2c1d99811012908ee3f6acb6e1b1",
        "md5": "c311654877c0c183d6a79c94c7c33b44",
        "sha256": "c544fb02f8cfd61e14875a111858dab32f5e9c8cea774fd66ee761936f7e098a"
      },
      "downloads": -1,
      "filename": "DSSATTools-2.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "c311654877c0c183d6a79c94c7c33b44",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 6087252,
      "upload_time": "2022-10-30T01:10:56",
      "upload_time_iso_8601": "2022-10-30T01:10:56.986617Z",
      "url": "https://files.pythonhosted.org/packages/ce/ba/7731e012854f98dfeed7c134711d01aa2c1d99811012908ee3f6acb6e1b1/DSSATTools-2.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}