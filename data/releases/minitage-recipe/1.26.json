{
  "info": {
    "author": "Mathieu Pasquet",
    "author_email": "kiorky@cryptelium.net",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Buildout",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "******************************************************************************\nRecipe for compiling and installing software with or without minitage\n******************************************************************************\n\n.. contents::\n\n=======================\nIntroduction\n=======================\n\nThis is a collection of recipe which can be use inside or outside a minitage environment.\nWhat is interresting in using them in minitage is that you ll have all your system dependencies in\nthe build environment automaticly.\n\nThe egg has those entry point:\n    - *cmmi*: install configure/make/make install softwares\n    - *fetch*: fetch something, somewhere, with git, http, frp, static, hg, svn or bzr.\n    - *egg*: install python eggs / packages 'setuptoolisables'\n    - *printer*: print or dump to a file all versions needed to achieve eggs\n      requirements (versions.cfg made easy)\n    - *scripts*: install scripts from an egg and install egg dependencies if they\n      are not already in the cache\n    - *wsgi*: Make a Python paste configuration file eatable by mod_wsgi with\n      all the eggs dependencies you need.\n\nThe reasons why i have rewrite yet another buildout recipes builder are:\n    - Support for downloading stuff\n    - Do not rely on easy_install dependency system\n    - Support on the fly patchs for eggs and other distribution.\n    - Support multiple hooks at each stage of the build system.\n    - Support for distutils\n    - Robust offline mode\n    - We like pypi, but offer a mode to scan for eggs without need to check\n      the index,\n    - Support malformed or not indexed distributions.\n      In other terms, we provide an url, and the recipe builds it, that's all.\n    - All recipes must support automaticly minitage dependencies and rpath linking.\n\nYou can browse the code on minitage's following resources:\n\n    - http://git.minitage.org/git/minitage/eggs/minitage.recipe/\n    - http://www.minitage.org/trac/browser/minitage/eggs/minitage.recipe\n\nYou can migrate your buldouts without any effort with buildout.minitagificator:\n\n    * http://pypi.python.org/pypi/buildout.minitagificator\n\n\n\n\n====================================\nOptions shared by all the recipes\n====================================\n\nNotes\n--------\n\n    - All recipes inherit all these options, depending which you are using, those options will have an incidence on the build.\n    - Useless to say that the recipes code is not difficult, and as a deployer, its your job to have a look at the code to avoid surprises.\n    - If you are inside a minitage all recipes will look on your minibuild dependencies section to get things into the environment at execution time. Like feeding CFLAGS, pkgconfig, ldflags and so on.\n    - All recipes look for a minitage section in your buildout file and take dependencies and eggs as minitage projects to get into the environnment too::\n\n        ...\n        [minitage]\n        dependencies = postgresql-8.3\n        eggs = py-libxslt-1.1\n\nOptions\n-------------\n    * urls\n      A set of urls to checkout in the form\n\n\n        - The last part or the urls will be the name of your checkout dir unless you have precised the name in \"destination directory name\"\n        - If you don't specify any scm_type, it will be static unless you specify it in options (see scm)\n        - If you don't specify any revision, it will be not set unless you specify it in options (see scm_revision)\n        - The form is a New line separated list of urls to fetcha in the following form (*the | is part of the line ;)*)::\n\n                url to checkout | fetch_type | revision | destination directory name | fetcher_args\n\n      Here are valid inputs ::\n\n            svn://toto | svn | 666 | mydirectoryname | --ignore-externals\n            svn://toto | svn | 666 | mydirectoryname\n            svn://toto | svn | 666\n            svn://toto | svn | | | --ignore-externals\n            svn://toto | svn\n            file://toto\n            http://tata/toto.tgz\n\n      Where::\n\n            fetch_type ::= bzr | hg | git | static (for ftp://, file://, http:// and local files) | svn\n\n    - executable\n        python executable to use\n    - url (backward cmpatibility)\n        url to get the source from, in the previous urls syntax\n    - scm\n        default scm to use (a valid minitage fetch factory to use (static, git, svn, bzr, hg).)\n        defaults to static.\n    - scm_revision\n            default revision to checkout if scm is not static\n    - md5sum\n        md5sum of the checkouted source [see cmmi recipe for documentation]\n    - patch-binary\n        path to the patch program\n    - patch-options\n        options to feed the patch program with [see cmmi recipe for documentation]\n    - patches\n        patches to apply [see cmmi recipe for documentation]\n    - patch\n        A patch to apply, compatibility with zc.recipe.cmmi\n    - location\n        where to put the build result. (default to parts/PART_NAME)\n    - includes\n        CFLAGS to give to the compiler [see cmmi recipe for documentation]\n    - includes-dirs\n        Directories to add to the include paths  [see cmmi recipe for documentation]\n    - library-dirs\n        Directories to add to the linker, and they will be added as -rpath too. [see cmmi recipe for documentation]\n    - environment\n        a part name where we can get key/values to add to the build environment [see cmmi recipe for documentation]\n    - path\n        line separated list of paths to append to $PATH during build\n    - pkgconfigpath\n        line separated list of paths to append to $PKGCONFIGPATH during build [see cmmi recipe for documentation]\n    - pythonpath\n        line separated list of paths to append to $PYTHONPATH during build\n\nOptions incidences\n----------------------\n\n - `minitage.recipe:cmmi`\n    executable is not taken in account.\n - `minitage.recipe:fetch`\n    only the download related options are used.\n - `minitage.recipe:eggs`, `minitage.recipe:wsgi`, `minitage.recipe:scripts`, `minitage.recipe:printer`\n    the configure-*, and make-*, and extra_options are not used\n\nPatches\n-----------\n\n    - They can be either a file or an url.\n    - You have means to specify options to the patch program, like -pXXX, abuses of it.\n\n\n\n===============================================\nminitage.recipe:scripts\n===============================================\n\n\nAbstract\n-----------------\n    - This recipe intends to install eggs and python software and on top of installed stuff, generating scripts and envrionment files.\n    - This recipe inherit from minitage;recipe:egg.\n    - Its heavilly inspired by zc.recipe.eggs* and try to completly replace it whereas be API compatbile.\n    - You can use it in conjunction with the buildout.minitagificator extension which monkey patch zc.buildout to use minitage recipes.\n    - What we can do that zc.recipe.egg wouldnt do, either at all or not in the way we want to:\n\n        * All scripts support initialisation code\n        * The 'scripts' egg metadata is also handled\n    - You can use it as you would use minitage.recipe:egg, use patch facility and etc.\n    - Ths recipe is also declared under those entry points:\n\n        * minitage.recipe:eggs\n        * minitage.recipe:script\n\nSpecific options\n-----------------\n\n    * All the shared options and the options from minitage.recipe:egg +\n    * scripts\n\n        - Scripts to generate, if empty, generate scripts for all the working set.\n        - If your egg have an old 'scripts' metadata, and old scripts where you want wrappers to be generated, just add the egg name to the scripts entry.\n        - If you want to rename a script, just enter something like entrypoint|scriptname=NewName::\n\n            s=NewName\n\n    * zap\n      If you do not want to a script, just enter a line separated list of not wanted scripts\n\n    * entry-points\n        A list of entry-point identifiers of the form:::\n\n            name=module:attrs\n\n        where name is a script name, module is a dotted name resolving to a module name, and attrs is a dotted name resolving to a callable object within a module.\n        This option is useful when working with distributions that don't declare entry points, such as distributions not written to work with setuptools.\n\n    * interpreter\n        The name of a script to generate that allow access to the Python interpreter with the PYTHONPATH set with all the working set entries.\n    * dependent-scripts\n        compatibility option, has no effect\n    * arguments\n        Specify some arguments to be passed to entry points as Python source.\n    * initialization\n        Python code to run prior to call the entry point\n\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file::\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n    >>> index_url = start_server(os.path.sep.join(tempdir))\n\nInitializing test env.\n+++++++++++++++++++++++\n::\n\n    >>> if os.path.exists('foo'): rmdir(dl)\n    >>> mkdir('dl')\n    >>> if os.path.exists('foo'): rmdir(foo)\n    >>> mkdir('foo')\n    >>> mkdir('foo/src/toto')\n    >>> touch('foo/setup.py', data=\"\"\"\n    ... from setuptools import setup, find_packages\n    ... setup(name='foo', version='1.0',\n    ...     packages=find_packages('src'),\n    ...     package_dir = {'': 'src'},\n    ...     include_package_data=True,\n    ...     scripts=['src/toto/toto.py'],\n    ...     entry_points={'console_scripts': ['s=toto.toto:f']},\n    ...     )\n    ... \"\"\")\n    >>> touch('foo/src/toto/__init__.py')\n    >>> touch('foo/src/toto/toto.py', data=\"\"\"\n    ... def f():\n    ...     print \"foo\"\n    ... if __name__ == '__main__' :\n    ...     print 'called'\n    ...\n    ... \"\"\")\n    >>> noecho = [os.remove(d) for d in os.listdir('.') if '.tar.gz' in d]\n    >>> os.chdir('foo')\n    >>> sh('python setup.py sdist')\n    p...\n    >>> noecho = [shutil.copy(os.path.join('dist', d), os.path.join('..', d)) for d in os.listdir('dist')]\n    >>> os.chdir('..')\n\nGenerating all scripts\n+++++++++++++++++++++++++++\nThus by not specifying any scripts entry in the buildout part.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Got foo 1.0.\n    minitage.recipe: Picked: foo = 1.0\n    minitage.recipe: All egg dependencies seem to be installed!\n    minitage.recipe: Generated scripts: 's', 'toto.py'...\n\n\nLook at what have been generated.\n\n    >>> cat('bin', 'toto.py')\n    #!...\n    # ! GENERATED BY minitage.recipe !\n    import os\n    import sys\n    import subprocess...\n    sys.path[0:0] = ['/tmp/buildout.test/eggs/foo-1.0-py....egg' ]...\n    # EXEC ORGINAL CODE WITHOUT SHEBANG\n    __doc__  = 'I am generated by minitage.recipe.script recipe'...\n    os.environ['PYTHONPATH'] = ':'.join(sys.path + os.environ.get('PYTHONPATH', '').split(':'))\n    sys.argv.pop(0)\n    sys.exit(\n        subprocess.Popen(\n            [sys.executable, '/tmp/buildout.test/eggs/foo-1.0-py....egg/EGG-INFO/scripts/toto.py']+sys.argv,\n            env=os.environ\n        ).wait()\n    )...\n    >>> cat('bin', 's')\n    #!...\n    #!!! #GENERATED VIA MINITAGE.recipe !!!...\n    import sys...\n    sys.path[0:0] = [ '/tmp/buildout.test/eggs/foo-1.0-py....egg' ]...\n    import toto.toto...\n    if __name__ == '__main__':\n        toto.toto.f()...\n\n\nSelecting scripts to install\n+++++++++++++++++++++++++++++++\nInstalling only s.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... scripts =\n    ...     s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated scripts: 's'....\n\nInstalling only toto.py.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... scripts =\n    ...     toto.py\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated scripts: 'toto.py'....\n\n.. desactivated because caused more harm than good... too much scripts no filtered\n.. Installing scripts from the foo distribution.\n..\n..     >>> data = \"\"\"\n..     ... [buildout]\n..     ... download-cache=${buildout:directory}/dl\n..     ... parts = part\n..     ... [part]\n..     ... recipe=minitage.recipe:scripts\n..     ... find-links=%(index)s\n..     ... scripts =\n..     ...     foo\n..     ... eggs=foo\n..     ... \"\"\"%{'index': index_url}\n..     >>> touch('buildout.cfg', data=data)\n..     >>> sh('bin/buildout -vvvvv install')\n..     b...\n..     minitage.recipe: Generated scripts: 's', 'toto.py'....\n\nDeclaring entry-points\n+++++++++++++++++++++++\nWe ll add an entry point 't' to be generated.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... entry-points=t=toto.toto:f\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated scripts: 't'....\n\nAdding initialization code\n++++++++++++++++++++++++++++\nWhat about adding environment variables for gis env.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... entry-points=t=toto.toto:f\n    ... eggs=foo\n    ... initialization = import os;os.environ.set('GDAL', 'TRUE')\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n\n    >>> \"import os;os.environ.set('GDAL', 'TRUE')\" in open(os.path.join('bin', 't')).read()\n    True\n\nAdding arguments\n++++++++++++++++++\nWhat about adding arguments to our launchers.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... eggs = foo\n    ... entry-points=t=toto.toto:f\n    ... arguments = ['a', 'b']\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n\n    >>> \"toto.toto.f(['a', 'b'])\" in open(os.path.join('bin', 't')).read()\n    True\n\nGenerating a python interpreter\n++++++++++++++++++++++++++++++++++\nHere is how you can generate a specific python interpreter will all the environement of the working set.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... interpreter = mypy\n    ... arguments = ['a', 'b']\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated scripts: 'mypy'....\n\n    >>> cat('bin', 'mypy')\n    #!...\n    #!!! #GENERATED VIA MINITAGE.recipe !!!...\n    sys.path[0:0] = [ '/tmp/buildout.test/eggs/foo-1.0-py....egg' ]...\n    if _interactive:\n        import code\n        code.interact(banner=\"\", local=globals())...\n\nGenerating an envrionment file\n++++++++++++++++++++++++++++++++++\nHere is how you can generate a specific envrionment file that you can source from to get the PYTHONPATH populated with eggs that you have configured.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}/dl\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:scripts\n    ... find-links=%(index)s\n    ... env-file = mypy\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated scripts: '/tmp/buildout.test/bin/mypy'....\n\n    >>> cat('bin', 'mypy')\n    #!/usr/bin/env sh\n    <BLANKLINE>\n    PYTHONPATH=\"/tmp/buildout.test/eggs/foo-1.0-py....egg:$PYTHONPATH\"\n    export PYTHONPATH\n    <BLANKLINE>\n    <BLANKLINE>\n\n\n\n\n===============================================\nminitage.recipe:egg\n===============================================\n\n\nAbstract\n-----------------\n    - This recipe intends to install eggs and python software\n    - Its heavilly inspired by zc.recipe.eggs* and try to completly replace it whereas be API compatbile.\n    - You can use it in conjunction with the buildout.minitagificator extension which monkey patch zc.buildout to use minitage recipes.\n    - The recipe has a robust offline mode.\n    - What we can do that zc.recipe.egg wouldnt do, either at all or not in the way we want to:\n\n        * Don't rely on easy_install to detect and install dependencies, that can lead to versions inccompatibilities\n        * Handles and preserve eggs extra dependencies\n        * Apply specific patches for eggs based on their name and them generate a specific egg with a specific version, burried in the buildout via the \"versions\".\n        * Make the minitage environnent comes into the environment when building if any, making compilation steps easy if you have declared and build the neccessary dependencies.\n        * Be able to install unindexed at all stuff, just by precising url to install, that can be even an automatic checkout from any repository.\n        * You have hooks to play with the recipe, if it doesnt fit exactly to your need, you can hook for a specific egg at any point of the build.\n        * Check md5 on indexes which append md5 fragments on urls, to verify package integrity\n\n    - If you need scripts generation, just use the minitage.recipe:scripts recipe, it's a specialized recipe of this one. Its use is similar, with just a bunch more options.\n\nSpecific options\n-----------------\n\n    * urls\n\n        See the shared options for more information on how to set them.\n        This is how to specify a distrbituion with is not indexed on pypi and where find-links dance can not work.\n        This is also how to specify to install something from svn::\n\n            urls = http://foo.tld/my_super_egg|svn|666 # checkout and install this egg from svn at revision 666\n    * eggs\n\n        A list of egg requirements to install without the version specs bit.::\n\n            Plone\n            lxml\n\n    * EGGNAME-patch-options\n        patch binary to use for this egg\n    * EGGNAME-patch-binary\n        Options to give to the patch program when applying patches for this egg\n    * EGGNAME-patches\n        Specific patchs for an egg name to apply at install time::\n\n            Django-patches = ${buildout:directory}/foo.patch\n    * EGGNAME-UNAME-patches\n        Same as previous, but will just occurs on this UNAME specifc OS (linux|freebsd|darwin)\n        Specific patchs for an egg name to apply at install time::\n\n            Django-linux-patches = ${buildout:directory}/foo.patch\n\n    * versions\n        Default to buildout:versions. versions part to use to pin the version of the installed eggs.\n        It defaults to buildout's one\n    * index\n        Custom eggs index (not pypi/simple). It defaults to buildout's one\n    * find-links\n        additionnal links vhere we can find eggs. It defaults to buildout's one\n    * extra-paths\n            Extra paths to include in a generated script or at build time.\n    * relative-paths\n        If set to true, then egg paths will be generated relative to the script path.\n        This allows a buildout to be moved without breaking egg paths.\n        This option can be set in either the script section or in the buildout section.\n    * Specifying the python to use, two ways:\n\n        * python\n            The name of a section to get the Python executable from. If not specified, then\n            the buildout python option is used. The Python executable is found in the\n            executable option of the named section. It defaults to buildout's one\n        * executable\n            path to the python executable to use.\n\n    * hooks\n\n      A hook is in the form /path/to/hook:CALLABLE::\n\n            myhook=${buildout:directory}/toto.py:foo\n\n      Where we have toto.py::\n\n            def foo(options, buildout):\n                return 'Hourray'\n\n      The complete possible hooks list:\n\n        * post-download-hook\n            hook executed after each download\n        * post-checkout-hook\n            hook executed after each checkout\n        * EGGNAME-pre-setup-hook\n            hook executed before running the setup.py dance\n        * EGGNAME-post-setup-hook\n            hook executed after running the setup.py dance\n\nPatches\n--------\n\n    * When you use patches for an egg, his version will become ::\n\n        Django-1.0-final -> Django-1.0-final-ZMinitagePatched-$PatchesNamesComputation$\n\n    * This name have some Z* inside to make some precedence on other eggs at the same version. (see setuptools naming scheme)\n    * After that the egg is created, the buildout is backed up and patched to point to this version\n    * Thus, you can have in your common egg cache, this egg for your specific project, and the classical one for others.\n      This can be interessant, for example, for the zope RelStorage patch to apply on ZODB code.\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file::\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n    >>> index_url = start_server(os.path.sep.join(tempdir))\n\nInitializing test env.\n+++++++++++++++++++++++\n::\n\n    >>> if not os.path.exists('foo'):\n    ...     mkdir('foo')\n    ... else:\n    ...     rmdir(foo)\n    ...     mkdir('foo')\n    >>> touch('foo/setup.py', data=\"\"\"\n    ... from setuptools import setup\n    ... setup(name='foo', version='1.0')\n    ...\n    ... \"\"\")\n    >>> touch('foo/toto.py', data=\"\"\"\n    ... def f():\n    ...     print \"foo\"\n    ...\n    ... \"\"\")\n    >>> noecho = [os.remove(d) for d in os.listdir('.') if '.tar.gz' in d]\n    >>> os.chdir('foo')\n    >>> sh('python setup.py sdist')\n    p...\n    >>> touch('setup.py', data=\"\"\"\n    ... from setuptools import setup\n    ... setup(name='foo', version='2.0')\n    ...\n    ... \"\"\")\n    >>> sh('python setup.py sdist')\n    p...\n    >>> noecho = [shutil.copy(os.path.join('dist', d), os.path.join('..', d)) for d in os.listdir('dist')]\n    >>> os.chdir('..')\n    >>> touch('patch', data=\"\"\"\n    ... --- foo.old/setup.py    2009-04-18 13:36:40.199680168 +0200\n    ... +++ foo/setup.py        2009-04-18 13:26:12.307692349 +0200\n    ... @@ -2,3 +2,7 @@\n    ...  from setuptools import setup\n    ...  setup(name='foo', version='2.0')\n    ...\n    ... +\n    ... +\n    ... +print 'patched'\n    ... +\n    ... \"\"\")\n\nInstalling eggs from index or find links, the classical way to install python packages\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nWe need to specify a find-links entry to make the recipe find our 'foo' egg as it is not on pypi\nAs we want to show the update capability of the recipe, we will first install the oldest foo version.\n\n    >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n    >>> data = \"\"\"\n    ... [versions]\n    ... foo=1.0\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:egg\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n    >>> sh('bin/buildout install part')\n    bin/buildout install part...\n    Installing part.\n    minitage.recipe: Installing python egg(s).\n    minitage.recipe: Trying to get  distribution for 'foo'\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading http://...:.../foo-1.0.tar.gz in /tmp/buildout.test/minitage/eggs/foo-1.0.tar.gz\n    minitage.recipe: Unpacking in ...\n    Processing foo-1.0.tar.gz...\n    Location : /tmp/buildout.test/eggs/foo-1.0-py...egg...\n\nInstalling eggs with a patch\n+++++++++++++++++++++++++++++++++++\nPatching is easy, just put your patches in YouEgg-patches.\n\n    >>> data = \"\"\"\n    ... [versions]\n    ... foo=1.0\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:egg\n    ... find-links=%(index)s\n    ... foo-patches = ${buildout:directory}/patch\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout install part')\n    bin/buildout install part...\n    minitage.recipe: Running patch -t -Np0 < /tmp/buildout.test/minitage/eggs/patches/foo/1.0/patch_d96115b00b41e282469f73708c68bdaf/patch\n    can't find file to patch at input line 4\n    Perhaps you used the wrong -p or --strip option?\n    The text leading up to this was:\n    --------------------------\n    |\n    |--- foo.old/setup.py...\n    |+++ foo/setup.py...\n    --------------------------\n    No file to patch.  Skipping patch.\n    1 out of 1 hunk ignored\n    <BLANKLINE>\n    While:\n      Installing part...\n    SystemError: ('Failed', 'patch -t -Np0 < /tmp/buildout.test/minitage/eggs/patches/foo/1.0/patch_d96115b00b41e282469f73708c68bdaf/patch')\n    <BLANKLINE>\n\nOups, the patch level ! .\n\n    >>> data = \"\"\"\\\n    ... [versions]\n    ... foo=1.0\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:egg\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... foo-patches = ${buildout:directory}/patch\n    ... foo-patch-options = -Np1\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install part')\n    b...\n    minitage.recipe: Pinning custom egg version in buildout, trying to write the configuration\n    minitage.recipe: CREATING buildout backup in /tmp/buildout.test/buildout.cfg.before.fixed_version.bak...\n    minitage.recipe: All egg dependencies seem to be installed!...\n\nNow that we have it, try to resintall.\n\n    >>> sh('bin/buildout -vvvvv install part')\n    bin/buildout...\n    minitage.recipe: We have the distribution that satisfies 'foo==1.0-ZMinitagePatched-Patch'.\n    minitage.recipe: Pinning custom egg version in buildout, trying to write the configuration\n    minitage.recipe: Version already pinned, nothing has been wroten...\n\nIn all cases our buildout is patched.\n\n    >>> cat('buildout.cfg')\n    [versions]\n    foo...=...1.0-ZMinitagePatched-Patch...\n\n.. Desactivated, i had bugs in buildout internals with that.\n.. Another interresint thing is that if a part wants an egg wich is requiring a patch\n.. in the minitage's sense, it will try to find a part providing this patch automaticly.\n..\n.. In the following exemple, we ll remark that t will call the 'part' part to build\n.. the foo-1.0_ZMinitagePatched_Patch egg as it was not there before.\n..\n..     >>> data = \"\"\"[versions]\n..     ... foo = 1.0-ZMinitagePatched-Patch\n..     ... [buildout]\n..     ... download-cache=${buildout:directory}\n..     ... parts =\n..     ...     part\n..     ... versions = versions\n..     ... [part]\n..     ... recipe=minitage.recipe:egg\n..     ... find-links=%(index)s\n..     ... eggs=foo\n..     ... foo-patches = ${buildout:directory}/patch\n..     ... foo-patch-options = -Np1\n..     ... [t]\n..     ... recipe=minitage.recipe:egg\n..     ... find-links=%(index)s\n..     ... eggs=foo\n..     ... \"\"\"%{'index': index_url}\n..     >>> touch('buildout.cfg', data=data)\n..     >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n..     >>> sh('bin/buildout -vvvvv install t')\n..     b...\n..     minitage.recipe: Installing python egg(s).\n..     minitage.recipe: We have no distributions for foo that satisfies 'foo==1.0-ZMinitagePatched-Patch'.\n..     minitage.recipe: Althought [t] doesn't provide appropriate patches for foo==1.0-ZMinitagePatched-Patch, we found [part] which provide them, running it!...\n..     Location : /tmp/buildout.test/eggs/foo-1.0_ZMinitagePatched_Patch-py...egg...\n\nOffline and newest modes\n+++++++++++++++++++++++++++\n\nWe have ways to make buildout not download the latest versions found\non indexes and be very conservative on what we akready got local.\n\nRemoving the version bit, but choosing to be non newest will make\nbuildout not to install the new foo-2.0 version.\n\n    >>> data = \"\"\"\\\n    ... [versions]\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... versions = versions\n    ... [t]\n    ... recipe=minitage.recipe:egg\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -Nvvvvv install t')\n    b...\n    minitage.recipe: Installing python egg(s).\n    minitage.recipe: Picked: foo = 1.0-ZMinitagePatched-Patch\n    minitage.recipe: All egg dependencies seem to be installed!...\n\nIdem in offline mode.\n\n    >>> sh('bin/buildout -ovvvvv install t')\n    b...\n    minitage.recipe: Picked: foo = 1.0-ZMinitagePatched-Patch\n    minitage.recipe: All egg dependencies seem to be installed!...\n\nBut then, going online/newest will trigger the installation of the 2.0 egg.\n\n    >>> sh('bin/buildout -nvvvvv install t')\n    b...\n    Location : /tmp/buildout.test/eggs/foo-2.0-py...egg\n    minitage.recipe: Got foo 2.0.\n    minitage.recipe: Picked: foo = 2.0\n    minitage.recipe: All egg dependencies seem to be installed!...\n\nInstalling eggs from an url, the specific way\n++++++++++++++++++++++++++++++++++++++++++++++++\nIt s possible to install an egg from a known url without any indexing system.\n\n    >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:egg\n    ... urls=file://${buildout:directory}/foo-1.0.tar.gz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install part')\n    bin/buildout -vvvvv install part...\n    minitage.recipe: We found a source distribution for 'foo==1.0' in '/tmp/buildout.test/minitage/eggs/foo-1.0.tar.gz'...\n    minitage.recipe: Unpacking in /tmp/...\n    minitage.recipe: Pinning custom egg version in buildout, trying to write the configuration\n    minitage.recipe: CREATING buildout backup in /tmp/buildout.test/buildout.cfg.before.fixed_version.bak...\n\nAs we are installing from an url, we must pin the version to be sure to use this egg,\neven if we have some other similar egg on index or find-links.\n\n    >>> cat('buildout.cfg')\n    <BLANKLINE>\n    [buildout]\n    download-cache=${buildout:directory}\n    parts =\n        part\n    versions = versions\n    [part]\n    recipe=minitage.recipe:egg\n    urls=file://${buildout:directory}/foo-1.0.tar.gz...\n    [versions]\n    foo...=...1.0...\n\nSee that a versions section, and a key in the buildout section have been added.\n\nIf we try to install a newer version, via an url, it will work, even if the version is pinned.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:egg\n    ... urls=file://${buildout:directory}/foo-2.0.tar.gz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install part')\n    b...\n    >>> cat('buildout.cfg')\n    <BLANKLINE>\n    [buildout]\n    download-cache=${buildout:directory}\n    parts =\n        part\n    versions = versions\n    [part]\n    recipe=minitage.recipe:egg\n    urls=file://${buildout:directory}/foo-2.0.tar.gz...\n    [versions]\n    foo = 2.0...\n\nFile urls work in offline mode.\n\n    >>> noecho = [remove(os.path.join('eggs', egg)) for egg in os.listdir('eggs') if 'foo' in egg]\n    >>> [egg for egg in os.listdir('eggs') if 'foo' in egg]\n    []\n    >>> sh('bin/buildout -o install part')\n    b...\n    >>> [egg for egg in os.listdir('eggs') if 'foo' in egg]\n    ['foo-2.0-py...egg']\n\nIf we try to rebuild the egg, we cannot, as the same egg is already built.\nThis is to prevent rebuilding triggered by buildout each time we launch it,\nand also to delete already good versions present in the cache.\n\n    >>> sh('bin/buildout -ovvvvv install part')\n    b...\n    minitage.recipe: If you want to rebuild, please do 'rm -rf /tmp/buildout.test/eggs/foo-2.0-py...egg'...\n\nPypi md5 check support\n+++++++++++++++++++++++++\n\nPypi has the habit to append an md5 fragment to its egg urls,\nwe ll use it to check the already present distribution files in the cache.\n\n    >>> dlcache = os.path.join('minitage', 'eggs')\n    >>> noecho = [(egg, remove(os.path.join(dlcache, egg))) for egg in os.listdir(dlcache) if 'developer' in egg]\n    >>> data = \"\"\"\n    ... [versions]\n    ... mr.developer=0.15\n    ... [buildout]\n    ... versions = versions\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe = minitage.recipe:egg\n    ... eggs=mr.developer\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout install part')\n    b...\n    >>> egg = [egg for egg in os.listdir(dlcache) if 'mr.developer' in egg][0]\n    >>> egg\n    'mr.developer-0.15.zip'\n\nResetting the file contents.\n\n    >>> touch(os.path.join(dlcache, egg), data='')\n\nDeleting the installed egg.\n\n    >>> noecho = [(egg, remove(os.path.join('eggs', egg))) for egg in os.listdir('eggs') if 'developer' in egg]\n\nTrying to reinstall.\n\n    >>> sh('bin/buildout -vvvvv install part')\n    b...\n    minitage.recipe: Searching cache at /tmp/buildout.test/minitage/eggs\n    minitage.recipe: MD5SUM mismatch for /tmp/buildout.test/minitage/eggs/mr.developer-0.15.zip: Good:796babbb65820f6c052141cae1fb3e8d != Bad:d41d8cd98f00b204e9800998ecf8427e\n    Backuping the old file but re download it!\n    A bakcup will be made in /tmp/buildout.test/minitage/eggs/mr.developer-0.15.zip.md5sum_mismatch.0.\n    minitage.recipe: Cache download http://pypi.python.org/packages/source/m/mr.developer/mr.developer-0.15.zip#md5=796babbb65820f6c052141cae1fb3e8d as /tmp/buildout.test/minitage/eggs\n    minitage.recipe: Downloading http://pypi.python.org/packages/source/m/mr.developer/mr.developer-0.15.zip#md5=796babbb65820f6c052141cae1fb3e8d in /tmp/buildout.test/minitage/eggs/mr.developer-0.15.zip...\n\n\nStatic distribution dev+static urls\n++++++++++++++++++++++++++++++++++++++++++++++++++\n\nYou can also install directly from urls.\nwe ll use it to check the already present distribution files in the cache.\n\n    >>> data = \"\"\"\n    ... [versions]\n    ... mr.developer=0.15\n    ... [buildout]\n    ... versions = versions\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe = minitage.recipe:egg\n    ... eggs=mr.developer\n    ... [a]\n    ... recipe=minitage.recipe:egg\n    ... urls=\n    ...     http://pypi.python.org/packages/source/m/minitage.core/minitage.core-1.0.4.tar.gz#md5=1e30ceabd1b012e33b1d2f327f6609b5\n    ...     http://pypi.python.org/packages/source/m/minitage.paste/minitage.paste-1.1.tar.gz#md5=b9076b78a17f2247f68d232368fcc8f0\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvvv install a')\n    b...\n    Installing a...\n    minitage.recipe: Downloading http://pypi.python.org/packages/source/m/minitage.core/minitage.core-1.0.4.tar.gz#md5=1e30ceabd1b012e33b1d2f327f6609b5 in /tmp/buildout.test/minitage/eggs/minitage.core-1.0.4.tar.gz_c3e78ea4294cdd0a243fbea6e2aa9757/minitage.core-1.0.4.tar.gz...\n    minitage.recipe: Downloading http://pypi.python.org/packages/source/m/minitage.paste/minitage.paste-1.1.tar.gz#md5=b9076b78a17f2247f68d232368fcc8f0 in /tmp/buildout.test/minitage/eggs/minitage.paste-1.1.tar.gz_d3403e6128eddb2b99063674ff8105a1/minitage.paste-1.1.tar.gz...\n    Location : ...\n    minitage.recipe: All egg dependencies seem to be installed!...\n\nThe versions are pinned to use your downloaded stuff\n\n    >>> cat('buildout.cfg')\n    <BLANKLINE>\n    [versions]\n    mr.developer=0.15\n    minitage.core = 1.0.4\n    minitage.paste = 1.1\n    [buildout]\n    versions = versions\n    download-cache=${buildout:directory}\n    parts =\n        part\n    [part]\n    recipe = minitage.recipe:egg\n    eggs=mr.developer\n    [a]\n    recipe=minitage.recipe:egg\n    urls=\n        http://pypi.python.org/packages/source/m/minitage.core/minitage.core-1.0.4.tar.gz#md5=1e30ceabd1b012e33b1d2f327f6609b5\n        http://pypi.python.org/packages/source/m/minitage.paste/minitage.paste-1.1.tar.gz#md5=b9076b78a17f2247f68d232368fcc8f0\n\n\n\n===============================================\nminitage.recipe:cmmi\n===============================================\n\nAbstract\n-----------------\n    - UNAME-patches\n        OS specific (sys.platform.lower()) patches to apply  [see cmmi recipe for documentation]\n    - make-targets\n        default to all and install, make targets to run\n    - The cmmi recipe use abusivly or -rpath to save you from settings LD_LIBRARY_PATH at run time.\n    - If you are inside a minitage environment, all the dependencies of your minibuild are put in the environment.\n      That mean that CFLAGS, LDFLAGS, PKG_CONFIG_PATH, and so on are updated to reference your minibuild's dependencies.\n    - minitage.recipe:cmmi is a replacment fo ``zc.recipe.cmmi``.\n    - It intends to do the *configure && make && make install* dance with hooks where you can do (in python) specific stuff at each stage of the build cursus.\n    - With this recipe, if the destination directory exists, we only remove it\n      when we can sucessfully install something, unless that we never touch to it,\n      or it is a bug.\n    - LOOK ALSO AT THE *SHARED VARIABLES* AS ALL THE MINITAGE RECIPES SHARE A LOT OF VARIABLES\n\nSpecific options\n-----------------\n\n* build-dir\n    inner directory to execute the build dance [see cmmi recipe for documentation]\n* configure-options-UNAME\n    Os specific options to give to configure\n    uname can be either linux2|freebsd6|freebsd7|darwin\n    Its the result of sys.platform.lower() [see cmmi recipe for documentation]\n* configure\n    configure script to use (default to ./configure)\n* prefix-separator [see cmmi recipe for documentation]\n    prefix separator to use between --prefix and location (default to =)\n* prefix-options [see cmmi recipe for documentation]\n    what to put for the \"prefix\" expression, default to --prefix$PREFIX_SEPARATOR$LOCATION\n* autogen\n    autogen script to use if any [optionnal]\n* configure-options\n    options to feed configure with [see cmmi recipe for documentation]\n* extra_options\n    appendended to configure-options  [see cmmi recipe for documentation]\n\n* hooks\n\n  A hook is in the form /path/to/hook:CALLABLE::\n\n        myhook=${buildout:directory}/toto.py:foo\n\n  Where we have toto.py::\n\n        def foo(options, buildout):\n            return 'Hourray'\n\n  The complete possible hooks list:\n\n    * pre-unpack-hook\n        hook executed before the unpack dance\n    * post-unpack-hook\n        hook executed after the unpack dance\n    * post-unpack-hook\n        hook executed after the unpack dance\n    * pre-configure-hook\n        hook executed before the configure is run\n    * pre-make-hook\n        hook executed before the first make target is run\n    * post-build-hook\n        hook executed after the build make targets are done\n    * pending-make-install\n        hook executed after the make and before the make install is done\n    * post-make-hook\n        hook executed after the make install is done\n    * noconfigure\n        do not run ./configure\n    * noinstall\n        do not run make install\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file.\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n\nThis first buildout is classical, trying to build some url.\n\n    >>> touch('buildout.cfg',\n    ... data=\"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... \"\"\")\n    >>> sh('bin/buildout install part')\n    bin/buildout install part...\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    A...\n    MinimergeError: URL was not set!\n    <BLANKLINE>\n\nOups, we forgot the url, we will make a basic distribution package to test our stuff\nRunning the buildout with the url bit.\n\n    >>> if not os.path.exists('foo'):\n    ...     mkdir('foo')\n    ... else:\n    ...     rmdir(foo)\n    ...     mkdir('foo')\n    >>> touch('foo/configure', data =\"\"\"echo configure $@\\n\"\"\")\n    >>> sh('chmod +x foo/configure')\n    c...\n    >>> touch('foo/Makefile',\n    ... data = \"\"\"\n    ... all:\n    ... \\t@echo all\n    ...\n    ... install:\n    ... \\t@echo install\n    ...\n    ... \"\"\")\n    >>> sh('tar cfz  foo.tgz foo')\n    tar cfz  ...\n    <BLANKLINE>\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading file:///tmp/buildout.test/foo.tgz in /tmp/buildout.test/minitage/foo.tgz\n    minitage.recipe: Unpacking in /tmp/buildout.test/__minitage__part__tmp.\n    minitage.recipe: Guessing compilation directory\n    minitage.recipe: Setting path\n    minitage.recipe: Setting pkgconfigpath\n    minitage.recipe: Setting compilation flags\n    minitage.recipe: Setting path\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part\n    configure --prefix=/tmp/buildout.test/parts/part\n    minitage.recipe: Running make\n    all\n    minitage.recipe: Running make  install\n    install\n    minitage.recipe: Completed install.\n\nGeneral usage\n++++++++++++++++++++++\nThis first buildout does nothing except print us the hooks calls. We have desactivated the configure and make dance!.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Unpacking in /tmp/buildout.test/__minitage__part__tmp.\n    minitage.recipe: Guessing compilation directory\n    minitage.recipe: Setting path\n    minitage.recipe: Setting pkgconfigpath\n    minitage.recipe: Setting compilation flags\n    minitage.recipe: Setting path\n    minitage.recipe: Completed install...\n\nApplying patches\n++++++++++++++++++++\nThis second one aimes to show us the patch capababilities.\n\n    >>> sh('cp foo/Makefile foo/Makefile.old')\n    cp foo/Makefile foo/Makefile.old\n    >>> sh('echo >> foo/Makefile')\n    echo >> foo/Makefile\n    >>> sh('diff -u foo/Makefile.old foo/Makefile > patch')\n    diff -u foo/Makefile.old foo/Makefile > patch\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... patches = ${buildout:directory}/patch\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running patch -t -Np0 < /tmp/buildout.test/minitage/patch_d96115b00b41e282469f73708c68bdaf/patch\n    can't find file to patch at input line 3\n    Perhaps you used the wrong -p or --strip option?\n    The text leading up to this was:\n    --------------------------\n    |--- foo/Makefile.old ...\n    |+++ foo/Makefile  ...\n    --------------------------\n    No file to patch.  Skipping patch.\n    1 out of 1 hunk ignored\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    An internal error occured due to a bug in either zc.buildout or in a...\n    SystemError: ('Failed', 'patch -t -Np0 < /tmp/buildout.test/minitage/patch_d96115b00b41e282469f73708c68bdaf/patch')\n    <BLANKLINE>\n\n\nThe patch level is wrong !\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... patches = ${buildout:directory}/patch\n    ... patch-options = -p1\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running patch -t -p1 < /tmp/buildout.test/minitage/patch...\n    patching file Makefile\n    minitage.recipe: Completed install...\n\n\nUsing hooks\n++++++++++++++\nBut now that we have some sort of messy packages, can we not intercale some python to code to arrange things upside down ?\nWe have hooks to achieve that. A hook is a python callable which takes at least the options part and the buildout.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... pre-unpack-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n    ... post-unpack-hook   = ${buildout:directory}/hooks.py:post_unpack_hook\n    ... pre-configure-hook = ${buildout:directory}/hooks.py:pre_configure_hook\n    ... pre-make-hook      = ${buildout:directory}/hooks.py:pre_make_hook\n    ... post-build-hook    = ${buildout:directory}/hooks.py:post_build_hook\n    ... post-make-hook     = ${buildout:directory}/hooks.py:post_make_hook\n    ... \"\"\"\n    >>> touch('hooks.py', data=\"\"\"\n    ... def  pre_unpack_hook    (o, b, hook='pre_unpack_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_unpack_hook   (o, b, hook='post_unpack_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  pre_configure_hook (o, b, hook='pre_configure_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  pre_make_hook      (o, b, hook='pre_make_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_build_hook    (o, b, hook='post_build_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_make_hook     (o, b, hook='post_make_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... \"\"\")\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    ... bin/buildout -o install part...\n    bin/buildout -o install part...\n    minitage.recipe: Download archive\n    minitage.recipe: Executing pre-unpack-hook\n    pre_unpack_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part...\n    minitage.recipe: Setting path\n    minitage.recipe: Executing post-unpack-hook\n    post_unpack_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Executing pre-configure-hook\n    pre_configure_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part\n    configure --prefix=/tmp/buildout.test/parts/part\n    minitage.recipe: Executing pre-make-hook\n    pre_make_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running make\n    all\n    minitage.recipe: Executing post-build-hook\n    post_build_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running make  install\n    install\n    minitage.recipe: Executing post-make-hook\n    post_make_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Completed install.\n    <BLANKLINE>\n\n\nMD5 check\n+++++++++++++\nCan we check md5, of course!\nAs we have already the foo package in our download cache, we try to download something else.\n\n    >>> shutil.copy2('foo.tgz', 'bar.tgz')\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... md5sum = b4d\n    ... url = file://${buildout:directory}/bar.tgz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part\n    Uninstalling part.\n    Unused options for buildout: 'download-directory'.\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading file:///tmp/buildout.test/bar.tgz in /tmp/buildout.test/minitage/bar.tgz\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    A...\n    MinimergeError: Failed download for file:///tmp/buildout.test/bar.tgz:      MD5SUM mismatch for /tmp/buildout.test/minitage/bar.tgz: Good:b4d != Bad:...\n    <BLANKLINE>\n\nControlling configure\n++++++++++++++++++++++++++++++\nGiving configure options the two possible ways.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/bar.tgz\n    ... configure-options = foo\n    ... extra_options = bar\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part foo bar\n    configure --prefix=/tmp/buildout.test/parts/part foo bar ...\n\nUse OS Specific rules\n+++++++++++++++++++++++++\nGiving os specific rules.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... configure-options-linux = linuxoptions\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part    linuxoptions...\n\nOr, in the same manner, you can specify OS specific patches: (darwin, linux, freebsd6, freebsd7). sys.platform is your friend :) ('linux', for all linuxes).\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... patch-options = -p1\n    ... url = file://${buildout:directory}/foo.tgz\n    ... \"\"\"\n    >>> data += '%s-patches =${buildout:directory}/patch' % uname\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Running patch -t -p1 < /tmp/buildout.test/minitage/patch...\n\n\nUsing underlying minitage environment\n++++++++++++++++++++++++++++++++++++++++++++\nIf you are in a minitage, all your minibuild dependencies come automaticly in the env, no need to do the following code :)\nAs you can have CFLAGS and so on added to your env., you can specify manual things too, the underlying code is the same.\nThe goal is to proove that all is preprended as we would have think.\nWe will use some hook to print the relevant parts.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n    ... includes-dirs = /foo/include\n    ... rpath = /someruntimespath/lib\n    ... library-dirs = /bar/lib\n    ... pkgconfigpath = /lib/pkgconfig/\n    ... noconfigure = true\n    ... nomake = true\n    ... noinstall = true\n    ... \"\"\"\n    >>> touch('hooks.py', data=\"\"\"\n    ... import os\n    ... def  pre_unpack_hook(o, b):\n    ...     flags = [(a, os.environ.get(a, 'not_set')) for a in ('CFLAGS', 'LDFLAGS', 'PKG_CONFIG_PATH', 'LD_RUN_PATH',)]\n    ...     for flag in flags:\n    ...         print flag\n    ... \"\"\")\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Executing pre-make-hook\n    ('CFLAGS', '-I/foo/include')\n    ('LDFLAGS', '-L/bar/lib -Wl,-rpath -Wl,/bar/lib -L/tmp/buildout.test/parts/part/lib -Wl,-rpath -Wl,/tmp/buildout.test/parts/part/lib')\n    ('PKG_CONFIG_PATH', '/lib/pkgconfig/...')\n    ('LD_RUN_PATH', '/someruntimespath/lib:/tmp/buildout.test/parts/part/lib')...\n\n\nPlaying with the environment\n++++++++++++++++++++++++++++++++\nYou can play also with the environment directly in two ways.\n\n    * Precising a buildout part\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [foo]\n        ... CFLAGS=bar\n        ... [part]\n        ... recipe=minitage.recipe:cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n        ... environment = foo\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n        bi...\n        ('CFLAGS', 'bar')...\n\n    * Entering an option formed by key=value pair\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [part]\n        ... recipe=minitage.recipe:cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... environment=\n        ...     CFLAGS=myvalue\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n         bin/buildout -o install part...\n         minitage.recipe: Executing pre-make-hook\n         ('CFLAGS', 'myvalue')...\n\nAutogen can be your friend\n+++++++++++++++++++++++++++++\nIt is possible to autogenerate the configure files.\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [part]\n        ... recipe=minitage.recipe:cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... autogen = configure\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n        bin/buildout -o install part...\n        minitage.recipe: Auto generating configure files\n        minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure\n        configure...\n\nshared builds\n++++++++++++++++++++\nHandling shared mode as a backward compatibility with zc.recipe.cmmi.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... shared = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/minitage/cmmi/...\n\n\n\n===============================================\nminitage.recipe:fetch\n===============================================\n\n\nAbstract\n-----------------\n    - This recipe can be used to fetch something from somewhere to some location of your local fileystem\n      This something can be either an url or a set of urls.\n    - Thus by:\n\n        * git\n        * svn\n        * ftp, http, file:// (urllib)\n        * bazaar\n        * mercurial\n\nSpecific options\n-----------------\n\n* urls\n  See the shared options for more information on how to set them.\n\nDetailled documentation\n-------------------------\nThe divide url function test::\n\n    - If you dont precise the directory, its the basename of the url::\n\n        >>> divide_url ('http://foo/bar|svn|666||--ignore-externals')\n        ('http://foo/bar', 'svn', '666', 'http.foo.bar', '--ignore-externals')\n\n    - Static as a default::\n\n        >>> divide_url ('')\n        ('', 'static', '', '', '')\n\n    - arguements can be optionnal::\n\n        >>> divide_url ('http://foo/bar')\n        ('http://foo/bar', 'static', '', 'http.foo.bar', '')\n\n\nLet's create a buildout configuration file::\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n\n\nInitializing test env.\n\n    >>> if not os.path.exists('foo'):\n    ...     mkdir('foo')\n    ... else:\n    ...     rmdir(foo)\n    ...     mkdir('foo')\n    >>> touch('foo/configure', data =\"\"\"echo configure $@\\n\"\"\")\n    >>> sh('chmod +x foo/configure')\n    c...\n    >>> touch('foo/Makefile',\n    ... data = \"\"\"\n    ... all:\n    ... \\t@echo all\n    ...\n    ... install:\n    ... \\t@echo install\n    ...\n    ... \"\"\")\n    >>> sh('tar cfz  foo.tgz foo')\n    tar cfz  ...\n    <BLANKLINE>\n\n\nDownloading some urls, files, git checkouts with one in a particular checkout directory and a particular revision::\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe:fetch\n    ... urls =file://${buildout:directory}/foo.tgz\n    ...        http://git.minitage.org/git/minitage/eggs/minitage.core|git\n    ...        http://git.minitage.org/git/minitage/eggs/minitage.recipe|git|e1f30b9d7a89572fa87fe26f8e353304532a281c|minitage.recipe.alt\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout install part')\n    bin/buildout  install part...\n    minitage.recipe: Start checkouts\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading file:///tmp/buildout.test/foo.tgz in /tmp/buildout.test/parts/part/foo.tgz\n    minitage.recipe: Completed dowbload of file:///tmp/buildout.test/foo.tgz in /tmp/buildout.test/parts/part/\n    minitage.recipe: Download archive\n    minitage.recipe: Setting path\n    Initialized empty Git repository in /tmp/buildout.test/parts/part/minitage.recipe.alt/.git/\n    HEAD is now at e1f30b9 0.28\n    minitage.recipe: Completed dowbload of http://git.minitage.org/git/minitage/eggs/minitage.recipe in /tmp/buildout.test/parts/part/minitage.recipe.alt\n    minitage.recipe: Download archive\n    minitage.recipe: Setting path\n    Initialized empty Git repository in /tmp/buildout.test/parts/part/http.git.minitage.org.git.minitage.eggs.minitage.core/.git/\n    HEAD is now at ...\n    minitage.recipe: Completed dowbload of http://git.minitage.org/git/minitage/eggs/minitage.core in /tmp/buildout.test/parts/part/http.git.minitage.org.git.minitage.eggs.minitage.core\n    minitage.recipe: Finnished checkouts...\n    <BLANKLINE>\n    g...\n    <BLANKLINE>\n\n\n\n===============================================\nminitage.recipe:printer\n===============================================\n\n\nAbstract\n-----------------\n    - This recipe intends to install eggs and python software and on top of installed stuff, generating KGS (Known good Set) versions file.\n    - This will help you to pion all the eggs used by a specific application by generating nicely configs will all eggs pinned insude?\n    - This recipe inherit from minitage;recipe:egg.\n\nSpecific options\n-----------------\n\n    * All the shared options and the options from minitage.recipe:egg +\n    * quiet\n        if set: do not print anything to stdout\n    * file\n        file to write the version to\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file::\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n    >>> index_url = start_server(os.path.sep.join(tempdir))\n\nInitializing test env.\n+++++++++++++++++++++++\n::\n\n    >>> if os.path.exists('foo'): rmdir(foo)\n    >>> mkdir('foo')\n    >>> mkdir('foo/src/toto')\n    >>> touch('foo/setup.py', data=\"\"\"\n    ... from setuptools import setup, find_packages\n    ... setup(name='foo', version='1.0',\n    ...     packages=find_packages('src'),\n    ...     package_dir = {'': 'src'},\n    ...     include_package_data=True,\n    ...     scripts=['src/toto/toto.py'],\n    ...     entry_points={'console_scripts': ['s=toto.toto:f']},\n    ...     )\n    ... \"\"\")\n    >>> touch('foo/src/toto/__init__.py')\n    >>> touch('foo/src/toto/toto.py', data=\"\"\"\n    ... def f():\n    ...     print \"foo\"\n    ... if __name__ == '__main__' :\n    ...     print 'called'\n    ...\n    ... \"\"\")\n    >>> noecho = [os.remove(d) for d in os.listdir('.') if '.tar.gz' in d]\n    >>> os.chdir('foo')\n    >>> sh('python setup.py sdist')\n    p...\n    >>> noecho = [shutil.copy(os.path.join('dist', d), os.path.join('..', d)) for d in os.listdir('dist')]\n    >>> os.chdir('..')\n\nWriting only to output\n+++++++++++++++++++++++++++++++\nDo not specify the file option.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:printer\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Maybe put this in a cfg like file ;)\n    #--- 8-< 8-<  8-<  8-<  8-<  8-<  8-<  ---...\n    [versions]\n    foo=1.0...\n    [buildout]\n    versions=versions...\n    #--- 8-< 8-<  8-<  8-<  8-<  8-<  8-<  ---...\n\nWriting to a file\n++++++++++++++++++++++++\nFeed the part with the file option.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:printer\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... file=toto.cfg\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    #--- 8-< 8-<  8-<  8-<  8-<  8-<  8-<  ---\n    minitage.recipe: Generated: toto.cfg...\n\n    >>> cat('toto.cfg')\n    <BLANKLINE>\n    <BLANKLINE>\n    [versions]\n    foo=1.0\n    <BLANKLINE>\n    [buildout]\n    versions=versions\n    <BLANKLINE>\n    <BLANKLINE>\n\nBe quiet please, baby is sleeping\n++++++++++++++++++++++++++++++++++++++\nSet the quiet flag.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:printer\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... quiet=1\n    ... file=toto.cfg\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: All egg dependencies seem to be installed!\n    minitage.recipe: Generated: toto.cfg...\n\n\n\n===============================================\nminitage.recipe:wsgi\n===============================================\n\nAbstract\n-----------------\n\n    - This recipe is inspired by collective.recipe.modwsgi but use\n      minitage code to generate  a wrapper to launch a paste configuration file, suitable for mod_mwsgi.\n    - This recipe inherit from minitage;recipe:egg.\n    - I recommend Spawning to be the WSGI server, but in the wonderful world of system administration, you\n      don't have always the choice of the final technology to use. This will help to to use mod_wsgi with\n      buildout based installations.\n\nSpecific options\n-----------------\n\n    * All the shared options and the options from minitage.recipe:egg +\n    * config-file\n        full path to the paste configuration file to use\n\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file::\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n    >>> index_url = start_server(os.path.sep.join(tempdir))\n\nInitializing test env.\n+++++++++++++++++++++++\n::\n\n    >>> if os.path.exists('foo'): rmdir(foo)\n    >>> mkdir('foo')\n    >>> mkdir('foo/src/toto')\n    >>> touch('foo/setup.py', data=\"\"\"\n    ... from setuptools import setup, find_packages\n    ... setup(name='foo', version='1.0',\n    ...     packages=find_packages('src'),\n    ...     package_dir = {'': 'src'},\n    ...     include_package_data=True,\n    ...     scripts=['src/toto/toto.py'],\n    ...     entry_points={'console_scripts': ['s=toto.toto:f']},\n    ...     )\n    ... \"\"\")\n    >>> touch('foo/src/toto/__init__.py')\n    >>> touch('toto.cfg')\n    >>> touch('foo/src/toto/toto.py', data=\"\"\"\n    ... def f():\n    ...     print \"foo\"\n    ... if __name__ == '__main__' :\n    ...     print 'called'\n    ...\n    ... \"\"\")\n    >>> noecho = [os.remove(d) for d in os.listdir('.') if '.tar.gz' in d]\n    >>> os.chdir('foo')\n    >>> sh('python setup.py sdist')\n    p...\n    >>> noecho = [shutil.copy(os.path.join('dist', d), os.path.join('..', d)) for d in os.listdir('dist')]\n    >>> os.chdir('..')\n\nGenerating a mod_mwsgi friendly configuration\n+++++++++++++++++++++++++++++++++++++++++++++++++++\nDo not specify the file option.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts = part\n    ... [part]\n    ... recipe=minitage.recipe:wsgi\n    ... config-file = toto.cfg\n    ... find-links=%(index)s\n    ... eggs=foo\n    ... \"\"\"%{'index': index_url}\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -vvvvv install')\n    b...\n    minitage.recipe: Generated script: '/tmp/buildout.test/parts/part/wsgi'...\n\n    >>> cat('parts', 'part', 'wsgi')\n    #!...\n    #!!! #GENERATED VIA MINITAGE.recipe !!!...\n    import sys\n    sys.path[0:0] = [ '/tmp/buildout.test/eggs/foo-1.0-py....egg', ]...\n    from paste.deploy import loadapp\n    application = loadapp(\"config:toto.cfg\")...\n\n\n\n===============================================\nminitage.recipe API tests\n===============================================\n\nThe divide url function\n------------------------------\n\n    - If you dont precise the directory, its the basename of the url::\n\n        >>> divide_url ('http://foo/bar|svn|666||--ignore-externals')\n        ('http://foo/bar', 'svn', '666', 'http.foo.bar', '--ignore-externals')\n\n    - Static as a default::\n\n        >>> divide_url ('')\n        ('', 'static', '', '', '')\n\n    - arguements can be optionnal::\n\n        >>> divide_url ('http://foo/bar')\n        ('http://foo/bar', 'static', '', 'http.foo.bar', '')\n\n\n\n=======================\nCHANGELOG\n=======================\n\n-> 1.20\n---------\n\nMinitage.recipe.egg:\n\n    - better errors handling\n    - In particular for eggs and url, now md5 urls are preferred.\n    - Also when we can't download a distribution from somewhere, we try to\n      fallback to other distributions which achieve the desired requirement\n    - In the same way, try to compile eggs from any other sdist fullfilling the\n      requirement if an error occurs on the first found.\n\nMinitage.recipe.cmmi:\n\n    - new patch selection for freebsd:\n        freebsd-patches\n\n    - Fix some double spaces left in compilation flags which broke some exotic\n      system builders.\n\n1.14\n-----\n\n    - add enrionment file generation to the scripts recipe\n\n1.13\n---------\n\n    - cmmi buggy update methods\n\n1.11 - 1.12\n----------------\n\n    - rescan egg direcrectories at install time because there may be new\n      develop eggs or eggs installed by buildout extensions (mr.developer)\n    - fix for interaction with buildout.minitagificator and\n      zc.buildout.easy_install..*script\n\n\n1.-1.10\n---------\n\n    - bugfix with cache and static distributions.\n\n1.8\n-------\n\n    - make patches go in a personnal directory with some md5 mecanism to redownload them.\n\n1.4->1.7\n----------\n\n    - x64 fixes\n    - bugfix in static distribution install when you have patches to apply.\n\n1.3\n----\n\n    - release uncomitted unittests updates\n\n1.2\n-------\n\n    - make it compatible with zc.buildout 1.0\n\n1.1\n-----\n\n    - md5 bug\n\n1.0\n------\n\n    * first stable release.\n    * All recipe are documented and well tested.\n    * buildout.minitagificator is completed.\n    * stabilized and synced with other minitage components\n    * minitage.recipe:eggs has been drasticly improved in term of algorythms and speed.\n\n0.33->0.34\n-----------\n\n    - Fix python executable computation\n\n0.32\n-----\n\n    - Documentation and tests release\n\n0.29\n----\n\n    - Fix bug in recipes initialization because of buildout auto-ordering\n\n\n0.28\n----\n\n    - Add another hook to the cmmi recipe: post-download\n\n0.27\n-----\n\n    - Fix an annoying bug when you are using virtualenv and a classical\n      python as executable in your recipe, it may occur that sometimes, the\n      virtualenv site-packages is appended to PYTHONPATH. As a fix, we now\n      filter all python core lib directories and site packages that are not\n      relevant to the python used by the recipe.\n\n0.26\n-----\n\n    - Introduce the minitage.recipe:wsgi recipe wich wraps a paste wsgi application\n      in a script eatable by mod_wsgi\n\n0.25\n------\n\n    - stop lowering project_name\n\n\n0.23->0.24\n-----------\n\n    - Fix small bugs in printer\n\n0.22\n-----\n\n    - Introduce a new recipe : minitage.recipe:printer which prints/dumps to a\n      file all versions eggs needed to achieve requirements.\n\n0.21\n-----\n\n    - Fix bug in compilation  directory guessing\n\n0.20\n------\n\n    - Fix bug in distribution reloading\n    - Better handling of pkg_resources's working set\n\n0.19\n--------\n\n    - add a post build hook\n\n0.18\n-------\n\n    - Change installation order\n\n0.16\n-------\n\n    - Fix index and find links options\n\n0.14 -> 0.15\n-------------\n    - logging output improved\n    - newest mode handling\n\n0.13\n-----\n- fix static dist install\n\n\n\n0.12\n------\n\n    - bugfix for zipped eggs\n\n0.11\n-----\n\n    - import bugfix for minitagificator\n\n0.10\n-----------\n\n    - Change some logging options\n    - follow allow host option from buildout for eggs installation\n\n0.9\n-----------\n\n    - Do not rely anymore on zc.buildout ez for script generation\n\n0.7 -> 0.8\n-----------\n\n    - egg and scripts recipes were rewritten a lot to adapt their api to\n      zc.recipe.egg\n    - Common to all recipes: all arguements are now identicak to zc.recipe.cmmi\n      or zc.recipe.egg\n    - Dependencies resolver has been improved a lot\n    - For static distribution, you can know speicify multiple urls with 'urls'\n\n\n0.6\n------\n\n    - fix bug in path generation in minitage.recipe:scripts\n\n0.2 -> 0.5\n-------------\n\n    - add make-options for make option in minitage.recipe.cmmi\n    - multiple bugfixes\n    - make things append in subprocess for environment conversation\n    - add initiaiization code for generated python interpreter in\n      minitage.recipe:scripts\n\n0.1\n------\n    - add fetch recipe\n\n0.0.13\n-------\n - fix zip safe flag\n\n0.0.11\n-------\n - Include eggs dependencies by default\n - Modulate the script recipe to append in the PYTHONPATH all egg dependencies\n   found into the local eggs cache.\n\n0.0.10\n-------\n - Add pyc regeneration feature stolen from zc.buildout\n\n0.0.9\n-------\n - minor fix for run without minitage\n - fix for long path/compilation flags\n\n0.0.8\n-------\n - minor fix for scm check outs\n\n0.0.7\n-------\n - add C compiler cflags/ldflags/makeopts customistation options\n\n0.0.6\n-------\n - Change the eggs installation way to do, now using easy_install everywhere\n   Also include a buildout option to allow to include eggs dependencies (ez-dependencies-true)\n - Set the __doc__ variable in scripts to fix some scripts like bzr.\n\n0.0.3\n-------\n - fix scm choice when there are eggs and url in the same part\n\n0.0.2\n------\n - bugfix version\n - fix linking problem\n\n0.0.1\n------\n - Initial version",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://cheeseshop.python.org/pypi/minitage.recipe",
    "keywords": "development buildout recipe",
    "license": "BSD",
    "maintainer": null,
    "maintainer_email": null,
    "name": "minitage.recipe",
    "package_url": "https://pypi.org/project/minitage.recipe/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/minitage.recipe/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "http://cheeseshop.python.org/pypi/minitage.recipe"
    },
    "release_url": "https://pypi.org/project/minitage.recipe/1.26/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "zc.buildout recipes to compile and install software or python packages and generate scripts or configuration files.",
    "version": "1.26",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 794813,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "244445f6926036866c302611cb77f9a619440886c1227195f049667586294b8e",
        "md5": "87827b137ebae296b833c53d2ac24268",
        "sha256": "4593ddc293a6bb8514c4b013e0c8dc078b6138c9424c8f8051e9d5598235a335"
      },
      "downloads": -1,
      "filename": "minitage.recipe-1.26.tar.gz",
      "has_sig": false,
      "md5_digest": "87827b137ebae296b833c53d2ac24268",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 87647,
      "upload_time": "2009-07-28T12:05:04",
      "upload_time_iso_8601": "2009-07-28T12:05:04.546343Z",
      "url": "https://files.pythonhosted.org/packages/24/44/45f6926036866c302611cb77f9a619440886c1227195f049667586294b8e/minitage.recipe-1.26.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}