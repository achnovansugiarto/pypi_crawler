{
  "info": {
    "author": "Vivien WALTER",
    "author_email": "walter.vivien@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# MicroIMAGE\n\n___\n\n## General\n\n### Description\n\n- **Version:** 2.3.1\n- **Author:** Vivien WALTER\n- **Contact:** walter.vivien@gmail.com\n\n**MicroIMAGE** is a Python 3.x module used to load all common types of images used in microscopy, edit and save them in any desired format.\n\n### Compatibility\n\nThe module can currently open the following type(s) of image:\n- .TIFF images and stacks\n- .GIF images and animations\n- .PNG, .BMP and .JPG standard images\n- Directories of multiple frames\n\nIt can also save image(s) in the following formats:\n- .TIFF images and stacks\n- .GIF images and animations (8-bits only)\n- .PNG, .BMP and .JPG standard images\n- .MP4 video\n\n---\n\n## Table of contents\n\n1. [Installation](#installation)\n  * [Requirements](#requirements)\n  * [Installation using the setup.py script](#script)\n2. [How-to use the module](#howto)\n  * [Basic Input/Output functions](#io)\n    * [Opening an image](#open)\n    * [Saving an image on the computer](#save)\n    * [Video generation](#video)\n  * [Image correction and modification](#correction)\n    * [Background correction](#background)\n    * [Contrast correction](#contrast)\n    * [Displaying the pixel value distribution](#distribution)\n    * [Crop the image](#crop)\n    * [Generate a montage](#montage)\n  * [Writing labels on images](#label)\n    * [Scale bar](#scale)\n    * [Time stamps](#time)\n3. [Using the ImageStack class](#class)\n  * [Loading the image in the class](#load_class)\n  * [Navigate in the frames and display them](#frame_class)\n  * [Duplicate and modify the image](#edit_class)\n  * [Apply a correction on the image](#correct_class)\n  * [Modify the space and time scale of the image](#scale_class)\n  * [Save the image(s) in a file](#save_class)\n\n---\n\n## Installation <a name=\"installation\"></a>\n\n### Requirements <a name=\"requirements\"></a>\n\nThe following modules are required to run MicroImage:\n\n- Bottleneck\n- ffmpeg-python\n- Matplotlib\n- NumPy\n- pims\n- Pillows\n- Scikit-image\n\nIf you install the module using the setup.py script, you do NOT need to install first the module above.\n\nIn order to generate video, it is required to have **FFMPEG** installed on the computer. Instructions on how to install FFMPEG can be found on [Internet](https://github.com/adaptlearning/adapt_authoring/wiki/Installing-FFmpeg) (e.g. [MacOS](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg/wiki/Installing-ffmpeg-on-Mac-OS-X))\n\n### Installation using PyPi\n\nTo install microImage using a terminal and PyPi, simply use the following command\n\n```sh\npip install microImage\n```\n\n### Installation using the setup.py script <a name=\"script\"></a>\n\n1. Download the module folder on the github repo\n\n- Installation in a **Terminal-based** environment\n\n  2. Open a terminal in the module folder\n  3. (Opt.) Start your virtualenv if you use one\n  4. Type and run the command\n    ```sh\n  > python3 setup.py install\n  ```\n\n- Installation in an **Anaconda** environment\n\n  2. Open Anaconda and go to your Environments\n  3. Select the environment you want to install the module into\n  4. Click on the arrow next to the name of the environment and select Open a Terminal\n  5. Navigate to the module folder\n  6. Type and run the command\n    ```bash\n  python setup.py install\n  ```\n\n---\n\n## How-to use the module <a name=\"howto\"></a>\n\nThe **examples/** folder provides a .py script as well as a Jupyter notebook to load and display an image using MicroImage.\n\n### Basic Input/Output functions <a name=\"io\"></a>\n\n#### Opening an image <a name=\"open\"></a>\n\nTo load an image, simply use the *openImage()* function:\n\n```python\nfrom microImage import openImage\n\nimageArray = openImage('./path/to/folder/or/image.image_extension')\n```\n\nThe *imageArray* output is a NumPy array of shape **(frames, Y pixel, X pixel)**.\nTo open a folder containing multiple frames, just type the path to the folder.\n\n#### Saving an image on the computer <a name=\"save\"></a>\n\nTo save an array as an image, you can use the *saveImage()* function:\n\n```python\nfrom microImage import saveImage\n\nsaveImage(imageArray, './path/to/new/file.tif', bit_depth=16, rescale=True)\n```\n\nThe function will automatically detect if you are trying to save a single frame or a stack/animation.\n\nYou can specify the bit depth of the output image (8 or 16 bits, 8 bits only for gif animations) using the *bit_depth* argument. The function will always try to cover the full bit depth with the given pixel values; this can be prevented with the argument *rescale=False*.\n\nIf an extension is not specified, in the path of the file to create, the default extension .tif will be used. This can be changed by using the argument *default* to specify another default format (e.g *default='.png'*)\n\n#### Video generation <a name=\"video\"></a>\n\nIt is also possible to save the array as a .mp4 video using the *saveVideo()* function:\n\n```python\nfrom microImage import saveVideo\n\nsaveVideo(imageArray, './path/to/new/file.mp4', fps=25)\n```\n\nHaving **ffmpeg** installed on the computer is required to use this function.\n\nAll arrays will be converted to 8-bits prior to be saved. The framerate of the video can be selected using the `fps=` argument.\n\nIt is possible to select a specific video codec for the output video using the `video_codec=` argument. The default video codec is *libx264*.\n\n### Image correction and modification <a name=\"correction\"></a>\n\n#### Background correction <a name=\"background\"></a>\n\nAssuming the input array is a stack of image (> 1 frame), microImage can be used to remove the static background of the stack using the function *backgroundCorrection()*\n\n```python\nfrom microImage import backgroundCorrection\n\ncorrectedArray = backgroundCorrection(imageArray, signed_bits=True, average='median', correction='division')\n```\n\nIf the images come from a signed bit array, it should be specified using the argument *signed_bits*.\n\nThe type of *average* used can be selected between mean or median, and the type of *correction* has to be picked between division and subtraction, using their respective arguments.\n\n#### Contrast correction <a name=\"contrast\"></a>\n\nThe contrast of the image contained in the array can be modified with the function *contrastCorrection()*\n\n```python\nfrom microImage import contrastCorrection\n\ncorrectedArray = contrastCorrection(imageArray, min=None, max=None, percentile=10, percentile_min=None, rescale=True)\n```\n\nThe user can specify either the *min* and *max* pixel value, or can ask the function to calculate it based on percentiles. The min value is calculated based on *percentile_min* and the max based on *percentile* (from 100%, so 10 corresponds to 90%). If percentile_min is not given, the value of percentile will be used.\n\nThe output can be rescaled to the full bit depth with *rescale=True*. If left False, the scale will be based on the old min and max pixel values.\n\n#### Displaying the pixel value distribution <a name=\"distribution\"></a>\n\nIt is possible to display the pixel value distribution of the image array, along with the position of the min and max values calculated by the *contrastCorrection()* function. This can be done with the *showPVD()* function.\n\n```python\nfrom microImage import showPVD\n\nshowPVD(imageArray, n_bins=10000, min=None, max=None, percentile=10, percentile_min=None, log_scale=None)\n```\n\nThe function will display the pixel value distribution as an histogram. The number of bins can be controlled by the `n_bins=` argument (default is 1000). The scale of the histogram can be switched to log using the `log_scale=` argument. If left to None, both axes will be shown as normal scales. \"x\" will use log scale for the X-axis, \"y\" for the Y-axis, and \"xy\" (or \"yx\") will use log scale for both axis.\n\nAll other arguments are similar to the one of the function *contrastCorrection()*, besides the `rescale=` which cannot be used here.\n\n#### Crop the image <a name=\"crop\"></a>\n\nThe image can be cropped using the *cropImage()* function\n\n```python\nfrom microImage import cropImage\n\ncroppedArray = cropImage(imageArray, top_left=(200,200), bottom_right=(800,800))\n```\n\nEach limit should be given as (X,Y) coordinates. If left to default, *top_left* will be equal to (0,0) and *bottom_right* to (Xmax, Ymax).\n\n#### Generate a montage <a name=\"montage\"></a>\n\nA stack of images can be turned into a montage of individual frames in a single image. This is done by the function *makeMontage()*\n\n```python\nfrom microImage import makeMontage\n\nmontageArray = makeMontage(imageArray, frames=5, column=None, row=None, margin=20, white_margin=False)\n```\n\nThe arguments `frames=` define the frames that has to be added in the montage. If an integer is given, the function will save every N frames of the stack. If a list is given, the list will be used as list of incides of the frame to save.\n\nThe general shape of the montage can be selected using the arguments `column=` and `row=`, respectively the number of columns and rows making the montage table. If any or both of these arguments are set to None, the function will automatically calculate what is required.\n\nThe arguments `margin=` allows for drawing margin between each pictures in the montage. If different from 0, it will be used as the thickness in pixels. The color of the margin is selected via the argument `white_margin=`.\n\n### Writing labels on images <a name=\"label\"></a>\n\nThe module microImage includes some simple tool to quicky write labels on the images\n\n#### Scale bar <a name=\"scale\"></a>\n\nIt is possible to add automatically a simple scale bar on the image using the *addBar()* function\n\n```python\nfrom microImage import addBar\n\nmodifiedArray = addBar(imageArray, scale_length=5, thickness=50, padding=20, white_bar=True, space_unit='µm', space_scale=46.21, add_text=True)\n```\n\nThe scale and space units can be specified using the arguments `space_scale=` and `space_unit=` respectively. If None are given, the function will assume a scale in pixel. The length of the bar (in the given space scale and unit) can be selected using `scale_length=`. The `thickness` and the `padding` surrouding the bar car be selected with their eponymous arguments. User can select between white and black bars using the `white_bar=` boolean argument.\n\nIt is possible to add text on top of the bar with the `add_text=` boolean argument. User can select the `font=` .ttf file to use (default: *Arial.ttf*) and the font size with the `font_size=` argument. If let empty, the function will automatically the font size to match the scale bar length.\n\n#### Time stamps <a name=\"time\"></a>\n\nTo add time stamps on an image stack, one can use the function *addTime()*\n\n```python\nfrom microImage import addTime\n\nmodifiedArray = addTime(imageArray, position='top', padding=20, white_text=True, time_unit='s', time_scale=1/200)\n```\n\nPosition of the stamp can be selected between top and bottom using the `position=` argument. The scale and time units can be specified using the arguments `time_scale=` and `time_unit=` respectively. The color of the text is selected using the argument `white_text=`.\n\nThe text options are the same as the one for the [addBar()](#scale) function.\n\n## Using the ImageStack class <a name=\"class\"></a>\n\nIt is possible to extract the images in an ImageStack object rather than in an array. Using an ImageStack object will reduce the versatility as compared to an array, but make the image processing easier to perform.\n\n### Loading the image in the class <a name=\"load_class\"></a>\n\n* To load an image and generate an object, we use the function *loadImage()*\n\n```python\nfrom microImage import loadImage\n\nimage = loadImage('./path/to/folder/or/image.image_extension')\n```\n\n* Additionally, the ImageStack class can be loaded with an array instead of an image file using the *loadArray()* function\n\n```python\nfrom microImage import loadArray\n\nimage = loadArray(imageArray, name='test array')\n```\n\nIt is essential that the imageArray object here is a 3-D array of dimension **(number of frame, Y, X)**\n\nThe element returned by each of these functions is an object with the following attributes:\n\nName | Type | Description\n---|---|---\n`image.name` | String | Name of the image stack (usually taken from the path)\n`image.n_frames` | Int | Total number of frame in the stack (1 if single image)\n`image.size` | 2-D Tuple | Size of the array in each dimension (Y,X)\n`image.source` | 3-D Array | Array used to generate the class instance. Is used to reset all corrections. Dimensions are (t,Y,X)\n`image.array` | 3-D Array | Originally copy of `image.source`, all modifications and corrections are applied to this array only (except crop). Dimensions are (t,Y,X)\n`image.frame` | ImageFrame object | Instance of the class ImageFrame used to handle single frame images. See below\n`image.frame_nbr` | Int | Index of the current frame being loaded in `image.frame`\n\nTo display the frames, the ImageStack class is calling another class named ImageFrame. This class has the following attributes\n\nName | Type | Description\n--- | --- | ---\n`frame.raw` | 2-D Array | Non-contrast corrected version of the frame being displayed. Used for calculation. Dimensions are (Y,X)\n`frame.corrected` | 2-D Array | Array containing the frame being displayed, eventually with the selected contrast correction. Dimensions are (Y,X)\n\n### Navigate in the frames and display them <a name=\"frame_class\"></a>\n\n* The frame loaded in the ImageFrame class for image processing can be selected using the command *.setFrame()*\n\n```python\nimage.setFrame(12)\n```\n\n* To dislay the frame (using the matplotlib library), just call the *.show()* command.\n\n```python\nimage.show(show_raw=False, cmap='gray', title=True)\n```\n\nThe user can select whether the raw or contrast corrected image can be displayed, the color map and if the title should be displayed or not on the image.\n\n### Duplicate and modify the image <a name=\"edit_class\"></a>\n\n* It is possible to create a copy of the ImageStack object anytime by using the command *.duplicate()*\n\n```python\nnew_copy = image.duplicate()\n```\n\n  All previous modification made on the initial object will be pasted into the copy.\n\n* The image can be cropped to a much smaller size with *.crop()*.\n\n```python\nimage.crop(top_left=(200,200), bottom_right=(800,800))\n```\n\nThe change will affect all image arrays in the ImageStack object, but also in the ImageFrame one. Check the [cropImage function](#crop) for details on the arguments of the function.\n\n* In the case of a stack of several frames, the stack can be reduced to a subrange of frames with the command *.reducedRange()*\n\n```python\nimage.reducedRange(first=10, last=20)\n```\n\nIf not specified, the *first* and *last* frame of the new subrange will be calculated respectively as the first and the last frame of the `image.source` array.\n\n### Apply a correction on the image <a name=\"correct_class\"></a>\n\n* Background correction similar to the one of the [backgroundCorrection()](#background) function can be applied with the *.backgroundCorrection()* command\n\n```python\nimage.backgroundCorrection(imageArray, signed_bits=True, average='median', correction='division')\n```\n\n* Contrast correction similar to the one of the [contrastCorrection()](#contrast) function can be applied with the *.contrastCorrection()* command\n\n```python\nimage.contrastCorrection(imageArray, min=None, max=None, percentile=10, percentile_min=None, rescale=True)\n```\n\n* The effect of the contrastCorrection on the pixel value distribution can be assessed with the *.showPVD()* command. Check the documentation on the [showPVD()](#distribution) function above for more details.\n\n```python\nimage.showPVD(min=None, max=None, percentile=10, percentile_min=None, n_bins=1000, log_scale='xy')\n```\n\n* All modifications can be reset anytime using the *.reset()* command.\n\n```python\nimage.reset()\n```\n\nThis will cancel any background and contrast correction, but not modifications made by the .crop() and .reducedRange() commands.\n\n### Modify the space and time scale of the image <a name=\"scale_class\"></a>\n\n* Set the scales using the *setScale()* function\n\n```python\nimage.setScale(time_scale=1/200, time_unit='s', space_scale=46.21, space_unit='µm')\n```\n\nThe `time_scale=` should be given in unit/frame and the `space_scale=` in unit/pixel. Only the called arguments will be modified, the one set to None or not added will be left unchanged.\n\n* Add a scale bar on the image(s) using the *scaleBar()* function\n\n```python\nimage.scaleBar(frame=0, scale_length=4, add_text=False)\n```\n\nThe argument `frame=` can used to select on which specific frame the scale bar should be added. If set to None, the scale bar will be added on all frames.\n\nRefer to the function [addBar()](#scale) above for description of other arguments.\n\n* Add time stamps on an image stack using the *timeStamps()* function\n\n```python\nimage.timeStamps(white_text=True)\n```\n\nRefer to the function [addTime()](#time) above for description of all arguments.\n\n### Save the image(s) in a file <a name=\"save_class\"></a>\n\n* The command *.saveStack()* will save the whole stack saved in the ImageStack instance.\n\n```python\nimage.saveStack('./path/to/new/file.tif', bit_depth=16, rescale=True, save_raw=False)\n```\n\nThe *save_raw* argument allows the user to select if the corrected or raw array should be save. Check the [saveImage function](#save) for details on the arguments of the function.\n\n* To only save the current frame in the ImageFrame instance, the command *.saveFrame()* can be used.\n\n```python\nimage.saveFrame('./path/to/new/file.tif', bit_depth=16, rescale=True, save_raw=False)\n```\n\n* To save a montage of a selection of frame, the command *.makeMontage()* can be used\n\n```python\nimage.makeMontage(name='./path/to/montage.tif', frames=[0,2,4,10], bit_depth=16, rescale=True)\n```\n\nRefer to the function [makeMontage()](#montage) above for description of all montage-related arguments of the command.\n\n* To save a video file, the command *.saveVideo()* cam be used\n\n```python\nimage.saveVideo(name='./path/to/montage.mp4', fps=25)\n```\n\nRefer to the function [saveVideo()](#video) above for description of all video generation arguments of the command.",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/vivien-walter/microImage/archive/v_2.3.1.tar.gz",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/vivien-walter/microImage",
    "keywords": "microscopy,image,open",
    "license": "GPL3.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "microImage",
    "package_url": "https://pypi.org/project/microImage/",
    "platform": "",
    "project_url": "https://pypi.org/project/microImage/",
    "project_urls": {
      "Download": "https://github.com/vivien-walter/microImage/archive/v_2.3.1.tar.gz",
      "Homepage": "https://github.com/vivien-walter/microImage"
    },
    "release_url": "https://pypi.org/project/microImage/2.3.1/",
    "requires_dist": null,
    "requires_python": ">=3.2",
    "summary": "Python module to open common types of image used in microscopy.",
    "version": "2.3.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9488213,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "69356d3891fc687aa154d1ef75b7c356eb01a83b98e1fb66f4ab42e3bbf4b357",
        "md5": "003a0231760740dde1fe8ee05e7767ab",
        "sha256": "0f230d18abc7a098db1bfdc58bfcf03792d130bf6275448e7378f94f60e8e2fc"
      },
      "downloads": -1,
      "filename": "microImage-2.3.1.tar.gz",
      "has_sig": false,
      "md5_digest": "003a0231760740dde1fe8ee05e7767ab",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.2",
      "size": 22507,
      "upload_time": "2021-02-22T12:31:15",
      "upload_time_iso_8601": "2021-02-22T12:31:15.925449Z",
      "url": "https://files.pythonhosted.org/packages/69/35/6d3891fc687aa154d1ef75b7c356eb01a83b98e1fb66f4ab42e3bbf4b357/microImage-2.3.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}