{
  "info": {
    "author": "Thomas Weholt",
    "author_email": "thomas@weholt.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Topic :: Database"
    ],
    "description": "DSE - Simplified \"bulk\" insert/update/delete for Django\r\n=======================================================\r\n\r\n\r\nVersion : 3.0.0\r\nAuthor : Thomas Weholt <thomas@weholt.org>\r\nLicense : Modified BSD.\r\nStatus : Beta\r\nUrl : https://bitbucket.org/weholt/dse2\r\n\r\n\r\nBackground\r\n----------\r\n\r\n* DSE is available for one reason - to insert/update/delete lots of data -- as fast as possible.\r\n\r\n* DSE vs Django ORM: typical speed gain is around 5x-10X for updates, 3X+ for inserts.\r\n\r\n* DSE is aware of default values specified in your Django models and will use those if no value is given for a field in an insert statement.\r\n\r\n* DSE caches SQL-statements, both inserts, updates and delete, and executes them when a specified number of statements has been prepared or when it`s told manually to flush cached statements to the database. The actual sql execution is done using DB API cursor.executemany and this is much faster than executing SQL-statements in sequence and way faster than using the Django ORM.\r\n\r\n* DSE uses a dictionary to specify what fields to work on.\r\n\r\n* My hope is to see something like this in the django core.\r\n\r\n\r\nNews in 3.x\r\n-----------\r\n\r\n* Changes in syntax which is NOT backwards compatible, therefore a version bump. That and the nice bulk_update method.\r\n \r\n* The add and execute methods have been removed.\r\n\r\n* Patched models now have a property called delayed instead of dse. You can also patch specific models (new in 2.1.0).\r\n\r\n* To insert an item call model.delayed.insert(values)\r\n\r\n* To update an item call model.delayed.update(values)\r\n\r\n* To delete an item call model.delayed.delete(id)\r\n\r\n* If you have to update a huge data set where the values for the fields are limited you can use the new model.delayed.bulk_update(values), for instance metadata from photos or music files. Thanks to Cal Leeming [Simplicity Media Ltd] for inspiration on this one :-). For more info look further down  for a more complete walkthrough on what happends behind the scenes.\r\n\r\n* You can now decorate methods in your model with the dse_value_parser-decorator to make all values passed to dse be parsed by that method. If the method returns None, the values will not be added. This way you can define clean-up or validation methods for your data. NB! These methods must be classmethods! Thanks to Andre Terra for this one.\r\n\r\n* Cursor caching is now optional. It crashed using Mysql in one scenario where several cursors where in play at the same time. Again thanks to Andre Terra.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\npip install dse\r\n\r\nor\r\n\r\nhg clone https://bitbucket.org/weholt/dse2\r\n\r\n\r\nExample usage\r\n-------------\r\n\r\nYou got a model like::\r\n\r\n    gender =  (('M', 'Male'), ('F', 'Female'))\r\n    \r\n    class Person(models.Model):\r\n        name = models.CharField(max_length = 30)\r\n        age = models.IntegerField(default = 30)\r\n        sex = models.CharField(max_length = 1, choices = gender, default = 'M')\r\n\r\nUsing dse::\r\n\r\n    import dse\r\n    dse.patch_models() # Monkey patch all your models and expose dse for all models:\r\n    # to monkey patch only the Person-model do dse.patch_models(specific_models=[Person])\r\n\r\n    with Person.delayed as d:\r\n        for name, age, sex in (('Thomas', 36, 'M'), ('Joe', 40, 'M'), ('Jane', 28, 'F')):\r\n             d.insert(dict(name = name, age = age, sex = sex))\r\n\r\nNothing will be inserted into the database before the loop is done ( or you \r\ninsert 1000 items ). Then the items will be inserted using cursor.executemany, \r\nusing plain SQL - no ORM in sight.\r\n\r\nDSE using default values defined in your model::\r\n    \r\n    with Person.delayed as d:\r\n        # Adding an item, just defining a name and using the default values from the model:\r\n        d.insert({'name': 'John'})\r\n\r\n        # Overriding the default values? Just specify a valid value\r\n        d.insert({'name': 'Thomas', 'age': 36, 'sex': 'M'})\r\n\r\n        # Update record with id = 1 and set its name to John. This will trigger \r\n        # a SQL-statement for this update alone, since not all columns are specified:\r\n        d.update({'id': 1, 'name': 'John'})\r\n  \r\nTo use delayed execution of SQL statements::\r\n\r\n    Person.delayed.update({'id': 2, 'name': 'Al Capone'}) # will NOT trigger anything\r\n    Person.delayed.update({'id': 3, 'name': 'John Dillinger'}) # will NOT trigger anything\r\n    Person.delayed.insert({'name': 'Scarface'}) # will NOT trigger anything\r\n    Person.delayed.flush() # will execute both update statements and insert a record for \"Scarface\"\r\n\r\nSay you want to update all records with some calculated value, something you \r\ncouldn't find a way to do in SQL. Using dse this is easy and fast::\r\n\r\n    with Person.delayed as d:\r\n        # Use Djangos ORM to generate dictionaries to use in DSE; objects.all().values().\r\n        for item in Person.objects.all().values():\r\n            d.update(dict(id=item.get('id'), somevar=calculated_value))\r\n\r\nI've recieved some questions about transaction handling. Below is an simple example,\r\nbut I`m looking into other ways of handling transactions as well::\r\n \r\n    from django.db import transaction\r\n    import dse\r\n\r\n    def some_method():\r\n        with transaction.commit_on_success():\r\n            with SomeModel.delayed as d:\r\n                for item in somelist:\r\n                    d.insert({'some_column': item.some_value, 'another_column': item.another_value})    \r\n\r\nYou can also cache items to delete::\r\n\r\n    with foo.delayed as d:\r\n        for person in person.objects.all():\r\n            if person.likes_perl_more_than_python:\r\n                foo.delayed.delete(person.id) # won't trigger anything\r\n    # here all cached items for deletions are deleted using plain SQL, no orm.\r\n        \r\nDSE caches id's and deletes them when 1000 items are cached or flush/close are called.\r\nIt uses sql similar to \"delete from tablename where id in (<list of ids>)\".\r\n\r\nDSE features singletons (NB! very experimental, no locking/thread support yet!)::\r\n\r\n    import dse.singleton\r\n\r\n    p1 = dse.singleton.Models.Person()\r\n    p2 = dse.singleton.Models.Person()\r\n    print p1 is p2 # should print True\r\n    p1.insert(dict(name = 'Joe'))\r\n    p2.flush()\r\n    print Person.objects.all().count() # should print 1\r\n\r\nSingletons makes it possible to cache entries across sections of code and cache\r\neven more data, hitting the db less.\r\n\r\nNew in the 3.x version of DSE is the bulk_update-method. It takes a dictionary of values to update,\r\nrequires a value for the primary key/id of the record, but uses the django orm's own update method\r\ninstead of plain sql to reduce number of statements to execute. This is helpful when your fields can\r\nhave a limited set of values, like EXIF-data from photos. An example::\r\n\r\n    with Photo.delayed as d:\r\n        d.update({'id': 1, 'camera_model': 'Nikon', 'fnumber': 2.8, 'iso_speed': 200})\r\n        d.update({'id': 2, 'camera_model': 'Nikon', 'fnumber': 11, 'iso_speed': 400})\r\n        d.update({'id': 3, 'camera_model': 'Nikon', 'fnumber': 2.8, 'iso_speed': 400})\r\n        d.update({'id': 4, 'camera_model': 'Canon', 'fnumber': 3.5, 'iso_speed': 200})\r\n        d.update({'id': 5, 'camera_model': 'Canon', 'fnumber': 11, 'iso_speed': 800})\r\n        d.update({'id': 6, 'camera_model': 'Pentax', 'fnumber': 11, 'iso_speed': 800})\r\n        d.update({'id': 7, 'camera_model': 'Sony', 'fnumber': 3.5, 'iso_speed': 1600})\r\n        # and then some thousand more lines like that\r\n\r\nInternally DSE will construct a structure like this::\r\n\r\n    bulk_updates = {\r\n        'camera_model': {\r\n                'Nikon': [1,2,3],\r\n                'Canon': [4,5],\r\n                'Pentax': [6],\r\n                'Sony': [7],\r\n            },\r\n        'fnumber': {\r\n                2.8: [1,3],\r\n                11: [2,5,6],\r\n                3.5: [4,7],\r\n            },\r\n        'iso_speed': {\r\n                200: [1,4],\r\n                400: [2,3],\r\n                800: [5,6],\r\n                1600: [7]\r\n        }\r\n    }\r\n\r\nAnd then execute those statements using::\r\n\r\n    # pk = the primary key field for the model, in most cases id\r\n    for field, values in bulk_updates.iteritems():\r\n        for value, ids in values.iteritems():\r\n            model.objects.filter(**{\"%s__in\" % pk: ids}).update(**{field: value})\r\n\r\nFor huge datasets where the fields can have limited values this has a big impact on performance. So when to use\r\nupdate or bulk_update depends on the data you want to process. For instance importing a contact list where most\r\nof the fields had almost unique values would benefit from the update-method, but importing data from photos, id3-tags\r\nfrom your music collection etc would process much faster using bulk_update.\r\n\r\nUsing the dse_value_parser decorator::\r\n\r\n    from dse import *\r\n\r\n    class YourModel(models.Model):\r\n       # your fields\r\n\r\n    @dse_value_parser\r\n    def data_validation(cls, values):\r\n        # validate your data, return None if validation fails\r\n        return values\r\n\r\nAnd that's all you have to do. Your method data_validation will be called each time you add a set of values.\r\n\r\n\r\nPerformance using DSE 2.x compared to the django orm using the django test framework\r\n------------------------------------------------------------------------------------\r\n\r\nLots of updates:\r\nDSE : 0.116728067398 seconds.\r\nORM : 15.0528171062 seconds.\r\n\r\nLots of inserts:\r\nDSE: 0.0825960636139 seconds.\r\nORM: 0.830269098282 seconds.\r\n\r\nIterate of objects and updating them:\r\nDSE: 0.817410230637 seconds.\r\nORM: 60.4543881416 seconds.\r\n\r\nDelete lots of objects:\r\nDSE: 0.495353937149 seconds.\r\nORM: 13.3724360466 seconds.\r\n\r\nYou can see the code for the test producing these numbers here:\r\nhttps://bitbucket.org/weholt/dse2/src/dbd87b0e2cdb/tests/performance_tests.py\r\n\r\nNB! These numbers do NOT represent real world performance, but merely show the overhead\r\nof using the django orm compared to DSE. My latests tests shows DSE to be about 3 \r\ntimes faster on inserts, it uses about 14% of the time compared to the orm when doing updates\r\nand in some special cases DSE can speed up delete-operations also.\r\n\r\n\r\nLicense\r\n-------\r\n\r\nCopyright (c) 2011, Thomas Augestad Weholt\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n\r\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\r\n  following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\n* Neither the name of Thomas Augestad Weholt nor the names of its contributors may be used to endorse or promote\r\n  products derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\r\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\nIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\nRelease notes\r\n-------------\r\n\r\n3.0.0 : clean up and release.\r\n\r\n3.0.0-BETA#3 : clean-up/validation decorator and optional cursor caching.\r\n\r\n3.0.0-BETA#2 : fixed a few things reported by Fido Garcia.\r\n\r\n3.0.0-BETA#1 : refactoring, removal of code, new methods for insert and update, removal of the add, execute and several other methods. UPDATE-code\r\n        optimized.\r\n\r\n2.1.0 : Small change; dse.patch_models can now take an optional list of models to patch, like so dse.patch_models(specific_models=[User, Comment]).\r\n\r\n2.0.0 : labeled as stable. Updated docs and examples.\r\n\r\n2.0.0-RC1 : no change in code, now released using the modified BSD license to be more compatible with django license use.\r\n\r\n2.0.0-BETA#9 : added FileExport-class to ease debugging what is processed during testing. Writes SQL-data to file. See source/testsuite for usage.\r\n\r\n2.0.0-BETA#4 : started refactoring DSE to remove all non-django specific code, mostly to gain speed and simply code.\r\n\r\n1.0.2 : reconnect if cursor is dead.\r\n\r\n1.0.1 : fixed issue #9 \"Factory can eat up memory\" reported by vangheem. When finding fields related to a table only the top row is fetched.\r\n\r\n1.0.0 : Version bump. Added unittest for issue #8.\r\n\r\n1.0.0-RC1 : updated README.txt. \r\n\r\n0.9.4 : - PEP8 and pyflake.\r\n\r\n0.9.3 : - Fixed issue #7: dse causes django-debug-toolbar to crash. Thanks to ringemup for pointing that out. Added some docstrings.\r\n\r\n0.9.2 : - Corrected type in usage.rst and README.txt.\r\n\r\n0.9.1 : - Refactored code even more, added usage.rst, singleton support in the singleton-package and some performance tests. Models not monkey patched be default anymore, must call dse.patch_models().\r\n\r\n0.9.0 : - Refactored code and cleaned up tests folder. Focus on getting singleton support in before 1.0.0. And more tests.\r\n\r\n0.8.2 : - added 'pysqlite2' to _DBMAP. Thanks to David Marble for 0.8.1 and 0.8.2.\r\n\r\n0.8.1 : - attempt to fix quoting problems with fields on postgresql.\r\n\r\n0.8.0 : - fixed crash when more than one database connection has been configured. No ModelFactory will be triggered.\r\n\r\n0.7.0 : - don`t remember.\r\n\r\n0.6.0 : - added support for the with-statement.\r\n        - added an ModelDelayedExecutor-instance to each model, so you can do Model.dse.add_item\r\n          instead of dse.ModelFactory.Model.add_item.\r\n        - renamed dse.modelfactory to dse.ModelFactory to be more style-compliant.\r\n\r\n0.5.1 : just some notes on transaction handling.\r\n\r\n0.5.0 :\r\n    - added modelfactory. Upon first import a modelfactory will be created in the DSE module. It`s basically just a helper-class containing ModelDelayedExecutor-instances for all models in all apps found in INSTALLED_APPS in settings.py.\r\n    - to change the default item limit before automatic execution of cached SQL statements to 10000 instead of the default 1000: import dse; dse.ITEM_LIMIT = 10000\r\n\r\n0.4.0 :\r\n    - fixed serious bug when using mass updates. Using cursor.executemany is only possible when values for all columns are specified. If only values for a subset of the columns is specified that will be executed as a seperate SQL-call. NOTE! Using dex.get_items() or Djangos Model.objects.values() will give you all the fields.\r\n    - code clean-up.\r\n    - added custom exceptions; UpdateManyException, UpdateOneException and InsertManyException.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/weholt/dse2",
    "keywords": null,
    "license": "UNKNOWN",
    "maintainer": null,
    "maintainer_email": null,
    "name": "dse",
    "package_url": "https://pypi.org/project/dse/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/dse/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://bitbucket.org/weholt/dse2"
    },
    "release_url": "https://pypi.org/project/dse/3.0.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "DSE - Simplified \"bulk\" insert/update/delete for Django.",
    "version": "3.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1085243,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2715b8bd6c03256f853bade738c91f29f23eb4db59fc78aaa04f162f2e5f4041",
        "md5": "ca637cc87339366f6bac151a9f7bc10e",
        "sha256": "40020b3a246b01ccc6b598b1e8d48d2723592d7d3f90cdf29614b1583c9ba551"
      },
      "downloads": -1,
      "filename": "dse-3.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "ca637cc87339366f6bac151a9f7bc10e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 13049,
      "upload_time": "2011-08-16T00:47:34",
      "upload_time_iso_8601": "2011-08-16T00:47:34.761888Z",
      "url": "https://files.pythonhosted.org/packages/27/15/b8bd6c03256f853bade738c91f29f23eb4db59fc78aaa04f162f2e5f4041/dse-3.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}