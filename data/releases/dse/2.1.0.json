{
  "info": {
    "author": "Thomas Weholt",
    "author_email": "thomas@weholt.org",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Topic :: Database"
    ],
    "description": "DSE - Simplified \"bulk\" insert/update/delete for Django\r\n=======================================================\r\n\r\n\r\nVersion : 2.1.0\r\nAuthor : Thomas Weholt <thomas@weholt.org>\r\nLicense : Modified BSD.\r\nStatus : Stable\r\nUrl : https://bitbucket.org/weholt/dse2\r\n\r\n\r\nBackground\r\n----------\r\n\r\n* DSE is available for one reason - to insert/update/delete lots of data -- as fast as possible.\r\n\r\n* DSE vs Django ORM: typical speed gain is around 5x-10X for updates, 3X+ for inserts.\r\n\r\n* DSE is aware of default values specified in your Django models and will use \r\nthose if no value is given for a field in an insert statement.\r\n\r\n* DSE caches SQL-statements, both inserts and updates, and executes them when \r\na specified number of statements has been prepared or when it`s told manually to flush\r\ncached statements to the database. The actual sql execution is done using \r\nDB API cursor.executemany and this is much faster than executing SQL-statements \r\nin sequence and way faster than using the Django ORM.\r\n\r\n* DSE uses a dictionary to specify what fields to update. It differs between\r\nupdate and insert statements by looking for a key similar to the primary key for\r\na given model.\r\n\r\n* DSE will try to execute as many statements as possible, but will detect update\r\nstatements where only a few sql fields/columns are updated and execute those \r\nstatements individually.\r\n\r\n* My hope is to see something like this in the django core.\r\n\r\n\r\nNews in 2.0.0\r\n-------------\r\n\r\nDSE 2.0.0 has been refactored, released under the modified BSD license and is now a django-only\r\npackage. It also contains some backwards incompatible changes compared to the 1.x-branch,\r\nmainly renaming the add_items method to just add.\r\n\r\nThe code is considerably smaller and most of my attention has been on removing the repeated subclassing in\r\nthe 1.x-branch and generating SQL used for standard insert/update at creation instead of repeatedly creating\r\nit for each execute statement. Also all the code related to modelfactory has been removed.\r\n\r\nThe code was restructured to allow subclassing so the generated SQL could be written to file etc. This\r\nhas not been tested much and there are issues with quoting/escaping certain fields, date/datetime etc. The goal\r\nof this code is to generate platform-specific SQL, put that into a file and use things like Postgresqls\r\nCOPY-command to insert data even faster than DSE is capable of. This will be expanded in the coming releases of 2.x.\r\n\r\nDSE also features caching of items to delete as well. This can be very handy when you iterate of a collection and\r\nsome items should be deleted, but which ones cannot be determined or filtered using the orm or plain sql. It caches\r\nprimary keys only and then uses a syntax like \"delete from somemodel where id in (<list of ids>)\". An example of\r\nusage is listed at the bottom of this document.\r\n\r\nI've also started looking at adding unittests with focus on possible SQL injection and input validation. So far my\r\ntests has been performed on postgresql and sqlite, not mysql. Users have reported using DSE and mysql with success,\r\nbut my intention are to create a performance related testsuite for all major database; postgresq, sqlite and mysql.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\npip install dse\r\n\r\nor\r\n\r\nhg clone https://bitbucket.org/weholt/dse2\r\n\r\n\r\nExample usage\r\n-------------\r\n\r\nYou got a model like::\r\n\r\n    gender =  (('M', 'Male'), ('F', 'Female'))\r\n    \r\n    class Person(models.Model):\r\n        name = models.CharField(max_length = 30)\r\n        age = models.IntegerField(default = 30)\r\n        sex = models.CharField(max_length = 1, choices = gender, default = 'M')\r\n\r\nUsing dse::\r\n\r\n    import dse\r\n    dse.patch_models() # Monkey patch all your models and expose dse for all models:\r\n\r\n    with Person.dse as d:\r\n        for name, age, sex in (('Thomas', 36, 'M'), ('Joe', 40, 'M'), ('Jane', 28, 'F')):\r\n             d.add(dict(name = name, age = age, sex = sex))\r\n\r\nNothing will be inserted into the database before the loop is done ( or you \r\ninsert 1000 items ). Then the items will be inserted using cursor.executemany, \r\nusing plain SQL - no ORM in sight.\r\n\r\nDSE using default values defined in your model::\r\n    \r\n    with Person.dse as d:    \r\n        # Adding an item, just defining a name and using the default values from the model:\r\n        d.add({'name': 'John'})\r\n\r\n        # Overriding the default values? Just specify a valid value\r\n        d.add({'name': 'Thomas', 'age': 36, 'sex': 'M'})\r\n\r\n        # Update record with id = 1 and set its name to John. This will trigger \r\n        # a SQL-statement for this update alone, since not all columns are specified:\r\n        d.add({'id': 1, 'name': 'John'})\r\n  \r\nTo use delayed execution of SQL statements::\r\n\r\n    Person.dse.add({'id': 2, 'name': 'Al Capone'}) # will NOT trigger anything\r\n    Person.dse.add({'id': 3, 'name': 'John Dillinger'}) # will NOT trigger anything\r\n    Person.dse.add({'name': 'Scarface'}) # will NOT trigger anything\r\n    Person.dse.flush() # will execute both update statements and insert a record for \"Scarface\"\r\n\r\nSay you want to update all records with some calculated value, something you \r\ncouldn`t find a way to do in SQL. Using dse this is easy and fast::\r\n\r\n    with Person.dse as d:    \r\n        # Use Djangos ORM to generate dictionaries to use in DSE; objects.all().values().\r\n        for item in Person.objects.all().values():\r\n            item['somevar'] = calculated_value\r\n            d.add(item)\r\n\r\nI`ve recieved some questions about transaction handling. Below is an simple example, \r\nbut I`m looking into other ways of handling transactions as well::\r\n \r\n    from django.db import transaction\r\n    import dse\r\n\r\n    def some_method():\r\n        with transaction.commit_on_success():\r\n            with SomeModel.dse as d:\r\n                for item in somelist:\r\n                    d.add({'some_column': item.some_value, 'another_column': item.another_value})    \r\n\r\nYou can also cache items to delete::\r\n\r\n    with foo.dse as d:\r\n        for person in person.objects.all():\r\n            if person.likes_perl_more_than_python:\r\n                foo.dse.delete(person.id) # won't trigger anything\r\n    # here all cached items for deletions are deleted using plain SQL, no orm.\r\n        \r\nDSE caches id's and deletes them when 1000 items are cached or flush/close are called.\r\nIt uses sql similar to \"delete from tablename where id in (<list of ids>)\".\r\n\r\nDSE features singletons (NB! very experimental, no locking/thread support yet!)::\r\n\r\n    import dse.singleton\r\n\r\n    p1 = dse.singleton.Models.Person()\r\n    p2 = dse.singleton.Models.Person()\r\n    print p1 is p2 # should print True\r\n    p1.add(dict(name = 'Joe'))\r\n    p2.flush()\r\n    print Person.objects.all().count() # should print 1\r\n\r\nSingletons makes it possible to cache entries across sections of code and cache\r\neven more data, hitting the db less.\r\n\r\n\r\nPerformance compared to the django orm using the django test framework\r\n----------------------------------------------------------------------\r\n\r\nLots of updates:\r\nDSE : 0.116728067398 seconds.\r\nORM : 15.0528171062 seconds.\r\n\r\nLots of inserts:\r\nDSE: 0.0825960636139 seconds.\r\nORM: 0.830269098282 seconds.\r\n\r\nIterate of objects and updating them:\r\nDSE: 0.817410230637 seconds.\r\nORM: 60.4543881416 seconds.\r\n\r\nDelete lots of objects:\r\nDSE: 0.495353937149 seconds.\r\nORM: 13.3724360466 seconds.\r\n\r\nYou can see the code for the test producing these numbers here:\r\nhttps://bitbucket.org/weholt/dse2/src/dbd87b0e2cdb/tests/performance_tests.py\r\n\r\nNB! These numbers do NOT represent real world performance, but merely show the overhead\r\nof using the django orm compared to DSE. My latests tests shows DSE to be about 3 \r\ntimes faster on inserts, it uses about 14% of the time compared to the orm when doing updates\r\nand in some special cases DSE can speed up delete-operations also.\r\n\r\n\r\nLicense\r\n-------\r\n\r\nCopyright (c) 2011, Thomas Augestad Weholt\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n\r\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\r\n  following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\n* Neither the name of Thomas Augestad Weholt nor the names of its contributors may be used to endorse or promote\r\n  products derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\r\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\nIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\nRelease notes\r\n-------------\r\n\r\n2.1.0 : Small change; dse.patch_models can now take an optional list of models to patch, like so dse.patch_models(specific_models=[User, Comment]).\r\n\r\n2.0.0 : labeled as stable. Updated docs and examples.\r\n\r\n2.0.0-RC1 : no change in code, now released using the modified BSD license to be more compatible with django license use.\r\n\r\n2.0.0-BETA#9 : added FileExport-class to ease debugging what is processed during testing. Writes SQL-data to file. See source/testsuite for usage.\r\n\r\n2.0.0-BETA#4 : started refactoring DSE to remove all non-django specific code, mostly to gain speed and simply code.\r\n\r\n1.0.2 : reconnect if cursor is dead.\r\n\r\n1.0.1 : fixed issue #9 \"Factory can eat up memory\" reported by vangheem. When finding fields related to a table only the top row is fetched.\r\n\r\n1.0.0 : Version bump. Added unittest for issue #8.\r\n\r\n1.0.0-RC1 : updated README.txt. \r\n\r\n0.9.4 : - PEP8 and pyflake.\r\n\r\n0.9.3 : - Fixed issue #7: dse causes django-debug-toolbar to crash. Thanks to ringemup for pointing that out. Added some docstrings.\r\n\r\n0.9.2 : - Corrected type in usage.rst and README.txt.\r\n\r\n0.9.1 : - Refactored code even more, added usage.rst, singleton support in the singleton-package and some performance tests. Models not monkey patched be default anymore, must call dse.patch_models().\r\n\r\n0.9.0 : - Refactored code and cleaned up tests folder. Focus on getting singleton support in before 1.0.0. And more tests.\r\n\r\n0.8.2 : - added 'pysqlite2' to _DBMAP. Thanks to David Marble for 0.8.1 and 0.8.2.\r\n\r\n0.8.1 : - attempt to fix quoting problems with fields on postgresql.\r\n\r\n0.8.0 : - fixed crash when more than one database connection has been configured. No ModelFactory will be triggered.\r\n\r\n0.7.0 : - don`t remember.\r\n\r\n0.6.0 : - added support for the with-statement.\r\n        - added an ModelDelayedExecutor-instance to each model, so you can do Model.dse.add_item\r\n          instead of dse.ModelFactory.Model.add_item.\r\n        - renamed dse.modelfactory to dse.ModelFactory to be more style-compliant.\r\n\r\n0.5.1 : just some notes on transaction handling.\r\n\r\n0.5.0 :\r\n    - added modelfactory. Upon first import a modelfactory will be created in the DSE module. It`s basically just a\r\n    helper-class containing ModelDelayedExecutor-instances for all models in all apps found in INSTALLED_APPS in\r\n    settings.py.\r\n    - to change the default item limit before automatic execution of cached SQL statements to 10000 instead of the default 1000::\r\n\r\n    import dse\r\n    dse.ITEM_LIMIT = 10000\r\n\r\n0.4.0 :\r\n    - fixed serious bug when using mass updates. Using cursor.executemany is only possible when values\r\n    for all columns are specified. If only values for a subset of the columns is specified that will be\r\n    executed as a seperate SQL-call. NOTE! Using dex.get_items() or Djangos Model.objects.values() will give you\r\n    all the fields.\r\n    - code clean-up.\r\n    - added custom exceptions; UpdateManyException, UpdateOneException and InsertManyException.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/weholt/dse2",
    "keywords": null,
    "license": "UNKNOWN",
    "maintainer": null,
    "maintainer_email": null,
    "name": "dse",
    "package_url": "https://pypi.org/project/dse/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/dse/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://bitbucket.org/weholt/dse2"
    },
    "release_url": "https://pypi.org/project/dse/2.1.0/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "DSE - Simplified \"bulk\" insert/update/delete for Django.",
    "version": "2.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1085243,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b46aa46e03f45c27eb1cbdcfa4a83a3b4d8329b6a8f799b1a35d921b5293e4a7",
        "md5": "0420830a4d681e709d3fa1dc8c8966f7",
        "sha256": "77dc5f24ea59e53461fcf6c97c697c3663d2ad908a23c5c53939951e4cbd8a47"
      },
      "downloads": -1,
      "filename": "dse-2.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "0420830a4d681e709d3fa1dc8c8966f7",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 12481,
      "upload_time": "2011-06-07T20:54:51",
      "upload_time_iso_8601": "2011-06-07T20:54:51.489867Z",
      "url": "https://files.pythonhosted.org/packages/b4/6a/a46e03f45c27eb1cbdcfa4a83a3b4d8329b6a8f799b1a35d921b5293e4a7/dse-2.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}