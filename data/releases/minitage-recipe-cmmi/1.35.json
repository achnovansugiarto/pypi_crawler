{
  "info": {
    "author": "Mathieu Pasquet",
    "author_email": "kiorky@cryptelium.net",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Buildout",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "******************************************************************************\nRecipe for compiling and installing software with or without minitage\n******************************************************************************\n\n.. contents::\n\n=======================\nIntroduction\n=======================\n\nPlease look for options at http://pypi.python.org/pypi/minitage.recipe.common\n\nThe egg has those entry point:\n\n    - *cmmi*: install configure/make/make install softwares\n\nThe reasons why i have rewrite yet another buildout recipes builder are:\n\n    - Support for downloading stuff\n    - Support on the fly patchs for eggs and other distribution.\n    - Support multiple hooks at each stage of the build system.\n    - Robust offline mode\n    - support automaticly minitage dependencies and rpath linking.\n\nYou can browse the code on minitage's following resources:\n\n    - http://git.minitage.org/git/minitage/eggs/minitage.recipe.cmmi/\n    - http://www.minitage.org/trac/browser/minitage/eggs/minitage.recipe.cmmi\n\nYou can migrate your buldouts without any effort with buildout.minitagificator:\n\n    - http://pypi.python.org/pypi/buildout.minitagificator\n\n\n\n\n===============================================\nminitage.recipe.cmmi\n===============================================\n\nAbstract\n-----------------\n\n    - The cmmi recipe use abusivly or -rpath to save you from settings LD_LIBRARY_PATH at run time.\n    - If you are inside a minitage environment, all the dependencies of your minibuild are put in the environment.\n      That mean that CFLAGS, LDFLAGS, PKG_CONFIG_PATH, and so on are updated to reference your minibuild's dependencies.\n    - minitage.recipe.cmmi is a replacment fo ``zc.recipe.cmmi``.\n    - It intends to do the *configure && make && make install* dance with hooks where you can do (in python) specific stuff at each stage of the build cursus.\n    - With this recipe, if the destination directory exists, we only remove it\n      when we can sucessfully install something, unless that we never touch to it,\n      or it is a bug.\n    - LOOK ALSO AT THE *SHARED VARIABLES* AS ALL THE MINITAGE RECIPES SHARE A LOT OF VARIABLES\n\nSpecific options\n-----------------\nPlease look for options at : http://pypi.python.org/pypi/minitage.recipe.common#options-shared-by-all-the-recipes\n\n* UNAME-patches\n    OS specific (sys.platform.lower()) patches to apply  [see cmmi recipe for documentation]\n* make-targets\n    default to all and install, make targets to run\n* inner-dir: change to inner directory before doing anything.\n* prefix: where to install (defaults to options:location)\n  Be warn that the content of the destination will be wiped before unless you\n  set 'install-in-place'\n* install-in-place: install over a previous installation instead of removing\n  the older install replacing it with the new 'makeinstall result'::\n\n    install-in-place=True\n\n* build-dir\n    inner directory to execute the build dance [see cmmi recipe for documentation]\n* configure-options-UNAME\n    Os specific options to give to configure\n    uname can be either linux2|freebsd6|freebsd7|darwin\n    Its the result of sys.platform.lower() [see cmmi recipe for documentation]\n* configure\n    configure script to use (default to ./configure)\n* prefix-separator [see cmmi recipe for documentation]\n    prefix separator to use between --prefix and location (default to =)\n* prefix-options [see cmmi recipe for documentation]\n    what to put for the \"prefix\" expression, default to --prefix$PREFIX_SEPARATOR$LOCATION\n* autogen\n    autogen script to use if any [optionnal]\n* configure-options\n    options to feed configure with [see cmmi recipe for documentation]\n* extra_options\n    appendended to configure-options  [see cmmi recipe for documentation]\n\n* hooks\n\n  A hook is in the form /path/to/hook:CALLABLE::\n\n        myhook=${buildout:directory}/toto.py:foo\n\n  Where we have toto.py::\n\n        def foo(options, buildout):\n            return 'Hourray'\n\n  The complete possible hooks list:\n\n    * pre-unpack-hook\n        hook executed before the unpack dance\n    * post-unpack-hook\n        hook executed after the unpack dance\n    * post-unpack-hook\n        hook executed after the unpack dance\n    * pre-configure-hook\n        hook executed before the configure is run\n    * pre-make-hook\n        hook executed before the first make target is run\n    * post-build-hook\n        hook executed after the build make targets are done\n    * pending-make-install\n        hook executed after the make and before the make install is done\n    * post-make-hook\n        hook executed after the make install is done\n    * noconfigure\n        do not run ./configure\n    * noinstall\n        do not run make install\n\nDetailled documentation\n-------------------------\n\nLet's create a buildout configuration file.\n\n    >>> rmdir(tempdir)\n    >>> mkdir(tempdir)\n    >>> cd(tempdir)\n    >>> a = [mkdir(d) for d in ('eggs', 'develop-eggs', 'bin', 'src')]\n    >>> install_develop_eggs(['minitage.recipe'])\n    >>> install_eggs_from_pathes(['zc.buildout'], sys.path)\n    >>> touch('buildout.cfg')\n    >>> sh('buildout -o bootstrap')\n    buildout -o bootstrap...\n\nThis first buildout is classical, trying to build some url.\n\n    >>> touch('buildout.cfg',\n    ... data=\"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... \"\"\")\n    >>> sh('bin/buildout install part')\n    bin/buildout install part...\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    A...\n    MinimergeError: URL was not set!\n    <BLANKLINE>\n\nOups, we forgot the url, we will make a basic distribution package to test our stuff\nRunning the buildout with the url bit.\n\n    >>> if not os.path.exists('foo'):\n    ...     mkdir('foo')\n    ... else:\n    ...     rmdir(foo)\n    ...     mkdir('foo')\n    >>> touch('foo/configure', data =\"\"\"echo configure $@\\n\"\"\")\n    >>> sh('chmod +x foo/configure')\n    c...\n    >>> touch('foo/Makefile',\n    ... data = \"\"\"\n    ... all:\n    ... \\t@echo all\n    ...\n    ... install:\n    ... \\t@echo install\n    ...\n    ... \"\"\")\n    >>> sh('tar cfz  foo.tgz foo')\n    tar cfz  ...\n    <BLANKLINE>\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading file:///tmp/buildout.test/foo.tgz in /tmp/buildout.test/minitage/foo.tgz\n    minitage.recipe: Unpacking in /tmp/buildout.test/__minitage__part__tmp.\n    minitage.recipe: Guessing compilation directory\n    minitage.recipe: Setting path\n    minitage.recipe: Setting pkgconfigpath\n    minitage.recipe: Setting compilation flags\n    minitage.recipe: Setting path\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part\n    configure --prefix=/tmp/buildout.test/parts/part\n    minitage.recipe: Running make\n    all\n    minitage.recipe: Running make  install\n    install\n    minitage.recipe: Completed install...\n\nGeneral usage\n++++++++++++++++++++++\nThis first buildout does nothing except print us the hooks calls. We have desactivated the configure and make dance!.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Unpacking in /tmp/buildout.test/__minitage__part__tmp.\n    minitage.recipe: Guessing compilation directory\n    minitage.recipe: Setting path\n    minitage.recipe: Setting pkgconfigpath\n    minitage.recipe: Setting compilation flags\n    minitage.recipe: Setting path\n    minitage.recipe: Completed install...\n\nApplying patches\n++++++++++++++++++++\nThis second one aimes to show us the patch capababilities.\n\n    >>> sh('cp foo/Makefile foo/Makefile.old')\n    cp foo/Makefile foo/Makefile.old\n    >>> sh('echo >> foo/Makefile')\n    echo >> foo/Makefile\n    >>> sh('diff -u foo/Makefile.old foo/Makefile > patch')\n    diff -u foo/Makefile.old foo/Makefile > patch\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... patches = ${buildout:directory}/patch\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running patch -t -Np0 < /tmp/buildout.test/minitage/patch_d96115b00b41e282469f73708c68bdaf/patch\n    can't find file to patch at input line 3\n    Perhaps you used the wrong -p or --strip option?\n    The text leading up to this was:\n    --------------------------\n    |--- foo/Makefile.old ...\n    |+++ foo/Makefile  ...\n    --------------------------\n    No file to patch.  Skipping patch.\n    1 out of 1 hunk ignored\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    An internal error occured due to a bug in either zc.buildout or in a...\n    SystemError: ('Failed', 'patch -t -Np0 < /tmp/buildout.test/minitage/patch_d96115b00b41e282469f73708c68bdaf/patch')\n    <BLANKLINE>\n\n\nThe patch level is wrong !\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... patches = ${buildout:directory}/patch\n    ... patch-options = -p1\n    ... noconfigure=true\n    ... noinstall = true\n    ... nomake = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running patch -t -p1 < /tmp/buildout.test/minitage/patch...\n    patching file Makefile\n    minitage.recipe: Completed install...\n\n\nUsing hooks\n++++++++++++++\nBut now that we have some sort of messy packages, can we not intercale some python to code to arrange things upside down ?\nWe have hooks to achieve that. A hook is a python callable which takes at least the options part and the buildout.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... pre-unpack-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n    ... post-unpack-hook   = ${buildout:directory}/hooks.py:post_unpack_hook\n    ... pre-configure-hook = ${buildout:directory}/hooks.py:pre_configure_hook\n    ... pre-make-hook      = ${buildout:directory}/hooks.py:pre_make_hook\n    ... post-build-hook    = ${buildout:directory}/hooks.py:post_build_hook\n    ... post-make-hook     = ${buildout:directory}/hooks.py:post_make_hook\n    ... \"\"\"\n    >>> touch('hooks.py', data=\"\"\"\n    ... def  pre_unpack_hook    (o, b, hook='pre_unpack_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_unpack_hook   (o, b, hook='post_unpack_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  pre_configure_hook (o, b, hook='pre_configure_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  pre_make_hook      (o, b, hook='pre_make_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_build_hook    (o, b, hook='post_build_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... def  post_make_hook     (o, b, hook='post_make_hook'):\n    ...     print \"%s in %s target %s\" % (hook, b['buildout']['directory'], o['location'])\n    ... \"\"\")\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    ... bin/buildout -o install part...\n    bin/buildout -o install part...\n    minitage.recipe: Download archive\n    minitage.recipe: Executing pre-unpack-hook\n    pre_unpack_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part...\n    minitage.recipe: Setting path\n    minitage.recipe: Executing post-unpack-hook\n    post_unpack_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Executing pre-configure-hook\n    pre_configure_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part\n    configure --prefix=/tmp/buildout.test/parts/part\n    minitage.recipe: Executing pre-make-hook\n    pre_make_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running make\n    all\n    minitage.recipe: Executing post-build-hook\n    post_build_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Running make  install\n    install\n    minitage.recipe: Executing post-make-hook\n    post_make_hook in /tmp/buildout.test target /tmp/buildout.test/parts/part\n    minitage.recipe: Completed install...\n\n\nMD5 check\n+++++++++++++\nCan we check md5, of course!\nAs we have already the foo package in our download cache, we try to download something else.\n\n    >>> shutil.copy2('foo.tgz', 'bar.tgz')\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... md5sum = b4d\n    ... url = file://${buildout:directory}/bar.tgz\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part\n    Uninstalling part.\n    Unused options for buildout: 'download-directory'.\n    Installing part.\n    minitage.recipe: Download archive\n    minitage.recipe: Downloading file:///tmp/buildout.test/bar.tgz in /tmp/buildout.test/minitage/bar.tgz\n    <BLANKLINE>\n    While:\n      Installing part.\n    <BLANKLINE>\n    A...\n    MinimergeError: Failed download for file:///tmp/buildout.test/bar.tgz:      MD5SUM mismatch for /tmp/buildout.test/minitage/bar.tgz: Good:b4d != Bad:...\n    <BLANKLINE>\n\nControlling configure\n++++++++++++++++++++++++++++++\nGiving configure options the two possible ways.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/bar.tgz\n    ... configure-options = foo\n    ... extra_options = bar\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part foo bar\n    configure --prefix=/tmp/buildout.test/parts/part foo bar ...\n\nUse OS Specific rules\n+++++++++++++++++++++++++\nGiving os specific rules.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... configure-options-linux = linuxoptions\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/parts/part    linuxoptions...\n\nOr, in the same manner, you can specify OS specific patches: (darwin, linux, freebsd6, freebsd7). sys.platform is your friend :) ('linux', for all linuxes).\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... patch-options = -p1\n    ... url = file://${buildout:directory}/foo.tgz\n    ... \"\"\"\n    >>> data += '%s-patches =${buildout:directory}/patch' % uname\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Running patch -t -p1 < /tmp/buildout.test/minitage/patch...\n\n\nUsing underlying minitage environment\n++++++++++++++++++++++++++++++++++++++++++++\nIf you are in a minitage, all your minibuild dependencies come automaticly in the env, no need to do the following code :)\nAs you can have CFLAGS and so on added to your env., you can specify manual things too, the underlying code is the same.\nThe goal is to proove that all is preprended as we would have think.\nWe will use some hook to print the relevant parts.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n    ... includes-dirs = /foo/include\n    ... rpath = /someruntimespath/lib\n    ... library-dirs = /bar/lib\n    ... pkgconfigpath = /lib/pkgconfig/\n    ... noconfigure = true\n    ... nomake = true\n    ... noinstall = true\n    ... \"\"\"\n    >>> touch('hooks.py', data=\"\"\"\n    ... import os\n    ... def  pre_unpack_hook(o, b):\n    ...     flags = [(a, os.environ.get(a, 'not_set')) for a in ('CFLAGS', 'LDFLAGS', 'PKG_CONFIG_PATH', 'LD_RUN_PATH',)]\n    ...     for flag in flags:\n    ...         print flag\n    ... \"\"\")\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    b...\n    minitage.recipe: Executing pre-make-hook\n    ('CFLAGS', '-I/foo/include')\n    ('LDFLAGS', '-L/bar/lib -Wl,-rpath -Wl,/bar/lib -L/tmp/buildout.test/parts/part/lib -Wl,-rpath -Wl,/tmp/buildout.test/parts/part/lib')\n    ('PKG_CONFIG_PATH', '/lib/pkgconfig/...')\n    ('LD_RUN_PATH', '/someruntimespath/lib:/tmp/buildout.test/parts/part/lib')...\n\n\nPlaying with the environment\n++++++++++++++++++++++++++++++++\nYou can play also with the environment directly in two ways.\n\n    * Precising a buildout part\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [foo]\n        ... CFLAGS=bar\n        ... [part]\n        ... recipe=minitage.recipe.cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n        ... environment = foo\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n        bi...\n        ('CFLAGS', 'bar')...\n\n    * Entering an option formed by key=value pair\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [part]\n        ... recipe=minitage.recipe.cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... pre-make-hook    = ${buildout:directory}/hooks.py:pre_unpack_hook\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... environment=\n        ...     CFLAGS=myvalue\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n         bin/buildout -o install part...\n         minitage.recipe: Executing pre-make-hook\n         ('CFLAGS', 'myvalue')...\n\nAutogen can be your friend\n+++++++++++++++++++++++++++++\nIt is possible to autogenerate the configure files.\n\n        >>> data = \"\"\"\n        ... [buildout]\n        ... download-cache=${buildout:directory}\n        ... parts =\n        ...     part\n        ... [part]\n        ... recipe=minitage.recipe.cmmi\n        ... url = file://${buildout:directory}/foo.tgz\n        ... noconfigure = true\n        ... nomake = true\n        ... noinstall = true\n        ... autogen = configure\n        ... \"\"\"\n        >>> touch('buildout.cfg', data=data)\n        >>> sh('bin/buildout -o install part')\n        bin/buildout -o install part...\n        minitage.recipe: Auto generating configure files\n        minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure\n        configure...\n\nshared builds\n++++++++++++++++++++\nHandling shared mode as a backward compatibility with zc.recipe.cmmi.\n\n    >>> data = \"\"\"\n    ... [buildout]\n    ... download-cache=${buildout:directory}\n    ... parts =\n    ...     part\n    ... [part]\n    ... recipe=minitage.recipe.cmmi\n    ... url = file://${buildout:directory}/foo.tgz\n    ... shared = true\n    ... \"\"\"\n    >>> touch('buildout.cfg', data=data)\n    >>> sh('bin/buildout -o install part')\n    bin/buildout -o install part...\n    minitage.recipe: Running /tmp/buildout.test/__minitage__part__tmp/foo/configure --prefix=/tmp/buildout.test/minitage/cmmi/...\n\n\n=======================\nCHANGELOG\n=======================\n\n\n-> 1.36\n--------\n\n    - splitted out from minitage.recipe\n\n1.34\n-------\n\nall:\n\n    - fix rst doc\n\n    - add ``ldflags`` and ``ldflags`` options\n\nminitage.recipe.cmmi:\n\n    - ``install-in-place`` option added and pivot on make install slightly\n      modified\n    - ``skip-flags`` option added\n    - ``prefix`` option added\n\nminitage.recipe.fetch:\n\n    - ``unpack`` option added\n    - md5sum un revision for static fetcher check added\n\nminitage.recipe.printer:\n\n    - remove fake eggs and develop eggs from fixed versions.\n\n-> 1.20\n---------\n\nMinitage.recipe.egg:\n\n    - better errors handling\n    - In particular for eggs and url, now md5 urls are preferred.\n    - Also when we can't download a distribution from somewhere, we try to\n      fallback to other distributions which achieve the desired requirement\n    - In the same way, try to compile eggs from any other sdist fullfilling the\n      requirement if an error occurs on the first found.\n\nMinitage.recipe.cmmi:\n\n    - new patch selection for freebsd:\n        freebsd-patches\n\n    - Fix some double spaces left in compilation flags which broke some exotic\n      system builders.\n\n1.14\n-----\n\n    - add enrionment file generation to the scripts recipe\n\n1.13\n---------\n\n    - cmmi buggy update methods\n\n1.11 - 1.12\n----------------\n\n    - rescan egg direcrectories at install time because there may be new\n      develop eggs or eggs installed by buildout extensions (mr.developer)\n    - fix for interaction with buildout.minitagificator and\n      zc.buildout.easy_install..*script\n\n\n1.-1.10\n---------\n\n    - bugfix with cache and static distributions.\n\n1.8\n-------\n\n    - make patches go in a personnal directory with some md5 mecanism to redownload them.\n\n1.4->1.7\n----------\n\n    - x64 fixes\n    - bugfix in static distribution install when you have patches to apply.\n\n1.3\n----\n\n    - release uncomitted unittests updates\n\n1.2\n-------\n\n    - make it compatible with zc.buildout 1.0\n\n1.1\n-----\n\n    - md5 bug\n\n1.0\n------\n\n    * first stable release.\n    * All recipe are documented and well tested.\n    * buildout.minitagificator is completed.\n    * stabilized and synced with other minitage components\n    * minitage.recipe:eggs has been drasticly improved in term of algorythms and speed.\n\n0.33->0.34\n-----------\n\n    - Fix python executable computation\n\n0.32\n-----\n\n    - Documentation and tests release\n\n0.29\n----\n\n    - Fix bug in recipes initialization because of buildout auto-ordering\n\n\n0.28\n----\n\n    - Add another hook to the cmmi recipe: post-download\n\n0.27\n-----\n\n    - Fix an annoying bug when you are using virtualenv and a classical\n      python as executable in your recipe, it may occur that sometimes, the\n      virtualenv site-packages is appended to PYTHONPATH. As a fix, we now\n      filter all python core lib directories and site packages that are not\n      relevant to the python used by the recipe.\n\n0.26\n-----\n\n    - Introduce the minitage.recipe:wsgi recipe wich wraps a paste wsgi application\n      in a script eatable by mod_wsgi\n\n0.25\n------\n\n    - stop lowering project_name\n\n\n0.23->0.24\n-----------\n\n    - Fix small bugs in printer\n\n0.22\n-----\n\n    - Introduce a new recipe : minitage.recipe:printer which prints/dumps to a\n      file all versions eggs needed to achieve requirements.\n\n0.21\n-----\n\n    - Fix bug in compilation  directory guessing\n\n0.20\n------\n\n    - Fix bug in distribution reloading\n    - Better handling of pkg_resources's working set\n\n0.19\n--------\n\n    - add a post build hook\n\n0.18\n-------\n\n    - Change installation order\n\n0.16\n-------\n\n    - Fix index and find links options\n\n0.14 -> 0.15\n-------------\n    - logging output improved\n    - newest mode handling\n\n0.13\n-----\n- fix static dist install\n\n\n\n0.12\n------\n\n    - bugfix for zipped eggs\n\n0.11\n-----\n\n    - import bugfix for minitagificator\n\n0.10\n-----------\n\n    - Change some logging options\n    - follow allow host option from buildout for eggs installation\n\n0.9\n-----------\n\n    - Do not rely anymore on zc.buildout ez for script generation\n\n0.7 -> 0.8\n-----------\n\n    - egg and scripts recipes were rewritten a lot to adapt their api to\n      zc.recipe.egg\n    - Common to all recipes: all arguements are now identicak to zc.recipe.cmmi\n      or zc.recipe.egg\n    - Dependencies resolver has been improved a lot\n    - For static distribution, you can know speicify multiple urls with 'urls'\n\n\n0.6\n------\n\n    - fix bug in path generation in minitage.recipe:scripts\n\n0.2 -> 0.5\n-------------\n\n    - add make-options for make option in minitage.recipe.cmmi\n    - multiple bugfixes\n    - make things append in subprocess for environment conversation\n    - add initiaiization code for generated python interpreter in\n      minitage.recipe:scripts\n\n0.1\n------\n    - add fetch recipe\n\n0.0.13\n-------\n - fix zip safe flag\n\n0.0.11\n-------\n - Include eggs dependencies by default\n - Modulate the script recipe to append in the PYTHONPATH all egg dependencies\n   found into the local eggs cache.\n\n0.0.10\n-------\n - Add pyc regeneration feature stolen from zc.buildout\n\n0.0.9\n-------\n - minor fix for run without minitage\n - fix for long path/compilation flags\n\n0.0.8\n-------\n - minor fix for scm check outs\n\n0.0.7\n-------\n - add C compiler cflags/ldflags/makeopts customistation options\n\n0.0.6\n-------\n - Change the eggs installation way to do, now using easy_install everywhere\n   Also include a buildout option to allow to include eggs dependencies (ez-dependencies-true)\n - Set the __doc__ variable in scripts to fix some scripts like bzr.\n\n0.0.3\n-------\n - fix scm choice when there are eggs and url in the same part\n\n0.0.2\n------\n - bugfix version\n - fix linking problem\n\n0.0.1\n------\n - Initial version",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://cheeseshop.python.org/pypi/minitage.recipe.cmmi",
    "keywords": "development buildout recipe",
    "license": "BSD",
    "maintainer": null,
    "maintainer_email": null,
    "name": "minitage.recipe.cmmi",
    "package_url": "https://pypi.org/project/minitage.recipe.cmmi/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/minitage.recipe.cmmi/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "http://cheeseshop.python.org/pypi/minitage.recipe.cmmi"
    },
    "release_url": "https://pypi.org/project/minitage.recipe.cmmi/1.35/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "zc.buildout recipes to compile and install software or python packages and generate scripts or configuration files.",
    "version": "1.35",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 794814,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c073b2c483fbaa9540ebf6e6aab38cd9d866b88d9ccb36fb872c427c5a9b13d3",
        "md5": "b4c4d67fb4832955db2d5b4cbcac2f2f",
        "sha256": "96ca04cd6153f113bdcdc5d72f3a73168e5512af4954a0b050af3994f29589a2"
      },
      "downloads": -1,
      "filename": "minitage.recipe.cmmi-1.35.zip",
      "has_sig": false,
      "md5_digest": "b4c4d67fb4832955db2d5b4cbcac2f2f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 37286,
      "upload_time": "2009-08-18T19:06:21",
      "upload_time_iso_8601": "2009-08-18T19:06:21.001141Z",
      "url": "https://files.pythonhosted.org/packages/c0/73/b2c483fbaa9540ebf6e6aab38cd9d866b88d9ccb36fb872c427c5a9b13d3/minitage.recipe.cmmi-1.35.zip",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}