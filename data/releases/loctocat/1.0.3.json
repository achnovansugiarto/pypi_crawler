{
  "info": {
    "author": "celsius narhwal",
    "author_email": "hello@celsiusnarhwal.dev",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# loctocat\n\n[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/loctocat?logo=pypi&logoColor=white&style=for-the-badge)](https://pypi.org/project/loctocat)\n[![PyPI](https://img.shields.io/pypi/v/loctocat?color=green&logo=pypi&style=for-the-badge&logoColor=white)](https://pypi.org/project/loctocat)\n[![GitHub release (latest SemVer including pre-releases)](https://img.shields.io/github/v/release/celsiusnarhwal/loctocat?color=orange&include_prereleases&label=latest%20release&logo=github&style=for-the-badge)](https://github.com/celsiusnarhwal/loctocat/releases/latest)\n[![PyPI - License](https://img.shields.io/pypi/l/loctocat?color=03cb98&style=for-the-badge)](https://github.com/celsiusnarhwal/loctocat/blob/HEAD/LICENSE.md)\n\nloctocat brings simple yet flexible OAuth 2.0 device flow authentication to Python. It has built-in asyncio support\nand even predefined authenticators for popular services. Plus, it's fully compliant with\n[RFC 8628](https://tools.ietf.org/html/rfc8628), making it compatible with any OAuth2-supporting service that\n(correctly) implements the standard.\n\n## Installation\n\n```bash\npip install loctocat\n```\n\n## Basic Usage\n\n### The `Authenticator` Class\n\nEvery authentication flow starts with loctocat's `Authenticator` class.\n\n```python\nfrom loctocat import Authenticator\n\nauthenticator = Authenticator(\n    client_id=\"your_client_id\",\n    auth_url=\"https://example.com/oauth2/authorize\",\n    token_url=\"https://example.com/oauth2/token\",\n    scopes=[\"list\", \"of\", \"scopes\"],\n)\n```\n\nIt's pretty simple â€” just instantiate the class with your client ID, authorization URL (where you'll get your device\nand user codes), token URL (where you'll poll the authorization server for an access token), and a list of any scopes\nyou need.\n\nOnce you've got an `Authenticator`, getting an access token is as simple as:\n\n```python\ntoken = authenticator.authenticate()\n```\n\nWhoa. That was easy.\n\n`Authenticator.authenticate()` will, in order:\n\n1. Obtain device and user codes from the authorization server\n2. Prompt the user to visit the verficiation URL and enter the user code\n3. Poll the authorization server for an access token\n4. Return the access token as a string\n\nHere's an example of using `Authenticator` to authenticate with GitHub:\n\n```python\n# https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#device-flow\n\nfrom loctocat import Authenticator\n\nauthenticator = Authenticator(\n    client_id=\"github_client_id\",  # Replace this with your app's actual client ID, obviously.\n    auth_url=\"https://github.com/login/device/code\",\n    token_url=\"https://github.com/login/oauth/access_token\",\n    scopes=[\"repo\"],  # https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps\n)\n\ntoken = authenticator.authenticate()\n```\n\nLike I said, easy. Unless you're building an asynchronous application, in which case this doesn't work at all, since\n`Authenticator.authenticate()` is a blocking call. Fortunately, loctocat has you covered.\n\n### The `AsyncAuthenticator` Class\n\n`AsyncAuthenticator` is a subclass of `Authenticator` that functions exactly the same except all its methods are\nasynchronous (and therefore must be called with `await`). Here's an example of `AsyncAuthenticator` in action:\n\n```python\nfrom loctocat import AsyncAuthenticator\n\nauthenticator = AsyncAuthenticator(\n    client_id=\"your_client_id\",\n    auth_url=\"https://example.com/oauth2/authorize\",\n    token_url=\"https://example.com/oauth2/token\",\n    scopes=[\"list\", \"of\", \"scopes\"],\n)\n\ntoken = await authenticator.authenticate()\n```\n\nWhoa. That was easy.\n\n`AsyncAuthenticator.authenticate()` will, in orâ€”wait, I'm getting dÃ©jÃ  vu.\n\n## Advanced Usage\n\nMaybe `Authenticator.authenticate()` is too simplistic for you. Maybe you'd rather, I don't know,\nhandle the user-facing authentication prompt yourself, or control when loctocat starts polling for access tokens.\nFortunately, locotcat has you covered.\n\n(Keep in mind that `AsyncAuthenticator` is a subclass of `Authenticator` and inherits all of its methods and\nattributes.)\n\n### `Authenticator.ping()`\n\n`Authenticator.ping()` requests device and user codes from the authorization server, returning a `LoctocatAuthInfo`\nobject that looks like this:\n\n```py\nclass LoctocatAuthInfo:\n    device_code: str\n    user_code: str\n    verification_uri: str\n    expires_in: int\n    interval: int\n```\n\nPretty self-explanatory. You can do whatever you want with this information (aside from change it\nâ€” `LoctocatAuthInfo`'s attributes are read-only). For example, you could prompt the user with some custom text\ncontaining the user code and verification URI:\n\n```python\nauth_info = authenticator.ping()\n\nprint(f\"Check it out, yo! This is some epic text telling YOU to go {auth_info.verification_uri} and enter {auth_info.user_code}! Swag!\")\n```\n\n### `Authenticator.poll()`\n\n`Authenticator.poll()` polls the authorization server for an access token, returning it as a string. You **don't**\nneed to pass the `LoctocatAuthInfo` object returned by `Authenticator.ping()` to `Authenticator.poll()` â€” the\nauthorization info is automatically remembered by `Authenticator`. All you have to do is call the method:\n\n```python\n# Authenticator.ping() must have been called on the Authenticator object already or this will not work.\n\ntoken = authenticator.poll()\n```\n\nWhoa. That was easy.\n\n(Fun fact: `Authenticator.authenticate()` is just a wrapper around `ping()` and `poll()`.)\n\n## Pro Usage\n\nMaybe [Advanced Usage](#advanced-usage) isn't advanced enough for you. Maybe you're working with an authorization\nserver that requires parameters beyond those defined by `Authenticator`. Maybe you want to customize the prompts and\nmessages displayed by `Authenticator.authenticate()` without having to use `Authenticator.ping()` and\n`Authenticator.poll()`. Maybe loctocat has a predefined authenticator for a service you like, and you want to use it.\nUnfortunately, loctocat doesn't have you covered.\n\n...\n\nOkay, loctocat actually does have you covered, but that stuff is the domain of loctocat's unfinished documentation\nsite. Emphasis on unfinished. It's not finished yet.\n\nFortunately, loctocat has you covered. loctocat's a pretty small library and it's public modules and classes are all\nproperly documented in the source code, so you're welcome to learn by example(?) and take a look around.\n\nOr you could wait until I finish the documentation site. I'm not your mother.\n\n## FAQ\n\nMaybe you have questions about loctocat that haven't been answered by the rest of this README. Maybe you just want to see me talk to\nmyself for like, two paragraphs. Fortunately, loctocat has you covered.\n\n### Q: loctowhat now\n\nA: Lock + [Octocat](https://octodex.github.com). loctocat was born out of my need for a Python library that implemented\nOAuth 2.0 device flow authentication for GitHub.\n\n### Q: pretty sure I can do this with requests-oauthlib or [INSERT OAUTH LIBRARY HERE] just fine dude\n\nA: Sure you can. In fact, loctocat uses requests and oauthlib under the hood. So let's leave loctocat behind and\nwrite a function to authenticate with GitHub using requests and oauthlib, together!\n\n```python\nimport time\n\nimport requests\nfrom oauthlib.oauth2 import DeviceClient\n\ndef authenticate_with_github(client_id: str, scopes: list[str]) -> str:\n    auth_url = \"https://github.com/login/device/code\"\n    token_url = \"https://github.com/login/oauth/access_token\"\n    client = DeviceClient(client_id=client_id, scope=scopes)\n    \n    ping_uri = client.prepare_request_uri(auth_url)\n    response = requests.post(ping_uri, headers={\"Accept\": \"application/json\"}).json()\n    \n    poll_uri = client.prepare_request_uri(token_url, code=response[\"device_code\"])\n    while True:\n        response = requests.post(poll_uri, headers={\"Accept\": \"application/json\"}).json()\n        \n        if \"error\" in response:\n            if response[\"error\"] in [\"authorization_pending\", \"slow_down\"]:\n                time.sleep(response[\"interval\"])\n                continue\n            else:\n                raise RuntimeError(response[\"error\"])\n        else:\n            return response[\"access_token\"]\n```\n\nDamn, that plate can boil!\n\nNow let's do the same thing, but with loctocat.\n\n```python\nfrom loctocat.predefined import GitHubAuthenticator\n\ndef authenticate_with_github(client_id: str, scopes: list[str]) -> str:\n    authenticator = GitHubAuthenticator(client_id=client_id, scopes=scopes)\n    return authenticator.authenticate()\n\n# \"Hey, that's cheating!\" Fine, let's do it the hard way.\n\nfrom loctocat import Authenticator\n\ndef authenticate_with_github(client_id: str, scopes: list[str]) -> str:\n    authenticator = Authenticator(\n        client_id=client_id,\n        auth_url=\"https://github.com/login/device/code\",\n        token_url=\"https://github.com/login/oauth/access_token\",\n        scopes=scopes\n    )\n    \n    return authenticator.authenticate()\n```\n\nWhoa. That was easy.\n\nPart of the reason I made loctocat is that no other library capable of doing what loctocat does does it in a way that\ndoesn't SUCK. The first example SUCKS. The second example is AWESOME. Case closed.\n\n\n### Q: loctocat isn't working with [INSERT SERVICE HERE] and I'm FRUSTRATED AAAAGGGGGGHHHHH\n\nA: loctocat is compliant with the OAuth 2.0 Device Authorization Grant standard so it's probably the service's fault.\nMake sure the service actually does support the device flow and is generally compliant with RFC 8628. If you're sure\nloctocat is the problem, [open an issue](https://github.com/celsiusnarhwal/loctocat/issues/new).\n\n### Q: oh my god thank you I've been looking for a library like this forever you have no idea\n\nA: You're very welcome. ðŸ™‚\n\n## License\n\nIn an age where developers must take great caution not to tread on the intellectual property of others, you must be\nhoping that a such an incredible library is made available under a permissive license. Fortunately,\nloctocat has you covered.\n\nloctocat is licensed under the [MIT License](https://github.com/celsiusnarhwal/loctocat/blob/HEAD/LICENSE.md).\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/celsiusnarhwal/loctocat",
    "keywords": "oauth,oauth2,authentication,device-flow,asyncio",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "loctocat",
    "package_url": "https://pypi.org/project/loctocat/",
    "platform": null,
    "project_url": "https://pypi.org/project/loctocat/",
    "project_urls": {
      "Homepage": "https://github.com/celsiusnarhwal/loctocat",
      "Repository": "https://github.com/celsiusnarhwal/loctocat"
    },
    "release_url": "https://pypi.org/project/loctocat/1.0.3/",
    "requires_dist": [
      "requests (>=2.28.1,<3.0.0)",
      "oauthlib (>=3.2.2,<4.0.0)",
      "halo (>=0.0.31,<0.0.32)",
      "termcolor (>=2.1.1,<3.0.0)",
      "aiohttp (>=3.8.3,<4.0.0)"
    ],
    "requires_python": ">=3.8,<4.0",
    "summary": "Simple yet flexible OAuth 2.0 device flow authentication for Python",
    "version": "1.0.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15894223,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9e384b628515c740dd31b32f7704a1d69392b19f2e424068eec705ffbefa6314",
        "md5": "823c808cfe13e3c7c6fb0786458502f5",
        "sha256": "903285c98ad3b806735a5b5dca2c65c084caffb8e5ffdb8817b4371de47633e0"
      },
      "downloads": -1,
      "filename": "loctocat-1.0.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "823c808cfe13e3c7c6fb0786458502f5",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8,<4.0",
      "size": 14223,
      "upload_time": "2022-11-25T22:15:23",
      "upload_time_iso_8601": "2022-11-25T22:15:23.343401Z",
      "url": "https://files.pythonhosted.org/packages/9e/38/4b628515c740dd31b32f7704a1d69392b19f2e424068eec705ffbefa6314/loctocat-1.0.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ebb38adb71fe77384c22851c73f04ee4951ea7f45a4762da818d90dbeffc5ebc",
        "md5": "d5b6f8196b8d3ba5e039d2ce2a80b90a",
        "sha256": "ddb1131c5d8c3564f9f3eda074413c70fa82c0fd3dcb6a15401d0ffea980af48"
      },
      "downloads": -1,
      "filename": "loctocat-1.0.3.tar.gz",
      "has_sig": false,
      "md5_digest": "d5b6f8196b8d3ba5e039d2ce2a80b90a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8,<4.0",
      "size": 12278,
      "upload_time": "2022-11-25T22:15:24",
      "upload_time_iso_8601": "2022-11-25T22:15:24.779082Z",
      "url": "https://files.pythonhosted.org/packages/eb/b3/8adb71fe77384c22851c73f04ee4951ea7f45a4762da818d90dbeffc5ebc/loctocat-1.0.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}