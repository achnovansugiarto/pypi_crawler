{
  "info": {
    "author": "Wes Kendall",
    "author_email": "wesleykendall@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Django",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "[![Build Status](https://travis-ci.org/ambitioninc/django-entity.svg)](https://travis-ci.org/ambitioninc/django-entity)\n# Django Entity - [Release Notes](release_notes.md)\n\nDjango Entity is an app that provides Django projects with the ability to mirror their entities and entity relationships in a separate, well-contained and easily-accessible table. Only PostgreSQL is supported.\n\nDjango Entity provides large-scale projects with the ability to better segregate their apps while minimizing the application-specific code in those apps that has to deal with entities and their relationships in the main project.\n\nWhat is an entity? An entity is any model in your Django project. For example, an entity could be a Django User model or a Group of Users. Similarly, an entity relationship defines a super and sub relationship among different types of entities. For example, a Group would be a super entity of a User. The Django Entity app allows you to easily express this relationship in your model definition and sync it to a centralized place that is accessible by any other app in your project.\n\n## A Use Case\nImagine that you have a Django project that defines many types of groupings of your users. For example, let's say in your enterprise project, you allow users to define their manager, their company position, and their regional branch location. Similarly, let's say that you have an app that can email groups of users based on their manager (or anyone who is under the managers of that manager), their position, or their region. This email app would likely have to know application-specific modeling of these relationships in order to be built. Similarly, doing things like querying for all users under a manager hierachy can be an expensive lookup depending on how it is modeled.\n\nUsing Django Entity, the email app could be written to take an Entity model rather than having to understand the complex relationships of each group. The Entity model passed to the email app could be a CompanyPosition model, and the get_sub_entities().is_any_type(ContentType.objects.get_for_model(User)) would return all of the User models under that CompanyPosition model. This allows the email app to be completely segregated from how the main project defines its relationships. Similarly, the query to obtain all User models under a CompanyPosition could be much more efficient than querying directly from the project (depending on how the project has its models structured).\n\n## Getting Started - Configuring Entity Syncing\n### Basic Use Case\n\nInstall using `pip`:\n\n```python\npip install django-entity\n```\n\nAdd 'entity' to your INSTALLED_APPS setting:\n\n```python\nINSTALLED_APPS = [\n    ...\n    'entity',\n]\n```\n\nSimilar to Django's model admin, entities are configured by registering them with the Entity registry as follows:\n\n```python\nfrom entity.config import EntityConfig, register_entity\n\n\nclass Account(Model):\n    email = models.CharField(max_length=64)\n\n\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n```\n\nAnd just like that, the ``Account`` model is now synced to the ``Entity`` table every time an account is saved, deleted, or has any of its M2M fields updated.\n\n### More Advanced Syncing Options\nDjango Entity would not be much if it only synced objects to a single ``Entity`` table. In order to take advantage of the power of mirroring relationships, the user must define a configuration for the entity that inherits ``EntityConfig``. A small example of this is below and extends our account model to have a ``Group`` foreign key.\n\n```python\nfrom entity.config import register_entity, EntityConfig\n\n\nclass Account(Model):\n    email = models.CharField(max_length=64)\n    group = models.ForeignKey(Group)\n\n\n@register_entity()\nclass GroupConfig(EntityConfig):\n    queryset = Group.objects.all()\n\n\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n\n    def get_super_entities(self, model_objs):\n        return {\n            Group: [(model_obj.id, model_obj.group_id) for model_obj in model_objs]\n        }\n```\n\nIn the above scenario, we mirrored the ``Group`` model using the default entity configuration. However, the ``Account`` model now uses a special configuration that inherits ``EntityConfig``. It overrides the ``get_super_entities`` function to return a list of all model objects that are super entities to the account. Once the account is synced, the user may then do various filtering on the relationships of accounts to groups (more on that later).\n\nNote - in the above example, we also used the ``register_entity`` decorator, which is really just short notation for doing ``entity_registry.register_entity(model_class, entity_config_class)``.\n\nAlong with the ability to mirror relationships, the entity configuration can be extended to mirror metadata about an entity. For example, using the ``Account`` model in the previous example:\n\n```python\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n\n    def get_super_entities(self, model_objs):\n        return {\n            Group: [(model_obj.id, model_obj.group_id) for model_obj in model_objs]\n        }\n\n    def get_entity_meta(self, model_obj):\n        return {\n            'email': model_obj.email\n        }\n```\n\nWith the above configuration, every account entity will have an entity_meta field (a JSON field) that has the email attribute mirrored as well. The metadata mirroring can be powerful for building generic apps on top of entities that need access to concrete fields of a concrete model (without having to prefetch all of the concrete models pointed to by the entities).\n\nAlong with metadata, entities come with the ability to mirror a ``display_name`` field in order to provide a human-readable name for the entity that can also be filtered in the database. By default, the ``display_name`` field uses the result of the ``unicode()`` function applied to the concrete model instance. The user may override this behavior by overriding the ``get_display_name`` method in the entity configuration.\n\nEntities can also be configured to be active or inactive, and this is done by adding an ``get_is_active`` function to the config that returns ``True`` (the default value) if the entity is active and ``False`` otherwise.\n\n### Advanced Syncing Continued - Entity Kinds\n\nEntities have the ability to be labeled with their \"kind\" for advanced filtering capabilities. The entity kind allows a user to explicitly state what type of entity is being mirrored along with providing human-readable content about the entity kind. This is done by mirroring a unique ``name`` field and a ``display_name`` field in the ``EntityKind`` object that each ``Entity`` model points to.\n\nBy default, Django Entity will mirror the content type of the entity as its kind. The name field will be the ``app_label`` of the content type followed by a dot followed by the ``model`` of the content type. For cases where this name is not descriptive enough for the kind of the entity, the user has the ability to override the ``get_entity_kind`` function in the entity config. For example:\n\n```python\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n\n    def get_entity_kind(self, model_obj):\n        return (model_obj.email_domain, 'Email domain {0}'.format(model_obj.email_domain))\n```\n\nIn the above case, the account entities are segregated into different kinds based on the domain of the email. The second value of the returned tuple provides a human-readable version of the kind that is being created.\n\n### Even More Advanced Syncing - Watching Other Models\n\nUnderneath the hood, Django Entity is syncing up the mirrored Entity table when saves, deletes, and M2M updates are happening on the mirrored models. However, some models may actually depend on objects that are not pointed to by the immediate fields of the model. For example, assume that we have the following models:\n\n```python\nclass Group(models.Model):\n    group_name = models.CharField()\n\n\nclass User(models.Model):\n    email = models.CharField()\n    groups = models.ManyToManyField(Group)\n\n\nclass Account(models.Model):\n    user = models.OneToOneField(User)\n```\n\nNow, assume that the ``Account`` model wants to add every ``Group`` model in the many to many of the ``User`` model as its super entity. This would be set up with the following config:\n\n```python\n@register_entity()\nclass GroupConfig(EntityConfig):\n    queryset = Group.objects.all()\n\n\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n\n    def get_super_entities(self, model_objs):\n        return {\n            Group: [\n                (model_obj.id, group.id)\n                for model_obj in model_objs\n                for group in model_obj.user.groups.all()\n            ]\n        }\n```\n\nAlthough it would be nice if this worked out of the box, Django Entity has no way of knowing that the ``Account`` model needs to be updated when the fields in its associated ``User`` model change. In order to ensure the ``Account`` model is mirrored properly, add a ``watching`` class variable to the entity config as follows:\n\n```python\n@register_entity()\nclass GroupConfig(EntityConfig):\n    queryset = Group.objects.all()\n\n\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.all()\n    watching = [\n        (User, lambda user_obj: Account.objects.filter(user=user_obj)),\n    ]\n\n    def get_super_entities(self, model_objs):\n        return {\n            Group: [\n                (model_obj.id, group.id)\n                for model_obj in model_objs\n                for group in model_obj.user.groups.all()\n            ]\n        }\n```\n\nThe ``watching`` field defines a list of tuples. The first element in each tuple represents the model to watch. The second element in the tuple describes the function used to access the entity models that are related to the changed watching model.\n\nHere's another more complex example using an ``Address`` model that points to an account.:\n\n```python\nclass Address(models.Model):\n    account = models.ForeignKey(Account)\n```\n\nTo make the Address model sync when the ``User`` model of the ``Account`` model is changed, define an entity configuration like so:\n\n```python\n@register_entity()\nclass AddressConfig(EntityConfig):\n    queryset = Address.objects.all()\n    watching = [\n        (User, lambda user_model_obj: Address.objects.filter(account__user=user_model_obj)),\n    ]\n```\n\nAgain, all that is happening under the hood is that when a ``User`` model is changed, all entity models related to that changed user model are returned so that they can be sycned.\n\n### Ensuring Entity Syncing Optimal Queries\nSince a user may need to mirror many different super entities from many different foreign keys, it is beneficial for them to provide caching hints to Django Entity. This can be done by simply providing a prefetched Django QuerySet to the ``queryset`` attribute in the entity config. For example, our previous account entity config would want to do the following:\n\n```python\n@register_entity()\nclass AccountConfig(EntityConfig):\n    queryset = Account.objects.prefetch_related('user__groups')\n```\n\nWhen invididual entities or all entities are synced, the QuerySet will be used to access the ``Account`` models and passed to relevent methods of the entity config.\n\n\n## Syncing Entities\nModels will be synced automatically when they are configured and registered with Django entity. However, the user will need to sync all entities initially after configuring the entities (and also subsequently resync all when configuration changes occur). This can be done with the sync_entities management command:\n\n```python\n# Sync all entities\npython manage.py sync_entities\n```\n\nSimilarly, you can directly call the function to sync entities in a celery processing job or in your own application code.\n\n```python\nfrom entity.sync import sync_entities\n\n# Sync all entities\nsync_entities()\n```\n\nNote that the ``sync_entities()`` function takes a variable length list of model objects if the user wishes to sync individual entities:\n\n```python\nfrom entity.sync import sync_entities\n\n# Sync three specific models\nsync_entities(account_model_obj, group_model_obj, another_model_obj)\n```\n\nEntity syncing can be costly depending on the amount of relationships mirrored. If the user is going to be updating many models in a row that are mirrored as entities, it is recommended to turn syncing off, explicitly sync all updated entities, and then turn syncing back on. This can be accomplished as follows:\n\n```python\nfrom entity.signal_handlers import turn_on_syncing, turn_off_syncing\nfrom entity.sync import sync_entities\n\n\n# Turn off syncing since we're going to be updating many different accounts\nturn_off_syncing()\n\n# Update all of the accounts\naccounts_to_update = [list of accounts]\nfor account in accounts_to_update:\n    account.update(...)\n\n# Explicitly sync the entities updated to keep the mirrored entities up to date\nsync_entities(*accounts_to_update)\n\n# Dont forget to turn syncing back on...\nturn_on_syncing()\n```\n\n## Accessing Entities\nAfter the entities have been synced, they can then be accessed in the primary entity table. The ``Entity`` model has the following fields:\n\n1. ``entity_type``: The ``ContentType`` of the mirrored entity.\n1. ``entity_id``: The object ID of the mirrored entity.\n1. ``entity_meta``: A JSONField of mirrored metadata about an entity (or null or none mirrored).\n1. ``entity_kind``: The EntityKind model that describes the type of mirrored entity. Defaults to parameters related to the entity content type.\n1. ``is_active``: True if the entity is active, False otherwise.\n\nAlong with these basic fields, all of the following functions can either be called directly on the ``Entity`` model or on the ``Entity`` model manager.\n\n### Basic Model and Manager Functions\nNote that since entities are activatable (i.e. can have active and inactive states), the entity model manager only accesses active entities by default. If the user wishes to access every single entity (active or inactive), they must go through the ``all_objects`` manager, which is used in the example code below. The methods below are available on the ``objects`` and ``all_objects`` model managers, although the ``active`` and ``inactive`` methods are not useful on the ``objects`` model manager since it already filters for active entities.\n\n#### get_for_obj(model_obj)\nThe get_for_obj function takes a model object and returns the corresponding entity. Only available in the ``Entity`` model manager.\n\n```python\ntest_model = TestModel.objects.create()\n# Get the resulting entity for the model object\nentity = Entity.objects.get_for_obj(test_model)\n```\n\n#### active()\nReturns active entities. Only applicable when using the ``all_objects`` model manager. Note that ``objects`` already filters for only active entities.\n\n#### inactive()\nDoes the opposite of ``active()``. Only applicable when using the ``all_objects`` model manager. Note that ``objects`` already disregards inactive entities.\n\n#### is_any_kind(*entity_kinds)\nReturns all entities that are any of the entity kinds provided.\n\n#### is_not_any_kind(*entity_kinds)\nThe opposite of ``is_any_kind()``.\n\n#### is_sub_to_all(*super_entities)\nReturn entities that are sub entities of every provided super entity (or all if no super entities are provided).\n\nFor example, if one wishes to filter all of the Account entities by the ones that belong to Group A and Group B, the code would look like this:\n\n```python\ngroupa_entity = Entity.objects.get_for_obj(Group.objects.get(name='A'))\ngroupb_entity = Entity.objects.get_for_obj(Group.objects.get(name='B'))\nfor e in Entity.objects.is_sub_to_all(groupa_entity, groupb_entity):\n    # Do your thing with the results\n    pass\n```\n\n#### is_sub_to_any(*super_entities)\nReturn entities that are sub entities of any one of the provided super entities (or all if no super entities are provided).\n\n#### is_sub_to_all_kinds(*super_entity_kinds)\nReturn entities for which the set of provided kinds is contained in the set of all their super-entity-kinds\n\n#### is_sub_to_any_kind(*super_entity_kinds)\nReturn entities that have at least one super entity-kind contained in the provided set of kinds (or all if no kinds are provided)\n\n#### cache_relationships()\nThe cache_relationships function is useful for prefetching relationship information. Accessing entities without the cache_relationships function will result in many extra database queries if filtering is performed on the entity relationships.\n\n```python\nentity = Entity.objects.cache_relationships().get_for_obj(test_model)\nfor super_entity in entity.get_super_entities():\n    # Perform much faster accesses on super entities...\n    pass\n```\n\nIf one wants to ignore caching sub or super entity relationships, simply pass ``cache_sub=False`` or ``cache_super=False`` as keyword arguments to the function. Note that both of these flags are turned on by default.\n\n### Chaining Filtering Functions\nAll of the manager functions listed can be chained, so it is possible to do the following combinations:\n\n```python\nEntity.objects.is_sub_to_all(groupa_entity).is_active().is_any_kind(account_kind, team_kind)\n\nEntity.objects.inactive().is_sub_to_all(groupb_entity).cache_relationships()\n```\n\n## Arbitrary groups of Entities\n\nOnce entities and their relationships are syncing is set up, most groupings of entities will be automatically encoded with the super/sub entity relationships. However, there are occasions when the groups that are automatically encoded do not capture the full extent of groupings that are useful.\n\nIn order to support arbitrary groups of entities without requiring additional syncing code, the `EntityGroup` model is provided. This model comes with convenience functions for adding and removing entities to a group, as well as methods for querying what entities are in the arbitrary group.\n\nIn addition to adding individual entities to an EntityGroup, you can also add all of an entity's sub-entities with a given type to the `EntityGroup` very easily. The following does the following:\n\n1. Creates an `EntityGroup`\n2. Adds an individual entity to the group\n3. Adds all the subentities of a given kind to the group\n4. Queries for all the entities in the group\n\n```python\nmy_group = EntityGroup.objects.create()\n\nmy_group.add_entity(entity=some_entity)\nmy_group.add_entity(entity=some_super_entity, sub_entity_kind=some_entity_kind)\n\nall_entities_in_group = my_group.all_entities()\n```\n\nAfter the code above is run, `all_entities_in_group` will be a\nQueryset of `Entity`s that contains the entity `some_entity` as well\nas all the sub-entities of `some_super_entity` who's entity-kind is\n`some_entity_kind`.\n\nThe following methods are available on `EntityGroup`s\n\n#### all_entitites\n\nGet a list of all individual entities in the group. This will pull out\nall the entities that have been added, combining all the entities that\nwere added individually as well as all the entities that were added\nbecause they are sub-entities to a super-entity that was added the the\ngroup, with the specified entity kind.\n\n#### add_entity\n\nAdd an individual entity, or all the sub-entities (with a given kind)\nof a super-entity to the group. There are two ways to add entities to\nthe group with this method. The first adds an individual entity to the\ngroup. The second adds all the individuals who are a super-entity's\nsub-entities of a given kind to the group.\n\nThis allows leveraging existing groupings as well as allowing other\narbitrary additions. Both individual, and sub-entity group memberships\ncan be added to a single `EntityGroup`.\n\nThe syntax for adding an individual entity is as simple as specifying\nthe entity to add:\n\n```python\nmy_group.add(some_entity)\n```\n\nAnd adding a sub-entity group is as simple as specifying the\nsuper-entity and the sub-entity kind:\n\n```python\nmy_group.add(entity=some_entity, sub_entity_kind=some_entity_kind)\n```\n\n#### bulk_add_entities\n\nAdd a number of entities, or sub-entity groups to the\n`EntityGroup`. It takes a list of tuples, where the first item in the\ntuple is an `Entity` instance, and the second is either an\n`EntityKind` instance or `None`.\n\n```python\nmy_group.bulk_add_entities([\n    (some_entity_1, None),\n    (some_entity_2, None),\n    (some_super_entity_1, some_entity_kind)\n    (some_super_entity_2, other_entity_kind)\n])\n```\n\n#### remove_entitiy\n\nRemoves a given entity, or sub-entity grouping from the\n`EntityGroup`. This method uses the same syntax of `add_entity`.\n\n### bulk_remove_entities\n\nRemoves a number of entities or sub-entity groupings from the\n`EntityGroup`. This method uses the same syntax as\n`bulk_add_entities`.\n\n#### bulk_overwrite\n\nThis method replaces all of the group members with a new set of group\nmembers. It has the same syntax as ``bulk_add_entities``.\n\n## License\nMIT License (see the LICENSE file for more info).\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://github.com/ambitioninc/django-entity/",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "django-entity",
    "package_url": "https://pypi.org/project/django-entity/",
    "platform": "",
    "project_url": "https://pypi.org/project/django-entity/",
    "project_urls": {
      "Homepage": "http://github.com/ambitioninc/django-entity/"
    },
    "release_url": "https://pypi.org/project/django-entity/5.0.0/",
    "requires_dist": [
      "Django (>=2.2)",
      "django-activatable-model (>=2.0.0)",
      "django-manager-utils (>=2.0.0)",
      "jsonfield (>=0.9.20)",
      "python3-utils (>=0.3)",
      "wrapt (>=1.10.5)",
      "coverage (==4.5.1) ; extra == 'dev'",
      "django-nose (==1.4.5) ; extra == 'dev'",
      "django-dynamic-fixture ; extra == 'dev'",
      "mock (==2.0.0) ; extra == 'dev'",
      "psycopg2 (>=2.7.7) ; extra == 'dev'"
    ],
    "requires_python": "",
    "summary": "Entity relationship management for Django",
    "version": "5.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16552897,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "df27c6d02741746372d69bca3fe8ac04be38435bc11d20c0d3f35d82e6091a0f",
        "md5": "2b24897068f4df19f8cc41142f95774d",
        "sha256": "fec907c9b3bdfb550ec36d37d168273e73e912b5a485db2196c257dd626b924e"
      },
      "downloads": -1,
      "filename": "django_entity-5.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2b24897068f4df19f8cc41142f95774d",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": null,
      "size": 45561,
      "upload_time": "2020-12-29T06:49:57",
      "upload_time_iso_8601": "2020-12-29T06:49:57.010762Z",
      "url": "https://files.pythonhosted.org/packages/df/27/c6d02741746372d69bca3fe8ac04be38435bc11d20c0d3f35d82e6091a0f/django_entity-5.0.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5f5ed689854593735ace0c40ecd6bd5c5bb9ca3df31cf14b46dab3037ee6d524",
        "md5": "485015ef5655d73e778a9d57bf5a7a9a",
        "sha256": "0b76110b8560e20d449b80f505c7ada2d7f0c4ecd08e34a7e4660b900cf6f05b"
      },
      "downloads": -1,
      "filename": "django-entity-5.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "485015ef5655d73e778a9d57bf5a7a9a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 44444,
      "upload_time": "2020-12-29T06:49:58",
      "upload_time_iso_8601": "2020-12-29T06:49:58.609154Z",
      "url": "https://files.pythonhosted.org/packages/5f/5e/d689854593735ace0c40ecd6bd5c5bb9ca3df31cf14b46dab3037ee6d524/django-entity-5.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}