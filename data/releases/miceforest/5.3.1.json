{
  "info": {
    "author": "Samuel Wilson",
    "author_email": "samwilson303@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: MacOS",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "\n[![Build\nStatus](https://travis-ci.com/AnotherSamWilson/miceforest.svg?branch=master)](https://travis-ci.com/AnotherSamWilson/miceforest)\n[![Documentation\nStatus](https://readthedocs.org/projects/miceforest/badge/?version=latest)](https://miceforest.readthedocs.io/en/latest/?badge=latest)\n[![MIT\nlicense](http://img.shields.io/badge/license-MIT-brightgreen.svg)](http://opensource.org/licenses/MIT)\n[![CodeCov](https://codecov.io/gh/AnotherSamWilson/miceforest/branch/master/graphs/badge.svg?branch=master&service=github)](https://codecov.io/gh/AnotherSamWilson/miceforest)\n[![Code style:\nblack](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)  \n[![DEV\\_Version\\_Badge](https://img.shields.io/badge/Dev-5.3.0-blue.svg)](https://pypi.org/project/miceforest/)\n[![Pypi](https://img.shields.io/pypi/v/miceforest.svg)](https://pypi.python.org/pypi/miceforest)\n[![Conda\nVersion](https://img.shields.io/conda/vn/conda-forge/miceforest.svg)](https://anaconda.org/conda-forge/miceforest)\n[![PyVersions](https://img.shields.io/pypi/pyversions/miceforest.svg?logo=python&logoColor=white)](https://pypi.org/project/miceforest/)\n[![Downloads](https://pepy.tech/badge/miceforest/month)](https://pepy.tech/project/miceforest)\n\n## miceforest: Fast, Memory Efficient Imputation with lightgbm\n\n<a href='https://github.com/AnotherSamWilson/miceforest'><img src='https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/icon.png' align=\"right\" height=\"300\" /></a>\n\nFast, memory efficient Multiple Imputation by Chained Equations (MICE)\nwith lightgbm. The R version of this package may be found\n[here](https://github.com/FarrellDay/miceRanger).\n\n`miceforest` was designed to be:\n\n  - **Fast** Uses lightgbm as a backend, and has efficient mean matching\n    solutions.\n  - **Memory Efficient** Capable of performing multiple imputation\n    without copying the dataset. If the dataset can fit in memory, it\n    can (probably) be imputed.\n  - **Flexible** Can handle pandas DataFrames and numpy arrays. The\n    imputation process can be completely customized. Can handle\n    categorical data automatically.\n  - **Used In Production** Kernels can be saved (recommended using the\n    dill package) and impute new, unseen datasets. Imputing new data is\n    often orders of magnitude faster than including the new data in a\n    new `mice` procedure. Imputation models can be built off of a kernel\n    dataset, even if there are no missing values. New data can also be\n    imputed in place.\n\nThis document contains a thorough walkthrough of the package,\nbenchmarks, and an introduction to multiple imputation. More information\non MICE can be found in Stef van Buuren’s excellent online book, which\nyou can find\n[here](https://stefvanbuuren.name/fimd/ch-introduction.html).\n\n#### Table of Contents:\n\n  - [Package\n    Meta](https://github.com/AnotherSamWilson/miceforest#Package-Meta)\n  - [The\n    Basics](https://github.com/AnotherSamWilson/miceforest#The-Basics)\n      - [Basic\n        Examples](https://github.com/AnotherSamWilson/miceforest#Basic-Examples)\n      - [Controlling Tree\n        Growth](https://github.com/AnotherSamWilson/miceforest#Controlling-Tree-Growth)\n      - [Preserving Data\n        Assumptions](https://github.com/AnotherSamWilson/miceforest#Preserving-Data-Assumptions)\n      - [Imputing With Gradient Boosted\n        Trees](https://github.com/AnotherSamWilson/miceforest#Imputing-With-Gradient-Boosted-Trees)\n  - [Advanced\n    Features](https://github.com/AnotherSamWilson/miceforest#Advanced-Features)\n      - [Customizing the Imputation\n        Process](https://github.com/AnotherSamWilson/miceforest#Customizing-the-Imputation-Process)\n      - [Imputing New Data with Existing\n        Models](https://github.com/AnotherSamWilson/miceforest#Imputing-New-Data-with-Existing-Models)\n      - [Building Models on Nonmissing\n        Data](https://github.com/AnotherSamWilson/miceforest#Building-Models-on-Nonmissing-Data)\n      - [Tuning\n        Parameters](https://github.com/AnotherSamWilson/miceforest#Tuning-Parameters)\n      - [On\n        Reproducibility](https://github.com/AnotherSamWilson/miceforest#On-Reproducibility)\n      - [How to Make the Process\n        Faster](https://github.com/AnotherSamWilson/miceforest#How-to-Make-the-Process-Faster)\n      - [Imputing Data In\n        Place](https://github.com/AnotherSamWilson/miceforest#Imputing-Data-In-Place)\n      - [Saving and Loading\n        Kernels](https://github.com/AnotherSamWilson/miceforest#Saving-and-Loading-Kernels)\n  - [Diagnostic\n    Plotting](https://github.com/AnotherSamWilson/miceforest#Diagnostic-Plotting)\n      - [Imputed\n        Distributions](https://github.com/AnotherSamWilson/miceforest#Distribution-of-Imputed-Values)\n      - [Correlation\n        Convergence](https://github.com/AnotherSamWilson/miceforest#Convergence-of-Correlation)\n      - [Variable\n        Importance](https://github.com/AnotherSamWilson/miceforest#Variable-Importance)\n      - [Mean\n        Convergence](https://github.com/AnotherSamWilson/miceforest#Variable-Importance)\n  - [Using the Imputed\n    Data](https://github.com/AnotherSamWilson/miceforest#Using-the-Imputed-Data)\n  - [The MICE\n    Algorithm](https://github.com/AnotherSamWilson/miceforest#The-MICE-Algorithm)\n      - [Introduction](https://github.com/AnotherSamWilson/miceforest#The-MICE-Algorithm)\n      - [Common Use\n        Cases](https://github.com/AnotherSamWilson/miceforest#Common-Use-Cases)\n      - [Predictive Mean\n        Matching](https://github.com/AnotherSamWilson/miceforest#Predictive-Mean-Matching)\n      - [Effects of Mean\n        Matching](https://github.com/AnotherSamWilson/miceforest#Effects-of-Mean-Matching)\n\n## Package Meta\n\n### News\n\nNew Major Update = 5.0.0\n\n  - New main classes (`ImputationKernel`, `ImputedData`) replace\n    (`KernelDataSet`, `MultipleImputedKernel`, `ImputedDataSet`,\n    `MultipleImputedDataSet`).  \n  - Data can now be referenced and imputed in place. This saves a lot of\n    memory allocation and is much faster.  \n  - Data can now be completed in place. This allows for only a single\n    copy of the dataset to be in memory at any given time, even if\n    performing multiple imputation.  \n  - `mean_match_subset` parameter has been replaced with `data_subset.`\n    This subsets the data used to build the model as well as the\n    candidates.  \n  - More performance improvements around when data is copied and where\n    it is stored.  \n  - Raw data is now stored as the original. Can handle pandas\n    `DataFrame` and numpy `ndarray`.\n\n### Installation\n\nThis package can be installed using either pip or conda, through\nconda-forge:\n\n``` bash\n# Using pip\n$ pip install miceforest --no-cache-dir\n\n# Using conda\n$ conda install -c conda-forge miceforest\n```\n\nYou can also download the latest development version from this\nrepository. If you want to install from github with conda, you must\nfirst run `conda install pip git`.\n\n``` bash\n$ pip install git+https://github.com/AnotherSamWilson/miceforest.git\n```\n\n### Classes\n\nmiceforest has 2 main classes which the user will interact with:\n\n  - `ImputationKernel` - This class contains the raw data off of which\n    the `mice` algorithm is performed. During this process, models will\n    be trained, and the imputed (predicted) values will be stored. These\n    values can be used to fill in the missing values of the raw data.\n    The raw data can be copied, or referenced directly. Models can be\n    saved, and used to impute new datasets.\n  - `ImputedData` - The result of\n    `ImputationKernel.impute_new_data(new_data)`. This contains the raw\n    data in `new_data` as well as the imputed values.\n\n## The Basics\n\nWe will be looking at a few simple examples of imputation. We need to\nload the packages, and define the data:\n\n``` python\nimport miceforest as mf\nfrom sklearn.datasets import load_iris\nimport pandas as pd\nimport numpy as np\n\n# Load data and introduce missing values\niris = pd.concat(load_iris(as_frame=True,return_X_y=True),axis=1)\niris.rename({\"target\": \"species\"}, inplace=True, axis=1)\niris['species'] = iris['species'].astype('category')\niris_amp = mf.ampute_data(iris,perc=0.25,random_state=1991)\n```\n\n### Basic Examples\n\nIf you only want to create a single imputed dataset, you can set the\n`datasets` parameter to 1:\n\n``` python\n# Create kernel. \nkds = mf.ImputationKernel(\n  iris_amp,\n  datasets=1,\n  save_all_iterations=True,\n  random_state=1991\n)\n\n# Run the MICE algorithm for 3 iterations\nkds.mice(2)\n```\n\nThere are also an array of plotting functions available, these are\ndiscussed below in the section [Diagnostic\nPlotting](https://github.com/AnotherSamWilson/miceforest#Diagnostic-Plotting).\n\nWe usually don’t want to impute just a single dataset. In statistics,\nmultiple imputation is a process by which the uncertainty/other effects\ncaused by missing values can be examined by creating multiple different\nimputed datasets. `ImputationKernel` can contain an arbitrary number of\ndifferent datasets, all of which have gone through mutually exclusive\nimputation processes:\n\n``` python\n# Create kernel. \nkernel = mf.ImputationKernel(\n  iris_amp,\n  datasets=4,\n  save_all_iterations=True,\n  random_state=1\n)\n\n# Run the MICE algorithm for 2 iterations on each of the datasets\nkernel.mice(2)\n\n# Printing the kernel will show you some high level information.\nprint(kernel)\n```\n\n    ##               Class: ImputationKernel\n    ##            Datasets: 4\n    ##          Iterations: 2\n    ##   Imputed Variables: 5\n    ## save_all_iterations: True\n\nAfter we have run mice, we can obtain our completed dataset directly\nfrom the kernel:\n\n``` python\ncompleted_dataset = kernel.complete_data(dataset=0, inplace=False)\nprint(completed_dataset.isnull().sum(0))\n```\n\n    ## sepal length (cm)    0\n    ## sepal width (cm)     0\n    ## petal length (cm)    0\n    ## petal width (cm)     0\n    ## species              0\n    ## dtype: int64\n\nUsing `inplace=False` returns a copy of the completed data. Since the\nraw data is already stored in `kernel.working_data`, you can set\n`inplace=True` to complete the data without returning a copy:\n\n``` python\nkernel.complete_data(dataset=0, inplace=True)\nprint(kernel.working_data.isnull().sum(0))\n```\n\n    ## sepal length (cm)    0\n    ## sepal width (cm)     0\n    ## petal length (cm)    0\n    ## petal width (cm)     0\n    ## species              0\n    ## dtype: int64\n\n### Controlling Tree Growth\n\nParameters can be passed directly to lightgbm in several different ways.\nParameters you wish to apply globally to every model can simply be\npassed as kwargs to `mice`:\n\n``` python\n# Run the MICE algorithm for 1 more iteration on the kernel with new parameters\nkernel.mice(iterations=1,n_estimators=50)\n```\n\nYou can also pass pass variable-specific arguments to\n`variable_parameters` in mice. For instance, let’s say you noticed the\nimputation of the `[species]` column was taking a little longer, because\nit is multiclass. You could decrease the n\\_estimators specifically for\nthat column with:\n\n``` python\n# Run the MICE algorithm for 2 more iterations on the kernel \nkernel.mice(iterations=1,variable_parameters={'species': {'n_estimators': 25}},n_estimators=50)\n```\n\nIn this scenario, any parameters specified in `variable_parameters`\ntakes presidence over the kwargs.\n\n### Preserving Data Assumptions\n\nIf your data contains count data, or any other data which can be\nparameterized by lightgbm, you can simply specify that variable to be\nmodeled with the corresponding objective function. For example, let’s\npretend `sepal width (cm)` is a count field which can be parameterized\nby a Poisson distribution:\n\n``` python\n# Create kernel. \ncust_kernel = mf.ImputationKernel(\n  iris_amp,\n  datasets=1,\n  random_state=1\n)\n\ncust_kernel.mice(iterations=1, variable_parameters={'sepal width (cm)': {'objective': 'poisson'}})\n```\n\nOther nice parameters like `monotone_constraints` can also be passed.\n\n### Imputing with Gradient Boosted Trees\n\nSince any arbitrary parameters can be passed to `lightgbm.train()`, it\nis possible to change the algrorithm entirely. This can be done simply\nlike so:\n\n``` python\n# Create kernel. \nkds_gbdt = mf.ImputationKernel(\n  iris_amp,\n  datasets=1,\n  save_all_iterations=True,\n  random_state=1991\n)\n\n# We need to add a small minimum hessian, or lightgbm will complain:\nkds_gbdt.mice(iterations=1, boosting='gbdt', min_sum_hessian_in_leaf=0.01)\n\n# Return the completed kernel data\ncompleted_data = kds_gbdt.complete_data(dataset=0)\n```\n\nNote: It is HIGHLY recommended to run parameter tuning if using gradient\nboosted trees. The parameter tuning process returns the optimal number\nof iterations, and usually results in much more useful parameter sets.\nSee the section [Tuning\nParameters](https://github.com/AnotherSamWilson/miceforest#Tuning-Parameters)\nfor more details.\n\n## Advanced Features\n\nThere are many ways to alter the imputation procedure to fit your\nspecific dataset.\n\n### Customizing the Imputation Process\n\nIt is possible to heavily customize our imputation procedure by\nvariable. By passing a named list to `variable_schema`, you can specify\nthe predictors for each variable to impute. You can also specify\n`mean_match_candidates` and `data_subset` by variable by passing a dict\nof valid values, with variable names as keys. You can even replace the\nentire default mean matching function if you wish:\n\n``` python\nvar_sch = {\n    'sepal width (cm)': ['species','petal width (cm)'],\n    'petal width (cm)': ['species','sepal length (cm)']\n}\nvar_mmc = {\n    'sepal width (cm)': 5,\n    'petal width (cm)': 0\n}\nvar_mms = {\n  'sepal width (cm)': 50\n}\n\n# The mean matching function requires these parameters, even\n# if it does not use them.\ndef mmf(\n  mmc,\n  model,\n  candidate_features,\n  bachelor_features,\n  candidate_values,\n  random_state,\n  hashed_seeds\n):\n\n    bachelor_preds = model.predict(bachelor_features)\n    imp_values = random_state.choice(candidate_values, size=bachelor_preds.shape[0])\n\n    return imp_values\n\ncust_kernel = mf.ImputationKernel(\n    iris_amp,\n    datasets=3,\n    variable_schema=var_sch,\n    mean_match_candidates=var_mmc,\n    data_subset=var_mms,\n    mean_match_function=mmf\n)\ncust_kernel.mice(1)\n```\n\n### Imputing New Data with Existing Models\n\nMultiple Imputation can take a long time. If you wish to impute a\ndataset using the MICE algorithm, but don’t have time to train new\nmodels, it is possible to impute new datasets using a `ImputationKernel`\nobject. The `impute_new_data()` function uses the random forests\ncollected by `ImputationKernel` to perform multiple imputation without\nupdating the random forest at each iteration:\n\n``` python\n# Our 'new data' is just the first 15 rows of iris_amp\nfrom datetime import datetime\n\n# Define our new data as the first 15 rows\nnew_data = iris_amp.iloc[range(15)]\n\nstart_t = datetime.now()\nnew_data_imputed = kernel.impute_new_data(new_data=new_data)\nprint(f\"New Data imputed in {(datetime.now() - start_t).total_seconds()} seconds\")\n```\n\n    ## New Data imputed in 0.681154 seconds\n\nAll of the imputation parameters (variable\\_schema,\nmean\\_match\\_candidates, etc) will be carried over from the original\n`ImputationKernel` object. When mean matching, the candidate values are\npulled from the original kernel dataset. To impute new data, the\n`save_models` parameter in `ImputationKernel` must be \\> 0. If\n`save_models == 1`, the model from the latest iteration is saved for\neach variable. If `save_models > 1`, the model from each iteration is\nsaved. This allows for new data to be imputed in a more similar fashion\nto the original mice procedure.\n\n### Building Models on Nonmissing Data\n\nThe MICE process itself is used to impute missing data in a dataset.\nHowever, sometimes a variable can be fully recognized in the training\ndata, but needs to be imputed later on in a different dataset. It is\npossible to train models to impute variables even if they have no\nmissing values by setting `train_nonmissing=True`. In this case,\n`variable_schema` is treated as the list of variables to train models\non. `imputation_order` only affects which variables actually have their\nvalues imputed, it does not affect which variables have models trained:\n\n``` python\norig_missing_cols = [\"sepal length (cm)\", \"sepal width (cm)\"]\nnew_missing_cols = [\"sepal length (cm)\", \"sepal width (cm)\", \"species\"]\n\n# Training data only contains 2 columns with missing data\niris_amp2 = iris.copy()\niris_amp2[orig_missing_cols] = mf.ampute_data(\n  iris_amp2[orig_missing_cols],\n  perc=0.25,\n  random_state=1991\n)\n\n# Specify that models should also be trained for species column\nvar_sch = new_missing_cols\n\ncust_kernel = mf.ImputationKernel(\n    iris_amp2,\n    datasets=1,\n    variable_schema=var_sch,\n    train_nonmissing=True\n)\ncust_kernel.mice(1)\n\n# New data has missing values in species column\niris_amp2_new = iris.iloc[range(10),:].copy()\niris_amp2_new[new_missing_cols] = mf.ampute_data(\n  iris_amp2_new[new_missing_cols],\n  perc=0.25,\n  random_state=1991\n)\n\n# Species column can still be imputed\niris_amp2_new_imp = cust_kernel.impute_new_data(iris_amp2_new)\niris_amp2_new_imp.complete_data(0).isnull().sum()\n```\n\n    ## sepal length (cm)    0\n    ## sepal width (cm)     0\n    ## petal length (cm)    0\n    ## petal width (cm)     0\n    ## species              0\n    ## dtype: int64\n\nHere, we knew that the species column in our new data would need to be\nimputed. Therefore, we specified that a model should be built for all 3\nvariables in the `variable_schema` (passing a dict of target - feature\npairs would also have worked).\n\n### Tuning Parameters\n\n`miceforest` allows you to tune the parameters on a kernel dataset.\nThese parameters can then be used to build the models in future\niterations of mice. In its most simple invocation, you can just call the\nfunction with the desired optimization steps:\n\n``` python\n# Using the first ImputationKernel in kernel to tune parameters\n# with the default settings.\noptimal_parameters, losses = kernel.tune_parameters(\n  dataset=0,\n  optimization_steps=5\n)\n\n# Run mice with our newly tuned parameters.\nkernel.mice(1, variable_parameters=optimal_parameters)\n\n# The optimal parameters are kept in ImputationKernel.optimal_parameters:\nprint(optimal_parameters)\n```\n\n    ## {0: {'boosting': 'gbdt', 'num_iterations': 65, 'max_depth': 8, 'num_leaves': 10, 'min_data_in_leaf': 1, 'min_sum_hessian_in_leaf': 0.1, 'min_gain_to_split': 0.0, 'bagging_fraction': 0.39791299065921537, 'feature_fraction': 1.0, 'feature_fraction_bynode': 0.6937388234549196, 'bagging_freq': 1, 'verbosity': -1, 'objective': 'regression', 'seed': 849382, 'learning_rate': 0.05, 'cat_smooth': 11.663587284343516}, 1: {'boosting': 'gbdt', 'num_iterations': 49, 'max_depth': 8, 'num_leaves': 9, 'min_data_in_leaf': 5, 'min_sum_hessian_in_leaf': 0.1, 'min_gain_to_split': 0.0, 'bagging_fraction': 0.6179134070114273, 'feature_fraction': 1.0, 'feature_fraction_bynode': 0.31478518263603694, 'bagging_freq': 1, 'verbosity': -1, 'objective': 'regression', 'seed': 586321, 'learning_rate': 0.05, 'cat_smooth': 13.957164461191296}, 2: {'boosting': 'gbdt', 'num_iterations': 65, 'max_depth': 8, 'num_leaves': 7, 'min_data_in_leaf': 4, 'min_sum_hessian_in_leaf': 0.1, 'min_gain_to_split': 0.0, 'bagging_fraction': 0.9979861290119383, 'feature_fraction': 1.0, 'feature_fraction_bynode': 0.5730380093960374, 'bagging_freq': 1, 'verbosity': -1, 'objective': 'regression', 'seed': 961902, 'learning_rate': 0.05, 'cat_smooth': 20.39766682094556}, 3: {'boosting': 'gbdt', 'num_iterations': 61, 'max_depth': 8, 'num_leaves': 11, 'min_data_in_leaf': 6, 'min_sum_hessian_in_leaf': 0.1, 'min_gain_to_split': 0.0, 'bagging_fraction': 0.7560736024385001, 'feature_fraction': 1.0, 'feature_fraction_bynode': 0.8058628021146634, 'bagging_freq': 1, 'verbosity': -1, 'objective': 'regression', 'seed': 449169, 'learning_rate': 0.05, 'cat_smooth': 16.369979689010446}, 4: {'boosting': 'gbdt', 'num_iterations': 99, 'max_depth': 8, 'num_leaves': 16, 'min_data_in_leaf': 8, 'min_sum_hessian_in_leaf': 0.1, 'min_gain_to_split': 0.0, 'bagging_fraction': 0.7186091265251624, 'feature_fraction': 1.0, 'feature_fraction_bynode': 0.10283114841793521, 'bagging_freq': 1, 'verbosity': -1, 'objective': 'multiclass', 'num_class': 3, 'seed': 933848, 'learning_rate': 0.05, 'cat_smooth': 10.956325813024653}}\n\nThis will perform 10 fold cross validation on random samples of\nparameters. By default, all variables models are tuned. If you are\ncurious about the default parameter space that is searched within, check\nout the `miceforest.default_lightgbm_parameters` module.\n\nThe parameter tuning is pretty flexible. If you wish to set some model\nparameters static, or to change the bounds that are searched in, you can\nsimply pass this information to either the `variable_parameters`\nparameter, `**kwbounds`, or both:\n\n``` python\n# Using a complicated setup:\noptimal_parameters, losses = kernel.tune_parameters(\n  dataset=0,\n  variables = ['sepal width (cm)','species','petal width (cm)'],\n  variable_parameters = {\n    'sepal width (cm)': {'bagging_fraction': 0.5},\n    'species': {'bagging_freq': (5,10)}\n  },\n  optimization_steps=5,\n  extra_trees = [True, False]\n)\n\nkernel.mice(1, variable_parameters=optimal_parameters)\n```\n\nIn this example, we did a few things - we specified that only `sepal\nwidth (cm)`, `species`, and `petal width (cm)` should be tuned. We also\nspecified some specific parameters in `variable_parameters.` Notice that\n`bagging_fraction` was passed as a scalar, `0.5`. This means that, for\nthe variable `sepal width (cm)`, the parameter `bagging_fraction` will\nbe set as that number and not be tuned. We did the opposite for\n`bagging_freq`. We specified bounds that the process should search in.\nWe also passed the argument `extra_trees` as a list. Since it was passed\nto \\*\\*kwbounds, this parameter will apply to all variables that are\nbeing tuned. Passing values as a list tells the process that it should\nrandomly sample values from the list, instead of treating them as set of\ncounts to search within.\n\nThe tuning process follows these rules for different parameter values it\nfinds:\n\n  - Scalar: That value is used, and not tuned.  \n  - Tuple: Should be length 2. Treated as the lower and upper bound to\n    search in.  \n  - List: Treated as a distinct list of values to try randomly.\n\n### On Reproducibility\n\n`miceforest` allows for different “levels” of reproducibility, global\nand record-level.\n\n##### **Global Reproducibility**\n\nGlobal reproducibility ensures that the same values will be imputed if\nthe same code is run multiple times. To ensure global reproducibility,\nall the user needs to do is set a `random_state` when the kernel is\ninitialized.\n\n##### **Record-Level Reproducibility**\n\nSometimes we want to obtain reproducible imputations at the record\nlevel, without having to pass the same dataset. This is possible by\npassing a list of record-specific seeds to the `random_seed_array`\nparameter. This is useful if imputing new data multiple times, and you\nwould like imputations for each row to match each time it is imputed.\n\n``` python\n# Define seeds for the data, and impute iris\nrandom_seed_array = np.random.randint(9999, size=150)\niris_imputed = kernel.impute_new_data(\n    iris_amp,\n    random_state=4,\n    random_seed_array=random_seed_array\n)\n\n# Select a random sample\nnew_inds = np.random.choice(150, size=15)\nnew_data = iris_amp.loc[new_inds]\nnew_seeds = random_seed_array[new_inds]\nnew_imputed = kernel.impute_new_data(\n    new_data,\n    random_state=4,\n    random_seed_array=new_seeds\n)\n\n# We imputed the same values for the 15 values each time,\n# because each record was associated with the same seed.\nassert new_imputed.complete_data(0).equals(iris_imputed.complete_data(0).loc[new_inds])\n```\n\nNote that record-level reproducibility is only possible in the\n`impute_new_data` function, there are no guarantees of record-level\nreproducibility in imputations between the kernel and new data.\n\n### How to Make the Process Faster\n\nMultiple Imputation is one of the most robust ways to handle missing\ndata - but it can take a long time. There are several strategies you can\nuse to decrease the time a process takes to run:\n\n  - Decrease `data_subset`. By default all non-missing datapoints for\n    each variable are used to train the model and perform mean matching.\n    This can cause the model training nearest-neighbors search to take a\n    long time for large data. A subset of these points can be searched\n    instead by using `data_subset`.  \n  - Convert your data to a numpy array. Numpy arrays are much faster to\n    index. While indexing overhead is avoided as much as possible, there\n    is no getting around it. Consider comverting to `float32` datatype\n    as well, as it will cause the resulting object to take up much less\n    memory.\n  - Decrease `mean_match_candidates`. The maximum number of neighbors\n    that are considered with the default parameters is 10. However, for\n    large datasets, this can still be an expensive operation. Consider\n    explicitly setting `mean_match_candidates` lower.\n  - Use different lightgbm parameters. lightgbm is usually not the\n    problem, however if a certain variable has a large number of\n    classes, then the max number of trees actually grown is (\\# classes)\n    \\* (n\\_estimators). You can specifically decrease the bagging\n    fraction or n\\_estimators for large multi-class variables, or grow\n    less trees in general.  \n  - Use a faster mean matching function. The default mean matching\n    function uses the scipy.Spatial.KDtree algorithm. There are faster\n    alternatives out there, if you think mean matching is the holdup.\n\n### Imputing Data In Place\n\nIt is possible to run the entire process without copying the dataset. If\n`copy_data=False`, then the data is referenced directly:\n\n``` python\nkernel_inplace = mf.ImputationKernel(\n  iris_amp,\n  datasets=1,\n  copy_data=False\n)\nkernel_inplace.mice(2)\n```\n\nNote, that this probably won’t (but could) change the original dataset\nin undesirable ways. Throughout the `mice` procedure, imputed values are\nstored directly in the original data. At the end, the missing values are\nput back as `np.NaN`.\n\nWe can also complete our original data in place:\n\n``` python\nkernel_inplace.complete_data(dataset=0, inplace=True)\nprint(iris_amp.isnull().sum(0))\n```\n\n    ## sepal length (cm)    0\n    ## sepal width (cm)     0\n    ## petal length (cm)    0\n    ## petal width (cm)     0\n    ## species              0\n    ## dtype: int64\n\nThis is useful if the dataset is large, and copies can’t be made in\nmemory.\n\n### Saving and Loading Kernels\n\nKernels can be saved using the `dill` module. The `pickle` module might\nnot work in some cases.\n\n## Diagnostic Plotting\n\nAs of now, miceforest has four diagnostic plots available.\n\n### Distribution of Imputed-Values\n\nWe probably want to know how the imputed values are distributed. We can\nplot the original distribution beside the imputed distributions in each\ndataset by using the `plot_imputed_distributions` method of an\n`ImputationKernel` object:\n\n``` python\nkernel.plot_imputed_distributions(wspace=0.3,hspace=0.3)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/distributions.png\" width=\"600px\" />\n\nThe red line is the original data, and each black line are the imputed\nvalues of each dataset.\n\n### Convergence of Correlation\n\nWe are probably interested in knowing how our values between datasets\nconverged over the iterations. The `plot_correlations` method shows you\na boxplot of the correlations between imputed values in every\ncombination of datasets, at each iteration. This allows you to see how\ncorrelated the imputations are between datasets, as well as the\nconvergence over iterations:\n\n``` python\nkernel.plot_correlations()\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/plot_corr.png\" width=\"600px\" />\n\n### Variable Importance\n\nWe also may be interested in which variables were used to impute each\nvariable. We can plot this information by using the\n`plot_feature_importance` method.\n\n``` python\nkernel.plot_feature_importance(dataset=0, annot=True,cmap=\"YlGnBu\",vmin=0, vmax=1)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/var_imp.png\" width=\"600px\" />\n\nThe numbers shown are returned from the\n`lightgbm.Booster.feature_importance()` function. Each square represents\nthe importance of the column variable in imputing the row variable.\n\n### Mean Convergence\n\nIf our data is not missing completely at random, we may see that it\ntakes a few iterations for our models to get the distribution of\nimputations right. We can plot the average value of our imputations to\nsee if this is occurring:\n\n``` python\nkernel.plot_mean_convergence(wspace=0.3, hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/mean_convergence.png\" width=\"600px\" />\n\nOur data was missing completely at random, so we don’t see any\nconvergence occurring here.\n\n## Using the Imputed Data\n\nTo return the imputed data simply use the `complete_data` method:\n\n``` python\ndataset_1 = kernel.complete_data(0)\n```\n\nThis will return a single specified dataset. Multiple datasets are\ntypically created so that some measure of confidence around each\nprediction can be created.\n\nSince we know what the original data looked like, we can cheat and see\nhow well the imputations compare to the original data:\n\n``` python\nacclist = []\nfor iteration in range(kernel.iteration_count()+1):\n    species_na_count = kernel.na_counts[4]\n    compdat = kernel.complete_data(dataset=0,iteration=iteration)\n\n    # Record the accuract of the imputations of species.\n    acclist.append(\n      round(1-sum(compdat['species'] != iris['species'])/species_na_count,2)\n    )\n\n# acclist shows the accuracy of the imputations\n# over the iterations.\nprint(acclist)\n```\n\n    ## [0.35, 0.7, 0.78, 0.86, 0.84, 0.89, 0.86]\n\nIn this instance, we went from a \\~32% accuracy (which is expected with\nrandom sampling) to an accuracy of \\~65% after the first iteration. This\nisn’t the best example, since our kernel so far has been abused to show\nthe flexability of the imputation procedure.\n\n## The MICE Algorithm\n\nMultiple Imputation by Chained Equations ‘fills in’ (imputes) missing\ndata in a dataset through an iterative series of predictive models. In\neach iteration, each specified variable in the dataset is imputed using\nthe other variables in the dataset. These iterations should be run until\nit appears that convergence has been met.\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/MICEalgorithm.png\" style=\"display: block; margin: auto;\" />\n\nThis process is continued until all specified variables have been\nimputed. Additional iterations can be run if it appears that the average\nimputed values have not converged, although no more than 5 iterations\nare usually necessary.\n\n### Common Use Cases\n\n##### **Data Leakage:**\n\nMICE is particularly useful if missing values are associated with the\ntarget variable in a way that introduces leakage. For instance, let’s\nsay you wanted to model customer retention at the time of sign up. A\ncertain variable is collected at sign up or 1 month after sign up. The\nabsence of that variable is a data leak, since it tells you that the\ncustomer did not retain for 1 month.\n\n##### **Funnel Analysis:**\n\nInformation is often collected at different stages of a ‘funnel’. MICE\ncan be used to make educated guesses about the characteristics of\nentities at different points in a funnel.\n\n##### **Confidence Intervals:**\n\nMICE can be used to impute missing values, however it is important to\nkeep in mind that these imputed values are a prediction. Creating\nmultiple datasets with different imputed values allows you to do two\ntypes of inference:\n\n  - Imputed Value Distribution: A profile can be built for each imputed\n    value, allowing you to make statements about the likely distribution\n    of that value.  \n  - Model Prediction Distribution: With multiple datasets, you can build\n    multiple models and create a distribution of predictions for each\n    sample. Those samples with imputed values which were not able to be\n    imputed with much confidence would have a larger variance in their\n    predictions.\n\n### Predictive Mean Matching\n\n`miceforest` can make use of a procedure called predictive mean matching\n(PMM) to select which values are imputed. PMM involves selecting a\ndatapoint from the original, nonmissing data which has a predicted value\nclose to the predicted value of the missing sample. The closest N\n(`mean_match_candidates` parameter) values are chosen as candidates,\nfrom which a value is chosen at random. This can be specified on a\ncolumn-by-column basis. Going into more detail from our example above,\nwe see how this works in practice:\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/PMM.png\" style=\"display: block; margin: auto;\" />\n\nThis method is very useful if you have a variable which needs imputing\nwhich has any of the following characteristics:\n\n  - Multimodal  \n  - Integer  \n  - Skewed\n\n### Effects of Mean Matching\n\nAs an example, let’s construct a dataset with some of the above\ncharacteristics:\n\n``` python\nrandst = np.random.RandomState(1991)\n# random uniform variable\nnrws = 1000\nuniform_vec = randst.uniform(size=nrws)\n\ndef make_bimodal(mean1,mean2,size):\n    bimodal_1 = randst.normal(size=nrws, loc=mean1)\n    bimodal_2 = randst.normal(size=nrws, loc=mean2)\n    bimdvec = []\n    for i in range(size):\n        bimdvec.append(randst.choice([bimodal_1[i], bimodal_2[i]]))\n    return np.array(bimdvec)\n\n# Make 2 Bimodal Variables\nclose_bimodal_vec = make_bimodal(2,-2,nrws)\nfar_bimodal_vec = make_bimodal(3,-3,nrws)\n\n\n# Highly skewed variable correlated with Uniform_Variable\nskewed_vec = np.exp(uniform_vec*randst.uniform(size=nrws)*3) + randst.uniform(size=nrws)*3\n\n# Integer variable correlated with Close_Bimodal_Variable and Uniform_Variable\ninteger_vec = np.round(uniform_vec + close_bimodal_vec/3 + randst.uniform(size=nrws)*2)\n\n# Make a DataFrame\ndat = pd.DataFrame(\n    {\n    'uniform_var':uniform_vec,\n    'close_bimodal_var':close_bimodal_vec,\n    'far_bimodal_var':far_bimodal_vec,\n    'skewed_var':skewed_vec,\n    'integer_var':integer_vec\n    }\n)\n\n# Ampute the data.\nampdat = mf.ampute_data(dat,perc=0.25,random_state=randst)\n\n# Plot the original data\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ng = sns.PairGrid(dat)\ng.map(plt.scatter,s=5)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/dataset.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\nWe can see how our variables are distributed and correlated in the graph\nabove. Now let’s run our imputation process twice, once using mean\nmatching, and once using the model prediction.\n\n``` r\nkernelmeanmatch = mf.ImputationKernel(ampdat, datasets=1,mean_match_candidates=5)\nkernelmodeloutput = mf.ImputationKernel(ampdat, datasets=1,mean_match_candidates=0)\n\nkernelmeanmatch.mice(2)\nkernelmodeloutput.mice(2)\n```\n\nLet’s look at the effect on the different variables.\n\n##### With Mean Matching\n\n``` python\nkernelmeanmatch.plot_imputed_distributions(wspace=0.2,hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/meanmatcheffects.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\n\n##### Without Mean Matching\n\n``` python\nkernelmodeloutput.plot_imputed_distributions(wspace=0.2,hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/nomeanmatching.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\n\nYou can see the effects that mean matching has, depending on the\ndistribution of the data. Simply returning the value from the model\nprediction, while it may provide a better ‘fit’, will not provide\nimputations with a similair distribution to the original. This may be\nbeneficial, depending on your goal.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/AnotherSamWilson/miceforest",
    "keywords": "MICE,Imputation,Missing Values,Missing,Random Forest",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "miceforest",
    "package_url": "https://pypi.org/project/miceforest/",
    "platform": null,
    "project_url": "https://pypi.org/project/miceforest/",
    "project_urls": {
      "Homepage": "https://github.com/AnotherSamWilson/miceforest"
    },
    "release_url": "https://pypi.org/project/miceforest/5.3.1/",
    "requires_dist": [
      "lightgbm (>=3.3.1)",
      "numpy",
      "scipy (>=1.6.0) ; extra == 'default_mm'",
      "seaborn (>=0.11.0) ; extra == 'plotting'",
      "matplotlib (>=3.3.0) ; extra == 'plotting'",
      "pandas ; extra == 'testing'",
      "sklearn ; extra == 'testing'"
    ],
    "requires_python": ">=3.7",
    "summary": "Imputes missing data with MICE + random forests",
    "version": "5.3.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16075390,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "97f0aaf6d11989c709e26700955b85f79ccd079754eee85f4ac4324bebf68b75",
        "md5": "c44faff46159593babf00353ec69dfd9",
        "sha256": "daeb1d48262345ae01d50d10b253de563ca623d414b1c703b5edfd0c37882b93"
      },
      "downloads": -1,
      "filename": "miceforest-5.3.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "c44faff46159593babf00353ec69dfd9",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 42389,
      "upload_time": "2022-04-14T02:56:40",
      "upload_time_iso_8601": "2022-04-14T02:56:40.160239Z",
      "url": "https://files.pythonhosted.org/packages/97/f0/aaf6d11989c709e26700955b85f79ccd079754eee85f4ac4324bebf68b75/miceforest-5.3.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7c0a915015b0ceba01e30ecfa38066f6a33baf2a741b3700b066eb1b4c57360e",
        "md5": "844362e1a6dd303f04d6654196e2f75f",
        "sha256": "2d768657cd1f50f6aa0dc70d705760b31f5c0a14fd3418eb93c48d7e3d270856"
      },
      "downloads": -1,
      "filename": "miceforest-5.3.1.tar.gz",
      "has_sig": false,
      "md5_digest": "844362e1a6dd303f04d6654196e2f75f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 63428,
      "upload_time": "2022-04-14T02:56:44",
      "upload_time_iso_8601": "2022-04-14T02:56:44.955750Z",
      "url": "https://files.pythonhosted.org/packages/7c/0a/915015b0ceba01e30ecfa38066f6a33baf2a741b3700b066eb1b4c57360e/miceforest-5.3.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}