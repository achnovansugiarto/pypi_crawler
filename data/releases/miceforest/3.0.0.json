{
  "info": {
    "author": "Samuel Wilson",
    "author_email": "samwilson303@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: MacOS",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "\n[![Build\nStatus](https://travis-ci.org/AnotherSamWilson/miceforest.svg?branch=master)](https://travis-ci.org/AnotherSamWilson/miceforest)\n[![MyPy](https://img.shields.io/badge/MyPy-passing-success.svg)](https://pypi.org/project/miceforest/)\n[![Documentation\nStatus](https://readthedocs.org/projects/miceforest/badge/?version=latest)](https://miceforest.readthedocs.io/en/latest/?badge=latest)\n[![MIT\nlicense](http://img.shields.io/badge/license-MIT-brightgreen.svg)](http://opensource.org/licenses/MIT)\n[![CodeCov](https://codecov.io/gh/AnotherSamWilson/miceforest/branch/master/graphs/badge.svg?branch=master&service=github)](https://codecov.io/gh/AnotherSamWilson/miceforest)\n[![Code style:\nblack](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)  \n[![DEV\\_Version\\_Badge](https://img.shields.io/badge/Dev-3.0.0-blue.svg)](https://pypi.org/project/miceforest/)\n[![Pypi](https://img.shields.io/pypi/v/miceforest.svg)](https://pypi.python.org/pypi/miceforest)\n[![Conda\nVersion](https://img.shields.io/conda/vn/conda-forge/miceforest.svg)](https://anaconda.org/conda-forge/miceforest)\n[![PyVersions](https://img.shields.io/pypi/pyversions/miceforest.svg?logo=python&logoColor=white)](https://pypi.org/project/miceforest/)\n[![Downloads](https://pepy.tech/badge/miceforest/month)](https://pepy.tech/project/miceforest)\n\n## miceforest: Fast Imputation with lightgbm in Python\n\n<a href='https://github.com/AnotherSamWilson/miceforest'><img src='https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/icon.png' align=\"right\" height=\"300\" /></a>\n\nFast, memory efficient Multiple Imputation by Chained Equations (MICE)\nwith random forests. It can impute categorical and numeric data without\nmuch setup, and has an array of diagnostic plots available. The R\nversion of this package may be found\n[here](https://github.com/FarrellDay/miceRanger).\n\nThis document contains a thorough walkthrough of the package,\nbenchmarks, and an introduction to multiple imputation. More information\non MICE can be found in Stef van Buurenâ€™s excellent online book, which\nyou can find\n[here](https://stefvanbuuren.name/fimd/ch-introduction.html).\n\n#### Table of Contents:\n\n  - [Package\n    Meta](https://github.com/AnotherSamWilson/miceforest#Package-Meta)\n  - [Using\n    miceforest](https://github.com/AnotherSamWilson/miceforest#Using-miceforest)\n      - [Single\n        Imputation](https://github.com/AnotherSamWilson/miceforest#Imputing-A-Single-Dataset)\n      - [Multiple\n        Imputation](https://github.com/AnotherSamWilson/miceforest#Simple-Example-Of-Multiple-Imputation)\n      - [Controlling Tree\n        Growth](https://github.com/AnotherSamWilson/miceforest#Controlling-Tree-Growth)\n      - [Imputing With Gradient Boosted\n        Trees](https://github.com/AnotherSamWilson/miceforest#Imputing-With-Gradient-Boosted-Trees)\n      - [Customizing the Imputation\n        Process](https://github.com/AnotherSamWilson/miceforest#Customizing-the-Imputation-Process)\n      - [Imputing New Data with Existing\n        Models](https://github.com/AnotherSamWilson/miceforest#Imputing-New-Data-with-Existing-Models)\n      - [How to Make the Process\n        Faster](https://github.com/AnotherSamWilson/miceforest#How-to-Make-the-Process-Faster)\n  - [Diagnostic\n    Plotting](https://github.com/AnotherSamWilson/miceforest#Diagnostic-Plotting)\n      - [Imputed\n        Distributions](https://github.com/AnotherSamWilson/miceforest#Distribution-of-Imputed-Values)\n      - [Correlation\n        Convergence](https://github.com/AnotherSamWilson/miceforest#Convergence-of-Correlation)\n      - [Variable\n        Importance](https://github.com/AnotherSamWilson/miceforest#Variable-Importance)\n      - [Mean\n        Convergence](https://github.com/AnotherSamWilson/miceforest#Variable-Importance)\n  - [Using the Imputed\n    Data](https://github.com/AnotherSamWilson/miceforest#Using-the-Imputed-Data)\n  - [The MICE\n    Algorithm](https://github.com/AnotherSamWilson/miceforest#The-MICE-Algorithm)\n      - [Introduction](https://github.com/AnotherSamWilson/miceforest#The-MICE-Algorithm)\n      - [Common Use\n        Cases](https://github.com/AnotherSamWilson/miceforest#Common-Use-Cases)\n      - [Predictive Mean\n        Matching](https://github.com/AnotherSamWilson/miceforest#Predictive-Mean-Matching)\n      - [Effects of Mean\n        Matching](https://github.com/AnotherSamWilson/miceforest#Effects-of-Mean-Matching)\n\n### Package Meta\n\nmiceforest has 4 main classes which the user will interact with:\n\n  - `KernelDataSet` - a kernel data set is a dataset on which the mice\n    algorithm is performed. Models are saved inside the instance, which\n    can also be called on to impute new data. Several plotting methods\n    are included to run diagnostics on the imputed data.  \n  - `MultipleImputedKernel` - a collection of `KernelDataSet`s. Has\n    additional methods for accessing and comparing multiple kernel\n    datasets together.  \n  - `ImputedDataSet` - a single dataset that has been imputed. These are\n    returned after `impute_new_data()` is called.\n  - `MultipleImputedDataSet` - A collection of datasets that have been\n    imputed. Has additional methods for comparing the imputations\n    between datasets.\n\nThis package can be installed using either pip or conda, through\nconda-forge:\n\n``` bash\n# Using pip\n$ pip install miceforest\n\n# Using conda\n$ conda install -c conda-forge miceforest\n```\n\nYou can also download the latest development version from this\nrepository. If you want to install from github with conda, you must\nfirst run `conda install pip git`.\n\n``` bash\n$ pip install git+https://github.com/AnotherSamWilson/miceforest.git\n```\n\n## Using miceforest\n\nWe will be looking at a few simple examples of imputation. We need to\nload the packages, and define the data:\n\n``` python\nimport miceforest as mf\nfrom sklearn.datasets import load_iris\nimport pandas as pd\nimport numpy as np\n\n# Load data and introduce missing values\niris = pd.concat(load_iris(as_frame=True,return_X_y=True),axis=1)\niris['target'] = iris['target'].astype('category')\niris_amp = mf.ampute_data(iris,perc=0.25,random_state=1991)\n```\n\n### Imputing a Single Dataset\n\nIf you only want to create a single imputed dataset, you can use\n`KernelDataSet`:\n\n``` python\n# Create kernel. \nkds = mf.KernelDataSet(\n  iris_amp,\n  save_all_iterations=True,\n  random_state=1991\n)\n\n# Run the MICE algorithm for 3 iterations\nkds.mice(3)\n\n# Return the completed kernel data\ncompleted_data = kds.complete_data()\n```\n\nThere are also an array of plotting functions available, these are\ndiscussed below in the section [Diagnostic\nPlotting](https://github.com/AnotherSamWilson/miceforest#Diagnostic-Plotting).\nThe plotting behavior between single imputed datasets and multi-imputed\ndatasets is slightly different.\n\n### Simple Example of Multiple Imputation\n\nWe can also create a class which contains multiple `KernelDataSet`s,\nalong with easy ways to compare them:\n\n``` python\n# Create kernel. \nkernel = mf.MultipleImputedKernel(\n  iris_amp,\n  datasets=4,\n  save_all_iterations=True,\n  random_state=1991\n)\n\n# Run the MICE algorithm for 3 iterations on each of the datasets\nkernel.mice(3)\n```\n\nPrinting the `MultipleImputedKernel` object will tell you some high\nlevel information:\n\n``` python\nprint(kernel)\n```\n\n    ##               Class: MultipleImputedKernel\n    ##        Models Saved: Last Iteration\n    ##            Datasets: 4\n    ##          Iterations: 3\n    ##   Imputed Variables: 5\n    ## save_all_iterations: True\n\n### Controlling Tree Growth\n\nParameters can be passed directly to lightgbm in several different ways.\nParameters you wish to apply globally to every model can simply be\npassed as kwargs to `mice`:\n\n``` python\n# Run the MICE algorithm for 2 more iterations on the kernel \nkernel.mice(1,n_estimators=50)\n```\n\nYou can also pass pass variable-specific arguments to\n`variable_parameters` in mice. For instance, letâ€™s say you noticed the\nimputation of the `[target]` column was taking a little longer, because\nit is multiclass. You could decrease the n\\_estimators specifically for\nthat column with:\n\n``` python\n# Run the MICE algorithm for 2 more iterations on the kernel \nkernel.mice(1,variable_parameters={'target': {'n_estimators': 25}},n_estimators=50)\n```\n\nIn this scenario, any parameters specified in `variable_parameters`\ntakes presidence over the kwargs.\n\n### Imputing with Gradient Boosted Trees\n\nSince any arbitrary parameters can be passed to `lightgbm.train()`, it\nis possible to change the algrorithm entirely. This can be done simply\nlike so:\n\n``` python\n# Create kernel. \nkds_gbdt = mf.KernelDataSet(\n  iris_amp,\n  save_all_iterations=True,\n  random_state=1991\n)\n\n# We need to add a minimum hessian, or lightgbm will complain:\nkds_gbdt.mice(3, boosting='gbdt', min_sum_hessian_in_leaf=1)\n\n# Return the completed kernel data\ncompleted_data = kds_gbdt.complete_data()\n```\n\n### Customizing the Imputation Process\n\nIt is possible to heavily customize our imputation procedure by\nvariable. By passing a named list to `variable_schema`, you can specify\nthe predictors for each variable to impute. You can also specify\n`mean_match_candidates` and `mean_match_subset` by variable by passing a\ndict of valid values, with variable names as keys. You can even replace\nthe entire default mean matching function if you wish:\n\n``` python\nvar_sch = {\n    'sepal width (cm)': ['target','petal width (cm)'],\n    'petal width (cm)': ['target','sepal length (cm)']\n}\nvar_mmc = {\n    'sepal width (cm)': 5,\n    'petal width (cm)': 0\n}\nvar_mms = {\n  'sepal width (cm)': 50\n}\n\n# The mean matching function requires these parameters, even\n# if it does not use them.\ndef mmf(\n        mmc,\n        candidate_preds,\n        bachelor_preds,\n        candidate_values,\n        cat_dtype,\n        random_state):\n\n    imp_values = random_state.choice(candidate_values, size=bachelor_preds.shape[0])\n    if cat_dtype is not None:\n        imp_values = cat_dtype.categories[imp_values]\n\n    return imp_values\n\ncust_kernel = mf.MultipleImputedKernel(\n    iris_amp,\n    datasets=3,\n    variable_schema=var_sch,\n    mean_match_candidates=var_mmc,\n    mean_match_subset=var_mms,\n    mean_match_function=mmf\n)\ncust_kernel.mice(2)\n```\n\n### Imputing New Data with Existing Models\n\nMultiple Imputation can take a long time. If you wish to impute a\ndataset using the MICE algorithm, but donâ€™t have time to train new\nmodels, it is possible to impute new datasets using a\n`MultipleImputedKernel` object. The `impute_new_data()` function uses\nthe random forests collected by `MultipleImputedKernel` to perform\nmultiple imputation without updating the random forest at each\niteration:\n\n``` python\n# Our 'new data' is just the first 15 rows of iris_amp\nnew_data = iris_amp.iloc[range(15)]\nnew_data_imputed = kernel.impute_new_data(new_data=new_data)\nprint(new_data_imputed)\n```\n\n    ##               Class: MultipleImputedDataSet\n    ##            Datasets: 4\n    ##          Iterations: 5\n    ##   Imputed Variables: 5\n    ## save_all_iterations: False\n\nAll of the imputation parameters (variable\\_schema,\nmean\\_match\\_candidates, etc) will be carried over from the original\n`MultipleImputedKernel` object. When mean matching, the candidate values\nare pulled from the original kernel dataset. To impute new data, the\n`save_models` parameter in `MultipleImputedKernel` must be \\> 0. If\n`save_models == 1`, the model from the latest iteration is saved for\neach variable. If `save_models > 1`, the model from each iteration is\nsaved. This allows for new data to be imputed in a more similar fashion\nto the original mice procedure.\n\n### How to Make the Process Faster\n\nMultiple Imputation is one of the most robust ways to handle missing\ndata - but it can take a long time. There are several strategies you can\nuse to decrease the time a process takes to run:\n\n  - Decrease `mean_match_subset`. By default all non-missing datapoints\n    are considered as candidates. This can cause the nearest-neighbors\n    search to take a long time for large data. A subset of these points\n    can be searched instead by using `mean_match_subset`.  \n  - Decrease `mean_match_candidates`. If your data is large, the default\n    mean\\_match\\_candidates for each variable is 0.001 \\* (\\#\n    non-missing datapoints). This can grow to be an unweidly large\n    number of neighbors that need to be found.  \n  - Use different lightgbm parameters. lightgbm is usually not the\n    problem, however if a certain variable has a large number of\n    classes, then the max number of trees actually grown is (\\# classes)\n    \\* (n\\_estimators). You can specifically decrease the bagging\n    fraction or n\\_estimators for large multi-class variables.  \n  - Use a faster mean matching function. The default mean matching\n    function uses the sklearn.neighbors.NearestNeighbors algorithm.\n    There are faster alternatives out there (faiss), however faiss is\n    only available from conda.\n\n## Diagnostic Plotting\n\nAs of now, miceforest has four diagnostic plots available.\n\n### Distribution of Imputed-Values\n\nWe probably want to know how the imputed values are distributed. We can\nplot the original distribution beside the imputed distributions in each\ndataset by using the `plot_imputed_distributions` method of an\n`MultipleImputedKernel` object:\n\n``` python\nkernel.plot_imputed_distributions(wspace=0.3,hspace=0.3)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/distributions.png\" width=\"600px\" />\n\nThe red line is the original data, and each black line are the imputed\nvalues of each dataset.\n\n### Convergence of Correlation\n\nWe are probably interested in knowing how our values between datasets\nconverged over the iterations. The `plot_correlations` method shows you\na boxplot of the correlations between imputed values in every\ncombination of datasets, at each iteration. This allows you to see how\ncorrelated the imputations are between datasets, as well as the\nconvergence over iterations:\n\n``` python\nkernel.plot_correlations()\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/plot_corr.png\" width=\"600px\" />\n\n### Variable Importance\n\nWe also may be interested in which variables were used to impute each\nvariable. We can plot this information by using the\n`plot_feature_importance` method.\n\n``` python\nkernel.plot_feature_importance(annot=True,cmap=\"YlGnBu\",vmin=0, vmax=1)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/var_imp.png\" width=\"600px\" />\n\nThe numbers shown are returned from the\n`lightgbm.Booster.feature_importance()` function. Each square represents\nthe importance of the column variable in imputing the row variable.\n\n### Mean Convergence\n\nIf our data is not missing completely at random, we may see that it\ntakes a few iterations for our models to get the distribution of\nimputations right. We can plot the average value of our imputations to\nsee if this is occurring:\n\n``` python\nkernel.plot_mean_convergence(wspace=0.3, hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/mean_convergence.png\" width=\"600px\" />\n\nOur data was missing completely at random, so we donâ€™t see any\nconvergence occurring here.\n\n## Using the Imputed Data\n\nTo return the imputed data simply use the `complete_data` method:\n\n``` python\ndataset_1 = kernel.complete_data(0)\n```\n\nThis will return a single specified dataset. Multiple datasets are\ntypically created so that some measure of confidence around each\nprediction can be created.\n\nSince we know what the original data looked like, we can cheat and see\nhow well the imputations compare to the original data:\n\n``` python\nacclist = []\nfor iteration in range(kernel.iteration_count()+1):\n    target_na_count = kernel.na_counts['target']\n    compdat = kernel.complete_data(dataset=0,iteration=iteration)\n\n    # Record the accuract of the imputations of target.\n    acclist.append(\n      round(1-sum(compdat['target'] != iris['target'])/target_na_count,2)\n    )\n\n# acclist shows the accuracy of the imputations\n# over the iterations.\nprint(acclist)\n```\n\n    ## [0.32, 0.84, 0.81, 0.68, 0.81, 0.86]\n\nIn this instance, we went from a \\~32% accuracy (which is expected with\nrandom sampling) to an accuracy of \\~86% after the first iteration. The\naccuracy kind of floundered around afterwards. This is typical when the\ndata is Missing Completely At Random. If the data were more Missing At\nRandom, we might see a more normal convergence of accuracy.\n\n## The MICE Algorithm\n\nMultiple Imputation by Chained Equations â€˜fills inâ€™ (imputes) missing\ndata in a dataset through an iterative series of predictive models. In\neach iteration, each specified variable in the dataset is imputed using\nthe other variables in the dataset. These iterations should be run until\nit appears that convergence has been met.\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/MICEalgorithm.png\" style=\"display: block; margin: auto;\" />\n\nThis process is continued until all specified variables have been\nimputed. Additional iterations can be run if it appears that the average\nimputed values have not converged, although no more than 5 iterations\nare usually necessary.\n\n### Common Use Cases\n\n##### **Data Leakage:**\n\nMICE is particularly useful if missing values are associated with the\ntarget variable in a way that introduces leakage. For instance, letâ€™s\nsay you wanted to model customer retention at the time of sign up. A\ncertain variable is collected at sign up or 1 month after sign up. The\nabsence of that variable is a data leak, since it tells you that the\ncustomer did not retain for 1 month.\n\n##### **Funnel Analysis:**\n\nInformation is often collected at different stages of a â€˜funnelâ€™. MICE\ncan be used to make educated guesses about the characteristics of\nentities at different points in a funnel.\n\n##### **Confidence Intervals:**\n\nMICE can be used to impute missing values, however it is important to\nkeep in mind that these imputed values are a prediction. Creating\nmultiple datasets with different imputed values allows you to do two\ntypes of inference:\n\n  - Imputed Value Distribution: A profile can be built for each imputed\n    value, allowing you to make statements about the likely distribution\n    of that value.  \n  - Model Prediction Distribution: With multiple datasets, you can build\n    multiple models and create a distribution of predictions for each\n    sample. Those samples with imputed values which were not able to be\n    imputed with much confidence would have a larger variance in their\n    predictions.\n\n### Predictive Mean Matching\n\n`miceforest` can make use of a procedure called predictive mean matching\n(PMM) to select which values are imputed. PMM involves selecting a\ndatapoint from the original, nonmissing data which has a predicted value\nclose to the predicted value of the missing sample. The closest N\n(`mean_match_candidates` parameter) values are chosen as candidates,\nfrom which a value is chosen at random. This can be specified on a\ncolumn-by-column basis. Going into more detail from our example above,\nwe see how this works in practice:\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/PMM.png\" style=\"display: block; margin: auto;\" />\n\nThis method is very useful if you have a variable which needs imputing\nwhich has any of the following characteristics:\n\n  - Multimodal  \n  - Integer  \n  - Skewed\n\n### Effects of Mean Matching\n\nAs an example, letâ€™s construct a dataset with some of the above\ncharacteristics:\n\n``` python\nrandst = np.random.RandomState(1991)\n# random uniform variable\nnrws = 1000\nuniform_vec = randst.uniform(size=nrws)\n\ndef make_bimodal(mean1,mean2,size):\n    bimodal_1 = randst.normal(size=nrws, loc=mean1)\n    bimodal_2 = randst.normal(size=nrws, loc=mean2)\n    bimdvec = []\n    for i in range(size):\n        bimdvec.append(randst.choice([bimodal_1[i], bimodal_2[i]]))\n    return np.array(bimdvec)\n\n# Make 2 Bimodal Variables\nclose_bimodal_vec = make_bimodal(2,-2,nrws)\nfar_bimodal_vec = make_bimodal(3,-3,nrws)\n\n\n# Highly skewed variable correlated with Uniform_Variable\nskewed_vec = np.exp(uniform_vec*randst.uniform(size=nrws)*3) + randst.uniform(size=nrws)*3\n\n# Integer variable correlated with Close_Bimodal_Variable and Uniform_Variable\ninteger_vec = np.round(uniform_vec + close_bimodal_vec/3 + randst.uniform(size=nrws)*2)\n\n# Make a DataFrame\ndat = pd.DataFrame(\n    {\n    'uniform_var':uniform_vec,\n    'close_bimodal_var':close_bimodal_vec,\n    'far_bimodal_var':far_bimodal_vec,\n    'skewed_var':skewed_vec,\n    'integer_var':integer_vec\n    }\n)\n\n# Ampute the data.\nampdat = mf.ampute_data(dat,perc=0.25,random_state=randst)\n\n# Plot the original data\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ng = sns.PairGrid(dat)\ng.map(plt.scatter,s=5)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/dataset.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\nWe can see how our variables are distributed and correlated in the graph\nabove. Now letâ€™s run our imputation process twice, once using mean\nmatching, and once using the model prediction.\n\n``` r\nkernelmeanmatch <- mf.MultipleImputedKernel(ampdat,mean_match_candidates=5)\nkernelmodeloutput <- mf.MultipleImputedKernel(ampdat,mean_match_candidates=0)\n\nkernelmeanmatch.mice(5)\nkernelmodeloutput.mice(5)\n```\n\nLetâ€™s look at the effect on the different variables.\n\n##### With Mean Matching\n\n``` python\nkernelmeanmatch.plot_imputed_distributions(wspace=0.2,hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/meanmatcheffects.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\n\n##### Without Mean Matching\n\n``` python\nkernelmodeloutput.plot_imputed_distributions(wspace=0.2,hspace=0.4)\n```\n\n<img src=\"https://raw.githubusercontent.com/AnotherSamWilson/miceforest/master/examples/nomeanmatching.png\" width=\"600px\" style=\"display: block; margin: auto;\" />\n\nYou can see the effects that mean matching has, depending on the\ndistribution of the data. Simply returning the value from the model\nprediction, while it may provide a better â€˜fitâ€™, will not provide\nimputations with a similair distribution to the original. This may be\nbeneficial, depending on your goal.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/AnotherSamWilson/miceforest",
    "keywords": "MICE,Imputation,Missing Values,Missing,Random Forest",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "miceforest",
    "package_url": "https://pypi.org/project/miceforest/",
    "platform": "",
    "project_url": "https://pypi.org/project/miceforest/",
    "project_urls": {
      "Homepage": "https://github.com/AnotherSamWilson/miceforest"
    },
    "release_url": "https://pypi.org/project/miceforest/3.0.0/",
    "requires_dist": [
      "lightgbm",
      "numpy",
      "pandas",
      "seaborn (>=0.11.0)",
      "matplotlib (>=3.3.0)",
      "scikit-learn ; extra == 'dmm'"
    ],
    "requires_python": ">=3.6",
    "summary": "Imputes missing data with MICE + random forests",
    "version": "3.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16075390,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e7d14147078c0dab0dc4a6710c59edaf076c8b1b05d77683487268d58e0d5a1b",
        "md5": "4d4e83f2c26befd283469ba51c8cea95",
        "sha256": "f2e9fd91be695744991646afa88e498b398104b80eafb79aab0c4de4e2957c12"
      },
      "downloads": -1,
      "filename": "miceforest-3.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "4d4e83f2c26befd283469ba51c8cea95",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 31846,
      "upload_time": "2021-09-03T23:11:38",
      "upload_time_iso_8601": "2021-09-03T23:11:38.579122Z",
      "url": "https://files.pythonhosted.org/packages/e7/d1/4147078c0dab0dc4a6710c59edaf076c8b1b05d77683487268d58e0d5a1b/miceforest-3.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "27a0af27b45988ad5fc98e5c6a0108d1570a98e1cba3b2b7e0c5258986a748e0",
        "md5": "c220936a1ef8c18184de29e3ea712a16",
        "sha256": "10083c127ecd66067439a57ca7920e629773c34c50fdb5e9b4cc0e4467fe8294"
      },
      "downloads": -1,
      "filename": "miceforest-3.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "c220936a1ef8c18184de29e3ea712a16",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 37190,
      "upload_time": "2021-09-03T23:11:41",
      "upload_time_iso_8601": "2021-09-03T23:11:41.110786Z",
      "url": "https://files.pythonhosted.org/packages/27/a0/af27b45988ad5fc98e5c6a0108d1570a98e1cba3b2b7e0c5258986a748e0/miceforest-3.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}