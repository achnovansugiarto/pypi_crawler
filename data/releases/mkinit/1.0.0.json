{
  "info": {
    "author": "Jon Crall",
    "author_email": "erotemic@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Utilities"
    ],
    "description": "mkinit\n======\n\n|CircleCI| |Travis| |Appveyor| |Codecov| |Pypi| |Downloads| |ReadTheDocs|\n\n\nRead the docs here: http://mkinit.readthedocs.io/en/latest/ (although this is\nmostly an API reference, the best getting started docs are currently in this\nREADME)\n\nThe ``mkinit`` module helps you write ``__init__`` files that expose all submodule\nattributes without ``from ? import *``.\n\n``mkinit`` automatically imports all submodules in a package and their members.\n\nIt can do this dynamically, or it can statically autogenerate the ``__init__``\nfor faster import times. Its kinda like using the ``fromimport *`` syntax, but\nits easy to replace with text that wont make other developers lose their hair.\n\nInstallation\n============\n\n.. code:: bash\n\n    pip install mkinit\n\n\nThe Pitch\n---------\n\nSay you have a python module structured like so:\n\n.. code::\n\n    └── mkinit_demo_pkg\n        ├── __init__.py\n        ├── submod.py\n        └── subpkg\n            ├── __init__.py\n            └── nested.py\n\n\nAnd you would like to make all functions inside of ``submod.py`` and\n``nested.py`` available at the top-level of the package. \n\nImagine the contents of submod.py and nested.py are:\n\n.. code:: python\n\n    # --- submod.py ---\n\n    def submod_func():\n        print('This is a submod func in {}'.format(__file__))\n\n    # --- nested.py ---\n\n    def nested_func():\n        print('This is a nested func in {}'.format(__file__))\n\nYou could manually write:\n\n\n.. code:: python\n    \n    from mkinit_demo_pkg.submod import *\n    from mkinit_demo_pkg.subpkg.nested import *\n\n\nBut that has a few problems. Using ``import *`` makes it hard for people\nreading the code to know what is coming from where. Furthermore, if there were\nmany submodules you wanted to expose attributes of, writing this would become\ntedious and hard to maintain. \n\nEnter the mkinit package. It has the ability to autogenerate explicit ``__init__.py``\nfiles using static analysis. Normally, the mkinit CLI only works on one file at\na time, but if we specify the ``--recursive`` flag, then mkinit will\nrecursively generate ``__init__.py`` files for all subpackages in the package.\n\nThus running ``mkinit mkinit_demo_pkg --recursive`` will result in a root\n``__init__.py`` file that looks like this:\n\n.. code:: python\n\n    from mkinit_demo_pkg import submod\n    from mkinit_demo_pkg import subpkg\n\n    from mkinit_demo_pkg.submod import (submod_func,)\n    from mkinit_demo_pkg.subpkg import (nested, nested_func,)\n\n    __all__ = ['nested', 'nested_func', 'submod', 'submod_func', 'subpkg']\n\n\nThat's pretty cool. The mkinit package was able to recursively parse our\npackage, find all of the defined names, and then generate ``__init__.py`` files\nsuch that all attributes are exposed at the top level of the package.\nFurthermore, this file is **readable**. It is perfectly clear exactly what\nnames are exposed in this module without having to execute anything.\n\n\nOf course, this isn't a perfect solution. Perhaps only some submodules should\nbe exposed, perhaps you would rather use relative import statements, maybe you\nonly want to expose submodule but not their attributes, or vis-versa. Well good\nnews, because mkinit has command line flags that allow for all of these modes.\nSee ``mkinit --help`` for more details.\n\n\nLastly, while exposing all attributes can be helpful for larger projects,\nimport time can start to become a consideration. Thankfully, PEP 0562 outlines\na lazy import specification for Python >= 3.7. As of 2020-12-26 mkinit\nsupports autogenerating these lazy init files. \n\nUnfortunately, there is no syntax support for lazy imports, so mkinit must\ndefine a ``lazy_import`` boilerplate function in each ``__init__.py`` file.\n\n\n.. code:: python\n\n    def lazy_import(module_name, submodules, submod_attrs):\n        \"\"\"\n        Boilerplate to define PEP 562 __getattr__ for lazy import\n        https://www.python.org/dev/peps/pep-0562/\n        \"\"\"\n        import importlib\n        import os\n        name_to_submod = {\n            func: mod for mod, funcs in submod_attrs.items()\n            for func in funcs\n        }\n\n        def __getattr__(name):\n            if name in submodules:\n                attr = importlib.import_module(\n                    '{module_name}.{name}'.format(\n                        module_name=module_name, name=name)\n                )\n            elif name in name_to_submod:\n                submodname = name_to_submod[name]\n                module = importlib.import_module(\n                    '{module_name}.{submodname}'.format(\n                        module_name=module_name, submodname=submodname)\n                )\n                attr = getattr(module, name)\n            else:\n                raise AttributeError(\n                    'No {module_name} attribute {name}'.format(\n                        module_name=module_name, name=name))\n            globals()[name] = attr\n            return attr\n\n        if os.environ.get('EAGER_IMPORT', ''):\n            for name in submodules:\n                __getattr__(name)\n\n            for attrs in submod_attrs.values():\n                for attr in attrs:\n                    __getattr__(attr)\n        return __getattr__\n\n    \n    __getattr__ = lazy_import(\n        __name__,\n        submodules={\n            'submod',\n            'subpkg',\n        },\n        submod_attrs={\n            'submod': [\n                'submod_func',\n            ],\n            'subpkg': [\n                'nested',\n                'nested_func',\n            ],\n        },\n    )\n\n    def __dir__():\n        return __all__\n\n    __all__ = ['nested', 'nested_func', 'submod', 'submod_func', 'subpkg']\n\n\n\nCommand Line Usage\n------------------\n\nThe following command will statically autogenerate an `__init__` file in the\nspecified path or module name. If one exists, it will only replace text after\nthe final comment. This means `mkinit` wont clobber your custom logic and can\nbe used to help maintain customized `__init__.py` files.\n\n.. code:: bash\n\n    mkinit <your_modname_or_modpath> -w\n\n\nYou can also enclose the area allowed to be clobbered in the auto-generation\nwith special xml-like comments.\n\nDynamic Usage\n-------------\n\nNOTE: Dynamic usage is NOT recommended. \n\nIn most cases, we recommend using mkinit command line tool to statically\ngenerate / update the `__init__.py` file, but there is an option to to use it\ndynamically (although this might be considered worse practice than using\n``import *``).\n\n.. code:: python\n\n    import mkinit; exec(mkinit.dynamic_init(__name__))\n\n\nExamples\n========\n\nThe `mkinit` module is used by the\n`ubelt`(https://www.github.com/Erotemic/ubelt) library to explicitly\nauto-generate part of the `__init__.py` file. This example walks through the\ndesign of this module to illustrate the usage of `mkinit`.\n\nStep 1 (Optional): Write any custom `__init__` code\n----------------------------------------------------\n\nThe first section of the `ubelt` module consists of manually written code. It\ncontains coding, `flake8` directives, a docstring a few comments, a future\nimport, and a custom `__version__` attribute. Here is an example of this\nmanually written code in the `0.2.0.dev0` version of `ubelt`.\n\n.. code:: python\n\n    # -*- coding: utf-8 -*-\n    # flake8: noqa\n    \"\"\"\n    CommandLine:\n        # Partially regenerate __init__.py\n        mkinit ubelt\n    \"\"\"\n    # Todo:\n    #     The following functions and classes are candidates to be ported from utool:\n    #     * reload_class\n    #     * inject_func_as_property\n    #     * accumulate\n    #     * rsync\n    from __future__ import absolute_import, division, print_function, unicode_literals\n\n    __version__ = '0.2.0'\n\nIt doesn't particularly matter what the above code is, the point is to\nillustrate that `mkinit` does not prevent you from customizing your code. By\ndefault auto-generation will only start clobbering existing code after the\nfinal comment, in the file, which is a decent heuristic, but as we will see,\nthere are other more explicit ways to define exactly where auto-generated code\nis allowed.\n\nStep 2 (Optional): Enumerate relevant submodules\n------------------------------------------------\n\nAfter optionally writing any custom code, you may optionally specify exactly\nwhat submodules should be considered when auto-generating imports. This is done\nby setting the `__submodules__` attribute to a list of submodule names. \n\nIn `ubelt` this section looks similar to the following:\n\n.. code:: python\n\n    __submodules__ = [\n        'util_arg',\n        'util_cmd',\n        'util_dict',\n        'util_links',\n        'util_hash',\n        'util_import',\n        'orderedset',\n        'progiter',\n    ]\n\nNote that this step is optional, but recommended. If the `__submodules__`\npackage is not specified, then all paths matching the glob expressions `*.py`\nor `*/__init__.py` are considered as part of the package.\n\nStep 3: Autogenerate explicitly\n-------------------------------\n\nTo provide the fastest import times and most readable `__init__.py` files, use\nthe `mkinit` command line script to statically parse the submodules and\npopulate the `__init__.py` file with the submodules and their top-level\nmembers.\n\nBefore running this script it is good practice to paste the XML-like comment\ndirectives into the `__init__.py` file. This restricts where `mkinit` is\nallowed to autogenerate code, and it also uses the same indentation of the\ncomments in case you want to run the auto-generated code conditionally. Note,\nif the second tag is not specified, then it is assumed that `mkinit` can\noverwrite everything after the first tag.\n\n.. code:: python\n\n    # <AUTOGEN_INIT>\n    pass\n    # </AUTOGEN_INIT>\n\nNow that we have inserted the auto-generation tags, we can actually run\n`mkinit`.  In general this is done by running `mkinit <path-to-pkg-directory>`.\n\nAssuming the `ubelt` repo is checked out in `~/code/`, the command to\nautogenerate its `__init__.py` file would be: `mkinit ~/code/ubelt/ubelt`.\nGiven the previously specified `__submodules__`, the resulting auto-generated\nportion of the code looks like this: \n\n\n.. code:: python\n\n    # <AUTOGEN_INIT>\n    from ubelt import util_arg\n    from ubelt import util_cmd\n    from ubelt import util_dict\n    from ubelt import util_links\n    from ubelt import util_hash\n    from ubelt import util_import\n    from ubelt import orderedset\n    from ubelt import progiter\n    from ubelt.util_arg import (argflag, argval,)\n    from ubelt.util_cmd import (cmd,)\n    from ubelt.util_dict import (AutoDict, AutoOrderedDict, ddict, dict_hist,\n                                 dict_subset, dict_take, dict_union, dzip,\n                                 find_duplicates, group_items, invert_dict,\n                                 map_keys, map_vals, odict,)\n    from ubelt.util_links import (symlink,)\n    from ubelt.util_hash import (hash_data, hash_file,)\n    from ubelt.util_import import (import_module_from_name,\n                                   import_module_from_path, modname_to_modpath,\n                                   modpath_to_modname, split_modpath,)\n    from ubelt.orderedset import (OrderedSet, oset,)\n    from ubelt.progiter import (ProgIter,)\n    __all__ = ['util_arg', 'util_cmd', 'util_dict', 'util_links', 'util_hash',\n               'util_import', 'orderedset', 'progiter', 'argflag', 'argval', 'cmd',\n               'AutoDict', 'AutoOrderedDict', 'ddict', 'dict_hist', 'dict_subset',\n               'dict_take', 'dict_union', 'dzip', 'find_duplicates', 'group_items',\n               'invert_dict', 'map_keys', 'map_vals', 'odict', 'symlink',\n               'hash_data', 'hash_file', 'import_module_from_name',\n               'import_module_from_path', 'modname_to_modpath',\n               'modpath_to_modname', 'split_modpath', 'OrderedSet', 'oset',\n               'ProgIter']\n\nWhen running the command-line `mkinit` tool, the target module is inspected\nusing static analysis, so no code from the target module is ever run. This\navoids unintended side effects, prevents arbitrary code execution, and ensures\nthat `mkinit` will do something useful even if there would otherwise be a\nruntime error.\n\nStep 3 (alternate): Autogenerate dynamically\n--------------------------------------------\n\nWhile running `mkinit` from the command line produces the cleanest and most\nreadable `__init__.py`, you have to run it every time you make a change to your\nlibrary. This is not always desirable especially during rapid development of a\nnew Python package. In this case it is possible to dynamically execute `mkinit`\non import of your module. To use dynamic initialization simply paste the\nfollowing lines into the `__init__.py` file.\n\n.. code:: python\n\n    import mkinit\n    exec(mkinit.dynamic_init(__name__, __submodules__))\n\nThis is almost equivalent to running the static command line variant.  However,\ninstead of using static analysis, this will use the Python interpreter to\nexecute and import all submodules and dynamically inspect the defined members.\nThis is faster than using static analysis, and in most circumstances there will\nbe no difference in the resulting imported attributes. To avoid all differences \nsimply specify the `__all__` attribute in each submodule.\n\nNote that inclusion of the `__submodules__` attribute is not strictly\nnecessary. The dynamic version of this function will look in the parent stack\nframe for this attribute if it is not specified explicitly as an argument.\n\nIt is also possible to achieve a \"best of both worlds\" trade-off using\nconditional logic. Use a conditional block to execute dynamic initialization\nand place the static auto-generation tags in the block that is not executed.\nThis lets you develop without worrying about updating the `__init__.py` file,\nand lets you statically generate the code for documentation purposes when you\nwant to. Once the rapid development phase is over, you can remove the dynamic\nconditional, keep the auto-generated portion, and forget you ever used `mkinit`\nin the first place!\n\n\n.. code:: python\n\n    __DYNAMIC__ = True\n    if __DYNAMIC__:\n        from mkinit import dynamic_mkinit\n        exec(dynamic_mkinit.dynamic_init(__name__))\n    else:\n        # <AUTOGEN_INIT>\n        from mkinit import dynamic_mkinit\n        from mkinit import static_mkinit\n        from mkinit.dynamic_mkinit import (dynamic_init,)\n        from mkinit.static_mkinit import (autogen_init,)\n        # </AUTOGEN_INIT>\n\n\nBehavior Notes\n--------------\n\nThe `mkinit` module is a simple way to execute a complex task. At times it may\nseem like magic, although I assure you it is not. To minimize perception of\nmagic and maximize understanding of its behaviors, please consider the\nfollowing:\n\n    * When discovering attributes of submodules `mkinit` will respect the `__all__`\n      attribute by default. In general it is good practice to specify this\n      property; doing so will also avoid the following caveats.\n\n    * Static analysis currently only extracts top-level module attributes. However, \n      if will also extract attributes defined on all non-error raising paths of\n      conditional if-else or try-except statements. \n\n    * Static analysis currently does not look or account for the usage of the `del`\n      operator. Again, these will be accounted for by dynamic analysis.\n\n    * In the case where no `__init__.py` file exists, the `mkinit` command line\n      tool will create one.\n\n    * By default we ignore attributes that are marked as non-public by a leading\n      underscore\n\nTODO\n----\n\n    - [ ] Give `dynamic_init` an options dict to maintain a compatible API with `static_init`.\n\n    - [ ] If an attribute would be defined twice, then don't define it at all.\n      Currently, it is defined, but its value is not well-defined.\n\n\n.. |CircleCI| image:: https://circleci.com/gh/Erotemic/mkinit.svg?style=svg\n    :target: https://circleci.com/gh/Erotemic/mkinit\n.. |Travis| image:: https://img.shields.io/travis/Erotemic/mkinit/master.svg?label=Travis%20CI\n   :target: https://travis-ci.org/Erotemic/mkinit?branch=master\n.. |Appveyor| image:: https://ci.appveyor.com/api/projects/status/github/Erotemic/mkinit?branch=master&svg=True\n   :target: https://ci.appveyor.com/projegt/Erotemic/mkinit/branch/master\n.. |Codecov| image:: https://codecov.io/github/Erotemic/mkinit/badge.svg?branch=master&service=github\n   :target: https://codecov.io/github/Erotemic/mkinit?branch=master\n.. |Pypi| image:: https://img.shields.io/pypi/v/mkinit.svg\n   :target: https://pypi.python.org/pypi/mkinit\n.. |Downloads| image:: https://img.shields.io/pypi/dm/mkinit.svg\n   :target: https://pypistats.org/packages/mkinit\n.. |ReadTheDocs| image:: https://readthedocs.org/projects/mkinit/badge/?version=latest\n    :target: http://mkinit.readthedocs.io/en/latest/\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Erotemic/mkinit",
    "keywords": "",
    "license": "Apache 2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mkinit",
    "package_url": "https://pypi.org/project/mkinit/",
    "platform": null,
    "project_url": "https://pypi.org/project/mkinit/",
    "project_urls": {
      "Homepage": "https://github.com/Erotemic/mkinit"
    },
    "release_url": "https://pypi.org/project/mkinit/1.0.0/",
    "requires_dist": [
      "ubelt",
      "Pygments ; extra == 'all'",
      "codecov ; extra == 'all'",
      "packaging ; extra == 'all'",
      "ubelt ; extra == 'all'",
      "xdoctest ; extra == 'all'",
      "Pygments (==2.2.0) ; extra == 'all-strict'",
      "codecov (==2.0.15) ; extra == 'all-strict'",
      "packaging (==21.3) ; extra == 'all-strict'",
      "ubelt (==1.2.2) ; extra == 'all-strict'",
      "xdoctest (==0.14.0) ; extra == 'all-strict'",
      "colorama ; (platform_system == \"Windows\") and extra == 'all-strict'",
      "coverage (==4.5) ; (python_version < \"2.7\" and python_version >= \"2.6\") and extra == 'all-strict'",
      "pytest-cov (==2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all-strict'",
      "pytest (<=4.6.11,==4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.10\" and python_version >= \"3.9\") and extra == 'all-strict'",
      "pytest (==4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'all-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.4\" and python_version >= \"2.7\") and extra == 'all-strict'",
      "coverage (==4.3.4) ; (python_version < \"3.5\" and python_version >= \"3.4\") and extra == 'all-strict'",
      "pytest-cov (==2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all-strict'",
      "pytest (<=4.6.11,==4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.6\" and python_version >= \"3.5\") and extra == 'all-strict'",
      "pytest-cov (==2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all-strict'",
      "pytest (<=6.1.2,==4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.7\" and python_version >= \"3.6\") and extra == 'all-strict'",
      "pytest (==4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'all-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.8\" and python_version >= \"3.7\") and extra == 'all-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.9\" and python_version >= \"3.8\") and extra == 'all-strict'",
      "black ; (python_version > \"3.5\" and platform_python_implementation == \"CPython\") and extra == 'all-strict'",
      "coverage (==6.1.1) ; (python_version >= \"3.10\") and extra == 'all-strict'",
      "pytest (==6.2.5) ; (python_version >= \"3.10.0\") and extra == 'all-strict'",
      "pytest-cov (==3.0.0) ; (python_version >= \"3.6.0\") and extra == 'all-strict'",
      "colorama ; (platform_system == \"Windows\") and extra == 'all'",
      "coverage ; (python_version < \"2.7\" and python_version >= \"2.6\") and extra == 'all'",
      "pytest ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all'",
      "pytest-cov ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all'",
      "coverage ; (python_version < \"3.10\" and python_version >= \"3.9\") and extra == 'all'",
      "pytest ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'all'",
      "coverage ; (python_version < \"3.4\" and python_version >= \"2.7\") and extra == 'all'",
      "coverage ; (python_version < \"3.5\" and python_version >= \"3.4\") and extra == 'all'",
      "pytest ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all'",
      "pytest-cov ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all'",
      "coverage ; (python_version < \"3.6\" and python_version >= \"3.5\") and extra == 'all'",
      "pytest ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all'",
      "pytest-cov ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all'",
      "coverage ; (python_version < \"3.7\" and python_version >= \"3.6\") and extra == 'all'",
      "pytest ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'all'",
      "coverage ; (python_version < \"3.8\" and python_version >= \"3.7\") and extra == 'all'",
      "coverage ; (python_version < \"3.9\" and python_version >= \"3.8\") and extra == 'all'",
      "black ; (python_version > \"3.5\" and platform_python_implementation == \"CPython\") and extra == 'all'",
      "coverage ; (python_version >= \"3.10\") and extra == 'all'",
      "pytest ; (python_version >= \"3.10.0\") and extra == 'all'",
      "pytest-cov ; (python_version >= \"3.6.0\") and extra == 'all'",
      "Pygments ; extra == 'optional'",
      "Pygments (==2.2.0) ; extra == 'optional-strict'",
      "colorama ; (platform_system == \"Windows\") and extra == 'optional-strict'",
      "black ; (python_version > \"3.5\" and platform_python_implementation == \"CPython\") and extra == 'optional-strict'",
      "colorama ; (platform_system == \"Windows\") and extra == 'optional'",
      "black ; (python_version > \"3.5\" and platform_python_implementation == \"CPython\") and extra == 'optional'",
      "ubelt (==1.2.2) ; extra == 'runtime-strict'",
      "codecov ; extra == 'tests'",
      "packaging ; extra == 'tests'",
      "xdoctest ; extra == 'tests'",
      "codecov (==2.0.15) ; extra == 'tests-strict'",
      "packaging (==21.3) ; extra == 'tests-strict'",
      "xdoctest (==0.14.0) ; extra == 'tests-strict'",
      "coverage (==4.5) ; (python_version < \"2.7\" and python_version >= \"2.6\") and extra == 'tests-strict'",
      "pytest-cov (==2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests-strict'",
      "pytest (<=4.6.11,==4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.10\" and python_version >= \"3.9\") and extra == 'tests-strict'",
      "pytest (==4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'tests-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.4\" and python_version >= \"2.7\") and extra == 'tests-strict'",
      "coverage (==4.3.4) ; (python_version < \"3.5\" and python_version >= \"3.4\") and extra == 'tests-strict'",
      "pytest-cov (==2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests-strict'",
      "pytest (<=4.6.11,==4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests-strict'",
      "coverage (==5.3.1) ; (python_version < \"3.6\" and python_version >= \"3.5\") and extra == 'tests-strict'",
      "pytest-cov (==2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests-strict'",
      "pytest (<=6.1.2,==4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.7\" and python_version >= \"3.6\") and extra == 'tests-strict'",
      "pytest (==4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'tests-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.8\" and python_version >= \"3.7\") and extra == 'tests-strict'",
      "coverage (==6.1.1) ; (python_version < \"3.9\" and python_version >= \"3.8\") and extra == 'tests-strict'",
      "coverage (==6.1.1) ; (python_version >= \"3.10\") and extra == 'tests-strict'",
      "pytest (==6.2.5) ; (python_version >= \"3.10.0\") and extra == 'tests-strict'",
      "pytest-cov (==3.0.0) ; (python_version >= \"3.6.0\") and extra == 'tests-strict'",
      "coverage ; (python_version < \"2.7\" and python_version >= \"2.6\") and extra == 'tests'",
      "pytest ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests'",
      "pytest-cov ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests'",
      "coverage ; (python_version < \"3.10\" and python_version >= \"3.9\") and extra == 'tests'",
      "pytest ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'tests'",
      "coverage ; (python_version < \"3.4\" and python_version >= \"2.7\") and extra == 'tests'",
      "coverage ; (python_version < \"3.5\" and python_version >= \"3.4\") and extra == 'tests'",
      "pytest ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests'",
      "pytest-cov ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests'",
      "coverage ; (python_version < \"3.6\" and python_version >= \"3.5\") and extra == 'tests'",
      "pytest ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests'",
      "pytest-cov ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests'",
      "coverage ; (python_version < \"3.7\" and python_version >= \"3.6\") and extra == 'tests'",
      "pytest ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'tests'",
      "coverage ; (python_version < \"3.8\" and python_version >= \"3.7\") and extra == 'tests'",
      "coverage ; (python_version < \"3.9\" and python_version >= \"3.8\") and extra == 'tests'",
      "coverage ; (python_version >= \"3.10\") and extra == 'tests'",
      "pytest ; (python_version >= \"3.10.0\") and extra == 'tests'",
      "pytest-cov ; (python_version >= \"3.6.0\") and extra == 'tests'"
    ],
    "requires_python": ">=3.6",
    "summary": "Autogenerate __init__.py files",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15981773,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "58a1f0dccb88bd9319956b842b866d4c37adda44a397aaf989ec069a0fae45f0",
        "md5": "275bc9248fb5a3d0b14633148f22850b",
        "sha256": "7e1389f935c1465181b16bc3a34ccbf942dc91c7699795122d013989a74858cb"
      },
      "downloads": -1,
      "filename": "mkinit-1.0.0-py3-none-any.whl",
      "has_sig": true,
      "md5_digest": "275bc9248fb5a3d0b14633148f22850b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 52385,
      "upload_time": "2022-12-03T23:21:59",
      "upload_time_iso_8601": "2022-12-03T23:21:59.911539Z",
      "url": "https://files.pythonhosted.org/packages/58/a1/f0dccb88bd9319956b842b866d4c37adda44a397aaf989ec069a0fae45f0/mkinit-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "876c679a8c45e956adaabb933076b762fa2034e7ad4e80d957e5bc7d66556853",
        "md5": "5318c58b3489f4bea0d63786c1e33d7c",
        "sha256": "18ff505b8670b7bb7aa1efe6e7967abc5f820d854e71d33800564f532d2b94f6"
      },
      "downloads": -1,
      "filename": "mkinit-1.0.0.tar.gz",
      "has_sig": true,
      "md5_digest": "5318c58b3489f4bea0d63786c1e33d7c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 52649,
      "upload_time": "2022-12-03T23:22:03",
      "upload_time_iso_8601": "2022-12-03T23:22:03.244822Z",
      "url": "https://files.pythonhosted.org/packages/87/6c/679a8c45e956adaabb933076b762fa2034e7ad4e80d957e5bc7d66556853/mkinit-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}