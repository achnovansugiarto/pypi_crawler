{
  "info": {
    "author": "Dusan Klinec",
    "author_email": "dusan.klinec@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Topic :: Security"
    ],
    "description": "Monero Python serialization library\n===================================\n\n|Build Status|\n\nThe library provides basic serialization logic for the Monero types,\nused in transaction processing and transaction signing.\n\n-  Mainly supports binary serialization equivalent to Monero\n   ``BEGIN_SERIALIZE_OBJECT()``. This serialization mechanism is used in\n   the blockchain entity serialization.\n-  Boost portable serialization added.\n-  Support for ``BEGIN_KV_SERIALIZE_MAP`` is mainly supported. JSON and\n   binary wire format.\n\nThe binary wire formats use streaming dumping / parsing for better\nmemory efficiency.\n\nFor usage please take a look at\n`tests <https://github.com/ph4r05/monero-serialize/tree/master/monero_serialize/tests>`__.\n\n::\n\n    pip install monero-serialize\n\nExample usage:\n--------------\n\n.. code:: python\n\n    import binascii\n    from monero_serialize import xmrserialize as x\n    from monero_serialize import xmrtypes as xmr\n\n    msg = xmr.TxinToKey(amount=123, key_offsets=[1, 2, 3, 2**76], k_image=bytearray(range(32)))\n\n    # Serialize\n    writer = x.MemoryReaderWriter()\n    await x.dump_message(writer, msg)\n    print(binascii.hexlify(writer.buffer))\n\n    # Deserialize\n    test_deser = await x.load_message(x.MemoryReaderWriter(writer.buffer), xmr.TxinGen)\n\nDonations\n=========\n\nThanks for your support!\n\n::\n\n    86KCjujm1Hp4dD2uyZdXjHQr5e5aNujG6LcunA8iQYjx4AwRorVLDpHMKKmrKQfAPFC5KCKPpjdax3NEbExBRTnSTS1QXWA\n\nAdvanced usage\n==============\n\nArchive interface\n-----------------\n\n.. code:: python\n\n    import binascii\n    from monero_serialize import xmrserialize as x\n    from monero_serialize import xmrtypes as xmr\n\n    msg = xmr.TxinGen(height=42)\n\n    # Serialize\n    writer = x.MemoryReaderWriter()\n    ar1 = x.Archive(writer, True)\n    await ar1.message(msg)\n\n    # Deserialize\n    msg2 = xmr.TxinGen()\n    ar2 = x.Archive(x.MemoryReaderWriter(writer.buffer), False)\n    await ar2.message(msg2)\n\nSymmetric Boost archive\n-----------------------\n\n.. code:: python\n\n    import binascii\n    from monero_serialize import xmrserialize as x\n    from monero_serialize import xmrtypes as xmr\n    from monero_serialize import xmrboost as xmrb\n\n    data_hex = b'011673657269616c697a6174696f6e3a3a61726368697665000000000134'\n    data_bin = base64.b16decode(data_hex, True)\n    reader = x.MemoryReaderWriter(bytearray(data_bin))\n    ar = xmrb.Archive(reader, False)\n\n    msg = xmr.TxinGen()\n    await ar.root_message(msg)\n    self.assertEqual(msg.height, 0x34)\n\nXMR classes\n-----------\n\n.. code:: python\n\n    class Hash(x.BlobType): pass;\n    class ECKey(x.BlobType): pass;\n    class ECPoint(x.BlobType): pass;\n    class SecretKey(ECKey): pass;\n    class ECPublicKey(ECPoint): pass;\n    class KeyImage(ECPoint): pass;\n    class KeyDerivation(ECPoint): pass;\n    class TxoutToScript(x.MessageType): pass;\n    class TxoutToKey(x.MessageType): pass;\n    class TxoutToScriptHash(x.MessageType): pass;\n    class TxoutTargetV(x.VariantType): pass;\n    class TxinGen(x.MessageType): pass;\n    class TxinToKey(x.MessageType): pass;\n    class TxinToScript(x.MessageType): pass;\n    class TxinToScriptHash(x.MessageType): pass;\n    class TxInV(x.VariantType): pass;\n    class TxOut(x.MessageType): pass;\n    class TransactionPrefix(x.MessageType): pass;\n    class TransactionPrefixExtraBlob(TransactionPrefix): pass;\n    class TxIndex(x.MessageType): pass;\n    class TransactionMetaData(x.MessageType): pass;\n\n    #\n    # rctTypes.h\n    #\n\n    class Key64(x.ContainerType): pass;\n    class KeyV(x.ContainerType): pass;\n    class KeyM(x.ContainerType): pass;\n    class KeyVFix(x.ContainerType): pass;\n    class KeyMFix(x.ContainerType): pass;\n    class CtKey(x.MessageType): pass;\n    class CtkeyV(x.ContainerType): pass;\n    class CtkeyM(x.ContainerType): pass;\n    class MultisigKLRki(x.MessageType): pass;\n    class MultisigOut(x.MessageType): pass;\n    class EcdhTuple(x.MessageType): pass;\n    class BoroSig(x.MessageType): pass;\n    class MgSig(x.MessageType): pass;\n    class RangeSig(x.MessageType): pass;\n    class Bulletproof(x.MessageType): pass;\n    class EcdhInfo(x.ContainerType): pass;\n    class RctSigBase(x.MessageType): pass;\n    class RctSigPrunable(x.MessageType): pass;\n    class RctSig(RctSigBase): pass;\n    class Signature(x.MessageType): pass;\n    class SignatureArray(x.ContainerType): pass;\n    class Transaction(TransactionPrefix): pass;\n    class BlockHeader(x.MessageType): pass;\n    class HashVector(x.ContainerType): pass;\n    class Block(BlockHeader): pass;\n    class AccountPublicAddress(x.MessageType): pass;\n    class SubaddressIndex(x.MessageType): pass;\n    class MultisigLR(x.MessageType): pass;\n    class MultisigInfo(x.MessageType): pass;\n    class MultisigStruct(x.MessageType): pass;\n    class TxExtraPadding(x.MessageType): pass;\n    class TxExtraPubKey(x.MessageType): pass;\n    class TxExtraNonce(x.MessageType): pass;\n    class TxExtraMergeMiningTag(x.MessageType): pass;\n    class TxExtraAdditionalPubKeys(x.MessageType): pass;\n    class TxExtraMysteriousMinergate(x.MessageType): pass;\n    class TxExtraField(x.VariantType): pass;\n    class TxExtraFields(x.ContainerType): pass;\n    class OutputEntry(x.TupleType): pass;\n    class TxSourceEntry(x.MessageType): pass;\n    class TxDestinationEntry(x.MessageType): pass;\n    class TransferDetails(x.MessageType): pass;\n    class TxConstructionData(x.MessageType): pass;\n    class PendingTransaction(x.MessageType): pass;\n    class PendingTransactionVector(x.ContainerType): pass;\n    class UnsignedTxSet(x.MessageType): pass;\n    class SignedTxSet(x.MessageType): pass;\n    class MultisigTxSet(x.MessageType): pass;\n\nSerialization formats\n=====================\n\nBlockchain format\n-----------------\n\nThe BC serialization format is scheme-oriented, i.e., you have to\nprovide the scheme according to which serialize/deserialize the data.\nScheme specifies how are fields composed, whether the size of containers\nis fixed (and then also the size is specified by the scheme) or not.\n\nThe format is not versioned, i.e., serialization format does not store\nexplicit version numbers which would affect serialization scheme.\n\nUvarint\n~~~~~~~\n\n-  Variable length integer encoded by 7-bit chunks, little endian.\n-  The MSB indicates whether there are more octets (1) or it is the last\n   one (0).\n-  0 - 0x7f encoded in 1 byte, 0x80 - 0x3fff encoded in 2 bytes, ...\n\nExample: - ``0x0f     -> 0f`` - ``0x1000   -> 8020`` -\n``0xffff   -> ffff03`` - ``0xffffff -> ffffff07``\n\nUInt\n~~~~\n\n-  Fixed width integer, little endian encoded\n\nExample:\n\n-  ``0x0f     Width 4 = 0f000000``\n-  ``0x1000   Width 4 = 001000``\n-  ``0xffffff Width 4 = ffffff00``\n\nBlob\n~~~~\n\n-  Binary bytes can have either fixed size or variable size.\n-  Variable size format: ``uvarint(lenght) || data``\n-  Fixed-size format: ``data``\n-  Typical example of a fixed-width blob is EC point or scalar, which\n   has 32 bytes\n\nUnicode string\n~~~~~~~~~~~~~~\n\n-  Format: ``uvarint(length) || input.encode(\"utf8\")``\n\nContainer\n~~~~~~~~~\n\n-  Variable size format: ``uvarint(length) || *elements``\n-  Fixed size format: ``*elements``\n-  Elements are serialized according to the scheme of the element.\n-  All elements are of the same type which is specified by the schema of\n   the container\n\nTuple\n~~~~~\n\n-  Tuple is heterogenous\n-  Format: ``uvarint(length) || *elements``\n-  Each element is serialized according to the scheme specified in the\n   tuple\n\nVariant\n~~~~~~~\n\n-  Similar to union from C, stores precisely one data type out of many\n-  Variants are identified by 1 byte code\n-  Format: ``uint(variant_code) || variant_object``\n-  Variant object is serialized according to the scheme corresponding\n   for the particular variant\n\nMessage / object\n~~~~~~~~~~~~~~~~\n\n-  Collection of heterogenous fields\n-  Fields are serialized according to the scheme\n-  Field ordering is fixed by the message scheme\n-  Field have names, but no name nor number of fields are serialized\n-  Messages serialization scheme can vary based on the version number\n   provided from outside\n\nBoost serialization\n-------------------\n\n-  Mainly used by the wallet and for internal purposes.\n-  Scheme oriented format. Scheme is required to understand the\n   serialized data.\n-  Versioned serialization format, explicitly storing version numbers to\n   the serialized data.\n-  Reference: `Boost\n   Serialization <https://www.boost.org/doc/libs/1_61_0/libs/serialization/doc/index.html>`__\n-  Archive starts with the header\n   ``011673657269616c697a6174696f6e3a3a617263686976650000`` which\n   translates to ``\\x01\\x16serialization::archive\\x00\\x00``. The\n   ``[-2]`` byte enables tracking (tracking is not supported in this\n   lib), ``[-1]`` is a version of root element.\n-  `Basic\n   archive <https://www.boost.org/doc/libs/1_66_0/libs/serialization/src/basic_oarchive.cpp>`__\n\nVersioning\n~~~~~~~~~~\n\n-  Schemes are versioned based on the C++ type, this python lib\n   identifies the object based on its type and parameters (e.g.\n   container + element type). Once the version for particular type has\n   been stored to the stream, it is not stored again. In C++ this is\n   handled by the type system and compiler. In this library we have to\n   explicitly track whether the type version has been already stored.\n-  Elementary types are not versioned (int, uvarint, unicode)\n-  Versioning can be disabled in the complex types\n-  Version is stored as the following tuple:\n   ``(uvarint(tracking) || uvarint(version))``\n-  tracking relates to the `Boost Object\n   Tracking <https://www.boost.org/doc/libs/1_61_0/libs/serialization/doc/special.html#objecttracking>`__,\n   advanced construct used with pointers (tracking by memory address),\n   alpha version of tracking is supported for reading the archive.\n-  tracking in C++ code: ``BOOST_CLASS_TRACKING``\n-  Versioning in the `Boost\n   docs <https://www.boost.org/doc/libs/1_61_0/libs/serialization/doc/tutorial.html#versioning>`__\n-  If tracking is enabled, the format is:\n   ``(uvarint(tracking) || uvarint(version) || uvarint(object_id))``\n\nUvarint\n~~~~~~~\n\n-  First byte encodes length and sign. Supports byte widths: 0-8. 2 byte\n   positive number: 0x2, 2 byte negative number: 0xfe\n-  Encoding in 8bit chunks, little endian.\n-  Uvarint serialization scheme defined by Monero code.\n\nUnicode\n~~~~~~~\n\n-  Format: ``uvarint(length) || input.encode(\"utf8\")``\n\nBlob\n~~~~\n\n-  Format: ``uvarint(length) || data``\n\nContainer\n~~~~~~~~~\n\n-  Primitive type containers are not versioned, in general, container is\n   versioned.\n-  After version follows ``uvarint(length)``\n-  Version of the element follows as ``uvarint(element_version)``\n   (exception for case of raw containers = statically allocated like\n   Key64)\n-  Elements follow. If element is serialized for the first time, same\n   rules apply for the versioning - version is stored.\n-  Example:\n   ``(tr, v), collection_size, element_version, (obj_tr, obj_v), obj1, obj2, ...``\n\nTuple\n~~~~~\n\n-  Versioned\n-  Stored without size information - obtained from the scheme\n\nVariant\n~~~~~~~\n\n-  Versioned\n-  Format: ``uvarint(variant_code) || field``\n-  Example: ``(tr, v), which, (tr, v), val``\n\nMessage\n~~~~~~~\n\n-  Versioned\n-  Stores field in a defined order, without storing field names or field\n   types. Types are derived from the scheme.\n-  Fields serialized recursively.\n\nJSONRPC\n-------\n\n-  Monero serialization format, with either binary or JSON form\n-  Defines serialization types supported by the format, each supported\n   serialization primitive has a tag.\n-  signed and unsigned integers of a fixed widths of: 18, 16,32, 64 bits\n-  boolean\n-  double\n-  string\n-  object\n-  array\n\n-  Root of archive starts with the ``0x01011101 || 0x01020101 || 0x1``,\n   i.e, signature A, signature B, format version\n-  Archive can be parsed as JSON, i.e., without scheme.\n\nIntegers\n~~~~~~~~\n\n-  Integer to encode is N, then the format encodes ``N<<2 | size_flag``\n   as little endian\n-  Flags 0, 1, 2, 3 correspond to 1, 2, 4, 8 byte integers\n   correspondingly\n\nString\n~~~~~~\n\n-  Format: ``uvarint(length) || data``\n\nArray\n~~~~~\n\n-  Serializes ``element_type | SerializeType.ARRAY_FLAG`` as integer,\n   where ``element_type`` is the object tag.\n-  Serializes length of the container\n-  Serializes each element recursively\n\nSection / object\n~~~~~~~~~~~~~~~~\n\n-  Correspond to JSON dictionaries with string keys\n-  Format:\n   ``uvarint(length) || serialize_string(section_1) || serialize_storage(value_1)``\n-  The ``serialize_storage`` serializes:\n-  object tag if object type does not have ``ARRAY_FLAG`` flag\n-  object itself recursively\n\n.. |Build Status| image:: https://travis-ci.org/ph4r05/monero-serialize.svg?branch=master\n   :target: https://travis-ci.org/ph4r05/monero-serialize",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ph4r05/monero-serialize",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "monero-serialize",
    "package_url": "https://pypi.org/project/monero-serialize/",
    "platform": null,
    "project_url": "https://pypi.org/project/monero-serialize/",
    "project_urls": {
      "Homepage": "https://github.com/ph4r05/monero-serialize"
    },
    "release_url": "https://pypi.org/project/monero-serialize/3.0.5/",
    "requires_dist": null,
    "requires_python": ">=3.5",
    "summary": "Monero serialization",
    "version": "3.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14189057,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9b4bbae3f1342777f1ee1ae5a9659f6a2ba75cea9aa8f7aa04ba086db83fe0bc",
        "md5": "97fff704895f0571b5bd34bbd023d0f1",
        "sha256": "d94f1657ef209481497ab077a03bcdf78f6e826bfb4ce4acd564b535caf9b8fb"
      },
      "downloads": -1,
      "filename": "monero-serialize-3.0.5.tar.gz",
      "has_sig": true,
      "md5_digest": "97fff704895f0571b5bd34bbd023d0f1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 145686,
      "upload_time": "2022-06-09T15:35:18",
      "upload_time_iso_8601": "2022-06-09T15:35:18.981344Z",
      "url": "https://files.pythonhosted.org/packages/9b/4b/bae3f1342777f1ee1ae5a9659f6a2ba75cea9aa8f7aa04ba086db83fe0bc/monero-serialize-3.0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}