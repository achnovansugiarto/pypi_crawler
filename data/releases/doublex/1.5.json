{
  "info": {
    "author": "David Villa Alises",
    "author_email": "David.Villa@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Topic :: Software Development",
      "Topic :: Software Development :: Quality Assurance",
      "Topic :: Software Development :: Testing"
    ],
    "description": "==============\npython-doublex\n==============\n\nA powerful test doubles framework for Python.\n\nThis started as a try to improve and simplify pyDoubles codebase and API\n\nSource repository is: https://bitbucket.org/DavidVilla/python-doublex\n\n\nDesign principles\n=================\n\n- doubles should not have public API framework methods. It avoid silent misspelling.\n- non-proxified doubles does not require collaborator instances, they may use classes\n- hamcrest.assert_that used for all assertions\n- mock invocation order is required by default\n- Compatible with old and new style classes\n\n\nDoubles\n=======\n\n\"free\" Stub\n-----------\n\nHint: *Stub objects tell you what you wanna hear.*\n\nA free Stub is an double object that have any method you invoke on it. Using the Stub\ncontext (``with`` keyword) you may program the double to return a specified value\ndepending on their method argument values::\n\n # given\n stub = Stub()\n with stub:\n     stub.foo('hi').returns(10)\n     stub.hello(ANY_ARG).returns(False)\n     stub.bye().raises(SomeException)\n\n # when\n result = stub.foo()\n\n # then\n assert_that(result, is_(10))\n\n\nIf you do not program specific result, the method invocation returns ``None``.\n\n\n\"checked\" Stub\n---------------\n\nA \"checked Stub\" forces the specified collaborator interface::\n\n class Collaborator:\n     def hello(self):\n         return \"hello\"\n\n with Stub(Collaborator) as stub\n     stub.hello().raises(SomeException)\n     stub.foo().returns(True)  # interface mismatch exception\n     stub.hello(1).returns(2)  # interface mismatch exception\n\nIf you invoke an nonexistent method you will get an ``AttributeError`` exception.\n\n\n\"free\" Spy\n----------\n\nHint: *Spies remember everything that happens to them.*\n\nThe free spy extends the *free Stub* functionality allowing you to assert on the\ninvocation it receives since its creation::\n\n\n # given\n with Spy() as sender:\n     sender.helo().returns(\"OK\")\n\n # when\n sender.send_mail('hi')\n sender.send_mail('foo@bar.net')\n\n # then\n assert_that(sender.helo(), is_(\"OK\"))\n assert_that(sender.send_mail, called())\n assert_that(sender.send_mail, called().times(2))\n assert_that(sender.send_mail, called().with_args('foo@bar.net'))\n\n\n\"checked\" Spy\n--------------\n\nAs the ``Stubs``, checked spies force you to use the specified collaborator interface::\n\n class Sender:\n     def say(self):\n         return \"hi\"\n\n     def send_mail(self, address, force=True):\n         [some amazing code]\n\n sender = Spy(Sender)\n\n sender.bar()        # interface mismatch exception\n sender.send_mail()  # interface mismatch exception\n sender.send_mail(wrong=1)         # interface mismatch exception\n sender.send_mail('foo', wrong=1)  # interface mismatch exception\n\n\nProxySpy\n--------\n\nHint: *Proxy spies forward invocations to its actual instance.*\n\nThe ``ProxySpy`` extends is a *verified* ``Spy`` that invoke on the actual\ninstance all invocations it receives::\n\n sender = ProxySpy(Sender())  # NOTE: It takes an instance (not class)\n\n sender.say('boo!')  # interface mismatch exception\n\n assert_that(sender.say(), is_(\"hi\"))\n assert_that(sender.say, called())\n\n\n\"free\" Mock\n-----------\n\nHint: *Mocks force the predefined script.*\n\nMock objects may be programmed with a sequence of method calls. Later, the double must\nreceive exactly the same sequence of invocations (including argument values). If the\nsequence does not match, an AssertionError is raised::\n\n with Mock() as smtp:\n     smtp.helo()\n     smtp.mail(ANY_ARG)\n     smtp.rcpt(\"bill@apple.com\")\n     smtp.data(ANY_ARG).returns(True).times(2)\n\n smtp.helo()\n smtp.mail(\"poormen@home.net\")\n smtp.rcpt(\"bill@apple.com\")\n smtp.data(\"somebody there?\")\n smtp.data(\"I am afraid..\")\n\n assert_that(smtp, verify())\n\n``verify()`` asserts invocation order. If your test does not require strict invocation\norder just use ``any_order_verify()`` matcher instead::\n\n with Mock() as mock:\n     mock.foo()\n     mock.bar()\n\n mock.bar()\n mock.foo()\n\n assert_that(mock, any_order_verify())\n\nProgrammed invocation sequence also may specify stubbed return values::\n\n with Mock() as mock:\n     mock.foo().returns(10)\n\n assert_that(mock.foo, is_(10))\n assert_that(mock, verify())\n\n\n\"checked\" Mock\n---------------\n\nThe checked variant also for mocks::\n\n class SMTP:\n     def helo(self):\n         [...]\n     def mail(self, address):\n         [...]\n     def rcpt(self, address):\n         [...]\n\n with Mock(STMP) as smtp:\n     smtp.wrong()  # interface mismatch exception\n     smtp.mail()   # interface mismatch exception\n\n\nstub methods\n------------\n\nYou may create standalone stub methods also::\n\n collaborator = Collaborator()\n collaborator.foo = method_returning(\"bye\")\n assertEquals(\"bye\", self.collaborator.foo())\n\n collaborator.foo = method_raising(SomeException)\n collaborator.foo()  # raises SomeException\n\n\nproperties\n----------\n\nDoublex support stub and spy properties in a pretty easy way compared with other\nframeworks like python-mock::\n\n class Collaborator(object):\n     @property\n     def prop(self):\n         return 1\n\n     @prop.setter\n     def prop(self, value):\n         pass\n\n with Spy(Collaborator) as spy:\n     spy.prop = 2  # stubbing its value\n\n assert_that(spy.prop, is_(2))  # property getter invoked\n assert_that(spy, property_got('prop'))\n\n spy.prop = 4  # property setter invoked\n spy.prop = 5  # --\n spy.prop = 5  # --\n\n assert_that(spy, property_set('prop'))  # set to any value\n assert_that(spy, property_set('prop').to(4))\n assert_that(spy, property_set('prop').to(5).times(2))\n assert_that(spy, never(property_set('prop').to(greater_than(6))))\n\n\nProperty doubles require:\n\n* Using \"checked\" doubles, ie: specify a collaborator in constructor.\n* collaborator must be a new-style classXS.\n\n\ndoublex matchers\n================\n\ncalled\n------\n\ncalled() matches any invocation to a method::\n\n spy.Spy()\n spy.m1()\n spy.m2(None)\n spy.m3(\"hi\", 3.0)\n spy.m4([1, 2])\n\n assert_that(spy.m1, called())\n assert_that(spy.m2, called())\n assert_that(spy.m3, called())\n assert_that(spy.m4, called())\n\n\nwith_args\n---------\n\nwith_args() matches explicit argument values and hamcrest matchers::\n\n spy.Spy()\n\n spy.m1()\n spy.m2(None)\n spy.m3(2)\n spy.m4(\"hi\", 3.0)\n spy.m5([1, 2])\n spy.m6(name=\"john doe\")\n\n assert_that(spy.m1, called())\n assert_that(spy.m2, called())\n\n assert_that(spy.m1, called().with_args())\n assert_that(spy.m2, called().with_args(None))\n assert_that(spy.m3, called().with_args(2))\n assert_that(spy.m4, called().with_args(\"hi\", 3.0))\n assert_that(spy.m5, called().with_args([1, 2]))\n assert_that(spy.m6, called().with_args(name=\"john doe\"))\n\n assert_that(spy.m3, called().with_args(less_than(3)))\n assert_that(spy.m3, called().with_args(greater_than(1)))\n assert_that(spy.m6, called().with_args(name=contains_string(\"doe\")))\n\n\nnever\n-----\n\n``never()`` is a convenient replacement for hamcrest.is_not::\n\n assert_that(spy.m5, hamcrest.is_not(called()))  # is_not() works\n assert_that(spy.m5, never(called()))            # but we recommend due to better error report messages\n\n\n\nANY_ARG\n=======\n\n``ANY_ARG`` is a special value that matches any subsequent argument values, including no\nargs. For example::\n\n spy.arg0()\n spy.arg1(1)\n spy.arg3(1, 2, 3)\n spy.arg_karg(1, key1='a')\n\n assert_that(spy.arg0, called().with_args(ANY_ARG))\n assert_that(spy.arg1, called().with_args(ANY_ARG))\n assert_that(spy.arg3, called().with_args(1, ANY_ARG))\n assert_that(spy.arg_karg, called().with_args(1, ANY_ARG))\n\nAlso for stubs::\n\n with Stub() as stub:\n     stub.foo(ANY_ARG).returns(True)\n     stub.bar(1, ANY_ARG).returns(True)\n\n assert_that(stub.foo(), is_(True))\n assert_that(stub.foo(1), is_(True))\n assert_that(stub.foo(key1='a'), is_(True))\n assert_that(stub.foo(1, 2, 3, key1='a', key2='b'), is_(True))\n\n assert_that(stub.foo(1, 2, 3), is_(True))\n assert_that(stub.foo(1, key1='a'), is_(True))\n\nBut, if you want match any single value, use hamcrest matcher ``anything()``::\n\n spy.foo(1, 2, 3)\n assert_that(spy.foo, called().with_args(1, hamcrest.anything(), 3))\n\n spy.bar(1, key=2)\n assert_that(spy.bar, called().with_args(1, key=hamcrest.anything()))\n\n\nmatchers, matchers, hamcrest matchers...\n========================================\n\ndoublex support all hamcrest matchers, and their amazing combinations.\n\nchecking spied calling args\n---------------------------\n\n::\n\n spy = Spy()\n spy.foo(\"abcd\")\n\n assert_that(spy.foo, called().with_args(has_length(4)))\n assert_that(spy.foo, called().with_args(has_length(greater_than(3))))\n assert_that(spy.foo, called().with_args(has_length(less_than(5))))\n assert_that(spy.foo, never(called().with_args(has_length(greater_than(5)))))\n\n``has_length``, ``less_than`` and ``greater_than`` are hamcrest matchers.\n\n\nstubbing\n--------\n\n::\n\n with Spy() as spy:\n     spy.foo(has_length(less_than(4))).returns('<4')\n     spy.foo(has_length(4)).returns('four')\n     spy.foo(has_length(\n\t\tall_of(greater_than(4),\n                       less_than(8)))).returns('4<x<8')\n     spy.foo(has_length(greater_than(8))).returns('>8')\n\n assert_that(spy.foo((1, 2)), is_('<4'))\n assert_that(spy.foo('abcd'), is_('four'))\n assert_that(spy.foo('abcde'), is_('4<x<8'))\n assert_that(spy.foo([0] * 9), is_('>8'))\n\n\n``all_of``, ``has_length``, ``less_than`` and ``greater_than`` are hamcrest matchers.\n\nchecking invocation 'times'\n---------------------------\n\n::\n\n spy.foo()\n spy.foo(1)\n spy.foo(1)\n spy.foo(2)\n\n assert_that(spy.never, never(called()))                      # = 0 times\n assert_that(spy.foo, called())                               # > 0\n assert_that(spy.foo, called().times(greater_than(0)))        # > 0 (same)\n assert_that(spy.foo, called().times(4))                      # = 4\n assert_that(spy.foo, called().times(greater_than(2)))        # > 2\n assert_that(spy.foo, called().times(less_than(6)))           # < 6\n\n assert_that(spy.foo, never(called().with_args(5)))                  # = 0 times\n assert_that(spy.foo, called().with_args().times(1))                 # = 1\n assert_that(spy.foo, called().with_args(anything()))                # > 0\n assert_that(spy.foo, called().with_args(anything()).times(4))       # = 4\n assert_that(spy.foo, called().with_args(1).times(2))                # = 2\n assert_that(spy.foo, called().with_args(1).times(greater_than(1)))  # > 1\n assert_that(spy.foo, called().with_args(1).times(less_than(5)))     # < 5\n assert_that(spy.foo, called().with_args(1).times(\n             all_of(greater_than(1), less_than(8))))                 # 1 < times < 8\n\n``anything``, ``all_of``, ``less_than`` and ``greater_than`` are hamcrest matchers.\n\n\nStub observers\n==============\n\nStub observers allow you to execute extra code (similar to python-mock \"side effects\")::\n\n class Observer(object):\n     def __init__(self):\n         self.state = None\n\n     def update(self, *args, **kargs):\n         self.state = args[0]\n\n observer = Observer()\n stub = Stub()\n stub.foo.attach(observer.update)\n stub.foo(2)\n\n assert_that(observer.state, is_(2))\n\n\nStub delegates\n==============\n\nThe value returned by the stub may be delegated from a function, method or other\ncallable...::\n\n def get_user():\n     return \"Freddy\"\n\n with Stub() as stub:\n     stub.user().delegates(get_user)\n     stub.foo().delegates(lambda: \"hello\")\n\n assert_that(stub.user(), is_(\"Freddy\"))\n assert_that(stub.foo(), is_(\"hello\"))\n\nIt may be delegated from iterables or generators too!::\n\n with Stub() as stub:\n     stub.foo().delegates([1, 2, 3])\n\n assert_that(stub.foo(), is_(1))\n assert_that(stub.foo(), is_(2))\n assert_that(stub.foo(), is_(3))\n\n\nMimic doubles\n=============\n\nUsually double instances behave as collaborator surrogates, but they do not expose the\nsame class hierarchy, and usually this is pretty enough when the code uses \"duck typing\"::\n\n class A(object):\n     pass\n\n class B(A):\n     pass\n\n >>> spy = Spy(B())\n >>> isinstance(spy, Spy)\n True\n >>> isinstance(spy, B)\n False\n\n\nBut some third party library DOES strict type checking using isinstance() invalidating our\ndoubles. For these cases you can use Mimic's. Mimic class can decorate any double class to\nachieve full replacement instances (Liskov principle)::\n\n >>> spy = Mimic(Spy, B)\n >>> isinstance(spy, B)\n True\n >>> isinstance(spy, A)\n True\n >>> isinstance(spy, Spy)\n True\n >>> isinstance(spy, Stub)\n True\n >>> isinstance(spy, object)\n True\n\n\n.. Local Variables:\n..  coding: utf-8\n..  mode: flyspell\n..  ispell-local-dictionary: \"american\"\n.. End:\n\n.. LocalWords:  hamcrest",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://bitbucket.org/DavidVilla/python-doublex",
    "keywords": null,
    "license": "GPLv3",
    "maintainer": null,
    "maintainer_email": null,
    "name": "doublex",
    "package_url": "https://pypi.org/project/doublex/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/doublex/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://bitbucket.org/DavidVilla/python-doublex"
    },
    "release_url": "https://pypi.org/project/doublex/1.5/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Test doubles framework for Python",
    "version": "1.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16854451,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6633ba423fa98c5a245a6b9aac7941ae74ae15abdb0ddb98b9c40b7a226ea4fd",
        "md5": "a86343ff165afd754887a714528a4cd3",
        "sha256": "9ca38000c32995f81ee14a664f08473f0241cda28d2b01f2d62f696258b73646"
      },
      "downloads": -1,
      "filename": "doublex-1.5.tar.gz",
      "has_sig": false,
      "md5_digest": "a86343ff165afd754887a714528a4cd3",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 14982,
      "upload_time": "2012-10-08T19:08:42",
      "upload_time_iso_8601": "2012-10-08T19:08:42.119041Z",
      "url": "https://files.pythonhosted.org/packages/66/33/ba423fa98c5a245a6b9aac7941ae74ae15abdb0ddb98b9c40b7a226ea4fd/doublex-1.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}