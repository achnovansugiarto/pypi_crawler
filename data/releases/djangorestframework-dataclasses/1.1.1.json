{
  "info": {
    "author": "Oxan van Leeuwen",
    "author_email": "oxan@oxanvanleeuwen.nl",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 2.0",
      "Framework :: Django :: 2.1",
      "Framework :: Django :: 2.2",
      "Framework :: Django :: 3.0",
      "Framework :: Django :: 3.1",
      "Framework :: Django :: 3.2",
      "Framework :: Django :: 4.0",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Internet :: WWW/HTTP",
      "Topic :: Software Development :: Libraries :: Application Frameworks",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Typing :: Typed"
    ],
    "description": "Dataclasses serializer\n======================\n\nA `dataclasses <https://docs.python.org/3/library/dataclasses.html>`__ serializer for the `Django REST Framework\n<http://www.django-rest-framework.org/>`__.\n\n.. image:: https://github.com/oxan/djangorestframework-dataclasses/workflows/CI/badge.svg\n   :target: https://github.com/oxan/djangorestframework-dataclasses/actions?query=workflow%3ACI\n.. image:: https://codecov.io/gh/oxan/djangorestframework-dataclasses/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/oxan/djangorestframework-dataclasses\n.. image:: https://badge.fury.io/py/djangorestframework-dataclasses.svg\n   :target: https://badge.fury.io/py/djangorestframework-dataclasses\n.. image:: https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=success\n   :target: https://github.com/sponsors/oxan\n\n|\n\n.. contents:: :local:\n\nRequirements\n------------\n\n* Python (3.7+)\n* Django (2.0+)\n* Django REST Framework (3.9+)\n\nThese are the supported Python and package versions. Older versions will probably work as well, but haven't been tested\nby the author.\n\nInstallation\n------------\n\n::\n\n    $ pip install djangorestframework-dataclasses\n\nThis package follows `semantic versioning`_. See `CHANGELOG`_ for breaking changes and new features, and `LICENSE`_ for\nthe complete license (BSD-3-clause).\n\n.. _`semantic versioning`: https://semver.org/\n.. _`CHANGELOG`: https://github.com/oxan/djangorestframework-dataclasses/blob/master/CHANGELOG.rst\n.. _`LICENSE`: https://github.com/oxan/djangorestframework-dataclasses/blob/master/LICENSE\n\nBasic usage\n-----------\n\nThe package provides the ``DataclassSerializer`` serializer, defined in the ``rest_framework_dataclasses.serializers``\nnamespace.\n\n.. code:: Python\n\n    from rest_framework_dataclasses.serializers import DataclassSerializer\n\nThis serializer provides a shortcut that lets you automatically create a ``Serializer`` class with fields that\ncorrespond to the fields on a dataclass. In usage, the ``DataclassSerializer`` is the same as a regular ``Serializer``\nclass, except that:\n\n* It will automatically generate fields for you, based on the declaration in the dataclass.\n* To make this possible it requires that a ``dataclass`` property is specified in the ``Meta`` subclass, with as value\n  a dataclass that has type annotations.\n* It includes default implementations of ``.create()`` and ``.update()``.\n\nFor example, define a dataclass as follows:\n\n.. code:: Python\n\n    @dataclass\n    class Person:\n        name: str\n        email: str\n        alive: bool\n        gender: typing.Literal['male', 'female']\n        birth_date: typing.Optional[datetime.date]\n        phone: typing.List[str]\n        movie_ratings: typing.Dict[str, int]\n\nThe serializer for this dataclass can now trivially be defined without having to duplicate all fields:\n\n.. code:: Python\n\n    class PersonSerializer(DataclassSerializer):\n        class Meta:\n            dataclass = Person\n\n    # is equivalent to\n    class PersonSerializer(Serializer):\n        name = fields.CharField()\n        email = fields.CharField()\n        alive = fields.BooleanField()\n        gender = fields.ChoiceField(choices=['male', 'female'])\n        birth_date = fields.DateField(allow_null=True)\n        phone = fields.ListField(child=fields.CharField())\n        movie_ratings = fields.DictField(child=fields.IntegerField())\n\nYou can add extra fields or override default fields by declaring them explicitly on the class, just as you would for a\nregular ``Serializer`` class. This allows to specify extra field options or change a field type.\n\n.. code:: Python\n\n    class PersonSerializer(Serializer):\n        email = fields.EmailField()\n\n        class Meta:\n            dataclass = Person\n\nDataclass serializers behave in the same way and can be used in the same places as the built-in serializers from Django\nREST Framework: you can retrieve the serialized representation using the ``.data`` property, and the deserialized\ndataclass instance using the ``.validated_data`` property. Furthermore, the ``save()`` method is implemented to create\nor update an existing dataclass instance. You can find more information on serializer usage in the\n`Django REST Framework <https://www.django-rest-framework.org/api-guide/serializers/>`__ documentation.\n\nNote that this usage pattern is very similar to that of the built-in ``ModelSerializer``. This is intentional, with the\nwhole API modelled after that of ``ModelSerializer``. Most features and behaviour known from ``ModelSerializer`` applies\nto dataclass serializers as well.\n\nCustomize field generation\n--------------------------\n\nThe auto-generated serializer fields are configured based on type qualifiers in the dataclass (these can be mixed):\n\n* Fields with a default value (factory) are marked as optional on the serializer (``required=False``). This means that\n  these fields don't need to be supplied during deserialization.\n\n* Fields marked as nullable through ``typing.Optional``, ``typing.Union[X, None]`` or ``X | None`` (`PEP 604`_) are\n  marked as nullable on the serializer (``allow_null=True``). This means that ``None`` is accepted as a valid value\n  during deserialization.\n\n* Fields marked as final through ``typing.Final`` (as in `PEP 591`_) are marked as read-only on the serializer\n  (``read_only=True``).\n\n.. code:: Python\n\n    @dataclass\n    class Person:\n        birth_date: typing.Optional[datetime.date]\n        alive: bool = True\n        species: typing.Final[str] = 'Human'\n\n    # the autogenerated serializer will be equal to\n    class PersonSerializer(Serializer):\n        birth_date = fields.DateField(allow_null=True)\n        alive = fields.BooleanField(required=False)\n        species = fields.CharField(read_only=True)\n\nBesides overriding fields by declaring them explicitly on the serializer, you can also change or override the generated\nserializer field using metadata on the dataclass field. Currently, two keys are recognized in this dictionary:\n\n* ``serializer_field`` can be used to replace the auto-generated field with a user-supplied one. Should contain an\n  instance of a field, not a field type.\n\n* ``serializer_kwargs`` can be used to specify arbitrary additional keyword arguments for the generated field. Manually\n  specified arguments will have precedence over generated arguments (so e.g. by supplying ``{required: True}``, a field\n  with a default value can be made required).\n\n.. code:: Python\n\n    @dataclasses.dataclass\n    class Person:\n        email: str = dataclasses.field(metadata={'serializer_field': fields.EmailField()})\n        age: int = dataclasses.field(metadata={'serializer_kwargs': {'min_value': 0}})\n\n    # the autogenerated serializer will be equal to\n    class PersonSerializer(Serializer):\n        email = fields.EmailField()\n        age = fields.IntegerField(min_value=0)\n\nTo further customize the serializer, the ``DataclassSerializer`` accepts the following options in the ``Meta``\nsubclass. All options have the same behaviour as the identical options in ``ModelSerializer``.\n\n* ``dataclass`` specifies the type of dataclass used by the serializer. This is equivalent to the ``model`` option in\n  ``ModelSerializer``.\n\n* ``fields`` and ``exclude`` can be used to specify which fields should respectively be included and excluded in the\n  serializer. These cannot both be specified.\n\n  The ``fields`` option accepts the magic value ``__all__`` to specify that all fields on the dataclass should be used.\n  This is also the default value, so it is not mandatory to specify either ``fields`` or ``exclude``.\n\n* ``read_only_fields`` can be used to mark a subset of fields as read-only.\n\n* ``extra_kwargs`` can be used to specify arbitrary additional keyword arguments on fields. This can be useful to\n  extend or change the autogenerated field without explicitly declaring the field on the serializer. This option should\n  be a dictionary, mapping field names to a dictionary of keyword arguments.\n\n  If the autogenerated field is a composite field (a list or dictionary), the arguments are applied to the composite\n  field. To add keyword arguments to the composite field's child field (that is, the field used for the items in the\n  list or dictionary), they should be specified as a nested dictionary under the ``child_kwargs`` name (see\n  `Nested dataclasses`_ section below for an example).\n\n  .. code:: Python\n\n    class PersonSerializer(DataclassSerializer):\n        class Meta:\n            extra_kwargs = {\n                'height': { 'decimal_places': 1 },\n                'movie_ratings': { 'child_kwargs': { 'min_value': 0, 'max_value': 10 } }\n            }\n\n* ``validators`` functionality is unchanged.\n\n* ``depth`` (as known from ``ModelSerializer``) is not supported, it will always nest infinitely deep.\n\nNesting\n-------\n\nNested dataclasses\n~~~~~~~~~~~~~~~~~~\n\nIf your dataclass has a field that also contains a dataclass instance, the ``DataclassSerializer`` will automatically\ncreate another ``DataclassSerializer`` for that field, so that its value will be nested. This also works for dataclasses\ncontained in lists or dictionaries, or even several layers deep.\n\n.. code:: Python\n\n    @dataclass\n    class House:\n        address: str\n        owner: Person\n        residents: typing.List[Person]\n\n    class HouseSerializer(DataclassSerializer):\n        class Meta:\n            dataclass = House\n\nThis will serialize as:\n\n.. code:: Python\n\n    >>> serializer = HouseSerializer(instance=house)\n    >>> serializer.data\n    {\n        'address': 'Main Street 5',\n        'owner': { 'name': 'Alice' }\n        'residents': [\n            { 'name': 'Alice', 'email': 'alice@example.org', ... },\n            { 'name': 'Bob', 'email': 'bob@example.org', ... },\n            { 'name': 'Charles', 'email': 'charles@example.org', ... }\n        ]\n    }\n\nThis does not give the ability to customize the field generation of the nested dataclasses. If that is needed, you\nshould declare the serializer to be used for the nested field explicitly. Alternatively, you could use the\n``extra_kwargs`` option to provide arguments to fields belonging to the nested dataclasses. Consider the following:\n\n.. code:: Python\n\n    @dataclass\n    class Transaction:\n       amount: Decimal\n       account_number: str\n\n    @dataclass\n    class Company:\n       sales: List[Transaction]\n\nIn order to tell DRF to give 2 decimal places to the transaction account number, write the serializer as follows:\n\n.. code:: Python\n\n    class CompanySerializer(DataclassSerializer):\n        class Meta:\n            dataclass = Company\n\n            extra_kwargs = {\n                'sales': {\n                    # Arguments here are for the ListField generated for the sales field on Company\n                    'min_length': 1,   # requires at least 1 item to be present in the sales list\n                    'child_kwargs': {\n                        # Arguments here are passed to the DataclassSerializer for the Transaction dataclass\n                        'extra_kwargs': {\n                            # Arguments here are the extra arguments for the fields in the Transaction dataclass\n                            'amount': {\n                                'max_digits': 6,\n                                'decimal_places': 2\n                            }\n                        }\n                    }\n                }\n            }\n\nNesting models\n~~~~~~~~~~~~~~\n\nLikewise, if your dataclass has a field that contains a Django model, the ``DataclassSerializer`` will automatically\ngenerate a relational field for you.\n\n.. code:: Python\n\n    class Company(models.Model):\n        name = models.CharField()\n\n    @dataclass\n    class Person:\n        name: str\n        employer: Company\n\nThis will serialize as:\n\n.. code:: Python\n\n    >>> serializer = PersonSerializer(instance=user)\n    >>> print(repr(serializer))\n    PersonSerializer():\n        name = fields.CharField()\n        employer = fields.PrimaryKeyRelatedField(queryset=Company.objects.all())\n    >>> serializer.data\n    {\n        \"name\": \"Alice\",\n        \"employer\": 1\n    }\n\nIf you want to nest the model in the serialized representation, you should specify the model serializer to be used by\ndeclaring the field explicitly.\n\nIf you prefer to use hyperlinks to represent relationships rather than primary keys, in the same package you can find\nthe ``HyperlinkedDataclassSerializer`` class: it generates a ``HyperlinkedRelatedField`` instead of a\n``PrimaryKeyRelatedField``.\n\nNew serializer field types\n--------------------------\nTo handle some types for which DRF does not ship a serializer field, some new serializer field types are shipped in the\n``rest_framework_dataclasses.fields`` namespace. These fields can be used independently of the ``DataclassSerializer``\nas well.\n\nDefaultDecimalField\n~~~~~~~~~~~~~~~~~~~\nA subclass of `DecimalField`_ that defaults ``max_digits`` to ``None`` and ``decimal_places`` to 2. Used to represent\ndecimal values which there is no explicit field configured.\n\nEnumField\n~~~~~~~~~\nA subclass of `ChoiceField`_ to represent Python `enumerations`_. The enumeration members can be represented by either\ntheir name or value. The member name is used as display name.\n\n**Signature**: ``EnumField(enum_class, by_name=False)``\n\n* ``enum_class``: The enumeration class.\n* ``by_name``: Whether members are represented by their value (``False``) or name (``True``).\n\n.. _`enumerations`: https://docs.python.org/3/library/enum.html\n.. _`ChoiceField`: https://www.django-rest-framework.org/api-guide/fields/#choicefield\n.. _`DecimalField`: https://www.django-rest-framework.org/api-guide/fields/#decimalfield\n\nAdvanced usage\n--------------\n\n* The output of methods or properties on the dataclass can be included as a (read-only) field in the serialized state\n  by adding their name to the ``fields`` option in the ``Meta`` class.\n\n* If you don't need to customize the generated fields, ``DataclassSerializer`` can also be used directly without\n  creating a subclass. In that case, the dataclass should be specified using the ``dataclass`` constructor parameter:\n\n  .. code:: Python\n\n    serializer = DataclassSerializer(data=request.data, dataclass=Person)\n\n* Partial updates are supported by setting the ``partial`` argument to ``True``. Nested dataclasses will also be\n  partially updated, but nested fields and dictionaries will be replaced in full with the supplied value:\n\n  .. code:: Python\n\n    @dataclass\n    class Company:\n        name: str\n        location: Optional[str] = None\n\n    @dataclass\n    class Person:\n        name: str\n        current_employer: Company\n        past_employers: List[Company]\n\n    alice = Person(name='Alice',\n                   current_employer=Company('Acme Corp.', 'New York City'),\n                   past_employers=[Company('PSF', 'Delaware'), Company('Ministry of Silly Walks', 'London')])\n\n    data = {'current_employer': {'location': 'Los Angeles'}, 'past_employers': [{'name': 'OsCorp', 'location': 'NYC'}]}\n\n    >>> serializer = PersonSerializer(partial=True, instance=alice, data=data)\n    >>> print(serializer.save())\n    Person(name='Alice',\n           current_employer=Company('Acme Corp.', 'Los Angeles'),\n           past_employers=[Company(name='OsCorp', location='NYC')])\n\n* If you override the ``create()`` or ``update()`` methods, the dataclass instance passed in the ``validated_data``\n  argument will have the special ``rest_framework.fields.empty`` value for any fields for which no data was provided.\n  This is required to distinguish between not-provided fields and fields with the default value, as needed for (both\n  regular and partial) updates. You can get rid of these ``empty`` markers and replace them with the default value by\n  calling the parent ``update()`` or ``create()`` methods - this is the only thing they do.\n\n  .. code:: Python\n\n    class CompanySerializer(DataclassSerializer):\n        def create(self, validated_data):\n            instance = super(CompanySerializer, self).create(validated_data)\n            # if no value is provided for location, these will both hold\n            assert validated_data.location == rest_framework.fields.empty\n            assert instance.location is None  # None is the default value of Company.location (see previous example)\n\n  The ``validated_data`` property on the serializer has these ``empty`` markers stripped as well, and replaced with the\n  default values for not-provided fields. Note that this means you cannot access ``validated_data`` on the serializer\n  for partial updates where no data has been provided for fields without a default value, an Exception will be thrown.\n\nField mappings\n--------------\n\nSo far, field generation is supported for the following types and their subclasses:\n\n* ``str``, ``bool``, ``int`` and ``float``.\n* ``date``, ``datetime``, ``time`` and ``timedelta`` from the ``datetime`` package.\n* ``decimal.Decimal`` (``max_digits`` and ``decimal_places`` default to ``None`` and ``2`` respectively).\n* ``uuid.UUID``\n* ``enum.Enum`` (mapped to a ``EnumField``)\n* ``typing.Iterable`` (including ``typing.List`` and `PEP 585`_-style generics such as ``list[int]``).\n* ``typing.Mapping`` (including ``typing.Dict`` and `PEP 585`_-style generics such as ``dict[str, int]``).\n* ``typing.Literal`` (mapped to a ``ChoiceField``).\n* ``django.db.Model``\n\nThe serializer also supports type variables that have an upper bound or are constrained. Type unions are not supported\nyet.\n\nFor advanced users, the ``DataclassSerializer`` also exposes an API that you can override in order to alter how\nserializer fields are generated:\n\n* The ``serializer_field_mapping`` property contains a dictionary that maps types to REST framework serializer classes.\n  You can override or extend this mapping to change the serializer field classes that are used for fields based on\n  their type. This dictionary also accepts dataclasses as keys to change the serializer used for nested dataclass.\n\n* The ``serializer_related_field`` property is the serializer field class that is used for relations to models.\n\n* The ``serializer_dataclass_field`` property is the serializer field class that is used for nested dataclasses. If you\n  subclass ``DataclassSerializer`` to customize behaviour, you probably want to change this property to use the subclass\n  as well. Note that since Python process the class body before it defines the class, this property is implemented using\n  the `property decorator`_ to allow it to reference the containing class.\n\n* The ``build_unknown_field()`` method is called to create serializer fields for dataclass fields that are not\n  understood. By default this just throws an error, but you can extend this with custom logic to create serializer\n  fields.\n\n* The ``build_property_field()`` method is called to create serializer fields for methods. By default this creates a\n  read-only field with the method return value.\n\n* The ``build_standard_field()``, ``build_relational_field()``, ``build_dataclass_field()``, ``build_enum_field()``,\n  ``build_literal_field()`` and ``build_composite_field()`` methods are used to process respectively fields, nested\n  models, nested dataclasses, enums, literals, and lists or dictionaries. These can be overridden to change the field\n  generation logic.\n\n.. _`PEP 591`: https://www.python.org/dev/peps/pep-0591/\n.. _`PEP 585`: https://www.python.org/dev/peps/pep-0585/\n.. _`PEP 604`: https://www.python.org/dev/peps/pep-0604/\n.. _`property decorator`: https://docs.python.org/3/library/functions.html#property\n\nSchemas\n-------\n\nStarting from version 0.22.0, `drf-spectacular`_ natively supports ``DataclassSerializer``. For previous versions, you\ncan include the `extension`_ in your project manually. You don't need to configure it, but you do need to import the\nmodule that contains the extension.\n\n.. _`drf-spectacular`: https://github.com/tfranzel/drf-spectacular\n.. _`extension`: https://github.com/tfranzel/drf-spectacular/blob/master/drf_spectacular/contrib/rest_framework_dataclasses.py\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/oxan/djangorestframework-dataclasses",
    "keywords": "",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "djangorestframework-dataclasses",
    "package_url": "https://pypi.org/project/djangorestframework-dataclasses/",
    "platform": "",
    "project_url": "https://pypi.org/project/djangorestframework-dataclasses/",
    "project_urls": {
      "Homepage": "https://github.com/oxan/djangorestframework-dataclasses"
    },
    "release_url": "https://pypi.org/project/djangorestframework-dataclasses/1.1.1/",
    "requires_dist": [
      "django (>=2.0)",
      "djangorestframework (>=3.9)",
      "typing-extensions (>=3.7.4) ; python_version < \"3.8\""
    ],
    "requires_python": ">=3.7",
    "summary": "A dataclasses serializer for Django REST Framework",
    "version": "1.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15819075,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "52ef2af86edb2a6e2e91ee7351e75ae16f5ff5095f7a1ed89f32e72d11c46562",
        "md5": "2057f6225e116ab30116d2bfa83f019f",
        "sha256": "aa4b23ac3de4ce25e82dd24110ddb9ff6551e2032ed7f25e8687eca6b4d7a472"
      },
      "downloads": -1,
      "filename": "djangorestframework_dataclasses-1.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2057f6225e116ab30116d2bfa83f019f",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 21657,
      "upload_time": "2022-01-25T17:06:48",
      "upload_time_iso_8601": "2022-01-25T17:06:48.409499Z",
      "url": "https://files.pythonhosted.org/packages/52/ef/2af86edb2a6e2e91ee7351e75ae16f5ff5095f7a1ed89f32e72d11c46562/djangorestframework_dataclasses-1.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7702a9db50867187c5575bd3afd4e6bea81c7b875aa453ad45cc67a64376d38f",
        "md5": "1ff983c2ab1817288feebf3e8f090bb3",
        "sha256": "11bed97049e433cdf00ebf963dac7b7f087aa5bedf92e04b48fe6b01467b0cf2"
      },
      "downloads": -1,
      "filename": "djangorestframework-dataclasses-1.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "1ff983c2ab1817288feebf3e8f090bb3",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 29217,
      "upload_time": "2022-01-25T17:06:50",
      "upload_time_iso_8601": "2022-01-25T17:06:50.223674Z",
      "url": "https://files.pythonhosted.org/packages/77/02/a9db50867187c5575bd3afd4e6bea81c7b875aa453ad45cc67a64376d38f/djangorestframework-dataclasses-1.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}