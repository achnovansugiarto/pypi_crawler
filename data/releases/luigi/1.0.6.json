{
  "info": {
    "author": "Erik Bernhardsson",
    "author_email": "erikbern@spotify.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "NOTE: For the latest code and documentation, please go to https://github.com/spotify/luigi\n\n \nLuigi is a Python package that helps you build complex pipelines of batch jobs. It handles dependency resolution, \nworkflow management, visualization, handling failures, command line integration, and much more. \n \nThe purpose of Luigi is to address all the plumbing typically associated with long-running batch processes. You want to \nchain many tasks, automate them, and failures *will* happen. These tasks can be anything, but typically long running \nthings like [Hadoop](http://hadoop.apache.org/) jobs, dumping data to/from databases, running machine learning \nalgorithms, or anything else.  \n \nThere are other software packages that focus on lower level aspects of data processing, like \n[Hive](http://hive.apache.org/), [Pig](http://pig.apache.org/), [Cascading](http://www.cascading.org/). Luigi is not a \nframework to replace these. Instead it helps you stitch many tasks together, where each task can be a Hive query, a \nHadoop job in Java, a Python snippet, dumping a table from a database, or anything else. It's easy to build up long-\nrunning pipelines that can comprise thousands of tasks and take days or weeks to complete. Luigi takes care of a lot of \nthe workflow management so that you can focus on the tasks themselves and their dependencies.  \n \nYou can build pretty much any task you want, but Luigi also comes with a *toolbox* of several common task templates that\n you use. It includes native Python support for running mapreduce jobs in Hadoop, as well as Pig and Jar jobs. It also \ncomes with file system abstractions for HDFS and local files that also ensures all file system operations are atomic. \nThis is important because it means your data pipeline will not crash in a state containing partial data. \n \nLuigi was built at [Spotify](http://www.spotify.com/), mainly by [Erik Bernhardsson](https://github.com/erikbern) and \n[Elias Freider](https://github.com/freider), but many other people have contributed. \n \n## Dependency graph example \n \nJust to give you an idea of what Luigi does, this is a screen shot from something we are running in production. Using \nLuigi's visualizer, we get a nice visual overview of the dependency graph of the workflow. Each node represents a task \nwhich has to be run. Green tasks are already completed whereas yellow tasks are yet to be run. Most of these tasks are \nHadoop job, but there's also some things that run locally and build up data files. \n \n \n## Background \n \nWe use Luigi internally at [Spotify](http://www.spotify.com/) to run 1000s of tasks every day, organized in complex \ndependency graphs. Most of these tasks are Hadoop job. Luigi provides an infrastructure that powers all kinds of stuff \nincluding recommendations, toplists, A/B test analysis, external reports, internal dashboards, etc. Luigi grew out of \nthe realization that powerful abstractions for the batch processing can help programmers focus on the most important \nbits and leave the rest (the boilerplate) to the framework. \n \nConceptually, Luigi similar to [GNU Make](http://www.gnu.org/software/make/) where you have certain tasks and these \ntasks in turn may have dependencies on other tasks. There are also some similarities to \n[Oozie](http://incubator.apache.org/oozie/) and [Azkaban](http://data.linkedin.com/opensource/azkaban). One major \ndifference is that Luigi is not just built specifically for Hadoop, and it's easy to extend it with other kinds of \ntasks. \n \nEverything in Luigi is in Python. Instead of XML configuration or similar external data files, the dependency graph is \nspecified *within Python*. This makes it easy to build up complex dependency graphs of tasks, where the dependencies can\n involve date algebra or recursive references to other versions of the same task. However, the workflow can trigger \nthings not in Python, such as running Pig scripts or scp'ing files. \n \n## Installing \n \nDownloading and running *python setup.py install* should be enough. Note that you probably want \n[Tornado](http://www.tornadoweb.org/). Also [Mechanize](http://wwwsearch.sourceforge.net/mechanize/) is optional if you \nwant to run Hadoop jobs since it makes debugging easier. See [Configuration](#configuration) for how to configure Luigi.\n \n \n## Example workflow – top artists \n \nThis is a very simplified case of something we do at Spotify a lot. All user actions are logged to HDFS where we run a \nbunch of Hadoop jobs to transform the data. At some point we might end up with a smaller data set that we can bulk \ningest into Cassandra, Postgres, or some other format. \n \nFor the purpose of this excercise, we want to aggregate all streams, and find the top 10 artists. We will then put it \ninto Postgres. \n \nThis example is also available in *examples/top_artists.py* \n \n### Step 1 - Aggregate artist streams \n \nclass AggregateArtists(luigi.Task): \n    date_interval = luigi.DateIntervalParameter() \n \n    def output(self): \n        return luigi.LocalTarget(\"data/artist_streams_%s.tsv\" % self.date_interval) \n \n    def requires(self): \n        return [Streams(date) for date in self.date_interval] \n \n    def run(self): \n        artist_count = defaultdict(int) \n \n        for input in self.input(): \n            with input.open('r') as in_file: \n                for line in in_file: \n                    timestamp, artist, track = line.strip().split() \n                    artist_count[artist] += 1 \n \n        with self.output().open('w') as out_file: \n            for artist, count in artist_count.iteritems(): \n                print >> out_file, artist, count \n \nThere are several pieces of this snippet that deserve more explanation. \n \n* Any *Task* may be customized by instantiating one or more *Parameter* objects on the class level. \n* The *output* method tells Luigi where the result of running the task will end up. The path can be some function of the\n parameters. \n* The *requires* tasks specifies other tasks that we need to perform this task. In this case it's an external dump named\n *Streams* which takes the date as the argument. \n* For plain Tasks, the *run* method implements the task. This could be anything, including calling subprocesses, \nperforming long running number crunching, etc. For some subclasses of *Task* you don't have to implement the *run* \nmethod. For instance, for the *HadoopJobTask* subclass you implement a *mapper* and *reducer* instead. \n* *HdfsTarget* is a built in class that makes it easy to read/write from/to HDFS. It also makes all file operations \natomic, which is nice in case your script crashes for any reason. \n \n### Running this locally \n \nTry running this using eg. \n \n    $ python examples/top_artists.py AggregateArtists --local-scheduler --date-interval 2012-06 \n \nYou can also try to view the manual using --help which will give you an overview of the options: \n \n    usage: wordcount.py [-h] [--local-scheduler] [--scheduler-host SCHEDULER_HOST] \n                        [--lock] [--lock-pid-dir LOCK_PID_DIR] [--workers WORKERS] \n                        [--date-interval DATE_INTERVAL] \n \n    optional arguments: \n      -h, --help            show this help message and exit \n      --local-scheduler     Use local scheduling \n      --scheduler-host SCHEDULER_HOST \n                            Hostname of machine running remote scheduler [default: \n                            localhost] \n      --lock                Do not run if the task is already running \n      --lock-pid-dir LOCK_PID_DIR \n                            Directory to store the pid file [default: \n                            /var/tmp/luigi] \n      --workers WORKERS     Maximum number of parallel tasks to run [default: 1] \n      --date-interval DATE_INTERVAL \n                            AggregateArtists.date_interval \n \nRunning the command again will do nothing because the output file is already created. In that sense, any task in Luigi \nis *idempotent* because running it many times gives the same outcome as running it once. Note that unlike Makefile, the \noutput will not be recreated when any of the input files is modified. You need to delete the output file manually. \n \nThe *--local-scheduler* flag tells Luigi not to connect to a scheduler server. This is not recommended for other purpose\n than just testing things. \n \n### Step 1b - running this in Hadoop \n \nLuigi comes with native Python Hadoop mapreduce support built in, and here is how this could look like, instead of the \nclass above. \n \nclass AggregateArtistsHadoop(luigi.hadoop.JobTask): \n    date_interval = luigi.DateIntervalParameter() \n \n    def output(self): \n        return luigi.HdfsTarget(\"data/artist_streams_%s.tsv\" % self.date_interval) \n \n    def requires(self): \n        return [StreamsHdfs(date) for date in self.date_interval] \n \n    def mapper(self, line): \n        timestamp, artist, track = line.strip().split() \n        yield artist, 1 \n         \n    def reducer(self, key, values): \n        yield key, sum(values) \n \nNote that `luigi.hadoop.JobTask` doesn't require you to implement a `run` method. Instead, you typically implement a \n`mapper` and `reducer` method. \n \n### Step 2 – Find the top artists \n \nAt this point, we've counted the number of streams for each artists, for the full time period. We are left with a large \nfile that contains mappings of artist -> count data, and we want to find the top 10 artists. Since we only have a few \nhundred thousand artists, and calculating artists is nontrivial to parallelize, we choose to do this not as a Hadoop \njob, but just as a plain old for-loop in Python. \n \nclass Top10Artists(luigi.Task): \n    date_interval = luigi.DateIntervalParameter() \n    use_hadoop = luigi.BooleanParameter() \n \n    def requires(self): \n        if self.use_hadoop: \n            return AggregateArtistsHadoop(self.date_interval) \n        else: \n            return AggregateArtists(self.date_interval) \n \n    def output(self): \n        return luigi.LocalTarget(\"data/top_artists_%s.tsv\" % self.date_interval) \n \n    def run(self): \n        top_10 = nlargest(10, self._input_iterator()) \n        with self.output().open('w') as out_file: \n            for streams, artist in top_10: \n                print >> out_file, self.date_interval.date_a, self.date_interval.date_b, artist, streams \n \n    def _input_iterator(self): \n        with self.input().open('r') as in_file: \n            for line in in_file: \n                artist, streams = line.strip().split() \n                yield int(streams), int(artist) \n \nThe most interesting thing here is that this task (*Top10Artists*) defines a dependency on the previous task \n(*AggregateArtists*). This means that if the output of *AggregateArtists* does not exist, the task will run before \n*Top10Artists*. \n \n    $ python examples/top_artists.py Top10Artists --local-scheduler --date-interval 2012-07 \n \nThis will run both tasks. \n \n### Step 3 - Insert into Postgres \n \nThis mainly serves as an example of a specific subclass *Task* that doesn't require any code to be written. It's also an\n example of how you can define task templates that you can reuse for a lot of different tasks. \n \nclass ArtistToplistToDatabase(luigi.postgres.CopyToTable): \n    date_interval = luigi.DateIntervalParameter() \n    use_hadoop = luigi.BooleanParameter() \n \n    host = \"localhost\" \n    database = \"toplists\" \n    user = \"luigi\" \n    password = \"abc123\"  # ;) \n    table = \"top10\" \n \n    columns = [(\"date_from\", \"DATE\"), \n               (\"date_to\", \"DATE\"), \n               (\"artist\", \"TEXT\"), \n               (\"streams\", \"INT\")] \n \n    def requires(self): \n        return Top10Artists(self.date_interval, self.use_hadoop) \n \nJust like previously, this defines a recursive dependency on the previous task. If you try to build the task, that will \nalso trigger building all its upstream dependencies. \n \n### Using the central planner \n \nThe --local-scheduler flag tells Luigi not to connect to a central scheduler. This is recommended in order to get \nstarted and or for development purposes. At the point where you start putting things in production we strongly recommend\n running the central scheduler server. In addition to provide locking so the same task is not run by multiple processes \nat the same time, this server also provides a pretty nice visualization of your current work flow. \n \nIf you drop the *--local-scheduler* flag, your script will try to connect to the central planner, by default at \nlocalhost port 8082. If you run \n \n    PYTHONPATH=. python bin/luigid \n \nin the background and then run \n \n    $ python wordcount.py --date 2012-W03 \n \nthen in fact your script will now do the scheduling through a centralized server. You need \n[Tornado](http://www.tornadoweb.org/) for this to work. \n \nLaunching *http://localhost:8082* should show something like this: \n \n \nLooking at the dependency graph for any of the tasks yields something like this: \n \n \nIn case your job crashes remotely due to any Python exception, Luigi will try to fetch the traceback and print it on \nstandard output. You need [Mechanize](http://wwwsearch.sourceforge.net/mechanize/) for it to work and you also need \nconnectivity to your tasktrackers. \n \n## Conceptual overview \n \nThere are two fundamental building blocks of Luigi - the *Task* class and the *Target* class. Both are abstract classes \nand expect a few methods to be implemented. In addition to those two concepts, the *Parameter* class is an important \nconcept that governs how a Task is run. \n \n### Target \n \nBroadly speaking, the Target class corresponds to a file on a disk. Or a file on HDFS. Or some kind of a checkpoint, \nlike an entry in a database. Actually, the only method that Targets have to implement is the *exists* method which \nreturns True if and only if the Target exists. \n \nIn practice, implementing Target subclasses is rarely needed. You can probably get pretty far with the *LocalTarget* and\n *hdfs.HdfsTarget* classes that are available out of the box. These directly map to a file on the local drive, or a file\n in HDFS, respectively. In addition these also wrap the underlying operations to make them atomic. They both implement \nthe *open(flag)* method which returns a stream object that could be read (flag = 'r') from or written to (flag = 'w'). \nBoth LocalTarget and hdfs.HdfsTarget also optionally take a format parameter. Luigi comes with Gzip support by providing\n *format=format.Gzip* . Adding support for other formats is pretty simple. \n \n### Task \n \nThe *Task* class is a bit more conceptually interesting because this is where computation is done. There is a few \nmethods that can be implemented to alter its behavior, most notably *run*, *output* and *requires*. \n \nThe Task class corresponds to some type of job that is run, but in general you want to allow some form of \nparametrization of it. For instance, if your Task class runs a Hadoop job to create a report every night, you probably \nwant to make the date a parameter of the class. \n \n#### Parameter \n \nIn Python this is generally done by adding arguments to the constructor, but Luigi requires you to declare these \nparameters instantiating Parameter objects on the class scope: \n \nclass DailyReport(luigi.hadoop.JobTask): \n    date = luigi.DateParameter(default=datetime.date.today()) \n    # ... \n \nBy doing this, Luigi can do take care of all the boiler plate code that would normally be needed in the constructor. \nInternally, the DailyReport object can now be constructed by running *DailyReport(datetime.date(2012, 5, 10))* or just \n*DailyReport()*. Luigi also creates a command line parser that automatically handles the conversion from strings to \nPython types. This way you can invoke the job on the command line eg. by passing *--date 2012-15-10*. \n \nThe parameters are all set to their values on the Task object instance, i.e. \n \nd = DailyReport(datetime.date(2012, 5, 10)) \nprint d.date \n \nwill return the same date that the object was constructed with. Same goes if you invoke Luigi on the command line. \n \nPython is not a typed language and you don't have to specify the types of any of your parameters. You can simply use \n*luigi.Parameter* if you don't care. In fact, the reason DateParameter et al exist is just in order to support command \nline interaction and make sure to convert the input to the corresponding type (i.e. datetime.date instead of a string). \n \n \n#### Task.requires \n \nThe *requires* method is used to specify dependencies on other Task object, which might even be of the same class. For \ninstance, an example implementation could be \n \ndef requires(self): \n    return OtherTask(self.date), DailyReport(self.date - datetime.timedelta(1)) \n \nIn this case, the DailyReport task depends on two inputs created earlier, one of which is the same class. requires can \nreturn other Tasks in any way wrapped up within dicts/lists/tuples etc \n \n#### Task.output \n \nThe *output* method returns one or more Target objects. Similarly to requires, can return wrap them up in any way that's\n convenient for you. However we strongly recommend that any Task only returns one single Target in output. \n \nclass DailyReport(luigi.Task): \n    date = luigi.DateParameter() \n    def output(self): \n        return luigi.hdfs.HdfsTarget(self.date.strftime('/reports/%Y-%m-%d')) \n    # ... \n \n \n#### Task.run \n \nThe *run* method now contains the actual code that is run. Note that Luigi breaks down everything into two stages. First\n it figures out all dependencies between tasks, then it runs everything. The *input()* method is an internal helper \nmethod that just replaces all Task objects in requires with their corresponding output. For instance, in this example \n \nclass TaskA(luigi.Task): \n    def output(self): \n        return luigi.LocalTarget('xyz') \n \nclass FlipLinesBackwards(luigi.Task): \n    def requires(self): \n        return TaskA() \n \n    def output(self): \n        return luigi.LocalTarget('abc') \n \n    def run(self): \n        f = self.input().open('r') # this will return a file stream that reads from \"xyz\" \n        g = self.output().open('w') \n        for line in f: \n            g.write('%s\\n', ''.join(reversed(line.strip().split())) \n        g.close() # needed because files are atomic \n \n#### Running from the command line \n \nAny task can be instantiated and run from the command line \n \nclass MyTask(luigi.Task): \n    x = IntParameter() \n    y = IntParameter(default=45) \n    def run(self): \n        print self.x + self.y \n \nif __name__ == '__main__': \n       luigi.run() \n \nYou can run this task from the command line like this: \n \n    python my_task.py MyTask --x 123 --y 456 \n \nYou can also pass *main_task_cls=MyTask* to luigi.run() and that way you can invoke it simply using \n \n    python my_task.py --x 123 --y 456 \n \n#### Executing a Luigi workflow \n \nAs seen above, command line integration is achieved by simply adding \n \nif __name__ == '__main__': \n    luigi.run() \n \nThis will read the args from the command line (using argparse) and invoke everything. \n \nIn case you just want to run a Luigi chain from a Python script, you can do that internally without the command line \nintegration. The code will look something like \n \ntask = MyTask(123, 'xyz') \nsch = scheduler.CentralPlannerScheduler() \nw = worker.Worker(scheduler=sch) \nw.add(task) \nw.run() \n \n#### Instance caching \n \nIn addition to the stuff mentioned above, Luigi also does some metaclass logic so that if eg. \n*DailyReport(datetime.date(2012, 5, 10))* is instantiated twice in the code, it will in fact result in the same object. \nThis is needed so that each Task is run only once. \n \n#### But I just want to run a Hadoop job? \n \nThe Hadoop code is integrated in the rest of the Luigi code because we really believe almost all Hadoop jobs benefit \nfrom being part of some sort of workflow. However, in theory, nothing stops you from using the hadoop.JobTask class (and\n also hdfs.HdfsTarget) without using the rest of Luigi. You can simply run it manually using \n \nMyJobTask('abc', 123).run() \n \nYou can use the hdfs.HdfsTarget class anywhere by just instantiating it: \n \nt = luigi.hdfs.HdfsTarget('/tmp/test.gz', format=format.Gzip) \nf = t.open('w') \n# ... \nf.close() # needed \n \n#### Using the central scheduler \n \nThe central scheduler does not execute anything for you, or help you with job parallelization. The two purposes it \nserves is to \n \n* Make sure two instances of the same task are not running simultaneously \n* Provide visualization of everything that's going on. \n \nFor running tasks periodically, the easiest thing to do is to trigger a Python script from cron or from a continuously \nrunning process. There is no central process that automatically triggers job. This model may seem limited, but we \nbelieve that it makes things far more intuitive and easy to understand. \n \n## Luigi patterns \n \n### Code reuse \n \nOne nice thing about Luigi is that it's super easy to depend on tasks defined in other repos. It's also trivial to have \n\"forks\" in the execution path, where the output of one task may become the input of many other tasks. \n \nCurrently no semantics for \"intermediate\" output is supported, meaning that all output will be persisted indefinitely. \nThe upside of that is that if you try to run X -> Y, and Y crashes, you can resume with the previously built X. The \ndownside is that you will have a lot of intermediate results on your file system. A useful pattern is to put these files\n in a special directory and have some kind of periodical garbage collection clean it up. \n \n### Triggering many tasks \n \nA common use case is to make sure some daily Hadoop job (or something else) is run every night. Sometimes for various \nreasons things will crash for more than a day though. A useful pattern is to have a dummy Task at the end just declaring\n dependencies on the past few days of tasks you want to run. \n \nclass AllReports(luigi.Task): \n    date = luigi.DateParameter(default=datetime.date.today()) \n    lookback = luigi.IntParameter(default=14) \n    def requires(self): \n        for i in xrange(self.lookback): \n           date = self.date - datetime.timedelta(i + 1) \n           yield SomeReport(date), SomeOtherReport(date), CropReport(date), TPSReport(date), FooBarBazReport(date)     \n \nThis simple task will not do anything itself, but will invoke a bunch of other tasks. \n \n## Configuration \n \nAll configuration can be done by adding a configuration file named client.cfg to your current working directory or \n/etc/luigi (although this is further configurable)  \n \n* *default-scheduler-host* defaults the scheduler to some hostname so that you don't have to provide it as an argument \n* *error-email* makes sure every time things crash, you will get an email (unless it was run on the command line) \n* If you want to run Hadoop mapreduce jobs in Python, you should also a path to your streaming jar \n* By default, Luigi is configured to work with the CDH4 release of Hadoop.  There are some minor differences with \nregards to the HDFS CLI in CDH3, CDH4 and the Apache releases of Hadoop.  If you want to use a release other than CDH4, \nyou need to specify which version you are using. \n \n### Example /etc/luigi/client.cfg \n \n[hadoop] \nversion: cdh4 \njar: /usr/lib/hadoop-xyz/hadoop-streaming-xyz-123.jar \n \n[core] \ndefault-scheduler-host: luigi-host.mycompany.foo \nerror-email: foo@bar.baz \n \n## More info \n \nLuigi is the sucessor to a couple of attempts that we weren't fully happy with. We learned a lot from our mistakes and \nsome design decisions include: \n \n* Straightforward command line integration. \n* As little boiler plate as possible. \n* Focus on job scheduling and dependency resolution, not a particular platform. In particular this means no limitation \nto Hadoop. Though Hadoop/HDFS support is built-in and is easy to use, this is just one of many types of things you can \nrun. \n* A file system abstraction where code doesn't have to care about where files are located. \n* Atomic file system operations through this abstraction. If a task crashes it won't lead to a broken state. \n* The depencies are decentralized. No big config file in XML. Each task just specifies which inputs it needs and cross-\nmodule dependencies are trivial. \n* A web server that renders the dependency graph and does locking etc for free. \n* Trivial to extend with new file systems, file formats and job types. You can easily write jobs that inserts a Tokyo \nCabinet into Cassandra. Adding broad support S3, MySQL or Hive should be a stroll in the park. (and feel free to send us\n a patch when you're done!) \n* Date algebra included. \n* Lots of unit tests of the most basic stuff \n \nIt wouldn't be fair not to mention some limitations with the current design: \n \n* Its focus is on batch processing so it's probably less useful for near real-time pipelines or continuously running \nprocesses. \n* The assumption is that a each task is a sizable chunk of work. While you can probably schedule a few thousand jobs, \nit's not meant to scale beyond tens of thousands. \n* Luigi maintains a strict separation between scheduling tasks and running them. Dynamic for-loops and branches are non-\ntrivial to implement. For instance, it's tricky to iterate a numerical computation task until it converges. \n \nIt should actually be noted that all these limitations are not fundamental in any way. However, it would take some major\n refactoring work. \n \nAlso it should be mentioned that Luigi is named after the world's second most famous plumber. \n \n## Future ideas \n \n* S3/EC2 - We have some old ugly code based on Boto that could be integrated in a day or two. \n* Built in support for Pig/Hive. \n* Better visualization tool - the layout gets pretty messy as the number of tasks grows. \n* Integration with existing Hadoop frameworks like mrjob would be cool and probably pretty easy. \n* Better support (without much boiler plate) for unittesting specific Tasks \n \n## Getting help \n \n* Find us on #luigi on freenode. \n* Subscribe to the [luigi-user](http://groups.google.com/group/luigi-user/) group and ask a question. \n \n## Want to contribute? \n \nAwesome! Let us know if you have any ideas. Feel free to contact x@y.com where x = luigi and y = spotify.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/spotify/luigi",
    "keywords": null,
    "license": "UNKNOWN",
    "maintainer": null,
    "maintainer_email": null,
    "name": "luigi",
    "package_url": "https://pypi.org/project/luigi/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/luigi/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/spotify/luigi"
    },
    "release_url": "https://pypi.org/project/luigi/1.0.6/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Workflow mgmgt + task scheduling + dependency resolution",
    "version": "1.0.6",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17285056,
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e93d68c6ca27f4bda9aabfef3c58c2866cf5db6e05524162d36b3adb4e8fa8e5",
        "md5": "173f1868d0f8c318b2f9e91036d9bff2",
        "sha256": "41728a3c49b813d96f39d5d21ad4f014c70b29c19214ea6c0e8cd8264d2d5e06"
      },
      "downloads": -1,
      "filename": "luigi-1.0.6.tar.gz",
      "has_sig": false,
      "md5_digest": "173f1868d0f8c318b2f9e91036d9bff2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 225527,
      "upload_time": "2013-08-07T23:47:21",
      "upload_time_iso_8601": "2013-08-07T23:47:21.097840Z",
      "url": "https://files.pythonhosted.org/packages/e9/3d/68c6ca27f4bda9aabfef3c58c2866cf5db6e05524162d36b3adb4e8fa8e5/luigi-1.0.6.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": [
    {
      "aliases": [
        "CVE-2018-1000843",
        "GHSA-p69g-f978-xxv9"
      ],
      "details": "Luigi version prior to version 2.8.0; after commit 53b52e12745075a8acc016d33945d9d6a7a6aaeb; after GitHub PR spotify/luigi/pull/1870 contains a Cross ite Request Forgery (CSRF) vulnerability in API endpoint: /api/<method> that can result in Task metadata such as task name, id, parameter, etc. will be leaked to unauthorized users. This attack appear to be exploitable via The victim must visit a specially crafted webpage from the network where their Luigi server is accessible.. This vulnerability appears to have been fixed in 2.8.0 and later.",
      "fixed_in": [
        "2.8.0"
      ],
      "id": "PYSEC-2018-11",
      "link": "https://osv.dev/vulnerability/PYSEC-2018-11",
      "source": "osv",
      "summary": null,
      "withdrawn": null
    },
    {
      "aliases": [
        "CVE-2018-1000843"
      ],
      "details": "Luigi version prior to version 2.8.0; after commit 53b52e12745075a8acc016d33945d9d6a7a6aaeb; after GitHub PR spotify/luigi/pull/1870 contains a Cross ite Request Forgery (CSRF) vulnerability in API endpoint: /api/<method> that can result in Task metadata such as task name, id, parameter, etc. will be leaked to unauthorized users. This attack appear to be exploitable via The victim must visit a specially crafted webpage from the network where their Luigi server is accessible.. This vulnerability appears to have been fixed in 2.8.0 and later.",
      "fixed_in": [
        "2.8.0"
      ],
      "id": "GHSA-p69g-f978-xxv9",
      "link": "https://osv.dev/vulnerability/GHSA-p69g-f978-xxv9",
      "source": "osv",
      "summary": null,
      "withdrawn": null
    }
  ]
}