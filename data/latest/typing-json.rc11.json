{
  "info": {
    "author": "sg495",
    "author_email": "sg495@users.noreply.github.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.7",
      "Typing :: Typed"
    ],
    "description": "# Welcome to the `typing_json` library\n[![Build Status](https://api.travis-ci.com/sg495/typing-json.svg?branch=master)](https://travis-ci.com/sg495/typing-json)\n[![codecov](https://codecov.io/gh/sg495/typing-json/graph/badge.svg)](https://codecov.io/gh/sg495/typing-json/)\n[![Generic badge](https://img.shields.io/badge/python-3.7/3.8-green.svg)](https://shields.io/)\n[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)\n[![PyPI version shields.io](https://img.shields.io/pypi/v/typing-json.svg)](https://pypi.python.org/pypi/typing-json/)\n[![PyPI status](https://img.shields.io/pypi/status/typing-json.svg)](https://pypi.python.org/pypi/typing-json/)\n[![Generic badge](https://img.shields.io/badge/license-MIT-green.svg)](https://choosealicense.com/licenses/mit/)\n\nThe `typing_json` library offers type-aware JSON encoding and decoding functionalities, on top of those offered by the builtin `json` library. The functions `dump`, `dumps`, `load` and `loads` mirror the functionality of their `json` counterparts, adding type-aware encoding/decoding and runtime type-checking of decoded objects.\n\nSupported types include JSON basic types, `Decimal`, typed collections from the `typing` library, literal types, union types, optional types and typed namedtuples. For a full list of types, see below.\nThe function `is_instance` extends the functionality of the builtin `isinstance` to include all the additional types supported by this library.\n\nThe [documentation](https://sg495.github.io/typing-json/typing_json/index.html) for this library was generated with [pdoc](https://pdoc3.github.io/pdoc/).\n\nYou can install the `typing_json` library with pip:\n\n```\npip install typing_json\n```\n\n\n## Main goals\n\nThere are two main drivers behind the development of the `typing_json` library:\n\n1. Type-aware **serialisation** of data using JSON.\n2. Runtime **validation** of JSON data for use with static typing.\n\nThe first goal of the `typing_json` library is to automate the serialisation of statically typed data in Python.\nIn a statically typed Python application (e.g. one validated using [mypy](http://mypy-lang.org/)), data is often structured using simple static types.\nThe `typing_json` library uses these types to automate the process of JSON serialisation and de-serialisation, ensuring that the serialised data can subsequently be de-serialised into a valid instance of the original static type, equivalent to the instance that was originally serialised.\n\nThe second goal of the `typing_json` library is to automate the validation of JSON data against existing static types.\nWhen JSON data is loaded dynamically into a statically typed Python application, it needs to be validated to ensure that it conforms to whatever static types are being used as its specification.\nThe `typing_json` library uses these types to automate the validation process, i.e. to perform runtime type-checking of the JSON data against the static types.\nThis guarantees that data successfully de-serialised from JSON using the `load`/`loads` functions of the `typing_json` library conforms to the static type provided.\n\n\n## Types supported\n\nThe following types are currently supported by the `typing_json` library:\n\n- the JSON basic types `bool`, `int`, `float`, `str` and `NoneType` (technically `type(None)`, but `None` can be used as an alias);\n- the type `Decimal` from the `decimal` builtin (cf. below for the handling of numerical types);\n- the following typed collections from the `typing` builtin library, as long as all generic type arguments are themselves supported: `List`, `Tuple`, `Deque`, `Set`, `FrozenSet`;\n- typed namedtuples constructed using `NamedTuple` from the builtin `typing` library, as long as all fields are of supported type;\n- typed dictionaries constructed using `TypedDict` from the `typing_extensions` library, as long as all fields are of supported type;\n- the following typed collections from the `typing` builtin library, as long as the generic key/value generic type arguments are themselves supported: `Dict`, `Mapping` and `OrderedDict` (see below for additional requirements on the key generic type arguments and special behaviour on JSON encoding/decoding of keys);\n- enumeration types\n- the `Literal` types from the `typing_extensions` library, as long as all literal are of one of the JSON basic types above;\n- `Optional` and `Union` types from the `typing` builtin library, as long as all generic type arguments are themselves supported (cf. below for a caveat about `Union` types).\n\nThe following function can be used at runtime to check whether `t` is a type supported by the `typing_json` library:\n\n```python\n    def is_json_encodable(t: Any, failure_callback=None) -> bool:\n        ...\n```\n\nThe optional parameter `failure_callback` can be used to pass a `Callable[[str], None]` that will be used to log any error messages.\nThe following provides an example of usage:\n\n```python\n# Python 3.7.4\n>>> from typing import Dict, List, Set, Tuple\n>>> from typing_json import is_json_encodable\n>>> error_log = []\n>>> my_callback = lambda s: error_log.append(s)\n>>> is_json_encodable(List[Dict[Set[int], int]], failure_callback=my_callback)\nFalse\n>>> error_log\n['Type typing.Set[int] is not keyable.',\n 'Type of keys in typing.Dict[typing.Set[int], int] is not keyable.',\n 'Type of elements in typing.List[typing.Dict[typing.Set[int], int]] is not json-encodable.']\n```\n\n\n## Overview of encoding/decoding functions\n\nThere are three pairs of encoding/decoding functions offered by the `typing_json` library, for use in three different circumstances.\n\nThe functions `to_json_obj` / `from_json_obj` offer runtime conversion of instances of supported types to/from JSON objects.\n\n```python\n    def to_json_obj(obj: Any, t: Type, use_decimal: bool = False) -> Any:\n        ...\n\n    def from_json_obj(obj: Any, t: Type, cast_decimal: bool = True) -> Any:\n        ...\n```\n\nThe functions `dumps` / `loads` offer (de-)serialisation of instances of supported types to/from JSON formatted strings.\n\n```python\ndef dumps(obj: Any, encoded_type: Type, **kwargs) -> str:\n    ...\n\ndef loads(s: str, decoded_type: Type, cast_decimal: bool = True, **kwargs) -> Any:\n    ...\n```\n\nThe functions `dump` / `load` offer (de-)serialisation of instances of supported types to/from JSON formatted IO streams.\n\n```python\ndef dump(obj: Any, encoded_type: Type, fp, **kwargs) -> None:\n    ...\n\ndef load(fp, decoded_type: Type, cast_decimal: bool = True, **kwargs) -> Any:\n    ...\n```\n\nThe calls `dump(obj, t, fp)` / `dumps(obj, t)` first use `to_json_obj(obj, t)` to encode an instance `obj` of a supported type `t` into a JSON object `obj_json`, then call `json.dump(obj_json)` / `json.dumps(obj_json)` to serialise `obj_json` to a file object `fp` or string.\n\nConversely, the calls `load(fp, t)` / `loads(s, t)` first call `json.load(fp)` / `json.loads(s)` to deserialise a JSON object `obj_json` from a file object `fp` or string `s`, then call `from_json_obj(obj_json, t)` to decode an instance `obj` of a supported type `t` from `obj_json`.\n\nIn all functions above, `TypeError` is raised if the object passed does not match the type specified.\nThis runtime type-checking is performed by the function `is_instance`:\n\n```python\ndef is_instance(obj: Any, t: Type, failure_callback=None, cast_decimal: bool = True) -> bool:\n    ...\n```\n\nThe function `is_instance` extends the behaviour of the builtin `isinstance` to type-checking of instances `obj` of all types `t` supported by the `typing_json` library.\nMost importantly, this includes the generic typed collections of the `typing` library, and features a slight alteration of behaviour on booleans and numerical types.\n\n\n## Using `dump`, `dumps`, `load` and `loads`\n\nThe functions `dump`, `dumps`, `load` and `loads` in the `typing_json` library mirror their builtin `json` counterparts, with a couple of exceptions:\n\n- an additional parameter `encoded_type` (resp. `decoded_type`) is used in `dump` / `dumps` (resp. in `load` / `loads`) to specify the type to be used in the JSON encoding (resp. decoding);\n- an additional optional parameter `cast_decimal` (default: `True`) is used in `load` / `loads` to specify whether instances of `Decimal` (used by default to parse float literals) should be silently cast to `int` and `float` wherever the type requires them to.\n\nAside from the additional type parameter, the usage of `dump`, `dumps`, `load` and `loads` is the same as that of their `json` counterparts:\n\n```python\n# Python 3.7.4\n>>> from typing import Dict\n>>> from typing_json import load\n# myexpenses.json:\n#\n# {\n#   \"home\": 150.25,\n#   \"travel\": 78.90,\n#   \"entertainment\": 52.00\n# }\n#\n>>> with open(\"myexpenses.json\", \"r\") as fp:\n...     load(fp, Dict[str, float])\n...\n{\"home\": 150.25, \"travel\": 78.90, \"entertainment\": 52.00}\n```\n\n```python\n# Python 3.7.4\n>>> from typing import Dict\n>>> from typing_json import loads\n>>> s = '{\"home\": 150.25, \"travel\": 78.9, \"entertainment\": 52.0}'\n>>> loads(s, Dict[str, float])\n{\"home\": 150.25, \"travel\": 78.90, \"entertainment\": 52.00}\n```\n\n```python\n# Python 3.7.4\n>>> from typing import Dict\n>>> from typing_json import dump\n>>> myexpenses = {\"home\": 150.25, \"travel\": 78.90, \"entertainment\": 52.00}\n>>> with open(\"myexpenses.json\", \"w\") as fp:\n...      dump(myexpenses, Dict[str, float], fp)\n...\n# myexpenses.json:\n#\n# {\n#   \"home\": 150.25,\n#   \"travel\": 78.90,\n#   \"entertainment\": 52.00\n# }\n#\n```\n\n```python\n>>> from typing import Dict\n>>> from typing_json import loads\n>>> myexpenses = {\"home\": 150.25, \"travel\": 78.90, \"entertainment\": 52.00}\n>>> dumps(myexpenses, Dict[str, float])\n'{\"home\": 150.25, \"travel\": 78.9, \"entertainment\": 52.0}'\n```\n\n\n\n\n## Basic types\n\nOn JSON basic types, the `to_json_obj` and `from_json_obj` functions return their argument unchanged:\n\n```python\n# Python 3.7.4\n>>> from typing_json import to_json_obj\n>>> to_json_obj(True, bool)\nTrue\n>>> to_json_obj(1, int)\n1\n>>> to_json_obj(1.5, float)\n1.5\n>>> to_json_obj(\"hello\", str)\n\"hello\"\n>>> to_json_obj(None, type(None))\nNone\n>>> to_json_obj(None, None) # `None` is alias for `type(None)`\nNone\n```\n\nThe exact same outcomes above are obtained if `to_json_obj` is replaced with `from_json_obj`.\n\nThe behaviour of `is_instance` on JSON basic types features two slight alterations from the behaviour of the builtin `isinstance`.\nFirstly, the `bool` literals `True` and `False` are not deemed to be of type `int` by `is_instance`, but they are by the builtin `isinstance`:\n\n```python\n# Python 3.7.4\n>>> from typing_json import is_instance\n>>> isinstance(False, int) # builtin\nTrue\n>>> isinstance(True, int) # builtin\nTrue\n>>> is_instance(False, int) # typing_json\nFalse\n>>> is_instance(True, int) # typing_json\nFalse\n```\n\nSecondly, instances of `int` are deemed to be of type `float` by `is_instance`, but they are not by the builtin `isinstance`:\n\n```python\n# Python 3.7.4\n>>> from typing_json import is_instance\n>>> isinstance(1, int) # builtin\nTrue\n>>> isinstance(1, float) # builtin\nFalse\n>>> is_instance(1, int) # typing_json\nTrue\n>>> is_instance(1, float) # typing_json\nTrue\n```\n\n\n## Number types\n\nWhen parsing JSON strings, from file object using `load` or from string instances using `loads`, the default behaviour is to use the constructor of class `Decimal` from the builtin `decimal` library to parse floating point literals.\nThis informs the following handling of number types in the `to_json_obj` / `from_json_obj` functions.\n\nThe default behaviour in `from_json_obj` is to silently decode instances of `Decimal` to instances of `int` and `float`, according to the type specified:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing_json import from_json_obj\n>>> from_json_obj(Decimal(\"1.2\"), Decimal)\nDecimal(\"1.2\")\n>>> from_json_obj(Decimal(\"1.2\"), float)\n1.2\n>>> from_json_obj(Decimal(\"1.0\"), Decimal)\nDecimal(\"1.0\")\n>>> from_json_obj(Decimal(\"1.0\"), float)\n1.0\n>>> from_json_obj(Decimal(\"1.0\"), int)\n1\n```\n\nThe optional parameter `cast_decimal` of `from_json_obj` (default: `True`) can be set to `False` to disable the silent conversion of `Decimal` to `float` and `int`:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing_json import from_json_obj\n>>> from_json_obj(Decimal(\"1.2\"), Decimal, cast_decimal=False)\nDecimal(\"1.2\")\n>>> from_json_obj(Decimal(\"1.2\"), float, cast_decimal=False)\n# TypeError: Object Decimal('1.2') is not of json basic type t=<class 'float'>.\n>>> from_json_obj(Decimal(\"1.0\"), Decimal, cast_decimal=False)\nDecimal(\"1.0\")\n>>> from_json_obj(Decimal(\"1.0\"), float, cast_decimal=False)\n# TypeError: Object Decimal('1.0') is not of json basic type t=<class 'float'>.\n>>> from_json_obj(Decimal(\"1.0\"), int, cast_decimal=False)\n# TypeError: Object Decimal('1.0') is not of json basic type t=<class 'int'>.\n```\n\nTo ensure that decimal precision is maintained, instances `Decimal` are ordinarily encoded into JSON as strings:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing_json import to_json_obj\n>>> to_json_obj(Decimal(\"1.2\"), Decimal)\n\"1.2\"\n>>> to_json_obj(Decimal(\"-16\"), Decimal)\n\"-16\"\n```\n\nThe optional parameter `use_decimal` of `to_json_obj` (default: `True`) can be set to `True` to instead allow instances of `Decimal` to be used directly in JSON objects:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing_json import to_json_obj\n>>> to_json_obj(Decimal(\"1.2\"), Decimal, use_decimal=True)\nDecimal(\"1.2\")\n>>> to_json_obj(Decimal(\"-16\"), Decimal, use_decimal=True)\nDecimal(\"-16\")\n```\n\nFinally, integers are always silently converted to floating point numbers in `from_json_obj`, but trying to convert floating point numbers to integers will always raise an error, regardless of whether the encoded number is an integer:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing_json import from_json_obj\n>>> from_json_obj(1, int)\n1\n>>> from_json_obj(1, float)\n1.0\n>>> from_json_obj(1.0, float)\n1.0\n>>> from_json_obj(1.0, int)\n# TypeError: Object 1.0 is not of json basic type t=<class 'int'>.\n```\n\n\n## Sequences\n\nInstances of `List`, `Tuple` and `Deque` are encoded by `to_json_obj` as JSON lists, with their elements recursively encoded:\n\n```python\n# Python 3.7.4\n>>> from collections import deque\n>>> from decimal import Decimal\n>>> from typing import Deque, List, Tuple\n>>> from typing_json import to_json_obj\n>>> to_json_obj([1, 2, 3], List[int])\n[1, 2, 3]\n>>> to_json_obj((1, 2.5, Decimal(\"3.5\")), Tuple[int, float, Decimal])\n[1, 2.5, \"3.5\"]\n>>> to_json_obj(deque([\"a\", \"b\", \"c\"]), Deque[str])\n[\"a\", \"b\", \"c\"]\n>>> to_json_obj(((0, Decimal(\"0.5\")), (1, Decimal(\"3\"))), Tuple[Tuple[int, Decimal], ...])\n[[0, \"0.5\"], [1, \"3\"]]\n```\n\nJSON lists are are decoded by `from_json_obj` to instances of `List`, `Tuple` and `Deque` depending on the specified type, with elements recursively decoded from the elements of the JSON list:\n\n```python\n# Python 3.7.4\n>>> from collections import deque\n>>> from decimal import Decimal\n>>> from typing import Deque, List, Tuple\n>>> from typing_json import from_json_obj\n>>> from_json_obj([1, 2, 3], List[int])\n[1, 2, 3]\n>>> from_json_obj([1, 2.5, '3.5'], Tuple[int, float, Decimal])\n(1, 2.5, Decimal(\"3.5\"))\n>>> from_json_obj([\"a\", \"b\", \"c\"], Deque[str])\ndeque([\"a\", \"b\", \"c\"])\n>>> from_json_obj([[0, \"0.5\"], [1, \"3\"]], Tuple[Tuple[int, Decimal], ...])\n((0, Decimal(\"0.5\")), (1, Decimal(\"3\")))\n```\n\n\n## Sets\n\nInstances of `Set` and `FrozenSet` are encoded by `to_json_obj` as JSON lists, with their elements recursively encoded:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing import FrozenSet, Set\n>>> from typing_json import to_json_obj\n>>> to_json_obj({1, 2, 3}, Set[int])\n[1, 2, 3]\n>>> to_json_obj(frozenset({Decimal(\"1.5\"), Decimal(\"2.5\")}), FrozenSet[Decimal])\n[\"1.5\", \"2.5\"]\n```\n\nJSON lists are are decoded by `from_json_obj` to instances of `Set` and `FrozenSet` depending on the specified type, with elements recursively decoded from the elements of the JSON list:\n\n```python\n# Python 3.7.4\n>>> from decimal import Decimal\n>>> from typing import FrozenSet, Set\n>>> from typing_json import from_json_obj\n>>> from_json_obj([1, 2, 3], Set[int])\n{1, 2, 3}\n>>> from_json_obj([\"1.5\", \"2.5\"], FrozenSet[Decimal])\nfrozenset({Decimal(\"1.5\"), Decimal(\"2.5\")})\n```\n\n\n## NamedTuples\n\nInstances of typed namedtuples constructed with `NamedTuple` are encoded by `to_json_obj` as JSON dictionaries (ordered), with the field names as their keys and the field values recursively encoded:\n\n```python\n# Python 3.7.4\n>>> from collections import OrderedDict\n>>> from typing import NamedTuple, Set, Tuple\n>>> from typing_json import to_json_obj\n>>> class Network(NamedTuple):\n...     nodes: Set[int]\n...     edges: Set[Tuple[int, int]]\n...\n>>> network = Network({0, 1, 2}, {(0, 1), (1, 2), (0, 2)})\n>>> to_json_obj(network, Network)\nOrderedDict([('nodes', [0, 1, 2]), ('edges', [[0, 1], [0, 2], [1, 2]])])\n>>> dict(to_json_obj(network, Network))\n{'nodes': [0, 1, 2], 'edges': [[0, 1], [0, 2], [1, 2]]}\n```\n\nJSON dictionaries are decoded by `from_json_obj` to instances of typed namedtuples depending on the specified type, with fields values recursively decoded from the values of the dictionary:\n\n```python\n# Python 3.7.4\n>>> from typing import NamedTuple, Set, Tuple\n>>> from typing_json import from_json_obj\n>>> class Network(NamedTuple):\n...     nodes: Set[int]\n...     edges: Set[Tuple[int, int]]\n...\n>>> from_json_obj({'nodes': [0, 1, 2], 'edges': [[0, 1], [0, 2], [1, 2]]}, Network)\nNetwork(nodes={0, 1, 2}, edges={(0, 1), (0, 2), (1, 2)})\n```\n\nWhile `collections.OrderedDict` is always used by `to_json_obj` when encoding typed namedtuples, but `from_json_obj` will also accept ordinary dictionaries (because the order of fields is already determined by the namedtuple type).\nIf the namedtuple has fields with default values, `from_json_obj` will use the default value for any field not appearing in the dictionary:\n\n```python\n# Python 3.7.4\n>>> from typing import NamedTuple, Set, Tuple\n>>> from typing_json import from_json_obj\n>>> class Employee(NamedTuple):\n...     name: str\n...     id: int = 3\n...\n>>> from_json_obj({\"name\": \"Gill\", \"id\": 2}, Employee)\nEmployee(name='Gill', id=2) # \"id\" value from dictionary\n>>> from_json_obj({\"name\": \"John\"}, Employee)\nEmployee(name='John', id=3) # default \"id\" value from `Employee`\n>>> from_json_obj({\"id\": 0}, Employee)\n# TypeError: Object {'id': 0} does not have the required keys:\n# t=<class '__main__.Employee'>, missing keys {'name'}.\n```\n\nIf a field in the namedtuple does not have a default value and does not appear in the dictionary, `from_json_obj` will raise `TypeError`.\n\n\n## Typed Dictionaries\n\nInstances of typed dictionaries constructed with `TypedDict` are encoded by `to_json_obj` as JSON dictionaries (ordered), with the same keys and JSON-encoded values:\n\n```python\n# Python 3.8.3\n>>> from collections import OrderedDict\n>>> from typing import Set, Tuple\n>>> from typing_extensions import TypedDict\n>>> from typing_json import to_json_obj\n>>> class Network(TypedDict):\n...     nodes: Set[int]\n...     edges: Set[Tuple[int, int]]\n...\n>>> network = {\"nodes\": {0, 1, 2}, \"edges\": {(0, 1), (1, 2), (0, 2)}}\n>>> to_json_obj(network, Network)\nOrderedDict([('nodes', [0, 1, 2]), ('edges', [[0, 1], [0, 2], [1, 2]])])\n>>> dict(to_json_obj(network, Network))\n{'nodes': [0, 1, 2], 'edges': [[0, 1], [0, 2], [1, 2]]}\n```\n\nJSON dictionaries are decoded by `from_json_obj` to instances of typed dictionaries depending on the specified type, with values recursively decoded from the values of the dictionary:\n\n```python\n# Python 3.8.3\n>>> from typing import Set, Tuple\n>>> from typing_extensions import TypedDict\n>>> from typing_json import from_json_obj\n>>> class Network(TypedDict):\n...     nodes: Set[int]\n...     edges: Set[Tuple[int, int]]\n...\n>>> from_json_obj({'nodes': [0, 1, 2], 'edges': [[0, 1], [0, 2], [1, 2]]}, Network)\n{\"nodes\": {0, 1, 2}, \"edges\": {(0, 1), (1, 2), (0, 2)}}\n```\n\nWhile `collections.OrderedDict` is always used by `to_json_obj` when encoding typed dictionaries, but `from_json_obj` will also accept ordinary dictionaries (because the order of fields is already determined by the typed dictionary).\n\n\n## Dictionaries\n\nInstances of `Mapping` and `Dict` are encoded by `to_json_obj` as JSON dictionaries, with their keys and values recursively encoded and their keys stringified if necessary (cf. below).\nInstances of `OrderedDict` follow the exact same rules, but are encoded as instances of `collections.OrderedDict` rather than instances of `dict`.\n\n```python\n# Python 3.7.4\n>>> import collections\n>>> from decimal import Decimal\n>>> import typing\n>>> from typing import Dict, Mapping, Tuple\n>>> from typing_json import to_json_obj\n>>> vect = {\"x\": (Decimal(\"1.0\"), Decimal(\"0.0\")), \"y\": (Decimal(\"0.0\"), Decimal(\"1.0\"))}\n>>> to_json_obj(vect, Dict[str, Tuple[Decimal, Decimal]])\n{\"x\": [\"1.0\", \"0.0\"], \"y\": [\"0.0\", \"1.0\"]}\n>>> to_json_obj(vect, Mapping[str, Tuple[Decimal, Decimal]])\n{\"x\": [\"1.0\", \"0.0\"], \"y\": [\"0.0\", \"1.0\"]}\n>>> to_json_obj(collections.OrderedDict(vect),\n...             typing.OrderedDict[str, Tuple[Decimal, Decimal]])\nOrderedDict([(\"x\", [\"1.0\", \"0.0\"]), (\"y\", [\"0.0\", \"1.0\"])])\n```\n\nKeys are either encoded or encoded and then stringified, depending on the key type:\n\n- JSON basic types (`bool`, `int`, `float`, `str` and `type(None)`) are encoded but not stringified;\n- literal types are encoded but not stringified (because only JSON basic types are allowed as literals);\n- enumeration types are encoded but not stringified (because they are already encoded as strings);\n- all other types are first encoded and then stringified.\n\nFor example, dictionaries using tuples as keys have their keys first encoded into lists and then stringified to form the keys of the final JSON dictionary:\n\n```python\n# Python 3.7.4\n>>> from typing import Dict, Tuple\n>>> from typing_json import to_json_obj\n>>> to_json_obj({(0,1): \"yes\", (2,3): \"no\"}, Dict[Tuple[int, int], str])\n{'[0, 1]': 'yes', '[2, 3]': 'no'}\n```\n\nJSON dictionaries are decoded by `from_json_obj` to instances of `Dict` and `Mapping` depending on the specified type. JSON ordered dictionaries (`collections.OrderedDict`) are decoded by `from_json_obj` to instances of `Dict`, `Mapping` and `OrderedDict` depending on the specified type.\nValues and keys are recursively decoded, and keys are first de-serialised from strings (using `json.loads`) if they were stringified as part of the encoding.\n\n```python\n# Python 3.7.4\n>>> import collections\n>>> from decimal import Decimal\n>>> import typing\n>>> from typing import Dict, Mapping, Tuple\n>>> from typing_json import from_json_obj\n>>> vect_json = {\"x\": [\"1.0\", \"0.0\"], \"y\": [\"0.0\", \"1.0\"]}\n>>> from_json_obj(vect_json, Dict[str, Tuple[Decimal, Decimal]])\n{\"x\": (Decimal(\"1.0\"), Decimal(\"0.0\")), \"y\": (Decimal(\"0.0\"), Decimal(\"1.0\"))}\n>>> from_json_obj(vect_json, Mapping[str, Tuple[Decimal, Decimal]])\n{\"x\": (Decimal(\"1.0\"), Decimal(\"0.0\")), \"y\": (Decimal(\"0.0\"), Decimal(\"1.0\"))}\n>>> from_json_obj(collections.OrderedDict(vect_json),\n...               typing.OrderedDict[str, Tuple[Decimal, Decimal]])\nOrderedDict([(\"x\", (Decimal(\"1.0\"), Decimal(\"0.0\"))), (\"y\", (Decimal(\"0.0\"), Decimal(\"1.0\")))])\n>>> from_json_obj({'[0, 1]': 'yes', '[2, 3]': 'no'}, Dict[Tuple[int, int], str])\n{(0,1): \"yes\", (2,3): \"no\"}\n```\n\n\n## Enumerations\n\nEnumerations members are encoded by using the corresponding member names and decoded by associating the number to the member of corresponding name:\n\n```python\n# Python 3.7.4\n>>> from enum import Enum\n>>> from typing_json import to_json_obj, from_json_obj\n>>> class Color(Enum):\n...     RED = (1.0, 0.0, 0.0)\n...     GREEN = (0.0, 1.0, 0.0)\n...     BLUE = (0.0, 0.0, 1.0)\n...\n>>> to_json_obj(Color.RED, Color)\n\"RED\"\n>>> from_json_obj(\"RED\", Color)\n<Color.RED: (1.0, 0.0, 0.0)>\n>>> to_json_obj({Color.RED: (255, 0, 0),\n...              Color.GREEN: (0, 255, 0),\n...              Color.BLUE: (0, 0, 255)},\n...             Dict[Color, Tuple[int, int, int]])\n{'RED': [255, 0, 0], 'GREEN': [0, 255, 0], 'BLUE': [0, 0, 255]}\n```\n\n\n\n## Literal types\n\nLiteral types can be constructed using `typing_extensions.Literal`, as long as the literals are all of JSON basic type.\nLiteral types are encoded/decoded exactly like JSON basic types would, i.e. nothing is done to them.\n\n\n## Optional types\n\nWhen encoding instances of an `Optional` type, it is first checked whether the instance can be encoded using the given generic type argument. If not, it is checked that the instance is `None`, in which case `None` is returned as the encoding (following the procedure for the JSON basic type `type(None)`).\n\n```python\n# Python 3.7.4\n>>> from typing import Dict, Optional, Set\n>>> from typing_json import to_json_obj\n>>> to_json_obj({\"set\": {1, 2, 3}}, Dict[str, Optional[Set[int]]])\n{\"set\": [1, 2, 3]}\n>>> to_json_obj({\"set\": None}, Dict[str, Optional[Set[int]]])\n{\"set\": None}\n```\n\nSimilarly, when decoding instances of an `Optional` type, it is first checked whether the JSON object can be decoded using the given generic type argument. If not, it is checked that the instance is `None`, in which case `None` is returned as the decoding.\n\n```python\n# Python 3.7.4\n>>> from typing import Dict, Optional, Set\n>>> from typing_json import from_json_obj\n>>> from_json_obj({\"set\": [1, 2, 3]}, Dict[str, Optional[Set[int]]])\n{\"set\": {1, 2, 3}}\n>>> from_json_obj({\"set\": None}, Dict[str, Optional[Set[int]]])\n{\"set\": None}\n```\n\n## Union types\n\nWhen serialising instances `obj` of a `Union` type, the generic type arguments of `Union` are tried in sequence until a type `T` is found of which `obj` is an instance (accoring to the `is_instance` function).\nThe serialisation then proceeds using `T` as the static type:\n\n```python\n# Python 3.7.4\n>>> from typing import Union\n>>> from typing_json import dumps\n>>> dumps(1, Union[int, str, float]) # same as `dumps(1, int)`\n'1'\n>>> dumps(\"hello\", Union[int, str, float]) # same as `dumps(\"hello\", str)`\n'\"hello\"'\n>>> dumps(2.5, Union[int, str, float]) # same as `dumps(2.5, float)`\n'2.5'\n```\n\nWhen the JSON data `obj_json` is de-serialised, the generic type arugments of `Union` ara again tried in sequence until a type `T` is found which results in correct de-serialisation of `obj_json`:\n\n```python\n# Python 3.7.4\n>>> from typing import Union\n>>> from typing_json import loads\n>>> loads('1', Union[int, str, float]) # same as `loads(1, int)`\n1\n>>> loads('\"hello\"', Union[int, str, float]) # same as `loads(\"hello\", str)`\n\"hello\"\n>>> loads('2.5', Union[int, str, float]) # same as `loads(2.5, float)`\n2.5\n```\n\nThis works well as long as the JSON encodings of the types are disjoint, as is the case for all JSON basic types.\nUnfortunately, some issues arise with overlapping union types, explained more in detail below.\nIn short: if two types in a `Union` have overlapping JSON encodings (e.g. `List` and `Set` are both encoded into JSON using lists), they may be deserialised to the incorrect runtime type (though the static `Union` type will still be respected).\n\n```python\n# Python 3.7.4\n>>> from typing import List, Set, Union\n>>> from typing_json import dumps, loads\n>>> UnionT = Union[List[int], Set[int]]\n>>> dumps([1, 2, 3], UnionT)\n'[1, 2, 3]'\n>>> dumps({1, 2, 3}, UnionT)\n'[1, 2, 3]'\n>>> loads(dumps([1, 2, 3], UnionT), UnionT)\n[1, 2, 3]\n>>> loads(dumps({1, 2, 3}, UnionT), UnionT)\n[1, 2, 3]\n```\n\nTagged unions can be used to mitigate this issue. Currently, tagged unions need to be defined manually (cf. below), but an automated way to construct them is a planned feature for future versions.\n\n\n## Overlapping union types\n\nHowever, this may create some issues when the following conditions are met:\n\n1. the JSON encodings for two type in the `Union` overlap, as is the case for the collections `List`, `Tuple`, `Deque`, `Set` and `FrozenSet`;\n2. the application depends on the runtime type of the `Union` instances in a way which results in incompatible behaviour on the overlaps.\n\nThe de-serialised object is still going to be a valid instance of the `Union` type, but its runtime type may not be the expected one.\nTo see a concrete example of this, imagine that we have a network with nodes labelled by `int`, featuring both directed and undirected edges.\nThe directed edges are encoded as 2-tuples, while the undirected edges are encoded as frozensets with two elements.\nLet's look at what happens when we serialise and de-serialise such a network:\n\n```python\n# Python 3.7.4\n>>> from typing import FrozenSet, NamedTuple, Set, Tuple, Union\n>>> from typing_json import dumps, loads\n>>> class Network(NamedTuple):\n...     nodes: Set[int]\n...     edges: Set[Union[Tuple[int, int], FrozenSet[int]]]\n...\n>>> nodes = {1, 2, 3}\n>>> edges = {(1, 2), frozenset({2, 3}), frozenset({1, 3})}\n>>> network = Network(nodes, edges)\n>>> print(network)\nNetwork(nodes={1, 2, 3}, edges={(1, 2), frozenset({1, 3}), frozenset({2, 3})})\n>>> network_serialised = dumps(network, Network)\n>>> print(network_serialised)\n{\"nodes\": [1, 2, 3], \"edges\": [[1, 2], [1, 3], [2, 3]]}\n>>> network_deserialised = loads(network_serialised, Network)\n>>> print(network_deserialised)\nNetwork(nodes={1, 2, 3}, edges={(1, 2), (1, 3), (2, 3)})\n```\n\nBoth directed edges (instances of `Tuple[int, int]`) and undirected edges (instances of `FrozenSet[int]` with two elements) in our `Network` data structure are encoded as lists with two elements.\nFor example, `[1, 3]` is the encoding of both the undirected edge `frozenset({1, 3})` (which is in our network) and a directed edge `(1, 3)` (which is not in our network).\nBecause of this, `[1, 3]` can be deserialised using both `Tuple[int, int]` and `FrozenSet[int]`: since `Tuple[int, int]` appears first in the list of generic type arguments to `Union`, `[1, 3]` will be deserialised to a directed edge `(1, 3)`, even though it was serialised from an undirected edge `frozenset({1, 3})`.\nIndeed, you can see from the prints of the example above that our original network had one directed edge `(1, 2)` and two undirected edges `frozenset({1, 3})` and `frozenset({2, 3})`, while the network we de-serialised has three directed edges `(1, 2)`, `(1, 2)` and `(2, 3)` and no undirected edges.\n\nA way to solve this issue is to use a tagged union instead of the original union:\n\n```python\n# Python 3.7.4\n>>> from typing import FrozenSet, NamedTuple, Set, Tuple, Union\n>>> from typing_extensions import Literal\n>>> from typing_json import dumps, loads\n>>> DirEdgeT = Tuple[Literal[\"d\"], Tuple[int, int]]\n>>> UndirEdgeT = Tuple[Literal[\"u\"], FrozenSet[int]]\n>>> class Network(NamedTuple):\n...     nodes: Set[int]\n...     edges: Set[Union[DirEdgeT, UndirEdgeT]]\n...     @staticmethod\n...     def from_untagged(nodes: Set[int],\n...                       edges: Set[Union[Tuple[int, int], FrozenSet[int]]]) -> Network:\n...         tagged_edges = {(\"d\", e) if isinstance(e, tuple) else (\"u\", e) for e in edges}\n...         return Network(nodes, tagged_edges)\n...\n```\n\nThe factory method `from_untagged` is there to allow automated tagging of edges as directed/undirected based on their runtime type: it is not used when de-serialising the network objects from JSON.\nBecause the union is tagged, the edges are now de-serialised to the correct runtime type:\n\n```python\n# Python 3.7.4\n>>> nodes = {1, 2, 3}\n>>> edges = {(1, 2), frozenset({2, 3}), frozenset({1, 3})}\n>>> network = Network.from_untagged(nodes, edges)\n>>> print(network)\nNetwork(nodes={1, 2, 3},\n        edges={('u', frozenset({1, 3})), ('u', frozenset({2, 3})), ('d', (1, 2))})\n>>> network_serialised = dumps(network, Network)\n>>> print(network_serialised)\n{\"nodes\": [1, 2, 3], \"edges\": [[\"u\", [1, 3]], [\"u\", [2, 3]], [\"d\", [1, 2]]]}\n>>> network_deserialised = loads(network_serialised, Network)\n>>> print(network_deserialised)\nNetwork(nodes={1, 2, 3},\n        edges={('u', frozenset({1, 3})), ('u', frozenset({2, 3})), ('d', (1, 2))})\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/sg495/typing-json",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "typing-json",
    "package_url": "https://pypi.org/project/typing-json/",
    "platform": "",
    "project_url": "https://pypi.org/project/typing-json/",
    "project_urls": {
      "Homepage": "https://github.com/sg495/typing-json"
    },
    "release_url": "https://pypi.org/project/typing-json/0.1.3/",
    "requires_dist": [
      "typing-extensions"
    ],
    "requires_python": "",
    "summary": "Type-aware Python JSON serialization and validation.",
    "version": "0.1.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8914530,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3014c972d69fe1f2c30f43cb0d88ee9841766e73848f42fe4cac4b9a48460e3a",
          "md5": "f5969a71a17c5021d599938866048f51",
          "sha256": "40a1d9bd0ccbf956b7f6e4606b456d29cfd869829c1e440cfc13ad2249a0b973"
        },
        "downloads": -1,
        "filename": "typing_json-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f5969a71a17c5021d599938866048f51",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 8604,
        "upload_time": "2019-09-02T12:20:25",
        "upload_time_iso_8601": "2019-09-02T12:20:25.929878Z",
        "url": "https://files.pythonhosted.org/packages/30/14/c972d69fe1f2c30f43cb0d88ee9841766e73848f42fe4cac4b9a48460e3a/typing_json-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a98abd7eb436cc66dd9f8e7ddb1714ff7231765d46631c0775a1c44de1f682a0",
          "md5": "577247c988f6034ec023eb25af755c40",
          "sha256": "5bdd8c4e5f602e21844c4d22dbd9d3e656b57b66b767687aa06e7f8f0dbe7a47"
        },
        "downloads": -1,
        "filename": "typing-json-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "577247c988f6034ec023eb25af755c40",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 11563,
        "upload_time": "2019-09-02T12:20:28",
        "upload_time_iso_8601": "2019-09-02T12:20:28.715010Z",
        "url": "https://files.pythonhosted.org/packages/a9/8a/bd7eb436cc66dd9f8e7ddb1714ff7231765d46631c0775a1c44de1f682a0/typing-json-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ac822743b96c8f98be7c297f597ff97e95e76f16539d5b3180cbc37e77e9d055",
          "md5": "0f5a527e746940c41d3b115f2c1a4f2c",
          "sha256": "72ea7b3ee38bd7da01d6c4977338e1eb71555e2cd891afc004c042cef1df1bae"
        },
        "downloads": -1,
        "filename": "typing_json-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0f5a527e746940c41d3b115f2c1a4f2c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 8768,
        "upload_time": "2019-09-02T17:15:24",
        "upload_time_iso_8601": "2019-09-02T17:15:24.258295Z",
        "url": "https://files.pythonhosted.org/packages/ac/82/2743b96c8f98be7c297f597ff97e95e76f16539d5b3180cbc37e77e9d055/typing_json-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7e0c4688c2138ffd5c78f7606fc18012ec761b0d9771b01781a6fa3388d8e61b",
          "md5": "c28f041b0f8268123bbe1ab5190d1209",
          "sha256": "2062723e4f9268d343817899745f302fc5524d1e457c9cc16c3c727fb652adfd"
        },
        "downloads": -1,
        "filename": "typing-json-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "c28f041b0f8268123bbe1ab5190d1209",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 11649,
        "upload_time": "2019-09-02T17:15:26",
        "upload_time_iso_8601": "2019-09-02T17:15:26.140551Z",
        "url": "https://files.pythonhosted.org/packages/7e/0c/4688c2138ffd5c78f7606fc18012ec761b0d9771b01781a6fa3388d8e61b/typing-json-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ee43edddc80e62dc330c97eb27f990cd4f9b192a48e624a7680cd7a8fc3f79f6",
          "md5": "b2ee1e76366c2ae815e1c8a3f0d63787",
          "sha256": "29cdc8e28c366912a8aecd34dad4d97212383bef29b8aa784d6b283cc87fc02c"
        },
        "downloads": -1,
        "filename": "typing_json-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b2ee1e76366c2ae815e1c8a3f0d63787",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 9019,
        "upload_time": "2019-09-03T17:42:12",
        "upload_time_iso_8601": "2019-09-03T17:42:12.675188Z",
        "url": "https://files.pythonhosted.org/packages/ee/43/edddc80e62dc330c97eb27f990cd4f9b192a48e624a7680cd7a8fc3f79f6/typing_json-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2ff4553184e122fccf61257f1550732809828adb645b26a4409ab8ac3236066f",
          "md5": "3bea2e5a148fc26d573331e5c13dc4c1",
          "sha256": "9f942b345f4f9717a5659d5960d8866f74d131157945f596c6fa214ed26ee6dd"
        },
        "downloads": -1,
        "filename": "typing-json-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "3bea2e5a148fc26d573331e5c13dc4c1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 11986,
        "upload_time": "2019-09-03T17:42:14",
        "upload_time_iso_8601": "2019-09-03T17:42:14.327510Z",
        "url": "https://files.pythonhosted.org/packages/2f/f4/553184e122fccf61257f1550732809828adb645b26a4409ab8ac3236066f/typing-json-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3da8c05b4cd84250d657373f81aed9a7993f353873a266118fbd34f9376b750c",
          "md5": "7cb0112e23dfc78c80307ab8f95790ef",
          "sha256": "4b6c3f6e7a5499e80e344b21733f2e8cb6757bd8a1101dbe76572080abe214b7"
        },
        "downloads": -1,
        "filename": "typing_json-0.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7cb0112e23dfc78c80307ab8f95790ef",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 11629,
        "upload_time": "2019-09-07T15:44:31",
        "upload_time_iso_8601": "2019-09-07T15:44:31.227973Z",
        "url": "https://files.pythonhosted.org/packages/3d/a8/c05b4cd84250d657373f81aed9a7993f353873a266118fbd34f9376b750c/typing_json-0.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "116ecaf3c554a0fff2f410adea5db7483d57aa103ee05fa6382c0aafa2347e1d",
          "md5": "a1ba3096866eec3f3b76e9fce5788079",
          "sha256": "9710a42bf1e17325cca2cf1f8e85dc592cc6b160683a95fc1a84499120f5f1e3"
        },
        "downloads": -1,
        "filename": "typing-json-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "a1ba3096866eec3f3b76e9fce5788079",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15723,
        "upload_time": "2019-09-07T15:44:33",
        "upload_time_iso_8601": "2019-09-07T15:44:33.112846Z",
        "url": "https://files.pythonhosted.org/packages/11/6e/caf3c554a0fff2f410adea5db7483d57aa103ee05fa6382c0aafa2347e1d/typing-json-0.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "de3eb76dbd2ff1bf7af37574779cf955b9a85345c7b8cfcb8b00c70090cb7d34",
          "md5": "c1e1e45a8ba8907e25c7a5b71b9874fe",
          "sha256": "15d683be4be67a71f328b27285b0b1dd636ca92839e3ba87ce9726b273334750"
        },
        "downloads": -1,
        "filename": "typing_json-0.0.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c1e1e45a8ba8907e25c7a5b71b9874fe",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 11690,
        "upload_time": "2019-09-10T11:13:14",
        "upload_time_iso_8601": "2019-09-10T11:13:14.157423Z",
        "url": "https://files.pythonhosted.org/packages/de/3e/b76dbd2ff1bf7af37574779cf955b9a85345c7b8cfcb8b00c70090cb7d34/typing_json-0.0.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cd2a6e3f15464ff807a59bf9e2da940b7c31d033612e6ab072bf6e41646252c7",
          "md5": "880d49e351164072ccdfe8e5e374ff1f",
          "sha256": "b2f20a81a976470b54b6e0cfe1b5e570a42a827e74c73d20a6856b54d333438c"
        },
        "downloads": -1,
        "filename": "typing-json-0.0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "880d49e351164072ccdfe8e5e374ff1f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15899,
        "upload_time": "2019-09-10T11:13:15",
        "upload_time_iso_8601": "2019-09-10T11:13:15.889247Z",
        "url": "https://files.pythonhosted.org/packages/cd/2a/6e3f15464ff807a59bf9e2da940b7c31d033612e6ab072bf6e41646252c7/typing-json-0.0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1b083eb2de8afb6b9dd9ac9e81a951bb1767cf898186f5908fe6607973dce162",
          "md5": "b636baf3fdff51e881cbda3fe12f4431",
          "sha256": "57fbfef08f3b57de66c855c951220bf1567f3ae2317bd695209c4ff499238bbf"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b636baf3fdff51e881cbda3fe12f4431",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23666,
        "upload_time": "2020-05-22T00:44:03",
        "upload_time_iso_8601": "2020-05-22T00:44:03.036469Z",
        "url": "https://files.pythonhosted.org/packages/1b/08/3eb2de8afb6b9dd9ac9e81a951bb1767cf898186f5908fe6607973dce162/typing_json-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a499aae7dd7c0462d555ae91a7a73e13e5117f9e52df5d23593e29b914ed0561",
          "md5": "f49bf69ce82d41f3c264a825481438af",
          "sha256": "fdf26db48517d1e2a174dc2be484effd9866303c9f6e88913796a670f7e93556"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f49bf69ce82d41f3c264a825481438af",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38923,
        "upload_time": "2020-05-22T00:44:05",
        "upload_time_iso_8601": "2020-05-22T00:44:05.489899Z",
        "url": "https://files.pythonhosted.org/packages/a4/99/aae7dd7c0462d555ae91a7a73e13e5117f9e52df5d23593e29b914ed0561/typing-json-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5a466391528620d1006251ecd6a7c4c475d7f0ed5c3ac94724971b9b6575ebf9",
          "md5": "7b56f7d7ad9376e58b94bf2a70522912",
          "sha256": "7bb2baea14af16e31be67cc3c168f5653be3e93aeff0384d6c5d08ea915ff2cf"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7b56f7d7ad9376e58b94bf2a70522912",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23681,
        "upload_time": "2020-05-22T00:50:41",
        "upload_time_iso_8601": "2020-05-22T00:50:41.302665Z",
        "url": "https://files.pythonhosted.org/packages/5a/46/6391528620d1006251ecd6a7c4c475d7f0ed5c3ac94724971b9b6575ebf9/typing_json-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6fb4ec9b2649389b315c9b89468f03bf67ad3b590422dc3c69dceb760391c6ca",
          "md5": "b140eee785d95f393c3745484d7e8bfe",
          "sha256": "08018401ed164ce0accf5f7d74de062864be91cafe458275d365de74030d3e01"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b140eee785d95f393c3745484d7e8bfe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38952,
        "upload_time": "2020-05-22T00:50:43",
        "upload_time_iso_8601": "2020-05-22T00:50:43.184680Z",
        "url": "https://files.pythonhosted.org/packages/6f/b4/ec9b2649389b315c9b89468f03bf67ad3b590422dc3c69dceb760391c6ca/typing-json-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1.post1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "75413e1457d41a26d048242d8e4d30c43af7a6347eff5ca2cdd65ee81f280ba0",
          "md5": "fe3d3915e3a1822af8e2e5f971d79b50",
          "sha256": "c5537d96ae3cc086a7a970677cfa497e18868277a95cb2dc3f1e3b640d94ea5c"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.1.post1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fe3d3915e3a1822af8e2e5f971d79b50",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24075,
        "upload_time": "2020-05-22T11:13:06",
        "upload_time_iso_8601": "2020-05-22T11:13:06.300598Z",
        "url": "https://files.pythonhosted.org/packages/75/41/3e1457d41a26d048242d8e4d30c43af7a6347eff5ca2cdd65ee81f280ba0/typing_json-0.1.1.post1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aedb17464ff00f8e4d53d112a021a73d21d3e1953000bff58b33dcb5ca4ab73c",
          "md5": "58d5c49951e8eb3d309cc7b7864d4b5b",
          "sha256": "7ee83a3be46673e8b813865a65440bd4b4cbe510452c5cd149b1cf14eeb6a67e"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.1.post1.tar.gz",
        "has_sig": false,
        "md5_digest": "58d5c49951e8eb3d309cc7b7864d4b5b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39426,
        "upload_time": "2020-05-22T11:13:08",
        "upload_time_iso_8601": "2020-05-22T11:13:08.027488Z",
        "url": "https://files.pythonhosted.org/packages/ae/db/17464ff00f8e4d53d112a021a73d21d3e1953000bff58b33dcb5ca4ab73c/typing-json-0.1.1.post1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1.post2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b97210218e3db2be84b4e89f42b4be1b29fa47ffdd3b6495d22e15ea2b258e71",
          "md5": "0852f2565534acaedf9fbb24ccc96213",
          "sha256": "a1eafb4786e534b918cc2d1a2a16bd79f48d7a43b28416311d58cf15c120aeee"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.1.post2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0852f2565534acaedf9fbb24ccc96213",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24088,
        "upload_time": "2020-05-29T14:06:12",
        "upload_time_iso_8601": "2020-05-29T14:06:12.259080Z",
        "url": "https://files.pythonhosted.org/packages/b9/72/10218e3db2be84b4e89f42b4be1b29fa47ffdd3b6495d22e15ea2b258e71/typing_json-0.1.1.post2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6723be707a2167fbf2cd9c02608bcc0469ee151e5a8ab1c7214753c7cbab1a3e",
          "md5": "52a904524ec376239a91ac2671fdbc0c",
          "sha256": "cb23d696dc01abb12c1e6fee69b6044389b95dc63d89e5e8ec8f101f74373965"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.1.post2.tar.gz",
        "has_sig": false,
        "md5_digest": "52a904524ec376239a91ac2671fdbc0c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39458,
        "upload_time": "2020-05-29T14:06:15",
        "upload_time_iso_8601": "2020-05-29T14:06:15.819691Z",
        "url": "https://files.pythonhosted.org/packages/67/23/be707a2167fbf2cd9c02608bcc0469ee151e5a8ab1c7214753c7cbab1a3e/typing-json-0.1.1.post2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d938882f4ac4cec81b7e9bf1d4aff4de9cc8d15e91c1c40c639b60eea21d5efe",
          "md5": "d32c5760199970834c633a5679fe4f21",
          "sha256": "ee658980bd1cd1e7a15f355ce6cfae3aa1c289e1b5e48b2c016201336b007d7a"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d32c5760199970834c633a5679fe4f21",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24509,
        "upload_time": "2020-06-04T12:54:02",
        "upload_time_iso_8601": "2020-06-04T12:54:02.815368Z",
        "url": "https://files.pythonhosted.org/packages/d9/38/882f4ac4cec81b7e9bf1d4aff4de9cc8d15e91c1c40c639b60eea21d5efe/typing_json-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ad460a4aaa24980039fceb3433e4c87dc318f0775e6498ac2e2ca0e87f09cbed",
          "md5": "98e49f6b7b82832d137096df1398dfdc",
          "sha256": "ca459b0417f31d79075093f39d78763ce7e7a831fd56a1aa83d6f0a27f1fb8b0"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "98e49f6b7b82832d137096df1398dfdc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 40252,
        "upload_time": "2020-06-04T12:54:08",
        "upload_time_iso_8601": "2020-06-04T12:54:08.452628Z",
        "url": "https://files.pythonhosted.org/packages/ad/46/0a4aaa24980039fceb3433e4c87dc318f0775e6498ac2e2ca0e87f09cbed/typing-json-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "618e5cdfee905fe18f014353085c509122e259d3859ef384034e2e8871405d09",
          "md5": "6b8f72082bb82b8daabf6328bccfc715",
          "sha256": "615d9aabbad6e791883dca832ba85026debc83ec8cab7998e913ec1c0c6647b9"
        },
        "downloads": -1,
        "filename": "typing_json-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6b8f72082bb82b8daabf6328bccfc715",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 25497,
        "upload_time": "2020-12-16T14:54:21",
        "upload_time_iso_8601": "2020-12-16T14:54:21.343498Z",
        "url": "https://files.pythonhosted.org/packages/61/8e/5cdfee905fe18f014353085c509122e259d3859ef384034e2e8871405d09/typing_json-0.1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d1ff4735223ca8115f5b64f0077802e832ab9c64077aaa055ce68a9331c57293",
          "md5": "43f805a069917bbae0dc07cd659accb0",
          "sha256": "17292f3ec1e3c1278c4928ced52aafd37e74a57836285c4b289b97f612ea2c91"
        },
        "downloads": -1,
        "filename": "typing-json-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "43f805a069917bbae0dc07cd659accb0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 44061,
        "upload_time": "2020-12-16T14:54:28",
        "upload_time_iso_8601": "2020-12-16T14:54:28.026616Z",
        "url": "https://files.pythonhosted.org/packages/d1/ff/4735223ca8115f5b64f0077802e832ab9c64077aaa055ce68a9331c57293/typing-json-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "618e5cdfee905fe18f014353085c509122e259d3859ef384034e2e8871405d09",
        "md5": "6b8f72082bb82b8daabf6328bccfc715",
        "sha256": "615d9aabbad6e791883dca832ba85026debc83ec8cab7998e913ec1c0c6647b9"
      },
      "downloads": -1,
      "filename": "typing_json-0.1.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6b8f72082bb82b8daabf6328bccfc715",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 25497,
      "upload_time": "2020-12-16T14:54:21",
      "upload_time_iso_8601": "2020-12-16T14:54:21.343498Z",
      "url": "https://files.pythonhosted.org/packages/61/8e/5cdfee905fe18f014353085c509122e259d3859ef384034e2e8871405d09/typing_json-0.1.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d1ff4735223ca8115f5b64f0077802e832ab9c64077aaa055ce68a9331c57293",
        "md5": "43f805a069917bbae0dc07cd659accb0",
        "sha256": "17292f3ec1e3c1278c4928ced52aafd37e74a57836285c4b289b97f612ea2c91"
      },
      "downloads": -1,
      "filename": "typing-json-0.1.3.tar.gz",
      "has_sig": false,
      "md5_digest": "43f805a069917bbae0dc07cd659accb0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 44061,
      "upload_time": "2020-12-16T14:54:28",
      "upload_time_iso_8601": "2020-12-16T14:54:28.026616Z",
      "url": "https://files.pythonhosted.org/packages/d1/ff/4735223ca8115f5b64f0077802e832ab9c64077aaa055ce68a9331c57293/typing-json-0.1.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}