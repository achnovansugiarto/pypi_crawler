{
  "info": {
    "author": "Adewale Azeez",
    "author_email": "azeezadewale98@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Natural Language :: English",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Topic :: Database",
      "Topic :: Database :: Database Engines/Servers",
      "Topic :: Database :: Front-Ends"
    ],
    "description": "Light weight package to manage key value based configuration and data\nfiles.\n\nThe notable use cases of this package is loading configuration file,\nlanguage file, preference setting in an application.\n\n--------------\n\nTable of content\n----------------\n\n-  `Installation <#installation>`__\n-  `Examples <#examples>`__\n\n   -  `Basic <#basic>`__\n   -  `Write to disk <#write-to-disk>`__\n   -  `Get Types <#get-types>`__\n   -  `Lazy Loading <#lazy-loading>`__\n   -  `Seperator and delimeter <#seperator-and-delimeter>`__\n   -  `Read file with Stream <#read-file-with-stream>`__\n   -  `Read String with Stream <#read-string-with-stream>`__\n   -  `Skip Comment entries <#Skip-comment-entries>`__\n   -  `Resolve Object <#resolve-object>`__\n   -  `Dissolve Object <#dissolve-object>`__\n   -  `Multiline value <#multiline-value>`__\n\n-  `Native Object Attachement <#native-object-attachement>`__\n\n   -  `match_get_key <#matchgetkey>`__\n   -  `match_put_key <#matchputkey>`__\n\n-  `API Documentations <#api-documentations>`__\n\n   -  `KonfigerStream <#konfigerstream>`__\n   -  `Konfiger <#konfiger>`__\n\n      -  `Fields <#fields>`__\n      -  `Functions <#functions>`__\n\n-  `Usage <#usage>`__\n\n   -  `Initialization <#initialization>`__\n   -  `Inserting <#inserting>`__\n   -  `Finding <#finding>`__\n   -  `Updating <#updating>`__\n   -  `Removing <#removing>`__\n   -  `Saving to disk <#saving-to-disk>`__\n\n-  `How it works <#how-it-works>`__\n-  `Contributing <#contributing>`__\n-  `Support <#support>`__\n-  `License <#license>`__\n\nInstallation\n------------\n\nModule name on PyPi is konfiger.\n\nUsing pip:\n\n.. code:: bash\n\n   pip install konfiger\n\nInstalling from source:\n\n.. code:: bash\n\n   git clone https://github.com/konfiger/konfiger-python.git\n   cd konfiger-python\n   pip install .\n\nExamples\n--------\n\nBasic\n~~~~~\n\nThe following example load from file, add an entry, remove an entry and\niterate all the key value entries\n\n.. code:: python\n\n   from konfiger import from_file\n\n   #initialize the key-value from file\n   kon = from_file('test/test.config.ini', True)\n\n   #add a string\n   kon.put_string(\"Greet\", \"Hello World\")\n\n   #get an object\n   print(kon.get(\"Greet\"))\n\n   #remove an object\n   kon.remove(\"Greet\")\n\n   #add an String\n   kon.put_string(\"What\", \"i don't know what to write here\");\n\n   for key, value in kon.entries():\n       print('[' + key + ', ' + value + ']')\n\nWrite to disk\n~~~~~~~~~~~~~\n\nInitialize an empty konfiger object and populate it with random data,\nthen save it to a file\n\n.. code:: python\n\n   from konfiger import from_string\n   import random\n\n   random_values = [ 'One', 'Two', 'Three', 'Four', 'Five' ]\n   kon = from_string(\"\", False)\n\n   for i in range(200):\n       rand = random.randint(0, len(random_values) - 1)\n       kon.put_string(str(i), random_values[rand])\n       \n   kon.save('test/konfiger.conf')\n\nGet Types\n~~~~~~~~~\n\nLoad the entries as string and get them as a True type.\n\n.. code:: python\n\n   from konfiger import from_string\n\n   kon = from_string(\"\"\"\n   String=This is a string\n   Number=215415245\n   Float=56556.436746\n   Boolean=True\n   \"\"\", False)\n\n   str_ = kon.get_string(\"String\")\n   num_ = kon.get_long(\"Number\")\n   flo_ = kon.get_float(\"Float\")\n   bool_ = kon.get_boolean(\"Boolean\")\n\n   print(type(str_))\n   print(type(num_))\n   print(type(flo_))\n   print(type(bool_))\n\nLazy Loading\n~~~~~~~~~~~~\n\nThe lazyLoad parameter is useful for progressively read entries from a\nlarge file. The next example shows initializing from a file with so much\nkey value entry with lazy loading:\n\nThe content of ``test/konfiger.conf`` is\n\n::\n\n   Ones=11111111111\n   Twos=2222222222222\n   Threes=3333333333333\n   Fours=444444444444\n   Fives=5555555555555\n\n.. code:: python\n\n   from konfiger import from_file\n\n   kon = from_file('test/konfiger.conf', #the file pth\n                           True #lazyLoad True\n                           )\n   #at this point nothing is read from the file\n\n   #the size of konfiger is 0 even if the file contains over 1000 entries\n\n   #the key 'Twos' is at the second line in the file, therefore two entry has \n   #been read to get the value.\n   print(kon.get(\"Twos\"))\n\n   #the size becomes 2,\n\n   #to read all the entries simply call the toString() method\n   print(str(kon))\n\n   #now the size is equal to the entry\n   print(len(kon))\n\nSeperator and delimeter\n~~~~~~~~~~~~~~~~~~~~~~~\n\nInitailize a konfiger object with default seperator and delimeter then\nchange the seperator and selimeter at runtime\n\n.. code:: python\n\n   from konfiger import from_file\n\n   kon = from_file('test/konfiger.conf', False)\n   kon.set_delimeter('?')\n   kon.set_seperator(',')\n\n   print(str(kon))\n\nRead file with Stream\n~~~~~~~~~~~~~~~~~~~~~\n\nRead a key value file using the progressive\n`KonfigerStream <https://github.com/konfiger/konfiger-python/blob/master/src/konfiger_stream.py>`__,\neach scan returns the current key value array ``('key', 'value')``\n\n.. code:: python\n\n   from konfiger import file_stream\n\n   k_stream = file_stream('test/konfiger.conf')\n   while (k_stream.has_next()):\n       entry = k_stream.next()\n       print(entry)\n\nRead String with Stream\n~~~~~~~~~~~~~~~~~~~~~~~\n\nRead a key value string using the progressive\n`KonfigerStream <https://github.com/konfiger/konfiger-python/blob/master/src/konfiger_stream.py>`__,\neach scan returns the current key value array ``('key', 'value')``\n\n.. code:: python\n\n   from konfiger import string_stream\n\n   k_stream = string_stream(\"\"\"\n   String=This is a string\n   Number=215415245\n   Float=56556.436746\n   Boolean=True\n   \"\"\")\n\n   while (k_stream.has_next()):\n       entry = k_stream.next()\n       print(entry)\n\nSkip Comment entries\n~~~~~~~~~~~~~~~~~~~~\n\nRead all the key value entry using the stream and skipping all commented\nentries. The default comment prefix is ``//`` but in the example below\nthe commented entries starts with ``#`` so the prefix is changed. The\nsame thing happen if the key value entry is loaded from file.\n\n.. code:: python\n\n   from konfiger import string_stream\n\n   k_stream = string_stream(\"\"\"\n   String=This is a string\n   #Number=215415245\n   Float=56556.436746\n   #Boolean=True\n   \"\"\")\n   k_stream.set_comment_prefix(\"#\")\n\n   while (k_stream.has_next()):\n       entry = k_stream.next()\n       print(entry)\n\nResolve Object\n~~~~~~~~~~~~~~\n\nThe example below attach a python object to a konfiger object, whenever\nthe value of the konfiger object changes the attached object entries is\nalso updated.\n\nFor the file properties.conf\n\n::\n\n   project = konfiger\n   author = Adewale Azeez\n   islibrary = True\n\n.. code:: python\n\n   from konfiger import from_file\n\n   class Properties:\n       project = \"\"\n       author = \"\"\n       islibrary = False\n\n   kon = from_file('properties.conf')\n   properties = Properties()\n   kon.resolve(properties)\n\n   print(properties.project) # konfiger\n   print(properties.author) # Adewale Azeez\n   print(properties.islibrary) # True\n   kon.put(\"project\", \"konfiger-python\")\n   print(properties.project) # konfiger-python\n\nDissolve Object\n~~~~~~~~~~~~~~~\n\nThe following snippet reads the value of a python object into the\nkonfiger object, the object is not attached to konfiger unlike resolve\nfunction.\n\n.. code:: python\n\n   from konfiger import from_string\n\n   class Properties:\n       project = \"konfiger\"\n       author = \"Adewale\"\n       islibrary = True\n\n   kon = from_string('')\n   kon.dissolve(Properties())\n\n   print(kon.get(\"project\")) # konfiger\n   print(kon.get(\"author\")) # Adewale Azeez\n   print(kon.get_boolean(\"islibrary\")) # True\n\nMultiline value\n~~~~~~~~~~~~~~~\n\nKonfiger stream allow multiline value. If the line ends with ``\\`` the\nnext line will be parse as the continuation and the leading spaces will\nbe trimmed. The continuation character chan be changed like the example\nbelow the continuation character is changed from ``\\`` to ``+``.\n\nfor the file test.contd.conf\n\n::\n\n   Description = This project is the closest thing to Android +\n                 Shared Preference in other languages +\n                 and off the Android platform.\n   ProjectName = konfiger\n\n.. code:: python\n\n   from konfiger import file_stream\n\n   ks = file_stream(\"test.contd.conf\")\n   ks.set_continuation_char('+')\n   print(ks.next()[1])\n   print(ks.next()[1])\n\nNative Object Attachement\n-------------------------\n\nThis feature of the project allow seamless integration with the konfiger\nentries by eliminating the need for writing ``get*(\"\")`` everytime to\nread a value into a variable or writing lot of ``put*()`` to add an\nentry.\n\nThe two function ``resolve`` is used to attach an object. resolve\nfunction integrate the object such that the entries in konfiger will be\nassigned to the matching key in the object. See the\n`resolve <#resolve-object>`__ and `dissolve <#dissolve-object>`__\nexamples above.\n\nIn a case where the object keys are different from the entries keys in\nthe konfiger object the function ``match_get_key`` can be declared in\nthe object to match the key when setting the object entries values, and\nthe function ``match_put_key`` is called when setting the konfiger\nentries from the object.\n\nKonfiger is aware of the type of an object field, if the type of a field\nis boolean the entry value will be parsed as boolean and assigned to the\nfield.\n\nFor the file English.lang\n\n::\n\n   LoginTitle = Login Page\n   AgeInstruction = You must me 18 years or above to register\n   NewsletterOptin = Signup for our weekly news letter\n   ShouldUpdate = True\n\nFor an object which as the same key as the konfiger entries above there\nis no need to declare the match_get_key or match_put_key in the object.\nResolve example\n\n.. code:: python\n\n   from konfiger import from_file\n\n   class PageProps:\n       LoginTitle = \"\"\n       AgeInstruction = \"\"\n       NewsletterOptin = \"\"\n       ShouldUpdate = False\n\n       def __str__(self):\n           return \"LoginTitle=\" + self.LoginTitle + \",AgeInstruction=\" + self.AgeInstruction + \",NewsletterOptin=\" + self.NewsletterOptin + \",ShouldUpdate=\" + str(self.ShouldUpdate)\n\n   kon = from_file('English.lang')\n   page_props = PageProps()\n   kon.resolve(page_props)\n   print(page_props)\n\nDissolve example\n\n.. code:: python\n\n   from konfiger import from_string\n\n   class PageProps:\n       LoginTitle = \"Login Page\"\n       AgeInstruction = \"You must me 18 years or above to register\"\n       NewsletterOptin = \"Signup for our weekly news letter\"\n       ShouldUpdate = True\n\n   kon = from_string('')\n   kon.dissolve(PageProps())\n   print(str(kon))\n\nmatch_get_key\n~~~~~~~~~~~~~\n\nIf the identifier in the object keys does not match the above entries\nkey the object will not be resolved. For example loginTitle does not\nmatch LoginTitle, the match_get_key can be used to map the variable key\nto the konfiger entry key. The following example map the object key to\nkonfiger entries key.\n\n.. code:: python\n\n   from konfiger import from_file\n\n   class PageProps:\n       loginTitle = \"\"\n       ageInstruct = \"\"\n       NewsletterOptin = \"\"\n       \n       def match_get_key(self, key):\n           if key == \"loginTitle\":\n               return \"LoginTitle\"\n           elif key == \"ageInstruct\":\n               return \"AgeInstruction\"\n               \n       def __str__(self):\n           return \"loginTitle=\" + self.loginTitle + \",ageInstruct=\" + self.ageInstruct + \",NewsletterOptin=\" + self.NewsletterOptin\n\n   kon = from_file('English.lang')\n   page_props = PageProps()\n   kon.resolve(page_props)\n   print(page_props)\n\nThe way the above code snippet works is that when iterating the object\nkeys if check if the function match_get_key is present in the object if\nit is present the key is sent as parameter to the match_get_key and the\nreturned value is used to get the value from konfiger, if the\nmatch_get_key does not return anything the object key is used to get the\nvalue from konfiger (as in the case of NewsletterOptin).\n\n   During the resolve or dissolve process if the entry value is function\n   it is skipped even if it key matches\n\nFor dissolving an object the method match_get_key is invoked to find the\nactual key to use to add the entry in konfiger, if the object does not\ndeclare the match_get_key function the entries will be added to konfiger\nas it is declared. The following example similar to the one above but\ndissolves an object into konfiger.\n\n.. code:: python\n\n   from konfiger import from_string\n\n   class PageProps:\n       loginTitle = \"Login Page\"\n       ageInstruct = \"You must me 18 years or above to register\"\n       NewsletterOptin = \"Signup for our weekly news letter\"\n       \n       def match_get_key(self, key):\n           if key == \"loginTitle\":\n               return \"LoginTitle\"\n           elif key == \"ageInstruct\":\n               return \"AgeInstruction\"\n               \n       def __str__(self):\n           return \"loginTitle=\" + self.loginTitle + \",ageInstruct=\" + self.ageInstruct + \",NewsletterOptin=\" + self.NewsletterOptin\n\n   kon = from_string('')\n   kon.dissolve(PageProps())\n   print(str(kon))\n\nmatch_put_key\n~~~~~~~~~~~~~\n\nThe match_put_key is invoked when an entry value is changed or when a\nnew entry is added to konfiger. The match_put_key is invoked with the\nnew entry key and checked in the object match_put_key (if decalred), the\nreturned value is what is set in the object. E.g. if an entry\n``[Name, Thecarisma]`` is added to konfiger the object match_put_key is\ninvoked with the parameter ``Name`` the returned value is used to set\nthe corresponding object entry.\n\n.. code:: python\n\n   from konfiger import from_string\n\n   class PageProps:\n       loginTitle = \"\"\n       ageInstruct = \"\"\n       NewsletterOptin = \"\"\n       \n       def match_put_key(self, key):\n           if key == \"LoginTitle\":\n               return \"loginTitle\"\n           elif key == \"AgeInstruction\":\n               return \"ageInstruct\"\n\n   kon = from_string('')\n   page_props = PageProps()\n   kon.resolve(page_props)\n\n   kon.put(\"LoginTitle\", \"Login Page\")\n   kon.put(\"AgeInstruction\", \"You must me 18 years or above to register\")\n   kon.put(\"NewsletterOptin\", \"Signup for our weekly news letter\")\n   print(page_props.loginTitle)\n   print(page_props.ageInstruct)\n   print(page_props.NewsletterOptin)\n\nKonfiger does not create new entry in an object it just set existing\nvalues. Konfiger only change the value in an object if the key is\ndefined\n\n   Warning!!! The values resolved is not typed so if the entry initial\n   value is an integer the resolved value will be a string. All resolved\n   value is string, you will need to do the type conversion by your\n   self.\n\nIf your entry keys is the same as the object keys you don\"t need to\ndeclare the match_get_key or match_put_key function in the object.\n\nUsage\n-----\n\nInitialization\n~~~~~~~~~~~~~~\n\nThe main Konfiger contructor is not exported from the package, the two\nfunctions are exported for initialization, ``from_string`` and\n``from_file``. The from_string function creates a Konfiger object from a\nstring with valid key value entry or from empty string, the from_file\nfunction creates the Konfiger object from a file, the two functions\naccept a cumpulsory second parameter ``lazyLoad`` which indicates\nwhether to read all the entry from the file or string suring\ninitialization. The lazyLoad parameter is useful for progressively read\nentries from a large file. The two initializing functions also take 2\nextra optional parameters ``delimeter`` and ``seperator``. If the third\nand fourth parameter is not specified the default is used, delimeter =\n``=``, seperator = ``\\n``. If the file or string has different delimeter\nand seperator always send the third and fourth parameter.\n\nThe following initializer progressively read the file when needed\n\n.. code:: python\n\n   konfiger = from_file('test/konfiger.conf', True)\n\nThe following initializer read all the entries from file at once\n\n.. code:: python\n\n   konfiger = from_file('test/konfiger.conf', False)\n\nThe following initializer read all the entries from string when needed\n\n.. code:: python\n\n   konfiger = from_string(\"\"\"\n   Ones=11111111111\n   Twos=2222222222222\n   \"\"\", True)\n\nThe following initializer read all the entries from String at once\n\n.. code:: python\n\n   konfiger = from_string(\"\"\"\n   Ones=11111111111\n   Twos=2222222222222\n   \"\"\", False)\n\nInitialize a string which have custom delimeter and seperator\n\n.. code:: python\n\n   konfiger = from_string(\"\"\"Ones:11111111111,Twos:2222222222222\"\"\", \n                                   False, \n                                   ':',\n                                   ',')\n\nInserting\n~~~~~~~~~\n\nThe following types can be added into the object, int, float, long,\nboolean, object and string.\n\nTo add any object into the entry use the ``put`` method as it check the\nvalue type and properly get it string value\n\n.. code:: python\n\n   konfiger.put(\"String\", \"This is a string\")\n   konfiger.put(\"Long\", 143431423)\n   konfiger.put(\"Boolean\", True)\n   konfiger.put(\"Float\", 12.345)\n\nThe ``put`` method do a type check on the value and calls the\nappropriate put method e.g ``konfiger.put(\"Boolean\", True)`` will result\nin a call to ``konfiger.put_boolean(\"Boolean\", True)``. The following\nmethod are avaliable to directly add the value according to the type,\n``put_string``, ``put_boolean``, ``put_long`` and ``putInt``. The\nprevious example can be re-written as:\n\n.. code:: python\n\n   konfiger.put_string(\"String\", \"This is a string\")\n   konfiger.put_long(\"Long\", 143431423)\n   konfiger.put_boolean(\"Boolean\", True)\n   konfiger.put_float(\"Float\", 12.345)\n\nFinding\n~~~~~~~\n\nThere are various ways to get the value from the konfiger object, the\nmain ``get`` method and ``get_string`` method both returns a string\ntype, the other get methods returns specific types\n\n.. code:: python\n\n   konfiger.get(\"String\")\n\nTo get specific type from the object use the following methods,\n``get_string``, ``get_boolean``, ``get_long``, ``get_float`` and\n``getInt``.\n\n.. code:: python\n\n   konfiger.get_string(\"String\")\n   konfiger.get_long(\"Long\")\n   konfiger.get_boolean(\"Boolean\")\n   konfiger.get_float(\"Float\")\n\nIf the requested entrr does not exist a null/undefined value is\nreturned, to prevent that a fallback value should be sent as second\nparameter incase the key is not found the second parameter will be\nreturned.\n\n.. code:: python\n\n   konfiger.get(\"String\", \"Default Value\")\n   konfiger.get_boolean(\"Boolean\", False)\n\nIf the konfiger is initialized with lazy loading enabled if the get\nmethod is called the stream will start reading until the key is found\nand the stream is paused again, if the key is not found the stream will\nread to end.\n\nUpdating\n~~~~~~~~\n\nThe ``put`` method can be used to add new entry or to update an already\nexisting entry in the object. The ``update_at`` method is usefull for\nupdating a value using it index instead of key\n\n.. code:: python\n\n   konfiger.update_at(0, \"This is an updated string\")\n\nRemoving\n~~~~~~~~\n\nThe ``remove`` method removes a key value entry from the konfiger, it\nreturns True if an entry is removed and False if no entry is removed.\nThe ``remove`` method accept either key(string) or index(int) of the\nentry.\n\n.. code:: python\n\n   konfiger.remove(\"String\")\n   konfiger.remove(0)\n\nSaving to disk\n~~~~~~~~~~~~~~\n\nEvery operation on the konfiger object is done in memory to save the\nupdated entries in a file call the ``save`` method with the file path to\nsave the entry. If the konfiger is initiated from file then there is no\nneed to add the file path to the ``save`` method, the entries will be\nsaved to the file path used during initialization.\n\n.. code:: python\n\n   konfiger.save(\"test/test.config.ini\")\n\nin case of load from file, the save will write the entries to\n*test/test.config.ini*.\n\n.. code:: python\n\n   #...\n   var konfiger = from_file('test/test.config.ini', True)\n   #...\n   konfiger.save()\n\nAPI Documentations\n------------------\n\nEven though python is weakly type the package does type checking to\nensure wrong datatype is not passed into the functions.\n\nKonfigerStream\n~~~~~~~~~~~~~~\n\n+-------------------------------------+--------------------------------+\n| Function                            | Description                    |\n+=====================================+================================+\n| def file_stream(file_path,          | Initialize a new               |\n| delimeter = \"=\", seperator =        | KonfigerStream object from the |\n| \"\\n\", err_tolerance =               | filePath. It throws en         |\n| False)                              | exception if the filePath does |\n|                                     | not exist or if the delimeter  |\n|                                     | or seperator is not a single   |\n|                                     | character. The last parameter  |\n|                                     | is boolean if True the stream  |\n|                                     | is error tolerant and does not |\n|                                     | throw any exception on invalid |\n|                                     | entry, only the first          |\n|                                     | parameter is cumpulsory.       |\n+-------------------------------------+--------------------------------+\n| def string_stream(raw_string,       | Initialize a new               |\n| delimeter = \"=\", seperator =        | KonfigerStream object from a   |\n| \"\\n\", err_tolerance =               | string. It throws en exception |\n| False)                              | if the rawString is not a      |\n|                                     | string or if the delimeter or  |\n|                                     | seperator is not a single      |\n|                                     | character. The last parameter  |\n|                                     | is boolean if True the stream  |\n|                                     | is error tolerant and does not |\n|                                     | throw any exception on invalid |\n|                                     | entry, only the first          |\n|                                     | parameter is cumpulsory.       |\n+-------------------------------------+--------------------------------+\n| def has_next(self)                  | Check if the KonfigerStream    |\n|                                     | still has a key value entry,   |\n|                                     | returns True if there is still |\n|                                     | entry, returns False if there  |\n|                                     | is no more entry in the        |\n|                                     | KonfigerStream                 |\n+-------------------------------------+--------------------------------+\n| def next(self)                      | Get the next Key Value array   |\n|                                     | from the KonfigerStream is it  |\n|                                     | still has an entry. Throws an  |\n|                                     | error if there is no more      |\n|                                     | entry. Always use              |\n|                                     | ``has_next()`` to check if     |\n|                                     | there is still an entry in the |\n|                                     | stream.                        |\n+-------------------------------------+--------------------------------+\n| def is_trimming_key(self)           | Check if the stream is         |\n|                                     | configured to trim key, True   |\n|                                     | by default                     |\n+-------------------------------------+--------------------------------+\n| def set_trimming_key(self,          | Change the stream to           |\n| trimming_key)                       | enable/disable key trimming    |\n+-------------------------------------+--------------------------------+\n| def is_trimming_value(self)         | Check if the stream is         |\n|                                     | configured to trim entry       |\n|                                     | value, True by default         |\n+-------------------------------------+--------------------------------+\n| def set_trimming_value(self,        | Change the stream to           |\n| trimming_value)                     | enable/disable entry value     |\n|                                     | trimming                       |\n+-------------------------------------+--------------------------------+\n| def get_comment_prefix(self)        | Get the prefix string that     |\n|                                     | indicate a pair entry if       |\n|                                     | commented                      |\n+-------------------------------------+--------------------------------+\n| def set_comment_prefix(self,        | Change the stream comment      |\n| comment_prefix)                     | prefix, any entry starting     |\n|                                     | with the comment prefix will   |\n|                                     | be skipped. Comment in         |\n|                                     | KonfigerStream is relative to  |\n|                                     | the key value entry and not    |\n|                                     | relative to a line.            |\n+-------------------------------------+--------------------------------+\n| def set_continuation_char(self,     | Set the character that         |\n| continuation_char)                  | indicates to the stream to     |\n|                                     | continue reading for the entry |\n|                                     | value on the next line. The    |\n|                                     | follwoing line leading spaces  |\n|                                     | is trimmed. The default is     |\n|                                     | ``\\``                          |\n+-------------------------------------+--------------------------------+\n| def get_continuation_char(self)     | Get the continuation character |\n|                                     | used in the stream.            |\n+-------------------------------------+--------------------------------+\n| def                                 | Validate the existence of the  |\n| validate_file_existence(file_path)  | specified file path if it does |\n|                                     | not exist an exception is      |\n|                                     | thrown                         |\n+-------------------------------------+--------------------------------+\n| def error_tolerance(self,           | Enable or disable the error    |\n| err_tolerance)                      | tolerancy property of the      |\n|                                     | konfiger, if enabled no        |\n|                                     | exception will be throw even   |\n|                                     | when it suppose to there for   |\n|                                     | it a bad idea but useful in a  |\n|                                     | fail safe environment.         |\n+-------------------------------------+--------------------------------+\n| def is_error_tolerant(self)         | Check if the konfiger object   |\n|                                     | errTolerance is set to True.   |\n+-------------------------------------+--------------------------------+\n\nKonfiger\n~~~~~~~~\n\nFields\n^^^^^^\n\n=================== ===================================================\nField               Description\n=================== ===================================================\nGLOBAL_MAX_CAPACITY The number of datas the konfiger can take, 10000000\n=================== ===================================================\n\nFunctions\n^^^^^^^^^\n\n+-------------------------------------+--------------------------------+\n| Function                            | Description                    |\n+=====================================+================================+\n| def from_file(file_path,            | Create the konfiger object     |\n| lazy_load=True, delimeter=\"=\",      | from a file, the first(string) |\n| seperator=\"\\n\")                     | parameter is the file path,    |\n|                                     | the second parameter(boolean)  |\n|                                     | indicates whether to read all  |\n|                                     | the entry in the file in the   |\n|                                     | constructor or when needed,    |\n|                                     | the third param(char) is the   |\n|                                     | delimeter and the fourth       |\n|                                     | param(char) is the seperator.  |\n|                                     | This creates the konfiger      |\n|                                     | object from call to            |\n|                                     | ``fromStre                     |\n|                                     | am(konfigerStream, lazyLoad)`` |\n|                                     | with the konfigerStream        |\n|                                     | initialized with the filePath  |\n|                                     | parameter. The new Konfiger    |\n|                                     | object is returned.            |\n+-------------------------------------+--------------------------------+\n| def from_string(raw_string,         | Create the konfiger object     |\n| lazy_load=True, delimeter=\"=\",      | from a string, the first       |\n| seperator=\"\\n\")                     | parameter is the String(can be |\n|                                     | empty), the second boolean     |\n|                                     | parameter indicates whether to |\n|                                     | read all the entry in the file |\n|                                     | in the constructor or when     |\n|                                     | needed, the third param is the |\n|                                     | delimeter and the fourth param |\n|                                     | is the seperator. The new      |\n|                                     | Konfiger object is returned.   |\n+-------------------------------------+--------------------------------+\n| def from_stream(konfiger_stream,    | Create the konfiger object     |\n| lazy_load=True)                     | from a KonfigerStream object,  |\n|                                     | the second boolean parameter   |\n|                                     | indicates whether to read all  |\n|                                     | the entry in the file in the   |\n|                                     | constructor or when needed     |\n|                                     | this make data loading         |\n|                                     | progressive as data is only    |\n|                                     | loaded from the file when put  |\n|                                     | or get until the Stream        |\n|                                     | reaches EOF. The new Konfiger  |\n|                                     | object is returned.            |\n+-------------------------------------+--------------------------------+\n| def put(self, key, value)           | Put any object into the        |\n|                                     | konfiger. if the second        |\n|                                     | parameter is a python Object,  |\n|                                     | ``JSON.stringify`` will be     |\n|                                     | used to get the string value   |\n|                                     | of the object else the         |\n|                                     | appropriate put\\* method will  |\n|                                     | be called. e.g                 |\n|                                     | ``put('Name', 'Adewale')``     |\n|                                     | will result in the call        |\n|                                     | ``pu                           |\n|                                     | t_string('Name', 'Adewale')``. |\n+-------------------------------------+--------------------------------+\n| def put_string(self, key, value)    | Put a String into the          |\n|                                     | konfiger, the second parameter |\n|                                     | must be a string.              |\n+-------------------------------------+--------------------------------+\n| def put_boolean(self, key, value)   | Put a Boolean into the         |\n|                                     | konfiger, the second parameter |\n|                                     | must be a Boolean.             |\n+-------------------------------------+--------------------------------+\n| def put_long(self, key, value)      | Put a Long into the konfiger,  |\n|                                     | the second parameter must be a |\n|                                     | Number.                        |\n+-------------------------------------+--------------------------------+\n| def put_int(self, key, value)       | Put a Int into the konfiger,   |\n|                                     | alias for                      |\n|                                     | ``put_long(self, key, value)``.|\n+-------------------------------------+--------------------------------+\n| def put_float(self, key, value)     | Put a Float into the konfiger, |\n|                                     | the second parameter must be a |\n|                                     | Float                          |\n+-------------------------------------+--------------------------------+\n| def put_double(self, key, value)    | Put a Double into the          |\n|                                     | konfiger, the second parameter |\n|                                     | must be a Double               |\n+-------------------------------------+--------------------------------+\n| def put_comment(self, the_comment)  | Put a literal comment into the |\n|                                     | konfiger, it simply add the    |\n|                                     | comment prefix as key and      |\n|                                     | value to the entries           |\n|                                     | e.g ``ko                       |\n|                                     | n.put_comment(\"Hello World\")`` |\n|                                     | add the entry                  |\n|                                     | ``//:Hello World``             |\n+-------------------------------------+--------------------------------+\n| def keys(self)                      | Get all the keys entries in    |\n|                                     | the konfiger object in         |\n|                                     | iterable array list            |\n+-------------------------------------+--------------------------------+\n| def values(self)                    | Get all the values entries in  |\n|                                     | the konfiger object in         |\n|                                     | iterable array list            |\n+-------------------------------------+--------------------------------+\n| def entries(self)                   | Get all the entries in the     |\n|                                     | konfiger in a                  |\n|                                     | ``[['Key', 'Value'], ...]``    |\n+-------------------------------------+--------------------------------+\n| def get(self, key,                  | Get a value as string, the     |\n| default_value=None)                 | second parameter is optional   |\n|                                     | if it is specified it is       |\n|                                     | returned if the key does not   |\n|                                     | exist, if the second parameter |\n|                                     | is not specified ``undefined`` |\n|                                     | will be returned               |\n+-------------------------------------+--------------------------------+\n| def get_string(self, key,           | Get a value as string, the     |\n| default_value=\"\")                   | second(string) parameter is    |\n|                                     | optional if it is specified it |\n|                                     | is returned if the key does    |\n|                                     | not exist, if the second       |\n|                                     | parameter is not specified     |\n|                                     | empty string will be returned. |\n+-------------------------------------+--------------------------------+\n| def get_boolean(self, key,          | Get a value as boolean, the    |\n| default_value=False)                | second(Boolean) parameter is   |\n|                                     | optional if it is specified it |\n|                                     | is returned if the key does    |\n|                                     | not exist, if the second       |\n|                                     | parameter is not specified     |\n|                                     | ``False`` will be returned.    |\n|                                     | When trying to cast the value  |\n|                                     | to boolean if an error occur   |\n|                                     | an exception will be thrown    |\n|                                     | except if error tolerance is   |\n|                                     | set to True then False will be |\n|                                     | returned.                      |\n+-------------------------------------+--------------------------------+\n| def get_long(self, key,             | Get a value as Number, the     |\n| default_value=0)                    | second(Number) parameter is    |\n|                                     | optional if it is specified it |\n|                                     | is returned if the key does    |\n|                                     | not exist, if the second       |\n|                                     | parameter is not specified     |\n|                                     | ``0`` will be returned. When   |\n|                                     | trying to cast the value to    |\n|                                     | Number if an error occur an    |\n|                                     | exception will be thrown       |\n|                                     | except if error tolerance is   |\n|                                     | set to True then ``0`` will be |\n|                                     | returned.                      |\n+-------------------------------------+--------------------------------+\n| def get_int(self, key,              | Get a value as Number, alias   |\n| default_value=0)                    | for                            |\n|                                     | ``def                          |\n|                                     | get_long(key, defaultValue)``. |\n+-------------------------------------+--------------------------------+\n| def get_float(self, key,            | Get a value as Float, the      |\n| default_value=0.0)                  | second(Float) parameter is     |\n|                                     | optional if it is specified it |\n|                                     | is returned if the key does    |\n|                                     | not exist, if the second       |\n|                                     | parameter is not specified     |\n|                                     | ``0.0`` will be returned. When |\n|                                     | trying to cast the value to    |\n|                                     | Float if an error occur an     |\n|                                     | exception will be thrown       |\n|                                     | except if error tolerance is   |\n|                                     | set to True then ``0.0`` will  |\n|                                     | be returned.                   |\n+-------------------------------------+--------------------------------+\n| def get_double(self, key,           | Get a value as Double, the     |\n| default_value=0.0)                  | second(Double) parameter is    |\n|                                     | optional if it is specified it |\n|                                     | is returned if the key does    |\n|                                     | not exist, if the second       |\n|                                     | parameter is not specified     |\n|                                     | ``0.0`` will be returned. When |\n|                                     | trying to cast the value to    |\n|                                     | Double if an error occur an    |\n|                                     | exception will be thrown       |\n|                                     | except if error tolerance is   |\n|                                     | set to True then ``0.0`` will  |\n|                                     | be returned.                   |\n+-------------------------------------+--------------------------------+\n| def remove(self, key_index)         | Remove a key value entry at a  |\n|                                     | particular index. Returns the  |\n|                                     | value of the entry that was    |\n|                                     | removed.                       |\n+-------------------------------------+--------------------------------+\n| def remove(self, key_index)         | Remove a key value entry using |\n|                                     | the entry Key. Returns the     |\n|                                     | value of the entry that was    |\n|                                     | removed.                       |\n+-------------------------------------+--------------------------------+\n| def append_string(self, raw_string, | Append new data to the         |\n| delimeter=None, seperator=None)     | konfiger from a string. If the |\n|                                     | Konfiger is initialized with   |\n|                                     | lazy loading all the data will |\n|                                     | be loaded before the entries   |\n|                                     | from the new string is added.  |\n+-------------------------------------+--------------------------------+\n| def append_file(self, file_path,    | Read new datas from the file   |\n| delimeter=None, seperator=None)     | path and append. If the        |\n|                                     | Konfiger is initialized with   |\n|                                     | lazy loading all the data will |\n|                                     | be loaded before the entries   |\n|                                     | from the new string is added.  |\n+-------------------------------------+--------------------------------+\n| def save(self, file_path=None)      | Save the konfiger datas into a |\n|                                     | file. The argument filePath is |\n|                                     | optional if specified the      |\n|                                     | entries is writtent to the     |\n|                                     | filePath else the filePath     |\n|                                     | used to initialize the         |\n|                                     | Konfiger object is used and if |\n|                                     | the Konfiger is initialized    |\n|                                     | ``from_string`` and the        |\n|                                     | filePath is not specified an   |\n|                                     | exception is thrown. This does |\n|                                     | not clear the already added    |\n|                                     | entries.                       |\n+-------------------------------------+--------------------------------+\n| def get_seperator(self)             | Get seperator char that        |\n|                                     | seperate the key value entry,  |\n|                                     | default is ``\\n``.             |\n+-------------------------------------+--------------------------------+\n| def get_delimeter(self)             | Get delimeter char that        |\n|                                     | seperated the key from it      |\n|                                     | value, default is ``=``.       |\n+-------------------------------------+--------------------------------+\n| def set_seperator(self, seperator)  | Change seperator char that     |\n|                                     | seperate the datas, note that  |\n|                                     | the file is not updates, to    |\n|                                     | change the file call the       |\n|                                     | ``save()`` function. If the    |\n|                                     | new seperator is different     |\n|                                     | from the old one all the       |\n|                                     | entries values will be re      |\n|                                     | parsed to get the new proper   |\n|                                     | values, this process can take  |\n|                                     | time if the entries is much.   |\n+-------------------------------------+--------------------------------+\n| def set_delimeter(self, delimeter)  | Change delimeter char that     |\n|                                     | seperated the key from object, |\n|                                     | note that the file is not      |\n|                                     | updates, to change the file    |\n|                                     | call the ``save()`` function   |\n+-------------------------------------+--------------------------------+\n| def set_case_sensitivity(self,      | change the case sensitivity of |\n| case_sensitive)                     | the konfiger object, if True   |\n|                                     | ``get(\"Key\")`` and             |\n|                                     | ``get(\"key\")`` will return     |\n|                                     | different value, if False same |\n|                                     | value will be returned.        |\n+-------------------------------------+--------------------------------+\n| def is_case_sensitive(self)         | Return True if the konfiger    |\n|                                     | object is case sensitive and   |\n|                                     | False if it not case sensitive |\n+-------------------------------------+--------------------------------+\n| def ``__len__``\\ (self)             | Get the total size of key      |\n|                                     | value entries in the konfiger  |\n+-------------------------------------+--------------------------------+\n| def clear(self)                     | clear all the key value        |\n|                                     | entries in the konfiger. This  |\n|                                     | does not update the file call  |\n|                                     | the ``save`` method to update  |\n|                                     | the file                       |\n+-------------------------------------+--------------------------------+\n| def is_empty(self)                  | Check if the konfiger does not |\n|                                     | have an key value entry.       |\n+-------------------------------------+--------------------------------+\n| void update_at(index, value)        | Update the value at the        |\n|                                     | specified index with the new   |\n|                                     | string value, throws an error  |\n|                                     | if the index is OutOfRange     |\n+-------------------------------------+--------------------------------+\n| def contains(self, key)             | Check if the konfiger contains |\n|                                     | a key                          |\n+-------------------------------------+--------------------------------+\n| def enable_cache(self,              | Enable or disable caching,     |\n| enable_cache _)                     | caching speeds up data search  |\n|                                     | but can take up space in       |\n|                                     | memory (very small though).    |\n|                                     | Using ``get_string`` method to |\n|                                     | fetch vallue **99999999999**   |\n|                                     | times with cache disabled      |\n|                                     | takes over 1hr and with cache  |\n|                                     | enabled takes 20min.           |\n+-------------------------------------+--------------------------------+\n| def ``__str__``\\ (self)             | All the kofiger datas are      |\n|                                     | parsed into valid string with  |\n|                                     | regards to the delimeter and   |\n|                                     | seprator, the result of this   |\n|                                     | method is what get written to  |\n|                                     | file in the ``save`` method.   |\n|                                     | The result is cached and       |\n|                                     | calling the method while the   |\n|                                     | no entry is added, deleted or  |\n|                                     | updated just return the last   |\n|                                     | result instead of parsing the  |\n|                                     | entries again.                 |\n+-------------------------------------+--------------------------------+\n| def resolve(self, obj)              | Attach an object to konfiger,  |\n|                                     | on attachment the values of    |\n|                                     | the entries in the object will |\n|                                     | be set to the coresponding     |\n|                                     | value in konfiger. The object  |\n|                                     | can have the ``match_get_key`` |\n|                                     | function which is called with  |\n|                                     | a key in konfiger to get the   |\n|                                     | value to map to the entry and  |\n|                                     | the function ``match_put_key`` |\n|                                     | to check which value to fetch  |\n|                                     | from the object to put into    |\n|                                     | konfiger.                      |\n+-------------------------------------+--------------------------------+\n| def dissolve(self, obj)             | Each string fields in the      |\n|                                     | object will be put into        |\n|                                     | konfiger. The object can have  |\n|                                     | the ``match_get_key`` function |\n|                                     | which is called with a key in  |\n|                                     | konfiger to get the value to   |\n|                                     | map to the entry. This does    |\n|                                     | not attach the object.         |\n+-------------------------------------+--------------------------------+\n| def attach(self, obj)               | Attach an object to konfiger   |\n|                                     | without dissolving it field    |\n|                                     | into konfiger or setting it    |\n|                                     | fields to a matching konfiger  |\n|                                     | entry. Use this if the values  |\n|                                     | in an object is to be left     |\n|                                     | intact but updated if a        |\n|                                     | matching entry in konfiger     |\n|                                     | changes.                       |\n+-------------------------------------+--------------------------------+\n| def detach(self)                    | Detach the object attached to  |\n|                                     | konfiger when the resolve      |\n|                                     | function is called. The        |\n|                                     | detached object is returned.   |\n+-------------------------------------+--------------------------------+\n\nHow it works\n------------\n\nKonfiger stream progressively load the key value entry from a file or\nstring when needed, it uses two method ``has_next`` which check if there\nis still an entry in the stream and ``next`` for the current key value\nentry in the stream.\n\nIn Konfiger the key value pair is stored in a ``map``, all search\nupdating and removal is done on the ``konfiger_objects`` in the class.\nThe string sent as first parameter if parsed into valid key value using\nthe separator and delimiter fields and if loaded from file it content is\nparsed into valid key value pair. The ``toString`` method also parse the\n``konfiger_objects`` content into a valid string with regards to the\nseparator and delimeter. The value is properly escaped and unescaped.\n\nThe ``save`` function write the current ``Konfiger`` to the file, if the\nfile does not exist it is created if it can. Everything is written in\nmemory and is disposed on app exit hence it important to call the\n``save`` function when nessasary.\n\nContributing\n------------\n\nBefore you begin contribution please read the contribution guide at\n`CONTRIBUTING\nGUIDE <https://github.com/konfiger/konfiger.github.io/blob/master/CONTRIBUTING.MD>`__\n\nYou can open issue or file a request that only address problems in this\nimplementation on this repo, if the issue address the concepts of the\npackage then create an issue or rfc\n`here <https://github.com/konfiger/konfiger.github.io/>`__\n\nSupport\n-------\n\nYou can support some of this community as they make big impact in the\ntraining of individual to get started with software engineering and open\nsource contribution.\n\n-  https://www.patreon.com/devcareer\n\nLicense\n-------\n\nMIT License Copyright (c) 2020 `Adewale\nAzeez <https://twitter.com/iamthecarisma>`__ - konfiger",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://konfiger.github.io/konfiger-python",
    "keywords": "key-value,database,python,package,thecarisma,quick,simple,dictionary",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "konfiger",
    "package_url": "https://pypi.org/project/konfiger/",
    "platform": "any",
    "project_url": "https://pypi.org/project/konfiger/",
    "project_urls": {
      "Homepage": "https://konfiger.github.io/konfiger-python"
    },
    "release_url": "https://pypi.org/project/konfiger/1.2.4/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Light weight package to manage key value based configuration and data files for Python",
    "version": "1.2.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8018532,
  "releases": {
    "1.2.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "22b557627594f9b7b0855538d8fce076891d170278b50e8124f467b41d1da732",
          "md5": "e7aadc207469f42a1a18f0e0b122fea2",
          "sha256": "73b56e99aa01c02f6622da30a5338ceb79e67ee1e03f685ff6168c7c27437a9e"
        },
        "downloads": -1,
        "filename": "konfiger-1.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "e7aadc207469f42a1a18f0e0b122fea2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 43150,
        "upload_time": "2020-08-22T17:34:47",
        "upload_time_iso_8601": "2020-08-22T17:34:47.763757Z",
        "url": "https://files.pythonhosted.org/packages/22/b5/57627594f9b7b0855538d8fce076891d170278b50e8124f467b41d1da732/konfiger-1.2.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "22b557627594f9b7b0855538d8fce076891d170278b50e8124f467b41d1da732",
        "md5": "e7aadc207469f42a1a18f0e0b122fea2",
        "sha256": "73b56e99aa01c02f6622da30a5338ceb79e67ee1e03f685ff6168c7c27437a9e"
      },
      "downloads": -1,
      "filename": "konfiger-1.2.4.tar.gz",
      "has_sig": false,
      "md5_digest": "e7aadc207469f42a1a18f0e0b122fea2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 43150,
      "upload_time": "2020-08-22T17:34:47",
      "upload_time_iso_8601": "2020-08-22T17:34:47.763757Z",
      "url": "https://files.pythonhosted.org/packages/22/b5/57627594f9b7b0855538d8fce076891d170278b50e8124f467b41d1da732/konfiger-1.2.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}