{
  "info": {
    "author": "Charles Tolley",
    "author_email": "charlestolley@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Natural Language :: English",
      "Programming Language :: Python :: 3 :: Only",
      "Topic :: Internet :: WWW/HTTP :: WSGI :: Application",
      "Topic :: Software Development :: Libraries :: Application Frameworks"
    ],
    "description": "# Overview\nThere are a lot of web frameworks for Python: Django, CherryPy, Flask, and a bunch more that I'm not familiar with. However, if you are just looking to create a JSON-based REST API, these frameworks seem like overkill, and are not really convenient for designing anything other than dynamic web pages. This framework is meant to act as a minimally-invasive adapter for the Web Server Gateway Interface (WSGI), which is the Python standard for interacting with web servers. My original intention was simply to familiarize myself with the details of WSGI, and create a basic framework that I could keep in my back pocket to use on future projects, but I see no reason not to publish it as an open-source project. As of this writing, I have not used it for any serious projects, so it is altogether possible that it is missing major features. As such, I welcome constructive feedback about how it falls short, and suggestions for improvements.\n\nThis framework is written for Python 3; I do not intend to support Python 2. I personally use Linux for basically everything, and I know nothing about programming in Windows. I don't see any reason this framework would not work in Windows, and I am not opposed to making it Windows-friendly, but to date I have not tried it in Windows.\n\n### Usage\nThe module-level `__init__.py` file only defines a handful of types: `API`, `HttpError`, `HttpRequest`, and `HttpResponse`.\n\nUnlike many popular frameworks, which provide built-in web servers, if only for debugging use, this framework requires you to bring your own web server. The `API` class implements the client-side WSGI specification, meaning it should be compatible with most of the popular web servers: Apache using mod\\_wsgi, Gunicorn, CherryPy, Nginx with uWSGI, and, again, probably a bunch more that I'm not familiar with. Each of these has its own documentation on how to set up a WSGI server. The example given later will demonstrate how to run the API framework with a CherryPy web server.\n\n#### Defining Endpoints\nThe `API` class only has two functions that are intended for public use: `endpoint()`, and `wsgi()`. The latter allows you to register other WSGI applications as a sub-tree of your resource (URI) structure, and is called simply by providing the path string and the application object.\n\n    application = restapi.API()\n    application.wsgi(\"/path/for/other/application\", other_application)\n\nThe `endpoint()` function has a similar signature, but instead of providing a WSGI application, the second argument is a class to handle all requests for that path. When the `API` receives a request, it will create an instance of the appropriate endpoint class, and then call the method corresponding to the type of request. Only four HTTP methods are currently allowed: GET, POST, PUT, and DELETE. For each method an endpoint class wishes to support, it should define a method of the same name, but in lowercase. For example, if an endpoint class wishes to support the HTTP GET method, it should define a function called `get()`. Each of these methods should expect a single argument (aside from `self`), which will be an `HttpRequest` object. The return value should be a JSON-encodable object (assuming you do not override the `API`'s encoder), in which case the response code will be given as 200, or else you can return an `HttpResponse` object, which allows you to use any response code, and/or return custom HTTP headers. Don't try to return `Content-Length` or `Content-Type`; those are handled by the `API`.\n\nThe `HttpError` class allows you to return error messages using Python's built-in exception mechanism. You can provide a status code, as well as an optional message. If you don't provide a message, the default message for the status code will be used. For example, if someone asks your server to brew it some coffee, just give 'em one of these:\n\n    raise HttpError(418, \"I'm a teapot\")\n\nThe response will look like this\n\n    HTTP/1.1 418\n    Content-Length:44\n    Content-Type: application/json\n    # other headers from your web server\n\n    {\"message\":\"I'm a teapot\",\"status_code\":418}\n\nIf your code throws an exception somewhere and you don't handle it, it will trigger a 500 Internal Server Error response, and log a stack trace (if you have the Python `logging` module enabled).\n\nThe API does support the use of path variables by enclosing the variable name in angle brackets like so:\n\n    application.endpoint(\"/resources/<id>\", Resource)\n\nPath variables are used as keyword arguments to the constructor of the endpoint class. The values are always given as strings. For the example above, the `Resource` class would look something like this:\n\n    class Resource:\n        def __init__ (self, id):\n            self.id = id\n\n        # other methods and stuff\n\nAs mentioned previously, the methods of the endpoint class (e.g. the `get()` method, for an HTTP GET) should expect a single argument of type `HttpRequest`. The `HttpRequest` class is a simple container for the request body (if any), the request headers, and the query string. The body (attribute name `body`) is either the JSON object (assuming you do not override the `API`'s decoder) provided in the request body, or `None`.  The headers (attribute name `headers`) are held in a `dict`. Note that, owing to the way the WSGI interface handles headers, any capitalization used by the client will be clobbered, and all headers will use a `Caplitalized-Dashed` format. This is only the case for incoming headers, meaning you may use whatever capitalization you like for the headers you provide to the `HttpResponse` object. The query string (attribute name `query`) is just the portion of the URL after the question mark, and is not handled or decoded in any special way.\n\n#### Customization\nThe `API` object has three additional attributes that you may customize as needed. The first is the `handler` attribute, which formats an `HttpError` into an `HttpResponse` You may replace the default handler with your own object. The only requirement for this object is to provide a `handle()` function that accepts a single argument (which will be an `HttpError` object), and returns an `HttpResponse` object. The attributes of `HttpError` are called `code` and `message`. The `HttpResponse` constructor looks like this:\n\n    class HttpResponse:\n        __init__ (self, body, code=200, headers={}):\n            # implementation\n\nYou may also replace the `encoder` and `decoder` attributes. The encoder is used for converting the response body object into a string. It has two requirements: it must have a `content_type` attribute with a valid `Content-Type` string value, and it must define an `encode()` function, which takes a single argument (the object to encode), and returns a string. The decoder must also define a `content_type` attribute, as well as a `decode()` function. This function takes a string as its only argument, and either returns the decoded object, or raises a 400 error. `decode()` will only be called with a non-empty string as the argument, as the `API` automatically uses `None` to represent an empty request body.\n\nPerhaps you will notice that this encoder-decoder setup only allows one content type. That's correct. As mentioned before, I have not used my own framework for any real projects, so I don't yet know whether this shortcoming is of any real consequence. I welcome feedback from anyone who views this as a major handicap.\n\n#### Example API with CherryPy Server\n###### Server\n\n    import restapi\n\n    class Hello:\n        def __init__ (self, first=\"World\", last=None):\n            self.first = first\n            self.last = last\n\n        def get (self, request):\n            if self.last is not None:\n                name = \" \".join((self.first.capitalize(), self.last.capitalize()))\n            else:\n                name = self.first\n\n            return {\"message\": \"Hello {}!\".format(name)}\n\n    class Collection:\n        def post (self, request):\n            # save to a database or something\n            # ...\n            return restapi.HttpResponse(request.body, 201)\n\n    if __name__ == '__main__':\n        application = restapi.API()\n        application.endpoint(\"/hello/world\", Hello)\n        application.endpoint(\"/hello/<first>/<last>\", Hello)\n        application.endpoint(\"/items\", Collection)\n\n        import cherrypy\n        cherrypy.tree.graft(application, \"/\")\n        cherrypy.engine.start()\n        cherrypy.engine.block()\n\n###### Client\n\n    if __name__ == '__main__':\n        import requests\n        print(requests.get(\"http://localhost:8080/hello/world\").json())\n        print(requests.get(\"http://localhost:8080/hello/full/name\").json())\n\n        r = requests.post(\"http://localhost:8080/items\", json={\"type\": \"item\", \"id\": 4})\n        print(r.status_code)\n        print(r.json())\n\n###### Output\n\n    {'message': 'Hello World!'}\n    {'message': 'Hello Full Name!'}\n    201\n    {'type': 'item', 'id': 4}\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/charlestolley/restapi-wsgi",
    "keywords": "",
    "license": "GPLv3+",
    "maintainer": "",
    "maintainer_email": "",
    "name": "restapi-wsgi",
    "package_url": "https://pypi.org/project/restapi-wsgi/",
    "platform": "",
    "project_url": "https://pypi.org/project/restapi-wsgi/",
    "project_urls": {
      "Homepage": "https://github.com/charlestolley/restapi-wsgi"
    },
    "release_url": "https://pypi.org/project/restapi-wsgi/0.0.1/",
    "requires_dist": null,
    "requires_python": "<4,>=3",
    "summary": "A lightweight WSGI REST API framework",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9433298,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aeb66a53e45162a55017c8e633950b65ce62a358e47a4917eba32abfbfb35659",
          "md5": "82a3696002c8b08e4bf0a66757e1dd68",
          "sha256": "66b28fcc66ad601c841d93fddc162ec89aba56b522a9bae9c319db777a5d3ef5"
        },
        "downloads": -1,
        "filename": "restapi_wsgi-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "82a3696002c8b08e4bf0a66757e1dd68",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": "<4,>=3",
        "size": 23311,
        "upload_time": "2021-02-16T13:39:54",
        "upload_time_iso_8601": "2021-02-16T13:39:54.144428Z",
        "url": "https://files.pythonhosted.org/packages/ae/b6/6a53e45162a55017c8e633950b65ce62a358e47a4917eba32abfbfb35659/restapi_wsgi-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "35cbe62ff332aaa06a3640654f0c3886210a25f2037869afde1969873e5d1cf2",
          "md5": "159fed5892a5d291d5ef9bb5389e7c51",
          "sha256": "37e043b36af96060fee1aff433d27d2b1f7dac0391c75b714637f35be362b97f"
        },
        "downloads": -1,
        "filename": "restapi-wsgi-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "159fed5892a5d291d5ef9bb5389e7c51",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "<4,>=3",
        "size": 13302,
        "upload_time": "2021-02-16T13:39:55",
        "upload_time_iso_8601": "2021-02-16T13:39:55.501874Z",
        "url": "https://files.pythonhosted.org/packages/35/cb/e62ff332aaa06a3640654f0c3886210a25f2037869afde1969873e5d1cf2/restapi-wsgi-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "aeb66a53e45162a55017c8e633950b65ce62a358e47a4917eba32abfbfb35659",
        "md5": "82a3696002c8b08e4bf0a66757e1dd68",
        "sha256": "66b28fcc66ad601c841d93fddc162ec89aba56b522a9bae9c319db777a5d3ef5"
      },
      "downloads": -1,
      "filename": "restapi_wsgi-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "82a3696002c8b08e4bf0a66757e1dd68",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": "<4,>=3",
      "size": 23311,
      "upload_time": "2021-02-16T13:39:54",
      "upload_time_iso_8601": "2021-02-16T13:39:54.144428Z",
      "url": "https://files.pythonhosted.org/packages/ae/b6/6a53e45162a55017c8e633950b65ce62a358e47a4917eba32abfbfb35659/restapi_wsgi-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "35cbe62ff332aaa06a3640654f0c3886210a25f2037869afde1969873e5d1cf2",
        "md5": "159fed5892a5d291d5ef9bb5389e7c51",
        "sha256": "37e043b36af96060fee1aff433d27d2b1f7dac0391c75b714637f35be362b97f"
      },
      "downloads": -1,
      "filename": "restapi-wsgi-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "159fed5892a5d291d5ef9bb5389e7c51",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": "<4,>=3",
      "size": 13302,
      "upload_time": "2021-02-16T13:39:55",
      "upload_time_iso_8601": "2021-02-16T13:39:55.501874Z",
      "url": "https://files.pythonhosted.org/packages/35/cb/e62ff332aaa06a3640654f0c3886210a25f2037869afde1969873e5d1cf2/restapi-wsgi-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}