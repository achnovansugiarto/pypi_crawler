{
  "info": {
    "author": "Karthik Raveendran",
    "author_email": "karthik@attinadsoftware.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "pychromecast |Build Status|\n===========================\n\n.. |Build Status| image:: https://travis-ci.org/balloob/pychromecast.svg?branch=master\n   :target: https://travis-ci.org/balloob/pychromecast\n\nLibrary for Python 3.4+ to communicate with the Google Chromecast. It\ncurrently supports:\n\n-  Auto discovering connected Chromecasts on the network\n-  Start the default media receiver and play any online media\n-  Control playback of current playing media\n-  Implement Google Chromecast api v2\n-  Communicate with apps via channels\n-  Easily extendable to add support for unsupported namespaces\n-  Multi-room setups with Audio cast devices\n\n*Check out* `Home Assistant <https://home-assistant.io>`_ *for a\nready-made solution using PyChromecast for controlling and automating\nyour Chromecast or Cast-enabled device like Google Home.*\n\nDependencies\n------------\n\nPyChromecast depends on the Python packages requests, protobuf and\nzeroconf. Make sure you have these dependencies installed using\n``pip install -r requirements.txt``\n\nHow to use\n----------\n\n.. code:: python\n\n    >> import time\n    >> import pychromecast\n\n    >> chromecasts = pychromecast.get_chromecasts()\n    >> [cc.device.friendly_name for cc in chromecasts]\n    ['Dev', 'Living Room', 'Den', 'Bedroom']\n\n    >> cast = next(cc for cc in chromecasts if cc.device.friendly_name == \"Living Room\")\n    >> # Start worker thread and wait for cast device to be ready\n    >> cast.wait()\n    >> print(cast.device)\n    DeviceStatus(friendly_name='Living Room', model_name='Chromecast', manufacturer='Google Inc.', uuid=UUID('df6944da-f016-4cb8-97d0-3da2ccaa380b'), cast_type='cast')\n\n    >> print(cast.status)\n    CastStatus(is_active_input=True, is_stand_by=False, volume_level=1.0, volume_muted=False, app_id='CC1AD845', display_name='Default Media Receiver', namespaces=['urn:x-cast:com.google.cast.player.message', 'urn:x-cast:com.google.cast.media'], session_id='CCA39713-9A4F-34A6-A8BF-5D97BE7ECA5C', transport_id='web-9', status_text='')\n\n    >> mc = cast.media_controller\n    >> mc.play_media('http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4', 'video/mp4')\n    >> mc.block_until_active()\n    >> print(mc.status)\n    MediaStatus(current_time=42.458322, content_id='http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4', content_type='video/mp4', duration=596.474195, stream_type='BUFFERED', idle_reason=None, media_session_id=1, playback_rate=1, player_state='PLAYING', supported_media_commands=15, volume_level=1, volume_muted=False)\n\n    >> mc.pause()\n    >> time.sleep(5)\n    >> mc.play()\n\nAdding support for extra namespaces\n-----------------------------------\n\nEach app that runs on the Chromecast supports namespaces. They specify a\nJSON-based mini-protocol. This is used to communicate between the\nChromecast and your phone/browser and now Python.\n\nSupport for extra namespaces is added by using controllers. To add your own namespace to a current chromecast instance you will first have to define your controller. Example of a minimal controller:\n\n.. code:: python\n\n    from pychromecast.controllers import BaseController\n\n    class MyController(BaseController):\n        def __init__(self):\n            super(MyController, self).__init__(\n                \"urn:x-cast:my.super.awesome.namespace\")\n\n        def receive_message(self, message, data):\n            print(\"Wow, I received this message: {}\".format(data))\n\n            return True  # indicate you handled this message\n\n        def request_beer(self):\n            self.send_message({'request': 'beer'})\n\nAfter you have defined your controller you will have to add an instance to a Chromecast object: `cast.register_handler(MyController())`. When a message is received with your namespace it will be routed to your controller.\n\nFor more options see the `BaseController`_. For an example of a fully implemented controller see the `MediaController`_.\n\n.. _BaseController: https://github.com/balloob/pychromecast/blob/master/pychromecast/controllers/__init__.py\n.. _MediaController: https://github.com/balloob/pychromecast/blob/master/pychromecast/controllers/media.py\n\nExploring existing namespaces\n-------------------------------\nSo you've got PyChromecast running and decided it is time to add support to your favorite app. No worries, the following instructions will have you covered in exploring the possibilities.\n\nThe following instructions require the use of the `Google Chrome browser`_ and the `Google Cast plugin`_.\n\n * In Chrome, go to `chrome://net-internals/#capture`\n * Enable the checkbox 'Include the actual bytes sent/received.'\n * Open a new tab, browse to your favorite application on the web that has Chromecast support and start casting.\n * Go back to the tab that is capturing events and click on stop.\n * From the dropdown click on events. This will show you a table with events that happened while you were recording.\n * In the filter box enter the text `Tr@n$p0rt`. This should give one SOCKET connection as result: the connection with your Chromecast.\n * Go through the results and collect the JSON that is exchanged.\n * Now write a controller that is able to mimic this behavior :-)\n\n.. _Google Chrome Browser: https://www.google.com/chrome/\n.. _Google Cast Plugin: https://chrome.google.com/webstore/detail/google-cast/boadgeojelhgndaghljhdicfkmllpafd\n\nIgnoring CEC Data\n-----------------\nThe Chromecast typically reports whether it is the active input on the device\nto which it is connected. This value is stored inside a cast object in the\nfollowing property.\n\n.. code:: python\n\n    cast.status.is_active_input\n\nSome Chromecast users have reported CEC incompatibilities with their media\ncenter devices. These incompatibilities may sometimes cause this active input\nvalue to be reported improperly.\n\nThis active input value is typically used to determine if the Chromecast\nis idle. PyChromecast is capable of ignoring the active input value when\ndetermining if the Chromecast is idle in the instance that the\nChromecast is returning erroneous values. To ignore this CEC detection\ndata in PyChromecast, append a `Linux style wildcard`_ formatted string\nto the IGNORE\\_CEC list in PyChromecast like in the example below.\n\n.. code:: python\n\n    pychromecast.IGNORE_CEC.append('*')  # Ignore CEC on all devices\n    pychromecast.IGNORE_CEC.append('Living Room')  # Ignore CEC on Chromecasts named Living Room\n\nThanks\n------\n\nI would like to thank `Fred Clift`_ for laying the socket client ground\nwork. Without him it would not have been possible!\n\n.. _Linux style wildcard: http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm\n.. _@am0s: https://github.com/am0s\n.. _@rmkraus: https://github.com/rmkraus\n.. _@balloob: https://github.com/balloob\n.. _Fred Clift: https://github.com/minektur",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/karthikpanicker/pychromecast",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Cantiz-PyChromecast",
    "package_url": "https://pypi.org/project/Cantiz-PyChromecast/",
    "platform": "any",
    "project_url": "https://pypi.org/project/Cantiz-PyChromecast/",
    "project_urls": {
      "Homepage": "https://github.com/karthikpanicker/pychromecast"
    },
    "release_url": "https://pypi.org/project/Cantiz-PyChromecast/3.2.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Python module to talk to Google Chromecast.",
    "version": "3.2.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5460655,
  "releases": {
    "3.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f259be4b74eec2af6bb3ce1078434e5b1a8756f2d34e722367b7a58a92195e3a",
          "md5": "a6b0c0d0b2795a71a17b1651dc72e564",
          "sha256": "ee04f529e8a4eb0049476d9b2df594bba8816fb5d8f0d14d141526968eb1aafa"
        },
        "downloads": -1,
        "filename": "Cantiz-PyChromecast-3.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a6b0c0d0b2795a71a17b1651dc72e564",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39683,
        "upload_time": "2019-06-28T08:49:19",
        "upload_time_iso_8601": "2019-06-28T08:49:19.508483Z",
        "url": "https://files.pythonhosted.org/packages/f2/59/be4b74eec2af6bb3ce1078434e5b1a8756f2d34e722367b7a58a92195e3a/Cantiz-PyChromecast-3.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f259be4b74eec2af6bb3ce1078434e5b1a8756f2d34e722367b7a58a92195e3a",
        "md5": "a6b0c0d0b2795a71a17b1651dc72e564",
        "sha256": "ee04f529e8a4eb0049476d9b2df594bba8816fb5d8f0d14d141526968eb1aafa"
      },
      "downloads": -1,
      "filename": "Cantiz-PyChromecast-3.2.2.tar.gz",
      "has_sig": false,
      "md5_digest": "a6b0c0d0b2795a71a17b1651dc72e564",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 39683,
      "upload_time": "2019-06-28T08:49:19",
      "upload_time_iso_8601": "2019-06-28T08:49:19.508483Z",
      "url": "https://files.pythonhosted.org/packages/f2/59/be4b74eec2af6bb3ce1078434e5b1a8756f2d34e722367b7a58a92195e3a/Cantiz-PyChromecast-3.2.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}