{
  "info": {
    "author": "",
    "author_email": "ZHB <zhb2000@whu.edu.cn>",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: AsyncIO",
      "License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Topic :: Internet",
      "Typing :: Typed"
    ],
    "description": "# LightQ\r\n\r\n![PyPI](https://img.shields.io/pypi/v/lightq?logo=pypi&logoColor=white) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/lightq?logo=python&logoColor=white) ![mirai-api-http version](https://img.shields.io/badge/mirai--api--http-v2.6.2-blue) ![PyPI - License](https://img.shields.io/pypi/l/lightq)\r\n\r\nLightQ 是一个基于 [mirai-api-http](https://github.com/project-mirai/mirai-api-http) 的 QQ 机器人框架。\r\n\r\n## 安装\r\n\r\n从 PyPI 安装：\r\n\r\n```shell\r\npip install lightq\r\n```\r\n\r\n从源代码安装：\r\n\r\n```shell\r\ngit clone https://github.com/zhb2000/lightq.git\r\ncd lightq\r\npip install .\r\n```\r\n\r\n## 前置条件\r\n\r\n环境要求：\r\n\r\n- Python 3.10\r\n- mirai-api-http 2.6.2\r\n\r\nLightQ 需要借助网络 API 调用 Mirai 的功能，因此请先安装并配置好  [Mirai Console Loader](https://github.com/iTXTech/mirai-console-loader) 和 [mirai-api-http](https://github.com/project-mirai/mirai-api-http) 插件：\r\n\r\n1. 安装 [Mirai Console Loader (MCL)](https://github.com/iTXTech/mirai-console-loader)。\r\n1. 在 MCL 中配置 QQ 账号和密码，确保能正常登录账号，中途可能需要使用 [TxCaptchaHelper](https://github.com/mzdluo123/TxCaptchaHelper) 应对滑动验证码。\r\n1. 为 MCL 安装 [mirai-api-http](https://github.com/project-mirai/mirai-api-http) 插件。\r\n1. 在 mirai-api-http 的配置文件中启用 websocket 适配器。\r\n\r\nLightQ 使用 Python 标准库的 [asyncio](https://docs.python.org/zh-cn/3/library/asyncio.html) 完成异步操作，如果你不熟悉 Python 的协程，可以先看看 Python 文档中[协程与任务](https://docs.python.org/zh-cn/3/library/asyncio-task.html)这一节。\r\n\r\n## 简明教程\r\n### 快速起步\r\n\r\n```python\r\nimport asyncio\r\nfrom lightq import message_handler, Bot, scan_handlers\r\nfrom lightq.entities import FriendMessage\r\n\r\n@message_handler(FriendMessage)\r\ndef say_hello() -> str:\r\n    return 'Hello'\r\n\r\nasync def main():\r\n    bot = Bot(123456789, 'verify-key')  # 请替换为相应的 QQ 号和 verify key\r\n    bot.add_all(scan_handlers(__name__))\r\n    await bot.run()\r\n\r\nif __name__ == '__main__':\r\n    asyncio.run(main())\r\n```\r\n\r\n上述代码实现了一个最简单的 QQ 机器人，无论谁给它发消息，它都只会回复 Hello。\r\n\r\n`message_handler` 装饰器将 `say_hello` 函数包装为一个 `MessageHandler` 对象，该消息处理器只会响应好友消息 `FriendMessage`。LightQ 还提供了 `event_handler` 和 `exception_handler` 装饰器，分别用于创建事件处理器和异常处理器。\r\n\r\n`bot.add_all(scan_handlers(__name__))` 的作用是获取当前模块中所有 public 的 handler，并将它们添加到 `bot` 中。\r\n\r\n- 注 1：[`__name__` 是 Python 中一个特殊的变量，表示当前模块的全限定名称](https://docs.python.org/zh-cn/3/reference/import.html#name__)。\r\n- 注 2：在 Python 中不以下划线开头的变量为模块的 public 成员，另一种做法是在模块中用 `__all__` 列出所有 public 成员的名字。\r\n\r\n一个合法的 handler 函数需要返回 `str` 或 `MessageChain` 或 `None`。Handler 函数既可以是同步函数也可以是异步函数。\r\n\r\n```python\r\nfrom lightq import message_handler\r\nfrom lightq.entities import FriendMessage, MessageChain, Plain\r\n\r\n@message_handler(FriendMessage)\r\nasync def say_hello() -> MessageChain:  # 一个返回 MessageChain 的异步函数\r\n    await asyncio.sleep(1)\r\n    return MessageChain([Plain('Hello')])\r\n```\r\n\r\n### 过滤器\r\n\r\n如何实现 handler 的有条件执行？需要使用过滤器。我们继续改进之前的 `say_hello`：\r\n\r\n```python\r\nfrom lightq import RecvContext\r\n\r\ndef condition(context: RecvContext) -> bool:\r\n    return str(context.data.message_chain) == 'Hello'\r\n\r\n@message_handler(FriendMessage, filters=condition)\r\ndef say_hello() -> str:\r\n    \"\"\"当别人对 bot 说 Hello 时回复 Hello\"\"\"\r\n    return 'Hello'\r\n```\r\n\r\n上面代码中的 `condition` 函数就是一个过滤器。`lightq.filters` 模块提供了一些现成的过滤器，可以直接使用。让我们再修改一下 `say_hello`，为它设置两个条件：\r\n\r\n```python\r\nfrom lightq import RecvContext, filters\r\n\r\ndef condition(context: RecvContext) -> bool:\r\n    return str(context.data.message_chain) == 'Hello'\r\n\r\n@message_handler(FriendMessage, filters=[filters.from_user(987654321), condition])\r\ndef say_hello() -> str:\r\n    \"\"\"当 QQ 号为 987654321 的用户对 bot 说 Hello 时回复 Hello\"\"\"\r\n    return 'Hello'\r\n```\r\n\r\n### 参数解析\r\n#### 基于类型的参数解析\r\n\r\n如果你用过 Spring Boot 之类的 Web 框架，对于参数解析这个概念应该不会陌生。LightQ 框架支持基于类型和基于函数两种参数解析机制。下面这个示例展示了如何使用基于类型的参数解析：\r\n\r\n```python\r\nfrom lightq.entities import GroupMessage, MessageChain\r\n\r\n@message_handler(GroupMessage)\r\ndef group_message_handler(chain: MessageChain):\r\n    print(f'收到一条群组消息，内容为：{chain}')\r\n```\r\n\r\n注意到 `group_message_handler` 函数带有参数类型注解 `chain: MessageChain`，这个类型注解是不可或缺的。LightQ 框架使用 Python 的内省 (inspect) 机制获取 `chain` 参数的类型，接收到消息后解析出消息链对象，再自动地将消息链对象注入 `chain` 参数中。\r\n\r\n参数解析机制的一个重要用途是在 handler 内获取 bot 的引用，并直接调用 bot 对象上的方法：\r\n\r\n```python\r\n@event_handler(NudgeEvent)\r\nasync def nudge_response(event: NudgeEvent, bot: Bot):\r\n    \"\"\"谁拍一拍我，我就拍一拍谁\"\"\"\r\n    if (event.subject.kind == 'Group'\r\n        and event.target == bot.bot_id\r\n        and event.from_id != bot.bot_id):\r\n        await bot.api.send_nudge(event.from_id, event.subject.id, 'Group')\r\n```\r\n\r\nLightQ 框架支持自动解析的类型有：\r\n\r\n- `Bot`\r\n- `RecvContext`\r\n- `ExceptionContext`\r\n- `MessageChain`\r\n- `Message` 及其子类\r\n- `Event` 及其子类\r\n- `Exception` 及其子类\r\n\r\n参数解析机制也支持自定义类型，只需让你自己的类型继承 `lightq.framework` 中的 `FromContext` / `FromRecvContext` / `FromExceptionContext` 抽象类并重写对应的方法即可。\r\n\r\n#### 基于函数的参数解析\r\n\r\n基于类型的参数解析无法覆盖所有场景，例如：希望从群组消息中解析出群号和发送者的 QQ 号，但二者皆为 `int` 类型，仅凭类型无法区分。此时需要使用基于函数的参数解析，请看如下例子：\r\n\r\n```python\r\nfrom lightq import resolvers  # resolvers 是一个模块\r\nfrom lightq import resolve  # resolve 是一个装饰器\r\n\r\n@resolve(resolvers.group_id, member_id=resolvers.sender_id)\r\n@message_handler(GroupMessage)\r\ndef group_message_handler(chain: MessageChain, group_id: int, member_id: int):\r\n    print(f'收到一条群组消息，群号 {group_id}，群员 QQ 号 {member_id}，内容为：{chain}')\r\n```\r\n\r\n`resolvers.group_id` 和 `resolvers.sender_id` 是两个类型为 `(RecvContext) -> int` 的函数，分别从 `RecvContext` 对象中解析出发送者的群号和 QQ 号，再配合 `resolve` 装饰器就可以实现参数解析和自动注入的效果。\r\n\r\n使用 `resolve` 装饰器时，若以普通方式传参（上面的 `@resolve(resolvers.group_id)`），则根据解析器的 `__name__` 属性注入同名的参数（[Python 函数的 `__name__` 属性默认为该函数的名字](https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__name__)）；若以命名参数的方式传参（上面的 `@resolve(member_id=resolvers.sender_id)`），则表示手动指定注入参数。\r\n\r\n本节的示例代码放在 [examples/resolver_example.py](./examples/resolver_example.py) 中。\r\n\r\n### 正则表达式\r\n\r\n`lightq.decorators` 模块中有三个很实用的装饰器：`regex_match`、`regex_search`、`regex_fullmatch`，分别对应 Python 标准库中的 `re.match`, `re.search`, `re.fullmatch`，可以通过正则表达式匹配消息的内容。\r\n\r\n```python\r\nimport re\r\nfrom lightq.decorators import regex_match\r\n\r\n@regex_match('(?P<first_group>\\w+) (?P<second_group>\\w+)')\r\n@message_handler(GroupMessage)\r\ndef handler(first_group: str, second_group: str, match: re.Match):\r\n    assert first_group == match['first_group']\r\n    assert second_group == match['second_group']\r\n```\r\n\r\n正则表达式中形如 `(?P<name>...)` 的是命名组语法。如果消息的内容与正则表达式相匹配，那么将捕获的组按照组的名字注入到 handler 的同名参数中，匹配对象将自动注入到类型为 `re.Match` 的参数中。\r\n\r\n正则表达式装饰器可以用来构建 QQ 机器人的指令系统：\r\n\r\n```python\r\n@regex_fullmatch(r'/mute\\s+(?P<member_id>\\d+)\\s+(?P<duration>\\d+)')\r\n@resolve(resolvers.group_id)\r\n@message_handler(GroupMessage)\r\nasync def mute_command(group_id: int, member_id: str, duration: str, bot: Bot):\r\n    \"\"\"\r\n    输入 /mute member_id duration 命令以禁言用户\r\n\r\n    :param group_id: 群号\r\n    :param member_id: 被禁言的用户\r\n    :param duration: 禁言时长（秒）\r\n    \"\"\"\r\n    await bot.api.mute(group_id, int(member_id), int(duration))\r\n```\r\n\r\n`regex_match` 的实现非常简单，其原理是将过滤器和解析器构造出来插入 handler 中，并不需要引入额外的组件。你可以在 [src/lightq/decorators/_regex.py](./src/lightq/decorators/_regex.py) 找到其源代码。\r\n\r\n### 设置 handler 的优先级\r\n\r\n若不显式地指定 handler 间的优先关系，则机器人遍历各个 handler 的顺序是不确定的，这有时候会带来问题。以下是一个复读机程序，可通过“开始复读”和“停止复读”命令来开关复读功能。\r\n\r\n```python\r\nrepeat_on = False\r\n\r\n@regex_fullmatch('(?P<option>开始|停止)复读')\r\n@message_handler(GroupMessage)\r\ndef switch(option: str):\r\n    global repeat_on\r\n    repeat_on = option == '开始'\r\n    return f'复读已{option}'\r\n\r\n@message_handler(GroupMessage, filters=lambda ctx: repeat_on, after=switch)\r\ndef repeat(chain: MessageChain) -> MessageChain:\r\n    return chain\r\n```\r\n\r\n注意到，必须先判断 `switch` 的条件是否满足，然后再判断 `repeat` 的条件是否满足，即 `switch` 的优先级必须高于 `repeat`，否则当用户输入“停止复读”时，程序会继续复读“停止复读”这句话而不是把复读功能关掉。\r\n\r\n怎样设置 handler 的优先级呢？有三种方法：\r\n\r\n- 使用装饰器的 `after` 参数或 `before` 参数，如上述代码在 `repeat` 的装饰器中设置了 `after=switch`。\r\n- 直接修改 handler 的 `after` 或 `before` 属性，如 `repeat.after.append(switch)`。\r\n- 使用 `Bot` 的 `add_order` 方法，如 `bot.add_order(switch, repeat)`。\r\n\r\n本节的示例代码放在 [examples/repeater.py](./examples/repeater.py) 中。\r\n\r\n### 使用 controller\r\n\r\n以上示例中所有的 bot 都是“一问一答”型，而一个具备连续对话能力的 bot 看起来会更加有趣：\r\n\r\n```text\r\n群友 1：/weather\r\nBot：您想查询哪个城市的天气？\r\n群友 1：武汉\r\nBot：武汉的天气为小雨\r\n\r\n群友 2：/mute_all\r\nBot：您确定要开启全员禁言吗？请回复“是”或“否”\r\n群友 2：no\r\nBot：请回复“是”或“否”\r\n群友 2：否\r\n```\r\n\r\n若要实现连续对话功能，就必须保存每个用户的状态。可以将状态保存到全局变量中。如果你不喜欢全局变量这种代码风格，也可以将状态封装到 controller 类中统一管理。Controller 类的编写方法如下：\r\n\r\n```python\r\nclass MyController(lightq.Controller):  # 继承 lightq.Controller 类\r\n    def __init__(self):\r\n        self.status = ...  # 将状态作为成员变量封装到 controller 中\r\n\r\n    # 过滤器方法\r\n    def condition(self, context: RecvContext) -> bool: ...\r\n\r\n    # 解析器方法\r\n    def resolver(self, context: RecvContext): ...\r\n\r\n    # 用 message_handler 装饰器将 my_handler 方法转换为消息处理器\r\n    # - 使用 condition 方法作为过滤条件\r\n    # - 使用 resolver 方法作为参数解析器\r\n    @resolve(data=resolver)\r\n    @message_handler(Message, filters=condition)\r\n    def my_handler(self, data):\r\n        self.status  # 在方法内部可以通过 self 引用保存的状态\r\n        ...\r\n\r\ncontroller = MyController()\r\n# 通过 handlers 方法获取所有 public 的 handler\r\nbot.add_all(controller.handlers())\r\n# ...\r\n```\r\n\r\n[examples/assistant.py](./examples/assistant.py) 提供了一个完整的 controller 示例，实现了一个支持 `/weather` 和 `/mute_all` 命令的机器人。\r\n\r\n此外，你还可以用 `handler_property` 装饰器将属性方法转换为处理器，示例代码见 [examples/assistant_property_style.py](./examples/assistant_property_style.py).\r\n\r\n### 其他功能\r\n#### 定时任务、后台任务\r\n\r\n相关的函数和方法：\r\n\r\n- `asyncio.sleep`：可用于延迟执行等场景。\r\n- `lightq.utils.sleep_until`：延迟到某个时刻执行，该函数是对 `asyncio.sleep` 的简单封装。\r\n- `Bot.create_task`：创建后台任务，该方法是对 `asyncio.create_task` 的简单封装。\r\n- `Bot.create_everyday_task`：创建每日定时任务。\r\n\r\n#### 日志\r\n\r\nLightQ 使用 Python 标准库中的 `logging` 模块来打印日志，可通过 `lightq.logger` 获得 logger 对象。默认的日志打印级别为 INFO。\r\n\r\n#### 自定义路由\r\n\r\nLightQ 默认的路由会根据消息/事件/异常的类型将数据送给指定的 handler。你也可以根据实际场景设计更高效的路由机制。继承 `MessageRouter` / `EventRouter` / `ExceptionRouter` 抽象类（位于 `lightq.framework` 模块中）并重写对应的方法以实现自定义路由机制。\r\n\r\n## 未来\r\n\r\n（可能是）将来的一些工作：\r\n\r\n- 完善文档\r\n- 支持文件操作\r\n- 补齐剩余的 API 功能\r\n- 中间件/钩子函数？\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "qq,mirai",
    "license": "AGPL-3.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "lightq",
    "package_url": "https://pypi.org/project/lightq/",
    "platform": null,
    "project_url": "https://pypi.org/project/lightq/",
    "project_urls": {
      "Bug Tracker": "https://github.com/zhb2000/lightq/issues",
      "Source": "https://github.com/zhb2000/lightq"
    },
    "release_url": "https://pypi.org/project/lightq/0.3.0/",
    "requires_dist": null,
    "requires_python": ">=3.10",
    "summary": "An elegant QQ bot framework based on mirai-api-http.",
    "version": "0.3.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15840519,
  "releases": {
    "0.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "db492dbec2750cee72c5c2c2ab26a945baa5dd18b560baa34436b9b10c335f83",
          "md5": "3bc680bc1a276aac9770e869ed5254b1",
          "sha256": "c9e3981dac97c2fcebf6473c879f855d3bed06a00344f99da626e175aae8abfd"
        },
        "downloads": -1,
        "filename": "lightq-0.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3bc680bc1a276aac9770e869ed5254b1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 13345,
        "upload_time": "2022-08-11T05:24:35",
        "upload_time_iso_8601": "2022-08-11T05:24:35.853316Z",
        "url": "https://files.pythonhosted.org/packages/db/49/2dbec2750cee72c5c2c2ab26a945baa5dd18b560baa34436b9b10c335f83/lightq-0.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3cf342990a8a2703bee3043ef45a56351c61a98c4d47b4757831d6035bd6864c",
          "md5": "e311ae2c63d312ebc525cd7116c26464",
          "sha256": "c15facad92a5d37cb41706edcedd86ad1682fbbdd706cc7693a93ff9bd2e0525"
        },
        "downloads": -1,
        "filename": "lightq-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e311ae2c63d312ebc525cd7116c26464",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 47551,
        "upload_time": "2022-08-11T07:29:38",
        "upload_time_iso_8601": "2022-08-11T07:29:38.661270Z",
        "url": "https://files.pythonhosted.org/packages/3c/f3/42990a8a2703bee3043ef45a56351c61a98c4d47b4757831d6035bd6864c/lightq-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4f7a95d11c00f264ca3aaa7d127869b5a83e3114110ff0bc8e9a28864cbcaf55",
          "md5": "806b369e7bf12c9c3ba30fcf1e1a96fd",
          "sha256": "ac83b99ba025a251ad107680317bd286498696ecb628d9610c479310273bc2f6"
        },
        "downloads": -1,
        "filename": "lightq-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "806b369e7bf12c9c3ba30fcf1e1a96fd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 49825,
        "upload_time": "2022-09-08T07:59:13",
        "upload_time_iso_8601": "2022-09-08T07:59:13.137951Z",
        "url": "https://files.pythonhosted.org/packages/4f/7a/95d11c00f264ca3aaa7d127869b5a83e3114110ff0bc8e9a28864cbcaf55/lightq-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f0cf36dafc07d60d38d79d6c3fd792a4f12aca20124b455cb0429fb23d3072de",
          "md5": "12eba19e5faaf0abb7e6708bd7946dc1",
          "sha256": "66c0ab28206f8b55532da0929d3f2680a4ec48d3efa7d14929cda8a3da03e207"
        },
        "downloads": -1,
        "filename": "lightq-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "12eba19e5faaf0abb7e6708bd7946dc1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 50888,
        "upload_time": "2022-11-21T13:45:15",
        "upload_time_iso_8601": "2022-11-21T13:45:15.306283Z",
        "url": "https://files.pythonhosted.org/packages/f0/cf/36dafc07d60d38d79d6c3fd792a4f12aca20124b455cb0429fb23d3072de/lightq-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f0cf36dafc07d60d38d79d6c3fd792a4f12aca20124b455cb0429fb23d3072de",
        "md5": "12eba19e5faaf0abb7e6708bd7946dc1",
        "sha256": "66c0ab28206f8b55532da0929d3f2680a4ec48d3efa7d14929cda8a3da03e207"
      },
      "downloads": -1,
      "filename": "lightq-0.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "12eba19e5faaf0abb7e6708bd7946dc1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.10",
      "size": 50888,
      "upload_time": "2022-11-21T13:45:15",
      "upload_time_iso_8601": "2022-11-21T13:45:15.306283Z",
      "url": "https://files.pythonhosted.org/packages/f0/cf/36dafc07d60d38d79d6c3fd792a4f12aca20124b455cb0429fb23d3072de/lightq-0.3.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}