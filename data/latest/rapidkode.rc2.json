{
  "info": {
    "author": "Sasi Vatsal",
    "author_email": "sasivatsal7122@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Education",
      "License :: OSI Approved :: MIT License",
      "Operating System :: Microsoft :: Windows :: Windows 10",
      "Programming Language :: Python :: 3"
    ],
    "description": "<img src='logo.png' width='100%'></img>\n\n<h1 align='center'>RapidKode: get it right the first time</h1>\n\n#### RapidKode is a Python package that provides fast, flexible, and expressive data structures,alogorithms designed to make working with both competitive programming and coding  easy and intuitive. It aims to be the fundamental high-level building block for competitive programming in Python.With RapidKode you can perform complex algorithms in less time, all the algorithms are optimized to their finest to reduce time complexity to make you stand out in the leader board. There is no more time wasting writing huge chucks of code and debugging them later, With RapidKode everything happens at your fingertips with just a single line of code. The aim of Rapidkode is to help beginners get started in competative programing, understand the importance of time and space. The motto of making Rapidkode is to 'Get it right the first time' instead of spending 10's of precious minutes on util functions.\n\n# Installation:\n\n- ### Install from the official pypi website -> <a href=''>Click Here</a>\nor \n```python\n$ pip install rapidkode\n```\n### For issues,bug reports and contributions visit the development repo --> <a href='https://github.com/sasivatsal7122/Rapidkode-package-pypi'>Click Here</a>\n\n# Available Functions :\n\n## Number functions :\n| **syntax**                     | **operation**                                            \n|:------------------------------:|:--------------------------------------------------------:\n| numbers.gen_sparsenum_upto(x)  | generates sparse number upto the given range             \n| numbers.get_sparsenum_after(n)  | Returns the succeding sparse number for the given number\n| numbers.checkprime(x)           | Returns True if number is prime                         \n| numbers.getprimes.generate(x)  | Returns first x prime numbers                           \n| numbers.getprimes.upto(x)      | Returns prime numbers upto given range                   \n| numbers.getprimes.inrange(x,y) | Returns prime numbers in the given range                \n| numbers.fib.getelement(x)      | Returns x'th fibonacci number                            \n| numbers.fib.generate(x)         | Returns first x fibonacci numbers           \n\n## Example:\n```python\nimport rapidkode as rk\n\nvar = rk.numbers.gen_sparsenum_upto(100)\nprint(var)\t\n\nvar = rk.numbers.get_sparsenum_after(3289)\t\t\nprint(var)\t\n\nvar = rk.numbers.checkprime(8364)\t\nprint(var)\t\n\nvar = rk.numbers.getprimes.generate(100)\t\nprint(var)\t\n\nvar = rk.numbers.getprimes.inrange(100,500)\t\nprint(var)\t\n\nvar = rk.numbers.fib.getelement(58)\t\nprint(var)\t\n\nvar = rk.numbers.fib.generate(25)\t\nprint(var)\n```\n## Output:\n```\n[0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20, 21, 32, 33, 34, 36, 37, 40, 41, 42, 64, 65, 66, 68, 69, 72, 73, 74, 80, 81, 82, 84, 85, 128]\n\n4096\n\nFalse\n\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\n\n[101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499]\n\n365435296162\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]\n\n```\n\n## Number System - Conversion functions:\n| **Syntax**                     | **Operation**                          \n|:------------------------------:|:---------------------------------------\n| convert(x,'sys').to('new_sys') | Converts x from sys to new sys          \n| Example:                       |                                         \n| convert(9845,'dec').to('bin')  | Converts 9845 from Decimal to Binary    \n| convert(3745,'oct').to('hex')  | Converts 3745 from Octal to Hexadecimal \n\n- You can replace with `sys` with ['bin','dec','oct','hex'] and `new_sys` with ['bin','dec','oct','hex'], to make number conversions.\n```python\nimport rapidkode as rk\n\nconverted_num_1 = rk.convert(2013,'dec').to('bin')\nprint(converted_num_1)\n\nconverted_num_2 = rk.convert(11111011101,'bin').to('hex')\nprint(converted_num_2)\n\nconverted_num_3 = rk.convert('7dd','hex').to('dec')\nprint(converted_num_3)\n\nconverted_num_4 = rk.convert(5634,'oct').to('dec')\nprint(converted_num_4)\n\nconverted_num_5 = rk.convert(2972,'hex').to('oct')\nprint(converted_num_5)\n\nconverted_num_6 = rk.convert(24562,'oct').to('bin')\nprint(converted_num_6)\n```\n#### Output:\n```\n11111011101\n7dd\n2013\n2972\n24562\n10100101110010\n```\n## Searching Algorithms :\n| **Technique**        | **Syntax**                  | **Operation**                | **Time Complexity** |\n|:--------------------:|:---------------------------:|:----------------------------:|:-------------------:|\n| Linear Search        | linear.search(arr,x)        | Returns position of x in arr | O(n)                |\n| Binary Search        | binary.search(arr,x)        | Returns position of x in arr | O(log n)            |\n| Jump Search          | jump.search(arr,x)          | Returns position of x in arr | O(√ n)              |\n| Interpolation Search | interpolation.search(arr,x) | Returns position of x in arr | O(log2(log2 n))     |\n| Exponential Search   | exponential.search(arr,x)   | Returns position of x in arr | O(log2 i)           |\n| Ternary Search       | ternary.search(arr,x)       | Returns position of x in arr | O(log3 n)           |\n\nadditonally you can use:\n| Function | Operation                       \n|----------|---------------------------------\n| .show()  | prints the code in the terminal \n| .info()  | Gives the brief info            \n| .algo()  | prints the step wise algorithm  \n\n#### Example:\n```python\nimport rapidkode as rk\n\n>>> rk.binary.show()\n>>> rk.binary.info()\n>>> rk.binary.algo()\n```\n#### Output:\n```python\ndef binarysearch(arr, x):\n\tl = 0\n\tr = len(arr)-1\n\twhile l <= r:\n\n\t\tmid = l + (r - l) // 2\n\t\tif arr[mid] == x:\n\t\t\treturn mid\n\t\telif arr[mid] < x:\n\t\t\tl = mid + 1\n\t\telse:\n\t\t\tr = mid - 1\n\treturn \"element not found\"\n```\n```\nBinary search is the search technique that works efficiently on sorted lists\n. Hence, to search an element into some list using the binary search technique, we must ensure that the list is sorted\n. Binary search follows the divide and conquer approach in which the list is divided into two halves, and the item is compared with the middle element of the list\n. If the match is found then, the location of the middle element is returned\n. Otherwise, we search into either of the halves depending upon the result produced through the match\n```\n```\nAlgorithm\n\nStep 1 - Read the search element from the user.\n\nStep 2 - Find the middle element in the sorted list.\n\nStep 3 - Compare the search element with the middle element in the sorted list.\n\nStep 4 - If both are matched, then display \"Given element is found!!!\" and terminate the function.\n\nStep 5 - If both are not matched, then check whether the search element is smaller or larger than the middle element.\n\nStep 6 - If the search element is smaller than middle element, repeat steps 2, 3, 4 and 5 for the left sublist of the middle element.\n\nStep 7 - If the search element is larger than middle element, repeat steps 2, 3, 4 and 5 for the right sublist of the middle element.\n\nStep 8 - Repeat the same process until we find the search element in the list or until sublist contains only one element.\n\nStep 9 - If that element also doesn't match with the search element, then display \"Element is not found in the list!!!\" and terminate the function.\n```\nThe three functions `.show()`, `.info()`, `.algo()` can be used for all the 6 searching techniques.\n\n## Sorting Algorithms :\n\n| **Technique**   | **Syntax**                | **Operation**                     | **Time Complexity** |\n|:---------------:|:-------------------------:|:---------------------------------:|:-------------------:|\n| Selection Sort  | selection.sort(arr)       | Sorts and Returns the given array | O(n^2)              |\n| Bubble Sort     | bubble.sort(arr)          | Sorts and Returns the given array | O(n^2)              |\n| Insertion Sort  | insertion.sort(arr)       | Sorts and Returns the given array | O(n^2)              |\n| Merge Sort      | merge.sort(arr)           | Sorts and Returns the given array | O(n log(n))\t        |\n| Heap Sort       | heap.sort(arr)            | Sorts and Returns the given array | O(n log(n))         |\n| Quick Sort      | quick.sort(start,end,arr) | Sorts and Returns the given array | O(n^2)              |\n| Count Sort      | count.sort(arr)           | Sorts and Returns the given array | O(n+k)              |\n| Radix Sort      | radix.sort(arr)           | Sorts and Returns the given array | O(nk)               |\n| Bucket Sort     | bucket.sort(arr)          | Sorts and Returns the given array |  O(n + k)           |\n| Shell Sort      | shell.sort(arr)           | Sorts and Returns the given array | O(nlog n)           |\n| Comb Sort       | comb.sort(arr)            | Sorts and Returns the given array | O(n log n)          |\n| Pigeongole Sort | pigeonhole.sort(arr)      | Sorts and Returns the given array |  O(n + N)           |\n| Cycle Sort      | cycle.sort(arr)           | Sorts and Returns the given array | O(n2)               |\n\nadditonally you can use:\n| Function | Operation                       \n|----------|---------------------------------\n| .show()  | prints the code in the terminal \n| .info()  | Gives the brief info            \n| .algo()  | prints the step wise algorithm  \n\n#### Example:\n```python\nimport rapidkode as rk\n\n>>> rk.count.show()\n>>> rk.count.info()\n>>> rk.count.algo()\n```\n#### Output:\n```python\ndef countsort(arr):\n    output = [0 for i in range(len(arr))]\n    count = [0 for i in range(256)]\n    array = [0 for _ in arr]\n    for i in arr:\n        count[i] += 1\n    for i in range(256):\n        count[i] += count[i-1]\n    for i in range(len(arr)):\n        output[count[arr[i]]-1] = arr[i]\n        count[arr[i]] -= 1\n    for i in range(len(arr)):\n        array[i] = output[i]\n    return array\n```\n```\nCounting sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrences of each unique element in the array\n. The count is stored in an auxiliary array and the sorting is done by mapping the count as an index of the auxiliary array\n. Counting sort is a sorting technique based on keys between a specific range\n. It works by counting the number of objects having distinct key values (kind of hashing)\n. Then doing some arithmetic to calculate the position of each object in the output sequence\n```\n```\nAlgorithm\n\nstep 1 - Find out the maximum element (let it be max) from the given array.\n\nstep 2 - Initialize an array of length max+1 with all elements 0.\n         This array is used for storing the count of the elements in the array.\n\nstep 3 - Store the count of each element at their respective index in count array\n\n         For example: if the count of element 3 is 2 then, 2 is stored in the 3rd position of count array.\n         If element \"5\" is not present in the array, then 0 is stored in 5th position.\n\nstep 4 - Store cumulative sum of the elements of the count array.\n         It helps in placing the elements into the correct index of the sorted array.\n\nstep 5 - Find the index of each element of the original array in the count array.\n         This gives the cumulative count. Place the element at the index calculated as shown in figure below.\n\nstep 6 - After placing each element at its correct position, decrease its count by one.\n\n```\nThe three functions `.show()`, `.info()`, `.algo()` can be used for all the 13 sorting techniques.\n\n## Graph Functions :\n| **Syntax**          | **Operation**                               \n|:-------------------:|:-------------------------------------------:\n| .buildedge(u,v)     | Create an Graph Edge                        \n| .buildmultiedge([]) | Creates an Graph with given Coord list      \n| .BFS(x)             | Perform Breadth First Search               \n| .DFS(x)             | Performs Depth First Search                 \n| .findAP()           | Returns the Articulation Point of the graph\n\n### Example:\n```python\nimport rapidkode as rk\n\n# make graph object with graph() class\n\nmy_graph = rk.graph()\n\n# adding one edge at a time\nmy_graph.buildedge(0, 1)\nmy_graph.buildedge(0, 2)\nmy_graph.buildedge(1, 2)\nmy_graph.buildedge(2, 0)\nmy_graph.buildedge(2, 3)\nmy_graph.buildedge(3, 3)\n```\n\n```python\nimport rapidkode as rk\n\n# make graph object with graph() class\n\nmy_graph = rk.graph()\n\n# adding multiple edges at once\n\nmy_graph.buildmultiedge([0,1,0,2,1,2,2,0,2,3,3,3])\n```\n```python\nimport rapidkode as rk\n\n# make graph object with graph() class\n\nmy_graph = rk.graph()\n\nmy_graph.buildmultiedge([0,1,0,2,1,2,2,0,2,3,3,3])\n\n# performing BFS from edge 2\nprint(my_graph.BFS(2))\n\n# performing DFS from edge 2\nprint(my_graph.DFS(2))\n\n# finding the Articulation Point\nprint(my_graph.findAP())\n\n```\n### Output:\n```\n['-->', 2, '-->', 0, '-->', 3, '-->', 1]\n\n['-->', 2, '-->', 0, '-->', 1, '-->', 3]\n\n2\n```\n## Pattern Functions :\n\nThe following function uses Rabin-Karp algorithm which is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then performs the comparison.\n\n| Syntax                    | Operation                                          |\n|---------------------------|----------------------------------------------------|\n| pattern.isthere(a).inn(b) | Returns true if string a is present in string b    |\n| pattern.whereis(a).inn(b) | Returns the index position of string a in string b |\n\n### Example:\n```python\nimport rapidkode as rk\n\na = 'sasi'\nb = 'satyasasivatsal'\n\nprint(rk.isthere(a).inn(b))\nprint(rk.whereis(a).inn(b))\n```\n### Output:\n```python\nTrue\n\n4\n```\n## Linkedlist Functions:\n\n| **Operation**             | **Syntax**                                       |\n|-----------------------|----------------------------------------------|\n| .ins_beg(node)        | Inserts a new node at beginning              |\n| .ins_end(node)        | Inserts a new node at the end                |\n| .ins_after(pos,node)  | Inserts a new node after the node specified  |\n| .ins_before(pos,node) | Inserts a new node before the specified node |\n| .del_node(node) | Deletes the specified node |\n| .return_as_list() | Returns LinkedList as python List |\n\n### Example:\n```python\nimport rapidkode as rk\n\nmy_list = rk.linkedlist()\n\nmy_list.head = rk.node('a')\n\ns1 = rk.node('b')\ns2 = rk.node('c')\ns3 = rk.node('d')\ns4 = rk.node('e')\ns5 = rk.node('f')\ns6 = rk.node('g')\n\nmy_list.head.next = s1\ns1.next =  s2\ns2.next =  s3\ns3.next =  s4\ns4.next =  s5\ns5.next =  s6\n\nprint(my_list)\n```\n### Output :\n```\na -> b -> c -> d -> e -> f -> g -> None\n```\n### Example -2 :\n```python\n# insertion at beginning\nmy_list.ins_beg(rk.node('A'))\n\n# insertion at end\nmy_list.ins_end(rk.node('G'))\n\n# insertion at positiom\nmy_list.ins_after('e',rk.node('E'))\n\n# insertion at position\nmy_list.ins_before('c',rk.node('C'))\n\n# deletion of ndoe\nmy_list.del_node('b')\n\n# returning as list\nmy_listt = my_list.return_as_list()\n\nprint(my_list)\n\nprint(my_listt)\n```\n### Output :\n```\nA -> a -> C -> c -> d -> e -> E -> f -> g -> G -> None\n\n['A', 'a', 'C', 'c', 'd', 'e', 'E', 'f', 'g', 'G', 'None']\n```\n                                                                                        \n## Bit manipulation Fuctions:\n\n| **Syntax**               | **Operation**                              |\n|--------------------------|--------------------------------------------|\n| bits.toggle_bits(x)      | Toggles the set bits and non set bits      |\n| bits.convert_to_bin(x)   | Converts a given number into binary        |\n| bits.counsetbits(x)      | Returns the no.of set bits in a dec number |\n| bits.rotate_byleft(x,d)  | Rotates the bits to left by d times        |\n| bits.rotate_byright(x,d) | Rotates the bits to left by d times        |\n| bits.countflips(x,y)     | Returns the no.of flips to make x as y     |\n\n### Example:\n```python\nimport rapidkode as rk\n\nvar = rk.bits.toggle_bits(873652)\nprint(var)\n\nvar = rk.bits.convert_to_bin(873652)\nprint(var)\n\nvar = rk.bits.countsetbits(873652)\nprint(var)\n\nvar = rk.bits.rotate_byleft(873652,4)\nprint(var)\n\nvar = rk.bits.rotate_byright(873652,4)\nprint(var)\n\nvar = rk.bits.countflips(8934756,873652)\nprint(var)\n```\n\n### Output:\n```\n960632\n\n11010101010010110100\n\n8474306\n\n13978432\n\n54603\n\n7\n```\n\n## Other misc Functions:\n| **Syntax**                   | **Operation**                                           |\n|------------------------------|---------------------------------------------------------|\n| .showsieves()                | Prints Sieves code for finding prime number in terminal |\n| getprimefactors.fornum(x)    | Returns a list of prime factors for given number        |\n| findgcdof(x,y)               | Returns GCD of the given numbers                        |\n| findinversions.forr(arr)     | Returns how close the array is from being sorted        |\n| catlan_numbers.getelement(x) | Returns the x'th Catlan Number                          |\n| catlan_numbers.gen(x)        | Returns a list of first x Catlan_numbers                |\n\n### Example:\n```python\nimport rapidkode as rk\n\nvar = rk.getprimefactors.fornum(6754)\nprint(var)\n\nvar = rk.findgcdof(97345435,8764897)\nprint(var)\n\nvar = rk.findinversions.forr([1, 20, 6, 4, 5])\nprint(var)\n\nvar = rk.catlan_numbers.getelement(15)\nprint(var)\n\nvar = rk.catlan_numbers.gen(28)\nprint(var)\n```\n\n### Output:\n```\n[2, 11, 307.0]\n\n1\n\n5\n\n9694845.0\n\n[1.0, 1.0, 2.0, 5.0, 14.0, 42.0, 132.0, 429.0, 1430.0, 4862.0, 16796.0, 58786.0, 208012.0, 742900.0, 2674440.0, 9694845.0, 35357670.0, 129644790.0, 477638700.0, 1767263190.0, 6564120420.0, 24466267020.0, 91482563640.0, 343059613650.0, 1289904147324.0, 4861946401452.0, 18367353072152.0, 69533550916004.0]\n```\n\n### Contributing to RapidKode\n- All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.\n- Raise an issue if you find any problem\n- If you like to contribute, fork the repo raise an issue before making a pull request, it will be easy for managing\n- Logo and header credits --> <a href='https://github.com/HarshaMalla'>M.Sri Harsha</a>❤️\n\n\n## Happy Rapid Koding!! \n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/sasivatsal7122/Rapidkode-package-pypi",
    "keywords": "rapidkode",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "rapidkode",
    "package_url": "https://pypi.org/project/rapidkode/",
    "platform": null,
    "project_url": "https://pypi.org/project/rapidkode/",
    "project_urls": {
      "Homepage": "https://github.com/sasivatsal7122/Rapidkode-package-pypi"
    },
    "release_url": "https://pypi.org/project/rapidkode/1.0.6/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "a powerful coding utility library",
    "version": "1.0.6",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13335217,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fd1f6e88c8a5cdd94af2ffe4759d10a14c9f34b75c5ffd22c6bda4a682ad2d96",
          "md5": "0551603c212724ed9c13f36c41598691",
          "sha256": "5d175bf87e087aff2361daf6cc00b24e71b9ea55aa06408f774df05f5c51f199"
        },
        "downloads": -1,
        "filename": "rapidkode-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0551603c212724ed9c13f36c41598691",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24800,
        "upload_time": "2022-03-29T15:29:39",
        "upload_time_iso_8601": "2022-03-29T15:29:39.031800Z",
        "url": "https://files.pythonhosted.org/packages/fd/1f/6e88c8a5cdd94af2ffe4759d10a14c9f34b75c5ffd22c6bda4a682ad2d96/rapidkode-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ccc622950052e85a9070b467cf7f09aff4e82fb0a90cb7dcecabfa29a66c8731",
          "md5": "a78b6a471feef3aad5443fe1f2d2e4e5",
          "sha256": "7c91f9058e3ae63ff9d311cc06618d715c3bc31b4a909e3c1fb1ff10f68ad6bc"
        },
        "downloads": -1,
        "filename": "rapidkode-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a78b6a471feef3aad5443fe1f2d2e4e5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47332,
        "upload_time": "2022-03-29T15:29:42",
        "upload_time_iso_8601": "2022-03-29T15:29:42.098091Z",
        "url": "https://files.pythonhosted.org/packages/cc/c6/22950052e85a9070b467cf7f09aff4e82fb0a90cb7dcecabfa29a66c8731/rapidkode-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "de352f85d72cef28ed9639c30a64f9424138fc9ea81a2710c7aeddb06e7258af",
          "md5": "d6a29e274162894e810d8107709bcf5a",
          "sha256": "021970dd7af3a064b69045258edb33f96c1360c5d43cc036bb91947460eaafa5"
        },
        "downloads": -1,
        "filename": "rapidkode-1.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d6a29e274162894e810d8107709bcf5a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24740,
        "upload_time": "2022-03-29T15:49:19",
        "upload_time_iso_8601": "2022-03-29T15:49:19.922254Z",
        "url": "https://files.pythonhosted.org/packages/de/35/2f85d72cef28ed9639c30a64f9424138fc9ea81a2710c7aeddb06e7258af/rapidkode-1.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7b38e3e8ed6c97dd459a3206f08537d886899156fe49e70e878444aa06a867be",
          "md5": "94c11949dd0de6c5744e7a12a9d98f59",
          "sha256": "11ce632e0827d9e7b49a9266b0db9c4aa71c55bd629e299f824da1953bc07c7a"
        },
        "downloads": -1,
        "filename": "rapidkode-1.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "94c11949dd0de6c5744e7a12a9d98f59",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47080,
        "upload_time": "2022-03-29T15:49:22",
        "upload_time_iso_8601": "2022-03-29T15:49:22.630167Z",
        "url": "https://files.pythonhosted.org/packages/7b/38/e3e8ed6c97dd459a3206f08537d886899156fe49e70e878444aa06a867be/rapidkode-1.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "de352f85d72cef28ed9639c30a64f9424138fc9ea81a2710c7aeddb06e7258af",
        "md5": "d6a29e274162894e810d8107709bcf5a",
        "sha256": "021970dd7af3a064b69045258edb33f96c1360c5d43cc036bb91947460eaafa5"
      },
      "downloads": -1,
      "filename": "rapidkode-1.0.6-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "d6a29e274162894e810d8107709bcf5a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 24740,
      "upload_time": "2022-03-29T15:49:19",
      "upload_time_iso_8601": "2022-03-29T15:49:19.922254Z",
      "url": "https://files.pythonhosted.org/packages/de/35/2f85d72cef28ed9639c30a64f9424138fc9ea81a2710c7aeddb06e7258af/rapidkode-1.0.6-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7b38e3e8ed6c97dd459a3206f08537d886899156fe49e70e878444aa06a867be",
        "md5": "94c11949dd0de6c5744e7a12a9d98f59",
        "sha256": "11ce632e0827d9e7b49a9266b0db9c4aa71c55bd629e299f824da1953bc07c7a"
      },
      "downloads": -1,
      "filename": "rapidkode-1.0.6.tar.gz",
      "has_sig": false,
      "md5_digest": "94c11949dd0de6c5744e7a12a9d98f59",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 47080,
      "upload_time": "2022-03-29T15:49:22",
      "upload_time_iso_8601": "2022-03-29T15:49:22.630167Z",
      "url": "https://files.pythonhosted.org/packages/7b/38/e3e8ed6c97dd459a3206f08537d886899156fe49e70e878444aa06a867be/rapidkode-1.0.6.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}