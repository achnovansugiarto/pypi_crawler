{
  "info": {
    "author": "Yousef, Waleed A. and Traoré, Issa and Briguglio, William",
    "author_email": "wyousef@uvic.ca",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "<div role=\"main\">\n\n<div id=\"section-intro\" class=\"section\">\n\n<span>Expand source code</span>\n\n    __all__ = ['unavoidsScore','getAllNCDFs','getNCDF','getBetaFractions','getBetaHist']\n    \n    import numpy as np\n    import matplotlib.pyplot as plt\n    from functools import partial\n    import multiprocessing as mp\n    import os\n    from decimal import Decimal\n    import warnings\n    import time\n    import sys\n    from sklearn.preprocessing import MinMaxScaler\n    \n    \n    def getNCDF(X, p, index):\n        \"\"\" \n        Calculate the NCDF for a single sample using a specified\n        norm.\n    \n        Parameters\n        ----------\n        X : numpy array of shape (n_samples, m_features)\n            Data matrix, assumed to be min max scaled to [0,1], where\n            `n_samples` is the number of samples and `n_features` is\n            the number of features.\n        p : float or np.inf constant\n            The norm to use when calculating the distance between\n            samples in `X`. If np.inf is supplied, then Chebyshev\n            distance is used.\n        index : int\n            The index of the sample in `X` which we are finding the\n            NCDF of. Assumed to be less than `n_samples`.\n    \n        Returns\n        ----------\n        NCDFxi : numpy array of shape (1, m_features) \n            The NCDF of `X[i,:]` where i = `index` and the j-th value equals\n            NCDF_xi(j)\n        \"\"\"\n    \n        n = X.shape[0]\n        d = X.shape[1]\n        \n        with warnings.catch_warnings():\n            try:\n                warnings.filterwarnings('error')\n                \n                NCDFxi = np.zeros((1, n))  # matrix to hold NCDF\n                \n                if p == np.inf:\n                    NCDFxi[0,:] = ( np.max(np.abs(X[index,:]-X[:,:]), axis=1)) #calculate Chebyshev distance between sample X[i] and X[j != i]\n                else:\n                    NCDFxi[0,:] = ( np.sum(np.abs(X[index,:]-X[:,:])**p, axis=1)**(1.0/float(p))) #calculate p-norm of samples X[i] and X[j != i]\n            \n                #normalize by max volumne\n                maxNorm = np.max(NCDFxi[0,:])\n                if maxNorm  > 0: \n                    NCDFxi[0,:] = NCDFxi[0,:]/maxNorm     \n            \n                NCDFxi = np.sort(NCDFxi, axis=1)\n    \n            except Warning as e:\n                print(\"Warning: \"+str(e)+\" -> switching to from numpy to Decimal library implementation, expect speed decrease.\\n\\tAny further warnings mean results may be incorrect.\")\n                \n                NCDFxi = []  # array to hold NCDF\n                \n                for I in range(n):\n                    if p == np.inf:\n                        NCDFxi.append(( np.max(np.abs(X[index,:]-X[I,:])) )) #calculate Chebyshev distance between sample X[i] and X[j != i]\n                    else:\n                        NCDFxi.append(Decimal(( np.sum(np.abs(X[index,:]-X[I,:])**p)))**Decimal(1.0/float(p))) #/ (d**(1.0/p)) #calculate p-norm of samples X[i] and X[j != i] \n    \n                #normalize by max volume\n                maxNorm = max(NCDFxi)\n                if maxNorm > 0:\n                    for I in range(n):\n                        NCDFxi[I] = NCDFxi[I]/maxNorm    \n                \n                NCDFxi = np.array(NCDFxi.sort()).reshape((1, n))\n        \n        return NCDFxi\n    \n    def getAllNCDFs(X, p=0.0625, ncpus=4):\n        \"\"\" \n        Calculate the NCDF for all samples in parallel using a\n        specified norm.\n    \n        Parameters\n        ----------\n        X : numpy array of shape (n_samples, m_features)\n            Data matrix where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        p : float or np.inf constant\n            The norm to use when calculating the distance between\n            samples in `X`. If np.inf is supplied, then Chebyshev\n            distance is used.\n        ncpus : int\n            The number of parallel processes.\n    \n        Returns\n        ----------\n        NCDFs : numpy array of shape (n_samples, n_samples)\n            The i-th row equals the NCDF for the i-th sample in `X`,\n            while the j-th column of the i-th row equals NCDF_xi(j)\n        \"\"\"\n    \n        if np.amax(X) != 1.0 or np.amax(X) != 0:\n    \n            #normalize features between 0 and 1\n            scaler = MinMaxScaler()\n            X = scaler.fit_transform(X)\n                            \n        #catch overflows, underflows and invalid values and invalid division \n        np.errstate(all='raise')\n        np.seterr(all='raise')\n        \n        #get NCDFs\n        pool = mp.Pool(processes=ncpus)\n        func = partial(getNCDF, X, p) #pass X and p as first two args of getNCDF\n        result = pool.map(func, range(X.shape[0])) #run getNCDFs in parallel across each sample\n        pool.close()\n        pool.join()\n    \n        return np.reshape(result, (X.shape[0],X.shape[0]))\n    \n    def getBetaFractions(NCDFs_L, BetaSorted, BetaRanks, fraction_WSS, index):\n        \"\"\" \n        Calculate the UNVAOIDS outlier score for a given sample using\n        the fractions of all gaps method.\n    \n        Parameters\n        ----------\n        NCDFs_L : numpy array of shape (n_samples, L_levels): \n            An array containing the intercepts for n NCDFs at L beta\n            levels, where `n_samples` is the number of samples and\n            `L_levels` is the number of beta levels.\n        BetaSorted : numpy array of shape (n_samples, L_levels): \n            Rhe same as `NCDFs_L` but the intercepts are sorted along\n            the L beta levels (column-wise sort of NCDFs_L).\n        BetaRanks : numpy array of shape (n_samples, L_levels): \n            The same as `NCDFs_L` but the value at `NCDFs_L[i,j]` is\n            replaced with the rank of `NCDFs_L[i,j]` on a given beta\n            horizontal.\n        fraction_WSS : int \n            The number of nearest intercepts to be encompassed by the\n            gap whose size will be the score for a given beta level\n            and NCDF intercept. Assumed to be less than \n            `n_samples/2`.\n        index : int \n            The row index of the NCDF in `NCDFs_L` which we are\n            finding the outlier score of.\n    \n        Returns\n        ----------\n        score : numpy array of shape (1, 1)\n            The highest outlier score for `NCDF_L[index,:]` across\n            all beta levels.\n        \"\"\"\n    \n        n = NCDFs_L.shape[0] #number of NCDFs\n        L = NCDFs_L.shape[1] #number of Betas\n    \n        k_gaps = np.zeros((L,1))\n    \n        #for each column\n        for col in range(L):\n            obser_intercept = NCDFs_L[index,col] #get intercept of this NCDF\n            obser_rank = BetaRanks[index,col] #get rank of intercept for this NCDF\n    \n            #get nearest(by rank) fraction_WSS * 2 intercepts\n            if obser_rank - fraction_WSS < 0:\n                bottom = 0\n                top =  obser_rank + fraction_WSS + 1 - (obser_rank - fraction_WSS)\n            elif obser_rank + fraction_WSS + 1 > n:\n                bottom = obser_rank - fraction_WSS - ((obser_rank + fraction_WSS + 1) - n)\n                top =  n\n            else:\n                bottom = obser_rank - fraction_WSS \n                top = obser_rank + fraction_WSS + 1\n    \n            #sort only the gaps to the k_max * 2 nearest intercepts \n            gaps = np.sort(np.abs(BetaSorted[bottom:top,col] - obser_intercept))\n    \n            #get gaps for each Fraction\n            k_gaps[col,0] = gaps[fraction_WSS]\n    \n        #get largest gap matrix\n        score = np.amax(k_gaps, axis=0)\n        \n        return score\n    \n    \n    def getBetaHist(NCDFs_L, BetaSorted, index):\n    \n        \"\"\" \n        Calculate the UNVAOIDS outlier score for a given sample using\n        the histogram method.\n    \n        Parameters\n        ----------\n        NCDFs_L : numpy array of shape (n_samples, L_levels)\n            An array containing the intercepts for n NCDFs at L beta\n            levels, where `n_samples` is the number of samples and\n            `L_levels` is the number of beta levels.\n        BetaSorted : numpy array of shape (n_samples, L_levels)\n            Rhe same as `NCDFs_L` but the intercepts are sorted along\n            the L beta levels (column-wise sort of NCDFs_L).\n        index : int \n            The row index of the NCDF in `NCDFs_L` which we are\n            finding the outlier score of.\n    \n        Returns\n        ----------\n        score : numpy array of shape (1, 1)\n            The highest outlier score for `NCDF_L[index,:]` across\n            all beta levels.\n        \"\"\"\n    \n        n = NCDFs_L.shape[0] #number of NCDFs\n        L = NCDFs_L.shape[1] #number of Betas\n    \n        beta_max = 0 #the highest score of the beta levels\n    \n        n_bins = int(n * 0.05)\n        step = 1/n_bins\n        edges_s = np.arange(0,1.01,step)\n    \n        if type(NCDFs_L[0,0]) == Decimal:\n            step = Decimal(step)\n            edges_s = np.array([Decimal(i) for i in edges_s])\n        \n        for col in range(1, L-1):\n            obser_intercept = NCDFs_L[index,col] #intercept of observation\n            hrzntl = NCDFs_L[:,col]              #current beta level\n    \n            #center observation intercept in bin with width step\n            if obser_intercept < step: #avoid underflow errors\n                n_le = 0\n            else:\n                n_le = int(obser_intercept/step)\n    \n            edges = edges_s + ((obser_intercept - edges_s[n_le]) - (step/2))\n    \n            if edges[-1] > 1:\n               edges = np.append([0.0], edges)\n               edges[-1] = 1.01\n               n_le += 1\n            elif edges[-1] < 1:\n               edges = np.append(edges, [1.01])\n               edges[0] = 0.0\n    \n            observed_bins = np.where(BetaSorted[:,col] > edges[1], np.minimum(((BetaSorted[:,col]-edges[1])/step).astype('int') + 1, len(edges)-2), 0)\n            u, c = np.unique(observed_bins, return_counts=True)\n            hist = np.zeros((len(edges)-1,))\n            hist[u] = c\n    \n            beta = np.sum(np.where(hist > hist[n_le], hist, 0))/n\n    \n            #compare with best score so far\n            if beta > beta_max:\n                beta_max = beta\n    \n        return np.array(beta_max).reshape((1,1))\n    \n    \n    def unavoidsScore(X, precomputed=False, p=0.0625, returnNCDFs=True, method=\"fractions\", r=0.01,  L=100, ncpus=4):\n    \n        \"\"\" \n        Calculate the UNVAOIDS outlier score for all samples in 'X'.\n    \n        Parameters\n        ----------\n        X : numpy array of shape (n_samples, m_features)\n            Data matrix where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        precomputed : bool, default=True\n            If True, `X` is assumed to be an NCDF array in the same\n            format as that returned by `getAllNCDFs`.\n        p : float or np.inf constant\n            The norm to use when calculating the distance between\n            samples in `X`. If np.inf is supplied, then Chebyshev\n            distance is used.\n        returnNCDFs : bool, default=True\n            If True, NCDF array is returned along with outlier\n            scores.\n        method : {\"fractions\", \"histogram\"}, default=\"fractions\"\n            Specifies which method to use for calculating outlier\n            scores; either \"fractions\" or \"histogram\".\n        r : float\n            Percentage of nearest intercepts to be encompassed by the\n            gap whose size will be the score for a given beta and\n            NCDF intercept in the \"fractions\" method. Ignored if\n            `method` == \"histogram\".\n        L : int\n            The number of beta levels to use.\n        ncpus : int\n            The number of parallel processes to use.\n    \n        Returns\n        ----------\n        scores : numpy array of shape (n_samples, 1)\n            The i-th element in scores is the UNAVOIDS outlier score\n            for the i-th sample(row) in `X`.\n        NCDFs : numpy array of shape (n_samples, n_samples)\n            The i-th row equals the NCDF for the i-th sample in `X`,\n            while the j-th column of the i-th row equals NCDF_xi(j).\n            Only returned if `returnNCDFs` == True.\n    \n        References\n        ----------\n        .. [1] W. A. Yousef, I. Traore and W. Briguglio, (2021)\n           \"UN-AVOIDS: Unsupervised and Nonparametric Approach for\n           Visualizing Outliers and Invariant Detection Scoring\",\n           IEEE Transactions on Information Forensics and Security,\n           vol. 16, pp. 5195-5210, [doi: 10.1109/TIFS.2021.3125608]\n    \n        Examples\n        --------\n        >>> import numpy as np\n        >>> from joblib import load\n        >>> from unavoids import unavoids\n        >>> from sklearn import metrics\n        >>>\n        >>> X_all = load(\"simData.joblib\")\n        >>> Y = np.zeros((X_all.shape[0],))\n        >>> Y[-3:] = 1         #last three samples are outliers\n        >>> X = X_all[:,:4]    #grab first 4 features\n        >>>\n        >>> scores, NCDFs = unavoids.unavoidsScore(X, p=0.0625, returnNCDFs=True, method=\"fractions\")\n        >>> fpr, tpr, thresholds = metrics.roc_curve(Y, scores)\n        >>> metrics.auc(fpr, tpr)\n        1.0\n        \"\"\"\n    \n        if precomputed == False:\n            NCDFs = getAllNCDFs(X, p)\n        else:\n            NCDFs = X\n    \n        WSS = NCDFs.shape[0]\n    \n        Lindexes = np.unique(np.append(np.floor(np.arange(0,L)*(WSS/L)), WSS-1).astype(int)) #indicies of beta levels \n        Fractions_WSS = int((r * WSS))  #convert percentage to portion of window size\n    \n        NCDFs_L = NCDFs[:, Lindexes] #for current norm, grab all NCDF intercepts with all L beta levels \n        BetaSorted = np.sort(NCDFs_L, axis=0) #sort intercepts along beta level\n        BetaRanks = np.argsort((np.argsort(NCDFs_L, axis=0)), axis=0) #get ranks of intercepts\n        \n        if method == \"fractions\":\n            #get score for each sample and all fractions using Fractions method\n            pool = mp.Pool(processes=ncpus)\n            func = partial(getBetaFractions, NCDFs_L, BetaSorted, BetaRanks, Fractions_WSS)\n            scores = np.array(pool.map(func, range(NCDFs_L.shape[0])))\n            pool.close()\n            pool.join()\n        \n        elif method == \"histogram\":\n            #get best beta using Histogram approaches\n            pool = mp.Pool(processes=ncpus)\n            func = partial(getBetaHist, NCDFs_L, BetaSorted)\n            scores = np.array(pool.map(func, range(0, NCDFs_L.shape[0])))\n            pool.close()\n            pool.join()\n    \n        if returnNCDFs == False:\n            return scores.reshape((NCDFs.shape[0], -1))\n        else:\n            return scores.reshape((NCDFs.shape[0], -1)), NCDFs\n\n</div>\n\n<div class=\"section\">\n\n</div>\n\n<div class=\"section\">\n\n</div>\n\n<div class=\"section\">\n\n## Functions\n\n  - `  def getAllNCDFs(X, p=0.0625, ncpus=4) `\n    \n    <div class=\"desc\">\n    \n    Calculate the NCDF for all samples in parallel using a specified\n    norm.\n    \n    ## Parameters\n    \n      - **`X`** : `numpy array` of `shape (n_samples, m_features)`  \n        Data matrix where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n      - **`p`** : `float` or `np.inf constant`  \n        The norm to use when calculating the distance between samples in\n        `X`. If np.inf is supplied, then Chebyshev distance is used.\n      - **`ncpus`** : `int`  \n        The number of parallel processes.\n    \n    ## Returns\n    \n      - **`NCDFs`** : `numpy array` of `shape (n_samples, n_samples)`  \n        The i-th row equals the NCDF for the i-th sample in `X`, while\n        the j-th column of the i-th row equals NCDF\\_xi(j)\n    \n    </div>\n    \n    <span>Expand source code</span>\n    \n        def getAllNCDFs(X, p=0.0625, ncpus=4):\n            \"\"\" \n            Calculate the NCDF for all samples in parallel using a\n            specified norm.\n        \n            Parameters\n            ----------\n            X : numpy array of shape (n_samples, m_features)\n                Data matrix where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            p : float or np.inf constant\n                The norm to use when calculating the distance between\n                samples in `X`. If np.inf is supplied, then Chebyshev\n                distance is used.\n            ncpus : int\n                The number of parallel processes.\n        \n            Returns\n            ----------\n            NCDFs : numpy array of shape (n_samples, n_samples)\n                The i-th row equals the NCDF for the i-th sample in `X`,\n                while the j-th column of the i-th row equals NCDF_xi(j)\n            \"\"\"\n        \n            if np.amax(X) != 1.0 or np.amax(X) != 0:\n        \n                #normalize features between 0 and 1\n                scaler = MinMaxScaler()\n                X = scaler.fit_transform(X)\n                                \n            #catch overflows, underflows and invalid values and invalid division \n            np.errstate(all='raise')\n            np.seterr(all='raise')\n            \n            #get NCDFs\n            pool = mp.Pool(processes=ncpus)\n            func = partial(getNCDF, X, p) #pass X and p as first two args of getNCDF\n            result = pool.map(func, range(X.shape[0])) #run getNCDFs in parallel across each sample\n            pool.close()\n            pool.join()\n        \n            return np.reshape(result, (X.shape[0],X.shape[0]))\n\n  - `  def getBetaFractions(NCDFs_L, BetaSorted, BetaRanks,\n    fraction_WSS, index) `\n    \n    <div class=\"desc\">\n    \n    Calculate the UNVAOIDS outlier score for a given sample using the\n    fractions of all gaps method.\n    \n    ## Parameters\n    \n      - **`NCDFs_L`** : `numpy array` of `shape (n_samples,\n        L_levels):`  \n        An array containing the intercepts for n NCDFs at L beta levels,\n        where `n_samples` is the number of samples and `L_levels` is the\n        number of beta levels.\n      - **`BetaSorted`** : `numpy array` of `shape (n_samples,\n        L_levels):`  \n        Rhe same as `NCDFs_L` but the intercepts are sorted along the L\n        beta levels (column-wise sort of NCDFs\\_L).\n      - **`BetaRanks`** : `numpy array` of `shape (n_samples,\n        L_levels):`  \n        The same as `NCDFs_L` but the value at `NCDFs_L[i,j]` is\n        replaced with the rank of `NCDFs_L[i,j]` on a given beta\n        horizontal.\n      - **`fraction_WSS`** : ` int  `  \n        The number of nearest intercepts to be encompassed by the gap\n        whose size will be the score for a given beta level and NCDF\n        intercept. Assumed to be less than `n_samples/2`.\n      - **`index`** : ` int  `  \n        The row index of the NCDF in `NCDFs_L` which we are finding the\n        outlier score of.\n    \n    ## Returns\n    \n      - **`score`** : `numpy array` of `shape (1, 1)`  \n        The highest outlier score for `NCDF_L[index,:]` across all beta\n        levels.\n    \n    </div>\n    \n    <span>Expand source code</span>\n    \n        def getBetaFractions(NCDFs_L, BetaSorted, BetaRanks, fraction_WSS, index):\n            \"\"\" \n            Calculate the UNVAOIDS outlier score for a given sample using\n            the fractions of all gaps method.\n        \n            Parameters\n            ----------\n            NCDFs_L : numpy array of shape (n_samples, L_levels): \n                An array containing the intercepts for n NCDFs at L beta\n                levels, where `n_samples` is the number of samples and\n                `L_levels` is the number of beta levels.\n            BetaSorted : numpy array of shape (n_samples, L_levels): \n                Rhe same as `NCDFs_L` but the intercepts are sorted along\n                the L beta levels (column-wise sort of NCDFs_L).\n            BetaRanks : numpy array of shape (n_samples, L_levels): \n                The same as `NCDFs_L` but the value at `NCDFs_L[i,j]` is\n                replaced with the rank of `NCDFs_L[i,j]` on a given beta\n                horizontal.\n            fraction_WSS : int \n                The number of nearest intercepts to be encompassed by the\n                gap whose size will be the score for a given beta level\n                and NCDF intercept. Assumed to be less than \n                `n_samples/2`.\n            index : int \n                The row index of the NCDF in `NCDFs_L` which we are\n                finding the outlier score of.\n        \n            Returns\n            ----------\n            score : numpy array of shape (1, 1)\n                The highest outlier score for `NCDF_L[index,:]` across\n                all beta levels.\n            \"\"\"\n        \n            n = NCDFs_L.shape[0] #number of NCDFs\n            L = NCDFs_L.shape[1] #number of Betas\n        \n            k_gaps = np.zeros((L,1))\n        \n            #for each column\n            for col in range(L):\n                obser_intercept = NCDFs_L[index,col] #get intercept of this NCDF\n                obser_rank = BetaRanks[index,col] #get rank of intercept for this NCDF\n        \n                #get nearest(by rank) fraction_WSS * 2 intercepts\n                if obser_rank - fraction_WSS < 0:\n                    bottom = 0\n                    top =  obser_rank + fraction_WSS + 1 - (obser_rank - fraction_WSS)\n                elif obser_rank + fraction_WSS + 1 > n:\n                    bottom = obser_rank - fraction_WSS - ((obser_rank + fraction_WSS + 1) - n)\n                    top =  n\n                else:\n                    bottom = obser_rank - fraction_WSS \n                    top = obser_rank + fraction_WSS + 1\n        \n                #sort only the gaps to the k_max * 2 nearest intercepts \n                gaps = np.sort(np.abs(BetaSorted[bottom:top,col] - obser_intercept))\n        \n                #get gaps for each Fraction\n                k_gaps[col,0] = gaps[fraction_WSS]\n        \n            #get largest gap matrix\n            score = np.amax(k_gaps, axis=0)\n            \n            return score\n\n  - `  def getBetaHist(NCDFs_L, BetaSorted, index) `\n    \n    <div class=\"desc\">\n    \n    Calculate the UNVAOIDS outlier score for a given sample using the\n    histogram method.\n    \n    ## Parameters\n    \n      - **`NCDFs_L`** : `numpy array` of `shape (n_samples, L_levels)`  \n        An array containing the intercepts for n NCDFs at L beta levels,\n        where `n_samples` is the number of samples and `L_levels` is the\n        number of beta levels.\n      - **`BetaSorted`** : `numpy array` of `shape (n_samples,\n        L_levels)`  \n        Rhe same as `NCDFs_L` but the intercepts are sorted along the L\n        beta levels (column-wise sort of NCDFs\\_L).\n      - **`index`** : ` int  `  \n        The row index of the NCDF in `NCDFs_L` which we are finding the\n        outlier score of.\n    \n    ## Returns\n    \n      - **`score`** : `numpy array` of `shape (1, 1)`  \n        The highest outlier score for `NCDF_L[index,:]` across all beta\n        levels.\n    \n    </div>\n    \n    <span>Expand source code</span>\n    \n        def getBetaHist(NCDFs_L, BetaSorted, index):\n        \n            \"\"\" \n            Calculate the UNVAOIDS outlier score for a given sample using\n            the histogram method.\n        \n            Parameters\n            ----------\n            NCDFs_L : numpy array of shape (n_samples, L_levels)\n                An array containing the intercepts for n NCDFs at L beta\n                levels, where `n_samples` is the number of samples and\n                `L_levels` is the number of beta levels.\n            BetaSorted : numpy array of shape (n_samples, L_levels)\n                Rhe same as `NCDFs_L` but the intercepts are sorted along\n                the L beta levels (column-wise sort of NCDFs_L).\n            index : int \n                The row index of the NCDF in `NCDFs_L` which we are\n                finding the outlier score of.\n        \n            Returns\n            ----------\n            score : numpy array of shape (1, 1)\n                The highest outlier score for `NCDF_L[index,:]` across\n                all beta levels.\n            \"\"\"\n        \n            n = NCDFs_L.shape[0] #number of NCDFs\n            L = NCDFs_L.shape[1] #number of Betas\n        \n            beta_max = 0 #the highest score of the beta levels\n        \n            n_bins = int(n * 0.05)\n            step = 1/n_bins\n            edges_s = np.arange(0,1.01,step)\n        \n            if type(NCDFs_L[0,0]) == Decimal:\n                step = Decimal(step)\n                edges_s = np.array([Decimal(i) for i in edges_s])\n            \n            for col in range(1, L-1):\n                obser_intercept = NCDFs_L[index,col] #intercept of observation\n                hrzntl = NCDFs_L[:,col]              #current beta level\n        \n                #center observation intercept in bin with width step\n                if obser_intercept < step: #avoid underflow errors\n                    n_le = 0\n                else:\n                    n_le = int(obser_intercept/step)\n        \n                edges = edges_s + ((obser_intercept - edges_s[n_le]) - (step/2))\n        \n                if edges[-1] > 1:\n                   edges = np.append([0.0], edges)\n                   edges[-1] = 1.01\n                   n_le += 1\n                elif edges[-1] < 1:\n                   edges = np.append(edges, [1.01])\n                   edges[0] = 0.0\n        \n                observed_bins = np.where(BetaSorted[:,col] > edges[1], np.minimum(((BetaSorted[:,col]-edges[1])/step).astype('int') + 1, len(edges)-2), 0)\n                u, c = np.unique(observed_bins, return_counts=True)\n                hist = np.zeros((len(edges)-1,))\n                hist[u] = c\n        \n                beta = np.sum(np.where(hist > hist[n_le], hist, 0))/n\n        \n                #compare with best score so far\n                if beta > beta_max:\n                    beta_max = beta\n        \n            return np.array(beta_max).reshape((1,1))\n\n  - `  def getNCDF(X, p, index) `\n    \n    <div class=\"desc\">\n    \n    Calculate the NCDF for a single sample using a specified norm.\n    \n    ## Parameters\n    \n      - **`X`** : `numpy array` of `shape (n_samples, m_features)`  \n        Data matrix, assumed to be min max scaled to \\[0,1\\], where\n        `n_samples` is the number of samples and `n_features` is the\n        number of features.\n      - **`p`** : `float` or `np.inf constant`  \n        The norm to use when calculating the distance between samples in\n        `X`. If np.inf is supplied, then Chebyshev distance is used.\n      - **`index`** : `int`  \n        The index of the sample in `X` which we are finding the NCDF of.\n        Assumed to be less than `n_samples`.\n    \n    ## Returns\n    \n      - **`NCDFxi`** : `numpy array` of ` shape (1, m_features)  `  \n        The NCDF of `X[i,:]` where i = `index` and the j-th value equals\n        NCDF\\_xi(j)\n    \n    </div>\n    \n    <span>Expand source code</span>\n    \n        def getNCDF(X, p, index):\n            \"\"\" \n            Calculate the NCDF for a single sample using a specified\n            norm.\n        \n            Parameters\n            ----------\n            X : numpy array of shape (n_samples, m_features)\n                Data matrix, assumed to be min max scaled to [0,1], where\n                `n_samples` is the number of samples and `n_features` is\n                the number of features.\n            p : float or np.inf constant\n                The norm to use when calculating the distance between\n                samples in `X`. If np.inf is supplied, then Chebyshev\n                distance is used.\n            index : int\n                The index of the sample in `X` which we are finding the\n                NCDF of. Assumed to be less than `n_samples`.\n        \n            Returns\n            ----------\n            NCDFxi : numpy array of shape (1, m_features) \n                The NCDF of `X[i,:]` where i = `index` and the j-th value equals\n                NCDF_xi(j)\n            \"\"\"\n        \n            n = X.shape[0]\n            d = X.shape[1]\n            \n            with warnings.catch_warnings():\n                try:\n                    warnings.filterwarnings('error')\n                    \n                    NCDFxi = np.zeros((1, n))  # matrix to hold NCDF\n                    \n                    if p == np.inf:\n                        NCDFxi[0,:] = ( np.max(np.abs(X[index,:]-X[:,:]), axis=1)) #calculate Chebyshev distance between sample X[i] and X[j != i]\n                    else:\n                        NCDFxi[0,:] = ( np.sum(np.abs(X[index,:]-X[:,:])**p, axis=1)**(1.0/float(p))) #calculate p-norm of samples X[i] and X[j != i]\n                \n                    #normalize by max volumne\n                    maxNorm = np.max(NCDFxi[0,:])\n                    if maxNorm  > 0: \n                        NCDFxi[0,:] = NCDFxi[0,:]/maxNorm     \n                \n                    NCDFxi = np.sort(NCDFxi, axis=1)\n        \n                except Warning as e:\n                    print(\"Warning: \"+str(e)+\" -> switching to from numpy to Decimal library implementation, expect speed decrease.\\n\\tAny further warnings mean results may be incorrect.\")\n                    \n                    NCDFxi = []  # array to hold NCDF\n                    \n                    for I in range(n):\n                        if p == np.inf:\n                            NCDFxi.append(( np.max(np.abs(X[index,:]-X[I,:])) )) #calculate Chebyshev distance between sample X[i] and X[j != i]\n                        else:\n                            NCDFxi.append(Decimal(( np.sum(np.abs(X[index,:]-X[I,:])**p)))**Decimal(1.0/float(p))) #/ (d**(1.0/p)) #calculate p-norm of samples X[i] and X[j != i] \n        \n                    #normalize by max volume\n                    maxNorm = max(NCDFxi)\n                    if maxNorm > 0:\n                        for I in range(n):\n                            NCDFxi[I] = NCDFxi[I]/maxNorm    \n                    \n                    NCDFxi = np.array(NCDFxi.sort()).reshape((1, n))\n            \n            return NCDFxi\n\n  - `  def unavoidsScore(X, precomputed=False, p=0.0625,\n    returnNCDFs=True, method='fractions', r=0.01, L=100, ncpus=4) `\n    \n    <div class=\"desc\">\n    \n    Calculate the UNVAOIDS outlier score for all samples in 'X'.\n    \n    ## Parameters\n    \n      - **`X`** : `numpy array` of `shape (n_samples, m_features)`  \n        Data matrix where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n      - **`precomputed`** : `bool`, default=`True`  \n        If True, `X` is assumed to be an NCDF array in the same format\n        as that returned by `getAllNCDFs()`.\n      - **`p`** : `float` or `np.inf constant`  \n        The norm to use when calculating the distance between samples in\n        `X`. If np.inf is supplied, then Chebyshev distance is used.\n      - **`returnNCDFs`** : `bool`, default=`True`  \n        If True, NCDF array is returned along with outlier scores.\n      - **`method`** : `{\"fractions\", \"histogram\"}`,\n        default=`\"fractions\"`  \n        Specifies which method to use for calculating outlier scores;\n        either \"fractions\" or \"histogram\".\n      - **`r`** : `float`  \n        Percentage of nearest intercepts to be encompassed by the gap\n        whose size will be the score for a given beta and NCDF intercept\n        in the \"fractions\" method. Ignored if `method` == \"histogram\".\n      - **`L`** : `int`  \n        The number of beta levels to use.\n      - **`ncpus`** : `int`  \n        The number of parallel processes to use.\n    \n    ## Returns\n    \n      - **`scores`** : `numpy array` of `shape (n_samples, 1)`  \n        The i-th element in scores is the UNAVOIDS outlier score for the\n        i-th sample(row) in `X`.\n      - **`NCDFs`** : `numpy array` of `shape (n_samples, n_samples)`  \n        The i-th row equals the NCDF for the i-th sample in `X`, while\n        the j-th column of the i-th row equals NCDF\\_xi(j). Only\n        returned if `returnNCDFs` == True.\n    \n    ## References\n    \n    .. \\[1\\] W. A. Yousef, I. Traore and W. Briguglio, (2021)\n    \"UN-AVOIDS: Unsupervised and Nonparametric Approach for Visualizing\n    Outliers and Invariant Detection Scoring\", IEEE Transactions on\n    Information Forensics and Security, vol. 16, pp. 5195-5210, \\[doi:\n    10.1109/TIFS.2021.3125608\\]\n    \n    ## Examples\n    \n        >>> import numpy as np\n        >>> from joblib import load\n        >>> from unavoids import unavoids\n        >>> from sklearn import metrics\n        >>>\n        >>> X_all = load(\"simData.joblib\")\n        >>> Y = np.zeros((X_all.shape[0],))\n        >>> Y[-3:] = 1         #last three samples are outliers\n        >>> X = X_all[:,:4]    #grab first 4 features\n        >>>\n        >>> scores, NCDFs = unavoids.unavoidsScore(X, p=0.0625, returnNCDFs=True, method=\"fractions\")\n        >>> fpr, tpr, thresholds = metrics.roc_curve(Y, scores)\n        >>> metrics.auc(fpr, tpr)\n        1.0\n    \n    </div>\n    \n    <span>Expand source code</span>\n    \n        def unavoidsScore(X, precomputed=False, p=0.0625, returnNCDFs=True, method=\"fractions\", r=0.01,  L=100, ncpus=4):\n        \n            \"\"\" \n            Calculate the UNVAOIDS outlier score for all samples in 'X'.\n        \n            Parameters\n            ----------\n            X : numpy array of shape (n_samples, m_features)\n                Data matrix where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            precomputed : bool, default=True\n                If True, `X` is assumed to be an NCDF array in the same\n                format as that returned by `getAllNCDFs`.\n            p : float or np.inf constant\n                The norm to use when calculating the distance between\n                samples in `X`. If np.inf is supplied, then Chebyshev\n                distance is used.\n            returnNCDFs : bool, default=True\n                If True, NCDF array is returned along with outlier\n                scores.\n            method : {\"fractions\", \"histogram\"}, default=\"fractions\"\n                Specifies which method to use for calculating outlier\n                scores; either \"fractions\" or \"histogram\".\n            r : float\n                Percentage of nearest intercepts to be encompassed by the\n                gap whose size will be the score for a given beta and\n                NCDF intercept in the \"fractions\" method. Ignored if\n                `method` == \"histogram\".\n            L : int\n                The number of beta levels to use.\n            ncpus : int\n                The number of parallel processes to use.\n        \n            Returns\n            ----------\n            scores : numpy array of shape (n_samples, 1)\n                The i-th element in scores is the UNAVOIDS outlier score\n                for the i-th sample(row) in `X`.\n            NCDFs : numpy array of shape (n_samples, n_samples)\n                The i-th row equals the NCDF for the i-th sample in `X`,\n                while the j-th column of the i-th row equals NCDF_xi(j).\n                Only returned if `returnNCDFs` == True.\n        \n            References\n            ----------\n            .. [1] W. A. Yousef, I. Traore and W. Briguglio, (2021)\n               \"UN-AVOIDS: Unsupervised and Nonparametric Approach for\n               Visualizing Outliers and Invariant Detection Scoring\",\n               IEEE Transactions on Information Forensics and Security,\n               vol. 16, pp. 5195-5210, [doi: 10.1109/TIFS.2021.3125608]\n        \n            Examples\n            --------\n            >>> import numpy as np\n            >>> from joblib import load\n            >>> from unavoids import unavoids\n            >>> from sklearn import metrics\n            >>>\n            >>> X_all = load(\"simData.joblib\")\n            >>> Y = np.zeros((X_all.shape[0],))\n            >>> Y[-3:] = 1         #last three samples are outliers\n            >>> X = X_all[:,:4]    #grab first 4 features\n            >>>\n            >>> scores, NCDFs = unavoids.unavoidsScore(X, p=0.0625, returnNCDFs=True, method=\"fractions\")\n            >>> fpr, tpr, thresholds = metrics.roc_curve(Y, scores)\n            >>> metrics.auc(fpr, tpr)\n            1.0\n            \"\"\"\n        \n            if precomputed == False:\n                NCDFs = getAllNCDFs(X, p)\n            else:\n                NCDFs = X\n        \n            WSS = NCDFs.shape[0]\n        \n            Lindexes = np.unique(np.append(np.floor(np.arange(0,L)*(WSS/L)), WSS-1).astype(int)) #indicies of beta levels \n            Fractions_WSS = int((r * WSS))  #convert percentage to portion of window size\n        \n            NCDFs_L = NCDFs[:, Lindexes] #for current norm, grab all NCDF intercepts with all L beta levels \n            BetaSorted = np.sort(NCDFs_L, axis=0) #sort intercepts along beta level\n            BetaRanks = np.argsort((np.argsort(NCDFs_L, axis=0)), axis=0) #get ranks of intercepts\n            \n            if method == \"fractions\":\n                #get score for each sample and all fractions using Fractions method\n                pool = mp.Pool(processes=ncpus)\n                func = partial(getBetaFractions, NCDFs_L, BetaSorted, BetaRanks, Fractions_WSS)\n                scores = np.array(pool.map(func, range(NCDFs_L.shape[0])))\n                pool.close()\n                pool.join()\n            \n            elif method == \"histogram\":\n                #get best beta using Histogram approaches\n                pool = mp.Pool(processes=ncpus)\n                func = partial(getBetaHist, NCDFs_L, BetaSorted)\n                scores = np.array(pool.map(func, range(0, NCDFs_L.shape[0])))\n                pool.close()\n                pool.join()\n        \n            if returnNCDFs == False:\n                return scores.reshape((NCDFs.shape[0], -1))\n            else:\n                return scores.reshape((NCDFs.shape[0], -1)), NCDFs\n\n</div>\n\n<div class=\"section\">\n\n</div>\n\n# Index\n\n<div class=\"toc\">\n\n</div>\n\n  - ### [Functions](#header-functions)\n    \n      - `getAllNCDFs`\n      - `getBetaFractions`\n      - `getBetaHist`\n      - `getNCDF`\n      - `unavoidsScore`\n\n</div>\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/isotlaboratory/UNAVOIDS-Code",
    "keywords": "",
    "license": "GNU GENERAL PUBLIC LICENSE",
    "maintainer": "",
    "maintainer_email": "",
    "name": "unavoids",
    "package_url": "https://pypi.org/project/unavoids/",
    "platform": null,
    "project_url": "https://pypi.org/project/unavoids/",
    "project_urls": {
      "Homepage": "https://github.com/isotlaboratory/UNAVOIDS-Code"
    },
    "release_url": "https://pypi.org/project/unavoids/1.4/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "",
    "version": "1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16376713,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "babdeca12a3d78ac1550e61c8cb4faa0cbdac5defd05b2194792e3cd8b134799",
          "md5": "278dcc15930b55a96117f8c96d3c64ff",
          "sha256": "c3a46ea15f75b1a676425b143088f1a37241801ad84856bb8632fed958b0ecd3"
        },
        "downloads": -1,
        "filename": "unavoids-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "278dcc15930b55a96117f8c96d3c64ff",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 8786,
        "upload_time": "2022-06-09T21:47:36",
        "upload_time_iso_8601": "2022-06-09T21:47:36.048713Z",
        "url": "https://files.pythonhosted.org/packages/ba/bd/eca12a3d78ac1550e61c8cb4faa0cbdac5defd05b2194792e3cd8b134799/unavoids-0.1.tar.gz",
        "yanked": true,
        "yanked_reason": null
      }
    ],
    "1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "689203220fa4306c3fb10d64e441bb98c24938c9b1a97555557f794049578480",
          "md5": "0133097c220866fb618796cdee8ab4b0",
          "sha256": "6dae7fa07f199395a99c812da56371d58547ca57f2eb65b599b752b0f410c93a"
        },
        "downloads": -1,
        "filename": "unavoids-1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0133097c220866fb618796cdee8ab4b0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21136,
        "upload_time": "2023-01-10T16:01:47",
        "upload_time_iso_8601": "2023-01-10T16:01:47.657135Z",
        "url": "https://files.pythonhosted.org/packages/68/92/03220fa4306c3fb10d64e441bb98c24938c9b1a97555557f794049578480/unavoids-1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1e3933330cf434a67d44b4fa9d84ef09d93ccccab0593c46aa325bca5cb7f967",
          "md5": "025e661c0d48dbe2b1cf003acc7a2101",
          "sha256": "f120a480df051ef8976e207ecb90ad18c6d119c8ab68223a0cf99f251b8a4132"
        },
        "downloads": -1,
        "filename": "unavoids-1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "025e661c0d48dbe2b1cf003acc7a2101",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18431,
        "upload_time": "2023-01-10T16:01:49",
        "upload_time_iso_8601": "2023-01-10T16:01:49.889310Z",
        "url": "https://files.pythonhosted.org/packages/1e/39/33330cf434a67d44b4fa9d84ef09d93ccccab0593c46aa325bca5cb7f967/unavoids-1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e98a77b528c75ba527f62bc1d403ca51b6df1dabe4c536996cc4274fd972a6bd",
          "md5": "da028aeaaf420a71f8cacb83532ab8a2",
          "sha256": "aa0231c29925acfd5f7935de54125f895cedfe92acf775dfd8676d40713d5e06"
        },
        "downloads": -1,
        "filename": "unavoids-1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "da028aeaaf420a71f8cacb83532ab8a2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21136,
        "upload_time": "2023-01-10T16:04:37",
        "upload_time_iso_8601": "2023-01-10T16:04:37.221393Z",
        "url": "https://files.pythonhosted.org/packages/e9/8a/77b528c75ba527f62bc1d403ca51b6df1dabe4c536996cc4274fd972a6bd/unavoids-1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e096a0a2405096cbb0686084ccba3844192eadb77179d1ad5f536ed4e504f2b4",
          "md5": "b2263a7f27cab8d2baee47168175ee30",
          "sha256": "69cbef4a0f003f3b1adce9d226038eb6eecf81387a0d7df8f8554293607933a9"
        },
        "downloads": -1,
        "filename": "unavoids-1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "b2263a7f27cab8d2baee47168175ee30",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18439,
        "upload_time": "2023-01-10T16:04:38",
        "upload_time_iso_8601": "2023-01-10T16:04:38.874736Z",
        "url": "https://files.pythonhosted.org/packages/e0/96/a0a2405096cbb0686084ccba3844192eadb77179d1ad5f536ed4e504f2b4/unavoids-1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a19a825f6999b475de722e1d5dffe864d1b786a7aafe8837e38bc05a3a759d7e",
          "md5": "2b6c9a9c86bfbf336e5c6a1f503f2349",
          "sha256": "d8ca2970746789ccac30dec2f88423bbbca4db5eac447a1946031c36d3757f41"
        },
        "downloads": -1,
        "filename": "unavoids-1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2b6c9a9c86bfbf336e5c6a1f503f2349",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 25261,
        "upload_time": "2023-01-10T16:05:45",
        "upload_time_iso_8601": "2023-01-10T16:05:45.592961Z",
        "url": "https://files.pythonhosted.org/packages/a1/9a/825f6999b475de722e1d5dffe864d1b786a7aafe8837e38bc05a3a759d7e/unavoids-1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "76e9a46b7d577a5da9dbef64220d1b6e4b37cca6d67d0d7dcfce31aaea8b93a6",
          "md5": "53bf6e55c0d3b7747f87241d94b64d18",
          "sha256": "571e3c89b4392375a96db9046793aa1b852e0556d16b9e005ee14c596010214a"
        },
        "downloads": -1,
        "filename": "unavoids-1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "53bf6e55c0d3b7747f87241d94b64d18",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 25049,
        "upload_time": "2023-01-10T16:05:47",
        "upload_time_iso_8601": "2023-01-10T16:05:47.236810Z",
        "url": "https://files.pythonhosted.org/packages/76/e9/a46b7d577a5da9dbef64220d1b6e4b37cca6d67d0d7dcfce31aaea8b93a6/unavoids-1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a19a825f6999b475de722e1d5dffe864d1b786a7aafe8837e38bc05a3a759d7e",
        "md5": "2b6c9a9c86bfbf336e5c6a1f503f2349",
        "sha256": "d8ca2970746789ccac30dec2f88423bbbca4db5eac447a1946031c36d3757f41"
      },
      "downloads": -1,
      "filename": "unavoids-1.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2b6c9a9c86bfbf336e5c6a1f503f2349",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 25261,
      "upload_time": "2023-01-10T16:05:45",
      "upload_time_iso_8601": "2023-01-10T16:05:45.592961Z",
      "url": "https://files.pythonhosted.org/packages/a1/9a/825f6999b475de722e1d5dffe864d1b786a7aafe8837e38bc05a3a759d7e/unavoids-1.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "76e9a46b7d577a5da9dbef64220d1b6e4b37cca6d67d0d7dcfce31aaea8b93a6",
        "md5": "53bf6e55c0d3b7747f87241d94b64d18",
        "sha256": "571e3c89b4392375a96db9046793aa1b852e0556d16b9e005ee14c596010214a"
      },
      "downloads": -1,
      "filename": "unavoids-1.4.tar.gz",
      "has_sig": false,
      "md5_digest": "53bf6e55c0d3b7747f87241d94b64d18",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 25049,
      "upload_time": "2023-01-10T16:05:47",
      "upload_time_iso_8601": "2023-01-10T16:05:47.236810Z",
      "url": "https://files.pythonhosted.org/packages/76/e9/a46b7d577a5da9dbef64220d1b6e4b37cca6d67d0d7dcfce31aaea8b93a6/unavoids-1.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}