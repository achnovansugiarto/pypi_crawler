{
  "info": {
    "author": "Nathanael Jöhrmann",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "GDEFReader\n==========\n.. image:: https://img.shields.io/pypi/v/GDEFReader.svg\n    :target: https://pypi.org/project/GDEFReader/\n\n.. image:: http://img.shields.io/:license-MIT-blue.svg?style=flat-square\n    :target: http://badges.MIT-license.org\n\n|\n\n.. figure:: https://github.com/natter1/gdef_reader/raw/master/docs/images/example_overview_image.png\n    :width: 800pt\n\n|\n\n\nTool to read \\*.gdf files (DME AFM)\n\nFeatures\n--------\n\n* import measurements from \\*.gdf file into python\n* create maps using matplotlib\n* analyze nanoindents\n* stich measurements\n* create customizable output (e.g. \\*.png or power point presentations)\n\n\n.. contents:: Table of Contents\n\nAPI documentation\n=================\nModule gdef_reader.gdef_importer\n--------------------------------\n\nclass GDEFImporter\n~~~~~~~~~~~~~~~~~~\nThis class is used to read data from a \\*.gdf file (DME AFM) into python. This can be done like:\n\n.. code:: python\n\n    from gdef_reader.gdef_importer import GDEFImporter\n    impported_data = GDEFImporter(gdf_path)  # gdf_path should be a pathlib.Path to a *.gdf file\n\n\n\n**Methods:**\n\n* **__init__**\n\n    .. code:: python\n\n        __init__(self, filename: Optional[pathlib.Path] = None)\n\n\n    :filename: Path to \\*.gdf file. If it is None (default), a file has to be loaded via GDEFImporter.load().\n\n* **export_measurements**\n\n    .. code:: python\n\n        export_measurements(self, path: pathlib.Path = None, create_images: bool = False) -> List[gdef_reader.gdef_measurement.GDEFMeasurement]\n\n    Create a list of GDEFMeasurement-Objects from imported data. The optional parameter create_images\n    can be used to show a matplotlib Figure for each GDEFMeasurement (default value is False).\n\n    :path: Save path for GDEFMeasurement-objects (and png's if create_images). No saved files, if None.\n\n    :create_images: Show a matplotlib Figure for each GDEFMeasurement; used for debugging (default: False)\n\n    :return: list of GDEFMeasurement-Objects\n\n* **load**\n\n    .. code:: python\n\n        load(self, filename: Union[str, pathlib.Path]) -> None\n\n    Import data from a \\*.gdf file.\n\n    :filename: Path to \\*.gdf file.\n\n    :return: None\n\n**Instance Attributes:**\n\n* basename: Path.stem of the imported \\*.gdf file.\n* bg_correction_type: BGCorrectionType for loaded measurements.\n* keep_z_offset: If False (default), z-values for each imported measurement are corrected so that mean(z) == 0.\n\nModule afm_tools.gdef_indent_analyzer\n-------------------------------------\n\nclass GDEFIndentAnalyzer\n~~~~~~~~~~~~~~~~~~~~~~~~\nClass to analyze a GDEFMeasurment with an indent.\n\n\n\n**Class Attributes:**\n\n* max_pixel_radius_value\n* pixel_radius_distance_matrix\n\n**Methods:**\n\n* **__init__**\n\n    .. code:: python\n\n        __init__(self, measurement: gdef_reader.gdef_measurement.GDEFMeasurement)\n\n\n    :measurement: GDEFMeasurement with the indent to analyze.\n\n* **add_map_with_indent_pile_up_mask_to_axes**\n\n    .. code:: python\n\n        add_map_with_indent_pile_up_mask_to_axes(self, ax: matplotlib.axes._axes.Axes, roughness_part=0.05) -> matplotlib.axes._axes.Axes\n\n    Add a topography map with a color mask for pile-up to the given ax. Pile-up is determined as all pixels with\n    z>0 + roughness_part \\* z_max\n\n    :ax: Axes object, to whitch the masked map should be added\n\n    :roughness_part:\n\n    :return: Axes\n\n* **get_summary_table_data**\n\n    .. code:: python\n\n        get_summary_table_data(self) -> List[list]\n\n    Returns a table (list of lists) with data of the indent. The result can be used directly to fill a pptx-table\n    with `python-ppxt-interface <https://github.com/natter1/python_pptx_interface/>`_.\n\n    :return:\n\nModule gdef_reader.gdef_measurement\n-----------------------------------\n\nclass GDEFMeasurement\n~~~~~~~~~~~~~~~~~~~~~\nClass containing data of a single measurement from \\*.gdf file.\n\n\n\n**Methods:**\n\n* **__init__**\n\n    .. code:: python\n\n        __init__(self)\n\n    Initialize self.  See help(type(self)) for accurate signature.\n\n* **correct_background**\n\n    .. code:: python\n\n        correct_background(self, correction_type: afm_tools.background_correction.BGCorrectionType = <BGCorrectionType.legendre_1: 3>, keep_offset: bool = False)\n\n    Corrects background using the given correction_type on values_original and save the result in values.\n    If keep_z_offset is True, the mean value of dataset is preserved. Otherwise the average value is set to zero.\n    Right now only changes topographical data. Also, the original data can be obtained again via\n    GDEFMeasurement.values_original.\n\n\n    :correction_type: select type of background correction\n\n    :keep_offset: If True (default) keeps average offset, otherwise average offset is reduced to 0.\n\n    :return: None\n\n* **create_plot**\n\n    .. code:: python\n\n        create_plot(self, max_figure_size=(4, 4), dpi=96, add_id: bool = False, trim: bool = True) -> matplotlib.figure.Figure\n\n    Returns a matplotlib figure of measurment data. If GDEFMeasurement.comment is not empty,\n    the comment is used as title. Otherwise a default title with the type of measurement data is created.\n\n    :max_figure_size: Max. figure size. The actual figure size might be smaller.\n\n    :dpi: dpi value for Figure\n\n    :add_id:\n\n    :trim:\n\n    :return: Figure\n\n* **get_summary_table_data**\n\n    .. code:: python\n\n        get_summary_table_data(self) -> List[list]\n\n    Create table data (list of list) summary of the measurement. The result can be used directly to fill a\n    pptx-table with `python-ppxt-interface <https://github.com/natter1/python_pptx_interface/>`_.\n\n* **load_from_pickle**\n\n    .. code:: python\n\n        load_from_pickle(filename: pathlib.Path) -> 'GDEFMeasurement'\n\n    Static method to load and return a measurement object using pickle. Take note, that pickle is not a save module\n    to load data. Make sure to only use files from trustworthy sources.\n\n\n    :filename:\n\n    :return: GDEFMeasurement\n\n* **save_as_pickle**\n\n    .. code:: python\n\n        save_as_pickle(self, filename)\n\n    Save the measurement object using pickle. This is useful for example, if the corresponding\n    \\*.gdf file contains a lot of measurements, but only a few of them are needed. Take note, that pickle is not\n    a save module to load data. Make sure to only use files from trustworthy sources.\n\n\n    :filename:\n\n    :return: None\n\n* **save_png**\n\n    .. code:: python\n\n        save_png(self, filename, max_figure_size=(4, 4), dpi: int = 300, transparent: bool = False)\n\n    Save a matplotlib.Figure of the measurement as a \\*.png.\n\n    :filename:\n\n    :max_figure_size: Max size of the Figure. The final size might be smaller in x or y.\n\n    :dpi: (default 300)\n\n    :transparent: Set background transparent (default False).\n\n    :return:\n\n* **set_topography_to_axes**\n\n    .. code:: python\n\n        set_topography_to_axes(self, ax: matplotlib.axes._axes.Axes, add_id: bool = False)\n\n    Sets the measurement data as diagram to a matplotlib Axes. If GDEFMeasurement.comment is not empty,\n    the comment is used as title. Otherwise a default title with the type of measurement data is created.\n\n    :ax: Axes object to witch the topography is written.\n\n    :add_id: Adds block_id before title text (default False)\n\n    :return: None\n\n**Instance Attributes:**\n\n* background_correction_type\n* comment: Comment text given for the measurement.\n* gdf_basename: Path.stem of the imported \\*.gdf file.\n* gdf_block_id: Block ID in original \\*.gdf file. Might be used to filter measurements.\n* name: Returns a name of the measurement created from original \\*.gdf filename and the gdf_block_id\n* pixel_width\n* preview\n* pygdf_filename\n* settings: GDEFSettings object\n* values_original: Original measurement data (read-only property)\n* values_original: Original measurement data (read-only property)\n\nclass GDEFSettings\n~~~~~~~~~~~~~~~~~~\nStores all the settings used during measurement.\n\n\n\n**Methods:**\n\n* **__init__**\n\n    .. code:: python\n\n        __init__(self)\n\n    Initialize self.  See help(type(self)) for accurate signature.\n\n* **pixel_area**\n\n    .. code:: python\n\n        pixel_area(self) -> float\n\n    Return pixel-area [m^2]\n\n* **shape**\n\n    .. code:: python\n\n        shape(self) -> Tuple[int, int]\n\n    Returns the shape of the scanned area (columns, lines). In case of aborted measurements, lines is reduced\n    by the number of missing lines.\n\n* **size_in_um_for_plot**\n\n    .. code:: python\n\n        size_in_um_for_plot(self) -> Tuple[float, float, float, float]\n\n    Returns the size of the scanned area as a tuple for use with matplotlib.\n\n**Instance Attributes:**\n\n* aux_gain\n* bias_voltage\n* calculated\n* columns\n* digital_loop\n* direct_ac\n* fft_type\n* fixed_max\n* fixed_min\n* fixed_palette\n* frequency_offset\n* id\n* invert_line_mean\n* invert_plane_corr\n* line_mean_order\n* line_mean_order\n* lines: total number of scan lines (including missing lines)\n* loop_filter\n* loop_gain\n* loop_int\n* max_height: scan area height [m]\n* max_width: scan area width [m]\n* measured_amplitude\n* missing_lines: number of missing lines (e.g. due to aborted measurement)\n* offset_pos\n* offset_x\n* offset_y\n* phase_shift\n* pixel_blend\n* pixel_height: Pixel-height [m] (read-only property)\n* pixel_width: Pixel-width [m] (read-only property)\n* q_boost\n* q_factor\n* retrace_type\n* retrace_type\n* scan_direction\n* scan_mode\n* scan_speed: [Âµm/s]\n* scanner_range\n* set_point\n* source_channel\n* x_calib\n* xy_linearized\n* y_calib\n* z_calib\n* z_linearized\n* z_unit\n* zero_scan\n\nModule afm_tools.gdef_sticher\n-----------------------------\n\nclass GDEFSticher\n~~~~~~~~~~~~~~~~~\nGDEFSticher combines/stiches several AFM area-measurements using cross-corelation to find the best fit.\nTo reduce calculation time, the best overlap position is only searched in a fraction of the measurement area\n(defined by parameter initial_x_offset_fraction), and each measutrement is added to the right side.\nMake sure the given list of measurements is ordered from left to right, otherwise wrong results are to be expected.\nTo evaluate the stiching, show_control_figures can be set to True. This creates a summary image\nfor each stiching step (using matplotlib plt.show()).\n\n\n\n**Methods:**\n\n* **__init__**\n\n    .. code:: python\n\n        __init__(self, measurements: List[gdef_reader.gdef_measurement.GDEFMeasurement], initial_x_offset_fraction: float = 0.35, show_control_figures: bool = False)\n\n\n    :measurements:\n\n    :initial_x_offset_fraction: used to specify max. overlap area, thus increasing speed and reducing risk of wrong stiching\n\n    :show_control_figures:\n\n* **stich**\n\n    .. code:: python\n\n        stich(self, initial_x_offset_fraction: float = 0.35, show_control_figures: bool = False) -> numpy.ndarray\n\n    Stiches a list of GDEFMeasurement.values using cross-correlation.\n\n    :initial_x_offset_fraction: used to specify max. overlap area, thus increasing speed and reducing risk of wrong stiching\n\n    :return: stiched np.ndarray\n\nModule afm_tools.background_correction\n--------------------------------------\n\n**Functions:**\n\n* **correct_background**\n\n    .. code:: python\n\n        correct_background(array2d: numpy.ndarray, correction_type: afm_tools.background_correction.BGCorrectionType, keep_offset: bool = False) -> Optional[numpy.ndarray]\n\n    Returns a numpy.ndarray with corrections given by parameters. Input array2d is not changed.\n\n\n    :array2d:\n\n    :correction_type:\n\n    :keep_offset:\n\n    :return: ndarray\n\n* **subtract_legendre_fit**\n\n    .. code:: python\n\n        subtract_legendre_fit(array2d: numpy.ndarray, keep_offset: bool = False, deg: int = 1) -> Optional[numpy.ndarray]\n\n    Use a legendre polynomial fit of degree legendre_deg in X and Y direction to correct background.\n    legendre_deg = 0 ... subtract mean value\n    legendre_deg = 1 ... subtract mean plane\n    legendre_deg = 2 ... subtract simple curved mean surface\n    legendre_deg = 3 ... also corrects \"s-shaped\" distortion\n    ...\n\n* **subtract_mean_gradient_plane**\n\n    .. code:: python\n\n        subtract_mean_gradient_plane(array2d: numpy.ndarray, keep_offset: bool = False) -> Optional[numpy.ndarray]\n\n    Returns 2d numpy.ndarray with subtracted mean gradient plane from given array2d. Using the gradient might give\n     better results, when the measurement has asymmetric structures like large objects on a surface.\n\n* **subtract_mean_level**\n\n    .. code:: python\n\n        subtract_mean_level(array2d: numpy.ndarray) -> numpy.ndarray\n\n    Correct an offset in the array2d by subtracting the mean level.\n\n    :array2d:\n\n    :return: ndarray\n\nclass BGCorrectionType\n~~~~~~~~~~~~~~~~~~~~~~\n.. figure:: https://github.com/natter1/gdef_reader/raw/master/docs/images/BGCorrectionType_example01.png\n    :width: 800pt\n\n**Class Attributes:**\n\n* gradient\n* legendre_0\n* legendre_1\n* legendre_2\n* legendre_3\n* raw_data\n\nModule gdef_reporter.plotter_utils\n----------------------------------\n\n**Functions:**\n\n* **best_ratio_fit**\n\n    .. code:: python\n\n        best_ratio_fit(total_size: 'tuple[float, float]', single_size: 'tuple[float, float]', n: 'int') -> 'tuple[int, int]'\n\n    Find best ratio of rows and cols to show n axes of ax_size on Figure with total_size.\n\n    :total_size: total size available for n axes\n\n    :single_size: size of one axes\n\n    :n: number of axes to plot on total size\n\n    :return: best ratio (rows and cols)\n\n* **create_plot**\n\n    .. code:: python\n\n        create_plot(data_object: 'DataObject', pixel_width: 'float' = None, title: 'str' = '', max_figure_size: 'tuple[float, float]' = (4, 4), dpi: 'int' = 96, cropped: 'bool' = True) -> 'Figure'\n\n    Creates a matplotlib Figure using given data_object. If cropped is True, the returned Figure has a smaller size\n    than specified in max_figure_size.\n\n    :data_object: DataObject with surface data\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :title: optional title (implemented as Figure suptitle)\n\n    :max_figure_size: Max. figure size of returned Figure (actual size might be smaller if cropped).\n\n    :dpi: dpi value of returned Figure\n\n    :cropped: Crop the result Figure (default is True). Useful if aspect ratio of Figure and plot differ.\n\n    :return: Figure\n\n* **create_rms_plot**\n\n    .. code:: python\n\n        create_rms_plot(data_object_list: 'DataObjectList', pixel_width=None, label_list: 'Union[str, list[str]]' = None, title: 'str' = '', moving_average_n: 'int' = 200, x_offset=0, x_units: \"Literal['Âµm', 'nm']\" = 'Âµm', subtract_average=True, plotter_style: 'PlotterStyle' = None) -> 'Figure'\n\n    Creates a matplotlib figure, showing a graph of the root mean square roughness per column.\n\n    :data_object_list: DataObjectList\n\n    :pixel_width: has to be set, if data_object_list contains 1 or more np.ndarry (for varying values, use a list)\n\n    :label_list: List with labels (str) for legend entries. If data_object_list is a dict, the keys are used.\n\n    :title: Optional Figure title\n\n    :moving_average_n: Number of columns to average over\n\n    :x_offset: move data along x-axis\n\n    :x_units: unit for x-axis (Âµm or nm)\n\n    :subtract_average: Subtract average for each average_window (it might be better to subtract a global average)\n\n    :plotter_style: PlotterStyle to format Figure-object (default: None -> use default format)\n\n    :return: Figure\n\n* **create_rms_with_error_plot**\n\n    .. code:: python\n\n        create_rms_with_error_plot(data_object_list: 'DataObjectList', pixel_width=None, label_list: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', average_n: 'int' = 8, x_units: \"Literal['px', 'Âµm', 'nm']\" = 'Âµm', y_units: \"Literal['Âµm', 'nm']\" = 'Âµm', plotter_style: 'PlotterStyle' = None) -> 'Figure'\n\n    Create a diagram, showing the root mean square roughness per column in for data in data_object_list.\n    The error-bars are calculated as standard deviation of columns (average_n) used per data point.\n\n    :data_object_list: DataObjectList\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :label_list: List with labels (str) for legend entries. If data_object_list is a dict, the keys are used.\n\n    :title: Optional Figure title\n\n    :average_n: Number of columns to average over\n\n    :x_units: unit for x-axis (Âµm or nm)\n\n    :y_units:\n\n    :plotter_style: PlotterStyle to format Figure-object (default: None -> use default format)\n\n    :return: None\n\n* **create_summary_plot**\n\n    .. code:: python\n\n        create_summary_plot(data_object_list: 'DataObjectList', pixel_width: 'Optional[float]' = None, ax_title_list: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', figure_size: 'tuple[float, float]' = (16, 10), dpi: 'int' = 96) -> 'Figure'\n\n    Creates a Figure with area-plots for each DataObject in data_object_list. Automatically determines best number of\n    rows and cols. Works best, if all area-plots have the same aspect ratio.\n\n    :data_object_list: DataObjectList\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :ax_title_list: Optional tiles for subplots\n\n    :title: Figure title\n\n    :figure_size:\n\n    :dpi:\n\n    :return: Figure\n\n* **create_z_histogram_plot**\n\n    .. code:: python\n\n        create_z_histogram_plot(data_object_list: 'DataObjectList', pixel_width=None, labels: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', n_bins: 'int' = 200, units: \"Literal['Âµm', 'nm']\" = 'Âµm', add_norm: 'bool' = False, plotter_style: 'PlotterStyle' = None) -> 'Figure'\n\n    Also accepts a list of np.ndarray data (for plotting several histograms stacked)\n\n    :data_object_list: DataObjectList\n\n    :labels: labels for plotted data from values2d\n\n    :title: Figure title; if empty, mu and sigma will be shown as axes subtitle(use title=None to prevent this)\n\n    :n_bins: number of equally spaced bins for histogram\n\n    :units: Can be set to Âµm or nm (default is Âµm).\n\n    :add_norm: if True (default), show normal/gaussian probability density function for each distribution\n\n    :plotter_style: PlotterStyle to format Figure-object (default: None -> use default format)\n\n    :return: Figure\n\n* **plot_rms_to_ax**\n\n    .. code:: python\n\n        plot_rms_to_ax(ax: 'Axes', data_object_list: 'DataObjectList', pixel_width=None, label_list: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', moving_average_n: 'int' = 200, x_offset=0, x_units: \"Literal['Âµm', 'nm']\" = 'Âµm', subtract_average=True, plotter_style=None) -> 'None'\n\n    Plot a diagram to ax, showing a the root mean square roughness per column in for data in data_object_list.\n\n    :ax: Axes object to which the surface should be written\n\n    :data_object_list: DataObjectList\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :label_list: List with labels (str) for legend entries. If data_object_list is a dict, the keys are used.\n\n    :title: Optional axes title\n\n    :moving_average_n: Number of columns to average over\n\n    :x_offset: move data along x-axis\n\n    :x_units: unit for x-axis (Âµm or nm)\n\n    :subtract_average: Subtract average for each average_window (it might be better to subtract a global average)\n\n    :plotter_style: PlotterStyle to format Figure-object (default: None -> use default format)\n\n    :return: None\n\n* **plot_rms_with_error_to_ax**\n\n    .. code:: python\n\n        plot_rms_with_error_to_ax(ax: 'Axes', data_object_list: 'DataObjectList', pixel_width=None, label_list: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', average_n: 'int' = 8, x_units: \"Literal['px', 'Âµm', 'nm']\" = 'Âµm', y_units: \"Literal['Âµm', 'nm']\" = 'Âµm', plotter_style: 'PlotterStyle' = None)\n\n    Plot a diagram to ax, showing the root mean square roughness per column in for data in data_object_list.\n    The error-bars are calculated as standard deviation of columns (average_n) used per data point.\n\n    :ax: Axes object to which the surface should be written\n\n    :data_object_list: DataObjectList\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :label_list: List with labels (str) for legend entries. If data_object_list is a dict, the keys are used.\n\n    :average_n: Number of columns to average over\n\n    :x_units: unit for x-axis (Âµm or nm)\n\n    :y_units:\n\n    :plotter_style: PlotterStyle to format Figure-object (default: None -> use default format)\n\n    :return: None\n\n* **plot_to_ax**\n\n    .. code:: python\n\n        plot_to_ax(ax: 'Axes', data_object: 'DataObject', pixel_width: 'float' = None, title: 'str' = '', z_unit: \"Literal['nm', 'Âµm']\" = 'nm') -> 'None'\n\n    Plot values in data_object to given ax.\n\n    :ax: Axes object to which the surface should be written\n\n    :data_object: DataObject with surface data\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :title: Axes title (if '' -> shows mu and sigma (default); for no title set None)\n\n    :z_unit: Units for z-Axis (color coded)\n\n    :return: None\n\n* **plot_z_histogram_to_ax**\n\n    .. code:: python\n\n        plot_z_histogram_to_ax(ax: 'Axes', data_object_list: 'DataObjectList', pixel_width: 'Optional[Union[float, list[float]]]' = None, label_list: 'Union[str, list[str]]' = None, title: 'Optional[str]' = '', n_bins: 'int' = 200, units: \"Literal['Âµm', 'nm']\" = 'Âµm', add_norm: 'bool' = False, plotter_style=None) -> 'None'\n\n    Also accepts a list of np.ndarray data (for plotting several histograms stacked)\n\n    :ax: Axes object to which the surface should be written\n\n    :data_object_list: DataObject or list[DataObject] with surface data\n\n    :pixel_width: Pixel width/height in [m] (only used, if data_object has no pixel_width attribute)\n\n    :label_list: labels for plotted data from values2d\n\n    :title: Axes title; if empty, mu and sigma will be shown; to prevent any subtitle, set title=None\n\n    :n_bins: number of equally spaced bins for histogram\n\n    :units: Can be set to Âµm or nm (default is Âµm).\n\n    :add_norm: if True (default), show normal/gaussian probability density function for each distribution\n\n    :plotter_style: PlotterStyle to format Axes-object (default: None -> use default format)\n\n    :return: None\n\n* **save_figure**\n\n    .. code:: python\n\n        save_figure(figure: 'Figure', output_path: 'Path', filename: 'str', png: 'bool' = True, pdf: 'bool' = False) -> 'None'\n\n    Helper function to save a matplotlib figure as png and or pdf. Automatically creates output_path, if necessary.\n    Does nothing if given output_path is None.\n\n* **split_dict_in_data_and_label_list**\n\n    .. code:: python\n\n        split_dict_in_data_and_label_list(data_dict_list: 'dict[str:DataObject]')\n\n    deprecated\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/natter1/gdef_reader",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "GDEFReader",
    "package_url": "https://pypi.org/project/GDEFReader/",
    "platform": "",
    "project_url": "https://pypi.org/project/GDEFReader/",
    "project_urls": {
      "Homepage": "https://github.com/natter1/gdef_reader"
    },
    "release_url": "https://pypi.org/project/GDEFReader/0.0.1a41/",
    "requires_dist": [
      "matplotlib",
      "numpy",
      "scipy"
    ],
    "requires_python": ">=3.9",
    "summary": "Tool to read/process *.gdf AFM measurement files",
    "version": "0.0.1a41",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10244561,
  "releases": {
    "0.0.1a39": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a8a912842c0c07573421216d8d13d579562eef16d1466f93aa3686fff22797f8",
          "md5": "0cd622921510257aeeb993c8892cbab2",
          "sha256": "76011e2cd91003d7e7139def53a71fdaf59451f9b778a40193ca36776f06e6ae"
        },
        "downloads": -1,
        "filename": "GDEFReader-0.0.1a39-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0cd622921510257aeeb993c8892cbab2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28527,
        "upload_time": "2021-03-29T22:18:33",
        "upload_time_iso_8601": "2021-03-29T22:18:33.472183Z",
        "url": "https://files.pythonhosted.org/packages/a8/a9/12842c0c07573421216d8d13d579562eef16d1466f93aa3686fff22797f8/GDEFReader-0.0.1a39-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.1a40": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9acad47afcdf70ddf4192083a5a83ca22cf630a99073a1ec481601ca6d2ab297",
          "md5": "e0b75cb4450ce549a050ff5d886a003d",
          "sha256": "acb0374a711f58f27c395cc4062d58009eed9b69faf4f7314f7c4b552290c6ab"
        },
        "downloads": -1,
        "filename": "GDEFReader-0.0.1a40-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e0b75cb4450ce549a050ff5d886a003d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 39729,
        "upload_time": "2021-04-26T11:10:46",
        "upload_time_iso_8601": "2021-04-26T11:10:46.355727Z",
        "url": "https://files.pythonhosted.org/packages/9a/ca/d47afcdf70ddf4192083a5a83ca22cf630a99073a1ec481601ca6d2ab297/GDEFReader-0.0.1a40-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.1a41": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5f39c8b719f1864e9b073fc88ab8df7b341f30826619bb29b3380ce45c00de81",
          "md5": "b16ddc86dc94821d0a9b5a7f728e0734",
          "sha256": "fe44fa244a79d6858a37da45071945f5d74195623306ad94a1d3cfeb26a9c1e1"
        },
        "downloads": -1,
        "filename": "GDEFReader-0.0.1a41-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b16ddc86dc94821d0a9b5a7f728e0734",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 42179,
        "upload_time": "2021-05-03T21:56:43",
        "upload_time_iso_8601": "2021-05-03T21:56:43.839551Z",
        "url": "https://files.pythonhosted.org/packages/5f/39/c8b719f1864e9b073fc88ab8df7b341f30826619bb29b3380ce45c00de81/GDEFReader-0.0.1a41-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5f39c8b719f1864e9b073fc88ab8df7b341f30826619bb29b3380ce45c00de81",
        "md5": "b16ddc86dc94821d0a9b5a7f728e0734",
        "sha256": "fe44fa244a79d6858a37da45071945f5d74195623306ad94a1d3cfeb26a9c1e1"
      },
      "downloads": -1,
      "filename": "GDEFReader-0.0.1a41-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "b16ddc86dc94821d0a9b5a7f728e0734",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.9",
      "size": 42179,
      "upload_time": "2021-05-03T21:56:43",
      "upload_time_iso_8601": "2021-05-03T21:56:43.839551Z",
      "url": "https://files.pythonhosted.org/packages/5f/39/c8b719f1864e9b073fc88ab8df7b341f30826619bb29b3380ce45c00de81/GDEFReader-0.0.1a41-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}