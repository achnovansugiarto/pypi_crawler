{
  "info": {
    "author": "Jeremy COMBES",
    "author_email": "jeremy.combes0902@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# Guitool\n\n![](https://img.shields.io/badge/Coverage-97%25-green)\n![](https://img.shields.io/badge/Version-v0.1.3-blue)\n![](https://img.shields.io/badge/Licence-MIT-red)\n\n--------------------------------------------------\n-------------------------------------------------\n\n## Installation\nTo install it, just use pip :\n````\npip install guitool\n````\n\n----------------------------------------------------\n\n## Description\nGuitool is an open source package based on the Tkinter canvas. It offers tools and widgets already formed and linked to allow to quickly create interfaces.\n\n-----------------------------------------------------\n\n## Link\nGitHub : https://github.com/Walrick/gui_tool\n\n-----------------------------------------------------\n\n## Use - Tutorial\nThe package was developed with the idea that a graphical object can be written simply in a template and can be updated with a single method.\nThe package is based on the use of Tkinter's canvas.\nThe graphic objects called here widgets are basically modeled on the widgets of the tkinter canvas.\nBut they were linked from the base to the action of the user, for example: when creating a rectangle, we can define a different color for it if the cursor passes over it or / and link an action to it if we have it click on it.\nThe tk_gui_tools package handles the creation of the tkinter environment and the mainloop () but it is necessary to prepare some files.\n\nStart by creating a settings.py file and pasting the following variables into it:\nThe screen dictionary is used to configure the desired window.\n\n````\n# Default settings screen\nscreen = {\n    \"screensize\": \"1920x1080\",\n    \"fullscreen\": False,\n    \"title\": \"Python Project\",\n    \"resizable\": {\"height\": True, \"width\": True},\n}\n````\n\nThe Boolean variable default_template is used to configure the first template to display.\nIf you wanted to use the default template which is called dashboard and which serves as a small example, put True instead of False.\n\n````\n# True is use default template in first\ndefault_template = True\n````\n\nA variable refresh allows you to set the after () method of tkinter, its value is expressed in ms\n\n````\n# set time refresh in ms\nrefresh = 200\n````\n\nTo be able to integrate the logic of your application, we propose this way of doing things:\n\n````\nracine\n|-app.py\n|-README.md\n|-.env\n|-requirements.txt\n|- core\n    |- __init__.py\n    |- master.py\n    |- settings.py\n    |- gui\n    |    |- __init__.py\n    |    |- template_manager.py\n    |    |- template\n    |          |- __init__.py\n    |          |- first_template.py\t\n    |    \n    |- logic_app\n\t    |- __init__.py\n\t\t|- master_logic.py\t\n\t\tetc...\n````\n\nThe settings.py file was described above, we will see master.py\n\nmaster.py\n````\nfrom tk_gui_tools.main import Main\n\nimport core.gui.template_manager as template_manager\nimport core.settings as settings\nimport core.logic_app.master_logic as master_logic\n\nclass Master(Main):\n\n    def __init__(self, *args):\n\n        Main.__init__(self, args, settings=settings)\n\n        self.master_app = master_logic.MasterLogic()\n\t\t\n        self.template = template_manager.TemplateGUI(self.window, self.default_template, self.master_app)\n\n````\nThe Master class inherits from the Main class of tk_gui_tools which allows Tkinter to be initialized.\nThe argument args passed to the init of Main are any commands received at launch by app.py and settings is the configuration file established above.\nSelf.master_app allows you to launch the logic of your application, here we take the example of Master_logic is a class.\nA thread can be used to launch your application, if so, Tkinter's thread must be the first, otherwise your application will crash.\nSelf.template allows you to initiate the gui of your program, it is necessary to give it as arguments \"self.window\" and self.default_template, the latter will depend on your application logic.\n\nThe next file is ultimately optional if you are only using a single template and want to use the default template. Otherwise, it will be necessary to add a few lines:\n\ntemplate_manager.py\n````\nfrom tk_gui_tools.template_manager import Template\n\nimport core.gui.template.first_template as first_template\n\n\nclass TemplateGUI(Template):\n\n    def __init__(self, window, default_template, master_app):\n        Template.__init__(self, window, default_template)\n        self.master_app = master_app\n        self.active_template = first_template.FirstTemplate(self.window, self.master_app)\n\n    def draw_first_template(self):\n        self.active_template = first_template.FirstTemplate(self.window, self.master_app)\n\n````\n\nThis class is used to manage templates.\nSelf.active_template allows you to display the current template.\nWe can add new template by adding methods and in the method by specifying the new active template with self.active_template\n\nThe last file to add is the template itself.\nIn our example, first_template.py\t\n````\n# HÃ©ritage\nfrom tk_gui_tools.template.base import Base\n\n\nclass FirstTemplate(Base):\n\n    def __init__(self, window, master_app):\n        # Init Base Template HÃ©ritage\n        Base.__init__(self, window)\n\t\t\n        self.template_name = \"First Template\"\n        self.master_app = master_app\n\n        # Create Canvas title\n        self.title = self.canvas.create_text(50, 50, text=\"First Template\", anchor=\"w\")\n\n        # Create button quit\n        self.button_quit = self.manage.create_rectangle(\n            50,\n            100,\n            100,\n            150,\n            text=\"quit\",\n            fill=\"white\",\n            fill_mouse=\"red\",\n            command=(\"<Button-1>\", self.quit_gui),\n        )\n\n        # Create round\n        self.round_test = self.manage.create_round(\n            200, 200, 250, 250, fill=\"red\", fill_mouse=\"green\"\n        )\n\n        # Create text\n        self.text_test = self.manage.create_text(500, 500, text=\"test\", fill=\"black\")\n\t\n    def update(self):\n        \"\"\"\n        Update the template\n        \"\"\"\n\n        self.canvas.update_idletasks()\n\t\t\n        if self.round_test.active_focus:\n            self.text_test.update(text=\"test ok\", fill=\"red\")\n        else:\n            self.text_test.update(text=\"test\", fill=\"black\")\n\t\t\n````\n\nOur template needs to inherit from Base and to initialize by giving it the window argument, then we don't have to use widgets to display what we want.\nThe guitool widgets are accessible through the manage class which is initialized by inheriting from Base.\nNote also that it is possible to use Tkinter widgets as in the example of self.title using self.canvas.create_text (... etc).\nThe widgets of tk_gui_tools called with self.manage.create_rectangle, for example, are described in the Widget section.\nIt is possible to update the template thanks to the update () method, the time defined in refresh will be used to call update (), if refresh is set to 200 ms, update () will be called every 200 ms.\n\n---------------------------------\n## Widget\nThe widgets of tk_gui_tools are widgets which are based on those of tkinter.\nCurrently, rectangle, oval, and text are implemented. Button and Menu are graphic assemblies of the first three widgets.\n\n### Rectangle\nThe rectangles are created from the template. You have to instantiate the class from the template by giving it several parameters to have the desired effect.\nThe class returns an object.\n\n````\nself.rectange = self.manage.create_rectangle(x1, y1, x2, y2)\n```` \n\nWe can then have access to its attribute self.rectange.active_focus if the mouse passes over it.\nYou can also call the update method described below.\n\t\t\n#### Mandatory arguments\n\nThe method to call the rectangle is as follows: self.manage.create_rectangle (x1, y1, x2, y2). This is the minimum code to create a rectangle.\n\nThe points x1 and y1 correspond to the beginning of the rectangle at the top left and x2 and y2 correspond to the point at the bottom left\n````\n:param x1: int \n:param y1: int\n:param x2: int\n:param y2: int\n````\n\n#### Optional arguments\n\nCreate_rectangle can take other arguments with kwargs, and they are all optional.\n\n##### fill\n\nFill allows you to fill the rectangle with a color, the color supported is the same as tkinter, you can write \"red\" or its hex format \"# FF0000\".\nThe default color is \"gray\" if not specified.\n````\nself.manage.create_rectangle(x1, y1, x2, y2, fill=\"red\")\n\nor\n\nself.manage.create_rectangle(x1, y1, x2, y2, fill=\"#FF0000\")\n````\n\n##### fill_mouse\n\nFill_mouse allows to change the color when the mouse passes over it, its operation is the same as fill.\nThe default color is the fill color.\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, fill_mouse=\"red\")\n\nor\n\nself.manage.create_rectangle(x1, y1, x2, y2, fill_mouse=\"#FF0000\")\n````\n\n##### width\n\nWidth allows you to choose the thickness of the border. Set to 0 to deactivate\nBy default, the value is 1.\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, width=0)\n\n````\n\n##### text\n\nText displays text in the rectangle.\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\")\n\n````\n\n##### anchor\n\nAnchor allows you to position the text in the rectangle.\nCurrently, the only position is the default position, the center.\n````\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\", anchor=\"center\")\n\n````\n\n##### text_fill\n\nText_fill allows you to give a color to the text, the default color is black.\nColor works the same as fill.\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\", fill_text=\"red\")\n\nor\n\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\", fill_text=\"#FF0000\")\n````\n\n##### text_fill_mouse\n\nText_fill_mouse allows to change the color of the text when the mouse passes over the rectangle.\nThe default color is text_fill.\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\", text_fill_mouse=\"red\")\n\nor\n\nself.manage.create_rectangle(x1, y1, x2, y2, text=\"test text\", text_fill_mouse=\"#FF0000\")\n````\n\n##### command\n\nCommand allows you to give an action when you click on the rectangle.\n````\nself.manage.create_rectangle(x1, y1, x2, y2, command=(\"<Button-1>\", self.quit_gui))\n\n````\nIn the example above, the first argument of the tuple is the action to be done on the rectangle, here a left mouse click will activate self.quit_gui.\nThe syntax is the same as tkinter and for more information refer to the commands chapter.\nCommand can take several actions, to do so, add the other two arguments to the tuple, action - command following. \nExample :\n\n````\nself.manage.create_rectangle(x1, y1, x2, y2, command=(\"<Button-1>\", self.quit_gui, \"<Double-Button-1>\", self.quit_gui))\n\n````\nHere as in the first example, the left click will activate the self.quit_gui command but also, the double left click.\n\n##### relief\n\nRelief is used to display a relief. It makes a black line appear under the rectangle and to the right of the rectangle.\n````\nself.manage.create_rectangle(x1, y1, x2, y2, relief=True)\n\n````\n\n#### Methode update()\n\nThe update method allows you to update certain attributes of the class which are initiated when it is created.\nThe arguments are fill and fill_mouse at the moment.\n\nIn the init of the template:\n````\nself.rectangle = self.manage.create_rectangle(x1, y1, x2, y2, fill=\"red\")\n\n````\n\nIn the update () method of the template:\n````\nself.rectangle.update(fill=\"green\")\n\n````\n\n### Round\n\nTo create ovals, as for rectangles, you have to instantiate the class from the template by giving it several parameters to have the desired effect.\nThe class returns an object.\n\n````\nself.round = self.manage.create_round(x1, y1, x2, y2)\n```` \n\nWe can then have access to its attribute self.round.active_focus if the mouse passes over it.\nYou can also call the update method described below.\n\n#### Mandatory arguments\n\nThe method to call the oval is: self.manage.create_round (x1, y1, x2, y2). This is the minimal code to create an oval.\n\nThe method to create an oval is the same as with tkinter, we place a rectangle, or an oval will be created.\nThe points x1 and y1 correspond to the beginning of the oval at the top left and x2 and y2 correspond to the point at the bottom left.\n````\n:param x1: int \n:param y1: int\n:param x2: int\n:param y2: int\n````\n\n#### Optional arguments\nCreate_round can take other arguments with kwargs, and they are all optional.\n\n\n##### fill\n\nFill allows to fill with a color of the oval, the supported color is the same as tkinter, we can write \"red\" or its format in hex \"# FF0000\".\nThe default color is \"gray\" if not specified.\n\n````\nself.manage.create_round(x1, y1, x2, y2, fill=\"red\")\n\nor\n\nself.manage.create_round(x1, y1, x2, y2, fill=\"#FF0000\")\n````\n\n##### fill_mouse\n\nFill_mouse allows to change the color when the mouse passes over it, its operation is the same as fill.\nThe default color is the fill color.\n\n````\nself.manage.create_round(x1, y1, x2, y2, fill_mouse=\"red\")\n\nor\n\nself.manage.create_round(x1, y1, x2, y2, fill_mouse=\"#FF0000\")\n````\n\n##### width\n\nWidth allows you to choose the thickness of the border. Set to 0 to deactivate\nBy default, the value is 1.\n\n````\nself.manage.create_round(x1, y1, x2, y2, width=0)\n\n````\n\n##### square_fill\n\n\nSquare_fill allows you to fill the rectangle obtained with the two construction points with a color. The supported color is the same as tkinter, you can write \"red\" or its hex format \"# FF0000\".\nThe default color is None if not specified and therefore transparent.\n\n````\nself.manage.create_round(x1, y1, x2, y2, square_fill=\"red\")\n\nor\n\nself.manage.create_round(x1, y1, x2, y2, square_fill=\"#FF0000\")\n````\n\n##### square_fill_mouse\n\nSquare_fill_mouse allows to change the color when the mouse passes over it, its operation is the same as Square_fill.\nThe default color is the color of Square_fill.\n\n````\nself.manage.create_round(x1, y1, x2, y2, fill_mouse=\"red\")\n\nor\n\nself.manage.create_round(x1, y1, x2, y2, fill_mouse=\"#FF0000\")\n````\n\n##### command\n\nCommand allows you to give an action when you click on the rectangle.\n````\nself.manage.create_round(x1, y1, x2, y2, command=(\"<Button-1>\", self.quit_gui))\n\n````\nIn the example above, the first argument of the tuple is the action to be done on the rectangle, here a left mouse click will activate self.quit_gui.\nThe syntax is the same as tkinter and for more information refer to the commands chapter.\nCommand can take several actions, to do so, add the other two arguments to the tuple, action - command following. \nExample :\n\n````\nself.manage.create_round(x1, y1, x2, y2, command=(\"<Button-1>\", self.quit_gui, \"<Double-Button-1>\", self.quit_gui))\n\n````\nHere as in the first example, the left click will activate the self.quit_gui command but also, the double left click.\n\n#### Methode update()\n\nAs with the update method of the rectangle, the method allows you to update certain attributes of the class which are initiated when it is created.\nThe arguments are fill and fill_mouse at the moment.\n\nIn the init of the template:\n````\nself.round_test = self.manage.create_round(x1, y1, x2, y2, fill=\"red\")\n\n````\n\nIn the update () method of the template:\n````\nself.round_test.update(fill=\"green\")\n\n````\n\n### Text\n\nThe text is created from the template. You have to instantiate the class from the template by giving it several parameters to have the desired effect.\nThe class returns an object.\n````\nself.text = self.manage.create_text(x1, y1, text=\"test\")\n```` \n\nYou can also call the update method described below.\n\t\t\n#### Mandatory arguments\n\nThe method to call the text is: self.manage.create_text (x1, y1). This is the minimal code to create a text, although nothing will be written in this case.\n\nThe points x1 and y1 correspond to the point of inking, the ink or anchor here, will be described below.\n````\n:param x1: int \n:param y1: int\n````\n\n#### Optional arguments\nCreate_text can take other arguments with kwargs and they are all optional.\n\n##### text\n\nText displays the text.\n````\nself.text = self.manage.create_text(x1, y1, text=\"test\")\n```` \n\n##### Anchor\n\nAnchor allows you to modify the start of text display.\nBy default, is 'center' which means that the text is centered in relation to the position (x, y).\n````\nself.text = self.manage.create_text(x1, y1, text=\"test\", anchor=\"center\")\n```` \n\n##### Fill\n\nFill allows to fill with a color of the text, the supported color is the same as tkinter, one can write \"red\" or its format in hex \"# FF0000\".\nThe default color is \"black\" if not specified.\n\n````\nself.manage.create_text(x1, y1, text=\"test\", fill=\"red\")\n\nor\n\nself.manage.create_text(x1, y1, text=\"test\", fill=\"#FF0000\")\n````\n\n#### Methode update()\n\nAs with the update method of the rectangle, the method allows to update certain attributes of the class which are initiated at its creation.\nThe arguments are fill and text at the moment.\n\nIn the init of the template:\n````\nself.text_test = self.manage.create_text(x1, y1, text=\"test\", fill=\"red\")\n\n````\n\nIn the update () method of the template:\n````\nself.text_test.update(fill=\"green\")\n\n````\n\n### Button\n\nThe button is a graphic object which is not integrated into the tkinter canvas, this button is in two states, active or not.\nThe body of the button is made up of a rectangle in the center superimposed with a circle that moves from side to side of the rectangle to visually show if the button is active.\n````\nself.button = self.manage.create_button(x1, y1)\n````\nTrick :\nTo create a simple button, rectangular or round widgets allow you to do this by linking an action when clicked.\n\n#### Mandatory arguments\n\nThe method to call the button is: self.manage.create_button (x1, y1). This is the minimal code to create a button.\n\nPoints x1 and y1 correspond to the center of the button.\n````\n:param x1: int \n:param y1: int\n````\n\n#### Optional arguments\n\nCreate_button can take other arguments with kwargs, and they are all optional.\n\n##### Active\n\nActive allows to choose if the button is activated at the beginning.\nBy default, the button will be disabled.\n````\nself.button = self.manage.create_button(x1, y1, active=True)\n````\n\n##### Fill_round\n\nFill_round allows you to choose the color of the round part of the button\nBy default, the color is \"red\"\n````\nself.button = self.manage.create_button(x1, y1, fill_round=\"black\")\n````\n\n##### Fill_body\n\nFill_body allows you to choose the color of the rectangle part of the button\nBy default, the color is \"blue\"\n````\nself.button = self.manage.create_button(x1, y1, fill_body=\"red\")\n````\n\n##### Scale\n\nScale allows you to adjust the size of the button.\nBy default, the size is 1\n\n````\nself.button = self.manage.create_button(x1, y1, scale=2)\n````\n\n### Menu\n\nMenu is also like button a graphic object created.\nMenu allows you to create a menu by adding cascading labels, its operation is similar to Menu () of tkinter but adapted to the canvas.\n\n````\nself.menu = self.manage.create_menu(x1, y1, x2, y2, text=\"test\")\n````\n\n#### Mandatory arguments\n\nThe method to call the menu is as follows: self.manage.create_menu (x1, y1, x2, y2). This is the minimal code to create a menu.\n\nAs with the rectangle, x1 and y1 represent the points of the rectangle at the top left and x2 and y2 represent the points at the bottom right.\n````\n:param x1: int \n:param y1: int\n:param x2: int \n:param y2: int\n````\n\n#### Optional arguments\nCreate_menu takes all the points of the rectangle, except the command that will be used has deployed the label drop-down list.\n\n#### Add_label () method\n\nThe add_label method allows you to add labels to the drop-down list when the menu is activated.\nFor the used, after with initiated a menu.\n````\nself.menu = self.manage.create_menu(x1, y1, x2, y2, text=\"test\")\n````\n\nAdded:\n````\nself.label_menu = self.menu.add_label(\"label_test\")\n````\nA command can be given as an argument, as before, you must give a tuple (action, command)\n\n#### Add_cascade () method\n\nThe add_cascade method allows you to add a drop-down list to a label, the list will be opened on the right of the label window.\nTo use it, after having initiated the menu and the label.\n````\nself.menu = self.manage.create_menu(x1, y1, x2, y2, text=\"test\")\n\nlabel_menu = self.menu.add_label(\"label_test\")\n````\n\nAdded:\n````\nself.menu.add_cascade(\"cascade_test\", label_menu)\n````\n\nAn order can be linked by adding:\n````\nself.menu.add_cascade(\"cascade_test\", label_menu, command=(\"<Button-1>\", self.quit_gui))\n````\n\n\n## Order\n\nGuitool has a few commands, but you can add your own.\nThe commands are separated into three classes, keyboard, mouse, and custom commands.\n\n### Keyboard\n\nTo add keyboard commands, nothing could be simpler.\nCreate a class where you group your commands linked to the keyboard.\n````\nclass KeyBoard:\n    \"\"\"\n    Manage keyboard events\n    \"\"\"\n\n    def __init__(self):\n\n        # key press alt + enter\n        self.window.bind(\"<Alt-Return>\", self.fullscreen)\n\n````\n\nThe use of the bind method of tkinter which allows to manage the events.\nself.fullscreen points to a custom command that we will see below.\n\nTo have access to this command, all you have to do is to inherit this class from your template.\nPlease note that the Keyboard name for the class name is already used.\n\n### Mouse\n\nIf you want to add actions with the mouse by clicking on your widgets, it will also defraud creating a new class.\nBasically, mouse capture, left single click and left double click are supported.\nYou can add more with:\n````\nclass Mous:\n    \"\"\"\n    Manage mouse events\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Init mouse event\n        \"\"\"\n\t\t\n        self.window.bind(\"<Button-3>\", self.click_button_3)\n\n\n    def self.click_button_3(self, event):\n\n        self.adjust_mousse(event.x, event.y)\n        self.manage.command(self.x, self.y, \"<Button-3>\")\n\t\t\n````\n\nThis example allows you to add the right click to the manage event loop and therefore to your widgets.\nThe call of the method self.adjust_mousse (event.x, event.y) allows to adjust the movement of the mouse with the real position of the window on you used scroolbar.\nAs for keyboard commands, all that remains is to inherit the class from your template.\nPlease note that the Mouse name for the class is already used\n\n### Custom order\n\nYou can create your commands which are given to your widgets.\n\nFor that you need a new class:\n````\nclass CommandGui:\n    \"\"\"\n    Manage command events\n    \"\"\"\n\t\n\tdef draw_dashboard(self):\n\t\t\"\"\"\n\t\tdestroy the old page and load the new one\n\t\t\"\"\"\n\n\t\tself.window.template.active_template.canvas.destroy()\n\t\tself.window.template.draw_dashboard()\n\t\n\tdef quit_gui(self):\n\t\t\"\"\"\n\t\tDestroy window and close app\n\t\t\"\"\"\n\n\t\tself.window.destroy()\n\t\tself.window.template = None\n\t\t\n````\n\nAll that remains is to inherit your class from your template.\nIt is here for example where you can put the command to load a new template with the example draw_dashboard\n\n\n\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Walrick/gui_tool",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "guitool",
    "package_url": "https://pypi.org/project/guitool/",
    "platform": "",
    "project_url": "https://pypi.org/project/guitool/",
    "project_urls": {
      "Homepage": "https://github.com/Walrick/gui_tool"
    },
    "release_url": "https://pypi.org/project/guitool/0.1.3/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Quickly create a user interface based on tkinter's canvas",
    "version": "0.1.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11221924,
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1aecc7f781346c56417060f7ace66efe28d899aa360455beb41529d8895b34c1",
          "md5": "1704e3f5eee216e533e217a043a6c252",
          "sha256": "ebd330498754c9d924f9e5d3ec2d6adc440e004ea0955e06881c66967749da1c"
        },
        "downloads": -1,
        "filename": "guitool-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1704e3f5eee216e533e217a043a6c252",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26281,
        "upload_time": "2021-08-09T08:47:12",
        "upload_time_iso_8601": "2021-08-09T08:47:12.146870Z",
        "url": "https://files.pythonhosted.org/packages/1a/ec/c7f781346c56417060f7ace66efe28d899aa360455beb41529d8895b34c1/guitool-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f2e867519ae18ae24869563c67884d6f0dfc374fc50058b81ad08b030a22cac7",
          "md5": "4f8496e163e6bf7942841b3fd35b7fde",
          "sha256": "ac4d5ce2d12f5d6f8f1b047328036b93b3db59d93b3391523ac813c068777fec"
        },
        "downloads": -1,
        "filename": "guitool-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4f8496e163e6bf7942841b3fd35b7fde",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26281,
        "upload_time": "2021-08-09T08:59:22",
        "upload_time_iso_8601": "2021-08-09T08:59:22.377936Z",
        "url": "https://files.pythonhosted.org/packages/f2/e8/67519ae18ae24869563c67884d6f0dfc374fc50058b81ad08b030a22cac7/guitool-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "24e5cc6c14a339ad4facea9bcc38fed5c4b7a700547a825544b4ce06f8a3f729",
          "md5": "225501a9ad0ea1afeb0dc541bd4cf960",
          "sha256": "051903f0ccc33b4e2f192cf1b1e07a82fae4cf2a9bb8b32dc2cb2618b550e77b"
        },
        "downloads": -1,
        "filename": "guitool-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "225501a9ad0ea1afeb0dc541bd4cf960",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26616,
        "upload_time": "2021-08-19T13:19:59",
        "upload_time_iso_8601": "2021-08-19T13:19:59.098403Z",
        "url": "https://files.pythonhosted.org/packages/24/e5/cc6c14a339ad4facea9bcc38fed5c4b7a700547a825544b4ce06f8a3f729/guitool-0.1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "24e5cc6c14a339ad4facea9bcc38fed5c4b7a700547a825544b4ce06f8a3f729",
        "md5": "225501a9ad0ea1afeb0dc541bd4cf960",
        "sha256": "051903f0ccc33b4e2f192cf1b1e07a82fae4cf2a9bb8b32dc2cb2618b550e77b"
      },
      "downloads": -1,
      "filename": "guitool-0.1.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "225501a9ad0ea1afeb0dc541bd4cf960",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 26616,
      "upload_time": "2021-08-19T13:19:59",
      "upload_time_iso_8601": "2021-08-19T13:19:59.098403Z",
      "url": "https://files.pythonhosted.org/packages/24/e5/cc6c14a339ad4facea9bcc38fed5c4b7a700547a825544b4ce06f8a3f729/guitool-0.1.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}