{
  "info": {
    "author": "David Smith",
    "author_email": "x300bps@icloud.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "**Threadify:**\n---------------\nThe purpose of this package is to make using Python threads easier and more \nuser-friendly while providing more flexibility and capability. \nThreadify extends Python threads to add the ability to cooperatively pause, unpause, and kill threads.\n\nOne of the inconvenient aspects of using generic Python threads is that there is no easy way to \npause, continue, or kill a thread at a natural unit-of-work boundary. Threadify adds methods to \nsignal a thread to cooperatively perform these actions. The unit-of-work executed by Threadify \nis the task-body function (the _task_). \n\n#### Structure:\n\nCreating a Threadify object is very similar to creating a Python thread.  \n```\nimport time\nfrom threadify import Threadify  \n\ndef taskbody(storage):\n    print(\".\")  \n    time.sleep(0.25)  \n\nt = Threadify(taskbody)\nt.start()\n```\n\n##### The Task: \nThe task is the work to be done by the Threadify object. The task function can be a simple run-to-completion model \nor a more complex, long-lasting function. The Threadify object acts as a superloop repeatedly calling the task. \nBetween invocations of task, requests for pause, unpause, or kill are processed. A task can signal its own Threadify\nobject to continue calling it by returning True, or can request to be killed by returning False. \n\n\n##### Task Storage Parameter:  \nThe task function takes a single parameter: a dictionary named 'storage'. This dictionary provides two primary features:  \n- A vehicle to pass initial values to the task via the Threadify initializer.\n- Mutable storage that persists across invocations of task by the Threadify superloop.\n\nAny values that need to be retained from one call to the next can be fetched from and saved to storage.\n\n##### Task Suggestions:  \n- Incorporate at least some small *time.sleep* interval before returning. This provides an opportunity for the\nscheduler to context switch to other tasks and helps prevent 'hogging' the CPU cycles. *Example: time.sleep(0.010)*\n- While blocking calls (such as pending on a queue) are perfectly acceptable, bear in mind that it reduces the \nThreadify object's responsiveness to requests to pause, unpause, or kill since these requests are executed between task \ninvocations. For the example of a queue, a queue timeout can be used to enforce a bare-minimum level of responsiveness \nas needed by the application.\n\n#### Documentation:\nThreadify inherits from Python's *threading.Thread*, so it makes available all of the methods that *threading.Thread* provides \nin-addition-to its own.\n```\nclass Threadify(threading.Thread):\n\n    VERSION: str = \"1.0.0\"\n\n    # Set True to enable debug output\n    ENABLE_DEBUG_OUTPUT = False\n\n    def __init__((self, task: Optional[Callable] = None, storage: Optional[dict] = None, *, name: str = None,\n                 daemon: bool = True, deep_copy: bool = True, ignore_task_exceptions: bool = False,\n                 start: bool = False):\n        :param task: The callable to be repeatedly executed by the thread in the thread's context.\n        :param storage: Dictionary containing data for 'task'. It is persistent and mutable across invocations of 'task'\n                        by the thread for the life of the thread. The task can access, modify, and add variables to\n                        the dictionary and have them persist across each task invocation (which happens repeatedly).\n        :param name:    Name for the thread or None for an autogenerated default name.\n        :param daemon:  True - Run as a daemon thread (ie: if main program exits, thread exits);\n                        False - Thread continues to run even if the main program that created it exits.\n        :param deep_copy: True - Make independent, deep copy of storage for use by thread; False - Shallow copy. A\n                        deep copy may require less programmer care since independent copies are made. A shallow\n                        copy is potentially faster, but requires the programmer to be careful not to create\n                        data contention between various threads of execution. Items that can't be pickled\n                        can't be deep-copied.\n        :param ignore_task_exceptions: True - Ignore unhandled exceptions raised in task and continue;\n                        False - Re-raise task exception thereby terminating the thread.\n        :param start:   True - Automatically start thread after construction; False - Thread must be manually started\n                        by calling its builtin 'start' method.\n\n    def pause(self, wait_until_paused: bool = False, timeout_secs: Optional[int] = None):\n        Use to cooperatively pause the thread. Note that unless 'wait_until_paused' is True, this\n        method can return before the pause has taken effect since thread pausing is affected by the responsiveness\n        of and the blocking in the user task.\n        :param wait_until_paused: True - wait until thread has paused before returning; False - return immediately.\n        :param timeout_secs: 'None' or maximum number of seconds to wait for thread to pause when\n                            'wait_until_paused' is True; None means ignore timeout and wait as long as required\n                            for thread to pause.\n        :return: True - Thread paused before return; False - Thread not yet paused before return\n\n    def unpause(self):\n        Unpause a paused thread.\n        :return: None\n\n    def is_paused(self) -> bool:\n        Indicate if the thread is currently paused. This represents the current actual state of the thread - not\n        whether or not a pause was requested.\n        :return: True - Thread is currently paused; False - Thread is not paused\n\n    def kill(self, wait_until_dead: bool = False, timeout_secs: Optional[int] = None):\n        Cooperatively end execution of the thread.\n        :param wait_until_dead: True - Wait with timeout for thread to terminate; False - Return immediately\n        :param timeout_secs: 'None' or maximum number of seconds to wait for termination when\n                            'wait_until_dead' is True; None means ignore timeout and wait as long as required\n                            for thread to terminate.\n        :return: True - Thread terminated before return; False - Thread not yet terminated before returning\n\n\n# User-Supplied Task Function\ndef task(storage: dict) -> bool:\n    The periodic work to be done by the thread. Blocking affects the responsiveness to cooperative\n    pause and kill signals; however, at least some small sleep delay (ex: time.sleep(0.010) ) or IO blocking\n    should be included to allow opportunities for context-switches for other threads. Note that changes made to\n    'storage' persist across each invocation of task for the life of the thread.\n    :param storage: Dict to provide persistent, mutable task variable storage.\n    :returns: True - continue to run; False - kill thread\n\n```\n#### Examples:\n```\nimport time\nfrom threadify import Threadify\nimport queue\n\n\ndef task_symbols(storage):\n    \"\"\"\n    Task that prints first character of contents of storage[\"symbol\"] forever.\n    \"\"\"\n    sym = storage.get(\"symbol\", \".\")\n    print(sym[0], sep=\" \", end=\"\", flush=True)\n    time.sleep(.25)\n    return True\n\n\ndef task_run_5s(storage):\n    \"\"\"\n    Demonstrate a self-terminating task.\n    Use storage to pass in a start time so that task can decide when to self-terminate.\n    \"\"\"\n    # Get start time from storage\n    start = storage.get(\"start_time\")\n\n    # Compute elapsed time and print\n    delta = time.time() - start\n    print(\"Elapsed time: {:4.2f}\".format(delta))\n\n    # Time to die?\n    if delta >= 5:\n        print(\"Stopping after {:4.2f} seconds\".format(delta))\n\n        # Signal thread to terminate\n        return False\n\n    # Sleep to control speed of the output\n    time.sleep(1)\n\n    # Signal thread to keep running\n    return True\n\n\ndef task_checkqueue(storage):\n    \"\"\"\n    Task that watches a queue for messages and acts on them when received.\n    \"\"\"\n    # Get the queue object from the storage dictionary\n    thequeue = storage.get(\"queue\")\n    try:\n        # Use a timeout so it blocks for at-most 0.5 seconds while waiting for a message. Smaller values can be used to\n        # increase the cycling of the task and responsiveness to Threadify control signals (like pause) if desired.\n        msg = thequeue.get(block=True, timeout=.5)\n    except queue.Empty:\n        print(\"_\", end=\"\")\n    else:\n        if msg == \"QUIT\":\n            return False\n\n        # Print received message\n        print(\"{:s}\".format(msg), end=\"\")\n\n    return True\n\n\ndef task_dosomething(storage):\n    \"\"\"\n    Task that gets launched to handle something in the background until it is completed and then terminates. Note that\n    this task doesn't return until it is finished, so it won't be listening for Threadify pause or kill requests. \n    \"\"\"    \n    # An important task that we want to run in the background.    \n    for i in range(10):\n        print(i, end=\"\")\n        time.sleep(1)\n\n    return False \n\n\n# To enable debug on ALL Threadify classes ...\nThreadify.ENABLE_DEBUG_OUTPUT = True\n# or it can be enabled on an instance-by-instance basis. \n\n\n# EXAMPLE 1) Simplest example - built-in task displays '.' to the screen each 0.25 seconds\nprint(\"EX 1) Print '.' approximately every 0.25 seconds.\")\n\nt1 = Threadify(start=True)\n# Main program sleeps here while task continues to run\ntime.sleep(5)\n\nt1.kill(wait_until_dead=True)\nprint(\"\\nDone\")\n\n\n# EXAMPLE 2) Demonstrate two tasks running with one being paused/continued\nprint(\"EX 2) Starting 2 tasks - one will be paused and continued while the other runs continuously.\")\n\n# Pass initial value of \"symbol\" via the storage dictionary to each task\nt1 = Threadify(task_symbols, {\"symbol\": \"X\"})\nt2 = Threadify(task_symbols, {\"symbol\": \"O\"})\n\n# Start tasks manually (could have been automatically started instead via the start parameter)\nt1.start()\nt2.start()\n\ntime.sleep(5.1)\nprint(\"\\nPausing 'X' for 5 seconds.\")\nt1.pause(True)\ntime.sleep(5)\n\nprint(\"\\nUnpausing 'X' for 5 seconds.\")\nt1.unpause()\ntime.sleep(5)\n\nt1.kill()\nt2.kill()\nt1.join()\nt2.join()\nprint(\"\\nDone\")\n\n\n# EXAMPLE 3) Demonstrate a task that self-terminates after 5 seconds\nprint(\"EX 3) Demonstrate a task that self-terminates after 5 seconds.\")\n\nt1 = Threadify(task_run_5s, {\"start_time\": time.time()}, daemon=False, start=True)\n\n# Join instructs main program to wait on t1 to complete before continuing\nt1.join()\nprint(\"\\nDone\")\n\n\n# EXAMPLE 4) Demonstrate communication with a task via a queue passed in through storage.\nprint(\"EX 4) Demonstrate communication with a task via a queue passed in through storage.\")\n\n# Create a thread-safe queue for message passing\nq = queue.Queue()\n\n# This instance REQUIRES deep_copy=FALSE since Queue is not pickleable.\nt1 = Threadify(task_checkqueue, {\"queue\": q}, deep_copy=False, start=True)\n# Wait 3 seconds - then send some messages\ntime.sleep(3)\nq.put(\"HE\")\nq.put(\"LLO\")\nq.put(\" WORLD\")\ntime.sleep(2)\nq.put(\"1\")\ntime.sleep(1)\nq.put(\"2\")\ntime.sleep(2)\nq.put(\"3\")\ntime.sleep(3)\n\n# Send the QUIT message to have task kill itself and then wait for it to die\nq.put(\"QUIT\")\nt1.join()\nprint(\"\\Done.\")\n\n\n# EXAMPLE 5) Fire and forget. Launch a function in a separate thread and have it run to completion. \nprint(\"EX 5) Fire and forget. Launch a function in a separate thread and have it run to completion.\")\n\nt1 = Threadify(task_dosomething, start=True)\n\n# Join instructs main program to wait on t1 to complete before continuing\nt1.join()\nprint(\"\\nDone\")\n```\n#### Conclusion:\nAs these simple examples demonstrate, there are many use-cases where Threadify can be used to simplify the\nproblems that a programmer is trying to solve. Concurrent programming can be hard; Threadify attempts to make it a\nlittle easier.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/300bps/threadify",
    "keywords": "thread threading concurrent cooperative multitasking multithreading pause kill",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "threadify",
    "package_url": "https://pypi.org/project/threadify/",
    "platform": "",
    "project_url": "https://pypi.org/project/threadify/",
    "project_urls": {
      "Homepage": "https://github.com/300bps/threadify"
    },
    "release_url": "https://pypi.org/project/threadify/1.0.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "An enhancement to Python threads that adds cooperative pause, unpause, and kill capabilities.",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9758665,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "08441c389dfc5a5d3241505f0d740cbaef1f8a2bc7d4cf77d4ee84e591f0ce77",
          "md5": "1eaa62ab502625dfe225105667e5bf6e",
          "sha256": "dfefacf0b952ea73d77e485b6b3331d2491c596bfe3375d521675635a8dfdc8a"
        },
        "downloads": -1,
        "filename": "threadify-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1eaa62ab502625dfe225105667e5bf6e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 10220,
        "upload_time": "2021-03-13T04:56:00",
        "upload_time_iso_8601": "2021-03-13T04:56:00.872875Z",
        "url": "https://files.pythonhosted.org/packages/08/44/1c389dfc5a5d3241505f0d740cbaef1f8a2bc7d4cf77d4ee84e591f0ce77/threadify-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6cd9542be272a07cca1d44ff038df6259845f2576612ace2dedd4b6a02b469ab",
          "md5": "480d801f97e90cbfcd366690e78fe414",
          "sha256": "9e1ee0cca697d2d06fc356c3f6683bfa8430b74a61c6b1c8332ed2bab92e6048"
        },
        "downloads": -1,
        "filename": "threadify-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "480d801f97e90cbfcd366690e78fe414",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 10051,
        "upload_time": "2021-03-13T04:56:02",
        "upload_time_iso_8601": "2021-03-13T04:56:02.145100Z",
        "url": "https://files.pythonhosted.org/packages/6c/d9/542be272a07cca1d44ff038df6259845f2576612ace2dedd4b6a02b469ab/threadify-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "08441c389dfc5a5d3241505f0d740cbaef1f8a2bc7d4cf77d4ee84e591f0ce77",
        "md5": "1eaa62ab502625dfe225105667e5bf6e",
        "sha256": "dfefacf0b952ea73d77e485b6b3331d2491c596bfe3375d521675635a8dfdc8a"
      },
      "downloads": -1,
      "filename": "threadify-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "1eaa62ab502625dfe225105667e5bf6e",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 10220,
      "upload_time": "2021-03-13T04:56:00",
      "upload_time_iso_8601": "2021-03-13T04:56:00.872875Z",
      "url": "https://files.pythonhosted.org/packages/08/44/1c389dfc5a5d3241505f0d740cbaef1f8a2bc7d4cf77d4ee84e591f0ce77/threadify-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6cd9542be272a07cca1d44ff038df6259845f2576612ace2dedd4b6a02b469ab",
        "md5": "480d801f97e90cbfcd366690e78fe414",
        "sha256": "9e1ee0cca697d2d06fc356c3f6683bfa8430b74a61c6b1c8332ed2bab92e6048"
      },
      "downloads": -1,
      "filename": "threadify-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "480d801f97e90cbfcd366690e78fe414",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 10051,
      "upload_time": "2021-03-13T04:56:02",
      "upload_time_iso_8601": "2021-03-13T04:56:02.145100Z",
      "url": "https://files.pythonhosted.org/packages/6c/d9/542be272a07cca1d44ff038df6259845f2576612ace2dedd4b6a02b469ab/threadify-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}