{
  "info": {
    "author": "Dmitry Pershin, Bernhard Kaindl",
    "author_email": "bernhardkaindl7@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: Public Domain",
      "Natural Language :: English",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "========\nxjsonrpc\n========\n\npjrpc upstream status:\n\n.. image:: https://static.pepy.tech/personalized-badge/pjrpc?period=month&units=international_system&left_color=grey&right_color=orange&left_text=Downloads/month\n    :target: https://pepy.tech/project/pjrpc\n    :alt: Downloads/month\n.. image:: https://travis-ci.org/dapper91/pjrpc.svg?branch=master\n    :target: https://travis-ci.org/dapper91/pjrpc\n    :alt: Build status\n.. image:: https://img.shields.io/pypi/l/pjrpc.svg\n    :target: https://pypi.org/project/pjrpc\n    :alt: License\n.. image:: https://img.shields.io/pypi/pyversions/pjrpc.svg\n    :target: https://pypi.org/project/pjrpc\n    :alt: Supported Python versions\n.. image:: https://codecov.io/gh/dapper91/pjrpc/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/dapper91/pjrpc\n    :alt: Code coverage\n.. image:: https://readthedocs.org/projects/pjrpc/badge/?version=stable&style=flat\n   :alt: ReadTheDocs status\n   :target: https://pjrpc.readthedocs.io/en/stable/\n\nbernhardkaindl/xjsonrpc status:\n\n.. image:: https://static.pepy.tech/personalized-badge/xjsonrpc?period=month&units=international_system&left_color=grey&right_color=orange&left_text=Downloads/month\n    :target: https://pepy.tech/project/xjsonrpc\n    :alt: Downloads/month\n.. image:: https://travis-ci.org/bernhardkaindl/xjsonrpc.svg?branch=master\n    :target: https://travis-ci.org/bernhardkaindl/xjsonrpc\n    :alt: Build status\n.. image:: https://img.shields.io/pypi/l/xjsonrpc.svg\n    :target: https://pypi.org/project/xjsonrpc\n    :alt: License\n.. image:: https://img.shields.io/pypi/pyversions/xjsonrpc.svg\n    :target: https://pypi.org/project/xjsonrpc\n    :alt: Supported Python versions\n.. image:: https://codecov.io/gh/bernhardkaindl/xjsonrpc/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/bernhardkaindl/xjsonrpc\n    :alt: Code coverage\n.. image:: https://readthedocs.org/projects/xjsonrpc/badge/?version=stable&style=flat\n   :alt: ReadTheDocs status\n   :target: https://xjsonrpc.readthedocs.io/en/stable/\n\n\n``xjsonrpc`` is an extensible `JSON-RPC <https://www.jsonrpc.org>`_ client/server library with an intuitive interface\nthat can be easily extended and integrated in your project without writing a lot of boilerplate code.\n\nIt was forked from https://github.com/dapper91/pjrpc to make fast progress in\nthe area of the rabbitmq/aio_pika backend with fixes and improved code examples.\n\nFeatures:\n\n- framework agnostic\n- intuitive api\n- extendability\n- synchronous and asynchronous client backend\n- synchronous and asynchronous server support\n- popular frameworks integration\n- builtin parameter validation\n- pytest integration\n- openapi schema generation support\n- web ui support (SwaggerUI, RapiDoc, ReDoc)\n\nInstallation\n------------\n\nYou can install xjsonrpc with pip:\n\n.. code-block:: console\n\n    $ pip install xjsonrpc\n\n\nExtra requirements\n------------------\n\n- `aiohttp <https://aiohttp.readthedocs.io>`_\n- `aio_pika <https://aio-pika.readthedocs.io>`_\n- `flask <https://flask.palletsprojects.com>`_\n- `jsonschema <https://python-jsonschema.readthedocs.io>`_\n- `kombu <https://kombu.readthedocs.io/en/stable/>`_\n- `pydantic <https://pydantic-docs.helpmanual.io/>`_\n- `requests <https://requests.readthedocs.io>`_\n- `httpx <https://www.python-httpx.org/>`_\n- `openapi-ui-bundles <https://github.com/dapper91/python-openapi-ui-bundles>`_\n- `starlette <https://www.starlette.io/>`_\n- `django <https://www.djangoproject.com>`_\n\n\nDocumentation\n-------------\n\nDocumentation is available at `Read the Docs <https://xjsonrpc.readthedocs.io/en/latest/>`_.\n\n\nQuickstart\n----------\n\nClient requests\n_______________\n\n``xjsonrpc`` client interface is very simple and intuitive. Methods may be called by name, using proxy object\nor by sending handmade ``xjsonrpc.common.Request`` class object. Notification requests can be made using\n``xjsonrpc.client.AbstractClient.notify`` method or by sending a ``xjsonrpc.common.Request`` object without id.\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    response: xjsonrpc.Response = client.send(xjsonrpc.Request('sum', params=[1, 2], id=1))\n    print(f\"1 + 2 = {response.result}\")\n\n    result = client('sum', a=1, b=2)\n    print(f\"1 + 2 = {result}\")\n\n    result = client.proxy.sum(1, 2)\n    print(f\"1 + 2 = {result}\")\n\n    client.notify('tick')\n\n\nAsynchronous client api looks pretty much the same:\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import aiohttp as xjsonrpc_client\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    response = await client.send(xjsonrpc.Request('sum', params=[1, 2], id=1))\n    print(f\"1 + 2 = {response.result}\")\n\n    result = await client('sum', a=1, b=2)\n    print(f\"1 + 2 = {result}\")\n\n    result = await client.proxy.sum(1, 2)\n    print(f\"1 + 2 = {result}\")\n\n    await client.notify('tick')\n\n\nBatch requests\n______________\n\nBatch requests also supported. You can build ``xjsonrpc.common.BatchRequest`` request by your hand and then send it to the\nserver. The result is a ``xjsonrpc.common.BatchResponse`` instance you can iterate over to get all the results or get\neach one by index:\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    batch_response = await client.batch.send(xjsonrpc.BatchRequest(\n        xjsonrpc.Request('sum', [2, 2], id=1),\n        xjsonrpc.Request('sub', [2, 2], id=2),\n        xjsonrpc.Request('div', [2, 2], id=3),\n        xjsonrpc.Request('mult', [2, 2], id=4),\n    ))\n    print(f\"2 + 2 = {batch_response[0].result}\")\n    print(f\"2 - 2 = {batch_response[1].result}\")\n    print(f\"2 / 2 = {batch_response[2].result}\")\n    print(f\"2 * 2 = {batch_response[3].result}\")\n\n\nThere are also several alternative approaches which are a syntactic sugar for the first one (note that the result\nis not a ``xjsonrpc.common.BatchResponse`` object anymore but a tuple of \"plain\" method invocation results):\n\n- using chain call notation:\n\n.. code-block:: python\n\n    result = await client.batch('sum', 2, 2)('sub', 2, 2)('div', 2, 2)('mult', 2, 2).call()\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\n- using subscription operator:\n\n.. code-block:: python\n\n    result = await client.batch[\n        ('sum', 2, 2),\n        ('sub', 2, 2),\n        ('div', 2, 2),\n        ('mult', 2, 2),\n    ]\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\n- using proxy chain call:\n\n.. code-block:: python\n\n    result = await client.batch.proxy.sum(2, 2).sub(2, 2).div(2, 2).mult(2, 2).call()\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\nWhich one to use is up to you but be aware that if any of the requests returns an error the result of the other ones\nwill be lost. In such case the first approach can be used to iterate over all the responses and get the results of\nthe succeeded ones like this:\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    batch_response = client.batch.send(xjsonrpc.BatchRequest(\n        xjsonrpc.Request('sum', [2, 2], id=1),\n        xjsonrpc.Request('sub', [2, 2], id=2),\n        xjsonrpc.Request('div', [2, 2], id=3),\n        xjsonrpc.Request('mult', [2, 2], id=4),\n    ))\n\n    for response in batch_response:\n        if response.is_success:\n            print(response.result)\n        else:\n            print(response.error)\n\n\nBatch notifications:\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    client.batch.notify('tick').notify('tack').notify('tick').notify('tack').call()\n\n\n\nServer\n______\n\n``xjsonrpc`` supports popular backend frameworks like `aiohttp <https://aiohttp.readthedocs.io>`_,\n`flask <https://flask.palletsprojects.com>`_ and message brokers like `kombu <https://kombu.readthedocs.io/en/stable/>`_\nand `aio_pika <https://aio-pika.readthedocs.io>`_.\n\n\nRunning of aiohttp based JSON-RPC server is a very simple process. Just define methods, add them to the\nregistry and run the server:\n\n.. code-block:: python\n\n    import uuid\n\n    from aiohttp import web\n\n    import xjsonrpc.server\n    from xjsonrpc.server.integration import aiohttp\n\n    methods = xjsonrpc.server.MethodRegistry()\n\n\n    @methods.add(context='request')\n    async def add_user(request: web.Request, user: dict):\n        user_id = uuid.uuid4().hex\n        request.app['users'][user_id] = user\n\n        return {'id': user_id, **user}\n\n\n    jsonrpc_app = aiohttp.Application('/api/v1')\n    jsonrpc_app.dispatcher.add_methods(methods)\n    jsonrpc_app.app['users'] = {}\n\n    if __name__ == \"__main__\":\n        web.run_app(jsonrpc_app.app, host='localhost', port=8080)\n\n\nParameter validation\n____________________\n\nVery often besides dumb method parameters validation it is necessary to implement more \"deep\" validation and provide\ncomprehensive errors description to clients. Fortunately ``xjsonrpc`` has builtin parameter validation based on\n`pydantic <https://pydantic-docs.helpmanual.io/>`_ library which uses python type annotation for validation.\nLook at the following example: all you need to annotate method parameters (or describe more complex types beforehand if\nnecessary). ``xjsonrpc`` will be validating method parameters and returning informative errors to clients.\n\n\n.. code-block:: python\n\n    import enum\n    import uuid\n    from typing import List\n\n    import pydantic\n    from aiohttp import web\n\n    import xjsonrpc.server\n    from xjsonrpc.server.validators import pydantic as validators\n    from xjsonrpc.server.integration import aiohttp\n\n    methods = xjsonrpc.server.MethodRegistry()\n    validator = validators.PydanticValidator()\n\n\n    class ContactType(enum.Enum):\n        PHONE = 'phone'\n        EMAIL = 'email'\n\n\n    class Contact(pydantic.BaseModel):\n        type: ContactType\n        value: str\n\n\n    class User(pydantic.BaseModel):\n        name: str\n        surname: str\n        age: int\n        contacts: List[Contact]\n\n\n    @methods.add(context='request')\n    @validator.validate\n    async def add_user(request: web.Request, user: User):\n        user_id = uuid.uuid4()\n        request.app['users'][user_id] = user\n\n        return {'id': user_id, **user.dict()}\n\n\n    class JSONEncoder(xjsonrpc.server.JSONEncoder):\n\n        def default(self, o):\n            if isinstance(o, uuid.UUID):\n                return o.hex\n            if isinstance(o, enum.Enum):\n                return o.value\n\n            return super().default(o)\n\n\n    jsonrpc_app = aiohttp.Application('/api/v1', json_encoder=JSONEncoder)\n    jsonrpc_app.dispatcher.add_methods(methods)\n    jsonrpc_app.app['users'] = {}\n\n    if __name__ == \"__main__\":\n        web.run_app(jsonrpc_app.app, host='localhost', port=8080)\n\n\nError handling\n______________\n\n``xjsonrpc`` implements all the errors listed in `protocol specification <https://www.jsonrpc.org/specification#error_object>`_\nwhich can be found in ``xjsonrpc.common.exceptions`` module so that error handling is very simple and \"pythonic-way\":\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    try:\n        result = client.proxy.sum(1, 2)\n    except xjsonrpc.MethodNotFound as e:\n        print(e)\n\n\nDefault error list can be easily extended. All you need to create an error class inherited from\n``xjsonrpc.exc.JsonRpcError`` and define an error code and a description message. ``xjsonrpc`` will be automatically\ndeserializing custom errors for you:\n\n.. code-block:: python\n\n    import xjsonrpc\n    from xjsonrpc.client.backend import requests as xjsonrpc_client\n\n    class UserNotFound(xjsonrpc.exc.JsonRpcError):\n        code = 1\n        message = 'user not found'\n\n\n    client = xjsonrpc_client.Client('http://localhost/api/v1')\n\n    try:\n        result = client.proxy.get_user(user_id=1)\n    except UserNotFound as e:\n        print(e)\n\n\nOn the server side everything is also pretty straightforward:\n\n.. code-block:: python\n\n    import uuid\n\n    import flask\n\n    import xjsonrpc\n    from xjsonrpc.server import MethodRegistry\n    from xjsonrpc.server.integration import flask as integration\n\n    app = flask.Flask(__name__)\n\n    methods = xjsonrpc.server.MethodRegistry()\n\n\n    class UserNotFound(xjsonrpc.exc.JsonRpcError):\n        code = 1\n        message = 'user not found'\n\n\n    @methods.add\n    def add_user(user: dict):\n        user_id = uuid.uuid4().hex\n        flask.current_app.users[user_id] = user\n\n        return {'id': user_id, **user}\n\n    @methods.add\n     def get_user(self, user_id: str):\n        user = flask.current_app.users.get(user_id)\n        if not user:\n            raise UserNotFound(data=user_id)\n\n        return user\n\n\n    json_rpc = integration.JsonRPC('/api/v1')\n    json_rpc.dispatcher.add_methods(methods)\n\n    app.users = {}\n\n    json_rpc.init_app(app)\n\n    if __name__ == \"__main__\":\n        app.run(port=80)\n\n\n\nOpen API specification\n______________________\n\n``xjsonrpc`` has built-in `OpenAPI <https://swagger.io/specification/>`_ and `OpenRPC <https://spec.open-rpc.org/#introduction>`_\nspecification generation support and integrated web UI as an extra dependency. Three UI types are supported:\n\n- SwaggerUI (`<https://swagger.io/tools/swagger-ui/>`_)\n- RapiDoc (`<https://mrin9.github.io/RapiDoc/>`_)\n- ReDoc (`<https://github.com/Redocly/redoc>`_)\n\nWeb UI extra dependency can be installed using the following code:\n\n.. code-block:: console\n\n    $ pip install xjsonrpc[openapi-ui-bundles]\n\nThe following example illustrates how to configure OpenAPI specification generation\nand Swagger UI web tool with basic auth:\n\n.. code-block:: python\n\n    import uuid\n    from typing import Any, Optional\n\n    import flask\n    import flask_httpauth\n    import pydantic\n    import flask_cors\n    from werkzeug import security\n\n    import xjsonrpc.server.specs.extractors.pydantic\n    from xjsonrpc.server.integration import flask as integration\n    from xjsonrpc.server.validators import pydantic as validators\n    from xjsonrpc.server.specs import extractors, openapi as specs\n\n\n    app = flask.Flask('myapp')\n    flask_cors.CORS(app, resources={\"/myapp/api/v1/*\": {\"origins\": \"*\"}})\n\n    methods = xjsonrpc.server.MethodRegistry()\n    validator = validators.PydanticValidator()\n\n    auth = flask_httpauth.HTTPBasicAuth()\n    credentials = {\"admin\": security.generate_password_hash(\"admin\")}\n\n\n    @auth.verify_password\n    def verify_password(username: str, password: str) -> Optional[str]:\n        if username in credentials and security.check_password_hash(credentials.get(username), password):\n            return username\n\n\n    class AuthenticatedJsonRPC(integration.JsonRPC):\n        @auth.login_required\n        def _rpc_handle(self, dispatcher: xjsonrpc.server.Dispatcher) -> flask.Response:\n            return super()._rpc_handle(dispatcher)\n\n\n    class JSONEncoder(xjsonrpc.JSONEncoder):\n        def default(self, o: Any) -> Any:\n            if isinstance(o, pydantic.BaseModel):\n                return o.dict()\n            if isinstance(o, uuid.UUID):\n                return str(o)\n\n            return super().default(o)\n\n\n    class UserIn(pydantic.BaseModel):\n        \"\"\"\n        User registration data.\n        \"\"\"\n\n        name: str\n        surname: str\n        age: int\n\n\n    class UserOut(UserIn):\n        \"\"\"\n        Registered user data.\n        \"\"\"\n\n        id: uuid.UUID\n\n\n    class AlreadyExistsError(xjsonrpc.exc.JsonRpcError):\n        \"\"\"\n        User already registered error.\n        \"\"\"\n\n        code = 2001\n        message = \"user already exists\"\n\n\n    class NotFoundError(xjsonrpc.exc.JsonRpcError):\n        \"\"\"\n        User not found error.\n        \"\"\"\n\n        code = 2002\n        message = \"user not found\"\n\n\n    @specs.annotate(\n        tags=['users'],\n        errors=[AlreadyExistsError],\n        examples=[\n            specs.MethodExample(\n                summary=\"Simple example\",\n                params=dict(\n                    user={\n                        'name': 'John',\n                        'surname': 'Doe',\n                        'age': 25,\n                    },\n                ),\n                result={\n                    'id': 'c47726c6-a232-45f1-944f-60b98966ff1b',\n                    'name': 'John',\n                    'surname': 'Doe',\n                    'age': 25,\n                },\n            ),\n        ],\n    )\n    @methods.add\n    @validator.validate\n    def add_user(user: UserIn) -> UserOut:\n        \"\"\"\n        Creates a user.\n\n        :param object user: user data\n        :return object: registered user\n        :raise AlreadyExistsError: user already exists\n        \"\"\"\n\n        for existing_user in flask.current_app.users_db.values():\n            if user.name == existing_user.name:\n                raise AlreadyExistsError()\n\n        user_id = uuid.uuid4().hex\n        flask.current_app.users_db[user_id] = user\n\n        return UserOut(id=user_id, **user.dict())\n\n\n    @specs.annotate(\n        tags=['users'],\n        errors=[NotFoundError],\n        examples=[\n            specs.MethodExample(\n                summary='Simple example',\n                params=dict(\n                    user_id='c47726c6-a232-45f1-944f-60b98966ff1b',\n                ),\n                result={\n                    'id': 'c47726c6-a232-45f1-944f-60b98966ff1b',\n                    'name': 'John',\n                    'surname': 'Doe',\n                    'age': 25,\n                },\n            ),\n        ],\n    )\n    @methods.add\n    @validator.validate\n    def get_user(user_id: uuid.UUID) -> UserOut:\n        \"\"\"\n        Returns a user.\n\n        :param object user_id: user id\n        :return object: registered user\n        :raise NotFoundError: user not found\n        \"\"\"\n\n        user = flask.current_app.users_db.get(user_id.hex)\n        if not user:\n            raise NotFoundError()\n\n        return UserOut(id=user_id, **user.dict())\n\n\n    @specs.annotate(\n        tags=['users'],\n        errors=[NotFoundError],\n        examples=[\n            specs.MethodExample(\n                summary='Simple example',\n                params=dict(\n                    user_id='c47726c6-a232-45f1-944f-60b98966ff1b',\n                ),\n                result=None,\n            ),\n        ],\n    )\n    @methods.add\n    @validator.validate\n    def delete_user(user_id: uuid.UUID) -> None:\n        \"\"\"\n        Deletes a user.\n\n        :param object user_id: user id\n        :raise NotFoundError: user not found\n        \"\"\"\n\n        user = flask.current_app.users_db.pop(user_id.hex, None)\n        if not user:\n            raise NotFoundError()\n\n\n    json_rpc = AuthenticatedJsonRPC(\n        '/api/v1',\n        json_encoder=JSONEncoder,\n        spec=specs.OpenAPI(\n            info=specs.Info(version=\"1.0.0\", title=\"User storage\"),\n            servers=[\n                specs.Server(\n                    url='http://127.0.0.1:8080',\n                ),\n            ],\n            security_schemes=dict(\n                basicAuth=specs.SecurityScheme(\n                    type=specs.SecuritySchemeType.HTTP,\n                    scheme='basic',\n                ),\n            ),\n            security=[\n                dict(basicAuth=[]),\n            ],\n            schema_extractor=extractors.pydantic.PydanticSchemaExtractor(),\n            ui=specs.SwaggerUI(),\n            # ui=specs.RapiDoc(),\n            # ui=specs.ReDoc(),\n        ),\n    )\n    json_rpc.dispatcher.add_methods(methods)\n\n    app.users_db = {}\n\n    myapp = flask.Blueprint('myapp', __name__, url_prefix='/myapp')\n    json_rpc.init_app(myapp)\n\n    app.register_blueprint(myapp)\n\n    if __name__ == \"__main__\":\n        app.run(port=8080)\n\n\nSpecification is available on http://localhost:8080/myapp/api/v1/openapi.json\n\nWeb UI is running on http://localhost:8080/myapp/api/v1/ui/\n\nSwagger UI:\n~~~~~~~~~~~\n\n.. image:: docs/source/_static/swagger-ui-screenshot.png\n  :width: 1024\n  :alt: Open API full example\n\nRapiDoc:\n~~~~~~~~\n\n.. image:: docs/source/_static/rapidoc-screenshot.png\n  :width: 1024\n  :alt: Open API cli example\n\nRedoc:\n~~~~~~\n\n.. image:: docs/source/_static/redoc-screenshot.png\n  :width: 1024\n  :alt: Open API method example\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/bernhardkaindl/xjsonrpc",
    "keywords": "json-rpc,rpc,jsonrpc-client,jsonrpc-server,requests,aiohttp,flask,httpx,aio-pika,kombu,openapi,openrpc,starlette,django",
    "license": "Public Domain License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "xjsonrpc",
    "package_url": "https://pypi.org/project/xjsonrpc/",
    "platform": null,
    "project_url": "https://pypi.org/project/xjsonrpc/",
    "project_urls": {
      "Documentation": "https://xjsonrpc.readthedocs.io/en/latest/",
      "Homepage": "https://github.com/bernhardkaindl/xjsonrpc",
      "Source": "https://github.com/bernhardkaindl/xjsonrpc"
    },
    "release_url": "https://pypi.org/project/xjsonrpc/1.4.3/",
    "requires_dist": [
      "aio-pika (~=7.0) ; extra == 'aio-pika'",
      "aiohttp (~=3.0) ; extra == 'aiohttp'",
      "django (~=3.0) ; extra == 'django'",
      "docstring-parser (~=0.0) ; extra == 'docstring-parser'",
      "flask (~=2.0) ; extra == 'flask'",
      "requests (~=0.0) ; extra == 'httpx'",
      "jsonschema (~=3.0) ; extra == 'jsonschema'",
      "kombu (~=5.0) ; extra == 'kombu'",
      "openapi-ui-bundles (~=0.0) ; extra == 'openapi-ui-bundles'",
      "pydantic (~=1.8.0) ; extra == 'pydantic'",
      "requests (~=2.0) ; extra == 'requests'",
      "starlette (~=0.12.0) ; extra == 'starlette'",
      "aiofiles (~=0.7) ; extra == 'starlette'",
      "aioresponses (~=0.0) ; extra == 'test'",
      "docstring-parser (~=0.0) ; extra == 'test'",
      "flask (~=2.0) ; extra == 'test'",
      "jsonschema (~=3.0) ; extra == 'test'",
      "pytest (~=6.0) ; extra == 'test'",
      "pytest-aiohttp (~=0.0) ; extra == 'test'",
      "pytest-mock (~=3.0) ; extra == 'test'",
      "responses (~=0.0) ; extra == 'test'",
      "respx (~=0.0) ; extra == 'test'",
      "pydantic (~=1.8.0) ; extra == 'test'",
      "werkzeug (~=2.0) ; extra == 'test'",
      "openapi-ui-bundles (~=0.0) ; extra == 'test'"
    ],
    "requires_python": ">=3.6",
    "summary": "Extensible JSON-RPC library",
    "version": "1.4.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13674504,
  "releases": {
    "1.4.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "af091e7ba12497468b05015be56be5f90670f0e9011dc659a0c76fdf445a4e8c",
          "md5": "68506ea9227d6f9fb310ec0daded4060",
          "sha256": "1ce7a09a712b017444b14d35b6933f62d30bd6f13b7eb8f5a1dfd05487bb6740"
        },
        "downloads": -1,
        "filename": "xjsonrpc-1.4.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "68506ea9227d6f9fb310ec0daded4060",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 64823,
        "upload_time": "2022-04-14T12:22:29",
        "upload_time_iso_8601": "2022-04-14T12:22:29.324320Z",
        "url": "https://files.pythonhosted.org/packages/af/09/1e7ba12497468b05015be56be5f90670f0e9011dc659a0c76fdf445a4e8c/xjsonrpc-1.4.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cc4efc0cb20a896fb19404f641cf570bdf2b1843f543c1e770c0223b9b8f9c23",
          "md5": "237552388e346b8906dd3b3762e6760f",
          "sha256": "e54e594b9cf5d3c16ab7cbabb2e4f428f49165825436e483fa8f5fddd1a1553d"
        },
        "downloads": -1,
        "filename": "xjsonrpc-1.4.2.tar.gz",
        "has_sig": false,
        "md5_digest": "237552388e346b8906dd3b3762e6760f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 63845,
        "upload_time": "2022-04-14T12:22:31",
        "upload_time_iso_8601": "2022-04-14T12:22:31.696437Z",
        "url": "https://files.pythonhosted.org/packages/cc/4e/fc0cb20a896fb19404f641cf570bdf2b1843f543c1e770c0223b9b8f9c23/xjsonrpc-1.4.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d83312277ba850259ab29516466c30a4e6fe3f144dd4d4b54cf6675ae98ab93d",
          "md5": "b53affdd20aee3ca3c969b14634564b6",
          "sha256": "3d23a4ca0649b49e1d90dfceb92fa571e98dfa4ad8477da1b72f398d8460f0cf"
        },
        "downloads": -1,
        "filename": "xjsonrpc-1.4.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b53affdd20aee3ca3c969b14634564b6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 64822,
        "upload_time": "2022-04-30T13:11:39",
        "upload_time_iso_8601": "2022-04-30T13:11:39.000623Z",
        "url": "https://files.pythonhosted.org/packages/d8/33/12277ba850259ab29516466c30a4e6fe3f144dd4d4b54cf6675ae98ab93d/xjsonrpc-1.4.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5cf5f39b4a4e833072a7eabeaa4ba7267558b508e5afac1c0dd066d00d24733b",
          "md5": "4a3ef0583e259fffa3e6444ea5b9ea24",
          "sha256": "429e2d6246d219aac69a85825147fa871ce4eeb6da890e7071c274c377a380c5"
        },
        "downloads": -1,
        "filename": "xjsonrpc-1.4.3.tar.gz",
        "has_sig": false,
        "md5_digest": "4a3ef0583e259fffa3e6444ea5b9ea24",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 63835,
        "upload_time": "2022-04-30T13:11:41",
        "upload_time_iso_8601": "2022-04-30T13:11:41.645960Z",
        "url": "https://files.pythonhosted.org/packages/5c/f5/f39b4a4e833072a7eabeaa4ba7267558b508e5afac1c0dd066d00d24733b/xjsonrpc-1.4.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d83312277ba850259ab29516466c30a4e6fe3f144dd4d4b54cf6675ae98ab93d",
        "md5": "b53affdd20aee3ca3c969b14634564b6",
        "sha256": "3d23a4ca0649b49e1d90dfceb92fa571e98dfa4ad8477da1b72f398d8460f0cf"
      },
      "downloads": -1,
      "filename": "xjsonrpc-1.4.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "b53affdd20aee3ca3c969b14634564b6",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 64822,
      "upload_time": "2022-04-30T13:11:39",
      "upload_time_iso_8601": "2022-04-30T13:11:39.000623Z",
      "url": "https://files.pythonhosted.org/packages/d8/33/12277ba850259ab29516466c30a4e6fe3f144dd4d4b54cf6675ae98ab93d/xjsonrpc-1.4.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5cf5f39b4a4e833072a7eabeaa4ba7267558b508e5afac1c0dd066d00d24733b",
        "md5": "4a3ef0583e259fffa3e6444ea5b9ea24",
        "sha256": "429e2d6246d219aac69a85825147fa871ce4eeb6da890e7071c274c377a380c5"
      },
      "downloads": -1,
      "filename": "xjsonrpc-1.4.3.tar.gz",
      "has_sig": false,
      "md5_digest": "4a3ef0583e259fffa3e6444ea5b9ea24",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 63835,
      "upload_time": "2022-04-30T13:11:41",
      "upload_time_iso_8601": "2022-04-30T13:11:41.645960Z",
      "url": "https://files.pythonhosted.org/packages/5c/f5/f39b4a4e833072a7eabeaa4ba7267558b508e5afac1c0dd066d00d24733b/xjsonrpc-1.4.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}