{
  "info": {
    "author": "Szymon Nieradka",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "# Snowflake CICD utility\n\nPython based **CICD** tool for for managing Snowflake databases.\n\n**Table of contents:**\n\n1. [Installation](#installation)\n2. [Configuration](#configuration)\n3. [Usage](#usage)\n4. [Work cycle](#work-cycle)\n5. [Use cases](#use-cases)\n6. [How it works](#how-it-works)\n7. [Troubleshooting](#troubleshooting)\n\n<a name=\"installation\"></a>\n## Installation\n\n#### 1. Install Python\n\nMake sure that `python3` executable is present in your path:\n\n```sh\n$ python3\nPython 3.7.7 (default, Mar 10 2020, 15:43:33)\n[Clang 11.0.0 (clang-1100.0.33.17)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```\n\nDeployment script won't work with Python2!\n\n#### 2. Install python dependencies\n\nThis should be as easy as running:\n\n```sh\n$ python3 -m pip install -r requirements.txt\n```\n\nOf course you can use `pip` instead, but this way it easier to make sure the packages will be installed in a proper location.\n\nFeel free to use one of Python's environment managers.\n\n<a name=\"configuration\"></a>\n## Configuration\n\nCurrent version supports [Key Pair Authentication](https://docs.snowflake.com/en/user-guide/python-connector-example.html#using-key-pair-authentication) with Snowflake. Only unencrypted keys are supported! There is an undocumented username+password method but should not be used.\n\nIf you have your key pair already generated you can jump to section **3**.\n\n#### 1. Generate key pair\n\nGenerate unencrypted private key:\n\n```sh\n$ openssl genrsa 2048 | openssl pkcs8 -topk8 -inform PEM -out [username]_snowflake.p8 -nocrypt\n```\n\nNow generate the public key by referencing the private key:\n\n```sh\n$ openssl rsa -in [username]_snowflake.p8 -pubout -out [username]_snowflake.pub\n```\n\nAssign the public key to the Snowflake user using ALTER USER. Run the query using your Snowflake's client:\n\n```sql\nalter user [username] set rsa_public_key='MIIBIjANBgkqh...\nWbyzHiMVJw8u+...\nxwIDAQAB';\n```\n\nTo fill in the `rsa_public_key` part you have to copy `[username]_snowflake.pub` file contents and paste it in SQL console.\n\n**Note:** You have to remove `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----` lines from public key in your SQL query.\n\nNow place your keys in a safe location. For Linux and OSX this can be for example:\n\n```sh\n$ mv [username]_snowflake.* ~/.ssh/\n```\n\n#### 2. Prepare data model repository\n\nPrepare (or reuse existing) GIT repository that holds data model.\n\nIf you don't have one, you can follow this procedure:\n\n```sh\n# you are in `snowflake-cicd` folder\n$ cp -r model-repo-sample ../data_model\n$ cd ../data_model\n$ git init\n```\n\n#### 3. Update configuration file\n\nGo to your model GIT repository, and open `.snowflake-cicd.ini` file:\n\n```sh\n# you are in `snowflake-cicd` folder\n$ cp snowflake-cicd.ini ~/.snowflake-cicd.ini\n$ edit .snowflake-cicd.ini\n```\n\nIn the `.snowflake-cicd.ini` file you have to fill in at least two fields: `user` and `private_key`.\n\n<a name=\"usage\"></a>\n## Usage\n\nYou can run `cicd` without arguments to see help:\n\n```sh\n$ cicd\nusage: cicd [-h] [-v] [-t] [-f]\n                 {abandoned,clone,compare,deploy,diff,history,migrate,prepare,sync,test_sync}\n                 [{abandoned,clone,compare,deploy,diff,history,migrate,prepare,sync,test_sync} ...]\n\nGit <-> Snowflake sync and automatic deployment.\n\nActions:\n\n  prepare               Prepares release candidate file.\n  deploy                Deploys changes from release candidate file.\n  migrate               prepare + deploy \n  validate              Validates all .sql files in model directory\n  history               Prints release history.\n  clone                 Clones (or replaces) database based on prod.\n  sync                  Syncs unapplied changes from model and releases dirs.\n  test_sync             Test release on a separate clone (run it before creating pull request).\n  compare               Compares Snowflake and current branch DDLs.\n  diff                  Prints diff from production.\n  abandoned             Compares active branches and development clones.\n\npositional arguments:\n  {prepare,deploy,migrate,validate,history,clone,sync,test_sync,compare,diff,abandoned}\n                        Action to run\n                        Action to run\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --verbose         Verbose mode. Shows SQL statements.\n  -t, --dry-run         Show SQL to be executed, but doesn't run it.\n  -f, --force           Force command without yes/no question asked in terminal.\n  --file [FILE]         Filename for compare action\n```\n\n<a name=\"actions\"></a>\n### Actions\n\n<a name=\"abandoned\"></a>\n#### `abandoned`\n\nCompares active development branches and database clones. It does so by querying all the databases `LIKE '_DEV%'` in `INFORMATION_SCHEMA.DATABASES`. For each clone found it is searching for a corresponding branch.\n\n<a name=\"branch-clone-mapping\"></a>Branch names are converted to database clone names this way:\n\n1. Uppercase\n2. Replace all non-words characters (`\\W`) with underscore (`_`)\n3. Take first 30 chars\n4. Add prefix `_DEV_`\n\nThis way branch `feature/DW-1249-create-pre-deploy-and-post-deploy-tests` is mapped to `_DEV_FEATURE_DW_1249_CREATE_PRE_DEP`.\n\n**`abandoned` example output:**\n\n```\n|____________clone_____________|_____created______|_____updated______|_has branch?__|\n| _DEV_DW_1336_CREATE_A_SAMPLE | 2020-04-20 17:18 | 2020-04-20 17:19 |      no      |\n| _DEV_FEATURE_A               | 2020-04-22 12:04 | 2020-04-22 12:06 |      no      |\n| _DEV_FEATURE_SQL_QUERIES_IN_ | 2020-04-23 19:27 | 2020-04-23 19:29 |      no      |\n| _DEV_FEATURE_DW_1249_CREATE_ | 2020-04-24 23:13 | 2020-04-24 23:14 |     yes      |\n```\n\nDatabase clones with `no` in the last column (`has branch?`) should be dropped.\n\n<a name=\"clone\"></a>\n#### `clone`\n\nClones (or replaces) database based on production. New clone is created based on active branch name (see [branch to clone mapping](#branch-clone-mapping) in [abandoned](#abandoned) action to learn how branch name is mapped to clone name). Due to this it is impossible to run `clone` on main branch (**CICD** will refuse to run).\n\nIf target clone does not exist the action will perform immediately. If target clone exists **CICD** will ask for confirmation before running. This behavior can be overwritten by `--force` flag.\n\n**`clone` example output:**\n\n```\nChecking if _DEV_FEATURE_A already exists...\n_DEV_FEATURE_A already exists. Are you sure you want to replace it (y/n): y\nCloning DWH into _DEV_FEATURE_A\nCloning finished\n```\n\nExample run on `main` branch:\n```\nTrying to create new database with name dwh...\n```\n\n<a name=\"compare\"></a>\n#### `compare`\n\nCompare allows you to list all the objects modified in your cloned database since cloning. The comparison is made purely on a database level. Even if altered an object manually on the server (ignoring GIT and releases history table) the object will be listed.\n\nTechnically compare list all the objects from `INFORMATION_SCHEMA`.`[TABLES|FUNCTIONS|FILE_FORMATS|EXTERNAL_TABLES|PIPES|PROCEDURES|SEQUENCES|STAGES|VIEWS]` looking for those with `LAST_ALTERED` greater than current clone creation time (+1 minute).\n\nComparison algorithm assumes the object was changed in both situation: it's definition has changed or it contents has changed (in case of a table).\n\n**`compare` example output:**\n\n```\n|___schema___|__________object name___________|____type____|___last change____|\n|     PUBLIC . dwh_releases_history           |   TABLE    | 2020-04-12 15:42 |\n|        RAW . lnk_event_sess                 |   TABLE    | 2020-04-12 15:42 |\n|        RAW . hub_event                      |   TABLE    | 2020-04-12 15:42 |\n|         DM . dim_page                       |    VIEW    | 2020-04-12 15:42 |\n|        RAW . load_hub_session               | PROCEDURE  | 2020-04-12 15:42 |\n|        BIZ . sat_event                      |    VIEW    | 2020-04-12 15:42 |\n```\n\nIn the example above all the listed objects were somehow altered after the clone was created. All the (beside `dwh_releases_history`) should be included in release file.\n\n<a name=\"deploy\"></a>\n#### `deploy`\n\nDeploys changes from release candidate file.\n\n<a name=\"diff\"></a>\n#### `diff`\n\nShow all the changes in `model` folder between current branch and `main`. Technically it runs:\n\n```\n$ git diff --color=always main model\n```\n\n**`diff` example output:**\n\n```diff\ndiff --git a/model/DV_Layers/dm/Dimension/tables/dim_time.sql b/model/DV_Layers/dm/Dimension/tables/dim_time.sql\nindex c9a758c..3303895 100644\n@@ -2,7 +2,7 @@ CREATE TABLE dm.dim_time\n        sk_time varchar(4) PRIMARY KEY NOT NULL,\n        time_of_day     varchar(8) NOT NULL,\n-       hour_of_day varchar(2) NOT NULL,\n+       hour_of_day varchar(4) NOT NULL,\n        minute_of_hour varchar(2) NOT NULL\n```\n\n<a name=\"history\"></a>\n#### `history`\n\nThis action displays a comparison of all the releases applied in on clone and production. It works only on a database level. Use [diff](#diff) action if you want to see the comparison on GIT level.\n\nTechnically the comparison is done by comparing entries in tables `PUBLIC.DWH_RELEASES_HISTORY` both in the production database, and cloned database.\n\n**`history` example output:**\n\n```\n|_commit hash_|___________file name____________|__applied by__|____applied on____|branch|_prod_|\n| bc2cbffee0  | <<init>>                       |     USER     | 2020-04-05 15:16 |  •   |  •   |\n| 84d474c10a  | lites/views/view_sat_event.sql |     USER     | 2020-04-08 14:55 |  •   |  •   |\n| dffcae544d  | imension/views/dim_browser.sql |     USER     | 2020-04-08 14:56 |  •   |  •   |\n| dc84b4ac53  | m/Dimension/views/dim_page.sql |     USER     | 2020-04-08 14:56 |  •   |  •   |\n| 0b66beaeac  | releases/fact_visits.sql       |     USER     | 2020-04-08 14:56 |      |  •   |\n| 4f79836a92  | releases/dim_page.sql          |     USER     | 2020-04-08 14:57 |  •   |      |\n```\n\nIn the example above we can see that:\n\n1. Release file named `releases/dim_page.sql` was applied only in our branch. Most likely this is something we did in our branch.\n2. Release file named `releases/fact_visits.sql` was applied on production but not applied in our clone. There are two possible ways of syncing with production:\n  a. Faster: apply this missing release file by running [sync](#sync) action.\n  b. Safer: run [clone](#clone) again to get a fresh copy of production.\n\n\n<a name=\"migrate\"></a>\n#### `migrate`\n\nThis is an equivalent of:\n\n```sh\n$ cicd prepare deploy\n```\n\nIn other words it prepares `releases/release_candidate.sql` file first, and then releases it. This can work only if you are making safe changes (as described in [prepare](#prepare) action).\n\n<a name=\"prepare\"></a>\n#### `prepare`\n\nPrepares release candidate file. Let's assume we are on a branch `feature/a` and we already [cloned](#clone) database into `_DEV_FEATURE_A` (as described in [branch to clone mapping](#branchclonemapping)). Prepare works this way:\n\n1. Getting latest applied commit in a current clone. It's as simple as selecting the latest `COMMIT` from `_DEV_FEATURE_A.PUBLIC.DWH_RELEASES_HISTORY`.\n2. Getting all the modified (renamed, removed, added) files in `model` folder. These files were not yet applied on current clone.\n3. Creating the file: `releases/release_candidate.sql`. This file has a recipe on how to apply changes on clone. Additionally `releases/release_candidate.sha` file is created with `release_candidate.sql` checksum inside.\n\n`release_candidate.sql` file contains entries in this form:\n\n```SQL\n--.Release candidate file, branch: feature_a\n\n--.File was changed but *will not be* included in the release.\n-- [M] NOT_INCLUDED:model/DV_Layers/dm/Dimension/tables/dim_time.sql\n--.DIFF: @@ -5 +5 @@ CREATE TABLE dm.dim_time\n--.DIFF: -\thour_of_day varchar(2) NOT NULL,\n--.DIFF: +\thour_of_day varchar(3) NOT NULL,\n\n   You may need to include an ALTER TABLE statement to properly sync database state:\n   ALTER TABLE DM.DIM_TIME <<HERE>>;\n\n--.File was changed and will be included in the release.\n--.You can change the order of the INCLUDE: statement below.\n-- [M] INCLUDED:model/DV_Layers/dm/Dimension/views/dim_event_la.sql\n```\n\nAs you can see each modified (renamed, removed, added) leaves an entry in `release_candidate.sql`. There are two main types of entries:\n\n<a name=\"safe-changes\"></a>\n##### Safe changes\n\nSafe changes are those that can be applied without any additional attention. These are:\n\n* newly created files\n* modified files with objects other that tables and streams\n\nYou can easily notice that view `dim_event_la.sql` is a safe change. Updated view definition can be easily applied on the server. There are two easy ways of detecting safe changes:\n\n1. By looking at `INCLUDED:` keyword in file description line\n2. By having no non-comment lines below the entry. Notice that there is nothing below `[M] INCLUDED:model/.../dim_event_la.sql`\n\nIn most of the cases you don't have to do anything with this entries. Exceptions are:\n\n1. This is a table or stream object definition that you already added into production database.\n\n    In this case you should change keyword `INCLUDE` to `NOT_INCLUDE` to avoid table/stream definition being executed. \n2. The order or `INCLUDE` statements is wrong.\n\n    In this case you shoud reorder the entries accordingly. You have to be careful with lines with filenames. Those starting from `--.` are comments that can be ignored.\n\n<a name=\"unsafe-changes\"></a>\n##### Unsafe changes\n\nUnsafe changes are:\n\n* modified or renamed files with table or stream definition\n* removed files with objects of any type definition\n\nYou can easily notice that table `dim_time.sql` is **not** a safe change. Updated table definition can not be easily applied on the server. You have to prepare a proper `ALTER TABLE` statement. There are two easy ways of detecting unsafe changes:\n\n1. By looking at `NON_INCLUDED:` keyword in file description line\n2. By having a non-comment lines below the entry. Notice the sentences below `[M] INCLUDED:model/.../dim_time.sql`\n\nYour job here is to replace the suggestion and sample code generated by **CICD** and fill it in with a valid SQL statement (if necessary). In the example above we should replace:\n\n```sql\n   You may need to include an ALTER TABLE statement to properly sync database state:\n   ALTER TABLE DM.DIM_TIME <<HERE>>;\n```\nwith:\n```sql\nALTER TABLE DM.DIM_TIME CHANGE hour_of_day hour_of_day varchar(3) NOT NULL;\n```\n\nTo make this process easier you have a difference highlighted. Notice lines starting from `--.DIFF:`\n\n```diff\n@@ -5 +5 @@ CREATE TABLE dm.dim_time\n-\thour_of_day varchar(2) NOT NULL,\n+\thour_of_day varchar(3) NOT NULL,\n```\n\n<a name=\"sync\"></a>\n#### `sync`\n\nSync performs all the missing releases in `releases` folder and run them against the database. It is somehow similar to `prepare` but it scans `releases` folder (with already prepared releases) instead of raw `model` folder.\n\nSyncing can be necessary if you merge changes from other branch (including `main`) into your branch. Imagine this scenario:\n\n1. You branched out to `feature/a` and created already a release file `releases/feature_a.sql`.\n2. Other person was working on a `feature/b`, created `releases/feature_b.sql` and merge it to `main`.\n3. You decided to `git merge` before creating a pull request. This created `releases/feature_b.sql` in your repository. You have two options (as described in [history](#history) action):\n  a. Faster: apply this missing release file by running [sync](#sync) action.\n  b. Safer: run [clone](#clone) again to get a fresh copy of production.\n\n**`sync` example output:**\n\n```\n  [A] releases/feature_DW-1249-create-pre-deploy-and-post-deploy-tests.sql\nSyncing changes:\nRunning release file releases/feature_DW-1249-create-pre-deploy-and-post-deploy-tests.sql:\n   'DWH_RELEASES_HISTORY was sucesfully created',\nNew entry in release history table with d31197261424b6c96ae7b8d31fcc1ac9220f934b\n```\n\n<a name=\"test_sync\"></a>\n#### `test_sync`\n\nTest sync combines three operations in one action:\n\n1. Creates a fresh clone of production database. This clone has a new name made out last commit SHA, not branch name. This way it's independent from all you existing changes.\n2. Syncs all the unsynchronized releases in `releases` directory.\n3. Drops clone created in step 1.\n\nThis step is useful for testing your changes before creating a pull-request. It ensures your release file is deployable on production.\n\n**`test_sync` example output:**\n\n```\nCloning DWH into _DEV_26FC3058369ACECB30C48A9C69FB47\nCloning finished\n   [A] releases/feature_DW-1249-create-pre-deploy-and-post-deploy-tests.sql\nSyncing changes:\nRunning release file releases/ feature_DW-1249-create-pre-deploy-and-post-deploy-tests.sql:\n   'DWH_RELEASES_HISTORY was sucesfully created',\n New entry in release history table with d31197261424b6c96ae7b8d31fcc1ac9220f934b\n Dropping clone _DEV_26FC3058369ACECB30C48A\n```\n\n#### Optional arguments\n\n##### `--help`\n\nDisplays help message. Running **CICD** without arguments will also cause the script to show help.\n\n<a name=\"verbose\"></a>\n##### `--verbose`\n\nUse `--verbose` or `-v` to display more details. It enables debugging messages and print-outs all the SQL queries being raised against Snowflake.\n\n##### `--dry-run`\n\nUse `--dry-run` or `-t` with [deploy](#deploy) or [sync](#sync) actions to preview the release SQL to be performed. Has no impact on other actions.\n\n##### `--force`\n\nUse `--force` or `-f` to:\n\n1. Ignore question _Clone already exists. Are you sure you want to replace it_ while running [clone](#clone) action.\n2. Bypass error _releases/release_candidate.sql was changed or you changed branch, can't create new release candidate._ In this case it the file will be overwritten.\n\n<a name=\"work-cycle\"></a>\n### Work cycle\n\n#### 1. Create branch\n\nStart from branching out from main branch. It's usually `main` but it doesn't have to. You can branch out from other active branch.\n\nYou can branch-out using Jira, Bitbucket or command line. In all the examples below we are going to use command line and we are going to work on branch `feature/a`.\n\n```sh\n# checking active branch\n$ git status\nOn branch main\n[...]\n# making sure we have all the latest changes\n$ git pull\n# branching out\n$ git checkout -b feature/a\n```\n\n#### 2. Clone database\n\nWe have a branch to work on. Now we need a fresh clone of production to have a safe destination of all our changes.\n\nClone database into new `_DEV_FEATURE_A` with:\n\n```sh\n$ cicd clone\n```\n\n(read more about [cloning](#clone))\n\nNow we have a new branch `feature/a` and new development clone `_DEV_FEATURE_A`. Both equal to production.\n\n#### 3. Modify and deploy changes\n\nWork on files in the `model/` folder and [migrate](#migrate) all the changes with:\n\n```sh\n$ cicd migrate\n```\n\n[Migrate](#migrate) is actually running two tasks: [prepare](#prepare) followed by [deploy](#deploy). The second step can raise an error if you made an [unsafe change](#unsafe-changes). It usually happens the moment you changed table or stream, or you dropped a file from `model` folder.\n\nIn this case the script raises an error:\n\n```\nCode placeholder (<<HERE>>) found in the release candidate file.\n```\n\nYou have to manually change the `releases/release_candidate.sql` file as described in [unsafe changes](#unsafe-changes) section. Once done you can repeat the second step with:\n\n```sh\n$ cicd deploy\n```\n\nYou should notice that while you modify files in `model` folder and deploy your changes in your clone, there is a new file being updated after each action. It's `releases/feature_a.sql` file. This file holds all the changes you've made.\n\n#### 4. Check your changes\n\nYou are give three ways to check your changes. Let's start from source code level.\n\nTo preview detailed [diff](#diff) of your branch against production run:\n\n```sh\n$ cicd diff\n```\n\nYou can also compare all the releases applied on your clone and compare the with production by running [history](#history) action:\n\n```sh\n$ cicd history\n```\n\nThe last option to examine your changes is it preview all the objects definitions changed in your cloned database since it's creation. To do so run [compare](#compare):\n\n```sh\n$ cicd compare\n```\n\n#### 5. Test your changes\n\nBefore submitting a pull-request test your changes against a fresh copy of your database. There is a command that automates all the steps. It [test_sync](#test_sync):\n\n```sh\n$ cicd test_sync\n```\n\nIf it's all good you are ready to create a pull-request!\n\n<a name=\"#use-cases\"></a>\n### Use cases\n\n#### 1. Changing object definition\n\nAll situations in which you modify an object DDL. This including renaming the object (and a corresponding file).\n\n##### a) [safe changes](#safe-changes)\n\nThis is the simplest scenario. Open any `.sql` file under `model/` folder and perform changes. Then run:\n\n```sh\n$ cicd migrate\n```\n\nThe script will detect the change and reapply it on the server. \n\n##### b) [unsafe changes](#unsafe-changes)\n\nChange table or stream definition in the `model/` folder and commit your changes. Then run:\n\n```sh\n$ cicd prepare\n```\n\nOpen the `releases/release_candidate.sql` file. You will notice that the changed table is listed in the release_candidate text, and you have to manually add a proper `ALTER TABLE` SQL statement.\n\nOnce done run:\n\n```sh\n$ cicd deploy\n```\n\n#### 2. Adding a new object\n\nIt's as simple as adding a new file into `model/` folder,  and commiting your changes, and running:\n\n```sh\n$ cicd migrate\n```\n\nThis works regardless the type of new object.\n\n#### 3. Dropping an object\n\nRemove a file from the `model/` folder and commit your changes. Then run:\n\n```sh\n$ cicd prepare\n```\n\nOpen the `releases/release_candidate.sql` file. You will notice that the dropped file is listed in the release_candidate text, and you have to manually add a proper `DROP OBJECT` SQL statement.\n\nOnce done run:\n\n```sh\n$ cicd deploy\n```\n\n#### 4. Altering a database state\n\nAll the other SQL statements that are not tracked in the `model/` folder can be also applied and tracked. To do so simply run:\n\n```sh\n$ cicd prepare\n```\n\nThis will generate an empty `releases/release_candidate.sql` file. Open it and add any SQL code you like.\n\nOnce done run:\n\n```sh\n$ cicd deploy\n```\n\n<a name=\"#how-it-works\"></a>\n## How it works\n\nIt's explained partially in the [Actions](#actions) section.\n\n<a name=\"#troubleshooting\"></a>\n## Troubleshooting\n\nIn most of the situations **CICD** is not leaving you alone. It explains what went wrong and what you can do about it.\n\nFor example if you start working on `model` folder before cloning, script will suggest you doing so the moment you run [prepare](#prepare) for the first time.\n\nIf your deployment script failed, the script will print out the exact SQL statement that failed, allow you to fix it and [deploy](#deploy) again.\n\nIn other cases adding [--verbose](#verbose) can be useful.\n\n<!--\nvim:spelllang=en\n-->\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/szn/snowflake-cicd/archive/refs/tags/v0.1.3.tar.gz",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/szn/snowflake-cicd",
    "keywords": "snowflake,cicd",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "snowflake-cicd",
    "package_url": "https://pypi.org/project/snowflake-cicd/",
    "platform": "",
    "project_url": "https://pypi.org/project/snowflake-cicd/",
    "project_urls": {
      "Download": "https://github.com/szn/snowflake-cicd/archive/refs/tags/v0.1.3.tar.gz",
      "Homepage": "https://github.com/szn/snowflake-cicd"
    },
    "release_url": "https://pypi.org/project/snowflake-cicd/0.1.3/",
    "requires_dist": [
      "GitPython",
      "snowflake-connector-python",
      "coloredlogs",
      "sqlparse",
      "termcolor",
      "importlib ; python_version == \"3.7\""
    ],
    "requires_python": "",
    "summary": "Snowflake CI/CD utility",
    "version": "0.1.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12124297,
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "23a81bd040d0b7619411110cd705a181f58b786e633d175184a288f3afbec27e",
          "md5": "a691aa8a4a0272e086df32dfab57249b",
          "sha256": "2bb8d39ae38c6695ab2947ff5cff23ac93a268d59d1b64c37ec1482bdf229e47"
        },
        "downloads": -1,
        "filename": "snowflake_cicd-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a691aa8a4a0272e086df32dfab57249b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28012,
        "upload_time": "2021-11-23T16:17:58",
        "upload_time_iso_8601": "2021-11-23T16:17:58.632895Z",
        "url": "https://files.pythonhosted.org/packages/23/a8/1bd040d0b7619411110cd705a181f58b786e633d175184a288f3afbec27e/snowflake_cicd-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "baa8a8faf4a9306f831d402a4d0869fadadabd1cc0eda40d594fe1568c1a3bcf",
          "md5": "276fe13459b007abc9ac6f1522ec0fcd",
          "sha256": "a202ee6f1cdab1460827def78517fe7d2c5a14abab7792461bf696e88330492e"
        },
        "downloads": -1,
        "filename": "snowflake-cicd-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "276fe13459b007abc9ac6f1522ec0fcd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 32149,
        "upload_time": "2021-11-23T16:18:00",
        "upload_time_iso_8601": "2021-11-23T16:18:00.678747Z",
        "url": "https://files.pythonhosted.org/packages/ba/a8/a8faf4a9306f831d402a4d0869fadadabd1cc0eda40d594fe1568c1a3bcf/snowflake-cicd-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "59585ad521ac5b654ea417e083ccf1deab68ae2973e9cb00a514955af317a7f7",
          "md5": "c0e6c548f12615d1bfaa50c31e0e027d",
          "sha256": "4f0f0fa3e8c632abc2d05c402d7fab657ea8026c6d6f27caeb6a7a97d5bc920a"
        },
        "downloads": -1,
        "filename": "snowflake_cicd-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c0e6c548f12615d1bfaa50c31e0e027d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28018,
        "upload_time": "2021-11-24T09:42:42",
        "upload_time_iso_8601": "2021-11-24T09:42:42.226451Z",
        "url": "https://files.pythonhosted.org/packages/59/58/5ad521ac5b654ea417e083ccf1deab68ae2973e9cb00a514955af317a7f7/snowflake_cicd-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "38c34fac60cbb017aef599ea4ad57c099f0e1ced74439bad21c408091f60eac7",
          "md5": "139bf35f20a50bd66a693ec112916688",
          "sha256": "6b987d5dcc708d980e13036b9099e138aa36d9d023f673b23c2ea1372cd2faa8"
        },
        "downloads": -1,
        "filename": "snowflake-cicd-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "139bf35f20a50bd66a693ec112916688",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 32151,
        "upload_time": "2021-11-24T09:42:43",
        "upload_time_iso_8601": "2021-11-24T09:42:43.935888Z",
        "url": "https://files.pythonhosted.org/packages/38/c3/4fac60cbb017aef599ea4ad57c099f0e1ced74439bad21c408091f60eac7/snowflake-cicd-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5f603b9b7614c6d36bb1bb154fb7f122706a401820afe88071c2691abae6bcc7",
          "md5": "2da1681d92432cad518f2c0f2a541e88",
          "sha256": "1ba37bfad09af62b9f63d8c3fadec70b18b1c2beb978c7728813bfa132547c23"
        },
        "downloads": -1,
        "filename": "snowflake_cicd-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2da1681d92432cad518f2c0f2a541e88",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28204,
        "upload_time": "2021-11-25T15:51:25",
        "upload_time_iso_8601": "2021-11-25T15:51:25.000166Z",
        "url": "https://files.pythonhosted.org/packages/5f/60/3b9b7614c6d36bb1bb154fb7f122706a401820afe88071c2691abae6bcc7/snowflake_cicd-0.1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "20464f821a706eaf9f3b65d4657617a256310d634da782e71d293fd258ec2317",
          "md5": "e886e1b9d0356343d33bc6a06702413a",
          "sha256": "9baf5ea9eb5fd874ed416a786f837d40efa424469bf654059f8b4a55cefeb83c"
        },
        "downloads": -1,
        "filename": "snowflake-cicd-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e886e1b9d0356343d33bc6a06702413a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 32387,
        "upload_time": "2021-11-25T15:51:26",
        "upload_time_iso_8601": "2021-11-25T15:51:26.733054Z",
        "url": "https://files.pythonhosted.org/packages/20/46/4f821a706eaf9f3b65d4657617a256310d634da782e71d293fd258ec2317/snowflake-cicd-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5f603b9b7614c6d36bb1bb154fb7f122706a401820afe88071c2691abae6bcc7",
        "md5": "2da1681d92432cad518f2c0f2a541e88",
        "sha256": "1ba37bfad09af62b9f63d8c3fadec70b18b1c2beb978c7728813bfa132547c23"
      },
      "downloads": -1,
      "filename": "snowflake_cicd-0.1.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2da1681d92432cad518f2c0f2a541e88",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 28204,
      "upload_time": "2021-11-25T15:51:25",
      "upload_time_iso_8601": "2021-11-25T15:51:25.000166Z",
      "url": "https://files.pythonhosted.org/packages/5f/60/3b9b7614c6d36bb1bb154fb7f122706a401820afe88071c2691abae6bcc7/snowflake_cicd-0.1.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "20464f821a706eaf9f3b65d4657617a256310d634da782e71d293fd258ec2317",
        "md5": "e886e1b9d0356343d33bc6a06702413a",
        "sha256": "9baf5ea9eb5fd874ed416a786f837d40efa424469bf654059f8b4a55cefeb83c"
      },
      "downloads": -1,
      "filename": "snowflake-cicd-0.1.3.tar.gz",
      "has_sig": false,
      "md5_digest": "e886e1b9d0356343d33bc6a06702413a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 32387,
      "upload_time": "2021-11-25T15:51:26",
      "upload_time_iso_8601": "2021-11-25T15:51:26.733054Z",
      "url": "https://files.pythonhosted.org/packages/20/46/4f821a706eaf9f3b65d4657617a256310d634da782e71d293fd258ec2317/snowflake-cicd-0.1.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}