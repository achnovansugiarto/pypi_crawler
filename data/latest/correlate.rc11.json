{
  "info": {
    "author": "Larry Hastings",
    "author_email": "larry@hastings.org",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3 :: Only"
    ],
    "description": "# correlate\n\n## A clever brute-force correlator for kinda-messy data\n\n##### Copyright 2019-2023 by Larry Hastings\n\n\n## Overview\n\n**correlate** is a data analysis library.  It's designed to find\nmatches between two datasets that conceptually represent the\nsame information, just in different formats.  Its goal is to\ntell you \"value *A* in the first dataset is a good match for\nvalue *B* in the second dataset\".\n\nTo use **correlate**, you feed in the two datasets of (opaque) values\nand their associated metadata information.  **correlate** uses the\nmetadata to find matches between the two datasets, ranks these matches\nusing a unique scoring heuristic, and returns the matches.\n\n\n### Quick Start\n\nThis code:\n\n```Python\n    import correlate\n\n    c = correlate.Correlator()\n    a, b = c.datasets\n\n    greg, carol, tony, steve = \"greg carol tony steve\".split()\n    Greg, Carol, Tony, Steve = \"Greg Carol Tony Steve\".split()\n\n    a.set(\"this\", greg)\n    a.set(\"is\", greg)\n    a.set(\"Greg\", greg, weight=5)\n    a.set_keys(\"Carol over here\".split(), carol)\n    a.set_keys(\"My name is Tony\".split(), tony)\n    a.set_keys(\"Hi I'm Steve\".split(), steve, weight=2)\n\n    b.set_keys(\"gosh my name is Greg\".split(), Greg)\n    b.set_keys(\"Carol is my name\".split() , Carol)\n    b.set_keys(\"Pretty sure I'm still Tony\".split(), Tony)\n    b.set_keys(\"I'm Steve\".split(), Steve)\n\n    result = c.correlate()\n    for match in result.matches:\n        print(f\"{match.score:1.3f} {match.value_a:>5} -> {match.value_b}\")\n```\n\nproduces this output:\n\n    5.750  greg -> Greg\n    3.800 steve -> Steve\n    1.286 carol -> Carol\n    1.222  tony -> Tony\n\n\n### A Real-Life Example\n\nThere's a podcast I like.  I download it as MP3 files\nusing an RSS feed, 1990s-style. But the metadata in the RSS\nfeed is junk--the episode titles are inconsistent,\nand the episode numbers are almost wholly absent.\n\nThis podcast also has a\nlist of episodes on its website. This data is *much* cleaner,\nincluding clean, proper episode numbers.  And it's easily\nscraped.  But it's still not perfect.\nThe two lists of episodes aren't exactly the same, and even the episodes\nthat are present in both are sometimes reordered.\n\nObviously, I want to take the MP3s from the RSS feed,\nand match them up with the nice clean metadata scraped from the website.\nThis gets me the best of both worlds.\n\nBut there are more than *seven hundred* episodes of this\nparticular podcast!  Matching those by hand would be a *lot* of work.\nAnd we get a new episode every week.\nAnd sometimes they actually add back in old episodes, or update the\nmetadata on old episodes--changes which would mess up any hand-built\nordering.  And I might want to listen to more than one podcast from\nthis same website someday!\nSo I really didn't want to do all of this by hand.\n\nHappily, after applying just a bit of intelligence to the two\ndatasets, **correlate** did a perfect job.\n\n### Why correlate Works So Well\n\nThe insight that inspired **correlate** is this:\nunique keys in the two datasets are probably very good matches.\nLet's say the key `\"egyptian\"` maps to value *A1* in one dataset\nand value *B1*  in the other dataset--and it *only* maps to those two\nvalues.  In that case, *A1* and *B1* are probably a match.\n\nThis leads to a virtuous cycle.  Let's say the word `\"nickel\"`\nmaps to two values in each of the two datasets: *A1* and *A2*,\nand *B1* and *B2*.  We have two options to match those four values:\n\n    A1->B1 and A2->B2\n    or\n    A1->B2 and A2->B1\n\nBut the key `\"egyptian\"` already told us *A1* and *B1* is\na good match.  Since we've already matched those, that\neliminates the second option.  Our only remaining choice is matching\n*A2* -> *B2*.  Choosing a good match based on `\"egyptian\"` helped\nus to eliminated extraneous possibilities and make a good choice\nbased on `\"nickel\"`, too.\n\nIn short, **correlate** capitalizes on the *relative uniqueness*\nof keys.\n\n\n## Getting Started With correlate\n\n### Requirements\n\n**correlate** requires Python 3.6 or newer.  It has no\nother dependencies.\n\nIf you want to run the **correlate** test suite,\nyou'll need to install the `rapidfuzz` package.\n(`rapidfuzz` is a fuzzy string matching library.\nIt's a lot like `fuzzywuzzy`, except `rapidfuzz`\nis MIT licensed, wheras `fuzzywuzzy` is GPL\nlicensed.)\n\n\n### The High-Level Conceptual Model\n\nTo correlate two datasets with **correlate**,\nyou first create a `correlate.Correlator` object.\nThis object contains two members\n`dataset_a` and `dataset_b`; these represent\nthe two datasets you want to correlate.\n\nYou fill each dataset with *keys* and *values*.\n\nA *value* is (nearly) any Python object.\nEach value should represent one value from your dataset.\n**correlate** doesn't examine your values--they're completely\nopaque to **correlate**.\n\nA *key* is a Python object that represents some metadata\nabout a value.  Keys \"map\" to values; **correlate** examines\nkeys, using matching keys in the two datasets to\nmatch up the values between them.\n\nKeys are usually strings--for example, the individual words\nfrom the title of some movie, TV show, song, or book.\nBut keys don't have to be strings.  Instances of lots of\nPython data types can be used as keys; they just need to\nbe hashable.\n\nOnce you've filled in the `correlate.Correlator` object\nwith your data, you call its `correlate()` method.  This\ncomputes the matches.  It returns a\n`correlate.CorrelateResult` containing\nthose matches, and lists of any objects from\nthe two datasets that didn't get matched.\n\nThe matches are returned as a list of `correlator.CorrelatorMatch`\nobjects.  Each object contains three members:\n\n* `value_a`, a reference to an object from `dataset_a`,\n* `value_b`, a reference to an object from `dataset_b`,\n* and a floating-point `score`.\n\nEach `CorrelatorMatch` object tells you that\n**correlator** thinks this `value_a` maps to this `value_b`.\nThe `score` is a sort of mathematical confidence level--it's\na direct result of the keys and other metadata you provide\nto **correlate**.  The list of matches is sorted by\n`score`--higher scores first, as higher scores represent\nhigher confidence in the match.\n\nThat's the basics.  But **correlate** supports some very sophisticated\nbehavior:\n\n* When mapping a key to a value, you may specify an optional *weight*,\n  which represents the relative importance of this key.  The default\n  weight is 1.  Higher scores indicate a higher significance; a weight of\n  2 tells **correlate** that this key mapped to this value is twice as\n  significant.  (Weight is an attribute of a particular mapping of a key\n  to a value--an \"edge\" in the graph of mapping keys to values.)\n* A key can map to a value multiple times.  Each mapping can have its own weight.\n* If both datasets are ordered, this ordering can optionally influence the match scores.\n  **correlate** calls this *ranking.*  Ranking is an attribute of values, not keys.\n* Keys can be \"fuzzy\", meaning two keys can be a partial match rather than a binary yes/no.\n  Fuzzy keys in **correlate** must inherit from a custom abstract base class called\n  `correlate.FuzzyKey`.\n\n## Sample Code And infer_mv\n\n**correlate** ships with some sample code for your reading pleasure.\nThe hope is it'll help you get a feel for what it's like to use **correlate**.\nTake a look at the scripts in the `tests` and `utilities` directories.\n\nIn particular, `utilities` contains a script called `infer_mv`.\n`infer_mv` takes a source directory and a list of files and directories\nto rename, and produces a mapping from the former to the latter.\nIn other words, when you run it, you're saying\n*\"here's a source directory and a list of files and directories to rename.\nFor each file in the list of things to rename, find the\nfilename in the source directory that most closely resembles that file,\nand rename the file so it's exactly like that other filename from the\nsource directory.\"*  (If you ask `infer_mv` to rename a directory,\nit renames all the files and directories inside that directory, recursively.)\n\nThis is useful if, for example, you have a directory where\nyou've already renamed the files the way you you like them, but then\nyou get a fresh copy from somewhere.  Simply run `infer_mv` with your\nexisting directory as the \"source directory\" and the fresh copy\nas the \"files\".  `infer_mv` will figure out how to rename the\nfresh files so they have the filenames how you like them.\n\nNote that `infer_mv` doesn't actually do the work of renaming!\nInstead, `infer_mv` prints out a *shell script* that, if executed,\nperforms the renames.\nWhy?  It's always a good idea to check over the output of **correlate**\nbefore you commit to it.\n\nI use `infer_mv` like so:\n\n    % infer_mv ../old_path *\n    # look at output, if it's all fine run\n    % infer_mv ../old_path * | sh\n\nOr you can direct the output of `infer_mv` into a file, then\nedit the file, then execute that.  Or something else!\nWhatever works for you!\n\n\n## Terminology And Requirements\n\n### Values\n\nValues are Python objects that represent individual elements of your two\ndatasets.  **correlate** doesn't examine values, and it makes very few\ndemands on them.  Here are the rules for values:\n\n* Values must support `==`.\n* Value comparison must be *reflexive,* *symmetric,* *transitive,* and *consistent*.\n  For all these examples, `a` `b` and `c` represent values:\n    * *reflexive:* A value must always compare as equal to itself.  `a == a` must evaluate to `True`.\n    * *symmetric:* If `a == b` is `True`, then `b == a` must also be `True`.\n    * *transitive:* If `a == b` is `True`, and `b == c` is `True`, then `a == c` must also be `True`.\n    * *consistent:* If `a == b` is `True`, it must always be `True`,\n       and if `a == b` is `False` it must always be `False`.\n\n### Keys\n\nKeys are Python objects that **correlate** uses to find matches between\nthe two datasets.  If a key maps to a value in `dataset_a` and also\na value in `dataset_b`, those two values might be a good match.\n\nKeys must obey all the same rules as values.  In addition,\nkeys must be *hashable.*  This in turn requires that keys\nmust be *immutable.*\n\n#### Exact Keys\n\nAn \"exact\" key is what **correlate** calls any key that isn't a \"fuzzy\" key.\nStrings, integers, floats, complex, `datetime` objects--they're all fine to use\nas **correlate** keys, and instances of many more types too.\n\nWhen considering matches, exact keys are binary--either they're an exact match\nor they don't match at all.  To work with non-exact matches you'll have\nto use \"fuzzy\" keys.\n\n\n#### Fuzzy Keys\n\nA \"fuzzy\" key is a key that supports a special protocol for performing \"fuzzy\"\ncomparisons--comparisons where the result can represent imperfect or partial matches.\n\nTechnically speaking, a **correlate** \"fuzzy\" key\nis an instance of a subclass of `correlate.FuzzyKey`.  If a key is an instance of\na subclass of that base class, it's a \"fuzzy\" key, and if it isn't, it's an \"exact\" key.\n\nFuzzy keys must follow the rules for keys above.\nAlso, the type of your fuzzy keys must also obey the same rules as keys;\nthey must be hashable, they must support `==`,\nand their comparison must be reflexive, symmetric, transitive, and consistent.\n\nIn addition, fuzzy keys must support a method called `compare` with this signature:\n`self.compare(other)`.  `other` will be another fuzzy key of the same type.  Your `compare`\nfunction should return a number (either `int` or `float`) between (and including)\n`0` and `1`, indicating how close a match `self` is to `other`.  If `compare`\nreturns `1`, it's saying this is a perfect match, that the two values are identical;\nif it returns `0`, it's a perfect mismatch, telling **correlate** that the two keys\nhave nothing in common.\n\n**correlate** requires that `compare` also obey the four mathematical constraints required\nof comparisons between keys.  In the following rules, `a` and `b` are fuzzy keys of the\nsame type.  `compare` must conform to these familiar four rules:\n\n* *reflexive:* `a.compare(a)` must return `1` (or `1.0`).\n* *symmetric:* If `a.compare(b)` returns *x*, then `b.compare(a)` must also return *x*.\n* *transitive:* If `a.compare(b)` returns *x*, and `b.compare(c)` returns *x*,\n  then `a.compare(c)` must also return *x*.\n* *consistent:* If `a.compare(b)` returns *x*, it must *always* return *x*.\n\nIt's important to note: fuzzy keys of two *different* types are automatically\nconsidered different to each other.  **correlate** won't even bother calling\n`compare()` on them--it automatically assigns the comparison a fuzzy score of `0`.\nThis is true even for subclasses; if you declare `class MyFuzzyNumber(correlate.FuzzyKey)`\nand also `class MyFuzzyInteger(MyFuzzyNumber)`,\n**correlate** will never compare an instance of `MyFuzzyNumber` and `MyFuzzyKey`\nto each other--it automatically assumes they have nothing in common.\n\n(Internally\n**correlate** stores fuzzy keys of different types segregated from each other.\nThis is a vital optimization!)\n\nOn a related note, **correlate** may optionally never\n*actually* call `a.compare(a)`, either.  That is, if the exact same key\nmaps to a value in both `dataset_a` and `dataset_b`, **correlate**\nis permitted to skip calling `compare()` and instead automatically\nassign the comparison a fuzzy score of `1`.  (Currently if this situation\narose it *would* call `a.compare(a)`, but that wasn't true at various\ntimes during development.)\n\nFinally, it's important to note that fuzzy keys are dramatically slower\nthan exact keys.  If you can express your problem purely using exact keys,\nyou should do so!  It'll run faster as a result.  You can get a sense of\nthe speed difference by running `tests/ytjd.test.py` with verbose mode\non (`-v`). A test using the same corpus but switching everything to fuzzy\nkeys runs about *12x slower* on my computer.\n\n\n## API\n\n`Correlator(default_weight=1)`\n\n> The correlator class.  `default_weight` is the weight used\n> when you map a key to a value without specifying an explicit weight.\n\n`Correlator.dataset_a`\n\n`Correlator.dataset_b`\n\n> Instances of `Correlator.Dataset` objects representing the two sets of data you want to correlate.  Initially empty.\n\n`Correlator.datasets`\n\n> A list containing the two datasets: `[dataset_a, dataset_b]`\n\n\n`Correlator.correlate(*,\n            minimum_score=0,\n            score_ratio_bonus=1,\n            ranking=BestRanking,\n            ranking_bonus=0,\n            ranking_factor=0,\n            reuse_a=False,\n            reuse_b=False)`\n\n> Correlates the two datasets.  Returns a `correlate.CorrelatorResult` object.\n>\n> `minimum_score` is the minimum permissible score for a match.  It must be\n> greater than or equal to 0.\n>\n> `score_ratio_bonus` specifies the weight of a bonus awarded to a match, based on the ratio of\n> the actual score computed between these two values divided by the maximum possible score.\n> For more information, consult the [*Score Ratio Bonus*](#score-ratio-bonus) section.\n>\n> `ranking` specifies which approch to computing ranking **correlate** should use.\n> The default value of `BestRanking` means **correlate** will try all approaches\n> and choose the one with the highest cumulative score across all matches.\n> Other values include `AbsoluteRanking` and `RelativeRanking`.\n>\n> `ranking_bonus` specifies the weight of the bonus awarded to a match\n> based on the proximity of the two values in their respective datasets, as specified\n> by their rankings.  The closer the two values are to the same position in their\n> respective datasets, the higher a percentage of the `ranking_bonus` will be awarded.\n>\n> `ranking_factor` specifies the ratio of the base score of a match that is multiplied\n> by the proximity of the two values in their respective datasets.  If you ues `ranking_factor=0.4`,\n> then a match only automatically keeps 60% of its original score; some percentage\n> of the remaining 40% will be re-awarded based on the proximity of the two values.\n>\n> (You can't use both a nonzero `ranking_bonus` and a nonzero `ranking_factor` in the\n> same correlation.  Pick at most one!)\n>\n> For more information on all these ranking-related parameters,\n> consult the [*Ranking*](#ranking-1) section of this document.\n>\n> `reuse_a` permits values in `dataset_a` to be matched to more than one value in `dataset_b`.\n> `reuse_b` is the same but for values in `dataset_b` matching `dataset_a`.\n> If you set both reuse flags to True, the `correlate.CorrelatorResult.matches`\n> list returned will contain *every* possible match.\n\n`Correlator.print_datasets()`\n\n> Prints both datasets in a human-readable form.  Uses `self.print` to print,\n> which defaults to `print`.\n\n`Correlate.Dataset()`\n\n> The class for objects representing a dataset.  Behaves somewhat like\n> a write-only dict.\n\n`Correlator.Dataset.set(key, value, weight=default_weight)`\n\n> Adds a new correlation.\n>\n> You can use `Dataset[key] = value` as a shortcut for `Dataset.set(key, value)`.\n\n`Correlator.Dataset.set_keys(keys, value, weight=default_weight)`\n\n> Map multiple keys to a single value, all using the same weight.\n> `keys` must be an iterable containing keys.\n\n`Correlator.Dataset.value(value, *, ranking=None)`\n\n> Annotates a value with extra metadata.  Currently only one metadatum\n> is supported: `ranking`.\n>\n> `ranking` represents the position of this value in the dataset,\n> if the dataset is ordered.  `ranking` should be an integer\n> representing the ranking; if this value is the 19th in the dataset,\n> you should supply `ranking=19`.\n\n`Correlator.Dataset.clear(default_weight=1, *, id=None)`\n\n> Clears the Dataset.  Reinitializes it to its empty state.\n> You can optionally also change the dataset's default weight\n> and its id.\n\n`CorrelatorResult()`\n\n> The class for objects returned by `Correlator.correlate()`.\n> Contains four members:\n>\n> * `matches`, a `list` of `CorrelatorMatch()` objects, sorted with highest score first\n> * `unmatched_a`, the `set` of values from `dataset_a` that were not matched\n> * `unmatched_b`, the `set` of values from `dataset_b` that were not matched\n> * `statistics`, a `dict` containing human-readable statistics about the correlation\n\n`CorrelatorResult.normalize(high=None, low=None)`\n\n> Normalizes the scores in `matches`.\n> When `normalize()` is called with its default values, it adjusts every score\n> so that they fall in the range `(0, 1]`.\n> If `high` is not specified, it defaults to the highest score in `matches`.\n> If `low` is not specified, it defaults to the `minimum_score` used for the correlation.\n\n\n`CorrelatorMatch()`\n\n> The class for objects representing an individual match made\n> by `Correlator.correlate()`.\n> Contains three members:\n>\n> * `value_a`, a value from `dataset_a`.\n> * `value_b`, a value from `dataset_b`.\n> * `score`, a number representing the confidence in this match.\n>   The higher the `score`, the higher the confidence.\n>   Scores don't have a predefined intrinsic meaning; they're a result\n>   of all the inputs to **correlate.**\n\n`Correlator.str_to_keys(s)`\n\n> A convenience function.\n> Converts string `s` into a list of string keys using a reasonable approach.\n> Lowercases the string, converts some common punctuation into spaces, then splits\n> the string at whitespace boundaries.  Returns a list of strings.\n\n\n### Getting Good Results Out Of Correlate\n\nUnfortunately, you can't always expect perfect results with **correlate**\nevery time.  You'll usually have to play with it at least a little.\nAt its heart, **correlate** is a heuristic, not an exact technology.\nIt often requires a bit of tuning before it produces the results you want.\n\n#### Ranking\n\nNaturally, the first step with **correlate** is to plug in your data.\nI strongly encourage you to add ranking information if possible.\n\nIf the two datasets are ordered, and equivalent items should appear in\nroughly the same place in each of the two datasets, ranking information\ncan make a *sizeable* improvement in the quality of your matches.\nTo use ranking information, you set the `ranking` for each value in each dataset\nthat you can, and specify either `ranking_bonus` or `ranking_factor` when\nrunning `correlate()`.\nWhich one you use kind of depends on how much confidence you have in the\nordering of your datasets.  If you think your ranking information is pretty\naccurate, you should definitely use `ranking_factor`; this exerts a much\nstronger influence on the matches.\nIf you have a low confidence in the ordering of your datasets,\nchoose `ranking_bonus`, which only provides a little nudge.\n\nRanking can also speed up **correlate** quite a bit.  If there are a\nlot of matches that end up with the same score, this can create a lot\nof work for the \"match boiler\" (see below), and that can get expensive\nquick.  Even a gentle nudge from ranking information can help differentiate\nscores enough to result in a *dramatic* speedup.\n\n#### Minimum Score\n\nOnce you've plugged in all your data, you should run the correlation,\nprint out the result in sorted order with the best\nmatches on top, then scroll to the bottom and see what the *worst*\n5% or 10% of matches look like.\n\nIf literally all your matches are already perfect--congratulations!\nYou're *already* getting good results out of **correlate** and you\ncan stop reading here.  But if you're not that lucky, you've got more\nwork to do.\n\nThe first step in cleaning up **correlate's** output is usually\nto stop it from making bad matches by setting a `minimum_score`.\n\nWhen you have bad matches, it's usually because the two datasets don't map\nperfectly to each other.  If there's a value in `dataset_a` that has no good\nmatch in `dataset_b`, well, **correlate** doesn't really have a way of\nknowing that.   So it may match that value to something anyway.\n\nLook at it this way: the goal of **correlate** is to find matches between\nthe two datasets.  If it's made all the good matches it can, and there's\nonly one item left in each of the the two datasets, and they have *anything*\nin common at all, **correlate** will match those two values together\nout of sheer desparation.\n\nHowever!  Bad matches like these tend to have a very low score.\nSo all those low-scoring bad matches clump together at the very\nbottom.  There'll probably be an inflection point where the scores\ndrop off significantly and the matches go from good to bad.\n\nThis is what `minimum_score` is for.  `minimum_score` tells **correlate**\nthe minimum permissible score for a match.  When you have a clump of bad\nmatches at the bottom, you simply set `minimum_score` to be somewhere\nbetween the highest bad match and the lowest good match--and\nbehold!  No more bad matches!  The values that were used in the bad\nmatches will move to `unused_a` and `unused_b`, which is almost\ncertainly the correct place for them.\n\n(Technically, **minimum_score** isn't *actually* the minimum score.\nIt's ever-so-slightly *less* than the lowest\npermitted score.  As in, for a match to be considered viable, its score\nmust be *greater than* **minimum_score.**  In Python 3.9+, you can\nexpress this concept as:\n\n    actual_minimum_score = math.nextafter(minimum.score, math.inf)\n\nThe default value for\n**minimum_score** is 0, which means **correlate** will keep\nany match with a positive score.)\n\nUnfortunately it's hard to predict what to set `minimum_score` to in advance.\nIts value really depends on your data set--how many keys you have, how good\nthe matches are, what weights you're using, everything.  It's much more\nstraightforward to run the correlation, look over the output, find where the\ncorrelations turn bad, and set a minimum score.  With large data sets there's\ngenerally a sudden and obvious dropoff in score, associated with **correlate**\nmaking poor matches.  That makes it pretty easy: set the minimum score so it\nkeeps the last good match and forgets the rest.  But there's no predicting what\nthat score will be in advance--every data set is different, and it's really\nan emergent property of your keys and weights--so\nyou'll have to calibrate it correctly for each correlation you run.\n\n(Sometimes there are good matches mixed in with the bad ones at the bottom.\nWhen that happens, the first step is generally to fix *that,* so that the\nbad ones are all clumped together at the bottom.  I can't give any general-purpose\nadvice on what to do here.  All I can suggest is to start experimenting.  Change\nyour keys, adjust your weights, run the correlation again and see what happens.\nUsually when I do this, I realize something I can do to improve the data I feed\nin to **correlate**, and I can fix the problem externally.)\n\n#### Weights\n\nIf you're still not getting the results you want, the next adjustment you\nshould consider is increasing the weight of\nkeys that provide a clear signal.  If the datasets you're comparing\nhave some sort of unique identifier associated with each value--like\nan episode number, or release date--you should experiment with giving those\nkeys a heavier weight.  Heavily-weighted keys like this can help\n**correlate** zero in on the best matches right away.\n\nIt's up to you what that weight\nshould be; I sometimes use weights as heavy as 5 for super-important keys,\nwhich means this one single key will have the same weight as 5 normal\nkeys.  Note that a weight of 5 on the mapping in `dataset_a` and\n`dataset_b` means that, if those keys match, they'll have a base score\nof 25!  If that key only appears once in each dataset, that will almost\n*certainly* result in a match.\n\nBut using weights can be a dual-edged sword.  If your data has mistakes\nin it, heavily weighting the bad data can magnify those mistakes.  One bad\nheavily-weighted key on the wrong value can inflate the score of a bad match\nover the correct match.  And that can result in a vicious cycle--if value\n*A1* should match value *B1*, but it get mapped to value *B43* instead,\nthat means *B1* is probably going to get mismatched too.  Which deprives\nanother value of its correct match.  And so on and so on and so on.\n\nOne final note on weights.  The weight of a key doesn't affect how\n*desirable* it is in a match, it only affects the resulting score of that\nmatch.  Consider this scenario involving weighted fuzzy keys:\n\n    FA1 and FA2 are fuzzy keys in dataset_a\n    FB is a fuzzy key in dataset_b\n    VA1 and VA2 are values in dataset_a\n\n    dataset_a.set(FA1, VA1, weight=1)\n    dataset_a.set(FA2, VA2, weight=5)\n\n    FA1.compare(FB) == 0.4\n    FA2.compare(FB) == 0.2\n\nIf **correlate** had to choose between these two matches, which one\nwill it prefer?  It'll prefer *FA1*->*FB*, because **correlate**\ndoesn't consider weights when considering matches.  It always prefers\nthe match with the higher *unweighted* score.  It's true,\nmatching *FA2* to *FB* results in a higher final score once you\nfactor in the weights.  But that doesn't make it a better match.\n\nThe best way to conceptualize this: weights don't make matches\n*higher quality,* they just make matches more *interesting*\nwhen true.\n\n\n#### Too-Common Keys\n\nSimilarly, if there are super-common keys that aren't going to help with\nthe correlation, consider throwing them away and not even feeding them in as\ndata.  Keys that map to most or all of the values in a dataset add little\nclarity, and will mainly serve just to make **correlate** slower.\nI usually throw away the word \"The\", and the name of the podcast or show.\n(When correlating filenames, I may throw away the file extension too.)\n\nThen again, often leaving them in won't hurt anything, and it can occasionally\nbe helpful!  The way **correlate** works, it considers multiple maps of a\nkey to a value as different things--if you map the key `\"The\"` to a value\ntwice, **correlate** understands that those are two separate mappings.\nAnd if there's only one value in each dataset that has two `\"The\"` mappings,\nthat can be a very strong signal indeed.  So it's really up to you.\nThrowing away largely-redundant keys is a speed optimization, but it\nshouldn't affect the quality of your matches.\n\nNote that **correlate** is now *very* efficient when it comes to\nmatching with exact keys.  For most people, the additional runtime cost\nfor redundant or common keys is probably negligible, and not worth the\nadditional development time or engoing support cost to make it even worth\nconsidering.  It's true they provide only a tiny amount of signal--but they\nalso have relatively little runtime cost, either in memory or CPU time.\nAt this point it's *probably* not worth the bother to almost anybody.\n\n(But here's a theoretical best of both worlds to consider: for very\ncommon keys, consider throwing away the *first* instance.  I admit I\nhaven't tried this experiment myself.)\n\n#### Check Your Inputs\n\nAs always, it's helpful to make sure your code is doing what you intend it to.\nSeveral times I've goofed up the mechanism I use to feed data sets into\n**correlate**; for example, instead of feeding in words as keys, I've occasionally\nfed in the individual characters in those words as keys.  (Like, instead of\nthe single key `\"booze\"`, I accidentally fed in the five keys\n`'b'`, `'o'`, `'o'`, `'z'`, and `'e'`.)\nHowever, the **correlate** algorithm works so well,\nit still did a shockingly good job!  (Though it was a *lot* slower.)\n\nI've learned to double-check that I'm inputting the mappings and weights I meant\nto, with a debugger or with `Correlator.print_datasets()`.  Making sure you gave\n**correlate** the right data can make it not only much more accurate,\nit might make it faster too!\n\n#### Normalize Strings\n\nWhen using strings as keys from real-world sources, I recommend you\n*normalize* the strings:\nlowercase the strings,\nremove most or all punctuation,\nand\nbreak the strings up into individual keys at word boundaries.\nIn the real world, punctuation\nand capitalization can both be inconsistent, so throwing it away can help\ndispel those sorts of inconsistencies.  **correlate**\nprovides a utility function called `correlate.str_to_keys()` that does this\nfor you.  But you can use any approach to string normalizing you like.\n\nYou might also consider *interning* your strings.  In my limited experimentation\nthis provided a small but measurable speedup.\n\n#### Sharpen Your Fuzzy Keys\n\nIf you're using fuzzy keys, make sure you *sharpen* your fuzzy keys.\nFuzzy string-matching libraries have a naughty habit of scoring\nnot-very-similar strings as not *that* much less than almost-exactly-the-same\nstrings.  If you give that data unaltered to **correlate,** that \"everything\nlooks roughly the same\" outlook will be reflected in your results as\nmediocre matches.\n\nIn general, you want to force your fuzzy matches to extremes.\nTwo good techniques:\n\n* Specify a minimum score for fuzzy matches, and replace any fuzzy score\n  below that minimum with `0`.\n  * Possibly remap the remaining range to the entire range.\n    For example, if your minimum score is `0.6`, should you simply\n    return values from `0.6` to `1`?  Or should you stretch the scores\n    over the entire range with `(fuzzy_score - 0.6) / (1 - 0.6)`?\n    You may need to experiment with both to find out what works well for you.\n* Multiply your fuzzy score by itself.  Squaring or even cubing a fuzzy\n  score will preserve high scores and attenuate low scores.\n  However, note that the scoring algorithm for fuzzy key matches already\n  *cubes* the fuzzy score.  Additional multiplying of the score by itself is\n  probably unnecessary in most cases.\n\n\n### What Do These Scores Mean?\n\nThe scores you seee in the results are directly related to the data you\ngave to **correlate**.  The scores really only have as much or as\nlittle meaning as you assign to them.\n\nIf you don't enjoy the unpredictable nature of **correlate** scores,\nconsider calling `normalize()` on your Correlate result object.\nThis normalizes the scores as follows: the highest score measured\nwill be adjusted to 1.0, `minimum_score` will be adjusted to 0.0,\nand every other score will be adjusted linearly between those two.\n\nMathematically:\n\n    score = the original score for this match\n    highest_score = highest score of any match\n    minimum_score = the minimum_score passed in to correlate()\n    delta = highest_score - minimum_score\n    normalized_score = (score - minimum_score) / delta\n\n\n## Implementation Notes On The Algorithm And The Code\n\n> If the implementation is hard to explain, it's a bad idea.\n> --*The Zen Of Python* by Tim Peters\n\nWhat follows is an exhaustive (and exhausting!) chapter\non the implementation of **correlate**.  This is here\npartially for posterity, partially because I like\nreading this sort of thing in other people's projects,\nbut mostly to make it easier to reaquaint myself with\nthe code when I have to fix a bug three years from now.\n\n### The High-Level Overview\n\nAt the heart of **correlate** is a brute-force algorithm.  It's what\ncomputer scientists would call an *O*(n²) algorithm.\n\n**correlate** computes every possible \"match\"--every mapping of a value in\n`dataset_a` to a value in `dataset_b` where the two values have keys in common.\nFor exact keys, it uses set intersections to ignore pairs of values that have\nnothing in common, discarding early matches it knows will have a score of 0.\nSadly, it can't do that for fuzzy keys, which is why fuzzy keys tend to\nnoticably slow down  **correlate**.\n\nFor each key that matches between the two values, **correlate**\ncomputes a score.  It then adds all those scores together,\ncomputing the final cumulative score for the \"match\",\nwhich it may modifiy based on the various bonuses and factors.\nIt then iterates over these scores in sorted order, highest score first.\nFor every match where neither of the two values have been used\nin a match yet, it counts that as a \"match\" and adds it to the output.\n(This assumes `reuse_a` and `reuse_b` are both `False`.  Also, this\nis a little bit of an oversimplification; see the [*Match Boiler*](#choosing-which-matches-to-keep-the-greedy-algorithm-and-the-match-boiler)\nsection below.)\n\nOne important detail: **correlate** strives to be 100%\ndeterministic.  Randomness can creep in around the edges in Python\nprograms; for example, if you ever iterate over a dictionary,\nthe order you will see the keys will vary from run to run.\n**correlate** eliminates every source of randomness it can.\nAs far as I can tell: given the exact same inputs, it performs\nthe same operations in the same order and produces the same result,\nevery time.\n\nThere are a number of concepts involved with how the **correlate**\nalgorithm works, each of which I'll explain in exhausting detail\nin the following sub-sections.\n\n\n### **correlate's** Six Passes And Big-O Complexity\n\nA single **correlate** correlation makes six passes over its data.\nHere's a high-level overview of those passes, followed by\ndeep-dives into the new terms and technical details of those passes.\n\n**Pass 1**\n\n> Iterate over both datasets and compute the \"streamlined\"\n> data.\n>\n> *Complexity:* *O*(n)\n\n\n**Pass 2**\n\n> Iterate over all keys and compute a sorted list of all matches\n> that could possibly have a nonzero score.  (The list represents\n> a match with a pair of indices into the lists of values for each\n> dataset.)  This pass also performs all fuzzy key comparisons and\n> caches their results.\n>\n> *Complexity:* *O*(n²), for the fuzzy key comparisons step.\n> For a *correlate* run with a lot of fuzzy keys, this is often\n> the slowest part of the run.  If your correlate is mostly\n> exact keys, this part will be pretty quick, because all the\n> *O*(n²) work is done in C code (set intersections, and sorting).\n\n**Pass 3**\n\n> For every match with a nonzero score,\n> compute subtotals for matching all fuzzy keys.\n> We need to add some of these together to compute the final\n> scores for fuzzy key matches.\n>\n> *Complexity:* *O*(n²)\n\n**Pass 4**\n\n> For every match with a nonzero score:\n>\n> * compute the scores for matching all exact keys,\n> * finalize the scores for fuzzy key match scores,\n> * compute the bonuses (score_ratio_bonus, ranking),\n> * and store the result per-ranking.\n>\n> The score for each match is now finalized.\n>\n> *Complexity:* *O*(n²)\n\n**Pass 5**\n\n> For every ranking approach being used,\n> compute the final list of successful matches,\n> using the \"match boiler\" and \"greedy algorithm\".\n>\n> *Complexity:* *O*(n log n) (approximate)\n\n**Pass 6**\n\n> Choose the highest-scoring ranking approach,\n> compute unseen_a and unseen_b,\n> and back-substitute the \"indexes\" with their actual values\n> before returning.\n>\n> *Complexity:* *O*(n)\n\nThus the big-O notation for **correlate** overall is *O*(n²).\nThe slowest part of **correlate** is processing lots of fuzzy\nkeys; if you can stick mostly to exact keys, your **correlate**\nruns will be a lot quicker.\n\nYou can see how long **correlate** spent in each of these\npasses by examining the `statistic` member of the `CorrelatorResult`\nobject.  This is a dict mapping string descriptions of\npasses to a floating-point number of seconds.  Pass 2's\nsub-passes dealing with exact keys and fuzzy keys are\nbroken out separately, as is the \"match boiler\" phase\nof Pass 5.\n\n\n### Rounds\n\nIf you call **correlate** as follows:\n\n    c = correlate.Correlator()\n    o = object()\n    c.dataset_a.set('a', o)\n    c.dataset_a.set('a', o)\n\nthen key `'a'` really *is* mapped to value `o` twice,\nand those two mappings can have different weights.\nTechnically, the correct way to think of this is as\nhaving two edges from the same key to the same value\nin the dataset graph.\nAnother way to think of it is to consider repeated keys as\nbeing two different keys--identical, but somehow distinct.\n\n(If it helps, you can also think of it as being\nlike two files with the same filename in two different\ndirectories.  They have the same *filename,* but\nthey're not the same *file.*)\n\n\n**correlate** calls groups of these multiple mappings *\"rounds\"*.\nA \"round\" contains all the keys from the Nth time they were\nrepeated.  Round 0 contains every key, round 1 contains the second\ninstances of all the keys that were repeated twice, round 2 contains\nall the third instances of all the keys that were repeated three times,\netc.\nRounds are per-value, and there are as\nmany rounds as the maximum number of redundant mappings of\nany single key to any particular value in a dataset.\n\nNaturally, exact keys and fuzzy keys use a different method\nto determine whether or not something is \"the same key\".\nTechnically both types of keys use `==` to determine equivalence.\nHowever, fuzzy keys don't implement a custom `__eq__`, so Python\nuses its default mechanism to determine equivalence, which is\nreally just the `is` operator.  Therefore: exact keys are the\nsame if `==` says they're the same, and (in practice) fuzzy keys\nare the same if and only if they're the same object.\n\n(Of course, you could implement your own `__eq__` when you write\nyour own fuzzy subclasses.  But I don't know why you would bother.)\n\nConsider this example:\n\n    c = correlate.Correlator()\n    o = object()\n    c.dataset_a.set('a', o, weight=1)\n    c.dataset_a.set('a', o, weight=3)\n    c.dataset_a.set('a', o, weight=5)\n    c.dataset_a.set('b', o)\n    c.dataset_a.set('b', o)\n    c.dataset_a.set('c', o)\n\n    o2 = object()\n    c.dataset_b.set('d', o2)\n    c.dataset_b.set('d', o2)\n    c.dataset_b.set('e', o2)\n    c.dataset_b.set('f', o2)\n\nHere, the value `o` in `dataset_a` would have three rounds:\n\n* Round 0 would contain the keys `{'a', 'b', 'c'}`.\n* Round 1 would contain the keys `{'a', 'b'}`.\n* Round 2 would contain only one key,`{'a'}`.\n\nAnd `o2` in `dataset_b` would have only two rounds:\n\n* Round 0 would contain the keys `{'d', 'e', 'f'}`.\n* Round 1 would contain only one key,`{'d'}`.\n\nAgain, conceptually, the `\"a\"` in round 0 is a different key\nfrom the `\"a\"` in round 1, and so on.\n\nFor exact keys, rounds are directly matched iteratively\nto each other; the exact keys in round 0 for a value in\n`dataset_a` are matched to the round 0 exact keys for a value in\n`dataset_b`, round 1 in `dataset_a` is matched to\nround 1 in `dataset_b`, and so on.\nIf one side runs out of rounds early, you stop; if you compute\nthe intersection of a round and they have nothing in common,\nyou stop.\n\nOne invariant property: each subsequent round has a subset of\nthe keys before it.  The set of keys in round **N+1** *must*\nbe a subset of the keys in round **N**.  (Though not necessarily\na *strict* subset.)\n\nWhat about weights?  Higher weights are sorted to lower rounds.\nThe weight for a key *k* in round **N-1** *must* be greater than\nor equal to the weight of *k* in round **N**.\nIn the above example, the `'a'` in round 0 has weight 5, in round 1\nit has weight 3, and in round 2 it has weight 1.\n(It doesn't matter what order you insert them in, **correlate**\nautomatically sorts the weights as you add the redundant mappings.)\n\nThus, round 0 always contains every exact key mapped to\na particular value, with the highest weights for each of those\nmappings.\n\nRounds can definitely help find the best matches.  If the\nkey `\"The\"` maps to most of your values once,\nthat's not particularly interesting, and it won't affect the scores\nvery much one way or another.  But if there's only one\nvalue in each dataset that `\"The\"` maps to *twice,*\nthat's a very strong signal indeed!  **correlate** does an\n*excellent* job of noticing unique-ness like that and factoring\nit into the scoring.\n\n### Streamlined Data\n\nThe **correlate** datasets store data in a format designed\nto eliminate redundancy and be easy to modify.  But this representation\nis inconvenient for performing the actual correlate.  Therefore, the first\nstep (\"Pass 1\") is to reprocess the data into a \"streamlined\" format.\nThis is an internal-only implementation detail, and in fact the data\nis thrown away at the end of each correlation.  As an end-user you'll\nnever have to deal with it.  It's only documented here just in case you\never need to understand the implementation of **correlate**.\n\nThis streamlined data representation is an important optimization.\nIt greatly speeds up computing a match between two values.  And it\nonly costs a little overhead, compared to all that matching work.\nConsider: if you have 600 values in `dataset_a` and 600 values in\n`dataset_b`, **correlate** will recompute 1,200 streamlined datasets.\nBut it'll then use it in as many as 360,000 comparisons!   Spending\na little time precomputing the data in a convenient format saves a\nlot of time in the long run.\n\nThe format of the streamlined data changes as the implementation\nchanges.  And since it's an internal-only detail, it's largely undocumented\nhere.  If you need more information, you'll just have to read the code.\nSearch the code for the word `streamlined`.\n\n\n### The Scoring Formula, And Conservation Of Score\n\nFor each match it considers, **correlate** computes the intersection of\nthe keys that map to each of those two values in the two datasets,\nthen computes a score based on each of those key matches.\nThis scoring formula is the heart of **correlate**, and it was a key\ninsight--without it **correlate** wouldn't work nearly as well as it does.\n\nIn the abstract, it looks like this:\n\n    for value_a in dataset_a:\n        for value_b in dataset_b:\n            subtotal_score = 0\n            for key_a, weight_a that maps to value_a:\n                for key_b, weight_b that maps to value_b:\n                    score = value of key_a compared to key_b\n                    cumulative_a = the sum of all scores resulting from key_a mapping to any value in dataset_b\n                    cumulative_b = the sum of all scores resulting from key_b mapping to any value in dataset_a\n                    score_ratio_a = score / cumulative_a\n                    score_ratio_b = score / cumulative_b\n                    unweighted_score = score * score_ratio_a * score_ratio_b\n                    score_a = weight_a * unweighted_score_a\n                    score_b = weight_b * unweighted_score_b\n                    final_score = score_a * score_b\n                    subtotal_score += final_score\n\nTwo notes before we continue:\n\n* `key_a` and `key_b` must always be *per-round,* for a number\nof reasons, the least of which is because we use their\nweights in computing the `final_score`.\n\n* `subtotal_score` is possibly further adjusted by `score_ratio_bonus`\nand ranking, if used.  We'll discuss that later.\n\nThis formula is how **correlate** computes a mathematical representation\nof \"uniqueness\".  The fewer values a key maps to in a dataset,\nthe higher it scores.  A key that's only mapped once in each\ndataset scores 4x higher than a key mapped twice in each dataset.\n\nThis scoring formula has a virtuous-feeling mathematical\nproperty I call *\"conservation of score\".*  Each key that\nyou add to a round in a dataset adds 1 to the total cumulative\nscore of all possible matches; when you map a key to multiple\nvalues, you divide this score up evenly between those values.\nFor example, if the key `x` is mapped to three values in `dataset_a`\nand four values in `dataset_b`, each of those possible matches\nonly gets 1/12 of that key's score, and the final cumulative\nscore for all matches only goes up by 1/12.  So a key always\nadds 1 to the sum of all scores across all *possible* matches,\nbut only increases the actual final score by the amount of\nsignal it *actually* communicates.\n\nAlso, now you see why repeated keys can be so interesting.\nThey add 1 for *each round* they're in, but that score is only\ndivided by the number of values they're mapped to *in that round!*\nSince there tend to be fewer and fewer uses of a key in\nsubsequent rounds, the few keys that make it to later rounds\ncan potentially score much higher than they did in earlier\nrounds, making them a more noteworthy signal.\n\n\n### Matching And Scoring Exact Keys\n\nThe \"streamlined\" data format for exact keys looks like this:\n\n    exact_rounds[index][round] = (set(d), d)\n\nThat is, it's indexed by \"index\" (which represents the value), then\nby round number.  That gives you a tuple containing a dict mapping\nkeys to weights, and a `set()` of just the keys.\n**correlate** uses `set.intersection()` (which is super fast!)\nto find the set of exact keys the two values have in common for that round.\nThe `len()` of this resulting set is the base cumulative score for that round,\nalthough that number is only directly useful in computing `score_ratio_bonus`.\n\nAlthough **correlate** uses the same scoring formula for both exact keys and\nfuzzy keys in an abstract sense, scoring matches between exact keys is much\nsimpler in practice.  Let's tailor the \"abstract\" scoring algorithm above for\nexact keys.  This lets us optimize the algorithm in a couple places, making\nit much faster!\n\nFirst, with exact keys, naturally they're either an exact match or they aren't.\nIf they're an exact match, they're the same Python value.  Therefore `key_a` and\n`key_b` must be identical.  Therefore, conceptually, we can swap them.  Let's\nrewrite the \"scoring formula\" equation slightly:\n\n    cumulative_a = the sum of all scores between key_b and all keys in dataset_b\n    cumulative_b = the sum of all scores between key_a and all keys in dataset_a\n\nAll we've changed is: we've swapped `key_a` and `key_b`.\n(Why?  It'll help.  Hey, keep reading.)\n\nNow consider: `score` for exact keys is always either `1` or `0`.  It's `1` when\ntwo keys are exactly the same, and `0` otherwise.  If the base `score` for the\nmatch is `0`, then the `final_score` will be `0` and we can skip all of it.\nSo we only ever compute a `final_score` when `score` is `1`, when the keys\nare identical.\n\nSince `score` is only ever used as a multiplier, we can discard it.\n\n`cumulative_a` and `cumulative_b` are similarly easy to compute.\nThey're just the number of times that key is mapped to any value in\nthe relevant dataset, *in that round.*  These counts are precomputed\nand stored in the \"streamlined\" data.\n\nSo, finally: if you do the substitutions, and drop out the constant `score`\nfactors, `final_score` for exact keys is computed like this:\n\n    final_score = (weight_a * weight_b) / (cumulative_a * cumulative_b)\n\nWhich we can rearrange into:\n\n    final_score = (weight_a / cumulative_b) * (weight_b / cumulative_a)\n\nAt the point we precompute the streamlined data for `dataset_a`,\nwe know `weight_a`, and we can compute `cumulative_b` because it only\nuses terms in `dataset_a`.  So we can pre-compute those terms,\nmaking the final math:\n\n    # when computing the streamlined data\n    precomputed_a = weight_a / cumulative_b\n    precomputed_b = weight_b / cumulative_a\n\n    # ...\n\n    # when computing the score for a matching exact key\n    final_score = precomputed_a * precomputed_b\n\nThat's a *lot* simpler!  And these optimizations made **correlate** a *lot* faster.\n\n\n### Fuzzy Keys\n\nLet me tell you a wonderful bed-time story.\nOnce upon a time, **correlate** was small and beautiful.\nBut that version only supported exact keys.\nBy the time fuzzy keys were completely implemented, and feature-complete,\nand working great, **correlate** was much more complex and... \"practical\".\nIt's because fuzzy keys introduce a lot of complex behavior, resulting in\ntricky scenarios that just don't arise with exact keys.\n\nConsider this example:\n\n>    Your two datasets represent lists of farms.  Both datasets list\n>    animals, but might have generic information (\"horse\") or might\n>    have specifics (\"Clydesdale\").  You create a fuzzy key subclass called\n>    `AnimalKey` that can handle matching these together;\n>    `AnimalKey(\"Horse/Clydesdale\")` matches `AnimalKey(\"Horse\")`,\n>    though with a score less than 1 because it isn't a perfect match.\n>\n>    The same farm, *Farm X*, is present in both datasets:\n>\n>    * In `dataset_a`, the key `AnimalKey(\"Horse\")` maps to Farm X *twice.*\n>\n>    * In `dataset_b`, the keys `AnimalKey(\"Horse/Clydesdale\")`\n>    and `AnimalKey(\"Horse/Shetland Pony\")` map to Farm X.\n\nQuestion: should one of the `\"Horse\"` keys in `dataset_a` match\n`\"Horse/Clydesdale\"` in `dataset_b`, and should the other `\"Horse\"`\nkey match `\"Horse/Shetland Pony\"`?\n\nOf course they should!  But consider the ramifications: we just matched\na key from *round 2* in `dataset_a` to a key from *round 1* in `dataset_b`.\nThat's simply *impossible* with exact keys!\n\nThe scoring used for fuzzy keys is conceptually the same as the scoring\nfor exact keys, including the concept of \"rounds\".  In practice, fuzzy key\nscoring is much more complicated; there are some multipliers I elided\nin the description for exact keys because they're always 1, and some other\nthings that are easy to compute for exact keys that we must do the hard way\nfor fuzzy keys.  (There's a whole section at the end of this document about\nthe history of fuzzy key scoring in **correlate**, in case you're interested.)\n\nAlso, it's reasonable for a single value in a dataset to have multiple fuzzy\nkeys of the same type, which means that now we could have multiple keys\nin one dataset in contention for the same key in the other dataset.\nIn the above example with farms and horses, **correlate** will need to\ncompare both `AnimalKey(\"Horse/Clydesdale\")` and `AnimalKey(\"Horse/Shetland Pony\")`\nfrom `dataset_a` to `AnimalKey(\"Horse\")` in `dataset_b`.\n\nBut **correlate** doesn't add up every possible fuzzy score generated by a\nkey; when computing the final score, a fuzzy key is only matched against\none other fuzzy key.  If fuzzy keys *FA1* and *FA2* map to value *VA*\nin `dataset_a`, and fuzzy key *FB* maps to value *VB* in `dataset_b`,\n**correlate** will consider *FA1* -> *FB* and also *FA2* -> *FB*\nand only keep the match with the highest score.  A match \"consumes\"\nthe two keys (one from each dataset) and they can't be matched again.\n(Again: when I say \"key\" here, I mean \"this key in this round\".)\nThe flip side of this: a key that isn't matched *isn't* \"consumed\".\nWhat do we do with it?  The example above with horses and farms makes\nit clear: unconsumed fuzzy keys should get recycled--reused in\nsubsequent rounds.\n\nSo, where exact keys use very precise \"rounds\", fuzzy keys\nrequire a more dynamic approach.  Precisely speaking, an unused key in\nround *N* conceptually \"survives\" to round *N+1*.  That's what the above\nexample with farms and ponies shows us; in round 0, if `\"Horse/Clysedale\"`\nin `dataset_a` gets matched to `\"Horse\"` in `dataset_b`,\n`\"Horse/Shetland Pony\"` in `dataset_a` goes unmatched, and survives,\nand advances on to round 1.  This also made scoring more complicated.\n(For more on this, check out the test suite.  There's a regression test\nthat exercises this exact behavior.)\n\nAfter a bunch of rewrites, I found the fastest way to compute fuzzy matches\nwas: for each fuzzy type the two values have in common, compute *all possible\nmatches* between all fuzzy keys mapping to the two values, even mixing\nbetween rounds.  Then sort the matches, preferring higher scores to lower\nscores, and preferring matches in lower rounds to matches in higher rounds.\n\nThe streamlined data for fuzzy keys looks like this:\n\n    fuzzy_types[index][type] = [\n                               [(key1, weight, round#0),  (key1, weight, round#1), ...],\n                               [(key2, weight, round#0),  (key2, weight, round#1), ...],\n                               ]\n\n\nThat is, they're indexed by index (a representation of the value),\nthen by fuzzy type.  That gets you a list of lists.  Each inner list\nis a list of tuples of\n\n    (key, weight, round_number)\n\nwhere `key` is always the same in all entries in the list, and\n`round_number` is always the same as that tuple's index in that list.\n\nWhen computing matches between fuzzy keys, **correlate** takes the\ntwo lists of lists and does nested `for` loops over them.  Since the\nkeys don't change, it only needs to look up the fuzzy score once.\nIf the fuzzy score is greater than 0, it stores the match in an\narray.\n\nOnce it's done with the fuzzy key matching, it sorts this array of matches,\nthen use the \"match boiler\" to reduce it down so that every per-round key\nis matched at most once.  (The \"match boiler\" is discussed later; for now\njust assume it's a magic function that does the right thing.  Though I had\nto ensure it was super-stable for this approach to work.)\n\nSorting these fuzzy key matches was tricky.  They aren't merely sorted\nby score; we also must ensure that fuzzy key matches from earlier rounds\nare *always* consumed before matches using that key in later rounds.\nSo we use a special `sort_by` tuple as the sorting key, computed as follows:\n\n    key_a, weight_a, round_a = fuzzy_types_a[index_a][type]...\n    key_b, weight_b, round_b = fuzzy_types_b[index_b][type]...\n    fuzzy_score = key_a.compare(key_b)\n    lowest_round_number  = min(round_a, round_b)\n    highest_round_number = max(round_a, round_b)\n    sort_by = (fuzzy_score, -lowest_round_number, -highest_round_number)\n\nThe `-lowest_round_number` trick is the very clever bit.  This lets\nus sort with highest values last, which is what the \"match boiler\" wants.\nBut negating it means lower round numbers are now *higher* numbers, which\nlets us prefer keys with *lower* round numbers.\n\nIn terms of the abstract scoring formula, `score` is the fuzzy score,\nwhat's returned by calling the `compare()` method. And `cumulative_a`\nis the sum of all fuzzy `score` scores for all matches using `key_a`.\n\n\n### Score Ratio Bonus\n\nThere's a \"bonus\" score calculated using `score_ratio_bonus`.  It's scored for the\noverall mapping of a value in `dataset_a` to a value in `dataset_b`.\nThis bonus is one of the last things computed for a match, just before ranking.\n\nThe bonus is calculated as follows:\n\n    value_a = a value from dataset_a\n    value_b = a value from dataset_b\n    actual_a = total actual score for all keys that map to value_a in dataset_a\n    actual_b = total actual score for all keys that map to value_b in dataset_b\n    possible_a = total possible score for all keys that map to value_a in dataset_a\n    possible_b = total possible score for all keys that map to value_b in dataset_b\n    bonus_weight = score_ratio_bonus * (actual_a + actual_b) / (possible_a + possible_b)\n\nThis bonus calculated with `score_ratio_bonus` clears up the\nambiguity when the set of keys mapping to one value is a subset of the keys\nmapping to a different value in the same dataset.  The higher percentage\nof keys that match, the larger this bonus will be.\n\nConsider this example:\n\n    c = correlate.Correlator()\n    c.dataset_a.set('breakin', X)\n\n    c.dataset_b.set('breakin', Y)\n    c.dataset_b.set_keys(['breakin', '2', 'electric', 'boogaloo'], Z)\n\nWhich is the better match, `X->Y` or `X->Z`?\nIn early versions of **correlate**, both matches got the exact same score.\nSo it was the luck of the draw as to which match **correlate** would choose.\n`score_ratio_bonus` disambiguates this scenario.  It awards a larger bonus\nto `X->Y` than it does to `X->Z`,  because a higher percentage of the keys\nmatched between `X` and `Y` than matched between `X` and `Z`.\nThat small nudge is generally all that's needed to let **correlate**\ndisambiguate these situations and pick the correct match.\n\nTwo things to note.  First, when I say \"keys\", this is another situation\nwhere the same key mapped twice to the same value is conceptually considered\nto be two different keys.\nIn the example I gave in the **Rounds** subsection above, where `value_a` is `o`\nand `value_b` is `o2`, `possible_a` would be 6 and `possible_b` would be 4.\n\nSecond, the scores used to compute `actual` and `possible` are *unweighted.*\nIf a match between two fuzzy keys resulted in a fuzzy score of `0.3`,\nthat adds `0.3` to both `actual_a` and `actual_b`, but each of those fuzzy\nkeys adds `1.0` to `possible_a` and `possible_b` respectively.\nWeights are always ignored when computing `score_ratio_bonus`, just like\nthey're ignored when comparing matches.\n\n\n### Choosing Which Matches To Keep: The \"Greedy Algorithm\" And The \"Match Boiler\"\n\nHere's a problem, presented in the abstract: if you're presented with\na list of match objects called `matches`,\nwhere each match object `M` has three attributes `value_a`, `value_b`,\nand `score`, how would you compute an optimal subset of `matches`\nsuch that:\n\n* every discrete value of `value_a` and `value_b` appears only once, and\n* the sum of the `score` attributes is maximized?\n\nFinding the perfectly optimal solution would require computing every\npossible set of matches, then computing the cumulative score of that\nset, then choosing the set with the highest score.  Unfortuantely,\nthat algorithm is *O*(nⁿ),\nwhich is so amazingly expensive that we can't even consider it.\n(You probably want your results from **correlate** before our sun\nturns into a red giant.)\n\nInstead, **correlate** uses a comparatively cheap \"greedy\" algorithm\nto compute the subset.  It's not *guaranteed* to produce the optimal\nsubset, but in practice it seems to produce optimal results on\nreal-world data.\n\nHere's a short description of the **correlate** \"greedy\" algorithm:\n\n* Sort `matches` with highest score first.\n* For every match `M` in `matches`:\n    * if `value_a` hasn't been matched yet,\n    * and `value_b` hasn't been matched yet,\n        * keep `M` as a good match,\n        * remember that `value_a` has been matched,\n        * and remember that `value_b` has been matched.\n\nThe sorting uses Python's built-in sort (Timsort), so it's\n*O*(n log n).  It's implemented in C so it's pretty quick.\nThe `for` loop is *O*(n).\n\nHowever!  Late in development of **correlate** I\nrealized there was a corner case where odds are good the\ngreedy algorithm wouldn't produce an optimal result.\nHappily, this had a relatively easy fix, and the\nfix didn't make **correlate** any slower in the general case.\n\nLet's start with the problem, the nasty corner case.  What if two\nmatches in the list are both viable, and they have the *same* score,\nand they have either `value_a` or `value_b` in common?\nIt's ambiguous as to which match the greedy algorithm\nwill choose.  But choosing the wrong one *could* result\nin less-than-optimal scoring in practice.\n\nHere's a specific example:\n\n* `dataset_a` contains fuzzy keys `fka1` and `fka2`.\n* `dataset_b` contains fuzzy keys `fkbH` and `fkbL`.\n  Any match containing `fkbH` has a higher score than any match containing `fkbL`.\n  (the H means *high* scoring,  the L means *low* scoring.)\n* The matches`fka1->fkbH` and `fka2->fkbH` have the same score.\n* The match `fka1->fkbL` has a lower score than `fka2->fkbL`.\n\nThe cumulative score over all matches would be higher if\n**correlate** chose `fka2->fkbL` to `fka1->fkbL`.\nAnd since scores in **correlate** are an indicator of\nthe quality of a match, a higher cumulative score reflects\nhigher quality matches.  Therefore we should maximize the\ncumulative score wherever possible.\n\nBut the greedy algorithm can only pick the higher-scoring second\nmatch if it previously picked `fka1->fkbH`.  And there's no guarantee\nthat it would!  If two items in the list have the same score,\nit's ambiguous which one the greedy algorithm would choose.\n\nTo handle this properly it needs to look ahead and experiment.\nSo that's why I wrote what I call the \"match boiler\", or the\n\"boiler\" for short.  The boiler uses a hybrid approach.  By default,\nwhen the scores for matches are unique, it uses the \"greedy\"\nalgorithm.  But if it encounters a group of items with matching\nscores, where any of those items have `value_a` or `value_b` in\ncommon, it recursively runs an experiment where it chooses each\nof those matches in turn.  It computes the score from each of these\nrecursive experiments and keeps the one with the highest score.\n\n(If two or more experiments have the same score, it keeps the first one\nit encountered with that score--but, since the input to the \"match boiler\"\nis a list, sorted with highest scores to the end, technically it's the\n*last* entry in the list that produced the high-scoring experiment.)\n\nWith the \"match boiler\" in place, **correlate** seems to produce optimal\nresults even in these rare ambigous situations.\n\nI'm honestly not sure what the *big-O* notation is for the \"match boiler\".\nThe pathological worst case\nis *probably* on the order of *O*(n log n), where the `log n` component\nrepresents the recursions.\nIn this case, every match has the same score, and they're all connected to\neach other via having `value_a` and `value_b` in common.  I still don't\nthink the \"match boiler\" would be as bad as *O*(n²).\nThe thing is, sooner or later the recursive step would cut the\n\"group\" of \"connected items\" in half (see next section).  It's guaranteed\n*not* to recurse on every single item.\nSo I assert that roughly cuts the number of recursive\nsteps down to `log n`, in the pathological worst case that you would\nnever see in real-world data.\n\n#### Cheap Recursion And The \"Grouper\"\n\nBut wait!  It gets even more complicated!\n\nCompared to the rest of the algorithm, the recursive step of the\n\"match boiler\" is quite expensive.  It does reduce the domain of\nthe problem at every step, so it's guaranteed to complete...\nsomeday.  But, if we're not careful, it'll perform a lot of\nexpensive and redundant calculations.  So there are a bunch\nof optimizations to the match boiler's recursive step, mainly\nto do with the group of matches that have the same score.\n\nThe first step is to analyze these matches and boil them out\ninto \"connected groups\".  A \"connected group\" is a set of\nmatch objects where either each object has a `value_a` or a\n`value_b` in common with another object in the group.  These\nare relevant because choosing one of the matches from these\ngroups will remove at least one other value from consideration\nin that group, because that `value_a` or `value_b` is\nnow \"used\" and so all remaining match using those values\nwill be discarded.\n\nAn example might help here.  Let's say you have these\nsix matches in a row all with the same score:\n\n    match[1]: value_a = A1, value_b = B1\n    match[2]: value_a = A1, value_b = B2\n    match[3]: value_a = A2, value_b = B1\n    match[4]: value_a = A3, value_b = B2\n    match[5]: value_a = A10, value_b = B10\n    match[6]: value_a = A10, value_b = B11\n\nThis would split into two \"connected groups\": matches 1-4\nwould be in the first group, and matches 5-6 would be in the\nsecond.  Every match in the first group has one member\n(`value_a` or `value_b`) in common with at least one other\nmatch in the first group; every match in the second group\nhas one member in common with at least one other match in\nthe second group.  So every match in the first group is\n\"connected\"; if you put them in a graph, every match would\nbe \"reachable\" from every other match in that group,\neven if they aren't directly connected.  For example,\n`match[4]` doesn't have any members in common with `match[1]`,\nbut both of them have a member in common with `match[2]`.\nBut none of the matches in the first group have any member in\ncommon with any of the matches in the second group (and\nnaturally vice-versa).\n\nThere's a utility function called `grouper()` that computes\nthese connected groups.  (`grouper()` only handles the case\nwhen `reuse_a == reuse_b == False`; there are alternate\nimplementations to handle the other possible cases, e.g.\n`grouper_reuse_a()`.)\n\nThe second step is to take those \"connected groups\" and,\nfor every group containing only one match object,\n\"keep\" it immediately.  We already know we're keeping\nthese and it's cheaper to do that first.\n\nNow that the only remaining connected groups are size 2 or\nmore, the third step is to recurse over each of the values of the\n*smallest* of these connected groups.  Why the smallest?\nIt's cheaper.  Let's say there are 50 items left in the list\nof matches.  At the top are 6 match objects with the same score.\nThere are two groups: one of length 2, the other of length 4.\n\nThe important realization is that, when we perform the experiment\nand recurse using each of these values, we're still going to\nhave to examine all the remaining matches we didn't throw away.\nThe number of operations we'll perform by looping and recursing is,\nroughly, **N** • **M**, where **N** is `len(group)` and **M** is\n`len(matches - group)`.  So which one has fewer operations:\n\n* 2 x 48, or\n* 4 x 46?\n\nObviously the first one!  By recursing into the smaller group,\nwe perform fewer overall operations.\n\n(There's a theoretical opportunity for further optimization here:\nwhen recursing, if there's more than one connected group of length 2\nor greater, pass in the list of groups we *didn't*\nconsume to the recursive step.  That would save the recursive\ncall from re-calculating the connected groups.  In practice I imagine this\nhappens rarely, so handling it would result in a couple of `if`\nbranches that never get taken.  Also, it's a little more complicated\nthan it seems, because you'd have to re-use the `grouper()` on\nthe group you're examining before passing it down, because it might\nsplit it into two groups.  In practice it wouldn't speed up anybody's\ncorrelations, and it'd make the code more complicated.  So let's skip it.\nThe code is already more-or-less correct in these rare circumstances\nand that's good enough.)\n\n\n#### The Match Boiler Reused For Fuzzy Key Scoring\n\nOnce my first version of the \"match boiler\" was done, I realized I could reuse\nit for boiling down all fuzzy key matches too.  Fuzzy key matches already\nused basically the same \"greedy\" algorithm that were used for matches,\nand it dawned on me that the same corner case existed here too.\n\nMy first attempt was quite complicated, as the \"match boiler\" doesn't\nitself understand rounds.  I added a callback which it'd call every time it\nkept a match, which passed in the keys that got matched.  Since those keys\nwere now \"consumed\", I would inject new matches using those keys from\nsubsequent rounds (if any). This worked but the code was complicated.\n\nAnd it got even more complicated later when I added the recursive step!\nI had to save and restore all the state of which fuzzy keys had been\nconsumed from which rounds.  I wound up building it into the subclass\nof `MatchBoiler`, which is part of why `MatchBoiler` clones itself\nwhen recursing.  This made the code cleaner but it was still clumsy\nand a bit slow.\n\nThe subsequent rewrite using the `sort_by` tuple was a big win all around:\nit simplified the code, it let me remove the callback, it let the match\nboiler implicitly handle all the rounds without really understanding them,\n*and* it was even slightly faster!\n\nBut this is why it's so important that the boiler is super-stable.\nEarlier versions of the match boiler assumed it could sort the\ninput array any time it wanted.  But the array passed in was sorted\nby score, *then* by round numbers--highest score is most important,\nlowest round number is second-most important.\nAnd the array is sorted with highest score, then lowest round number, last.\nWhen recursing, the match boiler has to prefer the *last* entry in its\ninput that produced the same score--otherwise, it might accidentally\nconsume a key from a later round before consuming that key from an\nearlier round.\n\nI didn't want to teach the boiler to understand this `sort_by` tuple.\nHappily, I didn't have to.  It wasn't much work to ensure that the boiler\nwas super-stable, and once that was true it always produced correct results.\n(Not to mention... faster!)\n\n\n#### Theoretical Failings Of The Match Boiler\n\nEven with the \"match boiler\", you can still contrive scenarios\nwhere **correlate** will produce arguably sub-optimal results.\nThe boiler only tries experiments where the matches have the\nsame score.  But it's possible that the greedy algorithm may\nfind a local maximum that causes it to miss the global maximum.\n\nIf `A` and `B` are values in `dataset_a`, and `X` and `Y` are\nvalues in `dataset_b`, and the matches have these scores:\n\n    A->X == 10\n    A->Y == 9\n    B->X == 8\n    B->Y == 1\n\nIn this scenario, the boiler will pick `A->X`, which means it's\nleft with `B->Y`.  Total score: 11.  But if it had picked `A->Y`,\nthat means it would get to pick `B->X`, and the total score would\nbe 17!  Amazing!\n\nIs that better?  Your first reaction is probably \"of course!\".\nBut in an abstract, hypothetical scenario like this, it's\nhard to say for sure.  I mean, yes it's a better *score.*  But\nis it a better *match?*  Is this the output the user would have\nwanted?  Who knows--this scenario is completely hypothetical in\nthe first place.\n\nI doubt this is a real problem in practice.  Ensuring **correlate**\nhandles the ambiguous scenario where items had identical scores is\nalready \"gilding the lily\", considering how rare it happens with\nreal-world data.  And when would real data behave in this contrived\nway?  Why would `A` score so highly against `X` and `Y`, but `B` scores\nhigh against `X` but low against `Y`?  If `B` is a good match for `X`,\nand `X` is a good match for `A`, and `A` is a good match for `Y`, then,\nwith real-world data, transitivity would suggest `B` is a good match\nfor `Y`.  This contrived scenario seems more and more contrived the more\nwe look at it, and unlikely to occur in the real world.\n\nI think pathological scenarios where the \"match boiler\" will fail like\nthis aren't realistic.  And the only way I can think of to fix it is\nwith the crushingly expensive *O*(nⁿ) algorithm.\nIt's just not worth it.  So, relax!  As we say in Python: YAGNI.\n\n\n### Ranking\n\nRanking information can help a great deal.\nIf a value in `dataset_a` is near the beginning, and the order\nof values is significant, then we should prefer matching it to values\nin `dataset_b` near the beginning too.  When the datasets are\nordered, matching the first value in `dataset_a` against the last\nvalue in `dataset_b` is probably a bad match.\n\nConceptually it works as follows: when scoring a match,\nmeasure the distance between\nthe two values and let that distance influence the score.  The closer\nthe two values are to each other, the higher the resulting score.\n\nBut how do you compute that distance?  What do the ranking numbers mean?\n**correlate** supports three possible interpretations\nof the rankings:\n\n* *Absolute* ranking,\n* *Relative* ranking, and\n* *Reversed Absolute* ranking.\n\nThese three approaches differ in how they compare the ranking numbers,\nas follows:\n\n* *Absolute* ranking assumes the ranking numbers are the same\n  for both datasets.  `ranking=5` in `dataset_a` is a perfect\n  match to `ranking=5` in `dataset_b`.  This works well when\n  your datasets are both reasonably complete; if they're different\n  sizes, perhaps one or both are truncated at either the beginning\n  or end.\n* *Relative* ranking assumes that the two datasets represent the\n  same range of data, and uses the ratio of the ranking of a value\n  divided by the highest ranking set in that dataset to compute\n  its relative position.  If the highest ranking we saw in a\n  particular dataset was `ranking=150`,\n  then a value that has `ranking=12` set is calculated to be 8%\n  of the way from the beginning to the end.  This percentage\n  is calculated similarly for both datasets, and the distance\n  between two values is the distance between these two percentages.\n  This works well if one or both of your datasets are sparse.\n* *Reversed Absolute* is like *Absolute*, but starts from the\n  *end* rather than from the *beginning.*  Think about *Absolute*\n  ranking this way: it's comparing the distance from\n  beginning of the dataset to the particular value.  Well,\n  *Reversed Absolute* uses the distance from the *end* of the\n  dataset to the particular value.  Consider: if `dataset_a`\n  contains 100 values, and `dataset_b` only contains 15 values,\n  but they're matches for the *last* 15 values of `dataset_a`,\n  neither *Absolute* nor *Relative* are a good fit.  What you'd\n  want there is *Reversed Absolute*.\n\nHere's a more concrete example of how these approaches work.\nLet's say `dataset_a` has 101 items ranked 0 to 100, `dataset_b`\nhas 801 items ranked 0 to 800, and we have a value in\n`dataset_a` with `ranking=50`:\n\n* With *Absolute* ranking, the closest value in `dataset_b` would have\n  `ranking=50`.  The two values are both 50 elements after\n  the first (lowest-ranked) value.\n* With *Relative* ranking, the closest value in `dataset_b` would have\n  `ranking=400`.  The two values are in the middle of the\n  rankings for their respective datasets.\n* With *Reversed Absolute* ranking, the closest value in `dataset_b`\n  would have `ranking=750`.  The two value are both 50 elements\n  in front of the last (highest-ranked) value.\n\nWhich one does **correlate** use?  It's configurable with the `ranking`\nparameter to `correlate()`.  By default it uses the \"best\" ranking.\n\"Best\" ranking means **correlate** compute a score using *all*\nmethods and chooses the one with the highest score.\nYou can override this by supplying a different value to `ranking`\nbut this shouldn't be necessary.  (Theoretically it should be faster\nto use only one ranking approach.  Unfortunately this hasn't been\noptimized yet, so using only one ranking doesn't currently speed\nthings up.)\n\nRanking is the last step in computing the score of a match.\nAs for how ranking affects the score, it depends on whether you\nuse `ranking_bonus` or `ranking_factor`.\n\nBoth approaches start with these four calculations:\n\n    semifinal_scores_sum = sum of all \"semifinal\" scores above\n    ranking_a = the ranking value computed for value_a\n    ranking_b = the ranking value computed for value_b\n    ranking_score = 1 - abs(ranking_a - ranking_b)\n\n`ranking_bonus` is then calculated per-match as follows:\n\n    bonus = ranking_score * ranking_bonus\n    final_score = semifinal_scores_sum + bonus\n\n`ranking_factor` is also calculated per-match, as follows:\n\n    unranked_portion = (1 - ranking_factor) * semifinal_scores_sum\n    ranked_portion = ranking_factor * semifinal_scores_sum * ranking_score\n    final_score = unranked_portion + ranked_portion\n\n(If you don't use either, the final score for the match is effectively\n`semifinal_scores_sum`.)\n\nObviously, `ranking` must be set on both values in both datasets to\nproperly compute `ranking_score`.  If it's not set on *both* values\nbeing considered for a match, **correlate** still applies\n`ranking_bonus` or `ranking_factor` as usual, but it skips the\ninitial four calculations and just uses a `ranking_score` of 0.\n\n\n## Final Random Topics\n\n### Debugging\n\nWhen all else fails... what next?\n\n**correlate** can optionally produce an enormous amount of debug output.\nThe main feature is showing every match it tests, and the score arrived\nat for that match, including every step along the way.  This log output\nquickly gets very large; even a comparison of 600x600 elements will produce\ntens of megabytes of output.\n\nUnfortunately, producing this much debugging output incurred a measurable\nperformance penalty--even when you had logging turned off!  It was mostly\nin computing the \"f-strings\" for the log, but the calls to the logging\nfunctions definitely added overhead too.\n\nMy solution: by default, each of the debug print statements\nis commented out.\n**correlate** ships with a custom script preprocessor called\n`debug.py` that can toggle debugging on and off, by uncommenting and\nre-commenting the debug code.\n\nHow does it know which lines to uncomment?  Each line of the logging-only\ncode ends with the special marker \"`#debug`\".\n\nTo turn on this logging, run the `debug.py` script in the same directory\nas **correlate's** `__init__.py` script.  Each time you run it, it'll\ntoggle (comment / uncomment) the debug print statements.\nNote that the debug feature in **correlate** requires Python 3.8 or higher,\nbecause it frequently uses 3.8's beloved \"equals sign inside f-strings\" syntax.\n\nBy default the logging is sent to stdout.  If you want to override where\nit's sent, write your own `print` function, and assign it to your\n`Correlator` object before calling `correlate()`.\n\nThe format of the log is undocumented and subject to change.  Good luck!\nThe main thing you'll want to do is figure out the \"index\" of the values\nin `dataset_a` and `dataset_b` that you want to compare, then search for\n`\" (index_a) x (index_b) \"`.  For example, if the match you want to see\nis between value index 35 in `dataset_a` and value index 51 in `dataset_b`,\nsearch in the log for `\" 35 x 51 \"`. (The leading and trailing spaces\nmeans your search will skip over, for example, `235 x 514`.)\n\n\n### Alternate Fuzzy Scoring Approaches That Didn't Work\n\nI find the math behind fuzzy scoring a bit surprising.\nIf you boil down the formula to its constituent factors,\nyou'll notice one of the factors is `fuzzy_score` *cubed.*\nWhy is it *cubed?*\n\nThe simplest answer: that's the first approach that seemed to work\nproperly.  To really understand why, you'll need to understand the\nhistory of fuzzy scoring in **correlate**--all the approaches\nI tried first that *didn't* work.\n\nInitially, the score for a fuzzy match was simply the fuzzy score\nmultiplied by the weights and other modifiers.\nThis was always a dumb idea; it meant fuzzy matches had *way* more\nimpact on the score than they should have.  This was particularly\ntrue when you got down to the last 10% or 20% of your matches,\nby which point the score contributed by exact keys had\nfallen off a great deal.  This approach stayed in for what is,\nin retrospect, an embarassingly long time; I'd convinced myself\nthat fuzzy keys were innately more *interesting* than exact keys,\nand so this comparative importance was fitting.\n\nOnce I realized how dumb that was, the obvious approach was to score\nthem identically to exact keys--divide the fuzzy score by the product\nof the number of keys this *could* have matched against in each\nof the two datasets.  This was obviously wrong right away.\nIn the \"YTJD\" test, every value had one or more fuzzy keys, depending\non the test: every value always had a fuzzy date key, and depending\non the test it might have a fuzzy title key and/or a fuzzy episode number\nkey too.  So each of the 812 values in the first dataset had one\nfuzzy key for each fuzzy type, and each of the 724 values in the second\ndataset did too.  Even if we got a perfect fuzzy match, the maximum score\nfor a fuzzy match was now `1.0 / (812 * 724)` which is `0.0000017`.  So now\nwe had the opposite problem: instead of being super important, even a perfect\nfuzzy match contributed practically nothing to the final score.\n\nAfter thinking about it for a while,\nI realized that the exact key score wasn't *really* being\ndivided by the number of *keys* in the two datasets, per se;\nit was being divided by the total possible *score* contributed\nby that key in each of the two datasets.  So instead of\ndividing fuzzy scores by the number of keys, they should be divided\nby the cumulative fuzzy score of all matches involving those two keys.\nThat formula looks like\n`fuzzy_score / (sum_of_fuzzy_scores_for_key_in_A * sum_of_fuzzy_scores_for_key_in_B)`.\n\nThis was a lot closer to correct!  But this formula had a glaring new problem.\nLet's say that in your entire correlation, `dataset_a` only had one\nfuzzy key that maps to a single value,\nand `dataset_a` only had one fuzzy key that also only maps to a single value.\nAnd let's say the fuzzy score you get from matching those two keys\nis `0.000001`--a really terrible match.\nLet's plug those numbers into our formula, shall we!\nWe get `0.000001 / (0.000001 * 0.000001)`, which is `1000000.0`.\nA million!  That's crazy!  We've taken an absolutely\nterrible fuzzy match and inflated its score to be nonsensically high.\nClearly that's not right either.\n\nThis leads us to the formula that actually works.  The insight here\nis that the same formula needs to work identically for exact keys.\nIf you take this formula and compute it where every `fuzzy_score`\nis 1 (or 0), it produces the same result as the formula for exact keys.\nSo the final trick is that we can multiply by `fuzzy_score` wherever we need\nto, because multiplying by 1 doesn't change anything.  That means\nthe resulting formula will still be consistent with the exact keys\nscoring formula.  And what worked was the formula where we multiply by\n`fuzzy_score` three times!\n\nHere again is the formula used to compute the score for a fuzzy match,\nsimplified to ignore weights and rounds:\n\n    value_a = a value from dataset_a\n    value_b = a value from dataset_b\n    key_a = a fuzzy key in dataset_a that maps to value_a\n    key_b = a fuzzy key in dataset_b that maps to value_b\n    fuzzy_score = the result of key_a.compare(key_b)\n    cumulative_a = the cumulative score of all matches between key_a and every fuzzy key of the same type in dataset_b\n    cumulative_b = the cumulative score of all matches between key_b and every fuzzy key of the same type in dataset_a\n    score_ratio_a = fuzzy_score / cumulative_a\n    score_ratio_b = fuzzy_score / cumulative_b\n    unweighted_score = fuzzy_score * score_ratio_a * score_ratio_b\n\nThe final trick really was realizing what `score_ratio_a` represents.\nReally, it represents the ratio of how much *this* fuzzy match for `key_a`\ncontributed to the sum of *all* fuzzy matches for `key_a`\nacross all successful matches in `dataset_a`.\n\n### Why correlate Doesn't Use The Gale-Shapley Algorithm\n\nA friend asked me if the problem **correlate** solves is isomorphic to the Stable Matching Problem:\n\nhttps://en.wikipedia.org/wiki/Stable_matching_problem\n\nBecause, if it was, I could use the Gale-Shapley algorithm:\n\nhttps://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm\n\nI thought about this for quite a while, and I don't think the problem **correlate**\nsolves maps perfectly onto the stable matching problem.  **correlate** solves a problem that is:\n\n1. simpler,\n2. different, and\n3. harder.\n\nFor inputs that are valid for both Gale-Shapley and **correlate**, I assert that both\nalgorithms will return the same results, but **correlate** will be faster.\n\n(Not a claim I make lightly!  Gale and Shapley were both brilliant\nmathematicians--they each independently won the *von Neumann* prize!--and the\nGale-Shapley algorithm is marvelous and elegant.  It's just that **correlate**\ncan take shortcuts Gale-Shapley cannot, because **correlate** is solving\na simpler problem.)\n\nIn all the following examples, `A`, `B`, and `C` are values in `dataset_a` and `X`, `Y`, and `Z` are values\nin `dataset_b`.  The expression `A: XY` means \"`A` prefers `X` to `Y`\". The expression `A:X=1.5` means\n\"when matching `A` and `X`, their score is `1.5`\".  When I talk about Gale-Shapley, `dataset_a` will stand for the\n\"men\" and `dataset_b` will stand for the \"women\", which means `A` is a man and `X` is a woman.  Where we need to talk\nabout the matches themselves, we'll call them `P` and `Q`.\n\n#### How is it simpler?\n\nThe stable matching problem only requires a local ordering, where the preferences of any value in either dataset\nare disjoint from the orderings of any other value.  But **correlate** uses an absolute \"score\"--a number--to compute\nthese preferences, and this score is symmetric; if `A:X=1.5`, then `X:A=1.5` too.\n\nOn this related Wikipedia page:\n\nhttps://en.wikipedia.org/wiki/Lattice_of_stable_matchings\n\nwe find a classic example of a tricky stable matching problem:\n\n    A: YXZ\n    B: ZYX\n    C: XZY\n\n    X: BAC\n    Y: CBA\n    Z: ACB\n\nGale-Shapley handles this situation with aplomb.  Does **correlate**?\nThe answer is... this arrangement of constraints just can't *happen*\nwith **correlate**, because it uses scores to establish its preferences,\nand the scores are symmetric. There are nine possible pairings with\nthose six values. It's impossible to assign a unique score to each of\nthose nine pairings such that the preferences of each value match\nthose constraints.\n\n(And, yes, I'm pretty certain.  Not only did I work my way through it,\nI also wrote a brute-force program that tried every possible combination.\n362,880 attempts later, I declared that there was no possible solution.)\n\n#### How is it different?\n\nOne minor difference: Gale-Shapley specifies that the two sets be of\nequal size; **correlate** permits the two sets to be different sizes.\nBut extending Gale-Shapley to handle this isn't a big deal.  Simply\nextend the algorithm to say that, if the size of the two datasets are\ninequal, swap the datasets if necessary so that the \"men\" are the\nlarger group. Then, if you have an unmatched \"man\" who iterates\nthrough all the \"women\" and nobody traded up to him, he remains\nunmatched.\n\nThe second thing: Gale-Shapley requires that every value in each\ndataset expresses a strictly ordered preference for every value\nin the other dataset. But in **correlate**, two matches can have\nthe same score.\n\nConsider this expression of a **correlate** problem:\n\n    A:X=100\n    A:Y=1\n\n    B:X=100\n    B:Y=2\n\nGale-Shapley as originally stated can't solve that problem, because\nX doesn't prefer A or B--it likes them both equally.  It wouldn't\nbe hard to extend Gale-Shapley to handle this; in the case where it\nprefers two equally, let it arbitrarily pick one.  For example,\nif X prefers A and B equally, say \"maybe\" to the first one that asks,\nand then let that decide for you that you prefer A to B.\n\n#### How is it harder?\n\nHere's the real problem.\n\n**correlate** uses a numerical score to weigh the merits of each match, and seeks to\nmaximize the cumulative score across *all* matches. Gale-Shapley's goals are comparatively\nmodest--any match that's stable is fine. There may be multiple stable matchings; Gale-Shapley\nconsiders them all equally good.\n\nIn practice, I think if you apply the original Gale-Shapley algorithm to an input data set\nwhere the matches have numerical scores, it *would* return the set of matches with the\nhighest cumulative score.  In thinking about it I haven't been able to propose a situation\nwhere it wouldn't.  The problem lies in datasets where two matches have the *same* score--which\nthe original Gale-Shapley algorithm doesn't allow.\n\nEnsuring that **correlate** returns the highest cumulative score in this situation\nrequired adding the sophisticated recursive step to the \"match boiler\".  We'd have to make\na similar modification to Gale-Shapley, giving it a recursive step.  Gale-Shapley is\nalready *O*(n²); I think the modified version would be *O*(n² log n).\n(But, like **correlate**, this worst-case shouldn't happen with real-world data.)\nAnyway, a modified Gale-Shapley that works for all **correlate** inputs is definitely\nmore expensive than what **correlate** has--or what it needs.\n\n#### Mapping Gale-Shapley To The Correlate Greedy Algorithm\n\nAgain, the set of valid inputs for **correlate** and Gale-Shapley aren't\nexactly the same.  But there's a lot of overlap.  Both algorithms can\nhandle an input where:\n\n* we can assign every match between a man `A` and a woman `X` a numerical score,\n* every match involving any particular man `A` has a unique score,\n* and also for every woman `X`,\n* and there are exactly as many men as there are women.\n\nI assert that, for these mutually acceptable inputs, both algorithms\nproduce the same result.  Here's an informal handwave-y proof.\n\nFirst, since Gale-Shapley doesn't handle preferring two matches equally,\nwe'll only consider datasets where all matches have a unique score.\nThis lets us dispense with the match boiler's \"recursive step\", so all we\nneed is the comparatively simple \"greedy algorithm\".  (Again: this\n\"greedy algorithm\" is much cheaper than Gale-Shapley, but as I'll show,\nit's sufficient for the simple problem domain we face here.)\n\nSo let's run Gale-Shapley on our dataset.  And every time we perform\nan operation, we write it down in a list--we write down\n\"man `A` asked woman `X`\" and whether her reply was *maybe* or *no*.\n\nObserve two things about this list:\n\n* First, order is significant in this list of operations.  If you change\nthe order in which particular men ask particular women, the pattern of\nresulting *maybe* and *no* responses will change.\n\n* Second, the *last* \"maybe\" said by each woman is always,\neffectively, a *yes*.\n\nSo let's iterate backwards through this list of matches, and the first\ntime we see any particular woman reply *maybe*, we change that answer\nto a *yes.*\n\nNext: observe that we can swap any two adjacent operations--with one\nimportant caveat.  We must maintain this invariant: for every woman `X`,\nfor every operation containing `X` that happens after `X` says *yes*,\n`X` must say *no.*\n\nThus, if there are two adjacent operations `P` and `Q`, where `P`\nis currently first, and we want to swap them so `Q` is first,\nand if the following conditions are all true:\n\n* The same woman `X` is asked in both `P` and `Q`.\n* In `Q` the woman `X` says either *maybe* or *yes.*\n* In `P` the woman `X` says *maybe.*\n\nThen we can swap `P` and `Q` if and only if we change `X`'s\nresponse in `P` to *no.*\n\nNow that we can reorder all the operations, let's sort the\noperations by score, with the highest score first.\nLet's call the operation with the highest score `P`,\nand say that it matches man `A` with woman `X`.\n\nWe now know the following are true:\n\n* `X` is the first choice of `A`.  This must be true because\n  `P` is the match with the highest score.  Therefore `A` will\n  ask `X` first.\n* `A` is the first choice of `X`, again because `P` is the\n  match with the highest score.  Therefore `X` is\n  guaranteed to say *yes*.\n\nSince the first operation `P` is guaranteed to be a *yes*,\nthat means that every subsequent operation involving either\n`A` or `X` must be a *no*.\n\nWe now iterate down the list to find an operation `Q`\ninvolving man `B` and woman `Y`. We define `Q` as the\nfirst operation such that:\n\n* `Q != P`, and therefore `Q` is after `P` in our ordered list of operations,\n* `B != A`, and\n* `Y != X`.\n\nBy definition `Q` must also be a *yes*, because `B` and `Y`\nare each other's first choices now that `A` and `X` are\nunavailable for matching.  If there are any operations\nbetween `P` and `Q`, these operations involve either `A` or `X`.\nTherefore they must be *no*.  Therefore `Q` represents the\nhighest remaining preference for both `B` and `Y`.\n\nObserve that the whole list looks like this.  Every *yes* is\nthe first operation for both that man and that woman in which\nthey weren't paired up with a woman or man (respectively) that\nhad already said *yes* to someone else.\n\nThis list of operations now more or less resembles the operations\nperformed by the **correlate** \"greedy\" algorithm. It sorts the\nmatches by score, then iterates down that sorted list.  For every\nman `A` and woman `X`, if neither `A` nor `X` has been matched yet,\nit matches `A` and `X` and remembers that they've been matched.\n\nIt's possible that there's minor variation in the list of\noperations; any operation involving any man or any woman\n*after* they've been matched with a *yes* is extraneous.\nSo you can add or remove them all you like without affecting\nthe results.\n\n\n## Version History\n\n**1.1**\n\nAdded a new ranking approach!  The first two were `AbsoluteRanking`\nand `RelativeRanking`, this new third one is `ReversedAbsoluteRanking`.\n\n**1.0**\n\nNo code changes.  But **correlate** has been stable and working\nfor a while now... it's time to mark it as 1.0.\n\n**0.8.3**\n\nA slight bugfix for `print_datasets()`.   `print_datasets()`\nprints out the keys for each value in sorted order.  But that\nmeant sorting the keys, and if you have keys of disparate\ntypes, attempting to compare them with `<` or `>` could throw\na `ValueError`.  So `print_datasets()` now separates the keys\nby type and sorts and prints each list of keys separately.\n\nThe dataset API allows you to set values that don't actually have\nany keys mapping to them.  (You can call `dataset.value()`\nwith a value that you never pass in to `set()` or `set_keys()`.)\n`correlate()` used to simply assert that every value had at\nleast one key; now it raises a `ValueError` with a string\nthat prints every value.  (This can be unreadable if there\nare a lot!  But better safe than sorry.)\n\n**0.8.2**\n\nFixed up ``infer_mv``.  It works the same, but the comments it\nprints out are now much improved.  In particular, there was\na bug where it reported the same score for every match--the score\nof the lowest-ranked match--instead of the correct score for each\nmatch.\n\nThere were no other changes; the **correlate** algorithm is\nunchanged from 0.8.1.\n\n**0.8.1**\n\nFixed compatibility with Python 3.6.  All I needed to do was\nremove some *equals-sign-in-f-strings* usage in spots.\n\n**0.8**\n\nThe result of loving hand-tuned optimization: **correlate** version 0.8\nis now an astonishing *19.5%* faster than version 0.7--and *27.3%* faster\nthan version 0.5!\n\nThe statistics have been improved, including some useful timing information.\nThis really demonstrates how much slower fuzzy keys are.\n\n(To see for yourself, run `python3 tests/ytjd.test.py -v` and compare\nthe slowest test to the fastest, using the same corpus.  On my computer\nthe test without fuzzy keys is *12x faster* than the one that uses\nfuzzy keys for everything.)\n\n**0.7**\n\nCareful micro-optimizations for both exact and fuzzy key\ncode paths have made **correlate** up to 7.5% faster!\n\nThe `MatchBoiler` was made even more ridiculously stable.\nIt should now always:\n\n* return `results` in the same order they appeared in in `matches`, and\n* prefer the *last* equivalent item when two or more items\n  produce the same cumulative score.\n\n**0.6.1**\n\nBugfix for major but rare bug: if there are multiple\ngroups of `len() > 1` of \"connected\" match objects with\nthe same score, the match boiler would only keep the\nsmallest one--the rest were accidentally discarded.\n(`match_boiler_2_test()` was added to `tests/regression_test.py`\nto check for this.)\n\n**0.6**\n\nBig performance boost in \"fuzzy boiling\"!  Clever sorting of fuzzy matches,\nand improvements in the stability (as in \"stable sort\") of `MatchBoiler`,\nallowed using an unmodified boiler to process fuzzy matches.  This allowed\nremoval of `FuzzyMatchBoiler` and the `MatchBoiler.filter()` callback mechanism.\n\nMinor performance improvement in `MatchBoiler`: when recursing, find the\nsmallest group of connected matches with the same score,\nand only recursively check each of those,\nrather than all possibly-connected matches with the same score.\n\nRemoved `key_reuse_penalty_factor`.\nIn the early days of **correlate**, it didn't understand rounds; if you mapped the same\nkey to the same value twice, it only remembered one mapping, the one with the\nhighest weight.  Later I added rounds but they didn't seem to add much signal.\nI thought redundant keys were uninteresting.  So I added `key_reuse_penalty_factor`.\nThat let you turn down the signal they provided, in case it\nwas adding more noise than actual useful signal.\nIt wasn't until the realization that `key->value` in round 0 and `key->value`\nin round 1 were conceptually *two different keys* that I really understood\nhow redundant mappings of the same key to the same value should work.  And\nonce rounds maintained distinct counts of `keys / scores` for the scoring\nformula, redundant keys in different rounds became *way* more informative.\nI now think `key_reuse_penalty_factor` is dumb and worse than useless and\nI've removed it.  If you think `key_reuse_penalty_factor` is useful,\nplease contact me and tell me why!  Or, quietly just pre-multiply it into\nyour weights.\n\n\nThe cumulative effect: a speedup of up to 30% in fuzzy match boiling,\nand up to 5% on YTJD tests using a lot of fuzzy keys.  Match boiling got\nslightly faster too.\n\n**0.5.1**\n\nBugfix release.  In the original version, if a match didn't have any matches between\nfuzzy keys (with a positive score), it ignored the weights of its exact keys and just\nused the raw exact score.\n\n**0.5**\n\nInitial public release.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": null,
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/larryhastings/correlate/",
    "keywords": null,
    "license": null,
    "maintainer": null,
    "maintainer_email": null,
    "name": "correlate",
    "package_url": "https://pypi.org/project/correlate/",
    "platform": null,
    "project_url": "https://pypi.org/project/correlate/",
    "project_urls": {
      "Homepage": "https://github.com/larryhastings/correlate/"
    },
    "release_url": "https://pypi.org/project/correlate/1.1/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Correlates two sets of data by matching",
    "version": "1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17175407,
  "releases": {
    "0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c097bfa2950015686153fd51b94adf9f70beb63aafabfde49bc7ea4296a37e82",
          "md5": "aa1a83a66f922c303b68c4ced92db9b1",
          "sha256": "54a772240b0166910c371dfcd9d993f8683872d4835fcfd489ffea13056ff4a7"
        },
        "downloads": -1,
        "filename": "correlate-0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "aa1a83a66f922c303b68c4ced92db9b1",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 44992,
        "upload_time": "2020-04-07T07:42:38",
        "upload_time_iso_8601": "2020-04-07T07:42:38.072987Z",
        "url": "https://files.pythonhosted.org/packages/c0/97/bfa2950015686153fd51b94adf9f70beb63aafabfde49bc7ea4296a37e82/correlate-0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "45157195dda3714caedc5bead5f9d189bcc8ec82c58275edf11a2b70415e7360",
          "md5": "cc83c6313629e86c5f6ca4ed7a1aeef8",
          "sha256": "c403380ff945d4d0bb28153902b45a336c3684baf600b5224ba2716d136f3455"
        },
        "downloads": -1,
        "filename": "correlate-0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "cc83c6313629e86c5f6ca4ed7a1aeef8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 85131,
        "upload_time": "2020-04-07T07:42:40",
        "upload_time_iso_8601": "2020-04-07T07:42:40.902470Z",
        "url": "https://files.pythonhosted.org/packages/45/15/7195dda3714caedc5bead5f9d189bcc8ec82c58275edf11a2b70415e7360/correlate-0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "44ad74313872b4d631aa479918aa6d256b5b17707b366412f152a112bde5cfe8",
          "md5": "4199960031abbcbcbd6b2a3de8714b76",
          "sha256": "f018c253f2dc068771446cb88884e03e79768c739164f33a949c5b9cb38529b5"
        },
        "downloads": -1,
        "filename": "correlate-0.5.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4199960031abbcbcbd6b2a3de8714b76",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 38707,
        "upload_time": "2020-04-07T11:30:13",
        "upload_time_iso_8601": "2020-04-07T11:30:13.020536Z",
        "url": "https://files.pythonhosted.org/packages/44/ad/74313872b4d631aa479918aa6d256b5b17707b366412f152a112bde5cfe8/correlate-0.5.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3f7bd9bc869f72c8c3aa7d27908d51b35bd6d63bc280254d7213a0a65f5125db",
          "md5": "102bc39d2164f65e0c765169f2872378",
          "sha256": "b557700fea65644c18e03f57a80d69a79a09df668bd0b3214140923c2616a5f3"
        },
        "downloads": -1,
        "filename": "correlate-0.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "102bc39d2164f65e0c765169f2872378",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 79219,
        "upload_time": "2020-04-07T11:30:14",
        "upload_time_iso_8601": "2020-04-07T11:30:14.605910Z",
        "url": "https://files.pythonhosted.org/packages/3f/7b/d9bc869f72c8c3aa7d27908d51b35bd6d63bc280254d7213a0a65f5125db/correlate-0.5.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "99d842ccb183c606cdd7e31767cbcb6314f0e4d92e20a67c785103eb6a296473",
          "md5": "2c5da10938082f2365ef44a4d6e2ab5e",
          "sha256": "cbb152d4f1b600f172df854906e3e340cce25ed9c931a0f8f9de512767cbfae1"
        },
        "downloads": -1,
        "filename": "correlate-0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2c5da10938082f2365ef44a4d6e2ab5e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 40528,
        "upload_time": "2020-04-14T07:43:11",
        "upload_time_iso_8601": "2020-04-14T07:43:11.845299Z",
        "url": "https://files.pythonhosted.org/packages/99/d8/42ccb183c606cdd7e31767cbcb6314f0e4d92e20a67c785103eb6a296473/correlate-0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2a5cfecb320795c33961b6da41699fc6ec0c9912f56abe559aadba40f9d4b9cf",
          "md5": "39141307af648033ce60517cac589b45",
          "sha256": "09b2225baeb1a5c4649a5698751579f6bfca45b6398e00c32851916d01f6fe9b"
        },
        "downloads": -1,
        "filename": "correlate-0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "39141307af648033ce60517cac589b45",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 81786,
        "upload_time": "2020-04-14T07:43:14",
        "upload_time_iso_8601": "2020-04-14T07:43:14.495003Z",
        "url": "https://files.pythonhosted.org/packages/2a/5c/fecb320795c33961b6da41699fc6ec0c9912f56abe559aadba40f9d4b9cf/correlate-0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.6.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "166f733ccd34eb77dd30ffe58122d43500105397e90c05232deae62c387443f5",
          "md5": "5f2a9f171b9118c2fb3f7bda4b62e6a2",
          "sha256": "f839a5855f9a647d2e3b1d52edcc4d12806281a00164ec31e2b2b6bb155d7fd9"
        },
        "downloads": -1,
        "filename": "correlate-0.6.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5f2a9f171b9118c2fb3f7bda4b62e6a2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 41362,
        "upload_time": "2020-04-15T06:45:10",
        "upload_time_iso_8601": "2020-04-15T06:45:10.646113Z",
        "url": "https://files.pythonhosted.org/packages/16/6f/733ccd34eb77dd30ffe58122d43500105397e90c05232deae62c387443f5/correlate-0.6.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2f93d55847d1aadd45bbc5f9c5c2d00dd95f52d30bbfe6f04ea251a7990ac481",
          "md5": "285d342930750661391ede56e4d09f75",
          "sha256": "c03b50aca2a3936a725d0b7baeed4de1f8651ad69d300d6ce5049263178d69ce"
        },
        "downloads": -1,
        "filename": "correlate-0.6.1.tar.gz",
        "has_sig": false,
        "md5_digest": "285d342930750661391ede56e4d09f75",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 82934,
        "upload_time": "2020-04-15T06:45:12",
        "upload_time_iso_8601": "2020-04-15T06:45:12.831241Z",
        "url": "https://files.pythonhosted.org/packages/2f/93/d55847d1aadd45bbc5f9c5c2d00dd95f52d30bbfe6f04ea251a7990ac481/correlate-0.6.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fe849f3cc4a375ffad58e1cb32bc8064743b1bd8253be289e49289c42eedf519",
          "md5": "9adfb36119e2b0786cb5a4aff8fb77ce",
          "sha256": "7c05f2559e52b106337bb91531a49855e271632dceed6bc4786519aa52351c65"
        },
        "downloads": -1,
        "filename": "correlate-0.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9adfb36119e2b0786cb5a4aff8fb77ce",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 47970,
        "upload_time": "2020-04-30T07:54:15",
        "upload_time_iso_8601": "2020-04-30T07:54:15.598648Z",
        "url": "https://files.pythonhosted.org/packages/fe/84/9f3cc4a375ffad58e1cb32bc8064743b1bd8253be289e49289c42eedf519/correlate-0.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2ce33153e16898f9bd8e0d9522f90a141a7c89b9b5cf3a3d6f497543efd7f2ac",
          "md5": "f7cdc1bc563f6e6a9bec555e4d442423",
          "sha256": "d41db73c31e1ae884377b86b27f20a674ab04df33de356904f50e10551651cc5"
        },
        "downloads": -1,
        "filename": "correlate-0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "f7cdc1bc563f6e6a9bec555e4d442423",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 90069,
        "upload_time": "2020-04-30T07:54:17",
        "upload_time_iso_8601": "2020-04-30T07:54:17.877745Z",
        "url": "https://files.pythonhosted.org/packages/2c/e3/3153e16898f9bd8e0d9522f90a141a7c89b9b5cf3a3d6f497543efd7f2ac/correlate-0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2d48d1c2b6f345ce6a0ffbdc56b8ee202f33e28700c671acd655e99323310170",
          "md5": "1456398ffae08ff6179772d2890a9ce6",
          "sha256": "db2b1976d1b92904c0861fcb45cd3237fc69abb0bc6201d0d24266ce1a08f860"
        },
        "downloads": -1,
        "filename": "correlate-0.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1456398ffae08ff6179772d2890a9ce6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 48924,
        "upload_time": "2020-05-03T06:04:04",
        "upload_time_iso_8601": "2020-05-03T06:04:04.738437Z",
        "url": "https://files.pythonhosted.org/packages/2d/48/d1c2b6f345ce6a0ffbdc56b8ee202f33e28700c671acd655e99323310170/correlate-0.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e359e2cf9e175c5f2a3a43652d3e76f72fedcb1bb36d774f8b5de6a6fad99cf1",
          "md5": "982821a5644c2a9fc0f5edb4f0338d04",
          "sha256": "66b42aee1bad3f4e89652a9b0d8f0975606fe99493590c3f3e07866c42a5eb81"
        },
        "downloads": -1,
        "filename": "correlate-0.8.tar.gz",
        "has_sig": false,
        "md5_digest": "982821a5644c2a9fc0f5edb4f0338d04",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 90986,
        "upload_time": "2020-05-03T06:04:06",
        "upload_time_iso_8601": "2020-05-03T06:04:06.470169Z",
        "url": "https://files.pythonhosted.org/packages/e3/59/e2cf9e175c5f2a3a43652d3e76f72fedcb1bb36d774f8b5de6a6fad99cf1/correlate-0.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "635002ce82296e9c91a10de3c30dcedd7c9a434dc6602bc3309afd112c293804",
          "md5": "1520617bdb3eac7fd50faa7f8d13a749",
          "sha256": "b8d519be6292ca44d6ba2c14af8ee0333e025b7b576b696c31519b509457bedb"
        },
        "downloads": -1,
        "filename": "correlate-0.8.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1520617bdb3eac7fd50faa7f8d13a749",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 49555,
        "upload_time": "2020-05-04T06:41:36",
        "upload_time_iso_8601": "2020-05-04T06:41:36.439738Z",
        "url": "https://files.pythonhosted.org/packages/63/50/02ce82296e9c91a10de3c30dcedd7c9a434dc6602bc3309afd112c293804/correlate-0.8.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bcf88bc2f9287da89c393beafec0fe8c0d877ea5d52e2cdd8b0dd67e6f301e51",
          "md5": "b999db9438ef9bc15c74b2c850788256",
          "sha256": "cf0b61dbf72f29d33b7bf9301dddca8247c87cc514a08d0ed979fe5ba7e76902"
        },
        "downloads": -1,
        "filename": "correlate-0.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b999db9438ef9bc15c74b2c850788256",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 91869,
        "upload_time": "2020-05-04T06:41:38",
        "upload_time_iso_8601": "2020-05-04T06:41:38.419813Z",
        "url": "https://files.pythonhosted.org/packages/bc/f8/8bc2f9287da89c393beafec0fe8c0d877ea5d52e2cdd8b0dd67e6f301e51/correlate-0.8.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bf2b17bb8265569cd990b319d7feddc4c59a51224d7fad0487c677a5c640da89",
          "md5": "44b519aca703ba5df6292206db85eacf",
          "sha256": "53fbcd4edae77e0fdeec6555a62f72cc14d1e5ed876b889d945e44733aeb39f7"
        },
        "downloads": -1,
        "filename": "correlate-0.8.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "44b519aca703ba5df6292206db85eacf",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 53083,
        "upload_time": "2020-12-31T22:01:28",
        "upload_time_iso_8601": "2020-12-31T22:01:28.953211Z",
        "url": "https://files.pythonhosted.org/packages/bf/2b/17bb8265569cd990b319d7feddc4c59a51224d7fad0487c677a5c640da89/correlate-0.8.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c0a46d227944d4fa04694936d5b98f347480d5a4e703437eb420ce0f1a3aa398",
          "md5": "11048119a4292d4d892b1cf629dc9ab3",
          "sha256": "ba2dd2056be316609aa22672432b8490c3a009c18cccce76b1f74d06e47f5893"
        },
        "downloads": -1,
        "filename": "correlate-0.8.2.tar.gz",
        "has_sig": false,
        "md5_digest": "11048119a4292d4d892b1cf629dc9ab3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 95918,
        "upload_time": "2020-12-31T22:01:31",
        "upload_time_iso_8601": "2020-12-31T22:01:31.102736Z",
        "url": "https://files.pythonhosted.org/packages/c0/a4/6d227944d4fa04694936d5b98f347480d5a4e703437eb420ce0f1a3aa398/correlate-0.8.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cb779ab91a7f20a7bd68b8f7e99cffd92d682063a8ebada095ebe627ef002fc2",
          "md5": "d939dd75ef286f840e12aeb1ba937abc",
          "sha256": "350298d5f51f60b885fd939a135b378e9e85eb7f52e2353b1a7e99588847c2bc"
        },
        "downloads": -1,
        "filename": "correlate-0.8.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d939dd75ef286f840e12aeb1ba937abc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 53494,
        "upload_time": "2021-02-05T22:45:19",
        "upload_time_iso_8601": "2021-02-05T22:45:19.916496Z",
        "url": "https://files.pythonhosted.org/packages/cb/77/9ab91a7f20a7bd68b8f7e99cffd92d682063a8ebada095ebe627ef002fc2/correlate-0.8.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a1f8ad66e7ba4e796f93fff71be2976697e9c5bdc5d03bf778841dce18abfd60",
          "md5": "a380a6989a18b5dcb104800568118112",
          "sha256": "3d4046dffbed06136e2f2cfde6f6890749d7d2771912490555be7b12a95c7d71"
        },
        "downloads": -1,
        "filename": "correlate-0.8.3.tar.gz",
        "has_sig": false,
        "md5_digest": "a380a6989a18b5dcb104800568118112",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 96351,
        "upload_time": "2021-02-05T22:45:21",
        "upload_time_iso_8601": "2021-02-05T22:45:21.911837Z",
        "url": "https://files.pythonhosted.org/packages/a1/f8/ad66e7ba4e796f93fff71be2976697e9c5bdc5d03bf778841dce18abfd60/correlate-0.8.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "267a905b9d5b0a3f07b4358dd0e773e66bba6268901527c785c470758ad76dac",
          "md5": "281b7b9005d40ed246cd4767ce6f488b",
          "sha256": "7dc78431cf50c05f9e7cf0df1b31ad1ba9ba191c5ee877bbf418360379f48844"
        },
        "downloads": -1,
        "filename": "correlate-1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "281b7b9005d40ed246cd4767ce6f488b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 52999,
        "upload_time": "2021-12-25T03:01:56",
        "upload_time_iso_8601": "2021-12-25T03:01:56.447434Z",
        "url": "https://files.pythonhosted.org/packages/26/7a/905b9d5b0a3f07b4358dd0e773e66bba6268901527c785c470758ad76dac/correlate-1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "050f09f0e0c8c2a68749b19499507e190b336a7696878933871933dd759ce3ad",
          "md5": "76c0f90bc984b239d91efab4fd7a62eb",
          "sha256": "1251ba77e02597f311b603ec86685088edc8f48a634b6d41777ee2dd8bb23a82"
        },
        "downloads": -1,
        "filename": "correlate-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "76c0f90bc984b239d91efab4fd7a62eb",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 129094,
        "upload_time": "2021-12-25T03:01:58",
        "upload_time_iso_8601": "2021-12-25T03:01:58.603059Z",
        "url": "https://files.pythonhosted.org/packages/05/0f/09f0e0c8c2a68749b19499507e190b336a7696878933871933dd759ce3ad/correlate-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1": [
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "036d66a994ddda54153c486ff64ff52d6418652ec7fb3bda0492fc109bd9b3f8",
          "md5": "9355796d2c179e6745fa14e47360773a",
          "sha256": "12b0978075b3c0add3faecbc5b6e18131e01920a061ef2abde3c860e74608b37"
        },
        "downloads": -1,
        "filename": "correlate-1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9355796d2c179e6745fa14e47360773a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 53660,
        "upload_time": "2023-03-06T13:51:39",
        "upload_time_iso_8601": "2023-03-06T13:51:39.513294Z",
        "url": "https://files.pythonhosted.org/packages/03/6d/66a994ddda54153c486ff64ff52d6418652ec7fb3bda0492fc109bd9b3f8/correlate-1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "6353494fa85ff76c21c6b2716e9a5ef12f387508fa6704127f1b7d49337df554",
          "md5": "918732ae52cfcb99114bd76d55b004be",
          "sha256": "e9fedcc499c0fcfa17a0162a1d16030e1c591737ab80cbcf6bcdbf30e8b8d9c5"
        },
        "downloads": -1,
        "filename": "correlate-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "918732ae52cfcb99114bd76d55b004be",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 130734,
        "upload_time": "2023-03-06T13:51:42",
        "upload_time_iso_8601": "2023-03-06T13:51:42.504739Z",
        "url": "https://files.pythonhosted.org/packages/63/53/494fa85ff76c21c6b2716e9a5ef12f387508fa6704127f1b7d49337df554/correlate-1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "036d66a994ddda54153c486ff64ff52d6418652ec7fb3bda0492fc109bd9b3f8",
        "md5": "9355796d2c179e6745fa14e47360773a",
        "sha256": "12b0978075b3c0add3faecbc5b6e18131e01920a061ef2abde3c860e74608b37"
      },
      "downloads": -1,
      "filename": "correlate-1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9355796d2c179e6745fa14e47360773a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 53660,
      "upload_time": "2023-03-06T13:51:39",
      "upload_time_iso_8601": "2023-03-06T13:51:39.513294Z",
      "url": "https://files.pythonhosted.org/packages/03/6d/66a994ddda54153c486ff64ff52d6418652ec7fb3bda0492fc109bd9b3f8/correlate-1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "6353494fa85ff76c21c6b2716e9a5ef12f387508fa6704127f1b7d49337df554",
        "md5": "918732ae52cfcb99114bd76d55b004be",
        "sha256": "e9fedcc499c0fcfa17a0162a1d16030e1c591737ab80cbcf6bcdbf30e8b8d9c5"
      },
      "downloads": -1,
      "filename": "correlate-1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "918732ae52cfcb99114bd76d55b004be",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 130734,
      "upload_time": "2023-03-06T13:51:42",
      "upload_time_iso_8601": "2023-03-06T13:51:42.504739Z",
      "url": "https://files.pythonhosted.org/packages/63/53/494fa85ff76c21c6b2716e9a5ef12f387508fa6704127f1b7d49337df554/correlate-1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}