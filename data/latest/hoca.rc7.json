{
  "info": {
    "author": "Jean-Louis Paquelin and Enrico Formenti",
    "author_email": "g-art-dev@villa-arson.org",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7",
      "Topic :: Artistic Software",
      "Topic :: Scientific/Engineering",
      "Topic :: Scientific/Engineering :: Artificial Life",
      "Topic :: Scientific/Engineering :: Image Processing",
      "Topic :: Software Development",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# hoca: an Higher-Order Cellular Automata Python Library\n\n## Overview\n\nIn the 80's many computer science magazines featured articles on Conway's game of life and Wolfram's elementary \ncellular automata. Many of these articles told us that cellular automata would revolutionize the arts and sciences.\nThere have indeed been some interesting scientific developments, but we cannot say that this announcement turned out\nto be premonitory, at least for the arts.\n\n`hoca` is a work in progress which aims to provide a framework to test ideas around the use of higher-order\ncellular automata to manipulate or create images. It is born while having some artistic goal in mind, but the\napproach quickly led to compare it with some traditional algorithms of the image processing toolkit.\nSo this work is double bound to visual arts and computer science.\n\n`Hoca` is a Python library, and its code was primarily written with readability before speed in mind. So relax\nand enjoy the scenery.\n\n## Installation\nThe latest version of `hoca` is installed via a standard pip command:\n\n```shell\npip install hoca\n```\n\n## Documentation\n\nAll the code is documented and largely commented, and we strongly recommend taking a look at it.\nHowever, in the following lines, we will introduce some concepts and present some examples.\nBut this matter could always be enhanced, so feel free to send us any comment, suggestion or question.\n\n### Concepts\n\n`hoca` relies on three concepts provided as classes and their subclasses: The fields, the populations, and\nthe automata.  \nFields hold the data processed by the automata population - a collection of agents - while populations\norchestrate the global behaviour of the automata.\n\n#### Field classes\n\nThe `Field` abstract class (in the `hoca.core.automata_framework` module) provides a common set of definitions of\na field implementation. At the moment, there is only one implementation provided, the `ImageField`\nsubclass (in the `hoca.core.ImageField` module) that allows image manipulation.\n\nFields are data structures that hold the source data processed by an automata population,\nor the result data produced by them. Fields can also be both source and result at the same time,\nthis way the automata can modify the field _in place_.  \n\nFor this purpose fields have an io_mode property that defines if they are:  \n- readable: `io_mode == Field.IOMode.IN`\n- writable: `io_mode == Field.IOMode.OUT`\n- readable and writable: `io_mode == Field.IOMode.INOUT`\n\nThe `ImageField` class provides two convenience class methods:\n- `from_image()` that creates an ImageField instance from an image file,\n- `blank()` that creates an ImageField filled with zeros.\n\nOnce a field (or multiple ones) has been instantiated, it has to be packed in a Python dictionary before\nbeing passed to the automata population. The key used along with the field will serve to select the data\nto be read or written by the automata, and to name the logged data.\n\nTo facilitate the preparation of the necessary field(s) to be supplied to an automata population, one may\ncall the `build_field_dict()` class method that all the automata classes must provide.\n\n#### Population classes\n\nThe `Population` abstract class (in the `hoca.core.automata_framework` module) provides a minimal set\nof definitions of the necessary methods for the automata population operation. The implementation of\nthese methods is provided in the `BasicPopulation` class (in the `hoca.core.BasicPopulation` module).\n\n`BasicPopulation` offers two main methods:\n- `run()` which runs all the automata once (i.e. one generation),\n- `play()` which runs all the automata for multiple generations.\n\nThe first is the most _complex_ of the two as `play()` simply calls `run()` repeatedly.\n\n`BasicPopulation` implements every features needed to achieve some task with a population of automata\n(or at least the features we wanted to investigate), and it's quite easy to use:\n\n1. Build a dictionary referencing one or more fields,\n   \n2. instantiate a `BasicPopulation` passing the field dictionary and an automata class to it,\n   \n3. play the population for a while.\n\nThe result of the automata process will be in the fields and that's maybe all one wants. However, to have\na clearer view on what's going on with the automata population or for debugging purpose, `hoca` provides\na `BasicPopulation` subclass: The `CallbackPopulation` (in the `hoca.monitor.CallbackPopulation` module).\n\nThe `CallbackPopulation` works the same as the `BasicPopulation` but it allows providing callbacks that are\ninvoked at the end of each generation (more on that below). These callbacks can log some information about\nthe state of the population or build a video of the movements of the automata.\n\n#### Automata class\n\nThe `Automata` abstract class (in the `hoca.core.automata_framework` module) defines the methods all\nautomaton classes must implement. There are three important methods:\n\n- The `build_field_dict()` class method is responsible for building a well-formed field dictionary in order\n  for the automata of this class to be able to process the data they contain. The field dictionary will be\n  passed to the population later on.\n  \n- The `run()` method defines the behaviour of each automaton instance of the implemented `Automaton`\n  class. The `run()` method is in charge of:\n  - Moving the automaton, and\n  - updating the field(s).\n  \n- The `get_status()` method computes and returns the current status of the automaton. This method will be\n  invoked on each generation for each automaton.\n  \n### Getting started with hoca\n\nThe `hoca.demo.LiteEdgeAutomaton` module provides the `LiteEdgeAutomaton` automata class. These automata\ncrawl an `ImageField` containing an image, and fill another `ImageField` with the contours found \nin the first.\n\n![Edward Hopper. Nighthawks, 1942. The Art Institute of Chicago.](https://github.com/g-art-dev/hoca/raw/main/images/EdwardHopper_Nighthawks_1942.jpg)\n> Edward Hopper. Nighthawks, 1942. (CC0) The Art Institute of Chicago.  \n> [https://www.artic.edu/artworks/111628/nighthawks](https://www.artic.edu/artworks/111628/nighthawks)  \n> (_source field_)\n\nWe will now see how to write some code to use this class: We have to build a field dictionary\nto:\n\n1. provide the source image and receive the contours drawn,\n   \n2. constitute a population of `LiteEdgeAutomaton`,\n\n3. and then _play_ the population.\n   \nHere is the code:\n\n```python\nimport random\n\nfrom hoca.core.BasicPopulation import BasicPopulation\nfrom hoca.demo.LiteEdgeAutomaton import LiteEdgeAutomaton\n\n# It may be of some interest to init the pseudo random generator to get consistent result\n# across multiple runs. This is optional.\nrandom.seed('This is the seed')\n\n# Build the field\nfield_dict = LiteEdgeAutomaton.build_field_dict('images/EdwardHopper_Nighthawks_1942.jpg')\n\n# Create the automata population\nautomata_count = 3800\nautomata_population = BasicPopulation(field_dict, automata_count, LiteEdgeAutomaton)\n\n# Play the population\nautomata_population.play(stop_after=2700)\n\n# Display the result\nfield_dict[\"result\"].image.show()\n```\n\nObviously, the code starts with the importation of the stuff it will need, it then initializes the field\ndictionary. In order to do that, the code calls the `build_field_dict()` convenience class method of the automata\nclass, passing the image to process to it. In this case, the returned dictionary contains two items the\n`\"source\"` field and the `\"result\"` field.  \nNote the parameters of `build_field_dict()` may change from class to class as the data to be processed may\ndiffer.\n\nThe automata population is created by instantiating the `BasicPopulation` class. The program passes the field\ndictionary, the number of automata to instantiate and the class of the automata to it.\nThe population is then played for 2700 generations by calling the `play()` method. \n\nThe program ends displaying the result field as an image. The field dictionary may also be accessed through the\ncorresponding property of the population instance (here `automata_population.field_dict`).\n\n![Nighthawks contours](https://github.com/g-art-dev/hoca/raw/main/images/LiteEdgeAutomation_A3800_I2700_result.jpg)\n> Hopper's Nighthawks after 2700 generations with 3800 LiteEdgeAutomaton automata.  \n> (_result field_)\n\nAs the image representation of a field is a PIL Image class instance, it can be saved or manipulated in many\nways. See the [Pillow Image module documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html)\nfor more information.\n\nIn the previous program, one can see the number of automata to instantiate or the number of generations as kind\nof magic numbers.\nThese numbers depend on the job the automata are doing, or the data provided. For instance, these numbers have\nprobably to be increased if the source image is larger. \nIn the case of the `LiteEdgeAutomaton`, these numbers are discussed in [1].\n\n#### Let's make a video\n\nThe `CallbackPopulation` class allows doing various tasks at each generation. For instance, we can aggregate\nthe result field at each generation to produce a video showing the effect of an automata population on a\nsource field:\n\n```python\nimport random\n\nfrom hoca.demo.LiteEdgeAutomaton import LiteEdgeAutomaton\nfrom hoca.monitor.CallbackPopulation import *\n\n# It may be of some interest to init the pseudo random generator to get consistent result\n# across multiple runs. This is optional.\nrandom.seed('This is the seed')\n\n# Build the field\nfield_dict = LiteEdgeAutomaton.build_field_dict('images/EdwardHopper_Nighthawks_1942.jpg')\n\n# Create the automata population\nautomata_count = 3800\nstop_after = 2700\nautomata_population = CallbackPopulation(field_dict, automata_count, LiteEdgeAutomaton)\n\n# Register the callbacks...\n# A logging callback\nautomata_population.register_callback(LogProgressCallback(automata_population))\n# A video building callback\n# video is built from the result fields each 5 generations\nautomata_population.register_callback(\n    SaveFieldsVideoCallback(automata_population,\n                            activation_condition_function=Callback.condition_each_n_generation(5)))\n\n# Play the population\nautomata_population.play(stop_after=stop_after)\n```\n\nThis code is quite similar to the previous one. But after having initialized the population class, some\ncallbacks are registered before playing the population. These callbacks are instances\nof one of the abstract `Callback` subclass (all defined in the `hoca.monitor.CallbackPopulation` module):\n\n- `LogProgressCallback` logs the progress of the computation in a file or to the console.\n\n- `SaveFieldsImageCallback` and `SaveFieldsVideoCallback` save the fields manipulated by the automata\n  population as a collection of images (stored in a folder) or as a video. \n\n- `SaveTracesImageCallback` or `SaveTracesVideoCallback` save the trace - the positions and/or the trajectories -\n  of the automata population as a collection of images (stored in a folder) or as a video. These are\n  particularly useful to debug an automaton code.\n\nThese callbacks must receive the population as a parameter. They are called on every generation but they can\nalso receive an optional so-called activation function (or an activation function generator) in order\nto control when the callback will have to do its job.\nFor instance, this mechanism could be used to make the callback aggregate some data at each generation but\nonly report a summary once in a while.\nThe activation function will take the population as parameter and return `True` if some condition has\noccurred (and `False` otherwise).\nIn the above example, `Callback.condition_each_n_generation(5)` is a function generator which builds an\nactivation function returning `True` every 5 generations. Hence, the video produced will have `2700 / 5`\nframes (it's 21.6s at 25fps).\n\nWe may add the following lines to trace the trajectories of the automata:\n\n```python\n    # A callback tracing the automata trajectories\n    automata_population.register_callback(\n        SaveTracesImageCallback(automata_population,\n                                trace=Trace.TRAJECTORIES,\n                                activation_condition_function=Callback.condition_at_generation(stop_after)))\n```\n\n### Coding an automaton\n\nWriting the code of an automaton needs to take care of few important things. We will illustrate the whole\nprocess by describing the important elements of an automata class and writing a toy arty automata class. \n\nAn automata class must inherit the `Automaton` abstract class and implement some mandatory methods:\n\n- `build_field_dict()` class method. This method will be used to build a proper field dictionary for the\n  automaton we are writing. The field dictionary will contain one or more fields. The number of fields depends\n  on what the automata are processing. The name (or keys as they're stored in a Python dictionary) can be\n  chosen freely.\n  \n- `run()` instance method. This method will contain the code controlling the behaviour of the automaton.\n  It will be called on each generation by the class that handles the automata population (presumably \n  `BasicPopulation` or `CallbackPopulation`). It will have to:\n  \n  - Read the value at the current automaton position of any provided input (or input-output) field.\n    However, please note that nothing prevents the automaton to read the value at any other coordinates.\n  \n  - Write the value at the current automaton position of any provided output (or input-output) field.\n    The same remark as reading the input field(s) applies, the writing can occur anywhere.\n    \n  - Update the state of the automaton.\n  \n  - Move the automaton to an adjacent field position. But as before, nothing prevents the automaton to jump\n    anywhere.\n  \n  These tasks may be done in any order (compatible with the purpose of the automaton). Some of them can be omitted\n  if they aren't necessary. \n  \n- `get_status()` instance method. This method will return the current status of the automaton, an instance\n  of the `hoca.core.automata_framework.AutomatonStatus` class.\n  \n- `describe()` class method. This method will return a string describing the automata class.\n\nWe also have to implement the `__init__()` method without omitting to call `super().__init__()` to invoke\nthe corresponding function of the parent class. As we are interested in higher-order automata,\nthe `__init__()` method has the responsibility to initialize the state or \"memory\" of the automaton for\nlater use.\n\nLet say we want to write an automata class that shuffles the content of a field containing an image, moving\nthe pixels along a specified distance and in a random direction. That may look similar to the [_Spread_ filter\nof the GNU Image Manipulation Program](https://docs.gimp.org/2.10/en/gimp-filter-noise-spread.html).\n\nThe code below is an implementation of such an antomaton. It is commented to explain how it works, but you'll\nfind more explanations below it.\n\n```python\n# Import the needed modules.\nimport random\n\nfrom hoca.core.automata_framework import Automaton, AutomatonStatus\nfrom hoca.core.ImageField import ImageField\nfrom hoca.core.utilities import AutomataUtilities\n\n\nclass SpreadingAutomaton(Automaton):\n    # The amount class variable determines how far a pixel will be moved.\n    amount = 5\n\n    @classmethod\n    def build_field_dict(cls, image_path):\n        # Build a field dictionary:\n        # - The source field is a read-only field built from the provided image.\n        # - The result field is a blank write-only field the same size of the source field.\n        source_field = ImageField.from_image(image_path, io_mode=ImageField.IOMode.IN, image_mode=\"RGB\")\n        return {'source': source_field,\n                'result': ImageField.blank(source_field.size, io_mode=ImageField.IOMode.OUT, image_mode=\"RGB\")}\n\n    def __init__(self, automata_population):\n        super().__init__()\n\n        # Keep a shortcut to the fields, it improves readability\n        # and may be efficient as it is accessed quite often.\n        # Set a shortcut to the fields from the fields dictionary\n        self.source_field = automata_population.field_dict['source']\n        self.result_field = automata_population.field_dict['result']\n\n        # Set an initial random position for the automaton\n        self.x = random.randint(0, self.source_field.width - 1)\n        self.y = random.randint(0, self.source_field.height - 1)\n\n        # As the automaton will move the pixel (it's colour actually) we also need to keep track\n        # we need a property to store the colour information while it's moved.\n        # This property is initialized with the colour value of the pixel at its current position\n        self.colour = self.source_field[self.x, self.y]\n\n        # We also need to know how far the pixel has been moved up to now.\n        self.distance = 0\n\n        # Set the automaton life expectancy from the population size and the dimensions of the field.\n        # In order to have a chance to move every pixels of the image we will choose this property of the\n        # automaton such that the number of pixels to be processed by an automaton is equal to\n        # the total number of pixels in the image divided by the number of automata.\n        # Note that, as the process is stochastic, it doesn't ensure that all pixels will be moved,\n        # it just allows it.\n        self.pixel_count_before_death = \\\n            self.source_field.width * self.source_field.height // automata_population.population_size\n\n        # Finally, set it alive.\n        self.status = AutomatonStatus.ALIVE\n\n    def run(self):\n        # Check if the automaton with its pixel/color has moved enough\n        if self.distance == self.amount:\n            # ... the pixel has been moved enough\n            # Set the color of the pixel at the current automaton position (on the result field)\n            self.result_field[self.x, self.y] = self.colour\n\n            # Decrease the number of pixels to be processed\n            self.pixel_count_before_death -= 1\n            # If the automaton has processed enough pixels, make it die.\n            if self.pixel_count_before_death == 0:\n                self.status = AutomatonStatus.DEAD\n                # And end run\n                return\n\n            # The automaton is still alive and it has still some pixels to process...\n            # Get the pixel color under the automaton (on the source field).\n            self.colour = self.source_field[self.x, self.y]\n\n            # Reset the distance traveled\n            self.distance = 0\n\n        # Move the automaton on one of the adjacent position:\n        # Choose a direction randomly and update the automaton position.\n        direction = random.randint(0, 7)\n        self.x, self.y = AutomataUtilities.get_x_y(direction, self.x, self.y)\n        # The direction may make the automaton pass a border of the field. So we need to wrap the coordinates\n        # around the field (or the contrary?). i.e. If the direction makes the automaton pass the right border\n        # of the field it will be moved to the left border and vice versa (the same for the top and bottom borders).\n        self.x, self.y = AutomataUtilities.wrap_coordinates(self.x, self.y, *self.source_field.size)\n\n        # Increase the count of the distance traveled so far\n        self.distance += 1\n\n    def get_status(self):\n        # Just return a status\n        return AutomatonStatus(self.status, self.x, self.y)\n\n    @classmethod\n    def describe(cls, short=True):\n        if short:\n            return f\"{super().describe(short=short)}-{cls.amount}\"\n        else:\n            return f\"\"\"{super().describe(short=short)}\n    amount: {cls.amount}\"\"\"\n```\n\nThe `build_field_dict()` method will prepare the field dictionary for the automata population. There are (as usual)\nmany ways to look at that. The most obvious is to have a dictionary with two fields: one field filled with the source image\nand one initially empty field to be filled by the automata process.\n\nThe `__init()__` method initializes the state of the automaton. This state will contain the necessary properties\nthe automaton must \"know\" from one generation to the next. These are, for example, the position (x, y) of the\nautomaton on the fields or its status (is it living or dead?).  \nIn the automata class we are coding, we also need  to retain the colour of the pixel the automata is moving, \nand the distance it has traveled. Hence, the `colour` instance variable is initialized with the colour found\nat the automaton initial position and the `distance` is initialized to 0 (has the automaton has not moved yet).  \nExcept if you always know in advance the number of generation the whole population of automata has to be run,\nit is also useful to have some sort of counter to control the life expectancy of each automaton.\nIn our case, the `pixel_count_before_death` instance variable will be decreased each time the automaton has\ncompleted a pixel move. The initial value of this variable will depend on the image size and the number of\nautomata in the population. Then, when the variable goes to zero, the automaton will die.\n\nIt is very important to call the `__init()__` method of the parent class (however, the location of the call\nisn't necessarily at the beginning of the method). In the case of our `SpreadingAutomaton` class, the parent class\nis the abstract `Automaton` which `__init()__` method sets the status property of the automaton to\n`AutomatonStatus.ALIVE` in order to let it run on the first population generation.\n\nThe `run()` method will do the work of the automaton for one generation. It's obviously the most interesting\npart of the automaton to write. In the case of the `SpreadingAutomaton` there are four things we need to handle:\n\n- The writing of the pixel colour currently stored in the `colour` variable when the automaton has moved enough.\n\n- The death of the automaton. It has to move a number of pixel colours equal to the value of `pixel_count_before_death`\n  variable. After that, the automaton should die.\n  \n- The reading of a new pixel colour when the automaton has completed the handling the previous pixel colour.\n\n- The movement of the automaton. It has to travel a number of pixels equal to the value of the `amount` class variable.\n\nThe writing of the `get_status()` method is straightforward, it just had to return the `status` variable (along with\nthe coordinates). But in some cases, the `run()` method don't or cannot compute the status, or it depends on an event\nexternal to the automaton instance or not occurring while the `run()` method is executed. Then, the automaton status\nshould be computed in the `get_status()` method.\n\nThere is not much to say about the `describe()` method except it's a class method and it can't report about\nthe automaton instance. Note this may change in the future.\n\nSo we wrote the class, now we need to run it. We'll follow the same path as in the previous section using the\n`CallbackPopulation` class to run a population of automata while having some report about what's going on.\n\n```python\nif __name__ == \"__main__\":\n    from hoca.monitor.CallbackPopulation import CallbackPopulation, LogProgressCallback\n\n    # Init the pseudo random generator to be able to replay the same population behaviour\n    # This is optional\n    random.seed('This is the seed')\n\n    automata_class = SpreadingAutomaton\n\n    # We can change the amount class property to spread the pixels farther.\n    # SpreadingAutomaton.amount = 10\n\n    # Build field\n    field_dict = automata_class.build_field_dict(\"images/EdwardHopper_Nighthawks_1942.jpg\")\n\n    # Create the automata population\n    automata_count = 1000\n    automata_population = CallbackPopulation(field_dict, automata_count, automata_class)\n\n    # Register a logging callback\n    automata_population.register_callback(LogProgressCallback(automata_population))\n\n    # Play the population\n    automata_population.play(stop_after=1000000)\n\n    # Display the result\n    field_dict[\"result\"].image.show()\n```\n\nNote that the `play()` method of the population is called with an arbitrary large number because the automata determine\nby themselves (with the `pixel_count_before_death` variable) the number of generations needed to achieve their job.\nSo the `play()` method will return when all the automata have died even if it's before having reached the millionth\ngeneration.\n\n![Spread Nighthawks](https://github.com/g-art-dev/hoca/raw/main/images/SpreadingAutomaton_A1000_I1931_result-withstains.jpg)\n> Hopper's Nighthawks after 1931 generations with 1000 SpreadAutomaton automata (with stains).  \n> (_result field_)\n\nYou can see in the result of the execution of the automata code above. There are black stains on the spread\nimage. This is not necessarily desirable, and it comes from the randomness of the coverage of the fields by the\nautomata.\nIn order to avoid this phenomenon (or at least hide it), we can pre-fill the result field with the original image.\nThis is done with a rewritten `build_field_dict()` method.\n\n```python\n    @classmethod\n    def build_field_dict(cls, image_path):\n        # As the course of the automata is random (see the run() method), the source and/or result fields\n        # will probably not be covered entirely and the result field will contain black/blank pixels. In order to\n        # have a (more interesting?) result without those blank spots, one can pre-fill the result field with the\n        # source image:\n        # - The source field is a read-only field built from the provided image.\n        # - The result field is a write-only field built from the provided image.\n        return {'source': ImageField.from_image(image_path, io_mode=ImageField.IOMode.IN, image_mode=\"RGB\"),\n                'result': ImageField.from_image(image_path, io_mode=ImageField.IOMode.OUT, image_mode=\"RGB\")}\n```\n\n![Spread Nighthawks](https://github.com/g-art-dev/hoca/raw/main/images/SpreadingAutomaton_A1000_I1931_result-nostain.jpg)\n> Hopper's Nighthawks after 1931 generations with 1000 SpreadAutomaton automata (without stain).  \n> (_result field_)\n\nA similar result could have been achieved by using a single input-output field. The automata would have read and\nwrite the colours on the same field, swapping the pixels at the beginning and the end of the move, or taking the colour\nfound at the end of the move for the next move.\n\nThe code of the `run()` method is quite demonstrative and may be easily enhanced if the user is in need of performance.\nAt the moment, it takes a number of generations equal to the `amount` class variable for an automaton to move the colour.\nBut this could be done in a single generation:\n\n```python\n    # Compute the relative destination position.\n    dx = random.randint(-self.amount, self.amount)\n    dy = random.randint(-self.amount, self.amount)\n    # As |dx| may be greater than 1 (the same for |dy|), the automaton will \"jump\" from\n    # its current position to the next.\n\n    # Compute the destination coordinates wrapping them if they're out of the field.\n    self.x, self.y = AutomataUtilities.wrap_coordinates(self.x + dx, self.y + dy, *self.source_field.size)\n\n    # Finally, update the distance travelled.\n    self.distance = self.amount\n```\n\nAs a final thought about this automata class, using a cellular automaton to do this kind of operation on an image isn't \nprobably the most efficient way to get a result. However, this approach allows thinking locally (at the pixel level)\ninstead of globally (at the image level) and may lead to simpler investigation of an idea.\n\n## Limitations\n\nAt the moment, automata are not aware of each other. This means you can't use the `hoca` library\nto implement classic automata, the Conway's game of life for instance. You can do it actually,\nbut it will be in O(N²) as each automaton will have to look at all other automata in the population\nto know if some are its neighbours.\n\n## Advertising hoca\n\nIt would be greatly appreciated by the authors if the images and other productions made with the `hoca` library\nwere accompanied by a citation naming it; something like:  \n\n> This <work> was produced with the `hoca` library (https://pypi.org/project/hoca/).\n\nYou might also send us a little mail about what you're doing with `hoca`.\n\n## Licencing & contribution\n\n`hoca` is a free software library written at [Villa Arson](https://www.villa-arson.fr/) and\n[I3S](https://www.i3s.unice.fr/) and released on GitHub under the LGPLv3 license.\nYou should have received a copy of the GNU Lesser General Public License\nalong with `hoca`. If not, see http://www.gnu.org/licenses/.\n\nThe library is copyrighted by its contributors (see source file headers).\n\nThere is a lot of room for improvements, everyone is welcome to contribute if you find any bug or have ideas\nfor new features!\n\n## Bibliography\n\n[1] Formenti E., Paquelin JL. (2021) _High Order Cellular Automata for Edge Detection: A Preliminary Study_.\n_In_: Cellular Automata. ACRI 2020. Lecture Notes in Computer Science, vol 12599. Springer,\nCham. https://doi.org/10.1007/978-3-030-69480-7_9\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/g-art-dev/hoca",
    "keywords": "cellular automata,agents",
    "license": "GNU Lesser General Public License v3 or later",
    "maintainer": "",
    "maintainer_email": "",
    "name": "hoca",
    "package_url": "https://pypi.org/project/hoca/",
    "platform": "",
    "project_url": "https://pypi.org/project/hoca/",
    "project_urls": {
      "Homepage": "https://github.com/g-art-dev/hoca"
    },
    "release_url": "https://pypi.org/project/hoca/2021.9.0/",
    "requires_dist": [
      "numpy (>=1.20.1)",
      "Pillow (>=7.0.0)",
      "av (>=8.0.3)"
    ],
    "requires_python": ">=3",
    "summary": "Provides a set of tools to implement Higher-Order Cellular Automata populations",
    "version": "2021.9.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11337317,
  "releases": {
    "2021.6.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eb224266b782b450d5d521f61ad534c8605ec58f76ae28d0030d6fc8a23f6142",
          "md5": "ae8366f44aacd3edb8c266b77389dc1f",
          "sha256": "4c9266935222d90b4ee4dd3a99ddca4ea8adfe524f783652ca4e2a1c1589f932"
        },
        "downloads": -1,
        "filename": "hoca-2021.6.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ae8366f44aacd3edb8c266b77389dc1f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 27190,
        "upload_time": "2021-06-30T07:49:02",
        "upload_time_iso_8601": "2021-06-30T07:49:02.872518Z",
        "url": "https://files.pythonhosted.org/packages/eb/22/4266b782b450d5d521f61ad534c8605ec58f76ae28d0030d6fc8a23f6142/hoca-2021.6.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f7055efc0f09cf24e3d8cb9f2b728334d856a232de39934dd518916c930b556d",
          "md5": "86de06e5000adf370c25e5601f57e5c3",
          "sha256": "264d1c0a5f5c79e028c5a2cbd452d76c5957a00db5c94dc58b7f15657acef689"
        },
        "downloads": -1,
        "filename": "hoca-2021.6.2.tar.gz",
        "has_sig": false,
        "md5_digest": "86de06e5000adf370c25e5601f57e5c3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 19884,
        "upload_time": "2021-06-30T07:49:04",
        "upload_time_iso_8601": "2021-06-30T07:49:04.706517Z",
        "url": "https://files.pythonhosted.org/packages/f7/05/5efc0f09cf24e3d8cb9f2b728334d856a232de39934dd518916c930b556d/hoca-2021.6.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.6.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "be8a252441391696610c86e313896e3f7dc7602622e2fcfa1b79e6e50f74a0d7",
          "md5": "3bb4f53458523dc122b4143d2d4ad5df",
          "sha256": "3f655e5e4629cbf31a99cd36d70f75e27ac1c1ae5591b8c59ef5f7f1f5019d83"
        },
        "downloads": -1,
        "filename": "hoca-2021.6.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3bb4f53458523dc122b4143d2d4ad5df",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 27192,
        "upload_time": "2021-06-30T17:53:18",
        "upload_time_iso_8601": "2021-06-30T17:53:18.550611Z",
        "url": "https://files.pythonhosted.org/packages/be/8a/252441391696610c86e313896e3f7dc7602622e2fcfa1b79e6e50f74a0d7/hoca-2021.6.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e0605b18924f6b8a90604874988ae952b5e665166e1e178c306a737336a6e622",
          "md5": "cc740ac7f160f8f2688c1eec55707842",
          "sha256": "8627bbb5ccf35ac51f18f252d43801d2d9649f457d4777eed6b03123912881ca"
        },
        "downloads": -1,
        "filename": "hoca-2021.6.3.tar.gz",
        "has_sig": false,
        "md5_digest": "cc740ac7f160f8f2688c1eec55707842",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 19912,
        "upload_time": "2021-06-30T17:53:19",
        "upload_time_iso_8601": "2021-06-30T17:53:19.918113Z",
        "url": "https://files.pythonhosted.org/packages/e0/60/5b18924f6b8a90604874988ae952b5e665166e1e178c306a737336a6e622/hoca-2021.6.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.7.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "281330f0445bc483d453e1ea2e02fe7dbb733b99cbf05ca477160076b4b77e84",
          "md5": "866afa022941fe0042baf1e5136590e2",
          "sha256": "81f033c8789fc70f01ba02e2e738a8bf59f6d2fc854cbf9efcbb5f84aaa14e7e"
        },
        "downloads": -1,
        "filename": "hoca-2021.7.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "866afa022941fe0042baf1e5136590e2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 30217,
        "upload_time": "2021-07-01T18:40:02",
        "upload_time_iso_8601": "2021-07-01T18:40:02.388132Z",
        "url": "https://files.pythonhosted.org/packages/28/13/30f0445bc483d453e1ea2e02fe7dbb733b99cbf05ca477160076b4b77e84/hoca-2021.7.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cc2ae5f4a9da4f2031ae8eaf913ccf29427164b941cd073dea38454e8c90dbb1",
          "md5": "45472e885266549ce3d04e7e4c71e344",
          "sha256": "07cd266a38c7eb7e36727ae98d2bc36c0dc602f3a0ec8b18b775a8014a4ee33f"
        },
        "downloads": -1,
        "filename": "hoca-2021.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "45472e885266549ce3d04e7e4c71e344",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 22622,
        "upload_time": "2021-07-01T18:40:03",
        "upload_time_iso_8601": "2021-07-01T18:40:03.680275Z",
        "url": "https://files.pythonhosted.org/packages/cc/2a/e5f4a9da4f2031ae8eaf913ccf29427164b941cd073dea38454e8c90dbb1/hoca-2021.7.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.8.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fb86501e221bc39f6c5434a662d9ec408f86eb6604bb5e4ce59cde3afddd0c30",
          "md5": "71533cb111475ab2dbd2d841eeb1f576",
          "sha256": "511ec1ac838f7ddec869e6ac0801c5f355234e8ccd6dac7adde5f4c5d504faa0"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "71533cb111475ab2dbd2d841eeb1f576",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 41187,
        "upload_time": "2021-08-27T12:25:28",
        "upload_time_iso_8601": "2021-08-27T12:25:28.859114Z",
        "url": "https://files.pythonhosted.org/packages/fb/86/501e221bc39f6c5434a662d9ec408f86eb6604bb5e4ce59cde3afddd0c30/hoca-2021.8.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f5e51099b1504d1d55380dd199720548b108b5d1e1ef1755171d111c7a365956",
          "md5": "00ec5dcc7c82de00c6ac6f6e0a109c79",
          "sha256": "b45ea00e20de148f85aa5a4b4ef1903475a963e67d0f5311abe3f4239a882968"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.0.tar.gz",
        "has_sig": false,
        "md5_digest": "00ec5dcc7c82de00c6ac6f6e0a109c79",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 40834,
        "upload_time": "2021-08-27T12:25:31",
        "upload_time_iso_8601": "2021-08-27T12:25:31.242173Z",
        "url": "https://files.pythonhosted.org/packages/f5/e5/1099b1504d1d55380dd199720548b108b5d1e1ef1755171d111c7a365956/hoca-2021.8.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.8.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d31073b83ba0192818811fcdf2182b36f93a09f584734537404a77986f1bcba5",
          "md5": "4c0f00e62d485fcb97d907e2cba5dad9",
          "sha256": "92b8df03fb54ea951e3a0015329d1babab38a9197078fd89a04af149111f895f"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4c0f00e62d485fcb97d907e2cba5dad9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 44669,
        "upload_time": "2021-08-31T15:11:58",
        "upload_time_iso_8601": "2021-08-31T15:11:58.551685Z",
        "url": "https://files.pythonhosted.org/packages/d3/10/73b83ba0192818811fcdf2182b36f93a09f584734537404a77986f1bcba5/hoca-2021.8.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9fafa1a3579f1add1b7304235e7e28b04a905fd0098e95ee66a4232456a9823b",
          "md5": "4d218c0579da4f716689fc7894b4e654",
          "sha256": "71348aae17c903e73138bb08506658351ce22298e1a3ca6b058936022ab88dc0"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "4d218c0579da4f716689fc7894b4e654",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 41524,
        "upload_time": "2021-08-31T15:12:00",
        "upload_time_iso_8601": "2021-08-31T15:12:00.681816Z",
        "url": "https://files.pythonhosted.org/packages/9f/af/a1a3579f1add1b7304235e7e28b04a905fd0098e95ee66a4232456a9823b/hoca-2021.8.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.8.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "69ebf47836635fa7c28645bc62c3499eca4c176ade859bc927f394658ad0616d",
          "md5": "eae6ee35eaac30301ccede2aa6559987",
          "sha256": "3a337641954020043185a9010d6456ab7196a6139bb2ffff2f0ad839e60a72a6"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "eae6ee35eaac30301ccede2aa6559987",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 44827,
        "upload_time": "2021-08-31T16:07:52",
        "upload_time_iso_8601": "2021-08-31T16:07:52.721523Z",
        "url": "https://files.pythonhosted.org/packages/69/eb/f47836635fa7c28645bc62c3499eca4c176ade859bc927f394658ad0616d/hoca-2021.8.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dfa33893f42ef8aa7ea64ea768afdcad46f877aebd8e29188ad584e2487efdbe",
          "md5": "fadb195a33aecfeb25b8655e4507780b",
          "sha256": "421ed504879ad45d545f1259f7832e4c79de2e66dc3b2a3ace040d0d26a73e44"
        },
        "downloads": -1,
        "filename": "hoca-2021.8.2.tar.gz",
        "has_sig": false,
        "md5_digest": "fadb195a33aecfeb25b8655e4507780b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 41761,
        "upload_time": "2021-08-31T16:07:54",
        "upload_time_iso_8601": "2021-08-31T16:07:54.223133Z",
        "url": "https://files.pythonhosted.org/packages/df/a3/3893f42ef8aa7ea64ea768afdcad46f877aebd8e29188ad584e2487efdbe/hoca-2021.8.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.9.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "03a07bd521f03a639dd2040da6da7d8876bbfce93c31ad422b8b20281218e872",
          "md5": "9e5fb73cf409ca199e3aa581db74c4b7",
          "sha256": "5b2d5bddd543130c690858c6d84b14bff15fa445fb33c789a065e968426b03ac"
        },
        "downloads": -1,
        "filename": "hoca-2021.9.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9e5fb73cf409ca199e3aa581db74c4b7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 44907,
        "upload_time": "2021-09-01T14:40:12",
        "upload_time_iso_8601": "2021-09-01T14:40:12.835948Z",
        "url": "https://files.pythonhosted.org/packages/03/a0/7bd521f03a639dd2040da6da7d8876bbfce93c31ad422b8b20281218e872/hoca-2021.9.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c9db92ca66adccac975525a5c7d51427729925db93c44dfdda658952144ccc83",
          "md5": "662fad278285b95cd06039f1e43ac81c",
          "sha256": "61bfbd21e06184d4b63e8f9272031f2b5d668275a8692ede2ba8e996d6e5984b"
        },
        "downloads": -1,
        "filename": "hoca-2021.9.0.tar.gz",
        "has_sig": false,
        "md5_digest": "662fad278285b95cd06039f1e43ac81c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 41848,
        "upload_time": "2021-09-01T14:40:14",
        "upload_time_iso_8601": "2021-09-01T14:40:14.862789Z",
        "url": "https://files.pythonhosted.org/packages/c9/db/92ca66adccac975525a5c7d51427729925db93c44dfdda658952144ccc83/hoca-2021.9.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "03a07bd521f03a639dd2040da6da7d8876bbfce93c31ad422b8b20281218e872",
        "md5": "9e5fb73cf409ca199e3aa581db74c4b7",
        "sha256": "5b2d5bddd543130c690858c6d84b14bff15fa445fb33c789a065e968426b03ac"
      },
      "downloads": -1,
      "filename": "hoca-2021.9.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "9e5fb73cf409ca199e3aa581db74c4b7",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3",
      "size": 44907,
      "upload_time": "2021-09-01T14:40:12",
      "upload_time_iso_8601": "2021-09-01T14:40:12.835948Z",
      "url": "https://files.pythonhosted.org/packages/03/a0/7bd521f03a639dd2040da6da7d8876bbfce93c31ad422b8b20281218e872/hoca-2021.9.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c9db92ca66adccac975525a5c7d51427729925db93c44dfdda658952144ccc83",
        "md5": "662fad278285b95cd06039f1e43ac81c",
        "sha256": "61bfbd21e06184d4b63e8f9272031f2b5d668275a8692ede2ba8e996d6e5984b"
      },
      "downloads": -1,
      "filename": "hoca-2021.9.0.tar.gz",
      "has_sig": false,
      "md5_digest": "662fad278285b95cd06039f1e43ac81c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3",
      "size": 41848,
      "upload_time": "2021-09-01T14:40:14",
      "upload_time_iso_8601": "2021-09-01T14:40:14.862789Z",
      "url": "https://files.pythonhosted.org/packages/c9/db/92ca66adccac975525a5c7d51427729925db93c44dfdda658952144ccc83/hoca-2021.9.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}