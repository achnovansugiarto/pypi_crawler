{
  "info": {
    "author": "Hyeonwook Kang",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Novar (v1.0)\n\nA short name for NoVariations, made to be able to detect any v4r1ati0ns in text.\n\n## Table of Contents\n1. [Introduction](#Introduction)\n2. [Installation](#Installation)\n3. [Simple Usage](#Simple-Usage)\n4. [Similarities of two strings with variations](#Text-Similarity)\n5. [Pronunciation similarities of two strings](#Pronunciation-Similarity)\n6. [Customizations](#Customizations)\n\n## Introduction\nNovar is a collection of functions that could be used for chat moderation and NLP. It is also highly customizable, allowing users to configure the functions.\n\nNovar has five functions, which are: `novar`, `compare`, `average_stuck_keyboard_enjoyer`, `text_variation`, and `pronunciation_similarity`. Besides those, there are other accessible functions which were made for the functionality of `novar`, which you can find in the source code.\n\nIf you have anything to ask me directly, e-mail me or add me on Discord at Signetar#3735\n\n\n## Installation\n\nUse the package manager [pip](https://pip.pypa.io/en/stable/) to install Novar.\n\n```bash\npip install novar\n```\n## Simple Usage\nI've combined (nearly) all functionalities of Novar to one function for accessibility.\n```python\nnovar(typed, target, groups=corresponding, softsounds=softsounds, ignored=ignored, delete_ignored=True) -> dict\n```\n### Parameters\n- *typed* : The 'typed' word. String that has variations in it.\n- *target* : The original string that consists of alphabets only. It doesn't have any variations.\n- *groups* : A list of tuples that have the same meaning in a string with variations, it's set to ```corresponding``` by default.\n- *softsounds* : A list of characters that have 'soft' sounds. This includes vowels, and it determines which characters should be removed when finding the pronunciation similarities of two strings.\n- *ignored* : A list of characters that get ignored when placed after a vowel.\n- *delete_ignored* : Whether to delete characters in `ignored` or not when determining pronunciation similarity. It's set to ```True``` by default.\n\n### Examples\n```python\nimport novar\n\none, two = \"4stat111ne33e\", \"astatine\"\nprint(novar.novar(one, two))\n```\nWhich would return:\n```\n{\n    'text_variation' : {\n        'Similarity' : 1.0\n    },\n    'pronunciation_similarity' : {\n        'Similarity' : 0,\n        'Error': 'One or more of the words contains non-alphabet characters.'\n    }\n}\n```\nAs *4stat111ne33e* is simply a variation (with a lot of special characters and spams) of *astatine*, `text_variation` is 1.0, meaning they are the same. However, as it contained special characters, `pronunciation_similarity`, a function only designed for strings that only consist of alphabets, would return an error.\n\nFor another use case:\n```python\none, two = \"accede\", \"exceed\"\nprint(novar.novar(one, two))\n```\nWould return\n```\n{\n    'text_variation' : {\n        'Similarity' : 0.0\n    },\n    'pronunciation_similarity' : {\n        'Similarity' : 1.0,\n        'Confidence' : 1.0\n    }\n}\n```\nAs *accede* and *exceed* are two different words, `text_variation` would be 0, while `pronunciation_similarity` would be 1.0 with the confidence of 1.0, as the two words are homophones.\n\n## Text Similarity\nThere are two functions to perform this task, which are `average_stuck_keyboard_enjoyer` (made by \nscreechingviolet) and `text_variation`. Keep in mind that both functions, despite working differently, can both handle recurring characters and special characters. \nThe descriptions and use cases of both functions are shown below:\n\n### `Average Stuck Keyboard Enjoyer`\nReturns True if what was typed is the target word, when recurring characters and stand-ins are disregarded. \n### Parameters\n- *typed* : The 'typed' word. String that has variations in it.\n- *target* : The original string that consists of alphabets only. It doesn't have any variations.\n- *corresponding* : A dictionary it uses to convert special characters to alphabetic characters. Set to *corresponding2* by default.\n```python\nprint(novar.average_stuck_keyboard_enjoyer('v4r14710ns', 'variations'))\n```\nWould return:\n```\nTrue\n```\n\n### `Text Variation`\nReturns a float value between 0 and 1 based on how similar `typed` is to `target`.\n### Parameters\n- *typed* : The 'typed' word. String that has variations in it.\n- *target* : The original string that consists of alphabets only. It doesn't have any variations.\n- *groups* : Set to `corresponding` by default, a group of characters that have the same meaning in a string with variations.\n```python\nprint(novar.text_variation('v4r14710ns', 'variations'))\n```\nWould return\n```\n{'Similarity': 1.0}\n```\nAnd even with recurring special characters,\n```python\nprint(novar.text_variation('v4r1ationx', 'variations'))\nprint(novar.text_variation('v4444aAar1ationx', 'variations'))\n```\nThe output would be the same.\n```\n{'Similarity': 0.9}\n{'Similarity': 0.9}\n```\n\n## Pronunciation Similarity\nAlthough there are other algorithms such as Soundex, novar presents a different method to determine how similar two strings of characters sound when pronounced.\n\n`Similarity` refers to how similar two strings sound, and `Confidence` shows how likely it is for the similarity score to be correct.\n\n### Usage\n```python\nprint(novar.pronunciation_similarity(\"masked\", \"masqued\"))\nprint(novar.pronunciation_similarity(\"cue\", \"queue\"))\n```\n```\n{'Similarity': 1.0, 'Confidence': 1.0}\n{'Similarity': 1.0, 'Confidence': 1.0}\n```\nWhat you see above are homophones, words that sound the same despite being spelt differently. Here are more examples:\n```python\nprint(novar.pronunciation_similarity(\"nature\", \"mature\"))\nprint(novar.pronunciation_similarity(\"elephant\", \"jellyfish\"))\n```\n```\n{'Similarity': 0.5, 'Confidence': 1.0}\n{'Similarity': 0.0, 'Confidence': 0.8}\n```\n### Disclaimer\nThis function is not compatible with numeric or special characters, only alphabetic. Hence, when a string with numbers of special characters is inputted, it would simply return an error.\n```python\nprint(novar.pronunciation_similarity(\"impossible\", \"3mpossible\"))\n```\n```\n{'Similarity': 0, 'Error': 'One or more of the words contains non-alphabet characters.'}\n```\nBut by using the `compare` function that comes with novar, you can try converting such characters to alphabetic characters.\n```python\nprint(novar.pronunciation_similarity(\"impossible\", \"empossible\"))\n```\n```\n{'Similarity': 1.0, 'Confidence': 1.0}\n```\n## Customizations\nNovar heavily relies on arrays of characters and nuances, and most of them were configured for general use and hence lacks accuracy in some aspects. By tweaking them to fit your needs, the functions would perform much better.\n\n### Tweaking groups for text similarity\nTwo functions that process texts with variations, `average_stuck_keyboard_enjoyer` and `text_variation`, uses **corresponding** and **corresponding2** respectavely. \n```python\ncorresponding = [\n    ('1', 'i', 'l', '!'),\n    ('2', 'r'),\n    ('3', 'e'),\n    ('4', 'a', '@'),\n    ('5', 's', '$'),\n    ('6', 'b'),\n    ('7', 't', '+'),\n    ('0', 'o'),\n    ('(', 'c')\n]\n\ncorresponding2 = {\n        'i': ['1', 'i', 'l', '!'],\n        'l': ['1', 'i', 'l', '!'],\n        'r': ['2', 'r'],\n        'e': ['3', 'e'],\n        'a': ['4', 'a', '@'],\n        's': ['5', 's', '$'],\n        'b': ['6', 'b'],\n        't': ['7', 't', '+'],\n        'o': ['0', 'o'],\n        'c': ['(', 'c']\n}\n```\nAs seen above, both work differently. For the case of ``corresponding``, elements its tuples are in the same group, and is recognised as the same character by it. Which means, *Astat1ne* and *Astatine* are the same as *1* and *i* are in the same group, and so on. In some cases, this wouldn't work very well, as *l* is also in the same group as *i*, and could lead to possible false positives.\n\nFor `corresponding2`, the value for a certain key contains a list of all the characters that could stand in for it, including the key itself.\n\n### Tweaking hardsounds, softsounds, ignored, and nuances for pronunciation similarity\n`pronunciation_similarity` function uses four arrays to determine how similar two strings sound when pronounced. This is because it first gets rid of *softsounds*, *nuances*, and *ignored* by default.\n```python\nhardsounds = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 's', 't', 'v' ,'x', 'z', 'r'] # these won't be ignored\nsoftsounds = ['a', 'e', 'i', 'o', 'u', 'y', 'w'] # these 'soft' sounds are ignored\nignored = ['w', 'h', 'r',] #if this is not placed at the start or the end, it will be deleted\n\n# These are nuances in pronunciations. Any second elements will be converted to their first elements. e.g. tia->sha, ph->f\nnuances = (\n    ('sha', 'tia'),\n    ('f', 'ph'),\n    ('c', 'k'),\n    ('c', 'q'),\n    ('u', 'oo'),\n    ('e', 'i'),\n    ('a', 'e'),\n    ('s', 'z'),\n    ('c', 'x')\n)\n```\nA string is processed using these. It is best to configure *softsounds*, *hardsounds* and *nuances* according to the words you are trying to pick up, to put more emphasis on certain characters.",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Novar",
    "package_url": "https://pypi.org/project/Novar/",
    "platform": null,
    "project_url": "https://pypi.org/project/Novar/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/Novar/1.0/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "NoVariation; detecting variations for moderation and NLP",
    "version": "1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14601964,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d407b01a401e90c014873b9423d60ab7c4f580cb6f837d317f3f5c4a1d94c943",
          "md5": "ccd6a553b973c0f40a18bd34714be1d2",
          "sha256": "dd7a517add84adac4be3e331d132d1adaa61ae232ee9f5d913a210126c8942d1"
        },
        "downloads": -1,
        "filename": "Novar-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ccd6a553b973c0f40a18bd34714be1d2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 5272,
        "upload_time": "2022-07-31T01:53:36",
        "upload_time_iso_8601": "2022-07-31T01:53:36.375352Z",
        "url": "https://files.pythonhosted.org/packages/d4/07/b01a401e90c014873b9423d60ab7c4f580cb6f837d317f3f5c4a1d94c943/Novar-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d407b01a401e90c014873b9423d60ab7c4f580cb6f837d317f3f5c4a1d94c943",
        "md5": "ccd6a553b973c0f40a18bd34714be1d2",
        "sha256": "dd7a517add84adac4be3e331d132d1adaa61ae232ee9f5d913a210126c8942d1"
      },
      "downloads": -1,
      "filename": "Novar-1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "ccd6a553b973c0f40a18bd34714be1d2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 5272,
      "upload_time": "2022-07-31T01:53:36",
      "upload_time_iso_8601": "2022-07-31T01:53:36.375352Z",
      "url": "https://files.pythonhosted.org/packages/d4/07/b01a401e90c014873b9423d60ab7c4f580cb6f837d317f3f5c4a1d94c943/Novar-1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}