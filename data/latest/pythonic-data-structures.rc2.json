{
  "info": {
    "author": "Nikolay Stanchev",
    "author_email": "nikist97.ns@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# Abstract and Tree-like Data Structures - Python\n\n**_The repository contains Python-based implementations for popular data structures._**\n\n### Installation:\nPlease use 'pip install pythonic-data-structures'.\n\n### Issues:\nPlease register any issues you find in the github repository so that they can be fixed as soon as possible.\n\n### Requirements:\nThere are no dependencies on external libraries. However, a Python 3.x version is required.\n\n### Docs:\n_Navigate to data structures:_ [Stack](#stack), [Queue](#queue), [Min Binary Heap](#minbh), \n[Max Binary Heap](#maxbh), [Priority Queue](#pq), [Duplicate Priority Queue](#dpq), [Graph](#graph)\n<br><br>\n\n\n### Data Structures\n\n**_Implementation for Stack, Queue, Max Binary Heap, Min Binary Heap, Priority Queue and Graph in Python_** <br>\n**These are located in the AbstractDataStructures.py and TreeDataStructures.py modules** <br><br>\n\n- **_Stack<a name=\"stack\"></a> (First-In-Last-Out)_** <br>\nThe Stack's implementation wraps around the python deque object, but is also generic: you can specify the type of elements \nin the stack in the constructor. If not specified, it is set to None and elements of any type can be added to the stack. The\nimplementation includes all the common operations of a stack: peek, push, pop, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Stack # import the stack data structure\n\nstack = Stack() # type is set to None, items of any types can be added\nstack = Stack(elements_type = int) # type is set to int, hence only integers can be pushed\n\nstack.size # the number of elements in the stack\nlen(stack) # same as stack.size\n\nstr(stack) # returns the string representation of the python deque object containing the elements of the stack\n\nitem = \"test_item\"\nstack.contains(item) # returns True if the item is in the stack and False otherwise\n# contains raises a StackTypeError if the type of the stack is not None and is different than the type of the parameter\nboolean = item in stack \n# same as boolean = stack.contains(item)\n\nstack.type # returns the type of the elements in the stack, None if no type is specified when initialised\n\nstack.peek() # returns the last element that was added to the stack, but doesn't remove it\n# peek returns None if there are no elements in the stack\n\nstack.pop() # same as peek(), but removes the last element that was added to the stack\n# pop raises an EmptyStackError if there are no elements in the stack\n\nelement = \"test_item\"\nstack.push(element) # pushes the element to the top of the stack\n# push raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type\n\n# the implementation includes an iterator\nfor element in stack:\n    print(element)\n# keep in mind that the iterator uses stack.pop() to get the next element, hence\n# after the iteration is over the stack would be empty\n\nstack.remove(element) # removes the element from the stack\n# raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type\n# raises a StackElementError if the stack doesn't contain the element specified as argument\n```\n\n<br> <br>\n\n- **_Queue<a name=\"queue\"></a> (First-In-First-Out)_** <br>\nThe Queue's implementation wraps around the python deque object, but is also generic: you can specify the type of elements in the queue in the constructor.\nIf not specified, it is set to None and elements of any type can be added to the queue. The\nimplementation includes all the common operations of a queue: enqueue, dequeue, peek, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Queue # import the queue data structure\nqueue = Queue() # type is set to None, items of any types can be added\nqueue = Queue(elements_type = str) # type is set to str, hence only strings can be enqueued\n\nqueue.size # the number of elements in the queue\nlen(queue) # same as queue.size\n\nstr(queue) # returns the string representation of the python deque object containing the elements of the queue\n\nitem = \"test_item\"\nqueue.contains(item) # returns True if the item is in the queue and False otherwise\n# contains raises a QueueTypeError if the type of the queue is not None and is different \n# than the type of the parameter\nboolean = item in queue \n# same as boolean = queue.contains(item)\n\nqueue.type # the type of the elements in the queue, None if no type is specified when initialised\n\nqueue.peek() # returns the first element that was added to the queue, but doesn't remove it\n# peek returns None if there are no elements in the queue\n\nqueue.dequeue() # same as peek(), but removes the first element that was added to the queue\n# dequeue raises a EmptyQueueError if there are no elements in the queue\n\nelement = \"test_element\"\nqueue.enqueue(element) # enqueues the element to the back of the queue\n# enqueue raises a QueueTypeError if the queue has a specified type for elements\n# and the argument is not of that type\n\n# the implementation includes an iterator\nfor element in queue:\n    print(element)\n# keep in mind that the iterator uses queue.dequeue() to get the next element, hence\n# after the iteration is over the queue would be empty\n\nqueue.remove(element) # removes the element from the queue\n# raises a QueueTypeError if the queue has a specified type for elements and the argument is not of that type\n# raises a QueueElementError if the queue doesn't contain the element specified as argument\n```\n\n\n<br> <br>\n\n\n- **_BinaryHeap_** <br>\nThe BinaryHeap's implementation is generic: you can specify the type of elements in the heap in the constructor. If not \nspecified, it is set to int, hence only integers can be added to the heap. The BinaryHeap class is abstract. You cannot \ninstantiate it. The implementation includes two types of heaps, which you can use: MinBinaryHeap and MaxBinaryHeap.\n<br>\n\n**MinBinaryHeap** - a heap with its root being the minimum element <br>\nMinBinaryHeap implements the common operations of a heap: add, replace_root, remove_min, peek_min, size, etc.\n\n<br>\n\n**MaxBinaryHeap** - a heap with its root being the maximum element <br>\nMaxBinaryHeap implements the common operations of a heap: add, replace_root, remove_max, peek_max, size, etc.\n\n<br>\n\nMinBinaryHeap<a name=\"minbh\"></a> _API_ : \n```python\nfrom DataStructures.AbstractDataStructures import MinBinaryHeap # import the min heap\n\nmin_heap = MinBinaryHeap() # type is set to default - int, hence only integers can be added\n# creates an empty heap\n\nmin_heap = MinBinaryHeap(str) # type is set to str, hence only strings can be added\n# creates an empty heap\n\nmin_heap.size # the number of elements in the heap\nlen(min_heap) # same as min_heap.size\n\nstr(min_heap) # returns a string of the list of elements in the heap\n\nmin_heap.type # the type of elements in the heap\n\nelement = \"test_element\"\nmin_heap.add(element) # adds the element to the min binary heap on the place it should be located\n# add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n\nmin_heap.peek_min() # returns the minimum element (the root), but doesn't remove it from the heap\n# returns None if heap is empty\n\nmin_heap.remove_min() # returns the minimum element (the root) and removes it from the heap\n# the method replaces the root with the second minimum element in the heap\n# it raises a EmptyBinaryHeapError if the heap is empty\n\n# returns the minimum element (the root) and removes it from the heap, by replacing it with the element argument\nmin_heap.replace_root(element) \n# same as min_heap.remove_min() followed by min_heap.add(element), but replace_root() is faster\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmin_heap.get_sorted_elements() # returns a list with the sorted elements from the heap, the heap remains unchanged\n# the order is ascending; returns an empty list if the heap is empty\n\n# the iterator goes through each element in the heap in ascending order\nfor element in min_heap:\n    print(element)\n# keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_min()\n# to generate the next element, hence when the iterator is finished the heap would be empty;\n# if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)\n\n# another example with the iterator\nheap_iter = iter(min_heap)\nwhile True:\n    try:\n        print(next(heap_iter))\n    except StopIteration:\n        break\nmin_heap.size # will return 0 after iteration is finished, as explained above\n\nold_element, new_element = 10, 100\nmin_heap.replace(old_element, new_element) # replaces the old element with the new element and readjusts the heap after\n# the replacement\n# raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the \n# elements in the heap\n# raises a BinaryHeapElementError if the old_element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmin_heap.remove(element)  # removes the element and readjusts the heap after deletion\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a BinaryHeapElementError if the element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n```\n\n<br>\n\nMaxBinaryHeap<a name=\"maxbh\"></a> _API_:\n```python\nfrom DataStructures.AbstractDataStructures import MaxBinaryHeap # import the max heap\n\nmax_heap = MaxBinaryHeap() # type is set to default - int, hence only integers can be added\n# creates an empty heap\n\nmax_heap = MaxBinaryHeap(str) # type is set to str, hence only strings can be added\n# creates an empty heap\n\nmax_heap.size # the number of elements in the heap\nlen(max_heap) # same as max_heap.size\n\nstr(max_heap) # returns a string of the list of elements in the heap\n\nmax_heap.type # the type of elements in the heap\n\nelement = \"test_element\"\nmax_heap.add(element) # adds the element to the max binary heap on the place it should be located\n# add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n\nmax_heap.peek_max() # returns the maximum element (the root), but doesn't remove it from the heap\n# returns None if heap is empty\n\nmax_heap.remove_max() # returns the maximum element (the root) and removes it from the heap\n# the method replaces the root with the second maximum element in the heap\n# it raises a EmptyBinaryHeapError if the heap is empty\n\n# returns the maximum element (the root) and removes it from the heap, by replacing it with the element argument\nmax_heap.replace_root(element) \n# same as max_heap.remove_max() followed by max_heap.add(element), but replace_root() is faster\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmax_heap.get_sorted_elements() # returns a list with the sorted elements from the heap, the heap remains unchanged\n# the order is descending; returns an empty list if the heap is empty\n\n# the iterator goes through each element in the heap in descending order\nfor element in max_heap:\n    print(element)\n# keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_max()\n# to generate the next element, hence when the iterator is finished the heap would be empty;\n# if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)\n\n# another example with the iterator\nheap_iter = iter(max_heap)\nwhile True:\n    try:\n        print(next(heap_iter))\n    except StopIteration:\n        break\nmax_heap.size # will return 0 after iteration is finished, as explained above\n\nold_element, new_element = 10, 100\nmax_heap.replace(old_element, new_element) # replaces the old element with the new element and readjusts the heap after\n# the replacement\n# raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the \n# elements in the heap\n# raises a BinaryHeapElementError if the old_element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmax_heap.remove(element)  # removes the element and readjusts the heap after deletion\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a BinaryHeapElementError if the element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n```\n\n\n<br> <br>\n\n- **_Priority Queue<a name=\"pq\"></a>_** <br>\nThe Priority Queue's implementation is generic: you can specify the type of elements in the queue in the constructor. \nIf not specified, it is set to None, hence objects of all types can be added to the priority queue. You can also set the reverse\nargument in the constructor. If reverse is set to False (default) the queue dequeues the element with the greatest priority, \nelse if the reverse argument is set to True - it dequeues the element with the lowest priority. The implementation includes \nall the common operations of a priority queue: enqueue, dequeue, peek, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import PriorityQueue # import the priority queue data structure\n\npriority_queue = PriorityQueue() # type is set to default None, hence objects of all types can be enqueued to the queue\n# the reverse argument is set to default False, hence dequeue returns the element with the highest priority\n\npriority_queue = PriorityQueue(elements_type=str, reverse=True) # type is set to str, hence only strings can be enqueued\n# the reverse argument is set to True, hence dequeue returns the element with the lowest priority\n\npriority_queue.size # the number of elements in the queue\nlen(priority_queue) # same as priority_queue.size\n\n\nstr(priority_queue) # returns a string of the dictionary linking priorities with elements in the queue\n\npriority_queue.type # the type of elements that can be enqueued in the priority queue\n# if this method returns None, objects of all types can be enqueued\n\npriority_queue.reversed # True if the queue dequeues the element with the lowest priority\n# returns False if the queue dequeues the element with the highest priority\n\npriority = 10\npriority_queue.contains_priority(priority) # returns True if the queue has an element linked to the given priority and False otherwise\n# contains raises a PriorityQueueTypeError if type of priority is not int\n\nelement = \"test_element\"\npriority_queue.contains_element(element) # returns True if an element is contained in the queue\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\nboolean = element in priority_queue # same as priority_queue.contains_element(element)\n\nitem = \"test_item\"\npriority_queue.enqueue(item, priority) # enqueues the given item and links it the given priority\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item\n# keep in mind that if there is another element linked to the same priority, the old element will be replaced\n# by the new element\npriority_queue.enqueue(\"first_item\", 5)\npriority_queue.enqueue(\"second_item\", 5)\n# doing this will link priority 5 to str object \"second_item\" while str object \"first_item\" will be ignored and \n# removed from the queue\n# Another thing to note is that you can enqueue the same element to different priorities\npriority_queue.enqueue(\"item\", 10)\npriority_queue.enqueue(\"item\", 11)\n\npriority_queue.peek() # returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue\n# if priority_queue.reversed is False, it returns the element with the maximum priority\n# if priority_queue.reversed is True, it returns the element with the minimum priority\n# returns None if the queue is empty\n\npriority_queue.dequeue() # same as priority_queue.peek(), but removes the returned element from the queue\n# raises a EmptyPriorityQueueError if the queue is empty \n\npriority_queue.get_element(priority) # returns the element linked to the given priority\n# returns None if no element is linked to this priority\n# raises a PriorityQueueTypeError if type(priority) is not int\n\n# the implementation includes an iterator too\nfor item in priority_queue:\n    print(item)\n# keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration \n# is finished the priority_queue will be empty\n\npriority_queue.replace_priority(element, priority) # replaces the given element's priority with the new priority argument\n# returns a boolean representing whether the element's priority has been replaced\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the element is not contained in the queue\n# if there is another element already assigned to the new priority, the old element will be replaced with the element \n# given as argument, thus the old element will be ignored and removed\n\n# you can also pass a third argument to the replace_priority method - comparison\ncomparison_type = 1\npriority_queue.replace_priority(element, priority, comparison=comparison_type)\n# returns a boolean representing whether the element's priority has been replaced\n# by doing so the priority of the element will only be replaced if a certain type of comparison between \n# the two priorities holds\n# if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority\n# if comparison is -1, the priorities will be replaced if the new priority is less than the old priority\n# if comparison is None (default), the priorities will always be replaced\n# raises ValueError if comparison is not -1, 1 or None\n\npriority_queue.remove_element(element) # finds and removes the element from the queue\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the queue doesn't contain the element\n```\n\n<br> <br>\n\n- **_Duplicate Priority Queue<a name=\"dpq\"></a>_** <br>\nThe Duplicate Priority Queue behaves exactly as the normal Priority Queue with the only difference being that it allows\nelements with duplicated priorities. This, however is not true for the normal Priority Queue, since in its implementation\nif you enqueue an element with a priority that is already linked to some old element, then the old element would be replaced\nby the new enqueued element. By using a duplicate priority queue, no elements are ignored. Instead, if you dequeue and there \nare two elements with the same priority, then they will be dequeued in the order they were enqueued.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import DuplicatePriorityQueue # import the priority queue data structure\n\nqueue = DuplicatePriorityQueue() # type is set to default None, hence objects of all types can be enqueued to the queue\n# the reverse argument is set to default False, hence dequeue returns the element with the highest priority\n\nqueue = DuplicatePriorityQueue(elements_type=str, reverse=True) # type is set to str, hence only strings can be enqueued\n# the reverse argument is set to True, hence dequeue returns the element with the lowest priority\n\nqueue.size # the number of elements in the queue, \n# elements with the same priority are NOT counted as one element, but as ordinary elements\nlen(queue) # same as queue.size\n\nstr(queue) # returns a string of the dictionary linking priorities with elements in the queue\n# keep in mind that if there is a priority linked to more than one element, the string representation will return\n# the priority linked to a Queue object\n\nqueue.type # the type of elements that can be enqueued in the priority queue\n# if this method returns None, objects of all types can be enqueued\n\nqueue.reversed # returns True if the queue dequeues the element with the lowest priority\n# returns False if the queue dequeues the element with the highest priority\n\npriority = 10\nqueue.contains_priority(priority) # returns True if the queue has an element or elements linked to the given priority and False otherwise\n# contains raises a PriorityQueueTypeError if type of priority is not int\n\nelement = \"test_element\"\nqueue.contains_element(element) # returns True if an element is contained in the queue\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\nboolean = element in queue # same as queue.contains_element(element)\n\nitem = \"test_item\"\nqueue.enqueue(item, priority) # enqueues the given item and links it the given priority\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item\n# in this implementation of a priority queue, if there is already an item with the given priority in the queue, then both \n# items will be retained and when dequeueing they will be dequeued in the order they were enqueued\nqueue.enqueue(\"first_item\", 5)\nqueue.enqueue(\"second_item\", 5)\nqueue.dequeue() # dequeues \"first_item\"\nqueue.dequeue() # dequeues \"second_item\"\n# Another thing to note is that you can enqueue the same element to different priorities\nqueue.enqueue(\"item\", 10)\nqueue.enqueue(\"item\", 11)\n\nqueue.peek() # returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue\n# if priority_queue.reversed is False, it returns the element with the maximum priority\n# if priority_queue.reversed is True, it returns the element with the minimum priority\n# returns None if the queue is empty\n# if there are more than one elements with the same priority, peek() will return the first element that was enqueued\n\nqueue.dequeue() # same as priority_queue.peek(), but removes the returned element from the queue\n# raises a EmptyPriorityQueueError if the queue is empty \n# if there are more than one elements with the same priority, dequeue() will return and remove them in the order they were\n# enqueued\n\nqueue.get_element(priority) # returns the element linked to the given priority\n# returns None if no element is linked to this priority\n# raises a PriorityQueueTypeError if type(priority) is not int\n# if there are more than one elements with the same priority, get() will return the first element that was enqueued\n\n# the implementation includes an iterator too\nfor item in queue:\n    print(item)\n# keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration \n# is finished the queue will be empty\n\nqueue.replace_priority(element, priority) # replaces the given element's priority with the new priority argument\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the element is not contained in the queue\n# in this implementation duplicated priorities are allowed, hence no elements will be ignored even if there is already\n# an element assigned to the new priority\n\n# you can also pass a third argument to the replace_priority method - comparison\ncomparison_type = 1\nqueue.replace_priority(element, priority, comparison=comparison_type)\n# by doing so the priority of the element will only be replaced if a certain type of comparison between \n# the two priorities holds\n# if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority\n# if comparison is -1, the priorities will be replaced if the new priority is less than the old priority\n# if comparison is None (default), the priorities will always be replaced\n# raises ValueError if comparison is not -1, 1 or None\n\nqueue.remove_element(element) # finds and removes the element from the queue\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the queue doesn't contain the element\n```\n\n<br> <br>\n\n- **_Graph<a name=\"graph\"></a>_** <br>\nThe graph's implementation is generic: you can specify the type of elements in the graph in the constructor. \nIf not specified, it is set to None, hence objects of all types can be added to the graph. You can also set the\ndirected, oriented and weighted arguments in the constructor if you want to have a graph with a special feature.\nBy default, those arguments are set to False. Keep in mind that you cannot initialize a graph, which is oriented and\nnot directed at the same time. <br>\nNodes of the graph are stored in a list and a set, which allows fast checking\nwhether the graph contains a certain node in cost of memory. The graph doesn't support duplicate node values <br>\nEdges of the graph are stored in a square matrix: 2-dimensional list which is resized automatically when needed. \nThe initial length of the edges list is 5. A value of None in the matrix represents the absence of an edge. If the graph\nis not weighted a value of 1 represents the presence of a node. If the graph is weighted, an edge would be represented by \nits weight in the matrix and it must be either float or int. <br>\nThe indices in the 2-dimensional list are the indices of the nodes in the list. E.g. <br> \nif the list of nodes is:\n```python\nnodes = [5.5, \"word\", 100]\n```\nand we have a non-directed and non-weighted graph with an edge between 5.5 and 100, the edges matrix will be\n```python\nedges = [\n[None, None, 1, None, None],\n[None, None, None, None, None],\n[1, None, None, None, None],\n[None, None, None, None, None],\n[None, None, None, None, None]\n]\n```\nNote the initial size of the matrix, which is 5 by 5 matrix. The indices of 5.5 and 100 in the list of nodes are 0 and 2\nrespectively and the graph is not directed. That's why edges[0][2] = edges[2][0] = 1.\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Graph # import the graph data structure\n\ngraph = Graph() # initialize a graph with None elements type, hence all types of elements can be added to the graph\n# the initialized graph is also neither directed, nor oriented, nor weighted\n\ngraph = Graph(elements_type=int, directed=True, oriented=False, weighted=True)\n# only integers can be added to the initialized graph; the graph is directed, but not oriented; the graph is also weighted\n \ngraph = Graph(elements_type=str, directed=False, oriented=True, weighted=True)\n# this raises an InvalidGraphError since a graph cannot be oriented and not directed at the same time\n\ngraph = Graph(float, True, True, True)\n# only floats can be added to the initialized graph; the graph is directed, oriented and weighted\n\ngraph.size # the number of elements in the graph\nlen(graph) # same as graph.size\n\nstr(graph) # returns a string in the format 'Graph: directed - boolean, oriented - boolean, weighted - boolean'\n\ngraph.type # the type of node values in the graph, returns None if all types of elements are allowed\n# if this method doesn't return None, only nodes of the returned type can be added to the graph\n\ngraph.directed # True if the graph is directed and False otherwise\n\ngraph.oriented # True if the graph is oriented and False otherwise\n\ngraph.weighted # True if the graph is weighted and False otherwise\n\nitem = \"test_element\"\ngraph.contains(item) # returns True if item is in the set of nodes of the graph and False otherwise\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\nboolean = item in graph # same as graph.contains(item)\n\nfirst_item = \"first_test_item\"\nsecond_item = \"second_test_item\"\ngraph.contains_edge(first_item, second_item) # returns True if an edge from first_item to second_item exists\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# if the graph is not directed the result will be the same even if you reverse the order of the arguments\n\ngraph.get_edge_weight(first_item, second_item)\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if the graph is not weighted\n# raises a GraphEdgeError if an edge between first_item and second_item doesn't exist\n# if the graph is not directed the result will be the same even if you reverse the order of the arguments\n\ngraph.nodes() # returns a deep copy of the list of nodes of the graph\n# a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list\n \ngraph.add_node(item) # adds item to the nodes of the graph if it is not already added\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises an GraphElementError if item is None\n# if item is already added as a node to the graph, the function does nothing\n\ngraph.remove_node(item) \n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises a GraphElementError if item is not a node in the graph\n# remove a node in the graph also removes all edges related to this node (going to and from this node)\n\nold_node = \"test_old_node\"\nnew_node = \"test_new_node\"\ngraph.replace_node(old_node, new_node) # replaces old_node with new_node in the graph list of nodes if possible\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if old_node is not a node the graph contains\n# raises a GraphElementError if new_node is a node the graph contains, since duplicate nodes are not allowed\n\n# the replacing of a node in the graph doesn't affect the edges in the graph, e.g.\nconnected_nodes = graph.edges_of(old_node)\ngraph.replace_node(old_node, new_node)\nnew_connected_nodes = graph.edges_of(new_node)\nprint(connected_nodes == new_connected_nodes) \n# will print True, since edges of the old node are not affected, only the value is replaced\n# the method is useful, since it retains the edges of the old node \n# and is faster than first removing the old node and then adding the new node\n\n\ngraph.edges() # returns a deep copy of the square matrix (2D list) representing the edges of the graph\n# a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list\n\ngraph.edges_of(item) # returns a list of all nodes to which there is an edge from the argument\n# returns an empty list if there are no such nodes\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises a GraphElementError if the item if not a node in the graph\n\nedge_weight = \"test_edge_weight\"\ngraph.add_edge(first_item, second_item, edge_weight) # adds an edge from first_item to second_item with the given edge_weight if appropriate\n# edge_weight should only be specified if the graph is weighted, otherwise, just skip this argument (set to None by default)\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphTypeError if edge_weight is specified and is not of type float or int\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if the graph is weighted and edge_weight is not specified or it is None\n# raises a GraphEdgeError if the graph is oriented and an edge from second_item to first_item already exists\n\ngraph.remove_edge(first_item, second_item) # removes the edge from first_item to second_item\n# if the graph is not directed, this function removes the edge from second_item to first_item too\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if there is no edge from first_item to second_item\n\n# the implementation includes an iterator too\nfor node in graph:\n    print(node)\n# the iterator goes through all nodes in the graph\n# the __iter__ method actually returns the iterator of the list of nodes of the graph\n```",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/nikist97/Python-DataStructures",
    "keywords": "data structures,data,structures,python,abstract,generic,graph,heap,queue,stack",
    "license": "Apache 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pythonic-data-structures",
    "package_url": "https://pypi.org/project/pythonic-data-structures/",
    "platform": "",
    "project_url": "https://pypi.org/project/pythonic-data-structures/",
    "project_urls": {
      "Homepage": "https://github.com/nikist97/Python-DataStructures"
    },
    "release_url": "https://pypi.org/project/pythonic-data-structures/0.2.1/",
    "requires_dist": null,
    "requires_python": ">=3",
    "summary": "Python-based implementations for many data structures.",
    "version": "0.2.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 4656729,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aae0190ec7bb6d11b612b81432568cfb70c4c94c8cfee5ba0f9b6e149821cb50",
          "md5": "a5c955985cc1594ccf3b062df5622429",
          "sha256": "dfd97a1d2f5ed752a0093f10063bd8c2e5847c4d4a1513f30149675c2ad9d2db"
        },
        "downloads": -1,
        "filename": "pythonic_data_structures-0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a5c955985cc1594ccf3b062df5622429",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 19027,
        "upload_time": "2018-06-10T18:10:20",
        "upload_time_iso_8601": "2018-06-10T18:10:20.599035Z",
        "url": "https://files.pythonhosted.org/packages/aa/e0/190ec7bb6d11b612b81432568cfb70c4c94c8cfee5ba0f9b6e149821cb50/pythonic_data_structures-0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9c926e26b280ae75a7872f6f6b5e17523842caccb45398454bcf1c9852fa815b",
          "md5": "df58085e344fecfddcd4efa275cc49b2",
          "sha256": "e64f74515fac6ef2fe184d1df649d13c9e0742dfede0ae8802be3abc3165490a"
        },
        "downloads": -1,
        "filename": "pythonic-data-structures-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "df58085e344fecfddcd4efa275cc49b2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 28242,
        "upload_time": "2018-06-10T18:10:22",
        "upload_time_iso_8601": "2018-06-10T18:10:22.378911Z",
        "url": "https://files.pythonhosted.org/packages/9c/92/6e26b280ae75a7872f6f6b5e17523842caccb45398454bcf1c9852fa815b/pythonic-data-structures-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "57e6d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb",
          "md5": "2ac2cc8c92e7edc0986986b8bca6d9d9",
          "sha256": "33003e27471daba887163bec47eba43165b1d7dfaf41310437cbd3c4b0b4eaa7"
        },
        "downloads": -1,
        "filename": "pythonic-data-structures-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2ac2cc8c92e7edc0986986b8bca6d9d9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 27621,
        "upload_time": "2019-01-03T15:16:15",
        "upload_time_iso_8601": "2019-01-03T15:16:15.213250Z",
        "url": "https://files.pythonhosted.org/packages/57/e6/d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb/pythonic-data-structures-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "57e6d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb",
        "md5": "2ac2cc8c92e7edc0986986b8bca6d9d9",
        "sha256": "33003e27471daba887163bec47eba43165b1d7dfaf41310437cbd3c4b0b4eaa7"
      },
      "downloads": -1,
      "filename": "pythonic-data-structures-0.2.1.tar.gz",
      "has_sig": false,
      "md5_digest": "2ac2cc8c92e7edc0986986b8bca6d9d9",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3",
      "size": 27621,
      "upload_time": "2019-01-03T15:16:15",
      "upload_time_iso_8601": "2019-01-03T15:16:15.213250Z",
      "url": "https://files.pythonhosted.org/packages/57/e6/d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb/pythonic-data-structures-0.2.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}