{
  "info": {
    "author": "Tomer Geva",
    "author_email": "tomerg777@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# CommDspy\nRepository for the communication signal processing package\n\nDeveloped by: Tomer Geva\n\n## Example uses:\n### Generating OSR1 and OSR `n` signal\n```python\nimport CommDspy as cdsp\nimport numpy as np\ndef tx_example():\n    # ==================================================================================================================\n    # Local variables\n    # ==================================================================================================================\n    prbs_type       = cdsp.constants.PrbsEnum.PRBS13\n    bits_per_symbol = 2\n    bit_order_inv   = False\n    inv_msb         = False\n    inv_lsb         = False\n    pn_inv          = False\n    constellation   = cdsp.constants.ConstellationEnum.PAM4\n    full_scale      = True\n    gray_coding     = False \n    poly_coeff      = cdsp.get_polynomial(prbs_type)\n    init_seed       = np.array([1] * prbs_type.value)\n    prbs_len        = 25  # can be any number\n    # ==================================================================================================================\n    # Creating reference pattern\n    # ==================================================================================================================\n    # --------------------------------------------------------------------------------------------------------------\n    # Getting PRBS binary pattern\n    # --------------------------------------------------------------------------------------------------------------\n    prbs_seq, seed_dut = cdsp.tx.prbs_gen(poly_coeff, init_seed, prbs_len * bits_per_symbol)\n    # --------------------------------------------------------------------------------------------------------------\n    # Duplicating if needed and coding\n    # --------------------------------------------------------------------------------------------------------------\n    pattern       = cdsp.tx.bin2symbol(prbs_seq, 2 ** bits_per_symbol, bit_order_inv, inv_msb, inv_lsb, pn_inv)\n    pattern       = cdsp.tx.mapping(pattern, constellation, full_scale) if not gray_coding else cdsp.tx.mapping(cdsp.tx.coding_gray(pattern, constellation), constellation, full_scale)\n\n    return pattern\n    \npattern = tx_example()\n# ==================================================================================================================\n# Pulse shaping\n# ==================================================================================================================\nrolloff     = 0.5\ntx_out_rect = cdsp.channel.pulse_shape(pattern,osr=32, span=8, method='rect')\ntx_out_sinc = cdsp.channel.pulse_shape(pattern,osr=32, span=8, method='sinc')\ntx_out_rcos = cdsp.channel.pulse_shape(pattern,osr=32, span=8, method='rcos', beta=rolloff)\ntx_out_rrc  = cdsp.channel.pulse_shape(pattern,osr=32, span=8, method='rrc', beta=rolloff)\n```\nResults:\n\n![Tx example](./pictures/tx_example.png)\n\n**Figure 1** - Simple Tx example\n\nThe pulse shaped signal can be plotted as an eye diagram as follows:\n```python\neye_d, amp_vec = cdsp.eye_diagram(tx_out_rcos, 32, 128, fs_value=3, quantization=2048, logscale=True)\n```\nThe results can be seen using `matplotlib.pyplot` functions such as `contourf`:\n![Eye_pulse_rcos_rolloff_0p5](./pictures/eye_pulse_shape_rcos_rolloff_0p5.png)\n\n**Figure 2** Eye diagram of PRBS13 after raised cosine pulse shaping with rolloff of 0.5, logscale plot\n\n![Eye_pulse_rcos_rolloff_0p5](./pictures/eye_pulse_shape_rcos_rolloff_0p9.png)\n\n**Figure 3** Eye diagram of PRBS13 after raised cosine pulse shaping with rolloff of 0.9, logscale plot\n\n## Passing a signal through channels\nThe package can be used to pass a signal through different channels\n### AWGN\nAdding white gaussian noise on top of the pulse shaping, this is done by:\n```python\nrolloff = 0.9\nsnr     = 30\npattern = tx_example()\nch_out  = cdsp.channel.awgn(pattern, osr=32, span=8, method='rcos', beta=rolloff, snr=snr)\neye_d, amp_vec = cdsp.eye_diagram(ch_out, 32, 128, fs_value=3, quantization=2048, logscale=False)\ntime_ui = np.linspace(0, 2, 256)\n```\nThe result can be shown in the form of an eye diagram:\n\n![awgn_snr30](./pictures/eye_rcos_awgn_snr30.png)\n\n**Figure 3** AWGN eye diagran, rolloff 0.9 and SNR 30 [dB]\n\n![awgn_snr10](./pictures/eye_rcos_awgn_snr10.png)\n\n**Figure 4** AWGN eye diagran, rolloff 0.9 and SNR 10 [dB]\n\n### ISI + AWGN channel\nThe ISI is given via filter parameters `a` and `b` where `b` are FIR parameters and `a` are IIR parameters.\n```python\nrolloff = 0.9\nsnr = 10\nb = [0.7]\na = [1, -0.2]\npattern = tx_example()\nch_out = cdsp.channel.awgn_channel(pattern, b, a, osr=32, span=8, method='rcos', beta=rolloff, snr=snr)\neye_d, amp_vec = cdsp.eye_diagram(ch_out, 32, 128, fs_value=3, quantization=1024, logscale=False)\n```\nThe result can be shown in the form of an eye diagram:\n\n![isi_awgn_snr30](./pictures/eye_rcos_awgn_isi_snr30.png)\n\n**Figure 3** ISI & AWGN eye diagran, rolloff 0.9 and SNR 30 [dB]\n\n![isi_awgn_snr10](./pictures/eye_rcos_awgn_isi_snr10.png)\n\n**Figure 4** ISI & AWGN eye diagran, rolloff 0.9 and SNR 10 [dB]\n\n## Digital oversampling\n```python\nimport numpy as np\nimport os\nimport CommDspy as cdsp\nimport json\n\n# ==================================================================================================================\n# Local variables\n# ==================================================================================================================\norder = 16\nbeta  = 0.5\n# ==================================================================================================================\n# Loading data\n# ==================================================================================================================\nf = open(os.path.join('..','test_data', 'example_channel_full.json'))\ndata = json.load(f)\nf.close()\nchannel             = np.array(data['channel'])\nchannel_ui          = data['channel_ui']\nchannel_sampled     = data['channel_sampled']\nosr                 = data['osr']\nch_segment          = channel[order // 2 * osr: -1*(((order // 2)-1) * osr - 1)]\n# ==================================================================================================================\n# Digital up-sampling DUT\n# ==================================================================================================================\nchannel_upsample_lag, x2, x1 = cdsp.digital_oversample(channel_sampled, osr=osr, order=order, method='lagrange')\nchannel_upsample_sinc, _, _  = cdsp.digital_oversample(channel_sampled, osr=osr, order=order, method='sinc')\nchannel_upsample_rcos, _, _  = cdsp.digital_oversample(channel_sampled, osr=osr, order=order, method='rcos', beta=beta)\n```\nResults:\n\n![channel reconstruction](./pictures/channel_reconstruction.png)\n\n**Figure 5** - channel reconstruction\n```Python\n# Sinc interpolation MSE          = -17.68 [dB]\n# Lagrange interpolation MSE      = -23.59 [dB]\n# Raised Cosine interpolation MSE = -29.84 [dB]\n```\n\n## Simple receiver model\nThe package supports simple concepts of digital processing receiver models. Example for such a receiver is given in the following:\n1. Generating PRBS13 pattern\n2. Loading the sampled channel from the above example\n3. Passing the signal through the ISI chaneel + adding noise as seen in the previous examples\n4. Defining Continuous  Time Linear Equalizer (CTLE) via zeros, poles and DC gain\n5. passing channel output through the CTLE\n6. Computing Rx Feed Forward Equalizer (FFE) and Decision Feedback Equalizer (DFE)\n7. Passing CTLE output through Rx FFE and DFE\n```python\nimport CommDspy as cdsp\nimport numpy as np\nfrom scipy import signal\nimport os\nimport json\ndef rx_example():\n    # ==================================================================================================================\n    # Tx + Channel setting\n    # ==================================================================================================================\n    prbs_type     = cdsp.constants.PrbsEnum.PRBS13\n    constellation = cdsp.constants.ConstellationEnum.PAM4\n    full_scale    = True\n    rolloff = 0.9\n    snr     = 10\n    osr     = 32\n    pattern = tx_example()\n    # ==================================================================================================================\n    # CTLE settings\n    # ==================================================================================================================\n    zeros   = [5e8, 11e9]\n    poles   = [1e9, 20e9, 25e9]\n    dc_gain = -4  # [dB]\n    fs      = 53.125e9\n    # ==================================================================================================================\n    # Rx FFE settings\n    # ==================================================================================================================\n    ffe_precursors  = 4\n    ffe_postcursors = 23\n    ffe_len         = ffe_postcursors + ffe_precursors + 1\n    dfe_taps        = 1\n    # ==================================================================================================================\n    # Loading data\n    # ==================================================================================================================\n    f = open(os.path.join('..', 'test_data', 'example_channel_full.json'))\n    data = json.load(f)\n    f.close()\n    channel_sampled = data['channel_sampled']\n    # ==================================================================================================================\n    # Passing through channel\n    # ==================================================================================================================\n    ch_out = cdsp.channel.awgn_channel(pattern, channel_sampled, [1], osr=osr, span=8, method='rcos', beta=rolloff, snr=snr)\n    ch_out = ch_out[len(channel_sampled):]\n    # ==================================================================================================================\n    # Passing through CTLE\n    # ==================================================================================================================\n    ctle_out = cdsp.rx.ctle(ch_out, zeros, poles, dc_gain, fs=fs, osr=osr)\n    # ==================================================================================================================\n    # Estimating optimal Rx FFE and passing data through\n    # ==================================================================================================================\n    ctle_out_mat = cdsp.buffer(ctle_out, osr, 0)\n    rx_ffe       = np.zeros(ffe_len)\n    err          = float('inf')\n    phase        = -1\n    for ii, sampled_phase_data in enumerate(ctle_out_mat.T):\n        rx_ffe_dfe_cand = cdsp.equalization_estimation_prbs(prbs_type, sampled_phase_data, constellation,\n                                                            prbs_full_scale=full_scale,\n                                                            ffe_postcursor=ffe_postcursors,\n                                                            ffe_precursor=ffe_precursors,\n                                                            dfe_taps=dfe_taps,\n                                                            normalize=False,\n                                                            bit_order_inv=False,\n                                                            pn_inv_precoding=False,\n                                                            gray_coded=False,\n                                                            pn_inv_postmapping=False)\n        if rx_ffe_dfe_cand[-1] < err:\n            err    = rx_ffe_dfe_cand[-1]\n            rx_ffe = rx_ffe_dfe_cand[0]\n            rx_dfe = rx_ffe_dfe_cand[1]\n            phase  = ii\n    # --------------------------------------------------------------------------------------------------------------\n    # Passing through the Rx FFE and DFE\n    # --------------------------------------------------------------------------------------------------------------\n    rx_ffe_ups   = cdsp.upsample(rx_ffe, osr)\n    rx_slicer_in = cdsp.rx.ffe_dfe(ctle_out, rx_ffe_ups, rx_dfe,levels=cdsp.get_levels(constellation, full_scale=full_scale), osr=osr, phase=phase)\n    \n    rx_slicer_in_osr1 = cdsp.rx.ffe_dfe(ctle_out_mat.T[phase], rx_ffe, rx_dfe,levels=cdsp.get_levels(constellation, full_scale=full_scale))\n    return rx_slicer_in_osr1\n```\nThe signal after passing the channel:\n\n![ch_out_snr30](./pictures/eye_ch_out_rx_example_snr30.png)\n\n**Figure 6** Channel output with SNR of 30 [dB], heavy ISI\n\n![ch_out_snr10](./pictures/eye_ch_out_rx_example_snr10.png)\n\n**Figure 6** Channel output with SNR of 10 [dB], heavy ISI\n\nFor the example above, the resulted CTLE is:\n\n![CTLE_example](./pictures/CTLE_example.png)\n\n**Figure 8** CTLE example\n\nAnd the eye diagram after the CTLE is: \n\n![CTLE_out](./pictures/eye_ctle_out_rx_example_snr30.png)\n\n**Figure 9** Eye diagram at the CTLE output\n\nWe can see that there is heavy ISI that can not be easily overcome by a CTLE alone, therefore we will use the Rx FFE. The resulting eye diagram after finding the Rx FFE:\n\n![ffe_out30](./pictures/eye_ffe_out_rx_example_snr30.png)\n\n**Figure 10** Eye diagram, FFE output with SNR of 30 [dB]\n\n![ffe_out30](./pictures/eye_ffe_out_rx_example_snr0.png)\n\n**Figure 11** Eye diagram, FFE output with SNR of 0 [dB]\n\n![ffe_out30](./pictures/eye_slicer_in_example_snr10.png)\n\n**Figure 11** Eye diagram, Slicer in (after FFE and 1 tap DFE) with SNR of 10 [dB]\n\nAnd we can see that the ISI was negated by the CTLE and FFE and DFE.\n\n## Geinie error checker\nThe package allows locking a PRBS data on the true PRBS and use that to check for errors. Example of such usage will be as follows:\n1. passing the Rx FFE result through a slicer\n2. decoding the symbols\n3. converting the symbols bacl to binary\n4. checking for errors\n```python\n# ==================================================================================================================\n# Local variables\n# ==================================================================================================================\nprbs_type       = cdsp.constants.PrbsEnum.PRBS13\nconstellation   = cdsp.constants.ConstellationEnum.PAM4\ngray_coding     = False\nfull_scale      = True\nrx_ffe_out      = rx_example()\nbits_per_symbol = 2\nbit_order_inv   = False\ninv_msb         = False\ninv_lsb         = False\npn_inv          = False\n# ==================================================================================================================\n# Slicing Rx FFE out to constellation points\n# ==================================================================================================================\nslicer_out = cdsp.rx.slicer(rx_ffe_out, levels=cdsp.get_levels(constellation, full_scale))\n# ==================================================================================================================\n# Decoding\n# ==================================================================================================================\ndecoded_dut = cdsp.rx.demapping(slicer_out, constellation) if not gray_coding else cdsp.rx.decoding_gray(cdsp.rx.demapping(slicer_out, constellation), constellation)\n# ==================================================================================================================\n# Converting to binary\n# ==================================================================================================================\nbit_vec_dut = cdsp.rx.symbol2bin(decoded_dut, 2 ** bits_per_symbol, bit_order_inv, inv_msb, inv_lsb, pn_inv)\n# ==================================================================================================================\n# Checking for errors\n# ==================================================================================================================\nlost_lock, correct_bit_count, error_bit = cdsp.rx.prbs_checker(prbs_type, bit_vec_dut, init_lock=False)\nprint(f'Lost lock: {lost_lock}')\nprint(f'Correct bit count: {correct_bit_count}')\nprint(f'Erred bits: {sum(error_bit)}')\n```\nAnd for the example above with very low noise we getzero errors since the eye is wide open, ever for SNR of 10 dB.\n```python\n# Lost lock: False\n# Correct bit count: 16294\n# Erred bits: 0\n```\nWhen Running the code for SNR of 0 [dB] we get:\n```python\n# Lost lock: False\n# Correct bit count: 16272\n# Erred bits: 22\n```\nAnd due to the high noise, the eye closed enough to generate 22 errored bits from the entire pattern we passed through the channel \n\n# Functions' Description\n## 0. Auxilliaty functions:\n### 0.1. get_polynomial\nFunction receives the PRBS type enumeration (detailed below) and returns the commonly used generating polymonial coefficients for the PRBS pattern\n### 0.2. get_levels\nFunction receives the constellation enumeration (detailed below) and returns the levels in the constellation. The function containg a \"full_scale\" flag. In case this flag is True, the levels are scaled such that random data which is coded to this constellation will have mean power of 1 (0 [dB])\n### 0.3. power\nFunction receives a signal, returns the mean power of the signal\n### 0.4. rms\nFunction receives a signal, returns the RMS of the signal\n### 0.5. buffer\nFunction receives a signal and breaks is into overlapping parts. Function is inputted with:\n* signal - Input numpy array vector to be buffered\n* length - The length of the chunks to be returned, should be a non-zero integer\n* overlap=0 - The number of overlapping symbols in the signal between each rows. Default is 0, i.e. no overlap. for values larger than 0, there will be overlap and for values smaller than 0 the following row will skip the respective number of symbols\n* delay=0 - The number of zero padding to perform over the beginning of the signal\n* clip=False - If False, padding the end of the signal with zeros such that the last row will have \"length\" length. If True, clips the data to match the length \"length\"\nFunction returns a 2D numpy array with \"length\" length rows. \n### 0.6. upsample\nFunction performs upsampling, i.e. inserting zeros between samples. Function receives the signal and the upsampling rate, returns the upsampled signal\n### 0.7. zoh\nFunction performs Zero Order Hold (ZOH) to an input signal. Function is inputted with:\n* signal - input signal\n* hold_idx - number of indices to hold\n## 1. Tx sub-package information\n### 1.1. prbs_gen\nFunction receives polynomial coefficients and an initial seed, creates binary PRBS sequences of the requested length . The function is inputted with:\n* poly_coeff - a coefficent vector for the generating polynomial of the PRBS pattern\n* init_seed - initial seed used to generate the pattern\n* output_length - wanted pattern length\n\n### 1.2. PrbsIterator\nAn iterable used to generate the next bit in the given PRBS. during initialization, a seed and the generating polynomial are given to the object. after calling iter(), next() can be used to pop the next bit in the PRBS\n\n### 1.3. bin2symbol\nFunction receives a binary sequence and computes the UNCODED symbols matching the binary sequence. The function is inputted wiith:\n* bin_mat - The binary sequence wanted to be converted \n* num_of_symbols - The number of symbols in the UNCODED pattern. NOW ONLY SUPPORTS POWERS OF 2 (2, 4, 8, ...)\n* bit_order_inv=False - Booleans stating if we want to invert the bit order (By default, MSB is the rightmost bit and the LSB is the leftmost bits)\n* inv_msb=False - Boolean stating if we want to invert the msb\n* inv_lsb=False - Boolean stating if we want to invert the lsb\n* pn_inv=False - Boolean stating if we want to invert all bits \n\n### 1.4. coding_gray\nFunction used to convert UNCODED symbols into GRAY coded symbols. Function is inputted with:\n* pattern - array of non-negative integers representing the UNCODED symbols\n* constellation=ConstellationEnum.PAM4 - chosen constellation. According to the symbol number in the constellation the GRAY coding will be done\n\n### 1.5. coding_differential\nFunction performs differential encoding. The function receives the symbols and returns the appropriate differential encoded symbols:\n* pattern - array of non-negative integers representing symbols\n* constellation=ConstellationEnum.PAM4 - chosen constellation. According to the number of symbols in the constellation the differential encoding will be done w.r.t. the modulo operation.\n\n### 1.6. coding_manchester\nFunction performs manchester encoding. Function is inputted with a binary pattern and outputs the pattern in manchester encoding. Note that the output is twice the length of the input. This requires doubling the bandwidth or slower data transfer rates due to the coding rate being 0.5\n\n### 1.7. coding_bipolar\nFunction perform bipolar encoding. Function is inputted with a binary pattern and outputs the pattern in bipolar encoding. This bipolar encoding resuces the SNR due to the addition of another level but allows slight error detection\n\n### 1.8. coding_mlt3\nFunction perform Multi-Level-Transmit 3 encoding. Function is inputted with a binary pattern and outputs the pattern in MLT-3 encoding. This encoding scheme reduces the SNR due to the introduction of a 3rd level but reduced the minimal cycle to 4 UI from 2 UI thus reduction the nyquist frequency as well. \n\n### 1.9. coding_differential_manchester\nFunction performs differential manchester encoding. Function is inputted with a binary pattern and outputs the pattern in differential manchester encoding. Note that the output is twice the length of the input. This requires doubling the bandwidth or slower data transfer rates due to the coding rate being 0.5\n\n### 1.10. mapping\nFunction used to map the symbols to their matching constellation levels . This is usually done as the last step prior to pulse shaping and transmission. Function is inputted with:\n* signal - Ihe signal to be mapped, should be UNCODED symbols array\n* constellation - The constellation we want to map to signal to\n* full_scale - Indicating if we want to use default levels such that the mean power of the signal will be 1 (0 [dB]) \n* levels=None -  Optional, if not None uses the levels given instead of the default levels\n* pn_inv=False -  Indicating if we want to invert the signal after the mapping\n\n## 2. Rx sub-package information\n### 2.1. slicer\nFunction receives data matrix from the slicer input and performs the slicing operation.\n* slicer_in_mat - Inputs to slice\n* levels=None - constellation points. The decision thresholds are at the midpoints to the constellations. If the user does not insert levels it assumes [-3,-1,1,3]\n\n### 2.2. demapping\nFunction performs de-mapping, i.e. converts the levels of the constellation to their respective integer value levels. Function is inputted with:\n* :param - Numpy array of constellation symbols.\n  * If PAM4 assuming that the constellation is [-3x,-x,x,3x]\n  * If NRZ assuming that the constellation is [-x,x]\n  * If OOK assuming that the constellation is [0, x]\n* constellation - The constellation we want to map to signal to\n* pn_inv: indicating if we want to invert the signal prior to de-mapping\n\n### 2.3. decoding_gray\nFunction receives GRAY coded symbols and performs decoding to UNCODED symbols. Function is inputted with:\n* pattern - array of non-negative integers representing the GRAY coded symbols\n* constellation=ConstellationEnum.PAM4 - chosen constellation. According to the symbol number in the constellation the GRAY decoding will be done\n\n### 2.4. decoding_differential\nFunction performs differential decoding. The function receives the coded symbols and returns the appropriate decoded symbols:\n* pattern - array of non-negative integers representing coded symbols\n* constellation=ConstellationEnum.PAM4 - chosen constellation. According to the number of symbols in the constellation the differential decoding will be done w.r.t. the modulo operation.\n\n### 2.5. decoding_manchester\nFunction perform manchester decoding. Function is inputted a binary sequence and returns the decoded bits. Note that te returned signal will have half the length of the input signal\n\n### 2.6. decoding_bipolar\nFunction performs bipolar decoding. Function is inputted with the coded levels, i.e. 0, 1, 2 and returns the decoded binary symbols in the pattern either with or without error correction\n\n### 2.7. decoding_mlt3\nFunction perform MLT-3 decoding. function receives the different levels, i.e. 0,1,2 ane returns the underlying binary symbols of the signal.\n\n### 2.8. decoding_differential_manchester\nFunction perform differential manchester decoding. Function is inputted a binary sequence and returns the decoded bits. Note that te returned signal will have half the length of the input signal\n\n### 2.9. symbol2bin\nFunction receives an UNCODED symbol sequence, returns the binary representation of the symbol sequence\n* symbol_mat - The binary sequence wanted to be converted \n* num_of_symbols - The number of symbols in the UNCODED pattern. NOW ONLY SUPPORTS 2 and 4\n* bit_order_inv=False - Booleans stating if we want to invert the bit order (By default, MSB is the rightmost bit and the LSB is the leftmost bits)\n* inv_msb=False - Boolean stating if we want to invert the msb\n* inv_lsb=False - Boolean stating if we want to invert the lsb\n* pn_inv=False - Boolean stating if we want to invert all bits\n\n### 2.10. prbs_checker\nFunction receives a slicer out capture matrix (or slicer in matrix after offine slicing) and does the following:\n1. builds a reference PRBS sequence\n2. synchronizes on the pattern\n3. checks BER\n4. returns the \"lost lock\" indication, nunber of correct bits and the vector with '0' in the correct locations, '1' in the error locations\n\nThe function is inputted with:\n* prbs_type - Enumeration stating the type of PRBS we used for the data-in\n* data_in - The data we want to check the errors on\n* init_lock - indicating if the data-in is aligned with the reference PRBS (with init seed of ones)\n* loss_th=100 - number of erred bit in the data to consider loss of PRBS lock\n\n### 2.11. prbs_ana_econ\nDoes the same as prbs_ana but, this function is more memory efficient at the cost of longer runtime\n\n### 2.12. ctle\nFunction passes an input signal through a CTLE defined via the poles, zeros and DC gain. Function is inputted with:\n* signal - input signal to pass through the CTLE\n* zeros - list of frequencies where there are zeros in [Hz]. If the given zeros are positive, multiply by -1 to enforce stability\n* poles - list of frequencies where there are poles in [Hz]. If the given poles are positive, multiply by -1 to enforce stability\n* dc_gain - gain in [dB] for the DC frequencies \n* fs - Symbol frequency, 1/Ts\n* osr - Over Sampling Rate the input signal 'sig'\n* zi - Initial condition for the CTLE, Default is None, where we start with zeros\n\n### 2.13. get_ctle_filter\nFunction computed the IIR coefficients for the digital equivalent for the CTLE defined via the zeros, poles and DC gain. Function is inputted with\n* zeros - list of frequencies where there are zeros in [Hz]. If the given zeros are positive, multiply by -1 to enforce stability\n* poles - list of frequencies where there are poles in [Hz]. If the given poles are positive, multiply by -1 to enforce stability\n* dc_gain - gain in [dB] for the DC frequencies \n* fs - Symbol frequency, 1/Ts\n* osr - Over Sampling Rate the input signal 'sig'\n\n### 2.14 ffe_dfe\nFunction passes the input signal through the FFE and DFE. Function is inputted with:\n* input_signal - input signal to pass through the FFE-DFE\n* ffe_taps - Numpy array containing the FFE taps to be used. If None, without any FFE\n* dfe_taps - Numpy array containing the DFE taps to be used. If None, without and DFE taps\n* levels - Levels used in the transmission. if None assuming levels of [-3,-1,1,3]\n* osr - Over Sampling Rate w.r.t the signal. This is needed only for the DFE buffer calculations\n* phase - Indicates at which the signal will be sampled for the DFE. Assuming that the first input is at phase 0 and there are OSR phases in total\n\nRead the respective description for further information\n\n## 3. Channel sub-package information\n### 3.0. Various pulse generators\nThe package supports all the pulses written in 3.1. The function names are:\n* rrc_pulse\n* rcos_pulse\n* sinc_pulse\n* rect_pulse\nRead the respective description for further information\n### 3.1. pulse_shape\nFunction useed to perform pulse shaping to the inputted discrete signal. Function is inputted with:\n* signal - Input signal in OSR 1 for the pulse shaping\n* osr - The wanted Over Sampling Rate after the shaping\n* span - The span of the pulse, the span is symmetrical, i.e. a span of 8 means 8 symbols back and 8 symbols forward\n* method - The shape of the pulse. can be either:\n  * 'rect' - rectangular pulse\n  * 'sinc' - sinc pulse\n  * 'rcos' - raised cosine pulse with roll-off parameter beta\n  * 'rrc' - root raised cosine pulse with rolloff parameter beta\n\nThis function simulated a perfect channel, i.e. ch[n] = delta[n] therefore at the end of the channel we only have the pulse shaping.\n\n### 3.2. awgn\nFunction that adds Additive White Gaussian Noise in a power to create a wanted SNR. Function is inputted with:\n* signal - input we and to add the AWGN to\n* snr - the SNR of the signal w.r.t the added noise\n\n### 3.3. awgn_channel\nFunction that passes a signal through a discrete-time channel and adds AWGN to the output. Function is inputted with:\n* signal - the signal we want to pass through the channel\n* b - The polynomial coefficients of the channel's nominator\n* a - The polynomial coefficients of the channel's denominator. if a[0] is not 1, all a and b coefficients are normalized by a[0]\n* snr=None - The AWGN SNR to be added to the channel output, If None, does not add noise at all\n\n## 4. Signal analysis\n\n### 4.1. channel_estimation_prbs\nFunction which performs channel estimation, assuming that the original pattern is a PRBS pattern using the get_polynomial generating polynomials. Function is inputted with:\n* prbs_type - Enumeration stating the type of PRBS used to generate the original data\n* signal - Channel output data we use to estimate the channel\n* constellation - Constellation used in the coding of the symbols\n* prbs_full_scale=False - Flag stating if the transmission has a mean power of 1 (0 [dB])\n* channel_postcursor=500 - Number of postcursors we want to use for the channel estimation\n* channel_precursor=19 - Number of precursors we want to use for the channel estimation\n* normalize=False - If ture, normalizes the channel impulse response ot have a peak value of 1\n* bit_order_inv=False -  Boolean indicating if the bit order in the signal generation is flipped\n* pn_inv_precoding=False - Boolean indicating if the P and N were flipped in the signal capture process before the coding\n* code=CodingEnum.UNCODED - Enumeration of the coding type used in the signal, taken from CommDspy.constants.CodingEnum\n* pn_inv_postcoding=False - Boolean indicating if the P and N were flipped in the signal capture process after the coding\n\nFunction returns the channel impulse response and the sum of squared residuals between the \"signal\" and the estimated channel's output\n\n### 4.2. equalization_estimation_prbs\nFunction which preform equalization over the input signal, estimation the MMSE equalizer to be used to invert the \n    ISI in the signal and recover the original data, using either an FFE or/and a DFE with controllable number of taps. Function is inputted with:\n* prbs_type- Type of PRBS used. This variable should be an enumeration from the toolbox. In the case of PRBSxQ\n                      patterns, use the bits_per_symbol to generate the pattern \n* signal - The signal we want to use to estimate the channel \n* constellation - Enumeration stating the constellation. Should be taken from CommDspy.constants.ConstellationEnum \n* ffe_postcursor: Number of postcursors in the FFE estimation                                                                                   \n* ffe_precursor: Number of precursors in the FFE estimation                                                                                     \n* dfe_taps: Number of postcursors in the DFE estimation                                                                                         \n* normalize: Boolean stating if the user wants to normalize the Rx FFE such that the peak will have value of 1                                  \n* regularization: String indicating the regularization in the computation of the equalizer. Can be either:                                      \n  * 'None' - Ordinary Least Squares (OLS) solving without regularization                                                                        \n  * 'ridge' - Applying ridge regression, L2 regularization                                                                                      \n  * 'lasso' - Applying lasso regression, L1 regularization                                                                                      \n* reg_lambda: If regularization is not 'None', and reg_lambda != 0, applies the wanted regularization with a regularization factor of reg_lambda\n\nThe Following flags are only relevant for constellation with multiple bits per symbol:\n* prbs_full_scale: Boolean stating if we want the levels to be scaled such that the mean power of the levels  at the reference pattern will be 1 (0 [dB]), i.e. that the PRBS pattern will be coded to power of 0 [dB]\n* bit_order_inv: Boolean indicating if the bit order in the signal generation is flipped. \n* pn_inv_precoding: Boolean indicating if the P and N were flipped in the signal capture process before the coding. \n* gray_coded: Boolean indicating if the signal is GRAY coded, if False, UNCODED \n* pn_inv_postcoding: Boolean indicating if the P and N were flipped in the signal capture process after the mapping.\n\nFunction returns:\n* ffe: The equalization FFE, normalized such that the cursor will have a value of 1 \n* dfe: The equalization DFE \n* dig_gain: The digital gain of the system. Note that this is highly dependant on the constellation \n* ls_err: Sum of squared residuals \n* mse: normalized MSE, meaning the MSE divided by the variance of the constellation, in dB units\n\n### 4.3. equalization_estimation\nFunction computes the linear equalizer with optimal results in the MSE sence with some regulations. The function is inputted with:\n* reference_signal - reference signal used for the equalization\n* signal - input signal we want to pass through the equalizer\n  1. signal and reference_signal MUST have the same length\n  2. signal and reference_signal MUST be synchronized\n* ffe_postcursor - Number of postcursors in the FFE estimation\n* ffe_precursor - Number of precursors in the FFE estimation\n* dfe_taps - Number of postcursors in the DFE estimation\n* normalize - Boolean stating if the user wants to normalize the Rx FFE such that the peak will have value of 1\n* regularization - String indicating the regularization in the computation of the equalizer. Can be either:\n  * 'None' - Ordinary Least Squares (OLS) solving without regularization\n  * 'ridge' - Applying ridge regression, L2 regularization\n  * 'lasso' - Applying lasso regression, L1 regularization* reg_lambda: \n* If regularization is not 'None', and reg_lambda != 0, applies the wanted regularization with a regularization factor of reg_lambda\n\n### 4.3. dig_delay_lagrange_coeffs\nFunction uses *Lagrange* interpolation polynomials to produce digital delay filter coefficients. Function is inputted with:\n* n - The order of the filter\n* alpha - the fractional delay wanted. alpha must be between 0 and 1\n* forward - Boolean stating the favorite location when the filter order is odd. If filter order is 1 then forward must be True for the function to work\n\n### 4.4. dig_delay_sinc_coeffs\nFunction uses *sinc* interpolation to produce digital delay filter coefficients. Function is inputted with:\n* n - The order of the filter\n* alpha - the fractional delay wanted. alpha must be between 0 and 1\n* forward - Boolean stating the favorite location when the filter order is odd. If filter order is 1 then forward must be True for the function to work\n\n### 4.5. dig_delay_rcos_coeffs\nFunction uses *raised cosine* interpolation to produce digital delay filter coefficients. Function is inputted with:\n* n - The order of the filter\n* alpha - the fractional delay wanted. alpha must be between 0 and 1\n* forward - Boolean stating the favorite location when the filter order is odd. If filter order is 1 then forward must be True for the function to work\n* beta - rolloff factor for the raised cosine\n\n### 4.5. digital_oversample\nFunction performs digital oversampling by applyting digital delat filters and fusing the results into 1 flattened array. Function is inputted with:\n* signal_vec - Input signal for oversampling\n* osr - Over sampling rate wanted, should be an integer\n* order - Order of the filter to be computed\n* method - the method of interpolation, can be:\n  * 'lagrange'\n  * 'sinc'\n  * 'rcos'\n* beta=0 - rolloff factor in case the method chosen is 'rcos'\n\n### 4.6. eye_diagram\nFunction computed the eye diagram of a signal. Function is inputted with:\n* signal - Input signal to plot the eye diagram\n* osr_in - Over Sampling Rate of the signal\n* osr_diag - Over Sampling used to plot the eye, if larger than `osr_in` then performing sinc interpolation \n* fs_value=1 - the limits of the eye diagram\n* quantization=256 - resolution of the amplitudes in the eye diagram is computed by: `2*fs_value / qualtization`\n* logscale=False - If True, returns the eye diagram with logscale values\n\n## 5. Misc\n### 5.1.PrbsEnum \nEnumeration for the PRBS type used\n  * PRBS7\n  * PRBS9 \n  * PRBS11\n  * PRBS13\n  * PRBS15\n  * PRBS31\n\n### 5.2. ConstellationEnum\nEnumeration for the constellations used\n  * NRZ - Non-Return to Zero, assuming constellation of [-1, 1]\n  * OOK - On Off Keying, assuming constellation of [0, 1]\n  * PAM4 - Pulse Amplitude Modulation 4, assuming constellation of [-3, -1, 1, 3]\n  \n### 5.4. EYE_COLORMAP\nA maplotlib colormap object to plot the eye diagrams\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/TomerGeva/CommDspy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "CommDspy",
    "package_url": "https://pypi.org/project/CommDspy/",
    "platform": null,
    "project_url": "https://pypi.org/project/CommDspy/",
    "project_urls": {
      "Homepage": "https://github.com/TomerGeva/CommDspy"
    },
    "release_url": "https://pypi.org/project/CommDspy/0.1.2/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "This package holds implementations for some Communication DSP methodology I found useful and informative",
    "version": "0.1.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14294503,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "670c768ee8beeb21dbb6fb3b368db830aaa6c35bf682408b13b3993f751d933e",
          "md5": "34789d1645d67b6d023bd60bc102906e",
          "sha256": "f69a5059e83d3ed3534087ae0dff4fdae71553e4ed4c6833d1820bc90c888f20"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "34789d1645d67b6d023bd60bc102906e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 56933,
        "upload_time": "2022-04-18T12:12:25",
        "upload_time_iso_8601": "2022-04-18T12:12:25.196036Z",
        "url": "https://files.pythonhosted.org/packages/67/0c/768ee8beeb21dbb6fb3b368db830aaa6c35bf682408b13b3993f751d933e/CommDspy-0.0.1-py3-none-any.whl",
        "yanked": true,
        "yanked_reason": "Primal test"
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cecb2ba7a919e5ea44f5349c32154d45ccb3feb1bcf5c8f89e91d732148c9639",
          "md5": "034d615483c47d27758fa449954d0ad9",
          "sha256": "08f1331e82fabf8177c50922bbfddbf77b323fefbd172508199221f6ecb6775d"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "034d615483c47d27758fa449954d0ad9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 58600,
        "upload_time": "2022-04-18T12:12:27",
        "upload_time_iso_8601": "2022-04-18T12:12:27.735344Z",
        "url": "https://files.pythonhosted.org/packages/ce/cb/2ba7a919e5ea44f5349c32154d45ccb3feb1bcf5c8f89e91d732148c9639/CommDspy-0.0.1.tar.gz",
        "yanked": true,
        "yanked_reason": "Primal test"
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0bbbd566a2143174cab276c6242b8224fb53862d73f06883792d855db5241888",
          "md5": "26ffe25ffd9af6127bf00b4346a8dc28",
          "sha256": "dc78245360606a0831c56cf2fc8d4539b9f78ba9772b70432b48ea2ff0686706"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "26ffe25ffd9af6127bf00b4346a8dc28",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 33812,
        "upload_time": "2022-04-19T08:37:37",
        "upload_time_iso_8601": "2022-04-19T08:37:37.205531Z",
        "url": "https://files.pythonhosted.org/packages/0b/bb/d566a2143174cab276c6242b8224fb53862d73f06883792d855db5241888/CommDspy-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8f9b1bfe40428819b361a022be3059d5ae1a0af2dae8a53cc804b1f1c85f4fd6",
          "md5": "361b5c6943242f1314b129c7bf53ef02",
          "sha256": "4164feba91b2a7c318adc7cf6291e8a9c029b23cdbf1172ea80d7d10a9db7504"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "361b5c6943242f1314b129c7bf53ef02",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 1029513,
        "upload_time": "2022-04-19T08:37:40",
        "upload_time_iso_8601": "2022-04-19T08:37:40.233724Z",
        "url": "https://files.pythonhosted.org/packages/8f/9b/1bfe40428819b361a022be3059d5ae1a0af2dae8a53cc804b1f1c85f4fd6/CommDspy-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4c4bb821a565faf472cc53ba12fb41ffbce2b4c1d06aa2fc5350d5f2612869a1",
          "md5": "7907d4345e44bf5393d3cacc4c1f6917",
          "sha256": "32761a164264968ecc0f30dce16dbb279279293040d078820d79395939b474af"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7907d4345e44bf5393d3cacc4c1f6917",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 33813,
        "upload_time": "2022-04-20T14:50:34",
        "upload_time_iso_8601": "2022-04-20T14:50:34.670267Z",
        "url": "https://files.pythonhosted.org/packages/4c/4b/b821a565faf472cc53ba12fb41ffbce2b4c1d06aa2fc5350d5f2612869a1/CommDspy-0.0.9-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "232bd4c62165bfc9c5bc9ff74859e84c630a88a74fa97c1bacd627a25b35d25b",
          "md5": "64f8adbe6186a9c6125195f6cd5f22eb",
          "sha256": "e0d15ae0c6ab68fb5a3a7bd5ed8765522df54db7ce47926164562d6b4912560e"
        },
        "downloads": -1,
        "filename": "CommDspy-0.0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "64f8adbe6186a9c6125195f6cd5f22eb",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 1029521,
        "upload_time": "2022-04-20T14:50:37",
        "upload_time_iso_8601": "2022-04-20T14:50:37.585639Z",
        "url": "https://files.pythonhosted.org/packages/23/2b/d4c62165bfc9c5bc9ff74859e84c630a88a74fa97c1bacd627a25b35d25b/CommDspy-0.0.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dce4075e7f0739d29bf983b1f8a6a4f532f1526f6f57e2e148b9bc5a7e4cd583",
          "md5": "76c01f86db37612f18611b8beb862710",
          "sha256": "b56af016e544c24ece2761a4cf170963ae90f172fcbb87aa90f78188915b18dd"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "76c01f86db37612f18611b8beb862710",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 36595,
        "upload_time": "2022-04-27T07:34:14",
        "upload_time_iso_8601": "2022-04-27T07:34:14.544695Z",
        "url": "https://files.pythonhosted.org/packages/dc/e4/075e7f0739d29bf983b1f8a6a4f532f1526f6f57e2e148b9bc5a7e4cd583/CommDspy-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "791c9e7760116dbc443ddafd22b95e45becd366ea4cd108ff1a1395c1eb848b7",
          "md5": "bd90ecc2fd4271ef757bac013cd3a697",
          "sha256": "c39cd3aabb561006cc66e7378bcf40622f702bd1760ab07c3471436d46a446bc"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "bd90ecc2fd4271ef757bac013cd3a697",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 1038392,
        "upload_time": "2022-04-27T07:34:17",
        "upload_time_iso_8601": "2022-04-27T07:34:17.172555Z",
        "url": "https://files.pythonhosted.org/packages/79/1c/9e7760116dbc443ddafd22b95e45becd366ea4cd108ff1a1395c1eb848b7/CommDspy-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7be8ef22708d58c6ddc77f22f9ba8ae79dd004d9ebebede85bc8f9a4070b487b",
          "md5": "21633fdff1e7467d87f7ebeff3c33bfe",
          "sha256": "5c8ad8d1a0f7f2389ee7dcd5572a6c349c8c43fad2a12b85b1a38d3a27308036"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "21633fdff1e7467d87f7ebeff3c33bfe",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 37924,
        "upload_time": "2022-05-01T13:30:38",
        "upload_time_iso_8601": "2022-05-01T13:30:38.100812Z",
        "url": "https://files.pythonhosted.org/packages/7b/e8/ef22708d58c6ddc77f22f9ba8ae79dd004d9ebebede85bc8f9a4070b487b/CommDspy-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "52d4addae86af4fc9ebaee455e2e58450ae0a83ea5fa629184d92524f7bb6d0b",
          "md5": "2c2c46520f136ac0afbfd2d0fc9d1bf9",
          "sha256": "4062a2cd0e6b10b879f35d7798f098e2528e78e40e8d46ef891f6bb28bef5aeb"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2c2c46520f136ac0afbfd2d0fc9d1bf9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 1040565,
        "upload_time": "2022-05-01T13:31:04",
        "upload_time_iso_8601": "2022-05-01T13:31:04.542267Z",
        "url": "https://files.pythonhosted.org/packages/52/d4/addae86af4fc9ebaee455e2e58450ae0a83ea5fa629184d92524f7bb6d0b/CommDspy-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aeee77d5b2b60ab282d5478b5643eef251c97ffa33e66d1609238c787f5b1c21",
          "md5": "ca4f3fdb60827b9818984915a1bb6427",
          "sha256": "851dc79b2bb74abc323b2799e8b888337f0180c7fbbf8d0d93ca0b10b855d3e5"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ca4f3fdb60827b9818984915a1bb6427",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 40023,
        "upload_time": "2022-06-30T09:53:05",
        "upload_time_iso_8601": "2022-06-30T09:53:05.535088Z",
        "url": "https://files.pythonhosted.org/packages/ae/ee/77d5b2b60ab282d5478b5643eef251c97ffa33e66d1609238c787f5b1c21/CommDspy-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8d96aff4ceba37c4c45e9aa60fc0a7f9fe2fed27a1180210e2a4b024489d20ba",
          "md5": "7fd56b8df47c20d84cdf4f13435d3f7f",
          "sha256": "f12923f1067991d12c2a6d6c7c01205ee1abfe3385d3437fd4cc95a05432cbd2"
        },
        "downloads": -1,
        "filename": "CommDspy-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "7fd56b8df47c20d84cdf4f13435d3f7f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 1100425,
        "upload_time": "2022-06-30T09:53:08",
        "upload_time_iso_8601": "2022-06-30T09:53:08.466395Z",
        "url": "https://files.pythonhosted.org/packages/8d/96/aff4ceba37c4c45e9aa60fc0a7f9fe2fed27a1180210e2a4b024489d20ba/CommDspy-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "aeee77d5b2b60ab282d5478b5643eef251c97ffa33e66d1609238c787f5b1c21",
        "md5": "ca4f3fdb60827b9818984915a1bb6427",
        "sha256": "851dc79b2bb74abc323b2799e8b888337f0180c7fbbf8d0d93ca0b10b855d3e5"
      },
      "downloads": -1,
      "filename": "CommDspy-0.1.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "ca4f3fdb60827b9818984915a1bb6427",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 40023,
      "upload_time": "2022-06-30T09:53:05",
      "upload_time_iso_8601": "2022-06-30T09:53:05.535088Z",
      "url": "https://files.pythonhosted.org/packages/ae/ee/77d5b2b60ab282d5478b5643eef251c97ffa33e66d1609238c787f5b1c21/CommDspy-0.1.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8d96aff4ceba37c4c45e9aa60fc0a7f9fe2fed27a1180210e2a4b024489d20ba",
        "md5": "7fd56b8df47c20d84cdf4f13435d3f7f",
        "sha256": "f12923f1067991d12c2a6d6c7c01205ee1abfe3385d3437fd4cc95a05432cbd2"
      },
      "downloads": -1,
      "filename": "CommDspy-0.1.2.tar.gz",
      "has_sig": false,
      "md5_digest": "7fd56b8df47c20d84cdf4f13435d3f7f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 1100425,
      "upload_time": "2022-06-30T09:53:08",
      "upload_time_iso_8601": "2022-06-30T09:53:08.466395Z",
      "url": "https://files.pythonhosted.org/packages/8d/96/aff4ceba37c4c45e9aa60fc0a7f9fe2fed27a1180210e2a4b024489d20ba/CommDspy-0.1.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}