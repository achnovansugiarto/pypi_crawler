{
  "info": {
    "author": "Ralf Schlatterbeck",
    "author_email": "rsc@runtux.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Other Audience",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python"
    ],
    "description": "MININEC in Python\n=================\n\n:Author: Ralf Schlatterbeck <rsc@runtux.com>\n\n.. |--| unicode:: U+2013   .. en dash\n.. |__| unicode:: U+2013   .. en dash without spaces\n    :trim:\n.. |_| unicode:: U+00A0 .. Non-breaking space\n    :trim:\n.. |-| unicode:: U+202F .. Thin non-breaking space\n    :trim:\n.. |numpy.linalg.solve| replace:: ``numpy.linalg.solve``\n\nThis is an attempt to rewrite the original MININEC3 basic sources in\nPython. Standard use-case like computation of feed impedance and far\nfield are implemented and are quite well tested. There is only a command\nline interface.\n\nAn example of using the command-line interface uses the following\n12-element Yagi/Uda antenna originally presented by Cebik [6]_ without\nthe resistive element loading and with slight corrections to the element\nlengths to make the antenna symmetric (the errors in the display in\nCebik's article may be due to a display issue of the program used that\ndisplays negative numbers with less accuracy than positive numbers).\nYou can get further help by calling ``pymininec`` with the ``--help``\noption.  The command-line options for the 12-element antenna example\n(also available in the file ``test/12-el.pym``) are::\n\n    pymininec -f 148 \\\n    -w 22,-.51943,0.00000,0,.51943,0.00000,0,.00238 \\\n    -w 22,-.50165,0.22331,0,.50165,0.22331,0,.00238 \\\n    -w 22,-.46991,0.34215,0,.46991,0.34215,0,.00238 \\\n    -w 22,-.46136,0.64461,0,.46136,0.64461,0,.00238 \\\n    -w 22,-.46224,1.03434,0,.46224,1.03434,0,.00238 \\\n    -w 22,-.45989,1.55909,0,.45989,1.55909,0,.00238 \\\n    -w 22,-.44704,2.19682,0,.44704,2.19682,0,.00238 \\\n    -w 22,-.43561,2.94640,0,.43561,2.94640,0,.00238 \\\n    -w 22,-.42672,3.72364,0,.42672,3.72364,0,.00238 \\\n    -w 22,-.41783,4.53136,0,.41783,4.53136,0,.00238 \\\n    -w 22,-.40894,5.33400,0,.40894,5.33400,0,.00238 \\\n    -w 22,-.39624,6.0452,0,.39624,6.0452,0,.00238 \\\n    --theta=0,5,37 --phi=0,5,73 \\\n    --excitation-segment=33 > 12-el.pout\n\nUsers on Linux can run this using (I'm sure Windows users can come up\nwith a similar command-line on Windows)::\n\n    pymininec $(cat test/12-el.pym) > 12-el.pout\n\nThe resulting output file contains currents, impedance at the feedpoint\nand antenna far field in dBi as tables. The output tries to reproduce\nthe format of the original Basic implementation of Mininec.\n\nPlotting\n--------\n\nThe output tables produced by ``pymininec``\nare not very useful to get an idea of the far field behaviour of\nan antenna. Therefore there is a small companion program ``plot-antenna``\nthat can plot the antenna pattern. The default is to plot all available\ngraphics, including an interactive 3d view. In addition with the\n``--azimuth`` or ``--elevation`` options you can get an Azimuth\ndiagram::\n\n    plot-antenna --azimuth test/12-el-1deg.pout\n\n.. figure:: https://raw.githubusercontent.com/schlatterbeck/pymininec/master/test/12-el-azimuth.png\n    :align: center\n\nor an elevation diagram::\n\n    plot-antenna --elevation test/12-el-1deg.pout\n\n.. figure:: https://raw.githubusercontent.com/schlatterbeck/pymininec/master/test/12-el-elevation.png\n    :align: center\n\nrespectively. Note that I used an output file with 1-degree resolution\nin elevation and azimuth angles not with 5 degrees as in the example\nabove. The pattern look smoother but a 3D-view will be very slow due to\nthe large number of points. The plot program also has a ``--help``\noption for further information. In particular the scaling of the antenna\nplot can be ``linear``, ``linear_db``, and ``linear_voltage`` in\naddition to the default of ``arrl`` scaling. You may consult Cebik's [6]_\narticle for explanation of the different diagrams.\n\nThe latest version accepts several plot parameters, ``--elevation``,\n``--azimuth``, ``--plot3d``, ``--plot-vswr`` which are plotted into one\ndiagram. The default is to plot all four graphs. With the ``--output``\noption pictures can directly be saved without displaying the graphics on\nthe screen.\n\nThe plot program can also display output files of ``nec2c``, not only\nfrom ``pymininec``.\n\nThe latest version has key-bindings for scrolling through the\nfrequencies of an antenna simulation. So if you have an output file with\na simulation of multiple frequencies (either with ``pymininec`` or\n``nec2c``) you can display diagrams for the next frequency by typing\n``+``, and to the previous frequency by typing ``-``. For newer versions\nof ``matplotlib`` you can display a scrollbar for the frequencies with\nthe ``--with-slider`` option.\n\nOther keybindings switch the scaling for the antenna plots, ``a``\nswitches to ``arrl`` scaling, ``l`` switches to linear scaling, ``d``\nswitches to linear dB scaling, and ``v`` switches to linear voltage\nscaling.\n\nFinally the ``w`` option toggles display of the 3d diagram from/to\nwireframe display. Note that the wireframe display may not be supported\non all versions of ``matplotlib`` and/or graphics cards.\n\nTest coverage: Making sure it is consistent with original Mininec\n-----------------------------------------------------------------\n\nThere are several tests against the `original Basic source code`_, for\nthe test cases see the subdirectory ``test``. One of the test cases is\na simple 7MHz wire dipole with half the wavelength and 10 segments.\nIn one case the wire is 0.01m (1cm) thick, we use such a thick wire to\nmake the mininec code work harder because it cannot use the thin wire\nassumptions. Another test is for the thin wire case. Also added are the\ninverted-L and the T antenna from the original Mininec reports. All\nthese may also serve as examples.  Tests statement coverage is currently\nat 100%.\n\nThere is a line that is flagged as not covered by the ``pytest``\nframework if the Python version is below 3.10. This is a ``continue``\nstatement in ``compute_impedance_matrix`` near the end (as of this\nwriting line 1388). This is a bug in Python in versions below 3.10:\nWhen setting a breakpoint in the python debugger on the continue\nstatement, the breakpoint is never reached although the continue\nstatement is correctly executed. A workaround would be to put a dummy\nassignment before the continue statement and verify the test coverage\nnow reports the continue statement as covered.\nI've `reported this as a bug in the pytest project`_ and `as a bug in\npython`_, the bugs are closed now because Python3.9 does no longer get\nmaintenance.\n\nFor all the test examples it was carefully verified that the results are\nclose to the original results in Basic (see `Running examples in Basic`_\nto see how you can run the original Basic code in the 21th century). The\ndifferences are due to rounding errors in the single precision\nimplementation in Basic compared to a double precision implementation in\nPython. I'm using numeric code from `numpy`_ where possible to speed up\ncomputation, e.g. solving the impedance matrix is done using\n|numpy.linalg.solve|_ instead of a line-by-line translation from Basic.\nYou can verify the differences yourself. In the ``test`` directory there\nare input files with extension ``.mini`` which are intended (after\nconversion to carriage-return convention) to be used as input to the\noriginal Basic code. The output of the Basic code is in files with the\nextension ``.bout`` while the output of the Python code is in files\nwith the extension ``.pout``. The ``.pout`` files are compared in the\nregression tests. The ``.pym`` files in the ``test`` directory are the\ncommand-line arguments to recreate the ``.pout`` files with\n``mininec.py``.\n\nIn his thesis [5]_, Zeineddin investigates numerical instabilities when\ncomparing near and far field. He solves this by doing certain\ncomputations for the near field in double precision arithmetics.\nI've tried to replicate these experiments and the numerical\ninstabilities are reproduceable in the Basic version. In the Python\nversion the instabilities are not present (because everything is in\ndouble precision). But the absolute field values computed in Python are\nlower than the ones reported by Zeineddin (and the Basic code *does*\nreproduce Zeineddins values).\n\nIt doesn't look like there is a problem in the computations of the\ncurrents in the Python code, the computed currents are lower than in\nBasic which leads to lower field values. But the computed impedance\nmatrix when comparing both versions has very low error, see the test\n``test_matrix_fill_ohio_example`` in ``test/test_mininec.py`` and the\nroutine ``plot_z_errors`` to plot the errors (in percent) in\n``test/ohio.py``. Compared to the values computed by NEC [5]_, the Basic\ncode produces slightly higher values for near and far field while the\nPython code produces slightly lower values than NEC. I've not tried to\nsimulate this myself in NEC yet.\n\nYou can find the files in\n``test/ohio*`` (the thesis was at Ohio University). This time there is a\npython script ``ohio.py`` to compute the near and far field values\nwithout recomputing the impedance matrix. This script can show the near\nand far field values in a plot and the difference in a second plot.\nThere are two distances for which these are computed, so the code\nproduces four plots. There is a second script to plot the Basic near and\nfar field differences ``plot_bas_ohio.py``.\n\nThe current Python code is still hard to understand |--| it's the\nresult of a line-by-line translation from Basic, especially where I\ndidn't (yet) understand the intention of the code. The same holds for\nVariable names which might not (yet) reflect the intention of the code.\nI *did* move things like computation of the angle of a complex number,\nor the computation of the absolute value, or multiplication/division of\ncomplex numbers to the corresponding complex arithmetic in python where\nI detected the pattern.\n\nSo the *de-spaghettification* was not successful in some parts of the\ncode yet :-) My notes from the reverse-engineering can be found in the\nfile ``basic-notes.txt`` which has explanations of some of the variables\nused in mininec and some sub routines with descriptions (mostly taken\nfrom ``REM`` statements) of the Basic code.\n\nThe code is also still quite slow: An example of a 12 element Yagi/Uda\nantenna used in modeling examples by Cebik [6]_ takes about 50 seconds\non my PC (this has 264 segments, more than the original Mininec ever\nsupported) when I'm using 5 degree increments for theta and phi angles\nand about 11 minutes (!) for 1 degree angles. The reason is that\neverything currently is implemented (like in Basic) as nested loops.\nThis could (and should) be changed to use vector and matrix operations\nin `numpy`_. In the inner loop of the matrix fill operation there are\nseveral integrals computed using `gaussian quadrature`_ or a numeric\nsolution to an `elliptic integral`_. These could be implemented by\nscipy_ library functions.\n\nNotes on Elliptic Integral Parameters\n-------------------------------------\n\nThe Mininec code uses the implementation of an elliptic integral when\ncomputing the impedance matrix and in several other places. The integral\nuses a set of E-vector coefficients that are cited differently in\ndifferent places. In the latest version of the open source Basic code\nthese parameters are in lines 1510 |__| 1512. They are also\nreprinted in the publication [2]_ about that version of Mininec which\nhas a listing of the Basic source code (slightly different from the\nversion available online) where it is on p. |-| C-31 in lines\n1512 |__| 1514.\n\n+---------------+--------------+--------------+--------------+--------------+\n| 1.38629436112 | .09666344259 | .03590092383 | .03742563713 | .01451196212 |\n+---------------+--------------+--------------+--------------+--------------+\n|            .5 | .12498593397 | .06880248576 | .0332835346  | .00441787012 |\n+---------------+--------------+--------------+--------------+--------------+\n\nIn one of the first publications on Mininec [1]_ the authors give the\nparameters on p. |-| 13 as:\n\n+---------------+--------------+--------------+--------------+--------------+\n| 1.38629436112 | .09666344259 | .03590092383 | .03742563713 | .01451196212 |\n+---------------+--------------+--------------+--------------+--------------+\n|            .5 | .1249859397  | .06880248576 | .03328355346 | .00441787012 |\n+---------------+--------------+--------------+--------------+--------------+\n\nThis is consistent with the later Mininec paper [2]_ on version |-| 3 of\nthe Mininec code on p. |-| 9, but large portions of that paper are copy\n& paste from the earlier paper.\n\nThe first paper [1]_ has a listing of the Basic code of that version and\non p.  |-| 48 the parameters are given as:\n\n+---------------+--------------+--------------+--------------+--------------+\n| 1.38629436    | .09666344    | .03590092    | .03742563713 | .01451196    |\n+---------------+--------------+--------------+--------------+--------------+\n|            .5 | .12498594    | .06880249    | .0332836     | .0041787     |\n+---------------+--------------+--------------+--------------+--------------+\n\nIn each case the first line are the *a* parameters, the second line are\nthe *b* parameters. The *a* parameters are consistent in all versions\nbut notice how in the *b* parameters (2nd line) the current Basic code\nhas one more *3* in the second column. The rounding of the earlier Basic\ncode suggests that the second *3* is a typo in the later Basic version.\nAlso notice that in the 4th column the later Basic code has a *5* less\nthan the version in the papers. The rounding in the earlier Basic code\nalso suggests that the later Basic code is in error.\n\nThe errors in the elliptic integral parameters do not have much effect\non the computed values of the Mininec code. There are some minor\ndifferences but these are below the differences between Basic and Python\nimplementation (single vs. double precision arithmetics). I had hoped\nthat this has something to do with the well known fact that Mininec\nfinds a resonance point of an antenna some percent too high which means\nthat usually in practice the computed wire lengths are a little too\nlong. This is apparently not the case. The resonance point is also wrong\nfor very thin wires below the *small radius modification condition*\nwhich happens when the wire radius is below 1e-4 of the wavelength.\nEven in that case --  where the elliptic integral is not used -- the\nresonance is slightly wrong.\n\nThe reference for the elliptic integral parameters [3]_ cited in both\nreports lists the following table on p. |-| 591:\n\n+---------------+--------------+--------------+--------------+--------------+\n| 1.38629436112 | .09666344259 | .03590092383 | .03742563713 | .01451196212 |\n+---------------+--------------+--------------+--------------+--------------+\n|            .5 | .12498593597 | .06880248576 | .03328355346 | .00441787012 |\n+---------------+--------------+--------------+--------------+--------------+\n\nNote that I could only locate the 1972 version of the Handbook, not the\n1980 version cited by the reports. So there is a small chance that these\nparameters were corrected in a later version. It turns out that the\nreports are correct in the fourth column and the Basic program is wrong.\nBut the second column contains still *another* version, note that there\nis a *5* in the 9th position after the comma, not a *3* like in the\nBasic program and not a missing digit like in the Mininec reports [1]_\n[2]_.\n\nSince I could not be sure that there was a typo in the handbook [3]_, I\ndug deeper: The handbook cites *Approximations for Digital Computers* by\nHastings (without giving a year) [4]_. The version of that book I found\nis from 1955 and lists the coefficients on p. |-| 172:\n\n+---------------+--------------+--------------+--------------+--------------+\n| 1.38629436112 | .09666344259 | .03590092383 | .03742563713 | .01451196212 |\n+---------------+--------------+--------------+--------------+--------------+\n|            .5 | .12498593597 | .06880248576 | .03328355346 | .00441787012 |\n+---------------+--------------+--------------+--------------+--------------+\n\nSo apparently the handbook [3]_ is correct. And the Basic version and\n*both* Mininec reports have at least one typo.\n\nRunning examples in Basic\n-------------------------\n\nThe original Basic source code can still be run today, thanks to Rob\nHagemans `pcbasic`_ project. It is written in Python and can be\ninstalled with pip. It is also packaged in some Linux distributions,\ne.g. in Debian_.\n\nSince Mininec reads all inputs for an antenna simulation from the\ncommand-line in Basic, I'm creating input files that contain\nreproduceable command-line input for an antenna simulation. An example\nof such a script is in ``dipole-01.mini``, the suffix ``mini``\nindicating a Mininec file.\n\nOf course the input files only make sense if you actually run them with\nthe mininec basic code as this displays all the prompts.\nNote that I had to change the dimensions of some arrays in the Basic\ncode to not run into an out-of-memory condition with the Basic\ninterpreter.\n\nYou can run `pcbasic`_ with the command-line option ``--input=`` to specify\nan input file. Note that the input file has to be converted to carriage\nreturn line endings (no newlines). I've described how I'm debugging the\nBasic code using the Python debugger in a `contribution to pcbasic`_,\nthis has been moved to the `pcbasic wiki`_.\n\nIn the file ``debug-basic.txt`` you can find my notes on how to debug\nmininec using the python debugger. This is more or less a random\ncut&paste buffer.\n\nThe `original basic source code`_ can be obtained from the `unofficial\nNEC archive`_ by PA3KJ or from a `Mininec github project`_, I'm using\nthe version from the `unofficial NEC archive`_ and have not verified if\nthe two links I've given contain the same code.\n\n.. _`original basic source code`: http://nec-archives.pa3kj.com/mininec3.zip\n.. _`unofficial NEC archive`: http://nec-archives.pa3kj.com/\n.. _`Mininec github project`: https://github.com/Kees-PA3KJ/MiniNec\n.. _`numpy`: https://numpy.org/\n.. _`pcbasic`: https://github.com/robhagemans/pcbasic\n.. _`Debian`: https://packages.debian.org/stable/python3-pcbasic\n.. _`contribution to pcbasic`: https://github.com/robhagemans/pcbasic/pull/183\n.. _`pcbasic wiki`:\n    https://github.com/robhagemans/pcbasic/wiki/Debugging-Basic-with-the-Python-Debugger\n\n.. [1] Alfredo J. Julian, James C. Logan, and John W. Rockway.\n    Mininec: A mini-numerical electromagnetics code. Technical Report\n    NOSC TD 516, Naval Ocean Systems Center (NOSC), San Diego,\n    California, September 1982. Available as ADA121535_ from the Defense\n    Technical Information Center.\n.. [2] J. C. Logan and J. W. Rockway. The new MININEC (version |-| 3): A\n    mini-numerical electromagnetic code. Technical Report NOSC TD 938,\n    Naval Ocean Systems Center (NOSC), San Diego, California, September\n    1986. Available as ADA181682_ from the Defense Technical Information\n    Center. Note: The scan of that report is *very* bad. If you have\n    access to a better version, please make it available!\n.. [3] Milton Abramowitz and Irene A. Stegun, editors. Handbook of\n    Mathematical Functions With Formulas, Graphs, and Mathematical\n    Tables.  Number 55 in Applied Mathematics Series.  National Bureau\n    of Standards, 1972.\n.. [4] Cecil Hastings, Jr. Approximations for Digital Computers.\n    Princeton University Press, 1955.\n.. [5] Rafik Paul Zeineddin. Numerical electromagnetics codes: Problems,\n    solutions and applications. Master’s thesis, Ohio University, March 1993.\n    Available from the `OhioLINK Electronic Theses & Dissertations Center`_\n.. [6] L. B. Cebik. Radiation plots: Polar or rectangular; log or linear.\n    In Antenna Modeling Notes [7], chapter 48, pages 366–379. Available\n    in Cebik's `Antenna modelling notes episode 48`_\n.. [7] L. B. Cebik. Antenna Modeling Notes, volume 2. antenneX Online\n    Magazine, 2003. Available with antenna models from the `Cebik\n    collection`_.\n\n.. _ADA121535: https://apps.dtic.mil/sti/pdfs/ADA121535.pdf\n.. _ADA181682: https://apps.dtic.mil/sti/pdfs/ADA181682.pdf\n.. _`numpy.linalg.solve`:\n    https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html\n.. _`OhioLINK Electronic Theses & Dissertations Center`:\n    https://etd.ohiolink.edu/apexprod/rws_etd/send_file/send?accession=ohiou1176315682\n.. _`reported this as a bug in the pytest project`:\n    https://github.com/pytest-dev/pytest/issues/10152\n.. _`as a bug in python`:\n    https://github.com/python/cpython/issues/94974\n.. _`Cebik collection`:\n    http://on5au.be/Books/allmodnotes.zip\n.. _`Antenna modelling notes episode 48`:\n    http://on5au.be/content/amod/amod48.html\n.. _`gaussian quadrature`: https://en.wikipedia.org/wiki/Gaussian_quadrature\n.. _`elliptic integral`: https://en.wikipedia.org/wiki/Elliptic_integral\n.. _`scipy`: https://scipy.org/",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/schlatterbeck/pymininec",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pymininec",
    "package_url": "https://pypi.org/project/pymininec/",
    "platform": "Any",
    "project_url": "https://pypi.org/project/pymininec/",
    "project_urls": {
      "Homepage": "https://github.com/schlatterbeck/pymininec"
    },
    "release_url": "https://pypi.org/project/pymininec/0.3.0/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Python version of the original MININEC Antenna Optimization code",
    "version": "0.3.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14699948,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "afcbf365ffdc48db0557eb6f06639e98e9e2f41662ff1eed8c37a03cadbecfde",
          "md5": "605a18e763dfdc7da5752eb646f95bcd",
          "sha256": "9f1fc920e0b67cb6663de57a9217a1ec93cb35a30b24cc4d1a87d5fce5e9dc4e"
        },
        "downloads": -1,
        "filename": "pymininec-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "605a18e763dfdc7da5752eb646f95bcd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 54130,
        "upload_time": "2022-07-19T11:41:26",
        "upload_time_iso_8601": "2022-07-19T11:41:26.602751Z",
        "url": "https://files.pythonhosted.org/packages/af/cb/f365ffdc48db0557eb6f06639e98e9e2f41662ff1eed8c37a03cadbecfde/pymininec-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "332681b485626dcd8537746eff5c5b42405710d5262e09d49ac1295ad83a28ed",
          "md5": "f960d39d13c3c20f1c3d10aa22c04787",
          "sha256": "44382bf6c997b37acf44a89efdea71d4d9a02bb64c7fdce297f40810ff4f4726"
        },
        "downloads": -1,
        "filename": "pymininec-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f960d39d13c3c20f1c3d10aa22c04787",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 57073,
        "upload_time": "2022-07-20T17:21:22",
        "upload_time_iso_8601": "2022-07-20T17:21:22.076452Z",
        "url": "https://files.pythonhosted.org/packages/33/26/81b485626dcd8537746eff5c5b42405710d5262e09d49ac1295ad83a28ed/pymininec-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3cd778df73271342afbb07fbe3b76d303e5cc00b4cd95700fef5e355ac4e9126",
          "md5": "a140955200ac95db18654d7df5bc2d0c",
          "sha256": "c0454d6da73edc2ce5fe4cb76c12233a74720087274e2b059543ca5149a33e29"
        },
        "downloads": -1,
        "filename": "pymininec-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a140955200ac95db18654d7df5bc2d0c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60403,
        "upload_time": "2022-08-09T08:33:10",
        "upload_time_iso_8601": "2022-08-09T08:33:10.105825Z",
        "url": "https://files.pythonhosted.org/packages/3c/d7/78df73271342afbb07fbe3b76d303e5cc00b4cd95700fef5e355ac4e9126/pymininec-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3cd778df73271342afbb07fbe3b76d303e5cc00b4cd95700fef5e355ac4e9126",
        "md5": "a140955200ac95db18654d7df5bc2d0c",
        "sha256": "c0454d6da73edc2ce5fe4cb76c12233a74720087274e2b059543ca5149a33e29"
      },
      "downloads": -1,
      "filename": "pymininec-0.3.0.tar.gz",
      "has_sig": false,
      "md5_digest": "a140955200ac95db18654d7df5bc2d0c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 60403,
      "upload_time": "2022-08-09T08:33:10",
      "upload_time_iso_8601": "2022-08-09T08:33:10.105825Z",
      "url": "https://files.pythonhosted.org/packages/3c/d7/78df73271342afbb07fbe3b76d303e5cc00b4cd95700fef5e355ac4e9126/pymininec-0.3.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}