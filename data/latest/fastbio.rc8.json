{
  "info": {
    "author": "Adrienne Hoarfrost",
    "author_email": "adrienne.l.hoarfrost@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Welcome to fastBio\n\nfastBio is a package for manipulating data and creating and training deep learning models for biological sequencing data. It is an extension of the fastai v1 library.\n\nA number of pretrained models for biological sequencing data can be loaded directly through fastBio with the **LookingGlass** and **LookingGlassClassifier** classes. \nThese models are available for download at the sister repository [LookingGlass](https://github.com/ahoarfrost/LookingGlass).\n\n\nIf you find fastBio or LookingGlass useful, please cite the preprint:\n\n> Hoarfrost, A., Aptekmann, A., Farfanuk, G. & Bromberg, Y. Shedding Light on Microbial Dark Matter with A Universal Language of Life. *bioRxiv* (2020). doi:10.1101/2020.12.23.424215. https://www.biorxiv.org/content/10.1101/2020.12.23.424215v2.\n\n# Installation\n\nYou can install fastBio with pip (python 3 only):\n\n`pip3 install fastBio`\n\n# Docs\n\nThe docs for the fastBio package are [here](https://fastbio.readthedocs.io/).\n\n# Tutorial\n\n\nYou can run the following tutorial in a jupyter notebook by downloading the notebook in [this repository](https://github.com/ahoarfrost/fastBio/blob/master/Tutorial.ipynb).\n__________________________\n\n\n```python\nimport fastBio\n```\n\n# Steps to training a model\n\nIn fast.ai, there are three basic steps to training a deep learning model: \n\n1) Define your **transforms** (for sequences/text, this means defining the **tokenizer** and **vocabulary** you will use for tokenization and numericalization)\n\n2) Create a **Databunch** (which wraps up a Pytorch Dataset and Dataloader into one)\n\n3) Create a **Learner** with your specified **model config**\n\nand train!\n\nIf fastai v1 is new to you, I recommend taking a look at their very extensive [documentation](https://fastai1.fast.ai/), [forum](https://forums.fast.ai/), and [online course](https://course19.fast.ai/). Note fastBio uses fastai v1, which isn't compatible with the new fastai v2.\n\nBiological sequence data asks for some special treatment as compared to text (kmer-based tokenization; handling sequence file types like fasta/fastq), so while we can use much of the built-in fast.ai *text* functionality, fastBio provides some helper functions and classes to deal with some of the quirks of biological data.\n\n# create tokenizer and vocabulary for transforming seq data\n\n\n```python\nfrom fastBio import BioTokenizer, BioVocab\n```\n\n\n```python\n#define a tokenizer with the correct kmer size and stride for your data\n\ntok = BioTokenizer(ksize=1, stride=1)\ntok\n```\n\n\n\n\n    BioTokenizer with the following special tokens:\n     - xxunk\n     - xxpad\n     - xxbos\n     - xxeos\n\n\n\nThe kmer size is how many nucleotides constitute a 'word' in the sequence, and the stride is the number of nucleotides to skip between tokens. \n\nSo for a sequence: `ACGGCGCTC`\n\na kmer size of 3 and stride of 1 would result in the tokenized sequence: `['ACG','CGG','GGC','GCG','CGC','GCT','CTC']`\n\nwhereas a kmer size of 3 and stride of 3 would result in: `['ACG','GCG','CTC']`\n\n## create vocab from scratch\n\n\n```python\nmodel_voc = BioVocab.create_from_ksize(ksize=1)\nprint(model_voc.itos)\nmodel_voc.stoi\n```\n\n    ['xxunk', 'xxpad', 'xxbos', 'xxeos', 'T', 'G', 'C', 'A']\n\n\n\n\n\n    defaultdict(int,\n                {'xxunk': 0,\n                 'xxpad': 1,\n                 'xxbos': 2,\n                 'xxeos': 3,\n                 'T': 4,\n                 'G': 5,\n                 'C': 6,\n                 'A': 7})\n\n\n\nAbove I created a vocabulary using a kmer size of 1 (so just the nucleotides A, C, T, G), but you can use larger kmer sizes as well:\n\n\n```python\nmodel_voc = BioVocab.create_from_ksize(ksize=2)\nprint(model_voc.itos)\nmodel_voc.stoi\n```\n\n    ['xxunk', 'xxpad', 'xxbos', 'xxeos', 'CC', 'GA', 'AG', 'CG', 'CT', 'TC', 'TT', 'TG', 'GG', 'GT', 'CA', 'GC', 'AC', 'AT', 'TA', 'AA']\n\n\n\n\n\n    defaultdict(int,\n                {'xxunk': 0,\n                 'xxpad': 1,\n                 'xxbos': 2,\n                 'xxeos': 3,\n                 'CC': 4,\n                 'GA': 5,\n                 'AG': 6,\n                 'CG': 7,\n                 'CT': 8,\n                 'TC': 9,\n                 'TT': 10,\n                 'TG': 11,\n                 'GG': 12,\n                 'GT': 13,\n                 'CA': 14,\n                 'GC': 15,\n                 'AC': 16,\n                 'AT': 17,\n                 'TA': 18,\n                 'AA': 19})\n\n\n\n## Or download the predefined LookingGlass vocabulary\n\nFor training the LookingGlass model, I used a ksize=1, stride=1. If you're using a pretrained LookingGlass-based model, you want to make sure that your vocabulary is in the same order so that numericalization is the same for your data as for the LookingGlass weights. \n\nOr, it's easy to simply download the LookingGlass vocabulary for this purpose:\n\n\n```python\n#or download from pretrained vocab used in LookingGlass\n\n#you might need this if you are me...\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context\n\nimport urllib.request\nurllib.request.urlretrieve (\"https://github.com/ahoarfrost/LookingGlass/releases/download/v1.0/ngs_vocab_k1_withspecial.npy\", \"ngs_vocab_k1_withspecial.npy\")\n\nimport numpy as np\nvoc = np.load('ngs_vocab_k1_withspecial.npy')\nmodel_voc = BioVocab(voc)\nprint(model_voc.itos)\nmodel_voc.stoi\n```\n\n    ['xxunk' 'xxpad' 'xxbos' 'xxeos' 'G' 'A' 'C' 'T']\n\n\n\n\n\n    defaultdict(int,\n                {'xxunk': 0,\n                 'xxpad': 1,\n                 'xxbos': 2,\n                 'xxeos': 3,\n                 'G': 4,\n                 'A': 5,\n                 'C': 6,\n                 'T': 7})\n\n\n\nNotice that the order of the nucleotides in the vocabulary is different than the one that we generated from scratch; if you're using the pretrained LookingGlass-based models, make sure you're using the LookingGlass vocab described here as well.\n\n# create a databunch \n\nYou can create a databunch using the **BioLMDataBunch** (for language modeling) or **BioClasDataBunch** (for classification). You can do this from raw sequence data fasta/fastq files or csv files:\n\n* from_folder\n* from_seqfile\n* from_df\n* from_multiple_csv\n\nYou will probably want to create a **BioLMDataBunch** from_folder (which will include all sequences from a folder containing multiple fasta/fastq files), or from_seqfile (all sequences from a single fasta or fastq file). \n\nFor a **BioClasDataBunch**, I find it easiest in practice to convert sequence files like fasta/fastq to csv files with the label in a column and the sequence in another column, and use from_df or from_multiple_csv, rather than use from_seqfile or from_folder. Alternatively, you *can* use the **BioTextList** class to go straight from sequence files. \n\nYou can create a custom databunch, a la the fast.ai data block API, using the **BioTextList** class, which provides a few extra specialized labeling functions etc. If you *must* use sequence files for classification, for example, you can provide a fairly complicated regex-based function to use fastai's label_from_func, or create a BioTextList.from_folder and use label_from_fname or label_from_header in the BioTextList class to extract labels from a filename or fasta header, for instance.\n\n## BioLMDataBunch example\n\nHere we'll download some toy metagenomes (a small subset of sequences from 6 marine metagenomes from the [TARA project](https://www.ebi.ac.uk/ena/browser/view/PRJEB402)), split them into 'train' and 'valid' folders, and create a BioLMDataBunch:\n\n\n```python\nfrom fastBio import BioLMDataBunch\n```\n\n\n```python\n#these are 1000 random sequences from 6 marine metagenomes from the TARA project:\nfrom pathlib import Path\nPath('./lmdata/train').mkdir(parents=True, exist_ok=True)\nPath('./lmdata/valid').mkdir(parents=True, exist_ok=True)\n\nfor srr in ['ERR598981','ERR599020','ERR599039','ERR599052']:\n    print('downloading',srr,'...')\n    'https://raw.githubusercontent.com/ahoarfrost/fastBio/master/example_data/TARA_cut1000/'+srr+'_cut1000.fastq'\n    url = 'https://raw.githubusercontent.com/ahoarfrost/fastBio/master/example_data/TARA_cut1000/'+srr+'_cut1000.fastq'\n    urllib.request.urlretrieve (url, Path('./lmdata/train/'+srr+'_cut1000.fastq'))\nfor srr in ['ERR599063','ERR599115']:\n    print('downloading',srr,'...')\n    url = 'https://raw.githubusercontent.com/ahoarfrost/fastBio/master/example_data/TARA_cut1000/'+srr+'_cut1000.fastq'\n    urllib.request.urlretrieve (url, Path('./lmdata/valid/'+srr+'_cut1000.fastq'))\n\ndata_path = Path('./lmdata/')\ntrain_path = Path('./train/') #relative to data_path\nvalid_path = Path('./valid/')\ndata_outfile = Path('metagenome_LMbunch.pkl')\n\n#define your batch size, ksize, and bptt\nbs=512 \nbptt=100\nksize=1\n\nmax_seqs=None #None or int to optionally limit the number of sequences read from each file in training\nval_max_seqs=None #same for valid set\nskiprows = 0 #0 or int to optionally skip X sequences in the beginning of the file before reading into the databunch\nval_skiprows = 0 #same for valid set\n#these will default to the parameters chosen here, we don't technically need to pass them\n\n#using tok and model_voc defined above\n\n#create new training chunk \nprint('creating databunch')\nlmdata = BioLMDataBunch.from_folder(path=data_path, \n                                        train=train_path, valid=valid_path, ksize=ksize,\n                                        tokenizer=tok, vocab=model_voc,\n                                        max_seqs_per_file=max_seqs, val_maxseqs=val_max_seqs,\n                                        skiprows=skiprows, val_skiprows=val_skiprows,\n                                        bs=bs, bptt=bptt\n                                            )\nprint('there are',len(lmdata.items),'items in itemlist, and',len(lmdata.valid_ds.items),'items in lmdata.valid_ds')\nprint('databunch preview:')\nprint(lmdata)\n#you can save your databunch to file like so:\nlmdata.save(data_outfile)\n```\n\n    there are 4000 items in itemlist, and 2000 items in lmdata.valid_ds\n    databunch preview:\n    BioLMDataBunch;\n\n    Train: LabelList (4000 items)\n    x: BioLMTextList\n    xxbos A T T A A A G A T A T C A A T G C G T A A A T C T T T A T T C T T A A T A T T A A T A T C T T A T T C A T T A T C A A T A T T T A G T T T T G A A T T T A G T G T T A T G A C C C T A A A T G C T C A A A,xxbos T G C T T T A A T T C G A T G G G T A A A T A A G C C T xxunk A T C A T T C T T T T T T G G G T C A T C A A T C G T A T C A A,xxbos T G T T A A A G C A A T A G G C A G T G A A G C A G A A G G C A G T C T C A C T G G A G T G C A C A C A G G T T T A A T G G G T T T G G G T T T C A T T A T A G G C A C G A T A A G C A T T G G A T T T G,xxbos T T T A T G T C C C T G G C T G C C A T G A A A C G G T xxunk T A C A A C A A A A G G C T G T C C C G G A T A G C C A A A T C,xxbos C C A T T A G A G T T T G T T G T T G A G T A A G T A T A A G C T C C T G A A C T T G T A T A A G T T G T T C C A T T C C A A C T A T A A G A A T C A C A A G A A G T A T G T G T A G T T G C A G A T G T\n    y: LMLabelList\n    ,,,,\n    Path: /Users/adrienne/Projects/fastBio/lmdata/train;\n\n    Valid: LabelList (2000 items)\n    x: BioLMTextList\n    xxbos A T T T T A A A G C A T A T G G T A G T A A A G G T A T T T C T T C C A A T A A A C T A C T T A G T C T G G G G A T T A A A G A T T T T C A C C G A A G T T T C C G A A T T G A A A A C A T T T C T C A A,xxbos T T T T C T T G A C T A T T T C C T T G G G C T C C A A C C A A A T A G G G G G C G A G C T T G G C G T A G G T G T T T T G A G A A A T G T T T T C A A T T C G G A A A C T T C G G T G A A A A T C T T T,xxbos T G C A A A A T C T T A T A C T A A A A T T G G T G A A A A T G T A A A A G A A G G C A T C T T T T T A C A T T A A A C T A A A A G A C G T G T T A A A C T A T T G A A A G A A G A A T T A A A A A A A,xxbos T A T T T T A T A T T C T A T A T C T T T T A C A T G T A T A G T T T C A T C T T T T C C T T T G T A A G T A A A C T T A A T A A T A C T A T G T T T T T T T A A T T C T T C T T T C A A T A G T T T A A,xxbos C T A G A C T T T T T T A T T C C T A A T T T C A A T T T T T C A T A T T T A T C T G A T G C T A G A T T T T T T A A A T C A T T A\n    y: LMLabelList\n    ,,,,\n    Path: /Users/adrienne/Projects/fastBio/lmdata/valid;\n\n    Test: None\n\n\n## BioClasDataBunch example\n\nHere we'll download sequences that I've preprocessed: downloading the coding sequences of three genomes, splitting them into read-length chunks, and recording that sequence, along with the label of the known reading frame from the coding sequence, in a csv file for each sequence. The sequence is in a column named 'seq' and the label is in a column named 'frame'.\n\nWe'll split these csv files into train and valid folders and create a BioClasDataBunch from_multiple_csv\n\n\n```python\nfrom fastBio import BioClasDataBunch\n```\n\n\n```python\nfrom pathlib import Path\nPath('./clasdata/train').mkdir(parents=True, exist_ok=True)\nPath('./clasdata/valid').mkdir(parents=True, exist_ok=True)\n\nfor genome in ['GCA_000007025.1_ASM702v1','GCA_000008685.2_ASM868v2']:\n    print('downloading',genome,'...')\n    url = 'https://github.com/ahoarfrost/fastBio/raw/master/example_data/FrameClas_sample/'+genome+'.csv'\n    urllib.request.urlretrieve (url, Path('./clasdata/train/'+genome+'.csv'))\n\nurl = 'https://github.com/ahoarfrost/fastBio/raw/master/example_data/FrameClas_sample/GCA_000011445.1_ASM1144v1.csv'\nprint('downloading GCA_000011445.1_ASM1144v1...')    \nurllib.request.urlretrieve (url, Path('./clasdata/valid/GCA_000011445.1_ASM1144v1.csv'))\n\ndata_path = Path('./clasdata/')\ntrain_path = Path('./clasdata/train/')\nvalid_path = Path('./clasdata/valid/')\ndata_outfile = Path('frameclas_bunch.pkl')\n\n#use tok and model_voc defined above again\n#you can optionally limit the number of sequences you read (and how many rows to skip in the csv)\n\nframedata = BioClasDataBunch.from_multiple_csv(path=data_path, train=train_path, valid=valid_path,\n                                    text_cols='seq', label_cols='frame',\n                                    tokenizer=tok, vocab=model_voc,\n                                    #let's limit the number of sequences for this toy example\n                                    max_seqs_per_file=1000, valid_max_seqs=500, skiprows=0, bs=512\n                                        )\nprint('there are',len(framedata.items),'items in itemlist, and',len(framedata.valid_ds.items),'items in data.valid_ds')\nprint('there are',framedata.c,'classes')\n\nprint('databunch preview:')\nprint(framedata)\n#you can save your databunch to file like so:\nframedata.save(data_outfile)\n```\n\n    there are 2000 items in itemlist, and 500 items in data.valid_ds\n    there are 6 classes\n    databunch preview:\n    TextClasDataBunch;\n\n    Train: LabelList (2000 items)\n    x: BioTextList\n    xxbos A G T T A A A T C G A T T T G G G T T C C A A T A A A A A A T T T T A T A G C A A G T G T A T C A G T T A A A A T T G A A T A C T T G G T A A T G T A A A T A G T G A A A G C T A A A T T G A A A T A,xxbos A A A G A A G T C G A T A A T T T A T A G T A A A T A C T A T A G T T A T T A G G T A T G A A A T C A A T T T C A A A T T T G A A G G T A A T T A T G G G A A G A A T T G G A T A G A G A A A T G C A T G A G T T G T T T T T C C T G T A A A T A T A G T A G T T C T C A G,xxbos A A T G A A G T A T A G T G C T A T T T T A T T A A T A T G T A G C G T T A A T T T A T T T T G T T T T C A A A A T A A A T T A A C T A C T T C T C G A T G G G A A T T C C C T A A A G A A G A T T T A A T T A A A A A A A A A A T A A A A A T A G G C A T A A T T T A C C A T A A T T A C A T A A A T T C T A T C T T T T A C A A T G A A A A T T A T A A A T A C A T T G C C T T T A T C G G A A T A T T G A C A T C T T A T A A T G A A T G G A T T G A A A T A C A A T T T A G C C C C A T A A A T T T T T T T A C T A T C C C A A C A A A T A A A G A T T T T A T T T C A A A T A C T,xxbos C T A A T A T T G A A A A T G C T A T T A A A A A G T C T T T G A G T T C G G G T G T C A A T A T A G T A C T C A T T C C T T A G,xxbos T T G C A T C T T A T T T A T A A A A T T G G T G A A G T T C T T G C T A A A C A A T T G C G T A G A T T G G G T A T T A A T T T A A A T A T G G C T C C A G T T G C C G A T A T A A A A T T T G C A C C A C A T A C T C C T T T A T T A A A T A G G A C A T T T G G A G G A T A T T C C G C T T A T A A T\n    y: CategoryList\n    -1,-1,2,3,1\n    Path: /Users/adrienne/Projects/fastBio/clasdata;\n\n    Valid: LabelList (500 items)\n    x: BioTextList\n    xxbos A T C T C T A C C A C C A A A T T C T T C T C C A A T T T G A G C T A A A G T G T G A T T T A A G A T C T C T T T T G T T A A A A A C A T T G C T A T A T G T C T T G C T G T T A C A A T T G A C T T A,xxbos A A G C T T T T A T A G C A G T T C A A A C C G T A A G T A A A A A T C C T G G A A T T T C T T A T A A T C C A T T G T T T A T T T A T G G T G A A T C T G G A A T G G G A A A A A C T C A T T T A T T A A A A G C T G C A A A A A A C T A T A T T G A A T C T A A T T T T T C T G A T C T A A A A G T T A,xxbos G T T C A T T A C T T G C A C C G A T T A C A A A A T T T T C A A A T G T G T T T T C A T T A A T T T T T T T A A C T T T T T T A G T G A T G A T A T C A G A A T G A T C T T T T T T G A T T A A T T C A T C T T T T T C T A G T T G T T T T T T A T A T T C T T G T T C G T A T G T A A A A C T A A T A T T,xxbos T T T A A A A T A C C T A A T T T T G A A G T A G G T A T A T C T C T A A A C A G A T C A G A A A C T A T T T C T A T A G T A A T A A T T T T T T C T T C T G G A T T T T G T T G A G A T C A A A A G T T T A A T C T T G A A A C A C T T C C T T T A A T T T T T C T A A C A T C A T C T G A A T A A T A A,xxbos T G T T A A A A A A A T T A A A G A A G T T G T T A G T G A A A A A T A T G G T A T T T C A G T T A A T G C A A T T G A T G G A A A A G C T A G A A G\n    y: CategoryList\n    -2,3,-1,-2,2\n    Path: /Users/adrienne/Projects/fastBio/clasdata;\n\n    Test: None\n\n\n# create a learner and train\n\nYou can now create a fastai 'learner' with your databunch and train! \n\nThere's nothing special in fastBio you *need* to create a learner - you can use get_language_model or get_text_classifier and any model config you want (see the fastai and pytorch docs for this). \n\nTo use LookingGlass architecture (with or without pretrained weights), use the **LookingGlass** or **LookingGlassClassifier** classes which maintain the architecture used for the LookingGlass models and associated transfer learning tasks.\n\nThere are several pretrained models available through the [LookingGlass](https://github.com/ahoarfrost/LookingGlass/releases/download/v1.0/LookingGlass.pth) release, which can be loaded by name in the LookingGlass and LookingGlassClassifier classes.\n\nMake sure to use pretrained=False if you're not using a pretrained model (pretrained=True by default). \n\n## Language model\n\nLet's use our BioLMDataBunch to train a language model with the same architecture as LookingGlass:\n\n\n```python\nfrom fastBio import LookingGlass\n```\n\n### from scratch (no pretrained weights)\n\n\n```python\nlmlearn = LookingGlass(data=lmdata).load(pretrained=False)\n```\n\n\n```python\n#adjusting batch size down for my laptop\nlmlearn.data.batch_size = 64\n```\n\n\n```python\nlmlearn.fit_one_cycle(5)\n```\n\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>accuracy</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1.592360</td>\n      <td>1.451439</td>\n      <td>0.302540</td>\n      <td>06:35</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>1.460893</td>\n      <td>1.411753</td>\n      <td>0.310217</td>\n      <td>06:58</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>1.421647</td>\n      <td>1.402959</td>\n      <td>0.316920</td>\n      <td>07:04</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>1.407578</td>\n      <td>1.399795</td>\n      <td>0.329194</td>\n      <td>06:53</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>1.403432</td>\n      <td>1.399376</td>\n      <td>0.330121</td>\n      <td>06:51</td>\n    </tr>\n  </tbody>\n</table>\n\n\n### using a pretrained model \n\nUsing pretrained=True with LookingGlass.load() will load the 'LookingGlass' language model pretrained weights.\n\n\n```python\n#create LookingGlass() model from databunch defined above\nlmlearn2 = LookingGlass(data=lmdata).load(pretrained=True, pretrained_dir='models')\n```\n\n    downloading pretrained model to models/LookingGlass.pth\n    loading pretrained LookingGlass language model\n\n\n## Classifier\n\nLet's use our BioClasDataBunch to create and train a classifier with the same encoder architecture as LookingGlass to predict the reading frame of a DNA sequence.\n\nLookingGlassClassifier has two ways to load a model:\n\n* **load()** \n\n* **load_encoder()**\n\nIf using pretrained=False, load() and load_encoder() both create the same classifier with a LookingGlass-like encoder and classification decoder. \n\nIf using pretrained=True, **load** and **load_encoder** differ in the pretrained models that can be loaded:\n\n* load_encoder - 'LookingGlass_enc' (default), or 'FunctionalClassifier_enc'\n\n* load - 'FunctionalClassifier', 'OxidoreductaseClassifier', 'OptimalTempClassifier', or 'ReadingFrameClassifier'\n\nThese models are described in the [preprint](https://www.biorxiv.org/content/10.1101/2020.12.23.424215v2).\n\n\n```python\nfrom fastBio import LookingGlassClassifier\n```\n\n### from scratch (no pretrained weights)\n\n\n```python\nframelearn = LookingGlassClassifier(data=framedata).load(pretrained=False)\n```\n\n\n```python\n#decrease batch size for my laptop\nframelearn.data.batch_size = 128\n```\n\n\n```python\nframelearn.fit_one_cycle(5)\n```\n\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>accuracy</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1.837610</td>\n      <td>1.793275</td>\n      <td>0.162000</td>\n      <td>03:52</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>1.769472</td>\n      <td>1.782107</td>\n      <td>0.184000</td>\n      <td>03:39</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>1.688373</td>\n      <td>1.776759</td>\n      <td>0.172000</td>\n      <td>03:24</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>1.631552</td>\n      <td>1.620592</td>\n      <td>0.270000</td>\n      <td>03:24</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>1.600325</td>\n      <td>1.555967</td>\n      <td>0.294000</td>\n      <td>03:22</td>\n    </tr>\n  </tbody>\n</table>\n\n\nWe have pretty limited data here, so we don't get great performance. Let's try loading the pretrained LookingGlass encoder and see if we can fine tune it to do any better:\n\n### with the pretrained 'LookingGlass' encoder\n\n\n```python\nframelearn2 = LookingGlassClassifier(data=framedata).load_encoder(pretrained_name='LookingGlass_enc', \n                                                                  pretrained=True, \n                                                                  pretrained_dir='models')\n```\n\n    downloading pretrained model to models/LookingGlass_enc.pth\n    loading classifier with pretrained encoder from models/LookingGlass_enc.pth\n\n\n\n```python\n#decrease batch size for my laptop\nframelearn2.data.batch_size = 128\n```\n\n\n```python\nframelearn2.fit_one_cycle(5)\n```\n\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>accuracy</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>1.821647</td>\n      <td>1.794491</td>\n      <td>0.238000</td>\n      <td>01:11</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>1.655392</td>\n      <td>1.745429</td>\n      <td>0.280000</td>\n      <td>01:13</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>1.470321</td>\n      <td>1.612899</td>\n      <td>0.376000</td>\n      <td>01:13</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>1.328448</td>\n      <td>1.432560</td>\n      <td>0.528000</td>\n      <td>01:11</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>1.241135</td>\n      <td>1.250988</td>\n      <td>0.548000</td>\n      <td>01:11</td>\n    </tr>\n  </tbody>\n</table>\n\n\nWe do much better, but of course we still don't have much data (and we're not using our tricks like gradual training of layers) so our performance isn't yet amazing, and we're starting to overfit. \n\nLuckily, there's an existing pretrained model for exactly this classification task, the 'ReadingFrameClassifier', that we can use:\n\n### using the pretrained ReadingFrameClassifier model\n\n\n```python\nframelearn3 = LookingGlassClassifier(data=framedata).load(pretrained_name='ReadingFrameClassifier', \n                                                                  pretrained=True, \n                                                                  pretrained_dir='models')\n```\n\n    downloading pretrained model to models/ReadingFrameClassifier.pth\n    loading pretrained classifier from models/ReadingFrameClassifier.pth\n\n\n\n```python\n#decrease batch size for my laptop\nframelearn3.data.batch_size = 128\n```\n\n\n```python\nframelearn3.fit_one_cycle(1)\n```\n\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>accuracy</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>0.060926</td>\n      <td>0.189241</td>\n      <td>0.944000</td>\n      <td>01:19</td>\n    </tr>\n  </tbody>\n</table>\n\n\nmuch better! Although we're already pretty overfit, so we probably should have just gone straight into using the pretrained model for inference rather than further training. \n\nWe can do that with framelearn3.predict() or .pred_batch(), or we can load an exported model for inference like so:\n\n## I don't want to deal with all the databunch/training stuff. What if I really just want to make  a handful of predictions on some data with a pretrained model? \n\nYou can do that! Pretrained models for LookingGlass and associated transfer learning tasks can be downloaded in [release v1 of LookingGlass](https://github.com/ahoarfrost/LookingGlass/releases/tag/v1.0). The ones that end in 'export.pkl' were saved using the fastai 'export' function and can be loaded (with empty databunches) with the fastai load_learner function and used for inference directly:\n\n\n```python\n#download the pretrained oxidoreductase classifier to 'models' folder\nimport urllib.request\nurllib.request.urlretrieve ('https://github.com/ahoarfrost/LookingGlass/releases/download/v1.0/OxidoreductaseClassifier_export.pkl', \n                            'models/OxidoreductaseClassifier_export.pkl')\n```\n\n\n\n\n    ('models/OxidoreductaseClassifier_export.pkl',\n     <http.client.HTTPMessage at 0x7ffd52420ef0>)\n\n\n\n\n```python\n#load the model (with an empty databunch)\nfrom fastai.text import load_learner\noxido = load_learner(Path('./models').resolve(), 'OxidoreductaseClassifier_export.pkl')\n```\n\nNow let's make some predictions for reads in one of our toy metagenomes we downloaded earlier:\n\n\n```python\nfrom Bio import SeqIO\n\nfor ix,record in enumerate(SeqIO.parse('lmdata/valid/ERR599115_cut1000.fastq','fastq')): \n    seq = str(record.seq)\n    if ix < 20:\n        print('sequence:',seq)\n        print('prediction:',oxido.predict(seq))\n        print('---------')\n    else:\n        break\n```\n\n    sequence: GGGTTGCCAGGTCGACGAGCACGACGACGGCTCGAAGAGCGGTTGGTGCGAGGACGGCACCGGTTGGTGG\n    prediction: (Category nonec1, tensor(1), tensor([0.0130, 0.9870]))\n    ---------\n    sequence: CTGGTTCCATCATCGTAGGAGTCGGTGGAACAGCCAGTCTCCTCGTCGTAGCTGTAGACGGGCGGAGCCCAGGACTCCTGCACACCCTCGGCGTCCTCC\n    prediction: (Category nonec1, tensor(1), tensor([0.0024, 0.9976]))\n    ---------\n    sequence: TTCAGAATAATCAACTCCATCAATATCCCAGCCACATCCTGATAAATATTGACATTGATCATCCGCATAACCCACGCCTAAATACATGTCACACCAGCC\n    prediction: (Category nonec1, tensor(1), tensor([0.4787, 0.5213]))\n    ---------\n    sequence: TGGANAGACGCCTATTTGGGTTGCAGAGTGTCCTGAAAATGGTGATTGCATGGATTTGACTGGATTATTTTTTGGCTGGTGTGACATGTATTTAGGCG\n    prediction: (Category nonec1, tensor(1), tensor([0.0030, 0.9970]))\n    ---------\n    sequence: ATGATTTAGCAACCATTTTAATCCCCCCTTCAAGTGGGGTTCAATCCGCTGAAGGAGCTCAGCTGGGAACAT\n    prediction: (Category nonec1, tensor(1), tensor([0.0132, 0.9868]))\n    ---------\n    sequence: TGTCACTGGCAGCTTATTTAGTGTTCTCTTGTGCAGGACAGAAAGTTCCTGATAATCCAAAACTGGTAGTGATGATAGCCGGCGATATGTTC\n    prediction: (Category nonec1, tensor(1), tensor([0.0019, 0.9981]))\n    ---------\n    sequence: TCTGCTGTGCCAGACCGATAAACGAATTCATGATACCAATGACGGTACCGAACAGACCGATATAGCGCGTTACTGAACCTACTGTGGCCAGAAAC\n    prediction: (Category nonec1, tensor(1), tensor([3.6912e-04, 9.9963e-01]))\n    ---------\n    sequence: CATCATGGCCGGTTCCCAGCGTGCCATGCGCGTAGCCTATTCGCGTGAAGAGGAAAAGCTGGAAAAACATCTGCCGTTTCTGGCCACAGTAGGTTCAGTA\n    prediction: (Category ec1, tensor(0), tensor([0.7161, 0.2839]))\n    ---------\n    sequence: TTATGGAGCATACCAAACATTACCAAATATACGAAAACAAAATTTTGCTATTTTGGTAGAAGGACAAACTGATTGTCTTCGTTTGGTAGAAAATGGTTT\n    prediction: (Category nonec1, tensor(1), tensor([0.0411, 0.9589]))\n    ---------\n    sequence: TTTTTAAGCACAGTAGCGTGTTTGCTCGAAAATGCGGTTCCTGAGGTAGCAATTACATTAGAAAAACCATTTTCTACCAAACGAAGACAATCAGTTTGTC\n    prediction: (Category nonec1, tensor(1), tensor([0.2211, 0.7789]))\n    ---------\n    sequence: CAGTGACAAGATAATTTTTTCATCGGTATGTTTTATTTATCACTATTTTTCTATCATAGTAATAGTTATCCACACCGCACTAGAACTGCTTTAAATGTT\n    prediction: (Category nonec1, tensor(1), tensor([0.0069, 0.9931]))\n    ---------\n    sequence: TAGGTTGTACTTTGAGTCTGTAAGTGAATCGAAAGTGAATCAAAACGTGAACATTTAAAGCAGTTCTAGTGCGGTGTGGATAACTATTACTATGATAGAAA\n    prediction: (Category nonec1, tensor(1), tensor([0.0203, 0.9797]))\n    ---------\n    sequence: GCCATGGGCGTTATTTGTCTAATTTGCCCTTTGATGCATCCACGAAGCGGGGTCATCCGTATCCCGGCATCGGTTCTTAACCAGCAAAGGAAGAACAAA\n    prediction: (Category ec1, tensor(0), tensor([0.6001, 0.3999]))\n    ---------\n    sequence: AGCCAGCGTGCACCATCAAGGCGCTTTGCTATCGTATTTTCCGGGGCACCATCATTAATATCTCTCGTCTCTTTGTACTTCCTTTGCTGGTTAAGAACCGA\n    prediction: (Category nonec1, tensor(1), tensor([0.0165, 0.9835]))\n    ---------\n    sequence: TCTTTTGCTTATTGTTGGTTCAACACAACGTGCACTTTCAGATGGTTCAAAAGTTAGAGGAGACATAAACGTTTTTCTTGTTGGAGATCCTGGTACGGC\n    prediction: (Category nonec1, tensor(1), tensor([0.2953, 0.7047]))\n    ---------\n    sequence: CCTGATGTGTATAATCCTCTAGGAGCAATTCTTGAACAGAACTTTAACATTTCACTTTTTGCCGTACCAGGATCTCCAACAAGAAAAACGTTTATGTCTCC\n    prediction: (Category nonec1, tensor(1), tensor([0.4585, 0.5415]))\n    ---------\n    sequence: TGCTTACATCAGTCATTTTTTTCACCAAATTCTTCGAGAATCTTAACTGGCCTTATCCGGTCTAAAGTCTT\n    prediction: (Category ec1, tensor(0), tensor([0.5849, 0.4151]))\n    ---------\n    sequence: TGATTTCGGTAGCGGATATCCATCTGATAAAAAAACAATTAATTTTTTGAAGAGGTTCTATGCTGATAATGGAAAGTGGCCTGAGGG\n    prediction: (Category nonec1, tensor(1), tensor([0.1965, 0.8035]))\n    ---------\n    sequence: AAAACTTTTCTAAAAAATCAATATCTACAATTAAAGAAGCAAGAATCCTAGATGGTGATTCCACATATTTTCTGAATTTTAATCATCAAGAAATTCAAA\n    prediction: (Category nonec1, tensor(1), tensor([0.1708, 0.8292]))\n    ---------\n    sequence: AAAGNTTTTTTTTGATTAAATGGTTTGGAATTAAATATCCTAAATTTTCTTTTTGAATTTCTTGATGATTAAAATTCAGAAAATATGTGGAATCACCATCT\n    prediction: (Category nonec1, tensor(1), tensor([0.0047, 0.9953]))\n    ---------\n\n\nThis model predicts whether a sequence comes from an oxidoreductase (EC 1.-.-.-) or not - 'ec1' or 'nonec1'. 3 out of 20 of the sequences are predicted as ec1, which is consistent with the results from [the paper](https://www.biorxiv.org/content/10.1101/2020.12.23.424215v2) which found around 20% of sequences to be oxidoreductases in marine metagenomes.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ahoarfrost/fastBio",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "fastBio",
    "package_url": "https://pypi.org/project/fastBio/",
    "platform": "",
    "project_url": "https://pypi.org/project/fastBio/",
    "project_urls": {
      "Homepage": "https://github.com/ahoarfrost/fastBio"
    },
    "release_url": "https://pypi.org/project/fastBio/0.1.7/",
    "requires_dist": [
      "fastai (==1.0.52)",
      "biopython (==1.73)",
      "torch (==1.2.0)",
      "torchvision (==0.4.0)"
    ],
    "requires_python": ">=3.6",
    "summary": "Deep learning for biological sequences with fastai",
    "version": "0.1.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11051368,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ec7fbafcd1e8e3a0e546c67ddd79885eaeec1a0768d7c23d6de7d2856bd11c80",
          "md5": "7662e7b07b9faf9c8f0ae7c75cf2709f",
          "sha256": "fbbde76f5dd3c693d802e46ab8ecaf38349fbab89ac3c881f165f7e3507a4740"
        },
        "downloads": -1,
        "filename": "fastBio-0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7662e7b07b9faf9c8f0ae7c75cf2709f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 16312,
        "upload_time": "2021-01-04T19:22:51",
        "upload_time_iso_8601": "2021-01-04T19:22:51.726340Z",
        "url": "https://files.pythonhosted.org/packages/ec/7f/bafcd1e8e3a0e546c67ddd79885eaeec1a0768d7c23d6de7d2856bd11c80/fastBio-0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2cef73ad448f870711d68143c6e5949ebf477667ed9440890656101bf36e18df",
          "md5": "afe9ba016fcb8f3b31e8bc96b1474f04",
          "sha256": "113d21182d35595ef55f8ce6f120e648f570151fff36840ceeb94cbf8b1baac9"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "afe9ba016fcb8f3b31e8bc96b1474f04",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 13606,
        "upload_time": "2021-01-04T19:22:52",
        "upload_time_iso_8601": "2021-01-04T19:22:52.783292Z",
        "url": "https://files.pythonhosted.org/packages/2c/ef/73ad448f870711d68143c6e5949ebf477667ed9440890656101bf36e18df/fastBio-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "45f6b8df8c2fb0db0784953f6b44cb35cb232d41eb3aeea28e2e27b4fc632882",
          "md5": "3c8a924e9809779c17f978ab11e94218",
          "sha256": "8834ee4cca806023e3a7f9e83f7bc8099b03d86f756b0400ec7d4c7e2f7bd5af"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3c8a924e9809779c17f978ab11e94218",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 16508,
        "upload_time": "2021-01-04T19:41:17",
        "upload_time_iso_8601": "2021-01-04T19:41:17.583295Z",
        "url": "https://files.pythonhosted.org/packages/45/f6/b8df8c2fb0db0784953f6b44cb35cb232d41eb3aeea28e2e27b4fc632882/fastBio-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "37d26edc3549ac779daceff589cf7789c8ff0e5d07c75740f4d2a68843b0c797",
          "md5": "1ec548778cff4eaef52c54d56db1296e",
          "sha256": "ce38f1176a302996b88b50b11524a05f26894078ca766efbc9a6ace06f050e56"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "1ec548778cff4eaef52c54d56db1296e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 14186,
        "upload_time": "2021-01-04T19:41:18",
        "upload_time_iso_8601": "2021-01-04T19:41:18.701800Z",
        "url": "https://files.pythonhosted.org/packages/37/d2/6edc3549ac779daceff589cf7789c8ff0e5d07c75740f4d2a68843b0c797/fastBio-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "369d71f9e4693e1393f57732a7eafe2152856f83c03793fc64ef1c5de51e9bcb",
          "md5": "3601989679e41bfa3fa684efe87599f7",
          "sha256": "b2fe24a4cad1acd3e28dccdf2465398781373c61ffb84144e3e37185ad2a5586"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3601989679e41bfa3fa684efe87599f7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 19176,
        "upload_time": "2021-01-07T22:01:03",
        "upload_time_iso_8601": "2021-01-07T22:01:03.385721Z",
        "url": "https://files.pythonhosted.org/packages/36/9d/71f9e4693e1393f57732a7eafe2152856f83c03793fc64ef1c5de51e9bcb/fastBio-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ec0d2c96dda155bc58aa81c56eee26348adc626c7de9a288b8d89708bd804cf0",
          "md5": "c0293cae6069f976ee7f178f8bf53d79",
          "sha256": "c954e344a14195b5ce4b7c85cd589bc9227f308df01fc602ea070c150bec18d0"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "c0293cae6069f976ee7f178f8bf53d79",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 16785,
        "upload_time": "2021-01-07T22:01:04",
        "upload_time_iso_8601": "2021-01-07T22:01:04.734379Z",
        "url": "https://files.pythonhosted.org/packages/ec/0d/2c96dda155bc58aa81c56eee26348adc626c7de9a288b8d89708bd804cf0/fastBio-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "90101dcac3589d9d9dd090baff77414219dc79d0b5212879e5915892c523388b",
          "md5": "a90d25fa5d10b1ce228ef42c72d2f6e4",
          "sha256": "2995df5b120c1369e08630e2d408671f24cc502db8a93fd343c8962f362620db"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a90d25fa5d10b1ce228ef42c72d2f6e4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 19166,
        "upload_time": "2021-01-07T22:26:35",
        "upload_time_iso_8601": "2021-01-07T22:26:35.373517Z",
        "url": "https://files.pythonhosted.org/packages/90/10/1dcac3589d9d9dd090baff77414219dc79d0b5212879e5915892c523388b/fastBio-0.1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7a9b743d3a7ee900c6bb5dd398878289673e78248cf725d6dace8c7b7de2b7ae",
          "md5": "8f0878f10b256394dda95c5104210388",
          "sha256": "13adb70778ddb6dfeb740fea511a4a5d33cc8ba5ea9a2dd99ef6e93a1fcf41ed"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "8f0878f10b256394dda95c5104210388",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 16744,
        "upload_time": "2021-01-07T22:26:36",
        "upload_time_iso_8601": "2021-01-07T22:26:36.571454Z",
        "url": "https://files.pythonhosted.org/packages/7a/9b/743d3a7ee900c6bb5dd398878289673e78248cf725d6dace8c7b7de2b7ae/fastBio-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3cb882173d4f39ecfe31228d572dcc855f76cb3421636d7288674934ac290a80",
          "md5": "28f50b1934270fd1ef35cca65bbf6393",
          "sha256": "947d0a7eb1630a5e95511fe34118dce00f0de61d4d0f22ee410b436726be9130"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "28f50b1934270fd1ef35cca65bbf6393",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 19211,
        "upload_time": "2021-01-08T00:24:56",
        "upload_time_iso_8601": "2021-01-08T00:24:56.100640Z",
        "url": "https://files.pythonhosted.org/packages/3c/b8/82173d4f39ecfe31228d572dcc855f76cb3421636d7288674934ac290a80/fastBio-0.1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "797bf547c0ee7df7e9bd3e95499f185217fea7c8241550c4b8f13a47baf312ea",
          "md5": "fba9f688e138208c396a58a234bc42f6",
          "sha256": "1599f6d2e1fc25f4b63b2891d0dc0a181318ab9f22cb126b366ebd5a597ab281"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "fba9f688e138208c396a58a234bc42f6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 16794,
        "upload_time": "2021-01-08T00:24:57",
        "upload_time_iso_8601": "2021-01-08T00:24:57.608364Z",
        "url": "https://files.pythonhosted.org/packages/79/7b/f547c0ee7df7e9bd3e95499f185217fea7c8241550c4b8f13a47baf312ea/fastBio-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7be12314cc14d74a66d0d5d4b8645684c61811a8a8baba201a4c0a7bb600a9fa",
          "md5": "053948606426d63a30587c3442b87a7b",
          "sha256": "3174d0bc48cb6261638e38a02a67d1443245b77c704b2ce1de691c1bb43d1577"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "053948606426d63a30587c3442b87a7b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 19211,
        "upload_time": "2021-01-08T01:30:09",
        "upload_time_iso_8601": "2021-01-08T01:30:09.971685Z",
        "url": "https://files.pythonhosted.org/packages/7b/e1/2314cc14d74a66d0d5d4b8645684c61811a8a8baba201a4c0a7bb600a9fa/fastBio-0.1.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b216b110b1f84df45497e9568455d672f8dba2d46093ed3a4ccf8d292ca00fcc",
          "md5": "ab452cbebf26911923e44bfb3ba1c7b6",
          "sha256": "d497bd521d868388906fdde0fb2904029e23947171b172bd2b6ee009db14b00e"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "ab452cbebf26911923e44bfb3ba1c7b6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 16787,
        "upload_time": "2021-01-08T01:30:12",
        "upload_time_iso_8601": "2021-01-08T01:30:12.146940Z",
        "url": "https://files.pythonhosted.org/packages/b2/16/b110b1f84df45497e9568455d672f8dba2d46093ed3a4ccf8d292ca00fcc/fastBio-0.1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "93d675b2e1dc12d57ba80eb8f98db4af18da8f6e8bcdbf7857a89dd8db3b0293",
          "md5": "dac3224b575eec1ba1d71c5c8d04096e",
          "sha256": "aa6319fdb95b414a0d11ab4edd31d9f94889d2f5454acd576a90e0df801b29df"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "dac3224b575eec1ba1d71c5c8d04096e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6,<=3.7",
        "size": 27432,
        "upload_time": "2021-07-29T17:34:48",
        "upload_time_iso_8601": "2021-07-29T17:34:48.780125Z",
        "url": "https://files.pythonhosted.org/packages/93/d6/75b2e1dc12d57ba80eb8f98db4af18da8f6e8bcdbf7857a89dd8db3b0293/fastBio-0.1.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dba0a79f110923466f67337147db6e39a752c0dee28e34710cddb963bd17a5b2",
          "md5": "bbc1f3e413e30c7d98dfabbc1d7915be",
          "sha256": "296a7211bf41a6bdb62436ef82f9c771e9485f70ebbb0ccb4ca8804e39644900"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "bbc1f3e413e30c7d98dfabbc1d7915be",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6,<=3.7",
        "size": 40625,
        "upload_time": "2021-07-30T14:51:42",
        "upload_time_iso_8601": "2021-07-30T14:51:42.759088Z",
        "url": "https://files.pythonhosted.org/packages/db/a0/a79f110923466f67337147db6e39a752c0dee28e34710cddb963bd17a5b2/fastBio-0.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7afc31f1622317b3171145445a9d58ec4a88eb1398a86e1787248c6661e0fcde",
          "md5": "94beaec81f2683e3c3edac923568bea5",
          "sha256": "70d86ad9111c7d12e991c8a3cb23c854d09b9f152381efe4058a053f12d19e1b"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "94beaec81f2683e3c3edac923568bea5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 27426,
        "upload_time": "2021-07-30T15:16:08",
        "upload_time_iso_8601": "2021-07-30T15:16:08.165844Z",
        "url": "https://files.pythonhosted.org/packages/7a/fc/31f1622317b3171145445a9d58ec4a88eb1398a86e1787248c6661e0fcde/fastBio-0.1.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e446964d9bc2b79fe4fe273ad3c8bf3467c3f6ca465d114dbcaa79c76f507f86",
          "md5": "bcf3caae7c38c096022a9ec9e443d16e",
          "sha256": "a1249b664a9c63026a77d14f45074aa03c08e867c736d92da0b11d914b2e8e08"
        },
        "downloads": -1,
        "filename": "fastBio-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "bcf3caae7c38c096022a9ec9e443d16e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 40612,
        "upload_time": "2021-07-30T15:16:09",
        "upload_time_iso_8601": "2021-07-30T15:16:09.619734Z",
        "url": "https://files.pythonhosted.org/packages/e4/46/964d9bc2b79fe4fe273ad3c8bf3467c3f6ca465d114dbcaa79c76f507f86/fastBio-0.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7afc31f1622317b3171145445a9d58ec4a88eb1398a86e1787248c6661e0fcde",
        "md5": "94beaec81f2683e3c3edac923568bea5",
        "sha256": "70d86ad9111c7d12e991c8a3cb23c854d09b9f152381efe4058a053f12d19e1b"
      },
      "downloads": -1,
      "filename": "fastBio-0.1.7-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "94beaec81f2683e3c3edac923568bea5",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 27426,
      "upload_time": "2021-07-30T15:16:08",
      "upload_time_iso_8601": "2021-07-30T15:16:08.165844Z",
      "url": "https://files.pythonhosted.org/packages/7a/fc/31f1622317b3171145445a9d58ec4a88eb1398a86e1787248c6661e0fcde/fastBio-0.1.7-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e446964d9bc2b79fe4fe273ad3c8bf3467c3f6ca465d114dbcaa79c76f507f86",
        "md5": "bcf3caae7c38c096022a9ec9e443d16e",
        "sha256": "a1249b664a9c63026a77d14f45074aa03c08e867c736d92da0b11d914b2e8e08"
      },
      "downloads": -1,
      "filename": "fastBio-0.1.7.tar.gz",
      "has_sig": false,
      "md5_digest": "bcf3caae7c38c096022a9ec9e443d16e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 40612,
      "upload_time": "2021-07-30T15:16:09",
      "upload_time_iso_8601": "2021-07-30T15:16:09.619734Z",
      "url": "https://files.pythonhosted.org/packages/e4/46/964d9bc2b79fe4fe273ad3c8bf3467c3f6ca465d114dbcaa79c76f507f86/fastBio-0.1.7.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}