{
  "info": {
    "author": "Larry Hastings",
    "author_email": "larry@hastings.org",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3 :: Only"
    ],
    "description": "![## Appeal](/resources/images/appeal.logo.png)\n\n![## Give your program Appeal!](/resources/images/give.your.program.appeal.png)\n\n##### Copyright 2021-2023 by Larry Hastings\n\n\n## Quickstart\n\n```Python\nimport appeal\nimport sys\n\napp = appeal.Appeal()\n\n@app.command()\ndef hello(name):\n    print(f\"Hello, {name}!\")\n\napp.main()\n```\n\nHere's a simple ``fgrep`` utility:\n\n```Python\nimport appeal\nimport sys\n\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(pattern, *files, ignore_case=False):\n    if not files:\n        files = ['-']\n    print_file = len(files) > 1\n    if ignore_case:\n        pattern = pattern.lower()\n    for file in files:\n        if file == \"-\":\n            f = sys.stdin\n        else:\n            f = open(file, \"rt\")\n        for line in f:\n            if ignore_case:\n                match = pattern in line.lower()\n            else:\n                match = pattern in line\n            if match:\n                if print_file:\n                    print(file + \": \", end=\"\")\n                print(line.rstrip())\n        if file != \"-\":\n            f.close()\n\n\nif __name__ == \"__main__\":\n    app.main()\n```\n\n\n## Overview\n\nAppeal is a command-line argument processing library for\nPython, like `argparse`, `optparse`, `getopt`, `click`,\n`docopt`, and `Typer`.  But Appeal takes a refreshing new\napproach.\n\nOther libraries have complicated, cumbersome interfaces\nthat force you to repeat yourself over and over.\nAppeal leverages Python's rich function call interface,\nwhich makes defining your command-line interface effortless.\nYou write Python functions, and Appeal translates them into\ncommand-line options and arguments.\n\nAppeal provides amazing power and flexibility--but it's\nalso intuitive, because it mirrors Python itself.\nIf you understand how to write Python functions,\nyou're already halfway to understanding Appeal!\n\n### A New And Appealing Approach\n\nAppeal isn't like other command-line parsing libraries.\nIn fact, you really shouldn't think of Appeal as a\n\"command-line parsing library\" per se. And, although you\nwork with Appeal by passing in functions for Appeal to call,\nyou shouldn't think of these functions as \"callbacks\".\n\nAppeal lets you design *APIs* callable from the command-line.\nIt's just like any other Python library API--except that\nthe caller calls you from the command-line instead of from\nPython.  Appeal is the mechanism converting between these two\ndomains: it translates your API into command-line semantics,\nthen translates the user's command-line back into calls to your API.\n\nThis raises another good point: the API you build using Appeal\nalso often makes for a very nice *automation API,* allowing\nyour program to also be used as a library by other programs\nwith minimal effort.\n\n\n## Basics\n\n### Taxonomy\n\nLet's start by establishing the terminology we'll use\nfor command-lines, based on command-line idioms established\nby POSIX and by popular programs.  Here's a sample\ncommand-line, illustrating all the various types of things\nyou might ever see:\n\n    % ./script.py --debug add --flag ro -v -xz myfile.txt\n      ^           ^       ^   ^      ^  ^  ^   ^\n      |           |       |   |      |  |  |   |\n      |           |       |   |      |  |  |   argument\n      |           |       |   |      |  |  |\n      |           |       |   |      |  |  multiple short options\n      |           |       |   |      |  |\n      |           |       |   |      |  short option\n      |           |       |   |      |\n      |           |       |   |      oparg\n      |           |       |   |\n      |           |       |   long option\n      |           |       |\n      |           |       command\n      |           |\n      |           global long option\n      |\n      program name\n\nCommand-lines are a sequence of strings separated by\nwhitespace.  The meaning of each string can depend\nboth on the position of the string and the characters\nin the string itself.\n\nAn *argument* is any whitespace-delimited string on the\ncommand-line that doesn't start with a `-` (minus sign).\nUnless it's an *oparg*--which we'll talk about in a minute--the\nmeaning of an argument is defined by its position.  For example,\nif you ran:\n\n    fgrep WM_CREATE window.c\n\n`WM_CREATE` and `window.c`\nwould be *arguments;* the first argument, `WM_CREATE`,\nwould be the string you wanted to search for, and `window.c`\nwould be the name of the file you wanted to search.\n\nA *command* is a special kind of argument some programs\nuse to specify what function you want the program to perform.\nA good example of a program that uses commands is `git`;\nwhen you run `git add` or `git commit`, `add` and `commit`\nare both *commands.*  The command is always the first\nargument to a program that uses them.\n\nIf a string on the command-line starts with a `-` (minus\nsign), that's an *option*.  There are two styles of\noption: *short options* and *long options.*\n\n*Short options* start with a single dash, `-`.  This is\nfollowed by one or more individual characters, which\nare the short option strings.  In the above example,\nwe specify two sets of short options: the first is `-v`,\nthe second is `-xz`.  You can combine options togther,\nand it's the same as specifying them separately.  We\ncould have said `-vxz`, or `-v -x -z`; these both do\nthe same thing.  When we talk about short options, we\nsay the word \"dash\" followed by the letter.  For example,\n`-v` would be pronounced \"dash v\".\n\n*Long options* start with two dashes, `--`.  Everything\nafter the two dashes is the name of the option.  In the\nabove example, we can see one long option, `--flag`.\nAgain, when we talk about long options, we say the\ndashes out loud, followed by the words from the option.\nFor example, `--flag` would be pronounced \"dash dash flag\".\n\nBoth types of options can optionally take one (or more)\narguments of their own.  An argument to an option is\ncalled an *oparg.*  In the above example, the long option\n`--flag` takes the oparg `ro`.\n\nFinally, there are *global options* and *command\noptions.*  Global options apply to the entire\nprogram, are always available, and are specified\n*before* the command.  Command options are\ncommand-specific, and appear *after* the command.\nGlobal options can be long options or short options;\ncommand options can be long options or short options, too.\n\n\n### Remapping Python To The Command-Line\n\nNow let's consider a Python function call:\n\n```Python\ndef fgrep(pattern, filename, *, ignore_case=False):\n    ...\n```\n\nWe can draw some similarities between Python\nfunction calls and command-lines.\n\nFor example, they both support arguments where\nposition is significant.  A command-line *argument*\nis similar to a Python function *positional*\nparameter, in that they're both identified by\nposition.\n\nPython function calls and command-lines also\nboth support arguments identified by name.\nA command-line *option* is similar to a Python\n*keyword-only* argument.\n\nThis leads us to the fundamental concept behind Appeal.\nWith Appeal, you write a Python function, and tell\nAppeal that it represents a *command.*  Appeal\nexamines the function, translating its parameters into\ncommand-line features.  Positional parameters become\ncommand-line arguments, and keyword-only parameters\nbecome options.\n\n(Technically, Appeal translates both *positional parameters*\nand *positional-or-keyword parameters* into arguments.\nFor the sake of clarity and consiseness, I'll always\nrefer to these collectively as *positional parameters.)*\n\n\n## Hello, World!\n\nLet's see Appeal in action, with our first example.\nIn all our examples we're going to assume your program\nis called `script.py`.  Let's say `script.py` looked like\nthis:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef hello(name):\n    print(f\"Hello, {name}!\")\n\napp.main()\n```\n\nIf you now ran `python3 script.py help hello`, you'd\nsee usage information for your `hello` command.\nIt'd start like this:\n\n    usage: script.py hello name\n\nAlready, a lot has happened!  Let's go over it piece by piece:\n\n* We created an `Appeal` object called `app`.\n  This object will handle processing the command-line\n  and calling the appropriate command function.\n* We decorated the function `hello()` with `@app.command()`,\n  a method call on our Appeal object.\n  This tells Appeal that `hello()` should be a\n  *command*, using the name of the function as the\n  command string, and translating the function's\n  parameters into the command-line parameters.\n  So our command-line command is called `hello`.\n  We call a function decorated with `@app.command()`\n  a *command function.*\n* Our `hello()` command function takes one positional\n  parameters, `name`.  Therefore, our `hello` command\n  on the command-line takes one positional argument,\n  which we identify as `name` in the usage string.\n* Appeal also automatically created simple help for our\n  program, displaying *usage* information.  Usage shows\n  you what command-line options and arguments the command\n  will accept.\n\nSo!  If you ran this command at the command-line:\n\n    % python3 script.py hello world\n\nAppeal would call your `hello()` function like this:\n\n```Python\nhello('world')\n```\n\nand you'd be rewarded with:\n\n    Hello, world!\n\nThe return value from your command function is the return\ncode for your program.  If you return `None` or `0`, that's\nconsidered success; returning a non-zero integer indicates\nfailure.  (And if your function exits without a return\nstatement, Python behaves as if your function ended with\n`return None`.)\n\n\n## Default Values And `*args`\n\nLet's change up our example, and add an optional parameter:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(pattern, filename=None):\n    print(f\"fgrep {pattern} {filename}\")\n\napp.main()\n```\n\nNow our command is called `fgrep`, and it takes two parameters.\nThe second one, `filename`, is optional, with a default value of `None`.\n\nYou can of course specify both parameters yourself.  Running this:\n\n    % python3 script.py fgrep WM_CREATE window.c\n\nresults in Appeal calling your `fgrep()` function like this:\n\n```Python\nfgrep('WM_CREATE', 'window.c')\n```\n\nBut you can also omit the `filename` parameter.\nIf you run this command at the command-line:\n\n    % python3 script.py fgrep WM_CREATE\n\nAppeal would call `fgrep()` like this:\n\n```Python\nfgrep('WM_CREATE', None)\n```\n\nActually that's not 100% accurate.  When Appeal\nbuilds the arguments to call your `fgrep()` function,\nit only passes in the arguments you passed in on the\ncommand-line.  So actually Appeal calls your `fgrep()`\nfunction like this:\n\n```Python\nfgrep('WM_CREATE')\n```\n\nAnd it's Python that sets the `filename` parameter to `None`.\n\nWhat else can Appeal command functions do?  Well, they can\nhave a `*args` parameter. Naturally, a command function that\ntakes `*args` (internally called a *var_positional*\nparameter) can accept as many positional arguments as the\nuser wants to supply.  Here's a demonstration:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(pattern, *filenames):\n    print(f\"fgrep {pattern} {filenames}\")\n\napp.main()\n```\n\nNow the user could pass in no filenames, one filename,\nfifty filenames--as many as they want!  They'd all be\ncollected in a tuple and passed in to `fgrep()` in the\n`filenames` parameter.\n\n\n## Options, Opargs, And Keyword-Only Parameters\n\nNow let's examine what Appeal does with keyword-only\nparameters.  Let's add three keyword-only parameters\nto our example:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(pattern, *filenames, color=\"\", number=0, ignore_case=False):\n    print(f\"fgrep {pattern} {filenames} {color!r} {number} {ignore_case}\")\n\napp.main()\n```\n\nNow the `fgrep` command-line usage looks like this:\n\n    usage: script.py fgrep [-c|--color str] [-n|--number int] [-i|--ignore_case] pattern [str]...\n\nAgain, a lot just happened.\n\nFirst, I'll remind you, keyword-only parameters\nare presented as options on the command-line.\nAppeal automatically took each keyword-only parameter,\nadded `'--'` to the front of the parameter name,\nand turned that into an option.  (Also, if the parameter\nname has any underscores, Appeal turns those into dashes.)\n\nSecond, Appeal also automatically uses the first letter of a\nkeyword-only argument as a short option.  So the\n`color` keyword-only parameter becomes both the `--color`\n*and* `-c` options.  When running your program, the user\ncan use `-c` or `--color` interchangably.  The same goes\nfor `-i` and `--ignore_case`, and for `-n` and `--number`.\n\n(What if you have two keyword-only parameters that start\nwith the same letter?  The first one gets the short option.\nIf we added a keyword-only parameter named `credit` to the\nend of `fgrep()`'s parameter list, Appeal would map `color`\nto `--color` and `-c`, but only map `credit` to `--credit`.)\n\nThird, options are *always optional.*\n(As a pedantic wag might put it--\"the clue's right there in the name.\")\nTherefore, in Appeal, keyword-only\nparameters to command functions must *always* have a\ndefault value.  (Python programmers usually have default\nvalues for their keyword-only parameters anyway, so this\nrequirement isn't a big deal.)\n\nFourth, notice that `--color` takes an argument, or *oparg.*\nAppeal noticed that the `color` parameter had a default\nvalue of `\"\"`--its default value is a `str`.\nSo Appeal infers that you want the user to supply an oparg\nto `--color`.  If the user specifies `--color` on the\ncommand-line, it must be followed by an oparg, and Appeal\nwill take the string off the command-line and pass it\nstraight into the `color` parameter.\n\nFifth, `--number` also takes an oparg, but it has a default of `0`.\nAppeal infers from that that `--number` should be an `int`.\nAppeal automatically converts the string from the command-line\ninto a Python object for you, using the type of the default value.\n(Appeal did that for `--color` too--except `--color` takes a str,\nso no conversion is necessary.)  When the user provides an oparg\nto `--number` on the command-line, it must be followed by an\noparg; Appeal will take that oparg, pass it in to `int`, then take\nthe return value from `int` and pass it in to the `number` parameter.\n\nFinally, `ignore_case` has a default value of `False`.\nBoolean values for options are a special case: they don't\ntake an oparg. All they do is negate the default value.\nSo if the user specifies `-i` once on the command-line,\nAppeal would pass `True` in to the `ignore_case` parameter.\n\n(By the way, a default value of `None` is a second\nspecial case.  If a positional or keyword-only parameter\nhas a default value of `None`, Appeal behaves as if the\ntype of the default is `str`.  It consumes an argument\nor oparg from the command-line and passes it in unchanged\nto that parameter.)\n\nLet's put it all together!  If you ran this command at the command-line:\n\n    % python3 script.py fgrep -i --number 3 --color blue WM_CREATE window.c\n\nAppeal would call `fgrep()` like this:\n\n```Python\nfgrep('WM_CREATE', 'window.c', color='blue', number=3, ignore_case=True)\n```\n\nAnd if you ran this command at the command-line:\n\n    % python3 script.py fgrep --color green boogaloo\n\nAppeal would call `fgrep()` like this:\n\n```Python\nfgrep('boogaloo', color='green')\n```\n\n\n## The Global Command, Subcommands, And The Default Command\n\nMany programs that support \"commands\" also have\n\"global options\".  Global options are options\nspecified on the command-line *before* the command.\nFor example, in the example command-line at the top\nof this document, `script.py` takes a `--debug`\noption specified before the command--which makes it\na \"global option\".\n\nAppeal supports global options, too.  It's simple:\nwrite your command function like normal, but\ninstead of decorating it with `Appeal.command()`, decorate\nit with `Appeal.global_command()`.  Appeal will process all\nthose options before the command, and call your global\ncommand function.\n\n`Appeal.global_command()` also gets used for programs that\ndon't use \"commands\".  Although the \"command\" command-line\nparadigm is popular these days, most programs don't bother\nwith them.  For example, `ls`, `grep`, and... hey! `python`\nitself!  None of these programs support commands, but they\nall support command-line arguments and options.\n\nNaturally, Appeal supports this behavior.  Simply decorate\none function with `Appeal.global_command()` and don't add\nany command functions.\n\nOn the flip side of this coin, Appeal also supports\n*subcommands*.  This is a common feature of command-line\nparsing libraries, though it's rarely-used in practice.\nThe idea is, your command can *itself* be followed by\nanother command.\n\nTo add a subcommand to your Appeal instance, just\ndecorate your command function with two chained\ncommand calls, specifying the name of the existing\ncommand in the first call, like so:\n\n```Python\n@app.command()\ndef db(...):\n    ...\n\n@app.command(\"db\").command()\ndef deploy(...):\n    ...\n```\n\nThis adds a `deploy` subcommand under the `db` command.\nSo now the whole command-line looks something like this:\n\n    script.py [global arguments and options] db [db arguments and options] deploy [deploy arguments and options]\n\nFinally, what should Appeal do if your program\ntakes commands, but the user doesn't supply one?\nThat's what the *default command* is for.  The\ndefault command is a command function Appeal will\nrun for you if your Appeal instance has commands,\nand the user doesn't supply one.  For example,\nif `script.py` has ten different commands, but the\nuser just runs\n\n    script.py\n\nwithout any arguments, Appeal would run the default\ncommand.\n\nIf you don't specify a default command, Appeal has\na built-in default *default command*.  The default *default\ncommand* raises a usage error, which means it prints basic help\ninformation and exits.\n\nTo specify your own default command, just decorate a\ncommand function with the `Appeal.default_command()` decorator.\nFor example, if you wanted your program to run the `status`\ncommand when the user didn't specify a command, you could\ndo this:\n\n```Python\n@app.default_command()\ndef default():\n    return status()\n```\n\nNotice that the default command doesn't take any arguments\nor options.  It simply can't accept any, by definition.\n\n(If the user specified options\nwithout a command, they'd be considered \"global options\"\nand would be processed by the global command.  And if the\nuser specified an argument, that would automatically be the\nname of the command to run.)\n\nAnd yes, subcommands can have a default command too:\n\n```Python\n@app.command('db').default_command()\ndef db_default():\n    return db_status()\n```\n\n## Annotations And Introspection\n\nPython 3 supports annotations for function parameters, meant\nto conceptually represent types.  Appeal supports annotations\ntoo; they explicitly tell Appeal what type of object a parameter\nrequires.  For example:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(pattern, *filenames, id:float=None):\n    print(f\"fgrep {pattern} {filenames} {id}\")\n\napp.main()\n```\n\nHere `id` has a default value of `None`, but it also has\nan explicit annotation of `float`.   If the user uses `--id`\non the command-line, it must be followed by an oparg,\nwhich Appeal will convert to a Python object by calling `float`.\n(And, as you can see, the annotation and the type of the default\ndon't *necessarily* have to agree... although it's usually a\ngood idea.)\n\nAlthough annotations are *meant* to represent types, Appeal\nactually accepts any callable--it can be a type, or a\nuser-defined class, or just a regular function.  Appeal\ncalls these annotations *converters.*\n\nHere's how Appeal decides on the converter for a parameter,\nfrom highest-priority to lowest-priority:\n\n* If the signature for that parameter has an annotation,\n  Appeal uses the annotation as the converter.\n* If the signature for that parameter *doesn't* have an\n  annotation, but *does* have a default value, Appeal\n  will use `type(default)` as the converter in most cases.\n  The exceptions:\n  - If `type(default)` is `NoneType`, Appeal will use `str`\n    instead.\n  - If `type(default)` is `bool`, and the parameter is a\n    keyword-only parameter, Appeal will use a special internal\n    class that implements the special-case \"negate the default\"\n    behavior for options with boolean default values.\n* If the signature for that parameter lacks both an annotation\n  *and* a default value, Appeal uses `str` as the converter.\n\nConverters are surprisingly flexible.\nFor example, Appeal will introspect the converter for a\nkeyword-only parameter and map all its positional arguments\ninto opargs.  That's how Appeal supports options that take\n*multiple opargs:* you simply annotate the keyword-only\nparameter with a converter that takes *multiple arguments.*\nAppeal will also pay attention to the annotations for the\nconverter's own arguments, and use those to convert the\nstrings from the command-line into Python objects.\n\nLet's tie it all together with another example:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\ndef int_and_float(integer: int, real: float):\n    return [integer*3, real*5]\n\n@app.command()\ndef fgrep(pattern, *filenames, position:int_and_float=(0, 0.0)):\n    print(f\"fgrep {pattern} {filenames} {position}\")\n\napp.main()\n```\n\nHere, Appeal would introspect `fgrep()`, then also\nintrospect `int_and_float()`.  The resulting usage\nstring would now look like this:\n\n    usage: script.py fgrep [-p|--position integer real] pattern [filenames]...\n\n`--position` takes *two* opargs.  Appeal would\ncall `int` on the first one and `float` on the second\none.  It would then call `int_and_float()` with those\nvalues, and the return value of `int_and_float()` would\nbe passed in to the `position` parameter on `fgrep()`.\n\nSo now if you ran:\n\n    % python3 script.py fgrep -p 2 13 funkyfresh\n\nAppeal would call:\n\n```Python\nfgrep('funkyfresh', position=[6, 65.0])\n```\n\nFinally, let's change the example to demonstrate something\nelse: although converters can be any callable, user-defined\nclasses work fine too.  And Appeal can correctly infer the\ntype based on the default value for any type.  So consider\nthis example:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\nclass IntAndFloat:\n    def __init__(self, integer: int, real: float):\n        self.integer = integer * 3\n        self.real = real * 5\n\n    def __repr__(self):\n        return f\"<IntAndFloat {self.integer} {self.real}>\"\n\n@app.command()\ndef fgrep(pattern, *filenames, position=IntAndFloat(0, 0.0)):\n    print(f\"fgrep {pattern} {filenames} {position}\")\n\napp.main()\n```\n\nThis example behaves essentially the same as the previous example\nin this section, except the formatting of `position` is slightly\ndifferent.  But the command-line usage is exactly the same!\nAppeal inferred the converter for `position` based on the type\nof its default value, then introspected that type to determine\nhow many opargs it should consume from the command-line and how\nto convert them.\n\n\n> **An important note about annotations**\n>\n> If you use static type analysis in your project,\n> your static type analyzer may not appreciate you\n> using normal Python functions as annotations.\n> Depending on the behavior of your static type analyzer,\n> you may need to decorate your Appeal command functions\n> and converters with `@typing.no_type_check()`.  If you\n> only ever use types and classes this shouldn't be\n> necessary.\n>\n> Also, Appeal doesn't understand \"type hint\"\n> annotations.  It expects annotations to be callables,\n> like functions or classes or types.  It should be\n> possible to add limited support in the future.\n>\n> Finally, Appeal uses function calls and related\n> snazzy technology in annotations--but many static\n> type checkers expect annotations to conform strictly\n> to only what is used for \"type hints\".  So it's\n> possible static type checkers may abort processing\n> in a file with advanced Appeal configuration.\n> It may be best to mix \"type hints\" and Appeal\n> in the same Python script, and to not run your\n> static type checker on scripts with Appeal code.\n\n\n## Converter Flexibility\n\nYou can use almost any function as an annotation...\nwithin reason.  Appeal will introspect your annotation,\ndetermine its input parameters, and call it to convert\nthe command-line argument into the argument it passes\nin to your command function.\n\nFor example, what if you wanted an option that accepted\na string which gets broken up based on a delimiter substring?\nThis is a common idiom for `configure` scripts on UNIX-like\nplatforms; for example,\n[Python's own `configure` script](https://github.com/python/cpython/blob/3.9/configure)\nsupports this option:\n\n    --with-dbmliborder=db1:db2:...\n\nHappily that's easy to do in Appeal.  Just write a converter\nfunction that accepts a string, breaks it into substrings\nhowever you like, and returns the list.\n\nAlthough... you don't need to bother!  Appeal also provides\na converter that does it for you, called `appeal.split()`.\nYou pass in as many delimiter strings as you want, and\n`appeal.split()` will split the command-line across all of\nthem.  (If you don't specify any delimiters, `appeal.split()`\nwill split at every whitespace character.)\n\n\n## Specifying An Option More Than Once\n\nOne thing you might have noticed by now: the interfaces\nyou've seen only allow Appeal to handle command-lines\nwhere an option can be specified either zero times or\none time.  What if you want the user to be able to\nspecify an option three times?  Or ten?  That's what the\n`MultiOption` class is for.  `MultiOption` objects\nare converters that allow options to be specified\nmultiple times.\n\n`MultiOption` isn't useful by itself; it's only an\nabstract base class.  To make use of it you'll\nneed to use a subclass--or create your own.\n\nThis time, let's start with some examples.  Appeal\nprovides three useful subclasses of `MultiOption`:\n`counter`, `accumulator`, and `mapping`.\n\nFirst, let's look at `counter`.  `counter`\nsimply counts the number of times an option is\nspecified on the command-line.  This is a somewhat\ncommon idiom for \"verbose\" options; a program\nthat supports `-v` to mean *verbose* may allow\nyou to specify `-v` more than once to make\nit *more* verbose.  Here's how you'd do that\nwith Appeal:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(*, verbose:appeal.counter()=0):\n    print(f\"fgrep verbose={verbose!r}\")\n\napp.main()\n```\n\nIf the user ran\n\n    % python3 script.py fgrep\n\nAppeal would call\n\n```Python\nfgrep()\n```\n\nallowing Python to pass in the default value of `0` to `verbose`.\nAnd if the user ran\n\n    % python3 script.py fgrep -v --verbose -v\n\nAppeal would call\n\n```Python\nfgrep(verbose=3)\n```\n\n`accumulator` handles options that take a single oparg.\nIt remembers them all and returns them in a single array.\nLike so:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(*, pattern:appeal.accumulator=[]):\n    print(f\"fgrep pattern={pattern!r}\")\n\napp.main()\n```\n\nIf the user ran\n\n    % python3 script.py fgrep --pattern three -p four --pattern fiv5\n\nAppeal would call\n\n```Python\nfgrep(pattern=['three', 'four', 'fiv5'])\n```\n\nWhat if you don't want strings, but another type?  Using crazy\nscience magic from the future, `accumulator` is actually\nparameterized.  You can say:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef fgrep(*, pattern:appeal.accumulator[int]=[]):\n    print(f\"fgrep pattern={pattern!r}\")\n\napp.main()\n```\n\nand now the opargs to `--pattern` will all be converted using int.\n\nYou can even specify multiple types as arguments to the\nparameterized version of `accumulator`, separated by commas.\nThe option will then require multiple opargs and convert\nthem to the types specified.\n\n`mapping` is like `accumulator` except it returns a\n`dict` instead of a `list`.  An option annotated with `mapping()`\nconsumes *two* positional arguments from the command-line;\nthe first one is the key, the second one is the value.\n(You can also parameterize `mapping` the same way you parameterize\n`accumulator`, though you can only specify exactly two types.)\n\n\nOf course, you can also subclass `MultiOption` to make your own\nconverter classes with custom behavior. `MultiOption` subclasses\ncan override these three methods:\n\n```Python\nclass Option:\n\n    def init(self, default):\n        ...\n\n    def option(self, ...):\n        ...\n\n    def render(self):\n        ...\n```\n\nWell, actually, subclasses are *required* to override\n`option()` and `render()`.  But `init()` is optional.\n\nIf you then specify a subclass of `MultiOption` as an\nannotation on a keyword-only parameter of an\nAppeal command function, several things happen:\n\n* If that option is specified one or more times on\n  the command-line, Appeal will instantiate exactly\n  one of these objects and call its `init()` method.\n* Every time the user specifies that option on\n  the command-line, Appeal will call the `option()`\n  method on the object.\n* After finishing processing the command-line,\n  Appeal will call the `render()` method on the\n  object, and pass the value it returns as the\n  argument to that keyword-only parameter.\n\nThe most powerful part of this interface: you can\nredefine `option()` to suit your needs--it supports\nthe same sort of polymorphism as annotations do.\nAppeal will introspect your `option()` method to\ndetermine how many opargs to consume from the\ncommand-line, and how to convert them.\n\nLet's demonstrate all this with another example.\nIf you want your option to take two opargs,\nwith one being an `int` and the other being\na `float`, you would define `option()` in your\nsubclass as:\n\n```Python\nclass MyMultiOption(appeal.MultiOption):\n\n    def option(self, a:int, b:float):\n        ....\n```\n\nEvery time the user specified your option,\nit would take two opargs, and they would be\nconverted into an `int` and a `float` before\ncalling your `option()` method.  It's up to\nyou to decide how to store them, and how to\nrender them into a single value returned\nby your `render()` method.\n\n`MultiOption` is a subclass of a general\n`Option` class.  `Option` behaves identically\nto `MultiOption`, except it only permits\nspecifying the option once on the command-line.\n(Which means it will only your `option()`\nmethod once.)\n\n\n## Data Validation\n\nWhat if you want to restrict the data the user provides\non the command-line?  That's simple, just use a converter!\nAppeal provides a couple sample converters for data validation,\nbut it's easy to write your own.\n\nThe classic example is a parameter where you can only use one\nof a list of values.  For that, you can use Appeal's `validate()`\nconverter.  For example, this command restricts the `direction`\nparameter to one of six canonical directions:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\ndef go(direction:appeal.validate('up', 'down', 'left', 'right', 'forward', 'back')):\n    print(f\"go direction={direction!r}\")\n\napp.main()\n```\n\nYou can pass in an explicit type using a `type=`\nnamed argument to `validate()`; if you omit it,\nit uses the type of the first argument.\n\nAppeal also has a built-in range validator\ncalled `validate_range()`.  It takes `start`\nand `stop` arguments the same way Python's\n`range()` function does. Note that `validate_range()`\ndiffers from Python's `range()` in one subtle way:\nvalues *equal* to `stop` are allowed.\n\nIf you prefer, you can \"clamp\"\nthe value the user passed in to the range,\nby supplying the argument `clamp=True` to\n`validate_range()`. In that case, if the value\nthe user specifies is outside the range, `validate_range()`\nwill return the closest value of either `start` or `stop`.\n\n(That's why `validate_range()` allows the\nvalue to be *equal to* `stop`.  `clamp` would\nbe annoying to use if `stop` itself was an\nillegal value--particularly if the types\nwere floats.)\n\nAppeal validation functions are straightforward to write.\nSo, if these are insufficient to your needs,\nyou can easily write your own.  Take a look\nat the implementations of `validate()` and\n`validate_range()` inside Appeal to see one way to do it!\n\n\n## Multiple Options For The Same Parameter\n\nSome programs have a set of options on their\ncommand-line that are mutually exclusive.  Consider\nthis simple-minded command-line:\n\n    go [--north|--south|--east|--west]\n\nThat is, you want the user to be able to \"go\" in\none of those four directions, but *only* one.\nHow would you do that in Appeal?\n\nEasy.  You simply define multiple options that\nwrite to the same parameter.  All the behavior\nyou've seen so far is using the *default* way of\nmapping keyword-only parameters to options.  But\nactually Appeal allows you to make your own mappings.\nYou can map a parameter as many ways as you want,\neven using different converters!\n\nTo manually define your own options, use the `Appeal.option()`\nmethod on your Appeal instance.  It's a decorator you\napply to your command function.  The first argument is\nthe name of the parameter you want the option to write\nto.  After that is one or more options you want to\nmap to this parameter.  `Appeal.option()` also takes\n`default` and `annotation` keyword-only parameters,\nallowing you to specify respectively the default value or\nannotation for this option.\n\nHere's a simple example of how to implement the above `go`\ncommand with Appeal:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\n@app.command()\n@app.option(\"direction\", \"--north\", annotation=lambda: \"north\")\n@app.option(\"direction\", \"--south\", annotation=lambda: \"south\")\n@app.option(\"direction\", \"--east\",  annotation=lambda: \"east\")\n@app.option(\"direction\", \"--west\",  annotation=lambda: \"west\")\ndef go(*, direction='north'):\n    print(f\"go direction={direction!r}\")\n\napp.main()\n```\n\nAll these annotations return a string.  But actually you can\nreturn any type you want--and you can even map multiple\nannotations that return different types to the same parameter.\nYou can even annotate with a `MultiOption` to allow specifying\nthat option multiple times!\n\nNote that, whenever you use the `option()` decorator\nto map your own options onto a parameter, Appeal won't add\nits default options for that parameter.  It'll only have\nthe options you explicitly set.  Which means, for example,\nthat in the sample code above, there aren't any short options\nfor the options we created.  `-n` won't work, only `--north`.\n\nOne final thing.  Your command function can accept `**kwargs`\ntoo.  The only things that will go into it are options you\ncreate with `Appeal.option()`, which map to parameters that\ndon't otherwise exist.\n\n\n## Recursive Converters\n\nYou already know that you can pass in a converter that takes\nmultiple arguments, and Appeal will consume multiple arguments\nfrom the command-line to fill it.  And if the arguments to that\nconverter have annotations, Appeal will call those functions to\nconvert the command-line argument into the type your converter\nwants.\n\nBut what if you did... *this?*\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\ndef int_float(i: int, f: float):\n    return (i, f)\n\ndef my_converter(i_f: int_float, s: str):\n    return [i_f, s]\n\n@app.command()\ndef recurse(a:str, b:my_converter=[(0, 0), '']):\n    print(f\"recurse a={a!r} b={b!r}\")\n\napp.main()\n```\n\nThe `my_converter()` parameter `i_f` is a positional\nparameter with an annotation that, itself,\n*takes two positional parameters.*\n\nWould it surprise you to know--yes, it actually works!\n\nConverters have been fully recursive this *whole time.*\nActually this fact has been hiding in plain sight\nall along--all the examples using `int_and_float()` are recursive\ntoo, because `int_and_float()` has parameters annotated with\n`int` and `float`.  Of course, those functions only take\na single string argument; `my_converter()` takes two\nannotated positional parameters.\nBut the principles remain the same.\n\nStill, this is a more complex situation than we've seen before.\n`recurse` takes a positional parameter `b` that has a default\nvalue, but its converter takes multiple positional parameters,\nand one of those *also* has a converter that takes multiple\npositional parameters.  How does Appeal map this to the\ncommand-line?\n\nAppeal \"flattens\" the tree of converter functions into a linear\nseries of arguments and options.  In this case the usage string\nwould look like this:\n\n    recurse a [i f s]\n\nThis tells you the `recurse` command takes either one or four command-line\narguments.  That optional group of three command-line arguments\nhas a special name in Appeal: it's an \"argument group\".\nTechnically, Appeal views this command-line as taking two\n\"argument groups\": the first group is required, and consumes\none command-line argument; the second group is optional, and\nconsumes three command-line arguments.\n\n(We actually saw our first \"argument group\" in the\nsecond example in the\n**Annotations And Introspection** section above, but\nthat time the argument group was an oparg.)\n\nNow let's add an option and see what changes:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\ndef int_float(i: int, f: float):\n    return (i, f)\n\ndef my_converter(i_f: int_float, s: str, *, verbose=False):\n    return [i_f, s, verbose]\n\n@app.command()\ndef recurse2(a:str, b:my_converter=[(0, 0), '', False]):\n    print(f\"recurse2 a={a!r} b={b!r}\")\n\napp.main()\n```\n\nNow the usage looks like this:\n\n    recurse2 a [i [-v|--verbose] f s]\n\nNotice the way Appeal renders it in the usage\nstring--the options aren't created until *after* the first\nargument in the optional argument group.  This may seem\nstrange but that's how it works.  That's how it *has* to work.\n\nWhy?  From a high conceptual level, Appeal doesn't know that\nyou've \"entered\" the optional argument group until it\nsees the user supply the first argument for that group.\nSo it doesn't create the options defined in that group\nuntil after the first argument.\n\nThis high conceptual level corresponds exactly to how Appeal\ncalls your function.  Consider, if the user runs this command:\n\n    recurse2 xyz\n\nAppeal calls your function like so:\n\n```Python\nrecurse2('xyz')\n```\n\nSince Appeal never called `my_converter()`, it can't\nmap `--verbose`.  It can only map `--verbose` once it\nknows it's going to call `my_converter()`, and that\nonly becomes true the moment you supply that second\ncommand-line argument.\n\nOnce you *do* supply that second command-line argument,\nyou have to supply two more, for a total of four.\n\n    recurse2 pdq 1 2 xyz\n\nAppeal calls your function like so:\n\n    recurse2('pdq', my_converter(int('1'), float('2'), xyz))\n\n    recurse2 pdq 1 2 xyz\n\nAnd in this example, you can supply the `-v` or `--verbose` anywhere *after*\nthe second parameter.  So if your command-line looks like this:\n\n    recurse2 pdq 1 2 xyz -v\n\nAppeal calls `recurse()` like this:\n\n```Python\nrecurse2('pdq', my_converter(int('1'), float('2'), xyz, verbose=True))\n```\n\n\nTake a look back at all the examples in this document, and consider\nthat anywhere you specify a function or type, you can pass in nearly\nany callable you like.\n\nFor example, the parameterized version of `mapping` isn't limited just to simple types.\nIf you used `mapping[str, int_float]` as the annotation\nfor a keyword-only parameter, that option would consume\nthree arguments on the command line: a `str`, an `int`, and\na `float`, and the dictionary would map strings to 2-tuples\nof ints and floats.\n\nNow you're starting to see how powerful Appeal's converters\nreally are!\n\n\n## Now Witness The Power Of This Fully Armed And Operational Battle Station\n\nBut recursive converters are just the beginning!\n\n> Buckle your seatbelt, Dorothy--because Kansas is going bye-bye.\n>\n> --Cypher, \"The Matrix\" (1999)\n\n### Options that map other options\n\nWhat if you did... *this?*\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\ndef my_converter(a: int, *, verbose=False):\n    return [a, verbose]\n\n@app.command()\ndef inception(*, option:my_converter=[0, False]):\n    print(f\"inception option={option!r}\")\n\napp.main()\n```\n\nWoah, that works too!  We've created an option that\n*itself* takes an option.  If you run `fgrep --option`,\nyou can now also specify `-v` or `--verbose`--but only\n*after* you've specified `--option`.\n\nIn case you're wondering: `Appeal.option()` must\ndecorate the function that takes the parameter you're\nmapping an option *to.*  So if you want to define\nexplicit options for the `verbose` parameter to\n`my_converter` in the above example, you'd\ndecorate `my_converter` with `Appeal.option()` calls,\nnot `inception`.  (This also means, everywhere you\nuse `my_converter` as a converter, it will behave\nthe same, including taking the same options.)\n\n### Multiple options that aren't MultiOptions\n\nWe're just getting started!  How about this:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\ndef my_converter(a: int, *, verbose=False):\n    return [a, verbose]\n\n@app.command()\ndef repetition(*args:my_converter):\n    print(f\"repetition args={args!r}\")\n\napp.main()\n```\n\nThat works too, and I bet you're already guessing what it\ndoes.  This version of `weird` accepts as many `int` arguments\nas the user wants to specify on the command-line, and *each one*\ncan optionally take its own `-v` or `--verbose` flag.\n\n### Positional parameters that only consume options\n\nI'll give you one more crazy example:\n\n```Python\nimport appeal\napp = appeal.Appeal()\n\nclass Logging:\n    def __init__(self, *, verbose=False, log_level='info'):\n        self.verbose = verbose\n        self.log_level = log_level\n\n    def __repr__(self):\n        return f\"<Logging verbose={self.verbose!r} log_level={self.log_level}>\"\n\n@app.command()\ndef mixin(log:Logging):\n    print(f\"mixin log={log!r}\")\n\napp.main()\n```\n\nCan you guess what usage for `mixin` looks like?  (Probably!)\nIt looks like this:\n\n    mixin [-v|--verbose] [-l|--log-level str]\n\nEven though `log` is a positional parameter, it doesn't consume\nany positional arguments on the command-line.  The `Logging`\nconverter only adds options!  This is what object-oriented\nprogrammers might call a \"mix-in\".  With the `Logging` converter,\nyou can add logging options to every one of your commands, without\nhaving to re-implement it each time.  (Though in most cases it's\nprobably better to add such options to a global command function.)\n\nInternally this works exactly like you'd expect.  Since the\n`log` parameter consumes no command-line arguments, Appeal will\nalways call its converter.  Specifying any of the options will\nset arguments for that call.  And the resulting `Logging` object\nwill be passed in as the argument to `log`.\n\n\nWhat's really going on here is that, from Appeal's perspective,\n*there's no difference between a \"command function\" and a\n\"converter\".*  A command function is just a converter that\nhappens to be mapped to a command.  So anything you can do\nwith a command function, you can do with a converter too.\nA converter can define options, it can be decorated with\n`app.option()` (or `app.argument()` which we haven't\ndiscussed yet), it can have accept any kind of parameter defined\nby Python, and any parameter can use (almost) any converter.\nAnd those converters can recursively use other converters.\n\nRealy, anything can be used with anything:\n\n* Converters for positional parameters\n  can take positional parameters, or keyword-only parameters, or `*args`, or `**kwargs`.\n* Converters for keyword-only parameters\n  can take positional parameters, or keyword-only parameters, or `*args`, or `**kwargs`.\n* Converters for `*args`\n  can take positional parameters, or keyword-only parameters, or `*args`, or `**kwargs`.\n* Command functions can use any converter.\n* The global command function can use any converter.\n\nBy *now* you can see the expressive power Appeal gives you.\nOf course, you'll rarely use only a fraction of that power.\nBut it's reassuring to know that, whatever command-line API\nmetaphor you want to express, it's not just *possible* in\nAppeal--it's *easy.*\n\n\n## Classes, Instances, And Preparers\n\nMaybe you've noticed--all the examples so far have used\nstandard Python functions as Appeal commands.  What about\nmethod calls?  Can you use those for commands?  The answer\nis, yes of course!  But it's slightly more complicated.\n\nAppeal's whole purpose in life is to call functions by\npulling data from the command-line.  Whenever it sees a\npositional parameter on a function, it thinks \"okay, I'm\ngonna have to supply an argument to that\".  So if you map\nan *unbound* method call to a command:\n\n```Python\nclass MyApp:\n    @app.command()\n    def sum(self, *operands: int):\n        return sum(*operands)\n```\n\nAppeal would see the `self` parameter and think \"aha! I\nneed to pass a string in there!\"  We need to prevent\nAppeal from seeing that parameter in the first place.\n\nThere are two major techniques to handle this.  The first\nis straightforward, if a bit inflexible: create the instance\nof your class first, then call `app.command()()` on the\nbound instances.  Like this:\n\n```Python\napp = appeal.Appeal()\nclass MyApp:\n    def sum(self, *operands: int):\n        return sum(*operands)\n\no = MyApp()\napp.command()(o.sum)\napp.main()\n```\n\nSince you pass in the already-bound method to Appeal, it doesn't\neven *see* the `self` parameter in the signature.  (The signature\nof a bound method doesn't include the `self` parameter.)\n\nThis works fine... but maybe it looks a little weird.  We're no\nlonger decorating functions (or methods), instead we're calling\nthe decorator function directly and passing in the bound method.\nIt also restricts us to one instance of `MyApp` per Appeal\ninstance, which might be restrictive.\n\nThe other technique uses a little magic to provide a convenient\nand familiar-looking interface.  `Appeal.app_class()` gives you\ntwo decorators; you use one to decorate your class, and the\nother to decorate methods in the class.  Appeal will instantiate\nyour class for you, and use your `__init__` method as your app's\n\"global command\" to handle global options!\n\n```Python\nimport appeal\n\napp = appeal.Appeal()\napp_class, command_method = app.app_class()\n\n@app_class()\nclass MyApp:\n    def __init__(self, *, verbose=False):\n        print(f\"MyApp init verbose={verbose!r}\")\n        self.verbose = verbose\n\n    def __repr__(self):\n        return \"<MyApp>\"\n\n    @command_method()\n    def add(self, a, b, c):\n        print(f\"MyApp add self={self!r} a={a!r} b={b!r} c={c!r} self.verbose={self.verbose!r}\")\n\napp.main()\n```\n\nBehind the scenes, this uses a `CommandMethodPreparer` object\nto handle late-binding the method to the object.  Since\n`Appeal.app_class()` is a little inflexible, you may want\nto use these objects directly.  You can create one manually\nby calling `Appeal.command_method()`.  Here's an example showing\nhow to use one:\n\n```Python\nimport appeal\n\napp = appeal.Appeal()\ncommand_method = app.command_method()\n\nclass MyApp:\n    def __init__(self, id):\n        self.id = id\n\n    def __repr__(self):\n        return f\"<MyApp id={self.id!r}>\"\n\n    @command_method()\n    def add(self, a, b, c):\n        print(f\"MyApp add self={self!r} a={a!r} b={b!r} c={c!r}\")\n\nmy_app = MyApp(\"dingus\")\n\np = app.processor()\np.preparer(command_method.bind(my_app))\np.main()\n```\n\nThis is the first time you're seeing the `Processor`\nobject.  All the runtime information for processing\na command-line lives in the `Processor` object; in\nfact, `Appeal.main` and `Appeal.process` are both\nthin wrappers over their equivalent methods on the\n`Processor` object.  Moving all the runtime information\ninto the `Processor` object lets you process multiple\ncommand-lines with the same Appeal object, even\nsimultaneously!\n\nThe `CommandMethodPreparer` object is at the core of how Appeal\nhandles late-binding of methods to objects.  First,\nyou decorate the method calls of your class with this object.\nYou then call the `bind` method on that object to pass in the\ninstance of that class you want to bind those methods to--though\n`app_class()` takes care of that for you.  `bind()` returns a callable\nyou pass in to `Processor.preparer`, which binds the method to that \ninstance before Appeal calls it.\n\nUnder the covers, `CommandMethodPreparer` wraps the method\nwith a `functools.partial` object, passing in a placeholder\nobject for the `self` parameter.  Then `command_method.bind()`\nreplaces the placeholder for the real instance.  For maximum\ncompatibility, it actually uses `getattr()` to bind the\ninstance to the method.\n\n## Writing Help\n\nAppeal automatically generates *usage* for your command functions.\nBut it's up to you to write the documentation explaining what those\ncommands and arguments and options actually *do.*\n\nThere's very complete notes on how to write documentation in Appeal,\nsee `appeal/notes/writing.documentation.txt` in the Appeal source\ndistribution.  In a nutshell, you write docstring in a particular way,\nand Appeal can mechanically parse them and combine them together.\nSo you document each converter separately, and Appeal smooshes all\nthese bits of documentation together to produce the help for your\ncommand function.\n\n(One note: the main help for your program should be the docstring\nfor your Appeal instance's global command.)\n\n\n## API Reference\n\n`Appeal(help=True, version=None, positional_argument_usage_format=\"{name}\", default_options=default_options)`\n\nCreates a new Appeal instance.\n\nIf `help` is true, Appeal automatically adds help support to\nyour program:\n\n* Adds hard-coded `-h` and `--help` options that print basic help.\n* If your Appeal instance has any commands, and you haven't defined\n  a `help` command, automatically adds a `help` command.\n\nIf `version` is true, it should be a string denoting the version\nof your program.  Appeal will automatically add version support\nto your program:\n\n* Adds hard-coded `-v` and `--version` options that print\n  the version string.\n* If your Appeal instance has any commands, and you haven't defined\n  a `version` command, automatically adds a `version` command\n  which prints the version string.\n\n`positional_argument_usage_format` is the format string used\nto format positional arguments for usage.  The only valid\ninterpolations inside this string are `{name}`, which evaluates\nto the name of the parameter, and `{name.upper()}`, which evaluates\nto the upper-cased name of the parameter.  So if you want your usage\nstring to show arguments or opargs as `<name>` or `NAME`, you can\nachieve that by setting `positional_argument_usage_format` to\n`<{name}>` or `{name.upper()}` respectively.\n\n`default_options` is a callable, called when a keyword-only parameter\nfor a command function or a converter doesn't have any options\nexplicitly mapped to it.  The purpose of `default_options` is to\ncall `Appeal.option()` one or more times to create some default options\nfor that keyword-only parameter.\n\nThe API for a `default_options` callable should be:\n\n    default_options(appeal, callable, parameter_name, annotation, default)\n\n* `appeal` is the Appeal instance.\n* `callable` is the command function or converter the parameter is defined on.\n* `parameter_name` is the name of the keyword-only parameter that does\n   not have any explicitly defined options.\n* `annotation` is the annotation for this parameter.  This may\n   be explicitly set on the function, or it may be inferred from the\n   default parameter.\n* `default` is the default value for this parameter.  Since Appeal\n   requires that keyword-only parameters must always have default values,\n   this may never be `inspect.Parameter.empty`.\n\nThe return value of `default_options` is ignored.\n\nThe default value of `default_options` is `Appeal.default_options()`,\ndocumented below.\n\n\n`Appeal.command(name=None)`\n\nUsed as a decorator.  Returns a callable that accepts a single\nparameter `callable`, which must be a callable.\n\nAdds the callable as a command\nfor the current Appeal instance.  If `name` is `None`, the name of\nthe command will be `callable.__name__`.\n\n(Doesn't modify `callable` in any way.)\n\n\n`Appeal.global_command()`\n\nUsed as a decorator.  Returns a callable that accepts a single\nparameter `callable`, which must be a callable.\n\nSets the *global command* for this Appeal object.  This is\nthe command that processes global options before the first\ncommand function.\n\nCan only be set on the topmost Appeal object.  (You can't\ncall `app.command('foo').global_command()`.)\n\n(Doesn't modify `callable` in any way.)\n\n\n`Appeal.default_command()`\n\nUsed as a decorator.  Returns a callable that accepts a single\nparameter `callable`, which must be a callable.\n\nSets the *default command* for this Appeal object.  The default\ncommand is run when your Appeal instance has subcommands,\nbut the user doesn't supply the name of a command on the command-line.\n\nYour default command function must not take any parameters.\n\n(Doesn't modify `callable` in any way.)\n\n\n`Appeal.option(parameter_name, *options, annotation=empty, default=empty)`\n\nUsed as a decorator.  Returns a callable that accepts a single\nparameter `callable`, which must be a callable.\n\nMaps an option on the command-line to the parameter `parameter_name`\non the decorated function.  All subsequent positional parameters\nare options, like `--verbose` or `-v`.  (Thus, they must be strings,\neither exactly two characters long, or four or more characters long.)\n\n`annotation` is the converter that will be used if this\noption is invoked.  If no explicit `annotation` is supplied,\n`Appeal.option()` will default to `type(default)`.\n\n`default` is the default value for this option.  Since this parameter\nonly comes into play if the user specifies this option, a `default` value\nhere is nearly useless.  But it does have two uses:\n\n* If the type of the annotation is a subclass of `Option`, this default\n  value will be passed in to `Option.init()`.\n* If no `annotation` is specified, the annotation defaults to\n  `type(default)`.\n\nIt's illegal to call `Appeal.option()` without specifying a value\nfor either `annotation` or `default`.\n\nRaises `AppealConfigurationError` if any `option` has already been\nmapped inside this `Appeal` instance *with a different signature.*\n\n(Doesn't modify `callable` in any way.)\n\n\n`Appeal.argument(self, parameter_name, *, usage=None)`\n\nUsed as a decorator.  Returns a callable that accepts a single\nparameter `callable`, which must be a callable.\n\nAllos for configuration of a positional (or positional-or-keyword)\nparameter on a command function or converter.  `parameter_name` is the\nname of the parameter; it must be a parameter of the decorated `callable`.\n\nCurrently the only supported configuration is `usage`, which specifies\nthe string that will represent this parameter in usage information.\n\n(Doesn't modify `callable` in any way.)\n\n\n`Appeal.main(args=None)`\n\nProcesses a command-line and calls your command functions.\nStops at the first failure result and passes it in to `sys.exit()`.\nCatches usage errors; if it catches one, displays usage information.\nThe implementation calls `Appeal.process()`.\n\n\n`Appeal.process(args=None)`\n\nProcesses a command-line and calls your command functions.\nStops at the first failure result and returns that result.\nDoesn't catch any errors.  Useful mainly for automation,\nparticularly for testing, and as the main driver underlying\n`Appeal.main()`.\n\n\n`Appeal.default_options()`\n\n`Appeal.default_long_option()`\n\n`Appeal.default_short_option()`\n\nThese functions create the default options for a keyword-only\nparameter.  They're all valid callbacks for the `default_options`\nparameter for the `Appeal()` constructor.  `Appeal.default_options()`\nis the default value for that parameter.\n\n`Appeal.default_long_option()` creates the option `--{modified_parameter_name}`\nwith the default annotation and default value.  `modified_parameter_name` is\n`parameter_name.lower().replace('_', '-')`.\n\n`Appeal.default_short_option()` creates the option `-{parameter_name[0]}`\nwith the default annotation and default value.\n\n`Appeal.default_options()` creates both.\n\nIn all three cases, if the function isn't able to map at least one option,\nit raises an `AppealConfigurationError`.\n\nNotes on the default option semantics:\n\n* When `Appeal.default_option()` converts a keyword-only parameter\n  into a long option and a short option, Appeal copies off the first\n  character as the short option, and *then* runs a conversion function\n  on the string.  The conversion function lowercases the string and\n  converts underscores into dashes.  So for the the keyword-only\n  parameter `Define`, `Appeal.default_option()`\n  would (attempt to) create the two options `-D` and `--define`.\n  For the keyword-only parameter `block_type`, it would attempt to\n  create `-b` and `--block-type`.\n\n* What if you have multiple keyword-only parameters that have\n  the same first letter?  Only the first mapping succeeds.\n  So if you use `def myoptions(*, block_type=None, bad_block=None)`\n  as an Appeal command, `-b` will map to `block_type`.  If you\n  want it to map to `bad_block`, just swap the two keyword-only\n  parameters so `bad_block` is first, or explicitly define your\n  options by decorating your function with `Appeal.option()`.\n  (As of some recent version, Python guarantees it will maintain\n  the order of keyword-only parameters when introspecting a\n  function--and it was accidentally true in every version of\n  Python before that explicit guarantee anyway.)\n\n\n`AppealConfigurationError`\n\nAn exception.\nRaised when the Appeal API is used improperly.\n\n`AppealUsageError`\n\nAn exception.\nRaised when Appeal processes an invalid command-line.\nCaught by `Appeal.main()`, which uses it to print usage\ninformation and return an error.\n\n`AppealCommandError`\n\nAn exception.\nRaised when an Appeal command function returns a\nresult indicating an error.  (Equivalent to `SystemExit`.)\nCaught by `Appeal.main()`, which uses it to print usage\ninformation and return an error.\n\n\n## Reference\n\nThe library inspects the parameters of your function and uses\nthose for the arguments, options, and opargs of your subcommand:\n\n* Positional-only and positional-or-keyword parameters\n  (parameters before `*,` or `*args,`) map to positional\n  arguments.  This:\n\n  ```Python\n  @app.command()\n  def fgrep(pattern, file, file2=None):\n      ...\n  ```\n\n  would take two required command-line arguments, \"pattern\"\n  and \"file\", and an optional third command-line argument \"file2\".\n\n* Keyword-only parameters map to options.  They must have a default\n  value.  The name of the\n  parameter is the name of the option, e.g. this subcommand\n  accepts a `--verbose` argument:\n\n  ```Python\n  @app.command()\n  def foo(*, verbose=False):\n      ...\n  ```\n\n* If an argument to your function has an annotation, that\n  value is called to convert the string from the command-line\n  before passing in to your function.  e.g.\n\n  ```Python\n  @app.command()\n  def foo(level:int):\n      ...\n  ```\n\n  would call `int` on the string from the command-line before\n  passing it in to level.\n\n* If a parameter to your function doesn't have an annotation,\n  but *does* have a default value, it behaves as if you added\n  an annotation of `type(default_value)`.  e.g.\n\n  ```Python\n  @app.command()\n  def foo(level=0):\n      ...\n  ```\n\n  would also call `int` on the string from the command-line before\n  passing it in to `level`.\n\n  * Keyword-only parameters with a `bool` annotation or a boolean\n    default value are special: they don't take an argument.  Instead,\n    they toggle the default value.\n\n  * Parameters with a default value of `None` and no annotation\n    are also slightly special, in that they take a `str` argument\n    (as taking a `NoneType` argument doesn't make sense).\n\n  * Appeal automatically adds single-letter options for keyword-only\n    parameters when possible.  Since keyword-only parameters maintain\n    their order in Python*++*, Appeal gives the single-letter shortcut to\n    the first parameter that starts with that letter.  e.g.\n\n    ```Python\n    @app.command()\n    def foo(*, verbose=False, varigated=0):\n        ...\n    ```\n\n    `-v` would map to `--verbose`, not `--varigated`.\n\nPutting it all together: if you wanted to write an \"fgrep\" subcommand\nwith a \"usage\" string like this:\n\n    fgrep [-v|--verbose] [--level <int>] pattern [ file1 [ file2 ... ] ]\n\nyou'd write it as follows:\n\n```Python\n@app.command()\ndef fgrep(pattern, *file, verbose=False, level=0):\n    ...\n```\n\n *++* This is now guaranteed behavior in current Python, and even\n    in the Python 3 series before that, it was always true anyway.\n\n\n## Appeal And POSIX Utility Semantics\n\nThe POSIX standard defines command-line behavior for all POSIX\nutility commands, in 1003.1, Chapter 12, currently at revision POSIX.1-2017:\n\n  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html\n\nAppeal isn't a perfect match for POSIX semantics; it disallows some\nthings POSIX allows, and allows some things POSIX disallows.\n\n* As per required POSIX semantics (1003.1-2017, Chapter 12),\n  options can never be required.  It therefore follows that\n  in Appeal, keyword arguments to command functions must\n  always have a default.\n* The POSIX standard makes no mention of \"long options\",\n  so it's not clear whether or not the standard permits them.\n  (Presumably they will be permitted in a future standard.)\n* POSIX requires that options that accept/require multiple opargs\n  should accept them as a single string with either spaces\n  or commas separating the opargs.  Appeal supports this behavior\n  with `appeal.split`.  But it also permits options that consume\n  multiple separate opargs from the command-line.\n* POSIX requires that all options be specified before any positional\n  arguments.  Appeal doesn't enforce this, and will happily consume\n  options and positional arguments in any order.  In fact,\n  \"subcommands\" require permitting options after positional arguments\n  for anything beyond the simplest possible subcommand support.\n\n\n## Additional Subtle Features And Behaviors\n\n* You can specify options and arguments in any order on a\n  command-line, Appeal doesn't care.  If you want Appeal to\n  stop recognizing arguments starting with dashes as options,\n  specify `--` (two dashes with nothing else).  All subsequent\n  strings on the command-line will be used as arguments, even\n  if they start with a `-`.\n* Many built-in types are not introspectable.  If you call\n  `inspect.signature(int)` it throws a `ValueError`.  Appeal\n  has special-cased exactly five built-in types: `bool`,\n  `int`, `str`, `complex`, and `float`.\n* `Accumulator` actually allows parameterizing multiple types,\n  separated by commas.  `Accumulator[int, float]` will take\n  two opargs each time the option is specified, and the first\n  will be an `int` and the second will be a `float`.  The\n  list returned will contain tuples of ints and floats.\n* You can't call `main()` on an Appeal object more than once.\n  The `Appeal()` instance you use has internal state that changes\n  when you execute its `main()` method.\n* Information about a particular converter is localized to\n  a particular `Appeal()` instance.  If you decorate a converter\n  with `@app.option()`, every place inside that `Appeal()` instance\n  that you use that converter will also pick up the changes you\n  made with `@app.option()`.\n* You shouldn't call `usage()` until you've added all the\n  commands, options, and parameters information into your\n  Appeal object.  Why?  Because, for example, `usage()`\n  computes the default options for keyword-only parameters\n  that haven't gotten any explicitly defined options.\n  But if you then define one of those options, Appeal will\n  throw an error at you.\n* Almost any callable can be a converter.  But not every\n  function.  There are two limitations.  First, as already\n  mentioned, in order for a function to be a legal converter,\n  every keyword-only parameter must have a default value.\n  The second requirement is more specific: in order to use\n  a function as a converter for a `*args*` parameter,\n  *somewhere* in the annotations tree under that function,\n  some function must take a required positional parameter.\n\nFinally, the UNIX `make` command has an interesting\nand subtle behavior.  The `--jobs` and `-j` options to `make`\nspecify how many jobs to run in parallel.  If you run\n`make` without any parameters, it runs one job at a time.\nIf you run `make -j 5`, it runs five jobs at a time.  But!\nIf you specify `make -j`, where `-j` is the last thing on the\ncommand-line it runs *as many jobs at a time as it wants*.\nIn a way, the `-j` option has *two default values.*\n\nCan you do this with Appeal?  Naturally!  Simply specify\nyour keyword-only parameter with both an annotation and\na default value, then design the annotation function\nto take one argument that *also* has a default value.\nLike so:\n\n```Python\ndef jobs(jobs:int=math.inf):\n    return jobs\n\n@app.command()\ndef make(*targets, jobs:jobs=1):\n    ...\n```\n\n\nRestrictions on Appeal command functions:\n\n* You may not use `inspect.Parameter.empty` as a default value\n  for any keyword-only parameter to a converter or command function.\n* The converter for a *var_positional* (`*args`) parameter\n  *must* require at least one positional argument.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": null,
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/larryhastings/appeal/",
    "keywords": null,
    "license": null,
    "maintainer": null,
    "maintainer_email": null,
    "name": "appeal",
    "package_url": "https://pypi.org/project/appeal/",
    "platform": null,
    "project_url": "https://pypi.org/project/appeal/",
    "project_urls": {
      "Homepage": "https://github.com/larryhastings/appeal/"
    },
    "release_url": "https://pypi.org/project/appeal/0.5.3/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "A powerful & Pythonic command-line parsing library.  Give your program Appeal!",
    "version": "0.5.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17061771,
  "releases": {
    "0.1": [],
    "0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0fcf46d366573273aa22b89ceddd98b6e728be9ed10d038a23b92c51a2e143b7",
          "md5": "72fe1e71a916e257436b3aeec135aea1",
          "sha256": "e0afe8bd72db458ed3ece34cd0251ecdd876beef65c6ff363bd70b4993ba9307"
        },
        "downloads": -1,
        "filename": "appeal-0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "72fe1e71a916e257436b3aeec135aea1",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 64938,
        "upload_time": "2021-12-21T08:55:56",
        "upload_time_iso_8601": "2021-12-21T08:55:56.886948Z",
        "url": "https://files.pythonhosted.org/packages/0f/cf/46d366573273aa22b89ceddd98b6e728be9ed10d038a23b92c51a2e143b7/appeal-0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f263fdb530c963bea65c71f895090ac838202cf3b68817322d15b19e7084da19",
          "md5": "0f4e8cd4a1659c305e2dd8108ebb0c23",
          "sha256": "6d220467c0070e2d812944750a6584cd131959eb666ca7bdaf5175c5ef423592"
        },
        "downloads": -1,
        "filename": "appeal-0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "0f4e8cd4a1659c305e2dd8108ebb0c23",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 162436,
        "upload_time": "2021-12-21T08:56:05",
        "upload_time_iso_8601": "2021-12-21T08:56:05.223969Z",
        "url": "https://files.pythonhosted.org/packages/f2/63/fdb530c963bea65c71f895090ac838202cf3b68817322d15b19e7084da19/appeal-0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.1": [
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "06f85ef6e8839fadfcbad27e4e6adff86b676eb1af36dcb311f25fbf7a8afe51",
          "md5": "34d5142090149c5b8164d4b90dbd6223",
          "sha256": "3b123d8a0181065fb4b527e2307cefc974f60969579475fc5e1e90a79e7382cf"
        },
        "downloads": -1,
        "filename": "appeal-0.5.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "34d5142090149c5b8164d4b90dbd6223",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 73460,
        "upload_time": "2022-11-23T19:06:04",
        "upload_time_iso_8601": "2022-11-23T19:06:04.079111Z",
        "url": "https://files.pythonhosted.org/packages/06/f8/5ef6e8839fadfcbad27e4e6adff86b676eb1af36dcb311f25fbf7a8afe51/appeal-0.5.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "03a1b13a459c937463649e18a155a614a15971fac3ea22b30ff50638efefa741",
          "md5": "97e86cd408e406d5d31e71b3aec6ae69",
          "sha256": "228e54582598133cec62e4b5f9ce060272fb2261a75a4b821fbe8069a3cb5655"
        },
        "downloads": -1,
        "filename": "appeal-0.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "97e86cd408e406d5d31e71b3aec6ae69",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 173280,
        "upload_time": "2022-11-23T19:06:06",
        "upload_time_iso_8601": "2022-11-23T19:06:06.742125Z",
        "url": "https://files.pythonhosted.org/packages/03/a1/b13a459c937463649e18a155a614a15971fac3ea22b30ff50638efefa741/appeal-0.5.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.2": [
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "577212c21dfe66bea67e4bd7815d19c2e93d3cb108d900f31624be4164be0a9c",
          "md5": "afee8d3eee6e6cf55872668358e0971c",
          "sha256": "25df56d81c42467d178b2918253a4d36debca59e5582728f7013b46c8f2e412c"
        },
        "downloads": -1,
        "filename": "appeal-0.5.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "afee8d3eee6e6cf55872668358e0971c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 73698,
        "upload_time": "2023-02-27T06:44:11",
        "upload_time_iso_8601": "2023-02-27T06:44:11.531921Z",
        "url": "https://files.pythonhosted.org/packages/57/72/12c21dfe66bea67e4bd7815d19c2e93d3cb108d900f31624be4164be0a9c/appeal-0.5.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "bca7cdc5ba28c7eee23da72d7d60aeaed77630f308a870348d08d2d3f8071d60",
          "md5": "7100e1413a6c5ce99c9e9e6456f6da64",
          "sha256": "adb71d32ac44c62921a8f4de9c8fcb9b827a979c01974df6a42f11206f5769cd"
        },
        "downloads": -1,
        "filename": "appeal-0.5.2.tar.gz",
        "has_sig": false,
        "md5_digest": "7100e1413a6c5ce99c9e9e6456f6da64",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 173515,
        "upload_time": "2023-02-27T06:44:14",
        "upload_time_iso_8601": "2023-02-27T06:44:14.411302Z",
        "url": "https://files.pythonhosted.org/packages/bc/a7/cdc5ba28c7eee23da72d7d60aeaed77630f308a870348d08d2d3f8071d60/appeal-0.5.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.3": [
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "1870ae1e87158794a7ec96dc28f16f30400b08f418b240fe0e76bf377f9cb72d",
          "md5": "77a532a783460776ddeeaeab84247971",
          "sha256": "4115245d870aa1f088e2c35761432d1d6e23709a27e5a7737a6d384f49bf4cdb"
        },
        "downloads": -1,
        "filename": "appeal-0.5.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "77a532a783460776ddeeaeab84247971",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 74232,
        "upload_time": "2023-02-27T09:21:04",
        "upload_time_iso_8601": "2023-02-27T09:21:04.113347Z",
        "url": "https://files.pythonhosted.org/packages/18/70/ae1e87158794a7ec96dc28f16f30400b08f418b240fe0e76bf377f9cb72d/appeal-0.5.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": null,
        "digests": {
          "blake2b_256": "e75f1f5ceb977904320e176b1e00332274ee7d347d80e277f50a1d4fa847a4cf",
          "md5": "d1dbbb3cd8ba912f99410b84e9e6c8fa",
          "sha256": "bae8d4e20e67b0c39eda4b23f49ff218a41d892d1a136405384bac5853664f35"
        },
        "downloads": -1,
        "filename": "appeal-0.5.3.tar.gz",
        "has_sig": false,
        "md5_digest": "d1dbbb3cd8ba912f99410b84e9e6c8fa",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 174008,
        "upload_time": "2023-02-27T09:21:06",
        "upload_time_iso_8601": "2023-02-27T09:21:06.866016Z",
        "url": "https://files.pythonhosted.org/packages/e7/5f/1f5ceb977904320e176b1e00332274ee7d347d80e277f50a1d4fa847a4cf/appeal-0.5.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "1870ae1e87158794a7ec96dc28f16f30400b08f418b240fe0e76bf377f9cb72d",
        "md5": "77a532a783460776ddeeaeab84247971",
        "sha256": "4115245d870aa1f088e2c35761432d1d6e23709a27e5a7737a6d384f49bf4cdb"
      },
      "downloads": -1,
      "filename": "appeal-0.5.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "77a532a783460776ddeeaeab84247971",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 74232,
      "upload_time": "2023-02-27T09:21:04",
      "upload_time_iso_8601": "2023-02-27T09:21:04.113347Z",
      "url": "https://files.pythonhosted.org/packages/18/70/ae1e87158794a7ec96dc28f16f30400b08f418b240fe0e76bf377f9cb72d/appeal-0.5.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": null,
      "digests": {
        "blake2b_256": "e75f1f5ceb977904320e176b1e00332274ee7d347d80e277f50a1d4fa847a4cf",
        "md5": "d1dbbb3cd8ba912f99410b84e9e6c8fa",
        "sha256": "bae8d4e20e67b0c39eda4b23f49ff218a41d892d1a136405384bac5853664f35"
      },
      "downloads": -1,
      "filename": "appeal-0.5.3.tar.gz",
      "has_sig": false,
      "md5_digest": "d1dbbb3cd8ba912f99410b84e9e6c8fa",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 174008,
      "upload_time": "2023-02-27T09:21:06",
      "upload_time_iso_8601": "2023-02-27T09:21:06.866016Z",
      "url": "https://files.pythonhosted.org/packages/e7/5f/1f5ceb977904320e176b1e00332274ee7d347d80e277f50a1d4fa847a4cf/appeal-0.5.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}