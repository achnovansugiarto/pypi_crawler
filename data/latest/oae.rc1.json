{
  "info": {
    "author": "Abhishek Sharma",
    "author_email": "numb3r33@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Natural Language :: English",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "# OAE\n> This package implements this <a href='https://www.cse.wustl.edu/~ychen/public/OAE.pdf'>paper</a> in which the author tries to address the problem of interpretability and actionability of tree-based models. The author of the paper presents a novel framework to post-process any tree-based classifier to extract an optimal actionable plan that can change a given input to a desired class with a minimum cost. Currently this package only supports scikit-learn's implementation of Random Forest.\n\n\n## Install\n\n`pip install oae`\n\n## How to use\n\n```python\nimport numpy as np\nimport pandas as pd\n\nfrom oae.core import *\nfrom oae.tree import *\nfrom oae.optimizer import *\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split as tts\nfrom sklearn.metrics import accuracy_score, roc_auc_score\n\nSEED = 41\nnp.random.seed(SEED)\n```\n\n```python\ndata = get_external_dataset(URLS['BREAST_CANCER'])\n```\n\n```python\ndata.target.value_counts(normalize=True)\n```\n\n\n\n\n    2    0.655222\n    4    0.344778\n    Name: target, dtype: float64\n\n\n\nConvert `benign` represented as `2` and `malignant` represented as `4` to `0` and `1` respectively.\n\n```python\n# convert benigna\nlbls, lbl_map = pd.factorize(data['target'])\n```\n\nLet's look at the data-type of the features\n\n```python\ndata.dtypes\n```\n\n\n\n\n    code_number                     int64\n    clump_thickness                 int64\n    cell_size_uniformity            int64\n    cell_shape_uniformity           int64\n    marginal_adhesion               int64\n    single_epithelial_cell_size     int64\n    bare_nuclei                    object\n    bland_chromatin                 int64\n    normal_nucleoli                 int64\n    mitoses                         int64\n    target                          int64\n    dtype: object\n\n\n\n```python\ndata.bare_nuclei.unique()\n```\n\n\n\n\n    array(['1', '10', '2', '4', '3', '9', '7', '?', '5', '8', '6'],\n          dtype=object)\n\n\n\nLet's replace this `?` with `-1` and convert it into int64 like others\n\n```python\ndata = data.assign(bare_nuclei=data.bare_nuclei.str.replace('?', '-1').astype(np.int))\ndata = data.assign(target=lbls); data.head()\n```\n\n\n\n\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>code_number</th>\n      <th>clump_thickness</th>\n      <th>cell_size_uniformity</th>\n      <th>cell_shape_uniformity</th>\n      <th>marginal_adhesion</th>\n      <th>single_epithelial_cell_size</th>\n      <th>bare_nuclei</th>\n      <th>bland_chromatin</th>\n      <th>normal_nucleoli</th>\n      <th>mitoses</th>\n      <th>target</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1000025</td>\n      <td>5</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>2</td>\n      <td>1</td>\n      <td>3</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1002945</td>\n      <td>5</td>\n      <td>4</td>\n      <td>4</td>\n      <td>5</td>\n      <td>7</td>\n      <td>10</td>\n      <td>3</td>\n      <td>2</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1015425</td>\n      <td>3</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>2</td>\n      <td>2</td>\n      <td>3</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1016277</td>\n      <td>6</td>\n      <td>8</td>\n      <td>8</td>\n      <td>1</td>\n      <td>3</td>\n      <td>4</td>\n      <td>3</td>\n      <td>7</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1017023</td>\n      <td>4</td>\n      <td>1</td>\n      <td>1</td>\n      <td>3</td>\n      <td>2</td>\n      <td>1</td>\n      <td>3</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n```python\ndata.iloc[:, 1:-1].nunique()\n```\n\n\n\n\n    clump_thickness                10\n    cell_size_uniformity           10\n    cell_shape_uniformity          10\n    marginal_adhesion              10\n    single_epithelial_cell_size    10\n    bare_nuclei                    11\n    bland_chromatin                10\n    normal_nucleoli                10\n    mitoses                         9\n    dtype: int64\n\n\n\nAll of the features of interest ( excluding code_number and target ) are categorical variables. Let's create a holdout set and train a Random Forest Classifier.\n\n```python\nSEED = 41\nnp.random.seed(SEED)\n\nfeatures = data.columns[1:-1]\n\nXtr, Xte, ytr, yte = tts(data.loc[:, features], data.target, test_size=.2, random_state=SEED)\n```\n\n```python\nclf = RandomForestClassifier(n_estimators=10, n_jobs=-1, random_state=SEED)\nclf.fit(Xtr, ytr)\n\nprint(f'train accuracy: {accuracy_score(ytr, clf.predict(Xtr))}')\nprint(f'holdout accuracy: {accuracy_score(yte, clf.predict(Xte))}')\n```\n\n    train accuracy: 0.998211091234347\n    holdout accuracy: 0.9714285714285714\n\n\nLet's select an instance from holdout set and look at the ground. We realize that the classifier marks it as `malignant` and we want to know what features could be changed so that classifier would mark it as `benign`.\n\n```python\ninstanceidx = 4\nprint(yte.iloc[instanceidx], ' ', clf.predict_proba(Xte.iloc[instanceidx:instanceidx+1]))\n```\n\n    1   [[0. 1.]]\n\n\nNow we will try to extract an optimal action problem by posing this problem as an Integer Linear Programming problem.\n\n```python\natm        = ATMSKLEARN(clf, data.loc[:, features].values)\ninstance   = Instance(Xte.iloc[instanceidx], ['categorical'] * len(features))\n```\n\n**We would be using the following cost function so our  OAE problem minimize the number of changed features, i.e. Hamming distance.**\n\n![](images/cost_function_def.png)\n\nBut we don' need to restrict ourselves to this particular cost function, you can design your cost function and pass it to the solver.\n\nIn this example our input has ground label `1` and we want to find out how to tweak features with minimum cost such that classifier classifies it as label `0` with `z` being the target threshold.\n\n$F(x) = \\frac{1}{w_{t}} \\sum_{k=1}^{m_t} h_{t,k}\\phi_{t,k} \\geq z$, where $h_{t_k} \\in R$\n\n$F(x)$ represents the probability estimate from Random Forest Classifier.\n\n```python\nopt = Optimizer(cost_matrix, combine, z=0.45, class_=0)\nv_i_j_sol, phi_t_k_sol = opt.solve(atm, instance)\n```\n\nThe package would help suggest changes that should be made to the feature to move it from classified as `malignant` to being `benign`.\n\n```python\natm.suggest_changes(v_i_j_sol, instance)\n```\n\n\n\n\n    ['no change, current value: 5',\n     'no change, current value: 3',\n     'no change, current value: 5',\n     'no change, current value: 1',\n     'no change, current value: 8',\n     'current value: 10, proposed change: [-1, 1]',\n     'current value: 5, proposed change: [3, 4]',\n     'no change, current value: 3',\n     'no change, current value: 1']\n\n\n\nAn action plan is extracted which says that we need to change `5th feature` which currently has value `10` to `-1` and `6th feature` to `3` and then our classifier would classify it as label `0`. Let's find it out.\n\n```python\nX_transformed = atm.transform(v_i_j_sol, instance); X_transformed\n```\n\n\n\n\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>clump_thickness</th>\n      <th>cell_size_uniformity</th>\n      <th>cell_shape_uniformity</th>\n      <th>marginal_adhesion</th>\n      <th>single_epithelial_cell_size</th>\n      <th>bare_nuclei</th>\n      <th>bland_chromatin</th>\n      <th>normal_nucleoli</th>\n      <th>mitoses</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5</td>\n      <td>3</td>\n      <td>5</td>\n      <td>1</td>\n      <td>8</td>\n      <td>-1</td>\n      <td>3</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n```python\nclf.predict_proba(X_transformed)\n```\n\n\n\n\n    array([[0.6, 0.4]])\n\n\n\nIndeed we can see that classifier will label it as `0` and probability is also greater than `z=0.45` so it also satisfies that concern as well.\n\n## Applications\n\n- One example coult be in targeted marketing, we can use the action plan generated per customer to better understand which all levers can we pull to get desired results.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/numb3r33/oae/tree/master/",
    "keywords": "ILP",
    "license": "Apache Software License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "oae",
    "package_url": "https://pypi.org/project/oae/",
    "platform": "",
    "project_url": "https://pypi.org/project/oae/",
    "project_urls": {
      "Homepage": "https://github.com/numb3r33/oae/tree/master/"
    },
    "release_url": "https://pypi.org/project/oae/0.0.1/",
    "requires_dist": [
      "appnope (==0.1.0)",
      "attrs (==19.3.0)",
      "backcall (==0.1.0)",
      "bleach (==3.1.5)",
      "cffi (==1.14.0)",
      "decorator (==4.4.2)",
      "defusedxml (==0.6.0)",
      "ecos (==2.0.7.post1)",
      "entrypoints (==0.3)",
      "fastscript (==0.1.4)",
      "future (==0.18.2)",
      "graphviz (==0.14)",
      "importlib-metadata (==1.6.0)",
      "ipykernel (==5.3.0)",
      "ipython (==7.15.0)",
      "ipython-genutils (==0.2.0)",
      "ipywidgets (==7.5.1)",
      "jedi (==0.17.0)",
      "Jinja2 (==2.11.2)",
      "joblib (==0.15.1)",
      "jsonschema (==3.2.0)",
      "jupyter (==1.0.0)",
      "jupyter-client (==6.1.3)",
      "jupyter-console (==6.1.0)",
      "jupyter-core (==4.6.3)",
      "MarkupSafe (==1.1.1)",
      "mip (==1.9.1)",
      "mistune (==0.8.4)",
      "nbconvert (==5.6.1)",
      "nbdev (==0.2.18)",
      "nbformat (==5.0.6)",
      "notebook (==6.0.3)",
      "numpy (==1.18.5)",
      "osqp (==0.6.1)",
      "packaging (==20.4)",
      "pandas (==1.0.4)",
      "pandocfilters (==1.4.2)",
      "parso (==0.7.0)",
      "pexpect (==4.8.0)",
      "pickleshare (==0.7.5)",
      "prometheus-client (==0.8.0)",
      "prompt-toolkit (==3.0.5)",
      "ptyprocess (==0.6.0)",
      "pycparser (==2.20)",
      "Pygments (==2.6.1)",
      "pyparsing (==2.4.7)",
      "pyrsistent (==0.16.0)",
      "python-dateutil (==2.8.1)",
      "pytz (==2020.1)",
      "PyYAML (==5.3.1)",
      "pyzmq (==19.0.1)",
      "qtconsole (==4.7.4)",
      "QtPy (==1.9.0)",
      "scikit-learn (==0.23.1)",
      "scipy (==1.4.1)",
      "scs (==2.1.2)",
      "Send2Trash (==1.5.0)",
      "six (==1.15.0)",
      "terminado (==0.8.3)",
      "testpath (==0.4.4)",
      "threadpoolctl (==2.1.0)",
      "tornado (==6.0.4)",
      "traitlets (==4.3.3)",
      "wcwidth (==0.2.3)",
      "webencodings (==0.5.1)",
      "widgetsnbextension (==3.5.1)",
      "zipp (==3.1.0)"
    ],
    "requires_python": ">=3.6",
    "summary": "Optimal Action Extraction for Random Forests and Boosted Trees",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7473926,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9b71cc3aa9e234b1913b26597a0591954c1c4f82bd8c87ffbd2c48a18f74114b",
          "md5": "5a3132a9548ffc8bd2e99fbd53c72c37",
          "sha256": "31190e56ae12bac7f74e50a258b90b8ace6ac0210e4dd36757ec3ecf13ab116c"
        },
        "downloads": -1,
        "filename": "oae-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5a3132a9548ffc8bd2e99fbd53c72c37",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 14146,
        "upload_time": "2020-06-14T15:24:50",
        "upload_time_iso_8601": "2020-06-14T15:24:50.680451Z",
        "url": "https://files.pythonhosted.org/packages/9b/71/cc3aa9e234b1913b26597a0591954c1c4f82bd8c87ffbd2c48a18f74114b/oae-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7b97e2a4b22e524d96c4a66286edb7ee734d4c2b7b94f657d2144996278599f9",
          "md5": "2655df20c1972579db75fab72da94852",
          "sha256": "67e6c25ef3193e0551c69ed2b2a7ba0c32a52863ce32e954ad401cc8ce07e974"
        },
        "downloads": -1,
        "filename": "oae-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2655df20c1972579db75fab72da94852",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 16861,
        "upload_time": "2020-06-14T15:24:54",
        "upload_time_iso_8601": "2020-06-14T15:24:54.936784Z",
        "url": "https://files.pythonhosted.org/packages/7b/97/e2a4b22e524d96c4a66286edb7ee734d4c2b7b94f657d2144996278599f9/oae-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9b71cc3aa9e234b1913b26597a0591954c1c4f82bd8c87ffbd2c48a18f74114b",
        "md5": "5a3132a9548ffc8bd2e99fbd53c72c37",
        "sha256": "31190e56ae12bac7f74e50a258b90b8ace6ac0210e4dd36757ec3ecf13ab116c"
      },
      "downloads": -1,
      "filename": "oae-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "5a3132a9548ffc8bd2e99fbd53c72c37",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 14146,
      "upload_time": "2020-06-14T15:24:50",
      "upload_time_iso_8601": "2020-06-14T15:24:50.680451Z",
      "url": "https://files.pythonhosted.org/packages/9b/71/cc3aa9e234b1913b26597a0591954c1c4f82bd8c87ffbd2c48a18f74114b/oae-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7b97e2a4b22e524d96c4a66286edb7ee734d4c2b7b94f657d2144996278599f9",
        "md5": "2655df20c1972579db75fab72da94852",
        "sha256": "67e6c25ef3193e0551c69ed2b2a7ba0c32a52863ce32e954ad401cc8ce07e974"
      },
      "downloads": -1,
      "filename": "oae-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "2655df20c1972579db75fab72da94852",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 16861,
      "upload_time": "2020-06-14T15:24:54",
      "upload_time_iso_8601": "2020-06-14T15:24:54.936784Z",
      "url": "https://files.pythonhosted.org/packages/7b/97/e2a4b22e524d96c4a66286edb7ee734d4c2b7b94f657d2144996278599f9/oae-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}