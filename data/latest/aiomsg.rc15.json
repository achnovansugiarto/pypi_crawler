{
  "info": {
    "author": "Caleb Hattingh",
    "author_email": "caleb.hattingh@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Framework :: AsyncIO",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Communications",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": ".. image:: https://github.com/cjrh/aiomsg/workflows/Python%20application/badge.svg\n    :target: https://github.com/cjrh/aiomsg/actions\n\n.. image:: https://img.shields.io/badge/stdlib--only-yes-green.svg\n    :target: https://img.shields.io/badge/stdlib--only-yes-green.svg\n\n.. image:: https://coveralls.io/repos/github/cjrh/aiomsg/badge.svg?branch=master\n    :target: https://coveralls.io/github/cjrh/aiomsg?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/aiomsg.svg\n    :target: https://pypi.python.org/pypi/aiomsg\n\n.. image:: https://img.shields.io/github/tag/cjrh/aiomsg.svg\n    :target: https://img.shields.io/github/tag/cjrh/aiomsg.svg\n\n.. image:: https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\n    :target: https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\n\n.. image:: https://img.shields.io/pypi/v/aiomsg.svg\n    :target: https://img.shields.io/pypi/v/aiomsg.svg\n\n.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\n    :target: http://calver.org/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/ambv/black\n\naiomsg\n======\n\nPure-Python smart sockets (like ZMQ) for simpler networking\n\n.. figure:: https://upload.wikimedia.org/wikipedia/commons/5/5e/NetworkDecentral.svg\n    :target: https://commons.wikimedia.org/wiki/File:NetworkDecentral.svg\n    :alt: Diagram of computers linked up in a network\n\n    :sub:`Attribution: And1mu [CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0)]`\n\n\nTable of Contents\n-----------------\n\n.. contents::\n\n\nDemo\n====\n\nLet's make two microservices; one will send the current time to the other.\nHere's the end that binds to a port (a.k.a, the \"server\"):\n\n.. code-block:: python3\n\n    import asyncio, time\n    from aiomsg import Søcket\n\n    async def main():\n        async with Søcket() as sock:\n            await sock.bind('127.0.0.1', 25000)\n            while True:\n                await sock.send(time.ctime().encode())\n                await asyncio.sleep(1)\n\n    asyncio.run(main())\n\nRunning as a different process, here is the end that does the\nconnecting (a.k.a, the \"client\"):\n\n.. code-block:: python3\n\n    import asyncio\n    from aiomsg import Søcket\n\n    async def main():\n        async with Søcket() as sock:\n            await sock.connect('127.0.0.1', 25000)\n            async for msg in sock.messages():\n                print(msg.decode())\n\n    asyncio.run(main())\n\nNote that these are both complete, runnable programs, not fragments.\n\nLooks a lot like conventional socket programming, except that *these*\nsockets have a few extra tricks. These are described in more detail\nfurther down in rest of this document.\n\nInspiration\n===========\n\nLooks a lot like ZeroMQ yes? no? Well if you\ndon't know anything about\nZeroMQ, that's fine too. The rest of this document will assume that you\ndon't know anything about ZeroMQ. ``aiomsg`` is heavily influenced\nby ZeroMQ.\n\nThere are some differences; hopefully they make things simpler than zmq.\nFor one thing, *aiomsg* is pure-python so no compilation step is required,\nand relies only on the Python standard library (and that won't change).\n\nAlso, we don't have special kinds of socket pairs like ZeroMQ has. There is\nonly the one ``Søcket`` class. The only role distinction you need to make\nbetween different socket instances is this: some sockets will **bind**\nand others will **connect**.\n\nThis is the leaky part of the API that comes from the\nunderlying BSD socket API. A *bind* socket will bind to a local interface\nand port. A *connect* socket must connect to a *bind* socket, which can\nbe on the same machine or a remote machine. This is the only complicated\nbit. You must decide, in a distributed microservices architecture,\nwhich sockets must bind and which must connect. A useful heuristic is\nthat the service which is more likely to require horizontal scaling should\nhave the *connect* sockets. This is because the *hostnames* to which they\nwill connect (these will be the *bind* sockets) will be long-lived.\n\nIntroduction\n============\n\nWhat you see above in the demo is pretty much a typical usage of\nnetwork sockets. So what's special about ``aiomsg``? These are\nthe high-level features:\n\n#.  Messages, not streams:\n\n    Send and receive are *message-based*, not stream based. Much easier! This\n    does mean that if you want to transmit large amounts of data, you're going\n    to have have to break them up yourself, send the pieces, and put them\n    back together on the other side.\n\n#.  Automatic reconnection\n\n    These sockets automatically reconnect. You don't have to\n    write special code for it. If the bind end (a.k.a \"server\") is restarted,\n    the connecting end will automatically reconnect. This works in either\n    direction.  Try it! run the demo code and kill one of the processes.\n    And then start it up again. The connection will get re-established.\n\n#.  Many connections on a single \"socket\"\n\n    The bind end can receive multiple connections, but you do all your\n    ``.send()`` and ``.recv()`` calls on a single object. (No\n    callback handlers or protocol objects.)\n\n    More impressive is that the connecting end is exactly the same; it can make\n    outgoing ``connect()`` calls to multiple peers (bind sockets),\n    and you make all your ``send()`` and ``recv()`` calls on a single object.\n\n    This will be described in more detail further on in this document.\n\n#.  Message distribution patterns\n\n    Receiving messages is pretty simple: new messages just show up (remember\n    that messages from all connected peers come through the same call):\n\n    .. code-block:: python3\n\n        async with Søcket() as sock:\n            await sock.bind()\n            async for msg in sock.messages():\n                print(f\"Received: {msg}\")\n\n    However, when sending messages you have choices. The choices affect\n    **which peers** get the message. The options are:\n\n    - **Publish**: every connected peer is sent a copy of the message\n    - **Round-robin**: each connected peer is sent a *unique* message; the messages\n      are distributed to each connection in a circular pattern.\n    - **By peer identity**: you can also send to a specific peer by using\n      its identity directly.\n\n    The choice between *pub-sub* and *round-robin* must be made when\n    creating the ``Søcket()``:\n\n    .. code-block:: python3\n\n        from aiomsg import Søcket, SendMode\n\n        async with Søcket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            async for msg in sock.messages():\n                await sock.send(msg)\n\n    This example receives a message from any connected peer, and sends\n    that same message to *every* connected peer (including the original\n    sender). By changing ``PUBLISH`` to ``ROUNDROBIN``, the message\n    distribution pattern changes so that each \"sent\" message goes to\n    only one connected peer. The next \"sent\" message will go to a\n    different connected, and so on.\n\n    For *identity-based* message sending, that's available any time,\n    regardless of what you choose for the ``send_mode`` parameter; for\n    example:\n\n    .. code-block:: python3\n\n        import asyncio\n        from aiomsg import Søcket, SendMode\n\n        async def main():\n            async with Søcket() as sock1, Søcket(send_mode=SendMode.PUBLISH) as sock2:\n                await sock1.bind(port=25000)\n                await sock2.bind(port=25001)\n                while True:\n                    peer_id, message = await sock1.recv_identity()\n                    msg_id, _, data = msg.partition(b\"\\x00\")\n                    await sock2.send(data)\n                    await sock1.send(msg_id + b\"\\x00ok\", identity=peer_id)\n\n        asyncio.run(main())\n\n    This example shows how you can receive messages on one socket (``sock1``,\n    which could have thousands of connected peers), and relay those messages to\n    thousands of other peers connected on a different socket (``sock2``).\n\n    For this example, the ``send_mode`` of ``sock1`` doesn't matter because\n    if ``identity`` is specified in the ``send()`` call, it'll ignore\n    ``send_mode`` completely.\n\n    Oh, and the example above is a complete, runnable program which is\n    pretty amazing!\n\n#.  Built-in heartbeating\n\n    Because ain't nobody got time to mess around with TCP keepalive\n    settings. The heartbeating is internal and opaque to your application\n    code. You won't even know it's happening, unless you enable debug\n    logs. Heartbeats are sent only during periods of inactivity, so\n    they won't interfere with your application messages.\n\n    In theory, you really shouldn't need heartbeating because TCP is a very robust\n    protocol; but in practice, various intermediate servers and routers\n    sometimes do silly things to your connection if they think a connection\n    has been idle for too long. So, automatic heartbeating is baked in to\n    let all intermediate hops know you want the connection to stay up, and\n    if the connection goes down, you will know much sooner than the\n    standard TCP keepalive timeout duration (which can be very long!).\n\n    If either a heartbeat or a message isn't received within a specific\n    timeframe, that connection is destroyed. Whichever peer is making the\n    ``connect()`` call will then automatically try to reconnect, as\n    discussed earlier.\n\n#.  Built-in reliability choices\n\n    Ah, so what do \"reliability choices\" mean exactly...?\n\n    It turns out that it's quite hard to send messages in a reliable way.\n    Or, stated another way, it's quite hard to avoid dropping messages:\n    one side sends and the other side never gets the message.\n\n    ``aiomsg`` already buffers messages when being sent. Consider the\n    following example:\n\n    .. code-block:: python3\n\n        from aiomsg import Søcket, SendMode\n\n        async with Søcket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'123)\n                await asyncio.sleep(1.0)\n\n    This server above will send the bytes ``b\"123\"`` to all connected peers;\n    but what happens if there are *no* connected peers? In this case the\n    message will be buffered internally until there is at least one\n    connected peer, and when that happens, all buffered messages will\n    immediately be sent. To be clear, you don't have to do anything extra.\n    This is just the normal behaviour, and it works the same with the\n    ``ROUNDROBIN`` send mode.\n\n    Message buffering happens whenever there are no connected peers\n    available to receive a message.  Sounds great right?  Unfortunately,\n    this is not quite enough to prevent messages from getting lost. It is\n    still easy to have your process killed immediately after sending data into\n    a kernel socket buffer, but right before the bytes actually get\n    transmitted. In other words, your code thinks the message got sent, but\n    it didn't actually get sent.\n\n    The only real solution for adding robustness is to have peers *reply*\n    to you saying that they received the message. Then, if you never receive\n    this notification, you should assume that the message might not have\n    been received, and send it again. ``aiomsg`` will do this for you\n    (so again there is no work on your part), but you do have to turn it\n    on.\n\n    This option is called the ``DeliveryGuarantee``. The default option,\n    which is just basic message buffering in the absence of any connected\n    peers, is called ``DeliveryGuarantee.AT_MOST_ONCE``. It means, literally,\n    that any \"sent\" message will received by a connected peer no more than\n    once (of course, it may also be zero, as described above).\n\n    The alternative is to set ``DeliveryGuarantee.AT_LEAST_ONCE``, which\n    enables the internal \"retry\" feature. It will be possible, under\n    certain conditions, that any given message could be received *more than\n    once*, depending on timing and situation.  This is how the code looks\n    if you enable it:\n\n    .. code-block:: python3\n\n        from aiomsg import Søcket, SendMode, DeliveryGuarantee\n\n        async with Søcket(\n                send_mode=SendMode.ROUNDROBIN,\n                delivery_guarantee=DeliveryGuarantee.AT_LEAST_ONCE\n        ) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'123)\n                await asyncio.sleep(1.0)\n\n    It's pretty much exactly the same as before, but we added the\n    ``AT_LEAST_ONCE`` option. Note that ``AT_LEAST_ONCE`` does not work\n    for the ``PUBLISH`` sending mode. (Would it make sense to enable?)\n\n    As a minor point, you should note that when ``AT_LEAST_ONCE`` is\n    enabled, it does not mean that every send waits for acknowledgement\n    before the next send. That would incur too much latency. Instead,\n    there is a \"reply checker\" that runs on a timer, and if a reply\n    hasn't been received for a particular message in a certain timeframe\n    (5.0 seconds by default), that message will be sent again.\n\n    The connection may have gone down and back up within those 5 seconds,\n    and there may be new messages buffered for sending before the retry\n    send happens. In this case, the retry message will arrive **after**\n    those buffered messages. This is a long way of saying that the way\n    that message reliability has been implemented can result in messages\n    being received in a different **order** to what they were sent. In\n    exchange for this, you get a lower overall latency because sending\n    new messages is not waiting on previous messages getting acknowledged.\n\n#.  Pure python, doesn't require a compiler\n\n#.  Depends only on the Python standard library\n\n\nCookbook\n========\n\nThe message distribution patterns are what make ``aiomsg`` powerful. It\nis the way you connect up a whole bunch of microservices that brings the\ngreatest leverage. We'll go through the different scenarios using a\ncookbook format.\n\nIn the code snippets that follow, you should assumed that each snippet\nis a complete working program, except that some boilerplate is omitted.\nThis is the basic template:\n\n.. code-block:: python3\n\n    import asyncio\n    from aiomsg import Søcket, SendMode, DeliveryGuarantee\n\n    <main() function>\n\n    asyncio.run(main())\n\nJust substitute in the ``main()`` function from the snippets below to\nmake the complete programs.\n\nPublish from either the *bind* or *connect* end\n-----------------------------------------------\n\nThe choice of \"which peer should bind\" is unaffected by the sending mode\nof the socket.\n\nCompare\n\n.. code-block:: python3\n\n    # Publisher that binds\n    async def main():\n        async with Søcket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'News!')\n                await asyncio.sleep(1)\n\nversus\n\n.. code-block:: python3\n\n    # Publisher that connects\n    async def main():\n        async with Søcket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.connect()\n            while True:\n                await sock.send(b'News!')\n                await asyncio.sleep(1)\n\nThe same is true for the round-robin sending mode. You will usually\nchoose the *bind* peer based one which service is least likely to\nrequire dynamic scaling.  This means that the mental conception of\nsocket peers as either a *server* or *client* is not that useful.\n\nDistribute messages to a dynamically-scaled service (multiple instances)\n------------------------------------------------------------------------\n\nIn this recipe, one service needs to send messages to another service\nthat is horizontally scaled.\n\nThe trick here is that we *don't* want to use bind sockets on\nhorizontally-scaled services, because other peers that need to make\na *connect* call will need to know what hostname to use.\nEach instance in a horizontally-scaled service has a different IP\naddress, and it becomes difficult to keep the \"connect\" side up-to-date\nabout which peers are available. This can also change as the\nhorizontally-scaled service increases or decreases the number of\ninstances. (In ZeroMQ documentation, this is described as the\n`Dynamic Discovery Problem <http://zguide.zeromq.org/page:all#The-Dynamic-Discovery-Problem>`_).\n\n``aiomsg`` handles this very easily: just make sure that the\ndynamically-scaled service is making the connect calls:\n\nThis is the manually-scaled service (has a specific domain name):\n\n.. code-block:: python3\n\n    # jobcreator.py -> DNS for \"jobcreator.com\" should point to this machine.\n    async def main():\n        async with Søcket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.bind(hostname=\"0.0.0.0\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nThese are the downstream workers (don't need a domain name):\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with Søcket() as sock\n            await sock.connect(hostname='jobcreator.com', port=25001)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nWith this code, after you start up ``jobcreator.py`` on the machine\nto which DNS resolves the domain name \"jobcreator.com\", you can start\nup multiple instances of ``worker.py`` on other machines, and work\nwill get distributed among them. You can even change the number of\nworker instances dynamically, and everything will \"just work\", with\nthe main instance distributing work out to all the connected workers\nin a circular pattern.\n\nThis core recipe provides a foundation on which many of the other\nrecipes are built.\n\nDistribute messages from a 2-instance service to a dynamically-scaled one\n-------------------------------------------------------------------------\n\nIn this scenario, there are actually two instances of the job-creating\nservice, not one. This would typically be done for reliability, and\neach instance would be placed in a different `availability zones <https://searchaws.techtarget.com/definition/availability-zones>`_.\nEach instance will have a different domain name.\n\nIt turns out that the required setup follows directly from the previous\none: you just add another connect call in the workers.\n\nThe manually-scaled service is as before, but you start on instance of\n``jobcreator.py`` on machine \"a.jobcreator.com\", and start another\non machine \"b.jobcreator.com\". Obviously, it is DNS that is configured\nto point to the correct IP addresses of those machines (or you could\nuse IP addresses too, if these are internal services).\n\n.. code-block:: python3\n\n    # jobcreator.py -> Configure DNS to point to these instances\n    async def main():\n        async with Søcket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.bind(hostname=\"0.0.0.0\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nAs before, the downstream workers, but this time each worker makes\nmultiple ``connect()`` calls; one to each job creator's domain name:\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with Søcket() as sock:\n            await sock.connect(hostname='a.jobcreator.com', port=25001)\n            await sock.connect(hostname='b.jobcreator.com', port=25001)\n            while True:\n                work = await sock.recv()\n                <do work>\n\n``aiomsg`` will return ``work`` from the ``sock.recv()`` call above as\nit comes in from either job creation service. And as before, the number\nof worker instances can be dynamically scaled, up or down, and all the\nconnection and reconnection logic will be handled internally.\n\nDistribute messages from one dynamically-scaled service to another\n------------------------------------------------------------------\n\nIf both services need to be dynamically-scaled, and can have\nvarying numbers of instances at any time, we can no longer rely\non having one end do the *socket bind* to a dedicated domain name.\nWe really would like each to make ``connect()`` calls, as we've\nseen in previous examples.\n\nHow to solve it?\n\nThe answer is to create an intermediate proxy service that has\n**two** bind sockets, with long-lived domain names. This is what\nwill allow the other two dynamically-scaled services to have\na dynamic number of instances.\n\nHere is the new job creator, whose name we change to ``dynamiccreator.py``\nto reflect that it is now dynamically scalable:\n\n.. code-block:: python3\n\n    # dynamiccreator.py -> can be on any number of machines\n    async def main():\n        async with Søcket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.connect(hostname=\"proxy.jobcreator.com\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nNote that our job creator above is now making a ``connect()`` call to\n``proxy.jobcreator.com:25001`` rather than binding to a local port.\nLet's see what it's connecting to. Here is the intermediate proxy\nservice, which needs a dedicated domain name, and two ports allocated\nfor each of the bind sockets.\n\n.. code-block:: python3\n\n    # proxy.py -> Set up DNS to point \"proxy.jobcreator.com\" to this instance\n    async def main():\n        async with Søcket() as sock1, \\\n                Søcket(send_mode=SendMode.ROUNDROBIN) as sock2:\n            await sock1.bind(hostname=\"0.0.0.0\", port=25001)\n            await sock2.bind(hostname=\"0.0.0.0\", port=25002)\n            while True:\n                work = await sock1.recv()\n                await sock2.send(work)\n\nNote that ``sock1`` is bound to port 25001; this is what our job creator\nis connecting to. The other socket, ``sock2``, is bound to port 25002, and\nthis is the one that our workers will be making their ``connect()`` calls\nto. Hopefully it's clear in the code that work is being received from\n``sock1`` and being sent onto ``sock2``. This is pretty much a feature\ncomplete proxy service, and with only minor additions for error-handling\ncan be used for real work.\n\nFor completeness, here are the downstream workers:\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with Søcket() as sock:\n            await sock.connect(hostname='proxy.jobcreator.com', port=25002)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nNote that the workers are connecting to port 25002, as expected.\n\nYou might be wondering: isn't this just moving our performance problem\nto a different place? If the proxy service is not scalable, then surely\nthat becomes the \"weakest link\" in our system architecture?\n\nThis is a pretty typical reaction, but there are a couple of reasons\nwhy it might not be as bad as you think:\n\n#. The proxy service is doing very, very little work. Thus, we expect\n   it to suffer from performance problems only at a much higher scale\n   compared to our other two services which are likely to be doing more\n   CPU-bound work (in real code, not my simple examples above).\n#. We could compile only the proxy service into faster low-level code using\n   any number of tools such as Cython, C, C++, Rust, D and so on, in order\n   to improve its performance, if necessary (this would require implementing\n   the ``aiomsg`` protocols in that other language though). This allows\n   us to retain the benefits of using a dynamic language like Python\n   in the dynamically scaled services where much greater business\n   logic is captured (these can be then be horizontally scaled quite\n   easily to handle performance issues if necessary).\n#. Performance is not the only reason services are dynamically scaled.\n   It is always a good idea, even in low-throughput services, to have\n   multiple instances of a service running in different availability zones.\n   Outages do happen, yes, even in your favourite cloud provider's\n   systems.\n#. A separate proxy service as shown above isolates a really complex\n   problem and removes it from your business logic code. It might not\n   be easy to appreciate how significant that is. As your dev team is\n   rapidly iterating on business features, and redeploying new versions\n   several times a day, the proxy service is unchanging, and doesn't\n   require redeployment. In this sense, it plays a similar role to\n   more traditional messaging systems like RabbitMQ and ActiveMQ.\n#. We can still run multiple instances of our proxy service using an\n   earlier technique, as we'll see in the next recipe.\n\nTwo dynamically-scaled services, with a scaled fan-in, fan-out proxy\n--------------------------------------------------------------------\n\nThis scenario is exactly like the previous one, except that we're\nnervous about having only a single proxy service, since it is a\nsingle point of failure.  Instead, we're going to have 3 instances of\nthe proxy service running in parallel.\n\nLet's jump straight into code. The proxy code itself is actually\nunchanged from before.  We just need to run more copies of it on\ndifferent machines. *Each machine will have a different domain name*.\n\n.. code-block:: python3\n\n    # proxy.py -> unchanged from the previous recipe\n    async def main():\n        async with Søcket() as sock1, \\\n                Søcket(send_mode=SendMode.ROUNDROBIN) as sock2:\n            await sock1.bind(hostname=\"0.0.0.0\", port=25001)\n            await sock2.bind(hostname=\"0.0.0.0\", port=25002)\n            while True:\n                work = await sock1.recv()\n                await sock2.send(work)\n\nFor the other two dynamically scaled services, we need to tell them\nall the domain names to connect to.  We could set that up in an\nenvironment variable:\n\n.. code-block:: shell\n\n    $ export PROXY_HOSTNAMES=\"px1.jobcreator.com;px2.jobcreator.com;px3.jobcreator.com\"\n\nThen, it's really easy to modify our services to make use of that. First,\nthe dynamically-scaled job creator:\n\n.. code-block:: python3\n\n    # dynamiccreator.py -> can be on any number of machines\n    async def main():\n        async with Søcket(send_mode=SendMode.ROUNDROBIN) as sock:\n            for proxy in os.environ['PROXY_HOSTNAMES'].split(\";\"):\n                await sock.connect(hostname=proxy, port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nAnd the change for the worker code is identical (making sure the correct\nport is being used, 25002):\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with Søcket() as sock:\n            for proxy in os.environ['PROXY_HOSTNAMES'].split(\";\"):\n                await sock.connect(hostname=proxy, port=25002)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nThree proxies, each running in a different availability zone, should\nbe adequate for most common scenarios.\n\nTODO: more scenarios involving identity (like ROUTER-DEALER)\n\nSecure connections with mutual TLS\n----------------------------------\n\nSecure connectivity is extremely important, *even in an internal\nmicroservices infrastructure*. From a design perspective, the single\nbiggest positive impact that can be made on security is to make it **easy**\nfor users to do the \"right thing\".\n\nFor this reason, ``aiomsg`` does nothing new at all. It uses the existing\nsupport for secure connectivity in the Python standard library, and\nuses the same APIs exactly as-is.\n\nAll you have to do is create an `SSLContext <https://docs.python.org/3/library/ssl.html#ssl.SSLContext>`_\nobject, exactly as you normally would for conventional Python\nsockets, and pass that in.\n\n`Mutual TLS authentication (mTLS) <https://en.wikipedia.org/wiki/Mutual_authentication>`_\nis where the client verifies the server **and** the server verifies\nthe client. In ``aiomsg``, names like \"client\" and \"server\" are less\nuseful, so let's rather say that the *connect* socket verifies the\ntarget *bind* socket, and the *bind* socket also verifies the incoming\nconnecting socket.\n\nIt sounds complicated, but at a high level you just need to supply\nan ``SSLContext`` instance to the bind socket, and a different ``SSLContext``\ninstance to the connect socket (usually on a different computer). The details\nare all stored in the ``SSLContext`` objects.\n\nLet's first look at how that looks for a typical bind socket and connect\nsocket:\n\n.. code-block:: python3\n\n    # bind end\n    import ssl\n    import asyncio, time\n    from aiomsg import Søcket\n\n    async def main():\n        ctx = ssl.SSLContext(...)    # <--------- NEW!\n        async with Søcket() as sock:\n            await sock.bind('127.0.0.1', 25000, ssl_context=ctx)\n            while True:\n                await s.send(time.ctime().encode())\n\n    asyncio.run(main())\n\n.. code-block:: python3\n\n    # connect end\n    import ssl\n    import asyncio\n    from aiomsg import Søcket\n\n    async def main():\n        ctx = ssl.SSLContext(...)    # <--------- NEW!\n        async with Søcket() as sock:\n            await sock.connect('127.0.0.1', 25000, ssl_context=ctx)\n            async for msg in sock.messages():\n                print(msg.decode())\n\n    asyncio.run(main())\n\nIf you compare these two code snippets to what was shown in the *Demo*\nsection, you'll see it's almost exactly the same, except that we're\npassing a new `ctx` parameter into the respective `bind()` and `connect()`\ncalls, which is an instance of `SSLContext`.\n\nSo if you already know how to work with Python's built-in `SSLContext`\nobject, you can already create secure connections with `aiomsg` and\nthere's nothing more you need to learn.\n\nCrash course on setting up an ``SSLContext``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou might not know how to set up the ``SSLContext`` object.\nHere, I'll give a crash course, but please remember that I am\nnot a security expert so make sure to ask an actual security expert\nto review your work if you're working on a production system.\n\nThe best way to create an ``SSLContext`` object is **not** with its\nconstructor, but rather a helper function called ``create_default_context()``,\nwhich sets a lot of sensible defaults that you would otherwise have to\ndo manually. So that's how you get the context instance.\n\nYou do have to specify whether the purpose of the context object is to\nverify a client or a server. Let's have a look at that:\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\nSo here, above, we're creating a context object for a bind socket. The\npurpose of the context is going to be to *verify incoming client connections*,\nthat's why the ``CLIENT_AUTH`` purpose was given.  As you might imagine,\non the other end, i.e., the connect socket (or \"client\"), the purpose\nis going to be to verify the server:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\nOnce you've created the context, the remaining parameters have the same\nmeaning for both client and server.\n\nThe way TLS works (the artist formerly known as SSL) is that each end\nof a connection has two pieces of information:\n\n1. A **certificate** (may be shared publicly)\n2. A **key** (MUST NOT BE SHARED! SECRET!)\n\nWhen the two sockets establish a connection, they trade certificates, but\ndo not trade keys. Anyway, let's look at what you need to actually set\nin the code. We'll start with the connect socket (client).\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(<something that can verify the server cert>)\n\nThe above will let the client verify that the server it is connecting\nto is the correct one. When the socket connects, the server socket\nwill send back a *certificate* and the client checks that against one of\nthose mysterious \"verify locations\".\n\nFor mutual TLS, the server also wants to check the client. What does it\ncheck? Well, the client must also provide a certificate back to the server.\nSo that requires an additional line in the code block above:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(<something that can verify the server cert>)\n\n    # Client needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"client.cert\", keyfile=\"client.key\")\n\nSo that completes everything we need to do for the SSL context on the\nclient side.  On the server side, everything is almost exactly the same:\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.load_verify_locations(<something that can verify the client cert>)\n\n    # Server needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"server.cert\", keyfile=\"server.key\")\n\nThat describes everything you need to do to set up *mutual TLS* using\n``SSLContext`` instances.\n\nThere are a few loose ends to tie up though. Where do you get the\n``certfile`` and ``keyfile`` from? And what is this mysterious\n\"verify location\"? The first question is easier. The cert and key can be\ngenerated using the OpenSSL command-line application:\n\n.. code-block:: bash\n\n    $ openssl req -newkey rsa:2048 -nodes -keyout server.key \\\n        -x509 -days 365 -out server.cert \\\n        -subj '/C=GB/ST=Blah/L=Blah/O=Blah/OU=Blah/CN=example.com'\n\nRunning the above command will create two new files, ``server.cert`` and\n``server.key``; these are ones you specify in earlier commands. Generating\nthese files for the client is exactly the same, but you use different\nnames.\n\nYou could also use `Let's Encrypt <https://letsencrypt.org/>`_\nto generate the cert and key, in which case you don't have to run the\nabove commands. *IF* you use Let's Encrypt, you've also solved the\nother problem of supplying a \"verify location\", and in fact you won't need\nto call ``load_verify_locations()`` in the client code at all. This is\nbecause there are a bunch of *root certificate authorities* that are\nprovided with most operating systems, and *Let's Encrypt* is one of those.\n\nHowever, for the sake of argument, let's say you want to make your\nown certificates and you don't want to rely on system-provided root\ncertificates at all; how to do the verification? Well it turns out that\na very simple solution is to just use the target certificate itself to be\nthe \"verify location\". For example, here is the client context again:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(\"server.cert\")   # <--- Same one as the server\n\n    # Client needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"client.cert\", keyfile=\"client.key\")\n\nand then in the server's context, you could also use the client's cert\nas the \"verify location\":\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.load_verify_locations(\"client.cert)   # <--- Same as on client\n\n    # Server needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"server.cert\", keyfile=\"server.key\")\n\nObviously, the client code and the server code are running on different\ncomputers and you need to make sure that the right files are on the right\ncomputers in the right places.\n\nThere are a lot of ways to make this more sophisticated, but it's\nprobably a good idea to get the simple case working, as described above,\nbefore looking at the more complicated cases. A cool option is to make\nyour own *root certificate authority*, which can be a standard\n\"verify location\" in all your microservices, and then when you make certs\nand keys for each microservice, you just have to \"sign\" them with the\nroot key. This process is described in\n`Be your own certificate authority <https://opensource.com/article/19/4/certificate-authority>`_\nby Moshe Zadka\n\nHope that helps!\n\nFAQ\n===\n\nWhy do you spell ``Søcket`` like that?\n--------------------------------------\n\nThe slashed O is used in homage to `ØMQ <http://zeromq.org/>`_, a truly\nwonderful library that changed my thinking around what socket programming\ncould be like.\n\nI want to talk to the aiomsg Søcket with a different programming language\n-------------------------------------------------------------------------\n\n**WARNING: This section is extremely provisional. I haven't fully\nnailed down the protocol yet.**\n\nTo make a clone of the ``Søcket`` in another language is probably a\nlot of work, but it's actually not necessary to implement everything.\n\nYou can talk to ``aiomsg`` sockets quite easily by implementing the\nsimple protocol described below. It would be just like regular\nsocket programming in your programming language. You just have to\nfollow a few simple rules for the communication protocol.\n\nThese are the rules:\n\n#. **Every payload** in either direction shall be length-prefixed:\n\n   .. code-block::\n\n        message = [4-bytes big endian int32][payload]\n\n#. **Immediately** after successfully opening a TCP connection, before doing\n   anything else with your socket, you shall:\n\n    - Send your identity, as a 16 byte unique identifier (a 16 byte UUID4\n      is perfect). Note that Rule 1 still applies, so this would look like\n\n      .. code-block::\n\n           identity_message = b'\\x00\\x00\\x00\\x10' + [16 bytes]\n\n      (because the payload length, 16, is ``0x10`` in hex)\n\n    - Receive the other peer's identity (16 bytes). Remember Rule 1 still\n      applies, so you'll actually receive 20 bytes, and the first four will\n      be the length of the payload, which will be 16 bytes for this message.\n\n#. You shall **periodically** send a heartbeat message ``b\"aiomsg-heartbeat\"``.\n   Every 5 seconds is good. If you receive such messages you can ignore them.\n   If you don't receive one (or an actual data message) within 15 seconds\n   of the previous receipt,\n   the connection is probably dead and you should kill it and/or reconnect.\n   Note that Rule 1 still applies, and because the length of this message\n   is also 16 bytes, the message is ironically similar to the identity\n   message:\n\n   .. code-block::\n\n        heartbeat_message = b'\\x00\\x00\\x00\\x10' + b'aiomsg-heartbeat'\n\nAfter you've satisfied these rules, from that point on every message\nsent or received is a Rule 1 message, i.e., length prefixed with 4 bytes\nfor the length of the payload that follows.\n\nIf you want to run a *bind* socket, and receive multiple connections from\ndifferent ``aiomsg`` sockets, then the above rules apply to *each* separate\nconnection.\n\nThat's it!\n\nTODO: Discuss the protocol for ``AT_LEAST_ONCE`` mode, which is a bit messy\nat the moment.\n\nDeveloper setup\n===============\n\n1. Setup::\n\n    $ git clone https://github.com/cjrh/aiomsg\n    $ python -m venv venv\n    $ source venv/bin/activate  (or venv/Scripts/activate.bat on Windows)\n    $ pip install -e .[all]\n\n2. Run the tests::\n\n    $ pytest\n\n3. Create a new release::\n\n    $ bumpymcbumpface --push-git --push-pypi\n\nThe easiest way to obtain the\n`bumpymcbumpface <https://pypi.org/project/bumpymcbumpface/>`_ tool is\nto install it with `pipx <https://github.com/pipxproject/pipx>`_. Once installed\nand on your ``$PATH``, the command above should work. **NOTE: twine must be\ncorrectly configured to upload to pypi.**  If you don't have rights to\npush to PyPI, but you do have rights to push to github, just omit\nthe ``--push-pypi`` option in the command above. The command will\nautomatically create the next git tag and push it.\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/cjrh/aiomsg",
    "keywords": "asyncio socket network",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "aiomsg",
    "package_url": "https://pypi.org/project/aiomsg/",
    "platform": "",
    "project_url": "https://pypi.org/project/aiomsg/",
    "project_urls": {
      "Homepage": "https://github.com/cjrh/aiomsg"
    },
    "release_url": "https://pypi.org/project/aiomsg/2019.12.3/",
    "requires_dist": [
      "colorama ; extra == 'all'",
      "wheel ; extra == 'all'",
      "pytest ; extra == 'all'",
      "pytest-cov ; extra == 'all'",
      "twine ; extra == 'all'",
      "pygments ; extra == 'all'",
      "check-manifest ; extra == 'all'",
      "aiorun ; extra == 'all'",
      "pytest-benchmark ; extra == 'all'",
      "sphinx ; extra == 'all'",
      "portpicker ; extra == 'all'",
      "check-manifest ; extra == 'dev'",
      "colorama ; extra == 'dev'",
      "pygments ; extra == 'dev'",
      "twine ; extra == 'dev'",
      "wheel ; extra == 'dev'",
      "aiorun ; extra == 'dev'",
      "sphinx ; extra == 'doc'",
      "pytest ; extra == 'test'",
      "pytest-cov ; extra == 'test'",
      "portpicker ; extra == 'test'",
      "pytest-benchmark ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "Socket-based abstraction for messaging patterns",
    "version": "2019.12.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 6260589,
  "releases": {
    "2018.8.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f8a46362f3d2cf369ddc7c8970b9978191291b358e3a14723ac9e61f1daffa50",
          "md5": "c4e542eca1e7553f455cb1b4db4e9484",
          "sha256": "c9f6f5264491dcaff760220687bc20166c679ff09f33b773997accc9461623cb"
        },
        "downloads": -1,
        "filename": "aiomsg-2018.8.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c4e542eca1e7553f455cb1b4db4e9484",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13920,
        "upload_time": "2019-01-13T07:38:14",
        "upload_time_iso_8601": "2019-01-13T07:38:14.170146Z",
        "url": "https://files.pythonhosted.org/packages/f8/a4/6362f3d2cf369ddc7c8970b9978191291b358e3a14723ac9e61f1daffa50/aiomsg-2018.8.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0b01e959f021e0cc8bd09cd086a1db674af4f353cffb4b092c2a7fa0776276a1",
          "md5": "41284c924e044b463f592645a35eb071",
          "sha256": "ff37c7ff877ac8ea0e0dadb867b5d7c47e6f2dfd09cb86959bedc0da8e6702b3"
        },
        "downloads": -1,
        "filename": "aiomsg-2018.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "41284c924e044b463f592645a35eb071",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13741,
        "upload_time": "2019-01-13T07:38:16",
        "upload_time_iso_8601": "2019-01-13T07:38:16.244846Z",
        "url": "https://files.pythonhosted.org/packages/0b/01/e959f021e0cc8bd09cd086a1db674af4f353cffb4b092c2a7fa0776276a1/aiomsg-2018.8.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "29de23a3ed250c64849ae139a13e077b28dc3ea008dced5e40730db4c8a7d24d",
          "md5": "55575be415f89d2504d0b3bf934a986c",
          "sha256": "88e44571f570850e356fa350be2b510d429162164256bfe7a5669f2cd51e8e2d"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "55575be415f89d2504d0b3bf934a986c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13880,
        "upload_time": "2019-01-13T07:50:10",
        "upload_time_iso_8601": "2019-01-13T07:50:10.119641Z",
        "url": "https://files.pythonhosted.org/packages/29/de/23a3ed250c64849ae139a13e077b28dc3ea008dced5e40730db4c8a7d24d/aiomsg-2019.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fa5e3f410e24b82d5aadc4a7a2e1b4f91d1b8352ecfb266330de922411bc198b",
          "md5": "018a3b5a66bb7d090fedc4ec79dc715a",
          "sha256": "8636f452e21961e00fe84dfd14314f9554eb98ebf4d129bfee9d4dee2b3b60f4"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "018a3b5a66bb7d090fedc4ec79dc715a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13653,
        "upload_time": "2019-01-13T07:50:12",
        "upload_time_iso_8601": "2019-01-13T07:50:12.832711Z",
        "url": "https://files.pythonhosted.org/packages/fa/5e/3f410e24b82d5aadc4a7a2e1b4f91d1b8352ecfb266330de922411bc198b/aiomsg-2019.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.12.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eb9e95451bbc6bd598e00d96df78942a5a7c8e9712e7474cbca3249eaee69ba6",
          "md5": "76ad75333ebb7822692be94adb2b37e9",
          "sha256": "340b8f28363f7cdb98c91d10d72e0f2674c268062d94825a228cb0fbab25c358"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "76ad75333ebb7822692be94adb2b37e9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 27202,
        "upload_time": "2019-12-08T03:19:27",
        "upload_time_iso_8601": "2019-12-08T03:19:27.383270Z",
        "url": "https://files.pythonhosted.org/packages/eb/9e/95451bbc6bd598e00d96df78942a5a7c8e9712e7474cbca3249eaee69ba6/aiomsg-2019.12.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a317c116ce6c656c9aaefd91ed84eaca0e9403e7e43eaf757c5791950330e660",
          "md5": "912c122694ab9dc45f929f5de54c652d",
          "sha256": "79aed8eb45d3905fbdebc1962be8e6ef2a2935ada7a13ccf31a4a47e49795482"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.1.tar.gz",
        "has_sig": false,
        "md5_digest": "912c122694ab9dc45f929f5de54c652d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47080,
        "upload_time": "2019-12-08T03:19:30",
        "upload_time_iso_8601": "2019-12-08T03:19:30.289405Z",
        "url": "https://files.pythonhosted.org/packages/a3/17/c116ce6c656c9aaefd91ed84eaca0e9403e7e43eaf757c5791950330e660/aiomsg-2019.12.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.12.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a12fb25331f6fd2503a2352ae2163baa243fe809d834d5569c39e1e55aba6d23",
          "md5": "a1d9b670c253018d66743dc7c73893ba",
          "sha256": "d1a56b43dee6d44068949ebe6607a16cbf367fb44f99e4104d882cbe5a4e3bb0"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a1d9b670c253018d66743dc7c73893ba",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 27344,
        "upload_time": "2019-12-08T04:02:33",
        "upload_time_iso_8601": "2019-12-08T04:02:33.551432Z",
        "url": "https://files.pythonhosted.org/packages/a1/2f/b25331f6fd2503a2352ae2163baa243fe809d834d5569c39e1e55aba6d23/aiomsg-2019.12.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "84f315d41218171cd54991a1d089e1f0b6d2ad3a7721371dd6a15f8a83710f13",
          "md5": "6e07976268fc03a399c208573ece2154",
          "sha256": "99e074d55cf3ec0c8a84ad656c9f2c6ec3ad264bf403d337c7db401e92fef006"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.2.tar.gz",
        "has_sig": false,
        "md5_digest": "6e07976268fc03a399c208573ece2154",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47493,
        "upload_time": "2019-12-08T04:02:36",
        "upload_time_iso_8601": "2019-12-08T04:02:36.227244Z",
        "url": "https://files.pythonhosted.org/packages/84/f3/15d41218171cd54991a1d089e1f0b6d2ad3a7721371dd6a15f8a83710f13/aiomsg-2019.12.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.12.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a210557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428",
          "md5": "22c070d8845db96e9c86fcce4856fdc9",
          "sha256": "aa531c1bc267908242dd7c6896c784ff542712255e18c0d5048c273b45418d85"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "22c070d8845db96e9c86fcce4856fdc9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28122,
        "upload_time": "2019-12-08T05:34:46",
        "upload_time_iso_8601": "2019-12-08T05:34:46.516994Z",
        "url": "https://files.pythonhosted.org/packages/a2/10/557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428/aiomsg-2019.12.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "09e1674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945",
          "md5": "8c9c31bea97bdb555cc65aca2f226e74",
          "sha256": "87af01daffa77f4461a9a88cf0df7047eb82e6a3edc2a0033c335a17903f8ce4"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.12.3.tar.gz",
        "has_sig": false,
        "md5_digest": "8c9c31bea97bdb555cc65aca2f226e74",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 48243,
        "upload_time": "2019-12-08T05:34:49",
        "upload_time_iso_8601": "2019-12-08T05:34:49.604355Z",
        "url": "https://files.pythonhosted.org/packages/09/e1/674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945/aiomsg-2019.12.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9a71eb7904620ee3d6a5040ddc9af72eece523f1646fbf071b24c8249bccc5a1",
          "md5": "ec1306afa9917f344e040ff3f742e646",
          "sha256": "53c4b47994b2a1d1fd641f9f0add58254d76221d92b08f9dc7f8a069f4cd60c9"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ec1306afa9917f344e040ff3f742e646",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 14052,
        "upload_time": "2019-04-14T12:44:55",
        "upload_time_iso_8601": "2019-04-14T12:44:55.210173Z",
        "url": "https://files.pythonhosted.org/packages/9a/71/eb7904620ee3d6a5040ddc9af72eece523f1646fbf071b24c8249bccc5a1/aiomsg-2019.4.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d2d5f265f753e888bad69bfd0a11a8317d98558ec121adaa169b13cae1731b30",
          "md5": "c72225d421e50f0b566c19e02c5781db",
          "sha256": "121ee578664b7d7e8a265fc7024616b1b7e5f1be4533a89cf0e82ada0929189c"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "c72225d421e50f0b566c19e02c5781db",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 14221,
        "upload_time": "2019-04-14T12:44:57",
        "upload_time_iso_8601": "2019-04-14T12:44:57.096413Z",
        "url": "https://files.pythonhosted.org/packages/d2/d5/f265f753e888bad69bfd0a11a8317d98558ec121adaa169b13cae1731b30/aiomsg-2019.4.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.12": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "924ac6e8ad37be9679d462e0f8ba0fef518df71ad4243902f9baf30ef0245ae8",
          "md5": "ca4842f8819a947d8195b75e17df0147",
          "sha256": "5e277294f16614f56521f0d10f99bbbda11ab53d1629a67d8fac19a3aa28a7cc"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.12-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ca4842f8819a947d8195b75e17df0147",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23337,
        "upload_time": "2019-04-29T13:09:44",
        "upload_time_iso_8601": "2019-04-29T13:09:44.202787Z",
        "url": "https://files.pythonhosted.org/packages/92/4a/c6e8ad37be9679d462e0f8ba0fef518df71ad4243902f9baf30ef0245ae8/aiomsg-2019.4.12-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6de983a92a4367ff4cb126c89df31ace437060234879a97b227169ea36d03d2e",
          "md5": "c1d2db80dd9dad7e5a9ebc418a2231fe",
          "sha256": "824b5b502a8c7b4cd7ece6b66975796f1bc6bda54cd29834985f5753e5309809"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.12.tar.gz",
        "has_sig": false,
        "md5_digest": "c1d2db80dd9dad7e5a9ebc418a2231fe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 36396,
        "upload_time": "2019-04-29T13:09:53",
        "upload_time_iso_8601": "2019-04-29T13:09:53.294781Z",
        "url": "https://files.pythonhosted.org/packages/6d/e9/83a92a4367ff4cb126c89df31ace437060234879a97b227169ea36d03d2e/aiomsg-2019.4.12.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.13": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "af203aa93b5abe19a19637397ffb09de8a0581ddd5d0c07ac86f09daf88a7274",
          "md5": "5b507ed5c4577a63c4e098630ae329bd",
          "sha256": "b37863b9acada1096583f6c7ede1b0c943834a448dbc16c695baf52a524d86f3"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.13-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5b507ed5c4577a63c4e098630ae329bd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24192,
        "upload_time": "2019-05-12T09:18:34",
        "upload_time_iso_8601": "2019-05-12T09:18:34.261670Z",
        "url": "https://files.pythonhosted.org/packages/af/20/3aa93b5abe19a19637397ffb09de8a0581ddd5d0c07ac86f09daf88a7274/aiomsg-2019.4.13-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4c555615546e97195f524f49f9e3104f6d15839b80cebb10d5424b27e071bcda",
          "md5": "8a48af63b0c0416aa78258121916b6ea",
          "sha256": "8495987bef2d88748845dc9ffedb67936a96e0f94898a46c8912849b9fd88421"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.13.tar.gz",
        "has_sig": false,
        "md5_digest": "8a48af63b0c0416aa78258121916b6ea",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39458,
        "upload_time": "2019-05-12T09:18:38",
        "upload_time_iso_8601": "2019-05-12T09:18:38.072691Z",
        "url": "https://files.pythonhosted.org/packages/4c/55/5615546e97195f524f49f9e3104f6d15839b80cebb10d5424b27e071bcda/aiomsg-2019.4.13.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8a4e56c33932130ab9648c8954b35c59b2e17c3e5da7b38d2c6847e228e00c45",
          "md5": "5f061d01b386542f43218c82c5e7917d",
          "sha256": "ddbd35226a9975d52cf7a0e3dcccd00309c598cef9f59d8baf95a9cc444311e3"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5f061d01b386542f43218c82c5e7917d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 17969,
        "upload_time": "2019-04-27T00:21:54",
        "upload_time_iso_8601": "2019-04-27T00:21:54.921187Z",
        "url": "https://files.pythonhosted.org/packages/8a/4e/56c33932130ab9648c8954b35c59b2e17c3e5da7b38d2c6847e228e00c45/aiomsg-2019.4.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3707471a75239e0b70ed7bde2f5b3046e989f0fae8844b1c650cebca9220421e",
          "md5": "c5b157fb63d7cfda2e4816cccf888888",
          "sha256": "81c60f241ea7a028fa1503ac0c1d36c00f67a919af9106697add7760590ab3fa"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.2.tar.gz",
        "has_sig": false,
        "md5_digest": "c5b157fb63d7cfda2e4816cccf888888",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18861,
        "upload_time": "2019-04-27T00:21:56",
        "upload_time_iso_8601": "2019-04-27T00:21:56.962776Z",
        "url": "https://files.pythonhosted.org/packages/37/07/471a75239e0b70ed7bde2f5b3046e989f0fae8844b1c650cebca9220421e/aiomsg-2019.4.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e0995a18baeb8362256a405029b0f26c9f1378e170d455d1ed97e168de80db80",
          "md5": "e23db30da55c708a3828c5a9109f2f80",
          "sha256": "54e736b8112acc750fece4653b59f5e982eb5ed93f95071624033bac3dc59838"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e23db30da55c708a3828c5a9109f2f80",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 17968,
        "upload_time": "2019-04-27T00:26:46",
        "upload_time_iso_8601": "2019-04-27T00:26:46.107153Z",
        "url": "https://files.pythonhosted.org/packages/e0/99/5a18baeb8362256a405029b0f26c9f1378e170d455d1ed97e168de80db80/aiomsg-2019.4.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fbc2907ff68dad09b417af6e131d372beaea8bbb5d0145f7f98268cadb09747f",
          "md5": "64e2fb1a10b9c136e331573e7297afc3",
          "sha256": "47f6db38bf78ea46ee2fad3a5f7ff2e040750b3018862ddc571c7d2388ac6e09"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.3.tar.gz",
        "has_sig": false,
        "md5_digest": "64e2fb1a10b9c136e331573e7297afc3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18858,
        "upload_time": "2019-04-27T00:26:48",
        "upload_time_iso_8601": "2019-04-27T00:26:48.278779Z",
        "url": "https://files.pythonhosted.org/packages/fb/c2/907ff68dad09b417af6e131d372beaea8bbb5d0145f7f98268cadb09747f/aiomsg-2019.4.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "542fedd99b9371ef1091d2bc1d79f25511204b005f75eb602b7e11c84df307c1",
          "md5": "f154130df9f1ff49032dc47f354e8121",
          "sha256": "013236c34ea7ed72f057db00a288d57aba44fc3275f6bf9a115380a74d8c01ff"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f154130df9f1ff49032dc47f354e8121",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 18348,
        "upload_time": "2019-04-28T04:11:19",
        "upload_time_iso_8601": "2019-04-28T04:11:19.687031Z",
        "url": "https://files.pythonhosted.org/packages/54/2f/edd99b9371ef1091d2bc1d79f25511204b005f75eb602b7e11c84df307c1/aiomsg-2019.4.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "43a613c1f630f2f2642cc2a22d9bb3dc17eef3e0d91f16e05f27114a8dbaa7a2",
          "md5": "64dc79a20fd0fcb438c6642ed6a2920d",
          "sha256": "0df8e7d7d1f0d62e5488500de1b11a6a3d89e9a5f39a52e57a0dc856074812a8"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.4.tar.gz",
        "has_sig": false,
        "md5_digest": "64dc79a20fd0fcb438c6642ed6a2920d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 19530,
        "upload_time": "2019-04-28T04:11:22",
        "upload_time_iso_8601": "2019-04-28T04:11:22.170781Z",
        "url": "https://files.pythonhosted.org/packages/43/a6/13c1f630f2f2642cc2a22d9bb3dc17eef3e0d91f16e05f27114a8dbaa7a2/aiomsg-2019.4.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.4.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "97568921a8a6cafee5a89db4d661fa17414323508b281d972533685e9df6538d",
          "md5": "f62f191bad4e4d20bd42a1cc07272eac",
          "sha256": "850ce8d07e8b9795d779ba949039aa568bd9d8b9555e1521a8999fe11f29d97f"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f62f191bad4e4d20bd42a1cc07272eac",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23310,
        "upload_time": "2019-04-28T13:01:38",
        "upload_time_iso_8601": "2019-04-28T13:01:38.487164Z",
        "url": "https://files.pythonhosted.org/packages/97/56/8921a8a6cafee5a89db4d661fa17414323508b281d972533685e9df6538d/aiomsg-2019.4.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b26c9bc9639cd2e786cfe36e20738ff2540ea46623210f3ffc52c1f089b82381",
          "md5": "8bdcccb4ab15bbb59e26f0c292cdfed7",
          "sha256": "ac332e9fe1400a2a311caf891fe29aa361ab3fbb06ffd1343eb7c1eb25238156"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.4.5.tar.gz",
        "has_sig": false,
        "md5_digest": "8bdcccb4ab15bbb59e26f0c292cdfed7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 35628,
        "upload_time": "2019-04-28T13:01:41",
        "upload_time_iso_8601": "2019-04-28T13:01:41.438876Z",
        "url": "https://files.pythonhosted.org/packages/b2/6c/9bc9639cd2e786cfe36e20738ff2540ea46623210f3ffc52c1f089b82381/aiomsg-2019.4.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5261888d7b3b2c36de887432a5bd203a69be07ed848997d6ef9e8159a1d21771",
          "md5": "ca88b5d87559b39e85b1cbe26d8c715f",
          "sha256": "41923dccf865787fc718c14788da6a90da09f51d7abeace1c7a1a03e71e9fa6e"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ca88b5d87559b39e85b1cbe26d8c715f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24145,
        "upload_time": "2019-05-27T12:11:43",
        "upload_time_iso_8601": "2019-05-27T12:11:43.235043Z",
        "url": "https://files.pythonhosted.org/packages/52/61/888d7b3b2c36de887432a5bd203a69be07ed848997d6ef9e8159a1d21771/aiomsg-2019.5.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1b3e0394c08803595f1e6c6d9a27cacb28c101bdd0044bcef182f3e58678b0ff",
          "md5": "1420df2fe92cef9d843f82e3d10cf940",
          "sha256": "2678eb3f04aaae3c42a8a374452119acac0ffdcbb9d6bc4309692911e607135d"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1420df2fe92cef9d843f82e3d10cf940",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38440,
        "upload_time": "2019-05-27T12:11:45",
        "upload_time_iso_8601": "2019-05-27T12:11:45.635966Z",
        "url": "https://files.pythonhosted.org/packages/1b/3e/0394c08803595f1e6c6d9a27cacb28c101bdd0044bcef182f3e58678b0ff/aiomsg-2019.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.5.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7fd5f289d949e022db0926ab4bfae8e2251ff741d26308baa8e80fef0dba699f",
          "md5": "8993da8eb2be31e6e14e7cdff4f1d234",
          "sha256": "c3decc34cee14b34c713d8e015095adb407da71736eca7c540c67d6df287bec8"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8993da8eb2be31e6e14e7cdff4f1d234",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 24258,
        "upload_time": "2019-06-05T23:58:57",
        "upload_time_iso_8601": "2019-06-05T23:58:57.011579Z",
        "url": "https://files.pythonhosted.org/packages/7f/d5/f289d949e022db0926ab4bfae8e2251ff741d26308baa8e80fef0dba699f/aiomsg-2019.5.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7c2d5286b5844d5ec491bb04e3ed533664ec4a561906ed067cdf6c4adb794859",
          "md5": "9642e73e2d78dbdf8d182949a76c165a",
          "sha256": "f9d84076e86921062bf7fe8a1e90e04fdb3acae6d365cc9107baec99354f6890"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.2.tar.gz",
        "has_sig": false,
        "md5_digest": "9642e73e2d78dbdf8d182949a76c165a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38943,
        "upload_time": "2019-06-05T23:58:59",
        "upload_time_iso_8601": "2019-06-05T23:58:59.278783Z",
        "url": "https://files.pythonhosted.org/packages/7c/2d/5286b5844d5ec491bb04e3ed533664ec4a561906ed067cdf6c4adb794859/aiomsg-2019.5.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2019.5.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "289b92836b57835adc09650fcfb8812acaed036db6bd16ce21db5e6a082c6b12",
          "md5": "b23fad69a8b2198d81cc8d1294acc565",
          "sha256": "099c8cde3c605ce764b135f0999ce8c5bf4eb1eed238ce9154a9e75ad878b694"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b23fad69a8b2198d81cc8d1294acc565",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26989,
        "upload_time": "2019-06-06T14:08:31",
        "upload_time_iso_8601": "2019-06-06T14:08:31.695970Z",
        "url": "https://files.pythonhosted.org/packages/28/9b/92836b57835adc09650fcfb8812acaed036db6bd16ce21db5e6a082c6b12/aiomsg-2019.5.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a17b7319bb8ee4dbedb03980e49802428cdf297375457eb0a3e4a6b9b3b710d9",
          "md5": "f315cd293b3838fca8bdae2393b6ec01",
          "sha256": "809731c911a397b2c89b1033812de40b5cfa35314703ed2bee7551d6ffdd07f7"
        },
        "downloads": -1,
        "filename": "aiomsg-2019.5.3.tar.gz",
        "has_sig": false,
        "md5_digest": "f315cd293b3838fca8bdae2393b6ec01",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47556,
        "upload_time": "2019-06-06T14:08:34",
        "upload_time_iso_8601": "2019-06-06T14:08:34.237899Z",
        "url": "https://files.pythonhosted.org/packages/a1/7b/7319bb8ee4dbedb03980e49802428cdf297375457eb0a3e4a6b9b3b710d9/aiomsg-2019.5.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a210557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428",
        "md5": "22c070d8845db96e9c86fcce4856fdc9",
        "sha256": "aa531c1bc267908242dd7c6896c784ff542712255e18c0d5048c273b45418d85"
      },
      "downloads": -1,
      "filename": "aiomsg-2019.12.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "22c070d8845db96e9c86fcce4856fdc9",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 28122,
      "upload_time": "2019-12-08T05:34:46",
      "upload_time_iso_8601": "2019-12-08T05:34:46.516994Z",
      "url": "https://files.pythonhosted.org/packages/a2/10/557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428/aiomsg-2019.12.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "09e1674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945",
        "md5": "8c9c31bea97bdb555cc65aca2f226e74",
        "sha256": "87af01daffa77f4461a9a88cf0df7047eb82e6a3edc2a0033c335a17903f8ce4"
      },
      "downloads": -1,
      "filename": "aiomsg-2019.12.3.tar.gz",
      "has_sig": false,
      "md5_digest": "8c9c31bea97bdb555cc65aca2f226e74",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 48243,
      "upload_time": "2019-12-08T05:34:49",
      "upload_time_iso_8601": "2019-12-08T05:34:49.604355Z",
      "url": "https://files.pythonhosted.org/packages/09/e1/674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945/aiomsg-2019.12.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}