{
  "info": {
    "author": "Bea Steers",
    "author_email": "bea.steers@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# wrappingpaper\n\nA collection of Python decorators and utilities to abstract away common/tedious Python patterns.\n\n#### Notes\n\nThis package is more about providing interesting abstractions and trying to flesh out the possibilities of Python code organization. I am in no way saying that using these functions will provide \"good\" code and I am in no way condoning their use for creating evil Python code ;).\n\nSome of the functions in here may incentivize less understandable code, but that's okay. I want to give them space to exist and hopefully we can develop them further to where they will be more understandable and provide more intuitive and familiar abstractions.\n\nThis package is about experimentation and trying to create basic, interesting, natural feeling, and convenient abstractions while sidelining the scrutiny of Python purists, and potentially people with more sense (!!). I want this to try to push the limits of the language to see what other interesting constructs we can facilitate.\n\nSo, I guess the motto of this package is to develop freely, but use responsibly. <3\n\nOne other thing to note though, some of these don't play nice with linters ðŸ˜¢\n\n#### Simple Example\n```python\nimport wrappingpaper as wp\n\n@wp.contextdecorator\ndef doing_something(a, b):\n    print(a)\n    yield\n    print(b)\n\n# por que no los dos?\n\n# you can do this\nwith doing_something(4, 5):\n    print(1)\n# prints 4 1 5\n\n# as well as this\n@doing_something(4, 5)\ndef something():\n    print(1)\nsomething()\n# prints 4 1 5\n\n```\n\n#### Includes\n - [helper modules](#helper-modules)\n    - real implementations of faux imports, meant as case-studies for import mechanic classes provided.\n - [logging / error handling](#logging)\n    - catch errors thrown in a function and redirect to logger\n - [context managers](#context-managers)\n   - context managers that double as function wrappers\n - [object properties](#properties)\n    - class and instance caching\n    - dynamic property objects - give properties nested attributes and methods !!\n - [function signature helpers](#function-signature)\n    - override and apply updates to function signatures\n    - filter function arguments that are outside the function schema\n    - partial that actually updates the wrapper\n - [import mechanics](#import-mechanics)\n    - create faux modules and customize how modules are imported (I did some of the confusing bits for us thankfully)\n - [iterables](#iterables)\n    - includes some basic iterable functions that I've pulled from other projects so I don't have to keep duplicating them everywhere\n - [misc](#misc)\n    - stuff I just haven't sorted. ya know?\n    - retry on exception\n    - check circular references\n\n\n## Install\n\n```bash\npip install wrappingpaper\n```\n\n## Usage\n```python\nimport wrappingpaper as wp\n```\n\n### Helper Modules\n\nThese are faux modules that utilize `wrappingpaper`'s [import mechanics](#import-mechanics) to alter modules that are imported from them.\n\n#### lazyimport\nThis is a simple implementation of lazy importing using the defined import mechanics.\n\n```python\nfrom lazyimport import sklearn\nimport librosa # sklearn imports will be lazy\n```\n\n#### presets\nThis is a re-implimentation of [bmcfee/presets](https://github.com/bmcfee/presets) that includes the import mechanics, instead of having to wrap modules afterwards. I may add a PR to that package, but implementing it here was trivial for the time being and I didn't feel like it was important enough to push it thru the review process.\n\n```python\nfrom presets import librosa\nlibrosa.update(sr=44100) # now functions will default to sr=44100\n```\n\n### Logging\n\n**NOTE: I haven't put in the work to mock logging objects for testing so beware that in their current form they are untested and most likely have 1 or 2 bugs in there.**\n\nI was working on a project that was full of error suppression and logging. There would be functions wrapped in try except blocks, logging calls, and a lot of redundancy in the scaffolding needed.\n\nSo I did work to factor that out and perform many of the common patterns in decorators.\n\nThe logging decorators here are primarily for functions that can be permitted to fail and return a default/empty value without the rest of the program breaking.\n\nIt also has utilities for pulling information from tracebacks. I haven't done anything about the logging Handlers and Formatters so that's a TODO.\n\n```python\nimport logging\nlog = logging.getLogger(__name__)\n\n# handle and log error\n\n@wp.log_error_as_warning(log, default=dict)\ndef get_stats(x=None):\n    if x is True:\n        raise ValueError() # some error happens\n    return {'a': 5, 'b': 6}\n\nassert get_stats() == {'a': 5, 'b': 6}\nassert get_stats(True) == {}\n```\n\n##### Roughly equivalent to:\n\n```python\ndef get_stats(x=None):\n    try:\n        if x is True:\n            raise ValueError() # some error happens\n        return {'a': 5, 'b': 6}\n    except ValueError as e:\n        log.warning('Exception in get_stats: %s', e)\n        return {}\n```\n\n### Context Managers\n\nTwo common patterns in Python are context managers and decorators. Often, they have the same basic structure: do some initialization, run a function, and do some cleanup.\n\nAnd both can be useful in different contexts to give you clean code, but to use both, I often find myself writing an additional wrapper function around the context manager, and then you have to give it a slightly different name and it can get confusing.\n\nSo, in comes `contextdecorator` which works the same as `contextlib.contextmanager`, but it also doubles as a function decorator. When used as a decorator, it will call the function inside the context manager.\n\n```python\n\n@wp.contextdecorator\ndef doing_something(a, b):\n    print(a)\n    yield\n    print(b)\n\n# por que no los dos?\n\n# you can do this\nwith doing_something(4, 5):\n    print(1)\n\n# as well as this\n@doing_something(4, 5)\ndef something():\n    print(1)\nsomething()\n\n```\n\nSometimes, your decorator isn't as simple and you need to do things a bit differently in the decorator (e.g. you need the name of the wrapped function).\n\n```python\n\n@doing_something.caller # override default decorator\ndef doing_something(func, a, b): # wrapped function, decorator arguments\n    # change arguments\n    name = func.__name__\n    a = 'calling {}: {}'.format(name, a)\n    b = 'calling {}: {}'.format(name, b)\n\n    # return the wrapped function\n    @functools.wraps(func)\n    def inner(*args, **kw):\n        with doing_something(a, b):\n            return func(*args, **kw)\n    return inner\n\n```\n\n##### Roughly equivalent to:\n\n```python\nimport functools\nfrom contextlib import contextmanager\n\n@contextmanager\ndef doing_something(a, b):\n    print(a)\n    yield\n    print(b)\n\ndef doing_something2(a, b):\n    def outer(func):\n        @functools.wraps(func)\n        def inner(*a, **kw):\n            with doing_something(a, b):\n                return func(*a, **kw)\n        return inner\n    return outer\n\n# used like:\nwith doing_something(4, 5):\n    print(1)\n\n@doing_something2(4, 5)\ndef something():\n    print(1)\nsomething()\n\n```\n\n### Properties\n\nPython property objects are incredibly useful as they allow you to create natural feeling objects with some complex stuff all bundled up in a nice unsuspecting interface.\n\nBut using them, there are often times where I find myself writing the same classes stored many times over in utility files.\n\nOne use-case is caching. There are different levels of caching that you can provide.\n - `cachedproperty`: cached on the instance object - runs once per instance\n - `onceproperty`: cached on the class object - runs once per class/baseclass\n - `overridable_property`: works as a normal property (calls the wrapped function), until the property is assigned to. Then it returns the assigned value.\n - `overridable_method`: works as a normal method (calls the wrapped function), until the function is called as a decorator. Then it calls the wrapped function. Works on an instance level.\n\n```python\nimport time\n\nclass SomeClass:\n    @wp.cachedproperty\n    def instance_prop(self):\n        '''This is run once per object instance.'''\n        return time.time()\n\n    @wp.onceproperty\n    def class_prop(self):\n        '''This is run once. It is cached in the property\n        object itself.'''\n        return time.time()\n\n    @wp.overridable_property\n    def overridable(self):\n        '''This property is run normally, until another value is assigned on top.'''\n        return time.time()\n\n    def __init__(self, overridable=None):\n        if overridable: # override the property value\n            # stores at self._overridable\n            self.overridable = overridable\n        # otherwise it just uses the property function like usual\n\na = SomeClass()\nb = SomeClass()\n\nassert a.instance_prop != b.instance_prop # prop runs once per object\nassert a.class_prop == b.class_prop # prop runs only once\nassert a.overridable != a.overridable # gets called twice, shouldn't be the same\na.overridable = 5\nassert a.overridable == 5 # now the value is overridden\n\nassert SomeClass(5).overridable == 5 # overriding inside class\n```\n\n### Function Signature\n\nThis is something that I'm looking for constantly.\n\nPersonally, I like the idea of config files that wrap up a bunch of function arguments into a file.\n\nI also hate having to duplicate arguments when passing variables down 5 levels of nested function calls.\n\nI like to just pass keyword arguments (`**kw`) down to the next function.\n\nBut there are cases, where there are extra config values in your keyword dict and you only want to pass the values that your function takes.\n\n\n```python\n# dynamic function defaults\n\n@wp.configfunction\ndef asdf(a=5, b=6, c=7):\n    return a + b + c\n\nassert asdf() == 5+6+7 # normal behavior\nasdf.update(a=1)\nassert asdf() == 1+6+7 # updated default\nassert asdf(3) == 3+6+7 # automatically resolves kwargs and posargs\nasdf.clear()\nassert asdf() == 5+6+7 # back to normal behavior\n\n# filter out kwargs not in the signature (if **kw, it's a no-op).\n\n@wp.filterkw\ndef asdf(a=5, b=6, c=7):\n    return a + b + c\n\nassert asdf(b=10, d=1234) == 5+10+7\n\n```\n\n### Objects\n\n\n#### Monkeypatching\n```python\nclass Blah:\n    def asdf(self):\n        return 10\n\nb = Blah()\n\n@wp.monkeypatch(b)\ndef asdf():\n    return 11\n\nassert asdf() == 11\n\nasdf.reset() # remove patch\nassert asdf() == 10\n\nasdf.repatch() # re-place the patch\nassert asdf() == 11\n```\n\n#### Namespace\n```python\nclass something(metaclass=wp.namespace):\n    one_thing = 5\n    other_thing = 6\n\n    def blah(x):\n        return one_thing + other_thing + x\n\nassert something.blah(10) == 5+6+10\n```\n\n### Iterables\n\n```python\n#####################\n# loop breaking\n#####################\n\nitems = wp.until(x if x != 7 else wp.done for x in range(10))\nassert list(items) == list(range(0, 6))\n\n\n####################\n# loop throttling\n####################\n\n# make sure that a for loop doesn't go too fast.\n# limit the time one iteration takes.\nt0 = time.time()\nfor x in wp.throttled(range(10), 1):\n    print(x)\nassert time.time() - t0 > 10\n\n# limiting the number of iterations to 10.\n# with no iterable passed, it loops infinitely and\n# yields the total yield time and the time it had to sleep.\nfor dt, time_asleep in wp.limit(wp.throttled(secs=1), 10):\n    print('Iteration took {}s. Had to sleep for {}s.'.format(dt, time_asleep))\n    print('-'*10)\n\n################################\n# Use `while True:` in a loop\n################################\n\nfor _ in wp.infinite():\n    print('this is gonna be a while...')\n\n\n#########################\n# pre-check an iterable\n#########################\n\n# check the first n items in an iterable, without removing them.\n\nit = iter(range(6))\nitems, it = wp.pre_check_iter(it, 3)\nassert items == [0, 1, 2]\nassert list(it) == [0, 1, 2, 3, 4, 5, 6]\n\n\n###########################################\n# repeat and chain a function infinitely\n###########################################\n\nimport random\n\ndef get_numbers(): # function returns an iterable\n    return [random.random() for _ in range(10)]\n\n\n\nnumbers = wp.run_iter_forever(get_numbers)\n# repeat get_numbers() and chain iterable outputs together\nall_numbers = list(wp.limit(numbers, 100))\nassert all(isinstance(x, float) for x in all_numbers)\n\n# If no items are returned by a call, instead of the iterable hanging\n# indefinitely waiting for an item, return None.\n\ndef get_numbers():\n    if random.random() > 0.8: # make random breaks\n        return # returns empty\n    return [random.random() for _ in range(10)]\n\nnumbers = wp.run_iter_forever(get_numbers, none_if_empty=True)\n# this SHOULD contain sporadic None's at a multiple of 10\nall_numbers = list(wp.limit(numbers, 5000))\nassert None in all_numbers\n\n```\n\n## Import Mechanics\n\nThis is probably the most dangerous thing to be playing with in here.\n\nPython exposes a lot of its internal mechanics including its import system.\n\nSo we can take advantage of that to provide import wrappers that modify module behavior.\n\nA basic example - lazy loading:\n\n```python\n# lazyimport/__init__.py\nimport wrappingpaper as wp\nwp.lazy_loader.activate(__name__)\n\n\n# main.py\nfrom lazyimport import sklearn.model_selection\n\n# sklearn is not currently loaded\n\nsklearn.model_selection.train_test_split() # now it's loaded.\n```\n\n#### Modify a module after it has been imported from your pseudo-module\n```python\nimport wrappingpaper as wp\n\n@wp.PseudoImportFinder.modulemodifier\ndef my_loader(module):\n    module.sneakything = '......hi'\n\nmy_loader.activate('somethingrandom')\n\n# now somewhere else, you can do\n\nfrom somethingrandom import numpy as np\n\nassert np.sneakything == '......hi'\n```\n#### Wrap a module to modify the module's contents\n```python\nimport importlib\nimport wrappingpaper as wp\n\n# create the module wrapper that will traverse and modify the module when it is loaded.\n\nclass Module(wp.ModuleWrapper):\n    # this is called for each item in the module\n    def _wrapattr(self, attr, value):\n        # do whatever you want with the value\n        if callable(value) and getattr(value, '__doc__', None) is not None:\n            value.__doc__ += '\\nI was here.'\n        elif self._is_submodule(value):\n            value = Module(value)\n        # always pass attr and modified value to be set,\n        # otherwise it will be undefined.\n        super()._wrapattr(attr, value)\n\n\n# applies the module wrapper on load\n\n@wp.PseudoImportFinder.moduleloader\ndef my_loader(spec):\n    return Module(importlib.util.module_from_spec(spec))\n\n\n# somewhere else (or in the same place. I'm not ur mom), actually use it\n\nwith my_loader.activated('somethingrandom'): # activated only inside context\n    from somethingrandom import glob\n\nprint(glob.glob.__doc__)\nassert glob.glob.__doc__.endswith('I was here.')\n```\n\n\n## Misc\n\nSome other miscellaneous stuff that I have yet to organize.\n\n```python\nimport random\n\n# retry a function if an exception is raised\n\n@wp.retry_on_failure(10)\ndef asdf():\n    x = random.random()\n    if x < 0.5:\n        raise ValueError\n    return x\n\n# will either return a number that is definitely > 0.5\n# or every number in the first 10 tries were below 0.5\ntry:\n    assert asdf() > 0.5\nexcept ValueError:\n    print(\"Couldn't get a number :/\")\n\n\n# ignore error\n\nwith wp.ignore():\n    a, b = 5, 0\n    c = a / b # throws divide by zero\n    a = 10 # never run\nassert a == 5\n\n```",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/beasteers/wrappingpaper",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "wrappingpaper",
    "package_url": "https://pypi.org/project/wrappingpaper/",
    "platform": "",
    "project_url": "https://pypi.org/project/wrappingpaper/",
    "project_urls": {
      "Homepage": "https://github.com/beasteers/wrappingpaper"
    },
    "release_url": "https://pypi.org/project/wrappingpaper/0.0.6/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "",
    "version": "0.0.6",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8317270,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e43594edf8aa9357a07e4c1698334b67f3ae91901a4031c70bd3d0e700e424db",
          "md5": "bc0f2cd079c765a0919df57a2e53f5a2",
          "sha256": "c017d2b674261ae5eeb503a7f0c5f39883db9032d3ef299efc299fa1ceb3c6d1"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "bc0f2cd079c765a0919df57a2e53f5a2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 9962,
        "upload_time": "2020-06-18T21:54:56",
        "upload_time_iso_8601": "2020-06-18T21:54:56.802068Z",
        "url": "https://files.pythonhosted.org/packages/e4/35/94edf8aa9357a07e4c1698334b67f3ae91901a4031c70bd3d0e700e424db/wrappingpaper-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9aa0f455e951c08d17b1cf8815958316772e4a09c707f7017b8e8e6a3790094d",
          "md5": "1b6871cce7d01fa7b2b994b30fe28a06",
          "sha256": "f2d8df01f379653e0b900a2ae5b53d0448ea72d2e9a72626d7ee1e00ad445616"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1b6871cce7d01fa7b2b994b30fe28a06",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 9958,
        "upload_time": "2020-06-18T22:12:41",
        "upload_time_iso_8601": "2020-06-18T22:12:41.843952Z",
        "url": "https://files.pythonhosted.org/packages/9a/a0/f455e951c08d17b1cf8815958316772e4a09c707f7017b8e8e6a3790094d/wrappingpaper-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6e694bd8908ffe3b220498e83ea91272b9621ec55940e828daed07ebd79ca93f",
          "md5": "c357b96c2e07ea97146af3be223a192b",
          "sha256": "38e8f05836d5b7e27644386247847e4d09e05b1306a647ce7482ded99846568e"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "c357b96c2e07ea97146af3be223a192b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 14925,
        "upload_time": "2020-06-22T15:01:49",
        "upload_time_iso_8601": "2020-06-22T15:01:49.863121Z",
        "url": "https://files.pythonhosted.org/packages/6e/69/4bd8908ffe3b220498e83ea91272b9621ec55940e828daed07ebd79ca93f/wrappingpaper-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f6acac1aeb51e0112b478a9f484006e9cadfeb2a42478277277557d061ae0b7a",
          "md5": "82f54bfe7ad628a7c72d59105d4ff523",
          "sha256": "09d1c829f065c90b5b4951a43d417f297223b10aa39c2934fe789a8c7649c21f"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "82f54bfe7ad628a7c72d59105d4ff523",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 20439,
        "upload_time": "2020-06-23T18:21:46",
        "upload_time_iso_8601": "2020-06-23T18:21:46.575418Z",
        "url": "https://files.pythonhosted.org/packages/f6/ac/ac1aeb51e0112b478a9f484006e9cadfeb2a42478277277557d061ae0b7a/wrappingpaper-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "21e5bfa29942acc8330e9783aeea4fafccea36c2ec211cb1590a6532f68ff1a8",
          "md5": "79830df82bda70fbad7c667989a4a3ee",
          "sha256": "11739d6f9cb9cddd4414ac201532362423fddf75d9465278a85496014b26ffcb"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "79830df82bda70fbad7c667989a4a3ee",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28411,
        "upload_time": "2020-07-22T20:59:46",
        "upload_time_iso_8601": "2020-07-22T20:59:46.447424Z",
        "url": "https://files.pythonhosted.org/packages/21/e5/bfa29942acc8330e9783aeea4fafccea36c2ec211cb1590a6532f68ff1a8/wrappingpaper-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d4092fce8a3a49a9750513d68ce9a39e8115e5b92f736bf307174a07caac754e",
          "md5": "00792f53d0e3dea84cf798a2773b38ed",
          "sha256": "6180e25b8a31ff7507c73e8c77b9aeb086c678e4ab47a6e8456f3352670da717"
        },
        "downloads": -1,
        "filename": "wrappingpaper-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "00792f53d0e3dea84cf798a2773b38ed",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 29938,
        "upload_time": "2020-10-01T16:38:45",
        "upload_time_iso_8601": "2020-10-01T16:38:45.249758Z",
        "url": "https://files.pythonhosted.org/packages/d4/09/2fce8a3a49a9750513d68ce9a39e8115e5b92f736bf307174a07caac754e/wrappingpaper-0.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d4092fce8a3a49a9750513d68ce9a39e8115e5b92f736bf307174a07caac754e",
        "md5": "00792f53d0e3dea84cf798a2773b38ed",
        "sha256": "6180e25b8a31ff7507c73e8c77b9aeb086c678e4ab47a6e8456f3352670da717"
      },
      "downloads": -1,
      "filename": "wrappingpaper-0.0.6.tar.gz",
      "has_sig": false,
      "md5_digest": "00792f53d0e3dea84cf798a2773b38ed",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 29938,
      "upload_time": "2020-10-01T16:38:45",
      "upload_time_iso_8601": "2020-10-01T16:38:45.249758Z",
      "url": "https://files.pythonhosted.org/packages/d4/09/2fce8a3a49a9750513d68ce9a39e8115e5b92f736bf307174a07caac754e/wrappingpaper-0.0.6.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}