{
  "info": {
    "author": "Viktor Yastrebov",
    "author_email": "Viktor Yastrebov <vyastrebov@vareger.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# zkSync2 client sdk\n\n## Contents\n- [Getting started](#getting-started)\n- [Provider](#provider-zksyncbuilder)\n- [Account](#account)\n- [Signer](#signer)\n- [Transactions](#transactions)\n- [Contract interfaces](#contract-interfaces)\n- [Examples](#examples)\n\n\n### Getting started\n\n#### Requirements\n| Tool  | Required  |\n|-------|-----------|\n| python| >= 3.8    |\n| package manager| pip |\n\n### how to install\n\n```console\npip install zksync2\n```\n\n\n### Provider (zkSyncBuilder)\n\n\n#### Design\nZkSync 2.0 is designed with the same styling as web3.<br>\nIt defines the zksync module based on Etherium and extends it with zkSync-specific methods.<br>\n\n\n#### How to construct\nFor usage, there is `ZkSyncBuilder` that returns a Web3 object with an instance of zksync module.<br>\nConstruction only needs the URL to the zkSync blockchain.\n\nExample:\n```python\nfrom zksync2.module.module_builder import ZkSyncBuilder\n...\nweb3 = ZkSyncBuilder.build(\"ZKSYNC_NET_URL\")\n```\n\n#### Module parameters and methods\n\nZkSync module attributes:\n\n|  Attribute | Description |\n|------------|-------------|\n|chain_id    | Returns an integer value for the currently configured \"ChainId\" |\n|gas_price   | Returns the current gas price in Wei |\n\n\nZkSync module methods:\n\n|  Method | Parameters | Return value |Description |\n|---------|------------|--------------|------------|\n|zks_estimate_fee | zkSync Transaction | Fee structure | Gets Fee for ZkSync transaction|\n|zks_main_contract | - | Address of main contract | Return address of main contract |\n|zks_get_confirmed_tokens | from, limit | List[Token]| Returns all tokens in the set range by global index|\n|zks_l1_chain_id | - | ChainID | Return etherium chain ID|\n|zks_get_all_account_balances| Address | Dict[str, int] | Return dictionary of token address and its value |\n|zks_get_bridge_contracts | - | BridgeAddresses | Returns addresses of all bridge contracts that are interacting with L1 layer|\n| eth_estimate_gas | Transaction | estimated gas | Overloaded method of eth_estimate_gas for ZkSync transaction gas estimation |\n| wait_for_transaction_receipt | Tx Hash, optional timeout,poll_latency | TxReceipt| Waits for the transaction to be included into block by its hash and returns its reciept. Optional arguments are `timeout` and `poll_latency` in seconds|\n\n\n### Account\n\nAccount incapsulate private key and, frequently based on it, the unique user identifier in the network.<br> This unique identifier also mean by wallet address.\n\n#### Account construction\n\nZkSync2 Python SDK account is compatible with `eth_account` package\nIn most cases user has its private key and gets account instance by using it.\n\nExample:\n```python\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\n...\naccount: LocalAccount = Account.from_key(\"PRIVATE_KEY\")\n\n```\n\nThe base property that is used directly of account is: `Account.address`\n\n\n### Signer\n\nSigner is used to generate signature of provided transaction based on your account(your private key)<br>\nThis signature is added to the final EIP712 transaction for its validation\n\n\n#### Singer construction\n\nzkSync2 already has implementation of signer. For contruct the instance it needs only account and chain_id\n\nExample:\n\n```python\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom eth_account import Account\nfrom zksync2.module.module_builder import ZkSyncBuilder\n\n\naccount = Account.from_key(\"PRIVATE_KEY\")\nzksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n...\nchain_id = zksync_web3.zksync.chain_id\nsigner = PrivateKeyEthSigner(account, chain_id)\n```\n\n\n#### Methods\n\n\nSigner has a few methods to generate signature and verify message\n\n|  Method | Parameters | Return value |Description |\n|---------|------------|--------------|------------|\n|sign_typed_data| EIP712 Structure, optional domain| Web3 py SignedMessage | Builds `SignedMessage` based on the encoded in EIP712 format Transaction |\n|verify_typed_data | signature, EIP712 structure, optional domain| bool | return True if this encoded transaction is signed with provided signature |\n\nSigner class also has the following properties:\n\n|  Attribute | Description |\n|------------|-------------|\n|address    | Account address|\n|domain   | domain that is used to generate signature. It's depends on chain_id of network |\n\n\n\n### Transactions\n\nBasic type of ZkSync transaction is quite similar to the Web3 based one<br>\nIt's defined in the package: zksync2.module.request_type<br>\n\nBut for sending and signed transaction it's neccessary to sign and encode it in EIP712 structure<br>\nEIP712 transaction type can be found in package: zksync2.transaction.transaction712\n\nFor convert ordinary transaction to EIP712 type there are defined helped classes:\n\n* TxFunctionCall\n* TxCreateContract\n* TxCreate2Contract\n\nUsage will be described in the examples [section][#Examples]\n\n\n### Contract interfaces\n\nThere is a set of system contract that helps execute and interact with ZkSync2 network<br>\nFor user needs there are the following contracts:\n\n* NonceHolder\n* ERC20Contract & ERC20FunctionEncoder\n* ContractDeployer\n* PaymasterFlowEncoder\n\n\n#### NonceHolder\n\nLet's start from the `NonceHolder`. This contract is handling the deployment nonce <br>\nIt's useful to precompute address for contract that is going to be deployer in the network.<br>\nTo construct it there is need only `account` and `Web3` object with integrated zksync module\n\n```python\nfrom zksync2.manage_contracts.nonce_holder import NonceHolder\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.module.module_builder import ZkSyncBuilder\n\nzksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\naccount: LocalAccount = Account.from_key(\"PRIVATE_KEY\")\nnonce_holder = NonceHolder(zksync_web3, account)\n```\n\n\nMethods:\n\n|  Method | Parameters | Return value |Description |\n|---------|------------|--------------|------------|\n|get_account_nonce | - | Nonce | returns account nonce |\n|get_deployment_nonce | - | Nonce | return current deployment nonce that is going to be used |\n|increment_deployment_nonce| Address | Nothing | Manually increments deployment nonce by provided account address | \n\n\n#### ERC20Contract\n\nThis is system contract that is used internally as a part of implementation methods of `EthereumProvider`<br>\nIt has functionality to interact at L1 level\n\n\nMore interested type is `ERC20FunctionEncoder`. it's using to provide method encoding in the case of<br> \nsending non-native tokens inside the network.\n\nConstruction needs only Web3 object with appended zksync module(ZkSyncBuilder)\n\nIt has only 1 single method: `python encode_method` with arguments of function name, and it's args\nUsage example you may find in [section](#examples) `Transfer funds (ERC20 tokens)`   \n\n\n#### ContractDeployer\n\nContractDeployer is utility contract represented as type to cover the following functionality:\n\n* encode binary contract representation by `create` method for further deploying\n* encode binary contract representation by `create2` method for further deploying\n* Precompute contract address for `create` and `create2` methods\n\nConstruction: needs only web3 object with appended zksync module\n\n\nExample:\n```python\nfrom zksync2.manage_contracts.contract_deployer import ContractDeployer\nfrom zksync2.module.module_builder import ZkSyncBuilder\n\nzksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\ndeployer = ContractDeployer(zksync_web3)\n```\n\nThe most functionality is hidden in the function builder helper types. See transaction [section](#transactions)  \n\nMethods:\n\n| Method                    | Parameters                                  | Return value | Description                                                                                                                                                                                                                                          |\n|---------------------------|---------------------------------------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| encode_create             | bytecode, optional `call_data` & `salt`     | HexStr  | create binary represenation of contract in internal deploying format.<br/> bytecode - contract binary representation, call_data is used for ctor bytecode only, salt is used to generate unique identifier of deploying contract                     |\n| encode_create2            | bytecode, optional `call_data` & `salt`     | HexStr  | create binary represenation of contract in internal deploying format.<br/> bytecode - contract binary representation, call_data is used for ctor bytecode only, salt is used to generate unique identifier of deploying contract                     |\n | compute_l2_create_address | Address, Nonce                              | Address | Accepts address of deployer and current deploing nonce and returns address of contract that is going to be deployed by `encode_create` method                                                                                                        |\n| compute_l2_create2_address | Address, bytecode, ctor bytecode, salt | Address | Accepts address of deployer, binary representation of contract, if needed it's constructor in binary format and salf. By default constructor can be b'0' value. Returns address of contract that is going to be deployed by  `encode_create2` method |\n\n#### PaymasterFlowEncoder\n\nPaymasterFlowEncoder is utility contract for encoding Paymaster parameters.<br>\nConstruction contract needs only Web3 Module object. It can be Eth or ZkSync.<br>\n\nExample:\n```python\nfrom zksync2.manage_contracts.paymaster_utils import PaymasterFlowEncoder\nfrom zksync2.module.module_builder import ZkSyncBuilder\n\nzksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\npaymaster_encoder = PaymasterFlowEncoder(zksync_web3)\n```\n\nThis utility contract has 2 methods wrapped directly to python:\n\n* encode_approval_based\n* encode_general\n\nFor example and usage, please have a look into example [section](#examples)\n\n\n### Examples\n\n#### Deposit funds\nThis is example how to deposit from Ethereum account to ZkSync account:\n\n```python\nfrom web3 import Web3\nfrom web3.middleware import geth_poa_middleware\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.manage_contracts.gas_provider import StaticGasProvider\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import Token\nfrom zksync2.provider.eth_provider import EthereumProvider\n\n\ndef deposit():\n    URL_TO_ETH_NETWORK = \"https://goerli.infura.io/v3/25be7ab42c414680a5f89297f8a11a4d\"\n    ZKSYNC_NETWORK_URL = \"https://zksync2-testnet.zksync.dev\"\n\n    eth_web3 = Web3(Web3.HTTPProvider(URL_TO_ETH_NETWORK))\n    eth_web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n    zksync_web3 = ZkSyncBuilder.build(ZKSYNC_NETWORK_URL)\n    account: LocalAccount = Account.from_key('YOUR_PRIVATE_KEY')\n    gas_provider = StaticGasProvider(Web3.toWei(1, \"gwei\"), 555000)\n    eth_provider = EthereumProvider.build_ethereum_provider(zksync=zksync_web3,\n                                                            eth=eth_web3,\n                                                            account=account,\n                                                            gas_provider=gas_provider)\n    tx_receipt = eth_provider.deposit(Token.create_eth(),\n                                      eth_web3.toWei(\"YOUR_AMOUNT_OF_ETH\", \"ether\"),\n                                      account.address)\n    print(f\"tx status: {tx_receipt['status']}\")\n\n\nif __name__ == \"__main__\":\n    deposit()\n\n```\n\n\n#### Check balance\n\nAfter depositing there could be needed to check the account balance under ZkSync network:\n\n```python\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import EthBlockParams\n\n\ndef get_account_balance():\n    ZKSYNC_NETWORK_URL: str = 'https://'\n    account: LocalAccount = Account.from_key('YOUR_PRIVATE_KEY')\n    zksync_web3 = ZkSyncBuilder.build(ZKSYNC_NETWORK_URL)\n    zk_balance = zksync_web3.zksync.get_balance(account.address, EthBlockParams.LATEST.value)\n    print(f\"ZkSync balance: {zk_balance}\")\n\n\nif __name__ == \"__main__\":\n    get_account_balance()\n\n```\n\n#### Transfer\n\nHere is example how to transfer funds in ZkSync network\n\n```python\nfrom eth_typing import HexStr\nfrom web3 import Web3\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import ZkBlockParams\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.transaction.transaction712 import TxFunctionCall\n\n\ndef transfer_to_self():\n    amount = 0.05\n    account: LocalAccount = Account.from_key(\"YOUR_PRIVATE_KEY\")\n    zksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n    chain_id = zksync_web3.zksync.chain_id\n    signer = PrivateKeyEthSigner(account, chain_id)\n\n    nonce = zksync_web3.zksync.get_transaction_count(account.address, ZkBlockParams.COMMITTED.value)\n    gas_price = zksync_web3.zksync.gas_price\n\n    tx_func_call = TxFunctionCall(chain_id=chain_id,\n                                  nonce=nonce,\n                                  from_=account.address,\n                                  to=account.address,\n                                  value=Web3.toWei(amount, 'ether'),\n                                  data=HexStr(\"0x\"),\n                                  gas_limit=0,  # unknown at this state, will be replaced by estimate_gas\n                                  gas_price=gas_price,\n                                  max_priority_fee_per_gas=100000000)\n    estimate_gas = zksync_web3.zksync.eth_estimate_gas(tx_func_call.tx)\n    print(f\"Fee for transaction is: {estimate_gas * gas_price}\")\n\n    tx_712 = tx_func_call.tx712(estimate_gas)\n\n    singed_message = signer.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zksync_web3.zksync.send_raw_transaction(msg)\n    tx_receipt = zksync_web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n    print(f\"tx_hash : {tx_hash.hex()}, status: {tx_receipt['status']}\")\n\n\nif __name__ == \"__main__\":\n    transfer_to_self()\n```\n\n#### Transfer funds (ERC20 tokens)\n\nExample of transferring ERC20 tokens\n\n```python\nfrom zksync2.manage_contracts.erc20_contract import ERC20FunctionEncoder\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import ZkBlockParams\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.transaction.transaction712 import TxFunctionCall\n\n\ndef transfer_erc20_token():\n    account: LocalAccount = Account.from_key(\"YOUR_PRIVATE_KEY\")\n    zksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n    chain_id = zksync_web3.zksync.chain_id\n    signer = PrivateKeyEthSigner(account, chain_id)\n\n    nonce = zksync_web3.zksync.get_transaction_count(account.address, ZkBlockParams.COMMITTED.value)\n    gas_price = zksync_web3.zksync.gas_price\n\n    tokens = zksync_web3.zksync.zks_get_confirmed_tokens(0, 100)\n    not_eth_tokens = [x for x in tokens if not x.is_eth()]\n    token_address = not_eth_tokens[0].l2_address\n\n    erc20_encoder = ERC20FunctionEncoder(zksync_web3)\n    transfer_params = [account.address, 0]\n    call_data = erc20_encoder.encode_method(\"transfer\", args=transfer_params)\n\n    func_call = TxFunctionCall(chain_id=chain_id,\n                               nonce=nonce,\n                               from_=account.address,\n                               to=token_address,\n                               data=call_data,\n                               gas_limit=0,  # unknown at this state, will be replaced by estimate_gas\n                               gas_price=gas_price,\n                               max_priority_fee_per_gas=100000000)\n    estimate_gas = zksync_web3.zksync.eth_estimate_gas(func_call.tx)\n    print(f\"Fee for transaction is: {estimate_gas * gas_price}\")\n\n    tx_712 = func_call.tx712(estimate_gas)\n    singed_message = signer.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zksync_web3.zksync.send_raw_transaction(msg)\n    tx_receipt = zksync_web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n    print(f\"tx_hash : {tx_hash.hex()}, status: {tx_receipt['status']}\")\n\n\nif __name__ == \"__main__\":\n    transfer_erc20_token()\n```\n\n#### Withdraw funds (Native coins)\n\n```python\nfrom decimal import Decimal\nfrom eth_typing import HexStr\nfrom zksync2.manage_contracts.l2_bridge import L2BridgeEncoder\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import Token, ZkBlockParams, BridgeAddresses\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.transaction.transaction712 import TxFunctionCall\n\n\ndef withdraw():\n    value = Decimal(\"0.001\")\n\n    account: LocalAccount = Account.from_key(\"PRIVATE_KEY\")\n    zksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n    chain_id = zksync_web3.zksync.chain_id\n    signer = PrivateKeyEthSigner(account, chain_id)\n    ETH_TOKEN = Token.create_eth()\n\n    nonce = zksync_web3.zksync.get_transaction_count(account.address, ZkBlockParams.COMMITTED.value)\n    gas_price = zksync_web3.zksync.gas_price\n    bridges: BridgeAddresses = zksync_web3.zksync.zks_get_bridge_contracts()\n\n    l2_func_encoder = L2BridgeEncoder(zksync_web3)\n    call_data = l2_func_encoder.encode_function(fn_name=\"withdraw\", args=[\n        account.address,\n        ETH_TOKEN.l2_address,\n        ETH_TOKEN.to_int(value)\n    ])\n\n    func_call = TxFunctionCall(chain_id=chain_id,\n                               nonce=nonce,\n                               from_=account.address,\n                               to=bridges.l2_eth_default_bridge,\n                               data=HexStr(call_data),\n                               gas_limit=0, # unknown at this state, will be replaced by estimate_gas\n                               gas_price=gas_price,\n                               max_priority_fee_per_gas=100000000)\n    estimate_gas = zksync_web3.zksync.eth_estimate_gas(func_call.tx)\n    print(f\"Fee for transaction is: {estimate_gas * gas_price}\")\n\n    tx_712 = func_call.tx712(estimate_gas)\n    singed_message = signer.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zksync_web3.zksync.send_raw_transaction(msg)\n    tx_receipt = zksync_web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n    print(f\"tx_hash : {tx_hash.hex()}, status: {tx_receipt['status']}\")\n\n\nif __name__ == \"__main__\":\n    withdraw()\n```\n\n\n#### Deploy contract with method create\n\nZkSync tools allows to build the contract into binary format. Then it can be deployed to the network<br>\nHere is the code of simple contract:\n\n```\npragma solidity ^0.8.0;\n\ncontract Counter {\n    uint256 value;\n\n    function increment(uint256 x) public {\n        value += x;\n    }\n\n    function get() public view returns (uint256) {\n        return value;\n    }\n}\n```\n\n\n> INFO: It must be compiled by ZkSync2 compiler only !\n\nAfter compilation there must be 2 files with:\n\n- contract binary representation\n- contract abi in json format\n\n\nContract ABI needs for calling its methods in standard web3 way<br>\n\n> INFO: in some cases you would need to get contract address before deploying it<br>\n> INFO: This case is also introduced in this example\n\n```python\nimport json\nimport os\nfrom pathlib import Path\nfrom eth_typing import HexStr\nfrom web3 import Web3\nfrom web3.types import TxParams\nfrom zksync2.manage_contracts.contract_deployer import ContractDeployer\nfrom zksync2.manage_contracts.nonce_holder import NonceHolder\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import ZkBlockParams, EthBlockParams\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.transaction.transaction712 import TxCreateContract\n\n\ndef generate_random_salt() -> bytes:\n    return os.urandom(32)\n\n\ndef read_hex_binary(name: str) -> bytes:\n    p = Path(f\"./{name}\")\n    with p.open(mode='r') as contact_file:\n        lines = contact_file.readlines()\n        data = \"\".join(lines)\n        return bytes.fromhex(data)\n\n\ndef read_binary(p: Path) -> bytes:\n    with p.open(mode='rb') as contact_file:\n        data = contact_file.read()\n        return data\n\n\ndef get_abi(p: Path):\n    with p.open(mode='r') as json_f:\n        return json.load(json_f)\n\n\nclass CounterContractEncoder:\n    def __init__(self, web3: Web3, bin_path: Path, abi_path: Path):\n        self.web3 = web3\n        self.counter_contract = self.web3.eth.contract(abi=get_abi(abi_path),\n                                                       bytecode=read_hex_binary(str(bin_path)))\n\n    def encode_method(self, fn_name, args: list) -> HexStr:\n        return self.counter_contract.encodeABI(fn_name, args)\n\n\ndef deploy_contract_create():\n    account: LocalAccount = Account.from_key(\"PRIVATE_KEY\")\n    zksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n    chain_id = zksync_web3.zksync.chain_id\n    signer = PrivateKeyEthSigner(account, chain_id)\n\n    counter_contract_bin = read_hex_binary(\"counter_contract.hex\")\n\n    nonce = zksync_web3.zksync.get_transaction_count(account.address, EthBlockParams.PENDING.value)\n    gas_price = zksync_web3.zksync.gas_price\n\n    nonce_holder = NonceHolder(zksync_web3, account)\n    deployment_nonce = nonce_holder.get_deployment_nonce(account.address)\n    deployer = ContractDeployer(zksync_web3)\n    precomputed_address = deployer.compute_l2_create_address(account.address, deployment_nonce)\n\n    print(f\"precomputed address: {precomputed_address}\")\n\n    random_salt = generate_random_salt()\n    create_contract = TxCreateContract(web3=zksync_web3,\n                                       chain_id=chain_id,\n                                       nonce=nonce,\n                                       from_=account.address,\n                                       gas_limit=0,  # unknown at this state, will be replaced by estimate_gas\n                                       gas_price=gas_price,\n                                       bytecode=counter_contract_bin,\n                                       salt=random_salt)\n    estimate_gas = zksync_web3.zksync.eth_estimate_gas(create_contract.tx)\n    print(f\"Fee for transaction is: {estimate_gas * gas_price}\")\n\n    tx_712 = create_contract.tx712(estimate_gas)\n\n    singed_message = signer.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zksync_web3.zksync.send_raw_transaction(msg)\n    print(f\"tx_hash:{tx_hash.hex()}\")\n    tx_receipt = zksync_web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n    print(f\"tx status: {tx_receipt['status']}\")\n\n    contract_address = tx_receipt[\"contractAddress\"]\n    print(f\"contract address: {contract_address}\")\n    counter_contract_encoder = CounterContractEncoder(zksync_web3, Path(\"./counter_contract.hex\"),\n                                                      Path(\"counter_contract_abi.json\"))\n\n    call_data = counter_contract_encoder.encode_method(fn_name=\"get\", args=[])\n    eth_tx: TxParams = {\n        \"from\": account.address,\n        \"to\": contract_address,\n        \"data\": call_data\n    }\n    # Value is type dependent so might need to be converted to corresponded type under Python\n    eth_ret = zksync_web3.zksync.call(eth_tx, ZkBlockParams.COMMITTED.value)\n    converted_result = int.from_bytes(eth_ret, \"big\", signed=True)\n    print(f\"Call method for deployed contract, address: {contract_address}, value: {converted_result}\")\n\n\nif __name__ == \"__main__\":\n    deploy_contract_create()\n```\n\n#### Deploy contract with method create2\n\n\n```python\nimport os\nimport json\nfrom pathlib import Path\nfrom eth_typing import HexStr\nfrom web3 import Web3\nfrom web3.types import TxParams\nfrom zksync2.manage_contracts.contract_deployer import ContractDeployer\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.core.types import ZkBlockParams, EthBlockParams\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.transaction.transaction712 import TxCreate2Contract\n\n\ndef generate_random_salt() -> bytes:\n    return os.urandom(32)\n\n\ndef read_hex_binary(name: str) -> bytes:\n    p = Path(f\"./{name}\")\n    with p.open(mode='r') as contact_file:\n        lines = contact_file.readlines()\n        data = \"\".join(lines)\n        return bytes.fromhex(data)\n\n\ndef read_binary(p: Path) -> bytes:\n    with p.open(mode='rb') as contact_file:\n        data = contact_file.read()\n        return data\n\n\ndef get_abi(p: Path):\n    with p.open(mode='r') as json_f:\n        return json.load(json_f)\n\n\nclass CounterContractEncoder:\n    def __init__(self, web3: Web3, bin_path: Path, abi_path: Path):\n        self.web3 = web3\n        self.counter_contract = self.web3.eth.contract(abi=get_abi(abi_path),\n                                                       bytecode=read_hex_binary(str(bin_path)))\n\n    def encode_method(self, fn_name, args: list) -> HexStr:\n        return self.counter_contract.encodeABI(fn_name, args)\n\n\ndef deploy_contract_create2():\n    account: LocalAccount = Account.from_key(\"PRIVATE_KEY\")\n    zksync_web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n    chain_id = zksync_web3.zksync.chain_id\n    signer = PrivateKeyEthSigner(account, chain_id)\n\n    counter_contract_bin = read_hex_binary(\"counter_contract.hex\")\n\n    nonce = zksync_web3.zksync.get_transaction_count(account.address, EthBlockParams.PENDING.value)\n    gas_price = zksync_web3.zksync.gas_price\n\n    deployer = ContractDeployer(zksync_web3)\n    random_salt = generate_random_salt()\n    precomputed_address = deployer.compute_l2_create2_address(sender=account.address,\n                                                              bytecode=counter_contract_bin,\n                                                              constructor=b'',\n                                                              salt=random_salt)\n    print(f\"precomputed address: {precomputed_address}\")\n\n    create2_contract = TxCreate2Contract(web3=zksync_web3,\n                                         chain_id=chain_id,\n                                         nonce=nonce,\n                                         from_=account.address,\n                                         gas_limit=0,\n                                         gas_price=gas_price,\n                                         bytecode=counter_contract_bin,\n                                         salt=random_salt)\n    estimate_gas = zksync_web3.zksync.eth_estimate_gas(create2_contract.tx)\n    print(f\"Fee for transaction is: {estimate_gas * gas_price}\")\n\n    tx_712 = create2_contract.tx712(estimate_gas)\n    singed_message = signer.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zksync_web3.zksync.send_raw_transaction(msg)\n    print(f\"tx_hash: {tx_hash.hex()}\")\n    tx_receipt = zksync_web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n    print(f\"tx status: {tx_receipt['status']}\")\n\n    contract_address = tx_receipt[\"contractAddress\"]\n    print(f\"contract address: {contract_address}\")\n\n    counter_contract_encoder = CounterContractEncoder(zksync_web3, Path(\"counter_contract.hex\"),\n                                                      Path(\"counter_contract_abi.json\"))\n    call_data = counter_contract_encoder.encode_method(fn_name=\"get\", args=[])\n    eth_tx: TxParams = {\n        \"from\": account.address,\n        \"to\": contract_address,\n        \"data\": call_data\n    }\n    eth_ret = zksync_web3.zksync.call(eth_tx, ZkBlockParams.COMMITTED.value)\n    result = int.from_bytes(eth_ret, \"big\", signed=True)\n    print(f\"Call method for deployed contract, address: {contract_address}, value: {result}\")\n\n\nif __name__ == \"__main__\":\n    deploy_contract_create2()\n\n```\n\n#### Custom Paymaster\nThis example is based on the `custom_paymaster_binary` that accepts any coin with <br>\nthe 1:1 relation to native token( 18 decimals )\n\n\n```python\n\nfrom pathlib import Path\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom eth_typing import HexStr\nfrom eth_utils import remove_0x_prefix\nfrom web3 import Web3\nfrom zksync2.manage_contracts.gas_provider import StaticGasProvider\nfrom zksync2.manage_contracts.paymaster_utils import PaymasterFlowEncoder\nfrom zksync2.signer.eth_signer import PrivateKeyEthSigner\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.manage_contracts.erc20_contract import ERC20Contract\nfrom zksync2.transaction.transaction712 import TxFunctionCall\n\nfrom zksync2.core.types import EthBlockParams, PaymasterParams, Token\n\n\ndef read_hex_binary(name: str) -> bytes:\n    p = Path(f\"./{name}\")\n    with p.open(mode='r') as contact_file:\n        lines = contact_file.readlines()\n        data = \"\".join(lines)\n        return bytes.fromhex(data)\n\n\n# Contract to mint custom token under testnet:\n# https://goerli.explorer.zksync.io/address/0xFC174650BDEbE4D94736442307D4D7fdBe799EeC#contract\n\nclass PaymasterExample:\n    SERC20_TOKEN = Token(\n        Web3.toChecksumAddress(\"0x\" + \"0\" * 40),\n        Web3.toChecksumAddress(\"0xFC174650BDEbE4D94736442307D4D7fdBe799EeC\"),\n        \"SERC20\",\n        18)\n\n    def __init__(self):\n        self.web3 = ZkSyncBuilder.build(\"ZKSYNC_NETWORK_URL\")\n        self.account: LocalAccount = Account.from_key(\"YOUR_PRIVATE_KEY\")\n        self.chain_id = self.web3.zksync.chain_id\n        self.signer = PrivateKeyEthSigner(self.account, self.chain_id)\n        self.gas_provider = StaticGasProvider(Web3.toWei(1, \"gwei\"), 555000)\n\n        self.custom_paymaster_contract_bin = read_hex_binary(\"custom_paymaster_binary.hex\")\n\n    @property\n    def paymaster_address(self) -> HexStr:\n        return self.web3.zksync.zks_get_testnet_paymaster_address()\n\n    def build_paymaster(self, trans: TxFunctionCall, fee: int) -> TxFunctionCall:\n        paymaster_encoder = PaymasterFlowEncoder(self.web3.zksync)\n        encoded_approval_base = paymaster_encoder.encode_approval_based(self.SERC20_TOKEN.l2_address,\n                                                                        fee,\n                                                                        b'')\n        encoded_approval_bin = bytes.fromhex(remove_0x_prefix(encoded_approval_base))\n        trans.tx[\"eip712Meta\"].paymaster_params = PaymasterParams(paymaster=self.paymaster_address,\n                                                                  paymaster_input=encoded_approval_bin)\n        return trans\n\n    def run(self):\n        gas_price = self.web3.zksync.gas_price\n        paymaster_address = self.paymaster_address\n        nonce = self.web3.zksync.get_transaction_count(self.account.address, EthBlockParams.PENDING.value)\n        transaction = TxFunctionCall(self.chain_id,\n                                     nonce=nonce,\n                                     from_=self.account.address,\n                                     to=self.account.address,\n                                     gas_price=gas_price)\n\n        # INFO: encode paymaster params with dummy fee to estimate real one\n        unknown_fee = 0\n        transaction = self.build_paymaster(transaction, unknown_fee)\n\n        paymaster_est_gas = self.web3.zksync.eth_estimate_gas(transaction.tx)\n        preprocessed_fee = gas_price * paymaster_est_gas\n\n        print(f\"Paymaster fee: {preprocessed_fee}\")\n\n        erc20 = ERC20Contract(self.web3.zksync, contract_address=self.SERC20_TOKEN.l2_address,\n                              account=self.account,\n                              gas_provider=self.gas_provider)\n\n        allowance = erc20.allowance(self.account.address, paymaster_address)\n        if allowance < preprocessed_fee:\n            is_approved = erc20.approve_deposit(paymaster_address, preprocessed_fee)\n            print(f\"pass deposite: {is_approved}\")\n\n        # INFO: encode paymaster params with real fee\n        transaction = self.build_paymaster(transaction, preprocessed_fee)\n\n        balance_before = self.web3.zksync.get_balance(self.account.address, EthBlockParams.PENDING.value)\n        print(f\"balance before : {balance_before}\")\n\n        tx712 = transaction.tx712(paymaster_est_gas)\n        singed_message = self.signer.sign_typed_data(tx712.to_eip712_struct())\n        msg = tx712.encode(singed_message)\n        tx_hash = self.web3.zksync.send_raw_transaction(msg)\n        tx_receipt = self.web3.zksync.wait_for_transaction_receipt(tx_hash, timeout=240, poll_latency=0.5)\n        print(f\"status: {tx_receipt['status']}\")\n\n        balance_after = self.web3.zksync.get_balance(self.account.address, EthBlockParams.PENDING.value)\n        print(f\"balance after: {balance_after}\")\n\n\nif __name__ == \"__main__\":\n    paymaster = PaymasterExample()\n    paymaster.run()\n\n```\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://zksync.io",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "zksync2",
    "package_url": "https://pypi.org/project/zksync2/",
    "platform": null,
    "project_url": "https://pypi.org/project/zksync2/",
    "project_urls": {
      "Bug Tracker": "https://github.com/zksync-sdk/zksync2-python/issues",
      "Homepage": "https://github.com/zksync-sdk/zksync2-python"
    },
    "release_url": "https://pypi.org/project/zksync2/0.2.0/",
    "requires_dist": [
      "eip712-structs (==1.1.0)",
      "eth-account (==0.5.7)",
      "eth-typing (==2.3.0)",
      "eth-utils (==1.10.0)",
      "hexbytes (==0.2.2)",
      "rlp (==2.0.1)",
      "web3 (==5.30.0)",
      "mypy (>=0.8) ; extra == 'test'"
    ],
    "requires_python": ">=3.8",
    "summary": "zkSync2 python client sdk",
    "version": "0.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16395406,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ff3fe059bc470770a38df92cd2e947629ac9533e41e7a2d380ca17d2cee8d05a",
          "md5": "d8692be35db717d9fe6abed7de814561",
          "sha256": "f4285ff7feec0bb867ae56d2b83b6ea7e08e83dc29d7fb64d1855753d8a0fb67"
        },
        "downloads": -1,
        "filename": "zksync2-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d8692be35db717d9fe6abed7de814561",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 35101,
        "upload_time": "2022-10-18T14:52:12",
        "upload_time_iso_8601": "2022-10-18T14:52:12.421685Z",
        "url": "https://files.pythonhosted.org/packages/ff/3f/e059bc470770a38df92cd2e947629ac9533e41e7a2d380ca17d2cee8d05a/zksync2-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bb8415c23b321a8468ef0512a7e7d81c22a8ddad9c5087a83a3c76a8a9094d94",
          "md5": "4687a20ea3b19ba7bc2aed631a342562",
          "sha256": "5182cdab830841f6f5c2821d315df2379c1ac06fcd30e21ce0daf20c968ef8a0"
        },
        "downloads": -1,
        "filename": "zksync2-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "4687a20ea3b19ba7bc2aed631a342562",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 56504,
        "upload_time": "2022-10-18T14:52:14",
        "upload_time_iso_8601": "2022-10-18T14:52:14.581160Z",
        "url": "https://files.pythonhosted.org/packages/bb/84/15c23b321a8468ef0512a7e7d81c22a8ddad9c5087a83a3c76a8a9094d94/zksync2-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3c18213dfc60f2c0c90935c10d3ac1d180d14629b5dc6f03b5b89288c95e239b",
          "md5": "717ca8df83186b3066fa59bef246bec2",
          "sha256": "7a1547661456cad55f46e2094706f77dd3c4e543a60d22f38622d963df37b581"
        },
        "downloads": -1,
        "filename": "zksync2-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "717ca8df83186b3066fa59bef246bec2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 35067,
        "upload_time": "2022-11-28T13:00:27",
        "upload_time_iso_8601": "2022-11-28T13:00:27.284721Z",
        "url": "https://files.pythonhosted.org/packages/3c/18/213dfc60f2c0c90935c10d3ac1d180d14629b5dc6f03b5b89288c95e239b/zksync2-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2b662c0e19350f46278a8aafd1f8d993eb7b3f6f5bc9edf270848400b9e0ac2d",
          "md5": "5cca000b2dc1a7140bca4bf887113536",
          "sha256": "4f4d7298a72fcca68efc678bcebd53a5de4f88f3cd12f0980b9d42f70377082e"
        },
        "downloads": -1,
        "filename": "zksync2-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "5cca000b2dc1a7140bca4bf887113536",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 57785,
        "upload_time": "2022-11-28T13:00:28",
        "upload_time_iso_8601": "2022-11-28T13:00:28.648100Z",
        "url": "https://files.pythonhosted.org/packages/2b/66/2c0e19350f46278a8aafd1f8d993eb7b3f6f5bc9edf270848400b9e0ac2d/zksync2-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c9b7ae3f9262426b35c0acb7184972dac2cfa418a63bf2b31e791501671f003e",
          "md5": "c2948bae3eac7c3f57ab2209a02f99e0",
          "sha256": "55d6eb4cc9c6868a27eca95b7db140a45b93b22cd77fd8b75db886f39602c6d3"
        },
        "downloads": -1,
        "filename": "zksync2-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c2948bae3eac7c3f57ab2209a02f99e0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 37780,
        "upload_time": "2022-12-15T15:14:09",
        "upload_time_iso_8601": "2022-12-15T15:14:09.910979Z",
        "url": "https://files.pythonhosted.org/packages/c9/b7/ae3f9262426b35c0acb7184972dac2cfa418a63bf2b31e791501671f003e/zksync2-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "21b9f21cc1e2a356c727b427612a3da80af481dd9b6b0651f0c7fc16d28ad95c",
          "md5": "b51e841eb072e166a513a7a5f8c4c4cd",
          "sha256": "367b455f2627ecea1ac8ac770229a0b76a553fcae8b421f4d6f561517a9a4ae3"
        },
        "downloads": -1,
        "filename": "zksync2-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b51e841eb072e166a513a7a5f8c4c4cd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 63041,
        "upload_time": "2022-12-15T15:14:11",
        "upload_time_iso_8601": "2022-12-15T15:14:11.458317Z",
        "url": "https://files.pythonhosted.org/packages/21/b9/f21cc1e2a356c727b427612a3da80af481dd9b6b0651f0c7fc16d28ad95c/zksync2-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e953c8d54ba25f92a89c4e07702717c05f9877c750311911ed31b6bb1c2b216c",
          "md5": "6a4a5ec6322e2478d8bf4e4d4770b1c0",
          "sha256": "49ddbc770b65ce931c1e2bcaa32c2f8b2d5d3de36d3ecd827e438a7b640a6ae3"
        },
        "downloads": -1,
        "filename": "zksync2-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6a4a5ec6322e2478d8bf4e4d4770b1c0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 40345,
        "upload_time": "2023-01-11T22:23:10",
        "upload_time_iso_8601": "2023-01-11T22:23:10.021381Z",
        "url": "https://files.pythonhosted.org/packages/e9/53/c8d54ba25f92a89c4e07702717c05f9877c750311911ed31b6bb1c2b216c/zksync2-0.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1853f35615131a27c7617588c2707d10d36feabdf21553a530b7e487cc9694cc",
          "md5": "131581ef9700b1339528c4cd43f0ffcc",
          "sha256": "b61cf2e1155ab2ed64e7dffcfa32269a67957fcce327482517ed4c6cec96a53f"
        },
        "downloads": -1,
        "filename": "zksync2-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "131581ef9700b1339528c4cd43f0ffcc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 72343,
        "upload_time": "2023-01-11T22:23:11",
        "upload_time_iso_8601": "2023-01-11T22:23:11.696199Z",
        "url": "https://files.pythonhosted.org/packages/18/53/f35615131a27c7617588c2707d10d36feabdf21553a530b7e487cc9694cc/zksync2-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e953c8d54ba25f92a89c4e07702717c05f9877c750311911ed31b6bb1c2b216c",
        "md5": "6a4a5ec6322e2478d8bf4e4d4770b1c0",
        "sha256": "49ddbc770b65ce931c1e2bcaa32c2f8b2d5d3de36d3ecd827e438a7b640a6ae3"
      },
      "downloads": -1,
      "filename": "zksync2-0.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6a4a5ec6322e2478d8bf4e4d4770b1c0",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 40345,
      "upload_time": "2023-01-11T22:23:10",
      "upload_time_iso_8601": "2023-01-11T22:23:10.021381Z",
      "url": "https://files.pythonhosted.org/packages/e9/53/c8d54ba25f92a89c4e07702717c05f9877c750311911ed31b6bb1c2b216c/zksync2-0.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1853f35615131a27c7617588c2707d10d36feabdf21553a530b7e487cc9694cc",
        "md5": "131581ef9700b1339528c4cd43f0ffcc",
        "sha256": "b61cf2e1155ab2ed64e7dffcfa32269a67957fcce327482517ed4c6cec96a53f"
      },
      "downloads": -1,
      "filename": "zksync2-0.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "131581ef9700b1339528c4cd43f0ffcc",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 72343,
      "upload_time": "2023-01-11T22:23:11",
      "upload_time_iso_8601": "2023-01-11T22:23:11.696199Z",
      "url": "https://files.pythonhosted.org/packages/18/53/f35615131a27c7617588c2707d10d36feabdf21553a530b7e487cc9694cc/zksync2-0.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}