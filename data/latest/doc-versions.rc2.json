{
  "info": {
    "author": "CHTD",
    "author_email": "info@chtd.ru",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "=======================================\nВерсионирование данных в реляционной БД\n=======================================\n\n----------------------------------------------------\nОбработка и хранение данных с временными параметрами\n----------------------------------------------------\n\n:Авторы: В. А. Фёдоров, К. А. Лопухин\n:Аннотация: \n Предлагается модель представления и методы обработки временных данных\n в реляционных СУБД с примерами для Django. \n\n.. contents::\n.. .. section-numbering::\n\nСуществует множество видов данных, содержащих в качестве одного из\nкомпонентов момент времени:\n\n- результат замера какой-нибудь величины (уровень воды по часам)\n- план работы\n- состояние документа (версии)\n- состояние процесса (workflow)\n\n\nПростейший способ\n=================\n\n\n::\n\n drop table if exists data ;\n create table data (\n       vtime timestamp DEFAULT CURRENT_TIMESTAMP ,\n       vid integer ,\t-- идентификатор\n       v text \t        -- значение\n       ) ;\n\n\nПредполагается что в таблице хранится множество измерений (**v**) от\nразных источников (**vid**) в разные моменты времени (**vtime**). Для\nпримера поместим в таблицу несколько значений::\n\n insert into data (vtime,vid,v) values ('2000-01',1,'2000 - 1') ;\n insert into data (vtime,vid,v) values ('2001-01',1,'2001 - 1') ;\n insert into data (vtime,vid,v) values ('2002-01',1,'2002 - 1') ;\n insert into data (vtime,vid,v) values ('2000-01',2,'2000 - 2') ;\n insert into data (vtime,vid,v) values ('2001-01',2,'2001 - 2') ;\n insert into data (vtime,vid,v) values ('2001-01',3,'2001 - 3') ;\n insert into data (vtime,vid,v) values ('2002-01',3,'2002 - 3') ;\n\nЕсли точно знать момент времени, то легко найти значения::\n\n select v from data where vtime='2001-01' ;\n\n 2001 - 1\n 2001 - 2\n 2001 - 3\n\nПроблема возникает если момент времени задан не точно. Тогда имеет\nсмысл запрос на ближайшее известное значение (например снизу). При\nэтом, если нужно показание конкретного источника, то задачу можно\nрешить с помощью сортировки и выбора первого значения::\n \n select v from data where vid=2 and vtime<='2001-05' \n   order by vtime DESC limit 1 ;\n\n 2001 - 2\n\nВ случае, когда нужны все источники, задача решается еще более сложным\nспособом с использованием агрегирующих функций::\n\n select vid,v from data \n where vtime=(select max(d.vtime) from data as d where\n d.vtime<='2001-05' and d.vid=data.vid) ;\n\n 1\t2001 - 1\n 2\t2001 - 2\n 3\t2001 - 3\n\nИли более эффективно (при большом наборе данных и индексировании)::\n \n select data.vid,v from data ,\n ( select max(vtime) as t,vid \n   from data where vtime<='2001-05' group by vid) as d\n where vtime=t and data.vid=d.vid ; \n\n 1\t2001 - 1\n 2\t2001 - 2\n 3\t2001 - 3\n\nИнтервалы\n=========\n\n.. note::\n В последних постгресах есть with, который позволяет упростить решения!\n\nПредложенные выше конструкции довольно громоздки и неэффективны\n(**select** встречается дважды), особенно если выбор значений\nдолжен рассматриваться как подзадача более сложной обработки\nполученных данных.\n\nУпростить решение можно с помощью добавления избыточных данных,\nт.е. вместо даты регистрации хранить **интервал** действия данного\nзначения::\n  \n drop table if exists ndata ;\n create table ndata (\n       vstart timestamp DEFAULT CURRENT_TIMESTAMP , -- начало действия (вкл.)\n       vend timestamp DEFAULT '9999-01' ,      -- конец действия (искл.)\n       vid integer ,\t-- идентификатор\n       v text \t        -- значение\n       ) ;\n\nПредыдущую таблицу можно преобразовать к новому виду::\n\n insert into ndata (vstart,vid,v) select vtime,vid,v from data ;\n\n update ndata set vend = ( -- минимум из всех начал после данного\n  select min(d.vstart) from ndata as d \n  where d.vstart>ndata.vstart and d.vid=ndata.vid )\n where exists ( -- существуют данные после текущего \n  select * from ndata as d \n  where d.vstart>ndata.vstart and d.vid=ndata.vid ) ;\n  \nРезультат::\n\n vstart\t\tvend\tvid\tv\n 2000-01\t2001-01\t1\t2000 - 1\n 2001-01\t2002-01\t1\t2001 - 1\n 2002-01\t9999-01\t1\t2002 - 1\n 2000-01\t2001-01\t2\t2000 - 2\n 2001-01\t9999-01\t2\t2001 - 2\n 2001-01\t2002-01\t3\t2001 - 3\n 2002-01\t9999-01\t3\t2002 - 3\n\nИнтервалы не пересекаются (считаем нижнюю границу включительно, а\nверхнюю исключительно). Задачи из предыдущего пункта решаются легко и\nодинаково:: \n\n select v from ndata where vid=2 and vstart<='2001-05' and vend>'2001-05' ;\n\nдля поиска из конкретного источника (независимо от совпадения с\nграницей) и::\n\n select vid,v from ndata where vstart<='2001-05' and vend>'2001-05' ;\n\nдля поиска всех источников.\n\nУсложняются процедуры вставки::\n\n insert into ndata (vstart,vend,vid,v) values ('2000-05',\n     -- значение для правого конца интервала:\n     case when exists ( -- попали в имеющийся\n            select * from ndata \n            where vid=2 and ndata.vstart<'2000-05' and ndata.vend>'2000-05' )\n          then ( select vend from ndata \n                 where vid=2 and ndata.vstart<'2000-05' and\n\t                         ndata.vend>'2000-05' )\n\t  when exists ( -- в начало\n            select * from ndata where vid=2 )\n\t  then ( select min(vstart) from ndata where vid=2 )\n          else '9999-01' end,\n  2,'2000-05 2') ;\n -- исправляем конец интервала, в который попали:\n update ndata set vend='2000-05' \n where vid=2 and vstart<'2000-05' and vend>'2000-05' ;\n\nи удаления::\n\n -- изменяем правый конец предыдущего интервала\n update ndata set vend=(select vend from ndata \n                       where vid=2 and vstart='2000-05')\n where vid=2 and vend='2000-05' ;\n delete from ndata where vid=2 and vstart='2000-05' ;\n\nВставка может быть более простой если известен контекст::\n\n -- первое значение для vid=4:\n insert into ndata (vstart,vid,v) values ('2000-05',4,'2000-05 4') ;\n\n  -- вставка в начало:\n insert into ndata\n select '1999-01',min(vstart),2,'1999-01 2' from ndata where vid=2 ;\n\n -- вставка в конец или внутрь\n insert into ndata \n select '2004-05',vend,2,'2004-05 2' from ndata \n where vid=2 and vstart<'2004-05' and vend>'2004-05' ;\n update ndata set vend='2004-05' \n where vid=2 and vstart<'2004-05' and vend=>'2004-05' ; \n\nМассовую вставку значений можно сделать эффективно если отложить\nвычисление правых границ на потом, как при импорте из **data**.\n\n\nСвязи между таблицами\n=====================\n\nИдентификатор и момент времени однозначно определяют значение (если\nоно есть). То есть пару (момент времени,идентификатор) можно\nиспользовать в качестве внешнего ключа таблицы **ndata**. Пусть есть\nпроизвольный список моментов времени и идентификаторов::\n\n drop table if exists idvtime ;\n create table idvtime ( id integer , t timestamp ) ;\n insert into idvtime values (3,'2000-01') ;\n insert into idvtime values (2,'2000-05') ;\n insert into idvtime values (1,'2001-01') ;\n insert into idvtime values (3,'2001-05') ;\n insert into idvtime values (2,'2002-01') ;\n\nТогда список значений из **ndata** можно присоединить запросом::\n\n select id,t,v \n from idvtime left join ndata on (id=vid and vstart<=t and vend>t) ;\n\n id\tt\tv\n 3\t2000-01\tNULL\n 2\t2000-05\t2000 - 2\n 1\t2001-01\t2001 - 1\n 3\t2001-05\t2001 - 3\n 2\t2002-01\t2001 - 2\n\n\nДокументы и версии\n==================\n\nСуществует множество систем управления версиями: cvs, svn, git, darcs\nи т.д. Их основная функция - хранение версий документов, запоминание\nсостояний документов в какие-то моменты времени с возможностью\nпросмотра прошлых состояний или даже возврата в какое-то предыдущее\nсостояние. Все системы работают с документами произвольного вида (в\nосновном текстовыми) и предназначены в большинстве своем для\nсопровождения процесса разработки программ. Применим аналогичный\nподход к данным, хранящимся в базе данных. Цели:\n\n- возможность вернуться к предыдущему состоянию документа;\n- возможность проследить динамику изменения документа;\n- возможность исследовать состояние всей системы (получить отчеты) в\n  произвольный момент в прошлом (ретроспекция).\n\nДокумент\n  связанный набор данных, возможно из нескольких таблиц,\n  воспринимаемых пользователем как единое целое. Документ имеет тип,\n  и уникальный (для данного типа) идентификатор экземпляра. \n\nДокумент может изменяться во времени (редактироваться пользователем\nили системой). Состояния, которые проходит документ со временем\nназываются **версиями** документа.\n\nВерсии документов не изменяются. У каждой версии есть временной\nинтервал ее действия. Последняя версия имеет правой границей плюс\nбесконечность - `datetime.max`. Документ считается удаленным из\nсистемы если в правую границу последней версии записать время\nудаления.\n\nВ базе храним версии документа. Одна из таблиц хранящих версию\nдокумента (возможно единственная) содержит интервал действия и\nидентификатор - **главная таблица документа**. Для каждой версии\nкаждого документа в главной таблице одна строка.\n\n\nСвязи между таблицами документа\n===============================\n\nГлавная таблица может быть связана с другими таблицами документа\nотношениями:\n\nОдин к одному\n  главная таблица содержит внешний ключ другой - ссылка на\n  дополнительные данные, которые почему-то не хотим иметь в главной\n  (например редко используются, а занимают много места).\n\n  Ссылка в обратную сторону имеет смысл если данные в другой таблице\n  существуют для редко встречающихся версий (экономится место).\n\nМногие к одному \n  поскольку версии не изменяются - при создании новой версии документа\n  можно повторно использовать имеющиеся данные другой таблицы (если\n  они не изменились) скопировав ссылку. Это еще одна причина хранения\n  данных в другой таблице - редко изменяемые данные.\n\nОдин ко многим\n  другая таблица содержит ссылки на данную строку главной. Способ\n  представления списка объектов относящихся к данной версии.\n\nМногие ко многим\n  для такого отношения делается отдельная таблица содержащая ссылки в\n  обе стороны, т. е. предыдущий вариант.\n\nДругие таблицы могут быть связаны с третьими и т. д. Важно чтобы\nсоблюдался принцип неизменяемости версии документа (и всех относящихся\nк документу данной версии компонент).\n\nДля выполнения массовых операций (например для построения отчетов)\nважно простым способом получать временной срез произвольных частей\nдокумента, т.е. рассматривать только те записи, которые действуют на\nзаданный момент времени. Сложность в том, что в таблице данных об\nинтервале действия нет (она не главная).  В большинстве случаев связи\nмежду компонентами документа можно представить в виде дерева, где\nглавная таблица - его корень. Для каждого некорневого узла есть\nединственный путь наверх, к корню. Есть два вида связи между данным\nузлом и узлом верхнего уровня:\n\n1. Узел верхнего уровня содержит ссылку на данный.\n2. Данный узел содержит ссылку на узел верхнего уровня.\n\nВ обоих случаях можно автоматически вычислять префикс доступа к\nглавной таблице и включать в запрос ограничения по времени.\n\n\nСвязи между документами\n=======================\n\nДокументы могут быть связаны друг с другом, для чего в одном документе\nпомещается ссылка на другой. Существует несколько вариантов связей по\nотношению к версиям связываемых документов:\n\n1. Ссылка на конкретную версию документа, заданную конкретным моментом\n   времени в прошлом.   \n2. Ссылка на версию документа, заданную моментом создания версии\n   ссылающегося документа.\n3. Ссылка на последнюю версию документа.\n4. Ссылка на версию документа, заданную некоторым моментом в будущем\n   (после создания версии ссылающегося документа).\n\nСсылка на документ общего вида задается парой (момент,идентификатор),\nи в общем случае необходимо отвести два поля в ссылающемся\nдокументе. В качестве момента времени для ссылки на последнюю версию\nможно взять произвольную дату, близкую к нашей бесконечности, например\n*9998-01-01*.\n\nВ случаях, когда при построении модели заранее известно, что ссылка\nбудет конкретного вида 2 или 3 - можно сэкономить, и хранить только\nидентификатор документа, на который ссылаются. Момент времени в случае\n2 задается моментом создания версии ссылающегося документа, а в случае\n3 - константа.\n\n\nРазрешение ссылок\n=================\n\nЕсли заранее известно, что ссылка будет вида 1 или 2, то ссылки можно\n*разрешать*, то есть вычислять первичный ключ таблицы, хранящей версии\nдокумента, на который ссылаемся, и хранить его значение. Идентификатор\nдокумента, на который ссылаемся можно найти пройдя по ссылке. В случае\n1 момент времени определяется также проходом по ссылке, а во втором\nуже есть в ссылающемся документе.\n\nВариант 2 - наиболее часто встречающийся вид ссылок между документами,\nи разрешение ссылок может дать большой прирост производительности при\nвыполнении массовых операций.\n\n\nРетроспекция\n============\n\nВ процессе создания документов и установки связей участвует глобальное\nзначение момента времени - **сейчас**. Обычно этот момент получается\nзапросом к системным часам. Если это значение сделать параметром\n(который по умолчанию берется из системных часов), то все приложение\nприобретает новое качество - возможность просмотра состояния всей\nсистемы в произвольный момент времени в прошлом. Для этого необходимо\nво все процедуры выборки данных, построения отчетов и т.п. добавить\nфильтрацию документов - версии после **сейчас** не существуют. При\nэтом ссылка на последнюю версию документа должна рассматриваться как\nссылка в момент **сейчас**. Если параметр **сейчас** задан вручную, то\nприложение должно работать в режиме *только для чтения*.\n\n\n--------------------------\nВерсии документов в Django\n--------------------------\n\nДля использования библиотеки необходимо включить в список приложений\nприложение **documents**: *documents.models* содержит абстрактные\nбазовые классы для таблиц составляющих документ, а *documents.fields*\nтип поля для ссылки на документы.\n\nAPI\n===\n\ndocuments.models\n----------------\n\n``DocumentPart`` \n    – абстрактный базовый класс для всех таблиц документа. Задает:\n\n    ``now`` \n        – дополнительный менеджер, задающий фильтр \"сейчас\", где\n        момент времени берется из глобальной переменной (локальной для\n        треда). См. модуль *retrospection*, функции *now* и *set_now*.\n\tГлобальное (для треда) время устанавливается при первом\n        обращении и **остается фиксированным** до изменения с помощью\n        *set_now*.\n    ``ConfigurationError``\n        – исключение, вызываемое в случае некорректной конфигурации\n        документа (например, невозможность определить главную таблицу)\n    ``document_get(cls, datetime, **kwargs)`` \n        – метод класса\n        возвращает объект (часть документа) определяемую ключевыми\n        параметрами и моментом времени. Если объектов нет или\n        несколько - вызывает исключения так же как и *get* для\n        *QuerySet*.\n    ``at(cls, datetime, **kwargs)``\n        – возвращает *QuerySet* для части документа определяемый\n        ключевыми значениями и заданным моментом времени (определяемым\n        по главной таблице документа). Путь к главной таблице\n        определяется с помощью вызова метода класса *to_master*\n        задающего префикс доступа к главной таблице.\n    ``history(self, **kwargs)``\n        – QuerySet для истории части документа в обратном\n        хронологическом порядке. \n\n``Document(DocumentPart)``\n    – абстрактный базовый класс для главной таблицы документа. Задает:\n\n    ``document_start`` – DateTimeField\n        – начальный момент действия данной версии документа (включительно).\n    ``document_end`` – DateTimeField\n        – конечный момент действия (исключительно).\n    ``document_id`` – IntegerField\n        – уникальный идентификатор данного документа. Если не задан -\n        вычисляется автоматически.\n    ``ChangedAlready`` – исключение\n        – вызывается методом *document_save* если заданный *id* не\n        является ключом последней версии документа.\n    ``document_save(self, document_start=None)``\n        – записывает в базу данных новую версию объекта главной таблицы\n        документа. В последней версии документа (если она есть)\n        устанавливается *document_end* (равный *document_start* для\n        новой версии). Если задан document_start, то он становится\n\tначалом действия новой версии, в противном случае берется\n\tdatetime.now().\n\n\tЕсли *id* не *None*, то предполагается что он\n        задает ключ последней версии документа (находящейся в\n        базе). Если это не так (не последняя), вызывается исключение\n        (позволяет обнаружить параллельное изменение документа\n        несколькими пользователями). Если не задан (нулевой)\n        идентификатор документа, после записи в базу вызывается\n        *new_document_id* для данного объекта и производится повторная\n        запись в базу уже с новым идентификатором. Все действия\n        выполняются в одной транзакции.\n    ``save_now(self)`` \n        – аналогично document_save, но в момент\n        заданный глобально (для треда). \n    ``new_document_id(self)`` \n        – выдает новый идентификатор для данного документа.\n    ``document_get_or_404(cls, datetime, **kwargs)``\n        – аналог *get_object_or_404* с указанием момента времени в качестве\n        первого параметра.\n    ``at(cls, datetime, **kwargs)``\n        – переопределяет метод базового класса для главной таблицы.\n    ``history(self, **kwargs)``\n        – QuerySet для истории документа в обратном\n        хронологическом порядке. \n    ``document_restore(self, document_start=None)``\n        – восстановить документ в активное состояние из текущей старой версии.\n\n        В составных документах надо переопределять, так как порядок\n        сохранения частей зависит от вида связи между частями. Ссылки\n        на другие части можно оставить как есть, а части ссылающиеся\n        на этот документ надо скопировать и перепривязать к новой\n        версии.\n    ``restore_now(self)`` \n        – аналогично document_restore, но в момент\n        заданный глобально (для треда).\n    ``bulk_documents_save(cls, documents, document_start=None)``\n        – сохранить новые версии документов (массовая загрузка).\n    ``bulk_save_now(cls, documents)`` \n        – аналогично bulk_documents_save,\n        но в момент заданный глобально (для треда).\n    ``bulk_documents_delete(cls, documents, delete_time=None)``\n        – массовое удаление документов, возвращает количество удаленных.\n    ``bulk_delete_now(cls, documents)`` \n        – аналогично bulk_documents_delete, но в момент заданный\n        глобально (для треда).\n\n\n\n``DocumentPartF(DocumentPart)``\n    – абстрактный базовый класс для части документа с версиями, на\n    которую ссылаются из главной или более близкой к главной части\n    документа. Определяет:\n\n    ``to_master(cls)``\n        – выдает префикс для пути к главной таблице документа. Делается\n        попытка найти модель унаследованную от *DocumentPart*\n        ссылающуюся на данную. Если это главная таблица - то задача\n        решена, в противном случае вызывается *to_master* для\n        найденной модели. Если модель не найдена или найдена не одна,\n        то вызывается исключение *ConfigurationError*. В этом случае\n        метод надо переопределить.\n\n``DocumentPartB(DocumentPart)``\n    – абстрактный базовый класс для части документа с версиями, которая\n    ссылается на главную или более близкую к главной часть\n    документа. Определяет:\n\n    ``to_master(cls)``\n        – выдает префикс для пути к главной таблице документа. Делается\n        попытка найти модель унаследованную от *DocumentPart*, на\n        которую ссылаются из данной. Если это главная таблица - то\n        задача решена, в противном случае вызывается *to_master* для\n        найденной модели. Если модель не найдена или найдена не одна,\n        то вызывается исключение *ConfigurationError*. В этом случае\n        метод надо переопределить.\n\n``load_related_document_fk(datetime, object_list, field)``\n     – аналог select_related для полей, ссылающихся на другой объект\n     через DocumentForeignKey. Загружает связанные через поле\n     {field} объекты в поле {field}_cached (ПОКА НЕ РЕАЛИЗОВАНО).\n\n\ndocuments.fields\n----------------\n\nСсылки на другие документы первых двух типов реализуются с помощью\nобычного поля типа *ForeignKey*. Ссылка третьего типа представляет\nинтерес при создании составного документа, который всегда показывает\nна последние версии других документов. Для ее реализации нужно\nиспользовать:\n\n``DocumentForeignKey(models.ForeignKey)``\n   – первый аргумент должен указывать на модель унаследованную от\n   *Document*. Остальные значения не обязательны (такие же как для\n   *ForeignKey*). Для доступа к объекту, на который сделана ссылка\n   используются те же методы что и для *ForeignKey*, за исключением\n   чтения, при котором нужно указывать момент времени::\n\n    class Source(...):\n      ...\n      link = DocumentForeignKey(SomeDocument)\n      ...\n\n    t = datetime.now()\n    s = Source.objects.get(pk=123)\n    some_document = s.link(t)\n\nВ НАСТОЯЩИЙ МОМЕНТ ФУНКЦИОНАЛЬНОСТЬ НЕ РЕАЛИЗОВАНА. ИСПОЛЬЗУЕТСЯ\nПРОСТО ЦЕЛОЕ ЗНАЧЕНИЕ.\n\n\ndocuments.retrospection\n-----------------------\n\n``now(request=None)``\n    – возвращает время установленное в запросе (если есть). Если нет,\n    или запрос не указан, возвращает текущее время треда. Если время\n    треда не задано – устанавливает. Последующие вызовы будут\n    возвращать одно и то же время до тех пор пока не закончится\n    обработка запроса или не будет установлено новое фиксированное\n    время с помощью *set_now*.\n\n``set_now(dt=None)``\n    – устанавливает новое фиксированное время, локальное для треда, в\n    dt или в datetime.now() если параметр не задан.\n\n``current_time(dt=None)``\n    – контекст менеджер – временно установить время в заданное значение.\n\n``@with_real_time``\n    – декоратор – устанавливает реальное время для выполнения функции.\n\n\ndocuments.admin\n---------------\n\nДля того, чтобы с документами можно было работать так же, как с\nобычными моделями, нужно использовать ``DocumentModelAdmin``. При его\nиспользовании мы видим только последнии версии документов, и можем\nпросмотреть историю изменений (вместе со значениями всех полей). При\nкаждом сохранении создается новая версия документа. Поддерживаются\nполя ``DocumentForeignKey`` (в виджете мы видим только последние версии\nдокументов). Но следует иметь ввиду, что совсем забыть о том, что мы\nработает с версионными документами, не получится. Эта часть\nпроверялась на ограниченном наборе связей и моделей.\n\n\nMiddleware для ретроспекции\n===========================\n\nРеализовано в ``documents.retrospection.RetrospectionMiddleware``.\n\nПараметр **сейчас** удобно хранить в данных сессии. В этом случае\nmiddleware может выполнить две функции:\n\n1. Установку значения **now** в данных сессии (если оно не задано\n   пользователем).\n2. Блокировку post-запросов в случае вручную заданного ограничения по\n   времени (Режим только для чтения).\n\nHе все post-запросы надо блокировать, например запросы отменяющие\nрежим ретроспекции. Для того, чтобы middleware \"пропустило\" запрос, \nнеобходимо включить в него поле ``post_in_retrospection``.\n\nДля включения нужно поместить \n``documents.retrospection.RetrospectionMiddleware`` в\nсписок ``MIDDLEWARE_CLASSES`` после ``SessionMiddleware``. \n\nПример\n======\n\nВ качестве примера добавим поддержку версий документов в приложение из\n`учебника Django \n<https://docs.djangoproject.com/en/1.4/intro/tutorial01/#creating-models>`_.\n\nВ примере рассматриваются два объекта: Poll и Choice. Poll – вопрос\nдля голосования, Choice - варианты ответов. Счетчик количества ответов\nобъединен с ответом::\n\n class Poll(models.Model):\n    question = models.CharField(max_length=200)\n    pub_date = models.DateTimeField('date published')\n\n    def __unicode__(self):\n        return self.question\n\n class Choice(models.Model):\n    poll = models.ForeignKey(Poll)\n    choice = models.CharField(max_length=200)\n    votes = models.IntegerField()\n\n    def __unicode__(self):\n        return self.choice\n\nВарианты ответа привязаны к вопросу. Внесем следующие изменения:\n\n1. Сделаем *вопрос* и *ответ* документами с версиями.\n2. *ответ* - универсальный документ - может встречаться в нескольких\n   вопросах.\n3. Результат опроса хранится в документе *результат*.\n\nМодель становится такой::\n\n class Choice(Document):\n     choice = models.CharField(max_length=200)\n\n     def __unicode__(self):\n        return self.choice\n \n class Poll(Document):\n     question = models.CharField(max_length=200)\n\n     def __unicode__(self): \n        return self.question\n \n class PollChoices(DocumentPartB):\n     poll = models.ForeignKey(Poll)\n     choice = models.ForeignKey(Choice)\n\n     @classmethod\n     def to_master(cls): \n        return 'poll'\n \n class PollResults(Document):\n     poll = models.ForeignKey(Poll)\n     choice = models.ForeignKey(Choice)\n     votes = models.IntegerField()\n\n     @staticmethod\n     def vote(poll_document_id, choice_document_id):\n         n = datetime.now()\n         p = Poll.document_get(n, document_id=poll_document_id)\n         c = Choice.document_get(n, document_id=choice_document_id)\n         try: \n             v = PollResults.document_get(\n                 n, poll__document_id=poll_document_id,\n                 choice__document_id=choice_document_id)\n             v.votes += 1\n         except PollResults.DoesNotExist:\n             v = PollResults(poll=p, choice=c, votes=1)\n         v.document_save()\n         return v.document_id\n\nDocument\n  базовый абстрактный класс для всех документов.\nChoice\n  вариант ответа. Документ. \nPoll\n  вопрос для голосования. Документ.\nPollChoices\n  часть документа **Poll** – содержит текущий список вариантов ответов\n  на вопрос.\nPollResults\n  текущее количество ответов заданного вида на вопрос. Документ.\n\n\nПример работы\n-------------\n\n::\n\n >>> from documents_test.docs.models import *\n \n # Пока нет голосований\n >>> Poll.objects.all()\n []\n \n # Создаем новое\n >>> p = Poll(question='Who is who?')\n \n # Сохраняем.\n >>> p.document_save()\n \n # Теперь есть id, document_id, document_start и document_end.\n >>> p.id\n 1\n >>> p.document_id\n 1\n \n # Access database columns via Python attributes.\n >>> print p.question\n Who is who?\n \n >>> p.document_start # doctest: +ELLIPSIS\n datetime.datetime(...)\n \n # Give the Poll a couple of Choices.\n >>> now = datetime.now()\n >>> p = Poll.document_get(now, document_id=1)\n \n # Display any choices from the related object set -- none so far.\n >>> PollChoices.at(now)\n []\n \n # Create three choices.\n >>> c1 = Choice(choice='President'); c1.document_save(); c1\n <Choice: President>\n >>> c2 = Choice(choice='Agent'); c2.document_save(); c2\n <Choice: Agent>\n >>> c3 = Choice(choice='Gena Crocodile'); c3.document_save(); c3\n <Choice: Gena Crocodile>\n \n # document_id назначен автоматически:\n >>> for c in (c1, c2, c3): print c.document_id\n 1\n 2\n 3\n \n # Добавим их:\n >>> p.document_save() # новая версия\n >>> p.pollchoices_set.add(*[PollChoices(choice=c) for c in (c1, c2, c3)]) \n \n # Голосование (результат - идентификатор документа в котором сделана отметка):\n >>> PollResults.vote(1, 1)\n 1\n >>> PollResults.vote(1, 1)\n 1\n >>> PollResults.vote(1, 1)\n 1\n >>> PollResults.vote(1, 2)\n 4\n \n # Запомним момент в промежутке (t):\n >>> from time import sleep\n >>> sleep(0.1)\n >>> t = datetime.now()\n >>> sleep(0.1)\n \n >>> PollResults.vote(1, 2)\n 4\n >>> PollResults.vote(1, 3)\n 6\n \n # Результаты голосования:\n >>> for r in PollResults.at(datetime.now(), poll__document_id=1):\n ...     print r.votes, r.choice.choice\n 3 President\n 2 Agent\n 1 Gena Crocodile\n \n # Ретроспекция (состояние на момент t):\n >>> for r in PollResults.at(t, poll__document_id=1):\n ...     print r.votes, r.choice.choice\n 3 President\n 1 Agent\n\n \nРедактор вопросов и ответов\n---------------------------\n\nУчебник Django предлагает создавать опросник через административный\nинтерфейс. В нашем случае такой подход не годится. Административный\nинтерфейс Django ничего не знает про документы и версии, поэтому его\nнадо использовать для управления пользователями и, при необходимости,\nдля редактирования данных *в обход системы управления\nверсиями*. Существуют *стационарные* данные в системе (например\nнекоторые справочники), которые не могут или не должны изменяться с\nтечением времени (за исключением исправления ошибок), для управления\nкоторыми административный интерфейс будет пригоден.\n\nПримечание: есть также ``documents.admin``, но он позволяет редактировать \nв админке лишь простые документы (состоящие из одной модели).\n\n.. -*- Local Variables:\n.. -*- mode: rst\n.. -*- mode: auto-fill\n.. -*- End:\n.. vim:set ft=rst:\n",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/chtd/doc-versions",
    "keywords": null,
    "license": "MIT",
    "maintainer": null,
    "maintainer_email": null,
    "name": "doc-versions",
    "package_url": "https://pypi.org/project/doc-versions/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/doc-versions/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "https://github.com/chtd/doc-versions"
    },
    "release_url": "https://pypi.org/project/doc-versions/0.1.1/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "Django app for tracking changes in models",
    "version": "0.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 733113,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0af26052eaeed6ca0a7a311141bac38fcf427b6ff4663433bd77ccfdc0fe9a98",
          "md5": "f1ad1f1dd0df8312f9404ad14c533f4e",
          "sha256": "8126f456198dcb90d3d6a8a3cd592bfaf8ea9614437967065dba0c7910c96808"
        },
        "downloads": -1,
        "filename": "doc-versions-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f1ad1f1dd0df8312f9404ad14c533f4e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 25295,
        "upload_time": "2013-02-23T18:13:31",
        "upload_time_iso_8601": "2013-02-23T18:13:31.512033Z",
        "url": "https://files.pythonhosted.org/packages/0a/f2/6052eaeed6ca0a7a311141bac38fcf427b6ff4663433bd77ccfdc0fe9a98/doc-versions-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1e5ca6b389fe67d3f83aa0e96fa0c1ceb4fb1cfa4880070b802e8563666b04c0",
          "md5": "aa0506480bb52a8fc36e7fecd81273b4",
          "sha256": "0fce7964acce303ad4d5eec81e2a20c3e9dd94493389eec0c8c4b09df1e4fc7d"
        },
        "downloads": -1,
        "filename": "doc-versions-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "aa0506480bb52a8fc36e7fecd81273b4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 26060,
        "upload_time": "2013-02-23T18:35:29",
        "upload_time_iso_8601": "2013-02-23T18:35:29.132573Z",
        "url": "https://files.pythonhosted.org/packages/1e/5c/a6b389fe67d3f83aa0e96fa0c1ceb4fb1cfa4880070b802e8563666b04c0/doc-versions-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1e5ca6b389fe67d3f83aa0e96fa0c1ceb4fb1cfa4880070b802e8563666b04c0",
        "md5": "aa0506480bb52a8fc36e7fecd81273b4",
        "sha256": "0fce7964acce303ad4d5eec81e2a20c3e9dd94493389eec0c8c4b09df1e4fc7d"
      },
      "downloads": -1,
      "filename": "doc-versions-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "aa0506480bb52a8fc36e7fecd81273b4",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 26060,
      "upload_time": "2013-02-23T18:35:29",
      "upload_time_iso_8601": "2013-02-23T18:35:29.132573Z",
      "url": "https://files.pythonhosted.org/packages/1e/5c/a6b389fe67d3f83aa0e96fa0c1ceb4fb1cfa4880070b802e8563666b04c0/doc-versions-0.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}