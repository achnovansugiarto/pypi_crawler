{
  "info": {
    "author": "",
    "author_email": "Simon Glass <sjg@chromium.org>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": ".. SPDX-License-Identifier: GPL-2.0+\n.. Copyright (c) 2016 Google, Inc\n\nIntroduction\n============\n\nFirmware often consists of several components which must be packaged together.\nFor example, we may have SPL, U-Boot, a device tree and an environment area\ngrouped together and placed in MMC flash. When the system starts, it must be\nable to find these pieces.\n\nBuilding firmware should be separate from packaging it. Many of the complexities\nof modern firmware build systems come from trying to do both at once. With\nbinman, you build all the pieces that are needed, using whatever assortment of\nprojects and build systems are needed, then use binman to stitch everything\ntogether.\n\n\nWhat it does\n------------\n\nBinman reads your board's device tree and finds a node which describes the\nrequired image layout. It uses this to work out what to place where.\n\nBinman provides a mechanism for building images, from simple SPL + U-Boot\ncombinations, to more complex arrangements with many parts. It also allows\nusers to inspect images, extract and replace binaries within them, repacking if\nneeded.\n\n\nFeatures\n--------\n\nApart from basic padding, alignment and positioning features, Binman supports\nhierarchical images, compression, hashing and dealing with the binary blobs\nwhich are a sad trend in open-source firmware at present.\n\nExecutable binaries can access the location of other binaries in an image by\nusing special linker symbols (zero-overhead but somewhat limited) or by reading\nthe devicetree description of the image.\n\nBinman is designed primarily for use with U-Boot and associated binaries such\nas ARM Trusted Firmware, but it is suitable for use with other projects, such\nas Zephyr. Binman also provides facilities useful in Chromium OS, such as CBFS,\nvblocks and the like.\n\nBinman provides a way to process binaries before they are included, by adding a\nPython plug-in.\n\nBinman is intended for use with U-Boot but is designed to be general enough\nto be useful in other image-packaging situations.\n\n\nMotivation\n----------\n\nAs mentioned above, packaging of firmware is quite a different task from\nbuilding the various parts. In many cases the various binaries which go into\nthe image come from separate build systems. For example, ARM Trusted Firmware\nis used on ARMv8 devices but is not built in the U-Boot tree. If a Linux kernel\nis included in the firmware image, it is built elsewhere.\n\nIt is of course possible to add more and more build rules to the U-Boot\nbuild system to cover these cases. It can shell out to other Makefiles and\nbuild scripts. But it seems better to create a clear divide between building\nsoftware and packaging it.\n\nAt present this is handled by manual instructions, different for each board,\non how to create images that will boot. By turning these instructions into a\nstandard format, we can support making valid images for any board without\nmanual effort, lots of READMEs, etc.\n\nBenefits:\n\n  - Each binary can have its own build system and tool chain without creating\n    any dependencies between them\n  - Avoids the need for a single-shot build: individual parts can be updated\n    and brought in as needed\n  - Provides for a standard image description available in the build and at\n    run-time\n  - SoC-specific image-signing tools can be accommodated\n  - Avoids cluttering the U-Boot build system with image-building code\n  - The image description is automatically available at run-time in U-Boot,\n    SPL. It can be made available to other software also\n  - The image description is easily readable (it's a text file in device-tree\n    format) and permits flexible packing of binaries\n\n\nTerminology\n-----------\n\nBinman uses the following terms:\n\n- image - an output file containing a firmware image\n- binary - an input binary that goes into the image\n\n\nInstallation\n------------\n\nYou can install binman using::\n\n   pip install binary-manager\n\nThe name is chosen since binman conflicts with an existing package.\n\nIf you are using binman within the U-Boot tree, it may be easiest to add a\nsymlink from your local `~/.bin` directory to `/path/to/tools/binman/binman`.\n\n\nRelationship to FIT\n-------------------\n\nFIT is U-Boot's official image format. It supports multiple binaries with\nload / execution addresses, compression. It also supports verification\nthrough hashing and RSA signatures.\n\nFIT was originally designed to support booting a Linux kernel (with an\noptional ramdisk) and device tree chosen from various options in the FIT.\nNow that U-Boot supports configuration via device tree, it is possible to\nload U-Boot from a FIT, with the device tree chosen by SPL.\n\nBinman considers FIT to be one of the binaries it can place in the image.\n\nWhere possible it is best to put as much as possible in the FIT, with binman\nused to deal with cases not covered by FIT. Examples include initial\nexecution (since FIT itself does not have an executable header) and dealing\nwith device boundaries, such as the read-only/read-write separation in SPI\nflash.\n\nFor U-Boot, binman should not be used to create ad-hoc images in place of\nFIT.\n\nNote that binman can itself create a FIT. This helps to move mkimage\ninvocations out of the Makefile and into binman image descriptions. It also\nhelps by removing the need for ad-hoc tools like `make_fit_atf.py`.\n\n\nRelationship to mkimage\n-----------------------\n\nThe mkimage tool provides a means to create a FIT. Traditionally it has\nneeded an image description file: a device tree, like binman, but in a\ndifferent format. More recently it has started to support a '-f auto' mode\nwhich can generate that automatically.\n\nMore relevant to binman, mkimage also permits creation of many SoC-specific\nimage types. These can be listed by running 'mkimage -T list'. Examples\ninclude 'rksd', the Rockchip SD/MMC boot format. The mkimage tool is often\ncalled from the U-Boot build system for this reason.\n\nBinman considers the output files created by mkimage to be binary blobs\nwhich it can place in an image. Binman does not replace the mkimage tool or\nthis purpose. It would be possible in some situations to create a new entry\ntype for the images in mkimage, but this would not add functionality. It\nseems better to use the mkimage tool to generate binaries and avoid blurring\nthe boundaries between building input files (mkimage) and packaging then\ninto a final image (binman).\n\nNote that binman can itself invoke mkimage. This helps to move mkimage\ninvocations out of the Makefile and into binman image descriptions.\n\n\nUsing binman\n============\n\nExample use of binman in U-Boot\n-------------------------------\n\nBinman aims to replace some of the ad-hoc image creation in the U-Boot\nbuild system.\n\nConsider sunxi. It has the following steps:\n\n  #. It uses a custom mksunxiboot tool to build an SPL image called\n     sunxi-spl.bin. This should probably move into mkimage.\n\n  #. It uses mkimage to package U-Boot into a legacy image file (so that it can\n     hold the load and execution address) called u-boot.img.\n\n  #. It builds a final output image called u-boot-sunxi-with-spl.bin which\n     consists of sunxi-spl.bin, some padding and u-boot.img.\n\nBinman is intended to replace the last step. The U-Boot build system builds\nu-boot.bin and sunxi-spl.bin. Binman can then take over creation of\nsunxi-spl.bin by calling mksunxiboot or mkimage. In any case, it would then\ncreate the image from the component parts.\n\nThis simplifies the U-Boot Makefile somewhat, since various pieces of logic\ncan be replaced by a call to binman.\n\n\nInvoking binman within U-Boot\n-----------------------------\n\nWithin U-Boot, binman is invoked by the build system, i.e. when you type 'make'\nor use buildman to build U-Boot. There is no need to run binman independently\nduring development. Everything happens automatically and is set up for your\nSoC or board so that binman produced the right things.\n\nThe general policy is that the Makefile builds all the binaries in INPUTS-y\n(the 'inputs' rule), then binman is run to produce the final images (the 'all'\nrule).\n\nThere should be only one invocation of binman in Makefile, the very last step\nthat pulls everything together. At present there are some arch-specific\ninvocations as well, but these should be dropped when those architectures are\nconverted to use binman properly.\n\nAs above, the term 'binary' is used for something in INPUTS-y and 'image' is\nused for the things that binman creates. So the binaries are inputs to the\nimage(s) and it is the image that is actually loaded on the board.\n\nAgain, at present, there are a number of things created in Makefile which should\nbe done by binman (when we get around to it), like `u-boot-ivt.img`,\n`lpc32xx-spl.img`, `u-boot-with-nand-spl.imx`, `u-boot-spl-padx4.sfp` and\n`u-boot-mtk.bin`, just to pick on a few. When completed this will remove about\n400 lines from `Makefile`.\n\nSince binman is invoked only once, it must of course create all the images that\nare needed, in that one invocation. It does this by working through the image\ndescriptions one by one, collecting the input binaries, processing them as\nneeded and producing the final images.\n\nThe same binaries may be used by multiple images. For example binman may be used\nto produce an SD-card image and a SPI-flash image. In this case the binaries\ngoing into the process are the same, but binman produces slightly different\nimages in each case.\n\nFor some SoCs, U-Boot is not the only project that produces the necessary\nbinaries. For example, ARM Trusted Firmware (ATF) is a project that produces\nbinaries which must be incorporate, such as `bl31.elf` or `bl31.bin`. For this\nto work you must have built ATF before you build U-Boot and you must tell U-Boot\nwhere to find the bl31 image, using the BL31 environment variable.\n\nHow do you know how to incorporate ATF? It is handled by the atf-bl31 entry type\n(etype). An etype is an implementation of reading a binary into binman, in this\ncase the `bl31.bin` file. When you build U-Boot but do not set the BL31\nenvironment variable, binman provides a help message, which comes from\n`missing-blob-help`::\n\n    See the documentation for your board. You may need to build ARM Trusted\n    Firmware and build with BL31=/path/to/bl31.bin\n\nThe mechanism by which binman is advised of this is also in the Makefile. See\nthe `-a atf-bl31-path=${BL31}` piece in `cmd_binman`. This tells binman to\nset the EntryArg `atf-bl31-path` to the value of the `BL31` environment\nvariable. Within binman, this EntryArg is picked up by the `Entry_atf_bl31`\netype. An EntryArg is simply an argument to the entry. The `atf-bl31-path`\nname is documented in .\n\nTaking this a little further, when binman is used to create a FIT, it supports\nusing an ELF file, e.g. `bl31.elf` and splitting it into separate pieces (with\n`fit,operation = \"split-elf\"`), each with its own load address.\n\n\nInvoking binman outside U-Boot\n------------------------------\n\nWhile binman is invoked from within the U-Boot build system, it is also possible\nto invoke it separately. This is typically used in a production build system,\nwhere signing is completed (with real keys) and any missing binaries are\nprovided.\n\nFor example, for build testing there is no need to provide a real signature,\nnor is there any need to provide a real ATF BL31 binary (for example). These can\nbe added later by invoking binman again, providing all the required inputs\nfrom the first time, plus any that were missing or placeholders.\n\nSo in practice binman is often used twice:\n\n- once within the U-Boot build system, for development and testing\n- again outside U-Boot to assembly and final production images\n\nWhile the same input binaries are used in each case, you will of course you will\nneed to create your own binman command line, similar to that in `cmd_binman` in\nthe Makefile. You may find the -I and --toolpath options useful. The\ndevice tree file is provided to binman in binary form, so there is no need to\nhave access to the original `.dts` sources.\n\n\nAssembling the image description\n--------------------------------\n\nSince binman uses the device tree for its image description, you can use the\nsame files that describe your board's hardware to describe how the image is\nassembled. Typically the images description is in a common file used by all\nboards with a particular SoC (e.g. `imx8mp-u-boot.dtsi`).\n\nWhere a particular boards needs to make changes, it can override properties in\nthe SoC file, just as it would for any other device tree property. It can also\nadd a image that is specific to the board.\n\nAnother way to control the image description to make use of CONFIG options in\nthe description. For example, if the start offset of a particular entry varies\nby board, you can add a Kconfig for that and reference it in the description::\n\n    u-boot-spl {\n    };\n\n    fit {\n        offset = <CONFIG_SPL_PAD_TO>;\n        ...\n    };\n\nThe SoC can provide a default value but boards can override that as needed and\nbinman will take care of it.\n\nIt is even possible to control which entries appear in the image, by using the\nC preprocessor::\n\n    #ifdef CONFIG_HAVE_MRC\n        intel-mrc {\n                offset = <CFG_X86_MRC_ADDR>;\n        };\n    #endif\n\nOnly boards which enable `HAVE_MRC` will include this entry.\n\nObviously a similar approach can be used to control which images are produced,\nwith a Kconfig option to enable a SPI image, for example. However there is\ngenerally no harm in producing an image that is not used. If a board uses MMC\nbut not SPI, but the SoC supports booting from both, then both images can be\nproduced, with only on or other being used by particular boards. This can help\nreduce the need for having multiple defconfig targets for a board where the\nonly difference is the boot media, enabling / disabling secure boot, etc.\n\nOf course you can use the device tree itself to pass any board-specific\ninformation that is needed by U-Boot at runtime (see binman_syms_ for how to\nmake binman insert these values directly into executables like SPL).\n\nThere is one more way this can be done: with individual .dtsi files for each\nimage supported by the SoC. Then the board `.dts` file can include the ones it\nwants. This is not recommended, since it is likely to be difficult to maintain\nand harder to understand the relationship between the different boards.\n\n\nProducing images for multiple boards\n------------------------------------\n\nWhen invoked within U-Boot, binman only builds a single set of images, for\nthe chosen board. This is set by the `CONFIG_DEFAULT_DEVICE_TREE` option.\n\nHowever, U-Boot generally builds all the device tree files associated with an\nSoC. These are written to the (e.g. for ARM) `arch/arm/dts` directory. Each of\nthese contains the full binman description for that board. Often the best\napproach is to build a single image that includes all these device tree binaries\nand allow SPL to select the correct one on boot.\n\nHowever, it is also possible to build separate images for each board, simply by\ninvoking binman multiple times, once for each device tree file, using a\ndifferent output directory. This will produce one set of images for each board.\n\n\nExample use of binman for x86\n-----------------------------\n\nIn most cases x86 images have a lot of binary blobs, 'black-box' code\nprovided by Intel which must be run for the platform to work. Typically\nthese blobs are not relocatable and must be placed at fixed areas in the\nfirmware image.\n\nCurrently this is handled by ifdtool, which places microcode, FSP, MRC, VGA\nBIOS, reference code and Intel ME binaries into a u-boot.rom file.\n\nBinman is intended to replace all of this, with ifdtool left to handle only\nthe configuration of the Intel-format descriptor.\n\n\nInstalling binman\n-----------------\n\nFirst install prerequisites, e.g:\n\n.. code-block:: bash\n\n    sudo apt-get install python-pyelftools python3-pyelftools lzma-alone \\\n        liblz4-tool\n\nYou can run binman directly if you put it on your PATH. But if you want to\ninstall into your `~/.local` Python directory, use:\n\n.. code-block:: bash\n\n    pip install tools/patman tools/dtoc tools/binman\n\nNote that binman makes use of libraries from patman and dtoc, which is why these\nneed to be installed. Also you need `libfdt` and `pylibfdt` which can be\ninstalled like this:\n\n.. code-block:: bash\n\n   git clone git://git.kernel.org/pub/scm/utils/dtc/dtc.git\n   cd dtc\n   pip install .\n   make NO_PYTHON=1 install\n\nThis installs the `libfdt.so` library into `~/lib` so you can use\n`LD_LIBRARY_PATH=~/lib` when running binman. If you want to install it in the\nsystem-library directory, replace the last line with:\n\n.. code-block:: bash\n\n   make NO_PYTHON=1 PREFIX=/ install\n\nRunning binman\n--------------\n\nType::\n\n.. code-block: bash\n\n   make NO_PYTHON=1 PREFIX=/ install\n    binman build -b <board_name>\n\nto build an image for a board. The board name is the same name used when\nconfiguring U-Boot (e.g. for sandbox_defconfig the board name is 'sandbox').\nBinman assumes that the input files for the build are in ../b/<board_name>.\n\nOr you can specify this explicitly:\n\n.. code-block:: bash\n\n   make NO_PYTHON=1 PREFIX=/ install\n    binman build -I <build_path>\n\nwhere <build_path> is the build directory containing the output of the U-Boot\nbuild.\n\n(Future work will make this more configurable)\n\nIn either case, binman picks up the device tree file (u-boot.dtb) and looks\nfor its instructions in the 'binman' node.\n\nBinman has a few other options which you can see by running 'binman -h'.\n\n\nEnabling binman for a board\n---------------------------\n\nAt present binman is invoked from a rule in the main Makefile. You should be\nable to enable CONFIG_BINMAN to enable this rule.\n\nThe output file is typically named image.bin and is located in the output\ndirectory. If input files are needed to you add these to INPUTS-y either in the\nmain Makefile or in a config.mk file in your arch subdirectory.\n\nOnce binman is executed it will pick up its instructions from a device-tree\nfile, typically <soc>-u-boot.dtsi, where <soc> is your CONFIG_SYS_SOC value.\nYou can use other, more specific CONFIG options - see 'Automatic .dtsi\ninclusion' below.\n\n.. _binman_syms:\n\nAccess to binman entry offsets at run time (symbols)\n----------------------------------------------------\n\nBinman assembles images and determines where each entry is placed in the image.\nThis information may be useful to U-Boot at run time. For example, in SPL it\nis useful to be able to find the location of U-Boot so that it can be executed\nwhen SPL is finished.\n\nBinman allows you to declare symbols in the SPL image which are filled in\nwith their correct values during the build. For example:\n\n.. code-block:: c\n\n    binman_sym_declare(ulong, u_boot_any, image_pos);\n\ndeclares a ulong value which will be assigned to the image-pos of any U-Boot\nimage (u-boot.bin, u-boot.img, u-boot-nodtb.bin) that is present in the image.\nYou can access this value with something like:\n\n.. code-block:: c\n\n    ulong u_boot_offset = binman_sym(ulong, u_boot_any, image_pos);\n\nThus u_boot_offset will be set to the image-pos of U-Boot in memory, assuming\nthat the whole image has been loaded, or is available in flash. You can then\njump to that address to start U-Boot.\n\nAt present this feature is only supported in SPL and TPL. In principle it is\npossible to fill in such symbols in U-Boot proper, as well, but a future C\nlibrary is planned for this instead, to read from the device tree.\n\nAs well as image-pos, it is possible to read the size of an entry and its\noffset (which is the start position of the entry within its parent).\n\nA small technical note: Binman automatically adds the base address of the image\n(i.e. __image_copy_start) to the value of the image-pos symbol, so that when the\nimage is loaded to its linked address, the value will be correct and actually\npoint into the image.\n\nFor example, say SPL is at the start of the image and linked to start at address\n80108000. If U-Boot's image-pos is 0x8000 then binman will write an image-pos\nfor U-Boot of 80110000 into the SPL binary, since it assumes the image is loaded\nto 80108000, with SPL at 80108000 and U-Boot at 80110000.\n\nFor x86 devices (with the end-at-4gb property) this base address is not added\nsince it is assumed that images are XIP and the offsets already include the\naddress.\n\nWhile U-Boot's symbol updating is handled automatically by the u-boot-spl\nentry type (and others), it is possible to use this feature with any blob. To\ndo this, add a `write-symbols` (boolean) property to the node, set the ELF\nfilename using `elf-filename` and set 'elf-base-sym' to the base symbol for the\nstart of the binary image (this defaults to `__image_copy_start` which is what\nU-Boot uses). See `testBlobSymbol()` for an example.\n\n.. _binman_fdt:\n\nAccess to binman entry offsets at run time (fdt)\n------------------------------------------------\n\nBinman can update the U-Boot FDT to include the final position and size of\neach entry in the images it processes. The option to enable this is -u and it\ncauses binman to make sure that the 'offset', 'image-pos' and 'size' properties\nare set correctly for every entry. Since it is not necessary to specify these in\nthe image definition, binman calculates the final values and writes these to\nthe device tree. These can be used by U-Boot at run-time to find the location\nof each entry.\n\nAlternatively, an FDT map entry can be used to add a special FDT containing\njust the information about the image. This is preceded by a magic string so can\nbe located anywhere in the image. An image header (typically at the start or end\nof the image) can be used to point to the FDT map. See fdtmap and image-header\nentries for more information.\n\nMap files\n---------\n\nThe -m option causes binman to output a .map file for each image that it\ngenerates. This shows the offset and size of each entry. For example::\n\n      Offset      Size  Name\n    00000000  00000028  main-section\n     00000000  00000010  section@0\n      00000000  00000004  u-boot\n     00000010  00000010  section@1\n      00000000  00000004  u-boot\n\nThis shows a hierarchical image with two sections, each with a single entry. The\noffsets of the sections are absolute hex byte offsets within the image. The\noffsets of the entries are relative to their respective sections. The size of\neach entry is also shown, in bytes (hex). The indentation shows the entries\nnested inside their sections.\n\n\nPassing command-line arguments to entries\n-----------------------------------------\n\nSometimes it is useful to pass binman the value of an entry property from the\ncommand line. For example some entries need access to files and it is not\nalways convenient to put these filenames in the image definition (device tree).\n\nThe -a option supports this::\n\n    -a <prop>=<value>\n\nwhere::\n\n    <prop> is the property to set\n    <value> is the value to set it to\n\nNot all properties can be provided this way. Only some entries support it,\ntypically for filenames.\n\n\nImage description format\n========================\n\nThe binman node is called 'binman'. An example image description is shown\nbelow::\n\n    binman {\n        filename = \"u-boot-sunxi-with-spl.bin\";\n        pad-byte = <0xff>;\n        blob {\n            filename = \"spl/sunxi-spl.bin\";\n        };\n        u-boot {\n            offset = <CONFIG_SPL_PAD_TO>;\n        };\n    };\n\n\nThis requests binman to create an image file called u-boot-sunxi-with-spl.bin\nconsisting of a specially formatted SPL (spl/sunxi-spl.bin, built by the\nnormal U-Boot Makefile), some 0xff padding, and a U-Boot legacy image. The\npadding comes from the fact that the second binary is placed at\nCONFIG_SPL_PAD_TO. If that line were omitted then the U-Boot binary would\nimmediately follow the SPL binary.\n\nThe binman node describes an image. The sub-nodes describe entries in the\nimage. Each entry represents a region within the overall image. The name of\nthe entry (blob, u-boot) tells binman what to put there. For 'blob' we must\nprovide a filename. For 'u-boot', binman knows that this means 'u-boot.bin'.\n\nEntries are normally placed into the image sequentially, one after the other.\nThe image size is the total size of all entries. As you can see, you can\nspecify the start offset of an entry using the 'offset' property.\n\nNote that due to a device tree requirement, all entries must have a unique\nname. If you want to put the same binary in the image multiple times, you can\nuse any unique name, with the 'type' property providing the type.\n\nThe attributes supported for entries are described below.\n\noffset:\n    This sets the offset of an entry within the image or section containing\n    it. The first byte of the image is normally at offset 0. If 'offset' is\n    not provided, binman sets it to the end of the previous region, or the\n    start of the image's entry area (normally 0) if there is no previous\n    region.\n\nalign:\n    This sets the alignment of the entry. The entry offset is adjusted\n    so that the entry starts on an aligned boundary within the containing\n    section or image. For example 'align = <16>' means that the entry will\n    start on a 16-byte boundary. This may mean that padding is added before\n    the entry. The padding is part of the containing section but is not\n    included in the entry, meaning that an empty space may be created before\n    the entry starts. Alignment should be a power of 2. If 'align' is not\n    provided, no alignment is performed.\n\nsize:\n    This sets the size of the entry. The contents will be padded out to\n    this size. If this is not provided, it will be set to the size of the\n    contents.\n\nmin-size:\n    Sets the minimum size of the entry. This size includes explicit padding\n    ('pad-before' and 'pad-after'), but not padding added to meet alignment\n    requirements. While this does not affect the contents of the entry within\n    binman itself (the padding is performed only when its parent section is\n    assembled), the end result will be that the entry ends with the padding\n    bytes, so may grow. Defaults to 0.\n\npad-before:\n    Padding before the contents of the entry. Normally this is 0, meaning\n    that the contents start at the beginning of the entry. This can be used\n    to offset the entry contents a little. While this does not affect the\n    contents of the entry within binman itself (the padding is performed\n    only when its parent section is assembled), the end result will be that\n    the entry starts with the padding bytes, so may grow. Defaults to 0.\n\npad-after:\n    Padding after the contents of the entry. Normally this is 0, meaning\n    that the entry ends at the last byte of content (unless adjusted by\n    other properties). This allows room to be created in the image for\n    this entry to expand later. While this does not affect the contents of\n    the entry within binman itself (the padding is performed only when its\n    parent section is assembled), the end result will be that the entry ends\n    with the padding bytes, so may grow. Defaults to 0.\n\nalign-size:\n    This sets the alignment of the entry size. For example, to ensure\n    that the size of an entry is a multiple of 64 bytes, set this to 64.\n    While this does not affect the contents of the entry within binman\n    itself (the padding is performed only when its parent section is\n    assembled), the end result is that the entry ends with the padding\n    bytes, so may grow. If 'align-size' is not provided, no alignment is\n    performed.\n\nalign-end:\n    This sets the alignment of the end of an entry with respect to the\n    containing section. Some entries require that they end on an alignment\n    boundary, regardless of where they start. This does not move the start\n    of the entry, so the contents of the entry will still start at the\n    beginning. But there may be padding at the end. While this does not\n    affect the contents of the entry within binman itself (the padding is\n    performed only when its parent section is assembled), the end result\n    is that the entry ends with the padding bytes, so may grow.\n    If 'align-end' is not provided, no alignment is performed.\n\nfilename:\n    For 'blob' types this provides the filename containing the binary to\n    put into the entry. If binman knows about the entry type (like\n    u-boot-bin), then there is no need to specify this.\n\ntype:\n    Sets the type of an entry. This defaults to the entry name, but it is\n    possible to use any name, and then add (for example) 'type = \"u-boot\"'\n    to specify the type.\n\noffset-unset:\n    Indicates that the offset of this entry should not be set by placing\n    it immediately after the entry before. Instead, is set by another\n    entry which knows where this entry should go. When this boolean\n    property is present, binman will give an error if another entry does\n    not set the offset (with the GetOffsets() method).\n\nimage-pos:\n    This cannot be set on entry (or at least it is ignored if it is), but\n    with the -u option, binman will set it to the absolute image position\n    for each entry. This makes it easy to find out exactly where the entry\n    ended up in the image, regardless of parent sections, etc.\n\nextend-size:\n    Extend the size of this entry to fit available space. This space is only\n    limited by the size of the image/section and the position of the next\n    entry.\n\ncompress:\n    Sets the compression algortihm to use (for blobs only). See the entry\n    documentation for details.\n\nmissing-msg:\n    Sets the tag of the message to show if this entry is missing. This is\n    used for external blobs. When they are missing it is helpful to show\n    information about what needs to be fixed. See missing-blob-help for the\n    message for each tag.\n\nno-expanded:\n    By default binman substitutes entries with expanded versions if available,\n    so that a `u-boot` entry type turns into `u-boot-expanded`, for example. The\n    `--no-expanded` command-line option disables this globally. The\n    `no-expanded` property disables this just for a single entry. Put the\n    `no-expanded` boolean property in the node to select this behaviour.\n\noptional:\n    External blobs are normally required to be present for the image to be\n    built (but see `External blobs`_). This properly allows an entry to be\n    optional, so that when it is cannot be found, this problem is ignored and\n    an empty file is used for this blob. This should be used only when the blob\n    is entirely optional and is not needed for correct operation of the image.\n    Note that missing, optional blobs do not produce a non-zero exit code from\n    binman, although it does show a warning about the missing external blob.\n\nThe attributes supported for images and sections are described below. Several\nare similar to those for entries.\n\nsize:\n    Sets the image size in bytes, for example 'size = <0x100000>' for a\n    1MB image.\n\noffset:\n    This is similar to 'offset' in entries, setting the offset of a section\n    within the image or section containing it. The first byte of the section\n    is normally at offset 0. If 'offset' is not provided, binman sets it to\n    the end of the previous region, or the start of the image's entry area\n    (normally 0) if there is no previous region.\n\nalign-size:\n    This sets the alignment of the image size. For example, to ensure\n    that the image ends on a 512-byte boundary, use 'align-size = <512>'.\n    If 'align-size' is not provided, no alignment is performed.\n\npad-before:\n    This sets the padding before the image entries. The first entry will\n    be positioned after the padding. This defaults to 0.\n\npad-after:\n    This sets the padding after the image entries. The padding will be\n    placed after the last entry. This defaults to 0.\n\npad-byte:\n    This specifies the pad byte to use when padding in the image. It\n    defaults to 0. To use 0xff, you would add 'pad-byte = <0xff>'.\n\nfilename:\n    This specifies the image filename. It defaults to 'image.bin'.\n\nsort-by-offset:\n    This causes binman to reorder the entries as needed to make sure they\n    are in increasing positional order. This can be used when your entry\n    order may not match the positional order. A common situation is where\n    the 'offset' properties are set by CONFIG options, so their ordering is\n    not known a priori.\n\n    This is a boolean property so needs no value. To enable it, add a\n    line 'sort-by-offset;' to your description.\n\nmultiple-images:\n    Normally only a single image is generated. To create more than one\n    image, put this property in the binman node. For example, this will\n    create image1.bin containing u-boot.bin, and image2.bin containing\n    both spl/u-boot-spl.bin and u-boot.bin::\n\n        binman {\n            multiple-images;\n            image1 {\n                u-boot {\n                };\n            };\n\n            image2 {\n                spl {\n                };\n                u-boot {\n                };\n            };\n        };\n\nend-at-4gb:\n    For x86 machines the ROM offsets start just before 4GB and extend\n    up so that the image finished at the 4GB boundary. This boolean\n    option can be enabled to support this. The image size must be\n    provided so that binman knows when the image should start. For an\n    8MB ROM, the offset of the first entry would be 0xfff80000 with\n    this option, instead of 0 without this option.\n\nskip-at-start:\n    This property specifies the entry offset of the first entry.\n\n    For PowerPC mpc85xx based CPU, CONFIG_TEXT_BASE is the entry\n    offset of the first entry. It can be 0xeff40000 or 0xfff40000 for\n    nor flash boot, 0x201000 for sd boot etc.\n\n    'end-at-4gb' property is not applicable where CONFIG_TEXT_BASE +\n    Image size != 4gb.\n\nalign-default:\n    Specifies the default alignment for entries in this section, if they do\n    not specify an alignment. Note that this only applies to top-level entries\n    in the section (direct subentries), not any subentries of those entries.\n    This means that each section must specify its own default alignment, if\n    required.\n\nsymlink:\n    Adds a symlink to the image with string given in the symlink property.\n\noverlap:\n    Indicates that this entry overlaps with others in the same section. These\n    entries should appear at the end of the section. Overlapping entries are not\n    packed with other entries, but their contents are written over other entries\n    in the section. Overlapping entries must have an explicit offset and size.\n\nwrite-symbols:\n    Indicates that the blob should be updated with symbol values calculated by\n    binman. This is automatic for certain entry types, e.g. `u-boot-spl`. See\n    binman_syms_ for more information.\n\nelf-filename:\n    Sets the file name of a blob's associated ELF file. For example, if the\n    blob is `zephyr.bin` then the ELF file may be `zephyr.elf`. This allows\n    binman to locate symbols and understand the structure of the blob. See\n    binman_syms_ for more information.\n\nelf-base-sym:\n    Sets the name of the ELF symbol that points to the start of a blob. For\n    U-Boot this is `__image_copy_start` and that is the default used by binman\n    if this property is missing. For other projects, a difference symbol may be\n    needed. Add this symbol to the properties for the blob so that symbols can\n    be read correctly. See binman_syms_ for more information.\n\noffset-from-elf:\n    Sets the offset of an entry based on a symbol value in an another entry.\n    The format is <&phandle>, \"sym_name\", <offset> where phandle is the entry\n    containing the blob (with associated ELF file providing symbols), <sym_name>\n    is the symbol to lookup (relative to elf-base-sym) and <offset> is an offset\n    to add to that value.\n\nExamples of the above options can be found in the tests. See the\ntools/binman/test directory.\n\nIt is possible to have the same binary appear multiple times in the image,\neither by using a unit number suffix (u-boot@0, u-boot@1) or by using a\ndifferent name for each and specifying the type with the 'type' attribute.\n\n\nSections and hierachical images\n-------------------------------\n\nSometimes it is convenient to split an image into several pieces, each of which\ncontains its own set of binaries. An example is a flash device where part of\nthe image is read-only and part is read-write. We can set up sections for each\nof these, and place binaries in them independently. The image is still produced\nas a single output file.\n\nThis feature provides a way of creating hierarchical images. For example here\nis an example image with two copies of U-Boot. One is read-only (ro), intended\nto be written only in the factory. Another is read-write (rw), so that it can be\nupgraded in the field. The sizes are fixed so that the ro/rw boundary is known\nand can be programmed::\n\n    binman {\n        section@0 {\n            read-only;\n            name-prefix = \"ro-\";\n            size = <0x100000>;\n            u-boot {\n            };\n        };\n        section@1 {\n            name-prefix = \"rw-\";\n            size = <0x100000>;\n            u-boot {\n            };\n        };\n    };\n\nThis image could be placed into a SPI flash chip, with the protection boundary\nset at 1MB.\n\nA few special properties are provided for sections:\n\nread-only:\n    Indicates that this section is read-only. This has no impact on binman's\n    operation, but his property can be read at run time.\n\nname-prefix:\n    This string is prepended to all the names of the binaries in the\n    section. In the example above, the 'u-boot' binaries which actually be\n    renamed to 'ro-u-boot' and 'rw-u-boot'. This can be useful to\n    distinguish binaries with otherwise identical names.\n\nfilename:\n    This allows the contents of the section to be written to a file in the\n    output directory. This can sometimes be useful to use the data in one\n    section in different image, since there is currently no way to share data\n    beteen images other than through files.\n\nImage Properties\n----------------\n\nImage nodes act like sections but also have a few extra properties:\n\nfilename:\n    Output filename for the image. This defaults to image.bin (or in the\n    case of multiple images <nodename>.bin where <nodename> is the name of\n    the image node.\n\nallow-repack:\n    Create an image that can be repacked. With this option it is possible\n    to change anything in the image after it is created, including updating\n    the position and size of image components. By default this is not\n    permitted since it is not possibly to know whether this might violate a\n    constraint in the image description. For example, if a section has to\n    increase in size to hold a larger binary, that might cause the section\n    to fall out of its allow region (e.g. read-only portion of flash).\n\n    Adding this property causes the original offset and size values in the\n    image description to be stored in the FDT and fdtmap.\n\n\nImage dependencies\n------------------\n\nBinman does not currently support images that depend on each other. For example,\nif one image creates `fred.bin` and then the next uses this `fred.bin` to\nproduce a final `image.bin`, then the behaviour is undefined. It may work, or it\nmay produce an error about `fred.bin` being missing, or it may use a version of\n`fred.bin` from a previous run.\n\nOften this can be handled by incorporating the dependency into the second\nimage. For example, instead of::\n\n    binman {\n        multiple-images;\n\n        fred {\n            u-boot {\n            };\n            fill {\n                size = <0x100>;\n            };\n        };\n\n        image {\n            blob {\n                filename = \"fred.bin\";\n            };\n            u-boot-spl {\n            };\n        };\n\nyou can do this::\n\n    binman {\n        image {\n            fred {\n                type = \"section\";\n                u-boot {\n                };\n                fill {\n                    size = <0x100>;\n                };\n            };\n            u-boot-spl {\n            };\n        };\n\n\n\nHashing Entries\n---------------\n\nIt is possible to ask binman to hash the contents of an entry and write that\nvalue back to the device-tree node. For example::\n\n    binman {\n        u-boot {\n            hash {\n                algo = \"sha256\";\n            };\n        };\n    };\n\nHere, a new 'value' property will be written to the 'hash' node containing\nthe hash of the 'u-boot' entry. Only SHA256 is supported at present. Whole\nsections can be hased if desired, by adding the 'hash' node to the section.\n\nThe has value can be chcked at runtime by hashing the data actually read and\ncomparing this has to the value in the device tree.\n\n\nExpanded entries\n----------------\n\nBinman automatically replaces 'u-boot' with an expanded version of that, i.e.\n'u-boot-expanded'. This means that when you write::\n\n    u-boot {\n    };\n\nyou actually get::\n\n    u-boot {\n        type = \"u-boot-expanded';\n    };\n\nwhich in turn expands to::\n\n    u-boot {\n        type = \"section\";\n\n        u-boot-nodtb {\n        };\n\n        u-boot-dtb {\n        };\n    };\n\nU-Boot's various phase binaries actually comprise two or three pieces.\nFor example, u-boot.bin has the executable followed by a devicetree.\n\nWith binman we want to be able to update that devicetree with full image\ninformation so that it is accessible to the executable. This is tricky\nif it is not clear where the devicetree starts.\n\nThe above feature ensures that the devicetree is clearly separated from the\nU-Boot executable and can be updated separately by binman as needed. It can be\ndisabled with the --no-expanded flag if required.\n\nThe same applies for u-boot-spl and u-boot-tpl. In those cases, the expansion\nincludes the BSS padding, so for example::\n\n    spl {\n        type = \"u-boot-spl\"\n    };\n\nyou actually get::\n\n    spl {\n        type = \"u-boot-expanded';\n    };\n\nwhich in turn expands to::\n\n    spl {\n        type = \"section\";\n\n        u-boot-spl-nodtb {\n        };\n\n        u-boot-spl-bss-pad {\n        };\n\n        u-boot-spl-dtb {\n        };\n    };\n\nOf course we should not expand SPL if it has no devicetree. Also if the BSS\npadding is not needed (because BSS is in RAM as with CONFIG_SPL_SEPARATE_BSS),\nthe 'u-boot-spl-bss-pad' subnode should not be created. The use of the expaned\nentry type is controlled by the UseExpanded() method. In the SPL case it checks\nthe 'spl-dtb' entry arg, which is 'y' or '1' if SPL has a devicetree.\n\nFor the BSS case, a 'spl-bss-pad' entry arg controls whether it is present. All\nentry args are provided by the U-Boot Makefile.\n\n\nOptional entries\n----------------\n\nSome entries need to exist only if certain conditions are met. For example, an\nentry may want to appear in the image only if a file has a particular format.\nObviously the entry must exist in the image description for it to be processed\nat all, so a way needs to be found to have the entry remove itself.\n\nTo handle this, when entry.ObtainContents() is called, the entry can call\nentry.mark_absent() to mark itself as absent, passing a suitable message as the\nreason.\n\nAny absent entries are dropped immediately after ObtainContents() has been\ncalled on all entries.\n\nIt is not possible for an entry to mark itself absent at any other point in the\nprocessing. It must happen in the ObtainContents() method.\n\nThe effect is as if the entry had never been present at all, since the image\nis packed without it and it disappears from the list of entries.\n\n\nCompression\n-----------\n\nBinman support compression for 'blob' entries (those of type 'blob' and\nderivatives). To enable this for an entry, add a 'compress' property::\n\n    blob {\n        filename = \"datafile\";\n        compress = \"lz4\";\n    };\n\nThe entry will then contain the compressed data, using the 'lz4' compression\nalgorithm. Currently this is the only one that is supported. The uncompressed\nsize is written to the node in an 'uncomp-size' property, if -u is used.\n\nCompression is also supported for sections. In that case the entire section is\ncompressed in one block, including all its contents. This means that accessing\nan entry from the section required decompressing the entire section. Also, the\nsize of a section indicates the space that it consumes in its parent section\n(and typically the image). With compression, the section may contain more data,\nand the uncomp-size property indicates that, as above. The contents of the\nsection is compressed first, before any padding is added. This ensures that the\npadding itself is not compressed, which would be a waste of time.\n\n\nAutomatic .dtsi inclusion\n-------------------------\n\nIt is sometimes inconvenient to add a 'binman' node to the .dts file for each\nboard. This can be done by using #include to bring in a common file. Another\napproach supported by the U-Boot build system is to automatically include\na common header. You can then put the binman node (and anything else that is\nspecific to U-Boot, such as bootph-all properies) in that header file.\n\nBinman will search for the following files in arch/<arch>/dts::\n\n   <dts>-u-boot.dtsi where <dts> is the base name of the .dts file\n   <CONFIG_SYS_SOC>-u-boot.dtsi\n   <CONFIG_SYS_CPU>-u-boot.dtsi\n   <CONFIG_SYS_VENDOR>-u-boot.dtsi\n   u-boot.dtsi\n\nU-Boot will only use the first one that it finds. If you need to include a\nmore general file you can do that from the more specific file using #include.\nIf you are having trouble figuring out what is going on, you can use\n`DEVICE_TREE_DEBUG=1` with your build::\n\n   make DEVICE_TREE_DEBUG=1\n   scripts/Makefile.lib:334: Automatic .dtsi inclusion: options:\n     arch/arm/dts/juno-r2-u-boot.dtsi arch/arm/dts/-u-boot.dtsi\n     arch/arm/dts/armv8-u-boot.dtsi arch/arm/dts/armltd-u-boot.dtsi\n     arch/arm/dts/u-boot.dtsi ... found: \"arch/arm/dts/juno-r2-u-boot.dtsi\"\n\n\nUpdating an ELF file\n====================\n\nFor the EFI app, where U-Boot is loaded from UEFI and runs as an app, there is\nno way to update the devicetree after U-Boot is built. Normally this works by\ncreating a new u-boot.dtb.out with he updated devicetree, which is automatically\nbuilt into the output image. With ELF this is not possible since the ELF is\nnot part of an image, just a stand-along file. We must create an updated ELF\nfile with the new devicetree.\n\nThis is handled by the --update-fdt-in-elf option. It takes four arguments,\nseparated by comma:\n\n   infile     - filename of input ELF file, e.g. 'u-boot's\n   outfile    - filename of output ELF file, e.g. 'u-boot.out'\n   begin_sym - symbol at the start of the embedded devicetree, e.g.\n   '__dtb_dt_begin'\n   end_sym   - symbol at the start of the embedded devicetree, e.g.\n   '__dtb_dt_end'\n\nWhen this flag is used, U-Boot does all the normal packaging, but as an\nadditional step, it creates a new ELF file with the new devicetree embedded in\nit.\n\nIf logging is enabled you will see a message like this::\n\n   Updating file 'u-boot' with data length 0x400a (16394) between symbols\n   '__dtb_dt_begin' and '__dtb_dt_end'\n\nThere must be enough space for the updated devicetree. If not, an error like\nthe following is produced::\n\n   ValueError: Not enough space in 'u-boot' for data length 0x400a (16394);\n   size is 0x1744 (5956)\n\n\nEntry Documentation\n===================\n\nFor details on the various entry types supported by binman and how to use them,\nsee entries.rst which is generated from the source code using:\n\n    binman entry-docs >tools/binman/entries.rst\n\n   :maxdepth: 2\n\n   entries\n\n\nManaging images\n===============\n\nListing images\n--------------\n\nIt is possible to list the entries in an existing firmware image created by\nbinman, provided that there is an 'fdtmap' entry in the image. For example::\n\n    $ binman ls -i image.bin\n    Name              Image-pos  Size  Entry-type    Offset  Uncomp-size\n    ----------------------------------------------------------------------\n    main-section                  c00  section            0\n      u-boot                  0     4  u-boot             0\n      section                     5fc  section            4\n        cbfs                100   400  cbfs               0\n          u-boot            138     4  u-boot            38\n          u-boot-dtb        180   108  u-boot-dtb        80          3b5\n        u-boot-dtb          500   1ff  u-boot-dtb       400          3b5\n      fdtmap                6fc   381  fdtmap           6fc\n      image-header          bf8     8  image-header     bf8\n\nThis shows the hierarchy of the image, the position, size and type of each\nentry, the offset of each entry within its parent and the uncompressed size if\nthe entry is compressed.\n\nIt is also possible to list just some files in an image, e.g.::\n\n    $ binman ls -i image.bin section/cbfs\n    Name              Image-pos  Size  Entry-type  Offset  Uncomp-size\n    --------------------------------------------------------------------\n        cbfs                100   400  cbfs             0\n          u-boot            138     4  u-boot          38\n          u-boot-dtb        180   108  u-boot-dtb      80          3b5\n\nor with wildcards::\n\n    $ binman ls -i image.bin \"*cb*\" \"*head*\"\n    Name              Image-pos  Size  Entry-type    Offset  Uncomp-size\n    ----------------------------------------------------------------------\n        cbfs                100   400  cbfs               0\n          u-boot            138     4  u-boot            38\n          u-boot-dtb        180   108  u-boot-dtb        80          3b5\n      image-header          bf8     8  image-header     bf8\n\nIf an older version of binman is used to list images created by a newer one, it\nis possible that it will contain entry types that are not supported. These still\nshow with the correct type, but binman just sees them as blobs (plain binary\ndata). Any special features of that etype are not supported by the old binman.\n\n\nExtracting files from images\n----------------------------\n\nYou can extract files from an existing firmware image created by binman,\nprovided that there is an 'fdtmap' entry in the image. For example::\n\n    $ binman extract -i image.bin section/cbfs/u-boot\n\nwhich will write the uncompressed contents of that entry to the file 'u-boot' in\nthe current directory. You can also extract to a particular file, in this case\nu-boot.bin::\n\n    $ binman extract -i image.bin section/cbfs/u-boot -f u-boot.bin\n\nIt is possible to extract all files into a destination directory, which will\nput files in subdirectories matching the entry hierarchy::\n\n    $ binman extract -i image.bin -O outdir\n\nor just a selection::\n\n    $ binman extract -i image.bin \"*u-boot*\" -O outdir\n\nSome entry types have alternative formats, for example fdtmap which allows\nextracted just the devicetree binary without the fdtmap header::\n\n    $ binman extract -i /tmp/b/odroid-c4/image.bin -f out.dtb -F fdt fdtmap\n    $ fdtdump out.dtb\n    /dts-v1/;\n    // magic:               0xd00dfeed\n    // totalsize:           0x8ab (2219)\n    // off_dt_struct:       0x38\n    // off_dt_strings:      0x82c\n    // off_mem_rsvmap:      0x28\n    // version:             17\n    // last_comp_version:   2\n    // boot_cpuid_phys:     0x0\n    // size_dt_strings:     0x7f\n    // size_dt_struct:      0x7f4\n\n    / {\n        image-node = \"binman\";\n        image-pos = <0x00000000>;\n        size = <0x0011162b>;\n        ...\n\nUse `-F list` to see what alternative formats are available::\n\n    $ binman extract -i /tmp/b/odroid-c4/image.bin -F list\n    Flag (-F)   Entry type            Description\n    fdt         fdtmap                Extract the devicetree blob from the fdtmap\n\n\nReplacing files in an image\n---------------------------\n\nYou can replace files in an existing firmware image created by binman, provided\nthat there is an 'fdtmap' entry in the image. For example::\n\n    $ binman replace -i image.bin section/cbfs/u-boot\n\nwhich will write the contents of the file 'u-boot' from the current directory\nto the that entry, compressing if necessary. If the entry size changes, you must\nadd the 'allow-repack' property to the original image before generating it (see\nabove), otherwise you will get an error.\n\nYou can also use a particular file, in this case u-boot.bin::\n\n    $ binman replace -i image.bin section/cbfs/u-boot -f u-boot.bin\n\nIt is possible to replace all files from a source directory which uses the same\nhierarchy as the entries::\n\n    $ binman replace -i image.bin -I indir\n\nFiles that are missing will generate a warning.\n\nYou can also replace just a selection of entries::\n\n    $ binman replace -i image.bin \"*u-boot*\" -I indir\n\n\n.. _`BinmanLogging`:\n\nLogging\n-------\n\nBinman normally operates silently unless there is an error, in which case it\njust displays the error. The -D/--debug option can be used to create a full\nbacktrace when errors occur. You can use BINMAN_DEBUG=1 when building to select\nthis.\n\nInternally binman logs some output while it is running. This can be displayed\nby increasing the -v/--verbosity from the default of 1:\n\n   0: silent\n   1: warnings only\n   2: notices (important messages)\n   3: info about major operations\n   4: detailed information about each operation\n   5: debug (all output)\n\nYou can use BINMAN_VERBOSE=5 (for example) when building to select this.\n\n\nBintools\n========\n\n`Bintool` is the name binman gives to a binary tool which it uses to create and\nmanipulate binaries that binman cannot handle itself. Bintools are often\nnecessary since Binman only supports a subset of the available file formats\nnatively.\n\nMany SoC vendors invent ways to load code into their SoC using new file formats,\nsometimes changing the format with successive SoC generations. Sometimes the\ntool is available as Open Source. Sometimes it is a pre-compiled binary that\nmust be downloaded from the vendor's website. Sometimes it is available in\nsource form but difficult or slow to build.\n\nEven for images that use bintools, binman still assembles the image from its\nimage description. It may handle parts of the image natively and part with\nvarious bintools.\n\nBinman relies on these tools so provides various features to manage them:\n\n- Determining whether the tool is currently installed\n- Downloading or building the tool\n- Determining the version of the tool that is installed\n- Deciding which tools are needed to build an image\n\nThe Bintool class is an interface to the tool, a thin level of abstration, using\nPython functions to run the tool for each purpose (e.g. creating a new\nstructure, adding a file to an existing structure) rather than just lists of\nstring arguments.\n\nAs with external blobs, bintools (which are like 'external' tools) can be\nmissing. When building an image requires a bintool and it is not installed,\nbinman detects this and reports the problem, but continues to build an image.\nThis is useful in CI systems which want to check that everything is correct but\ndon't have access to the bintools.\n\nTo make this work, all calls to bintools (e.g. with Bintool.run_cmd()) must cope\nwith the tool being missing, i.e. when None is returned, by:\n\n- Calling self.record_missing_bintool()\n- Setting up some fake contents so binman can continue\n\nOf course the image will not work, but binman reports which bintools are needed\nand also provide a way to fetch them.\n\nTo see the available bintools, use::\n\n    binman tool --list\n\nTo fetch tools which are missing, use::\n\n    binman tool --fetch missing\n\nYou can also use `--fetch all` to fetch all tools or `--fetch <tool>` to fetch\na particular tool. Some tools are built from source code, in which case you will\nneed to have at least the `build-essential` and `git` packages installed.\n\nBintool Documentation\n=====================\n\nTo provide details on the various bintools supported by binman, bintools.rst is\ngenerated from the source code using:\n\n    binman bintool-docs >tools/binman/bintools.rst\n\n   :maxdepth: 2\n\n   bintools\n\nBinman commands and arguments\n=============================\n\nUsage::\n\n    binman [-h] [-B BUILD_DIR] [-D] [-H] [--toolpath TOOLPATH] [-T THREADS]\n        [--test-section-timeout] [-v VERBOSITY] [-V]\n        {build,bintool-docs,entry-docs,ls,extract,replace,test,tool} ...\n\nBinman provides the following commands:\n\n- **build** - build images\n- **bintools-docs** - generate documentation about bintools\n- **entry-docs** - generate documentation about entry types\n- **ls** - list an image\n- **extract** - extract files from an image\n- **replace** - replace one or more entries in an image\n- **test** - run tests\n- **tool** - manage bintools\n\nOptions:\n\n-h, --help\n    Show help message and exit\n\n-B BUILD_DIR, --build-dir BUILD_DIR\n    Directory containing the build output\n\n-D, --debug\n    Enabling debugging (provides a full traceback on error)\n\n-H, --full-help\n    Display the README file\n\n--toolpath TOOLPATH\n    Add a path to the directories containing tools\n\n-T THREADS, --threads THREADS\n    Number of threads to use (0=single-thread). Note that -T0 is useful for\n    debugging since everything runs in one thread.\n\n-v VERBOSITY, --verbosity VERBOSITY\n    Control verbosity: 0=silent, 1=warnings, 2=notices, 3=info, 4=detail,\n    5=debug\n\n-V, --version\n    Show the binman version\n\nTest options:\n\n--test-section-timeout\n    Use a zero timeout for section multi-threading (for testing)\n\nCommands are described below.\n\nbinman build\n------------\n\nThis builds one or more images using the provided image description.\n\nUsage::\n\n    binman build [-h] [-a ENTRY_ARG] [-b BOARD] [-d DT] [--fake-dtb]\n        [--fake-ext-blobs] [--force-missing-bintools FORCE_MISSING_BINTOOLS]\n        [-i IMAGE] [-I INDIR] [-m] [-M] [-n] [-O OUTDIR] [-p] [-u]\n        [--update-fdt-in-elf UPDATE_FDT_IN_ELF] [-W]\n\nOptions:\n\n-h, --help\n    Show help message and exit\n\n-a ENTRY_ARG, --entry-arg ENTRY_ARG\n    Set argument value `arg=value`. See\n    `Passing command-line arguments to entries`_.\n\n-b BOARD, --board BOARD\n    Board name to build. This can be used instead of `-d`, in which case the\n    file `u-boot.dtb` is used, within the build directory's board subdirectory.\n\n-d DT, --dt DT\n    Configuration file (.dtb) to use. This must have a top-level node called\n    `binman`. See `Image description format`_.\n\n-i IMAGE, --image IMAGE\n    Image filename to build (if not specified, build all)\n\n-I INDIR, --indir INDIR\n    Add a path to the list of directories to use for input files. This can be\n    specified multiple times to add more than one path.\n\n-m, --map\n    Output a map file for each image. See `Map files`_.\n\n-M, --allow-missing\n    Allow external blobs and bintools to be missing. See `External blobs`_.\n\n-n, --no-expanded\n    Don't use 'expanded' versions of entries where available; normally 'u-boot'\n    becomes 'u-boot-expanded', for example. See `Expanded entries`_.\n\n-O OUTDIR, --outdir OUTDIR\n    Path to directory to use for intermediate and output files\n\n-p, --preserve\n    Preserve temporary output directory even if option -O is not given\n\n-u, --update-fdt\n    Update the binman node with offset/size info. See\n    `Access to binman entry offsets at run time (fdt)`_.\n\n--update-fdt-in-elf UPDATE_FDT_IN_ELF\n    Update an ELF file with the output dtb. The argument is a string consisting\n    of four parts, separated by commas. See `Updating an ELF file`_.\n\n-W, --ignore-missing\n    Return success even if there are missing blobs/bintools (requires -M)\n\nOptions used only for testing:\n\n--fake-dtb\n    Use fake device tree contents\n\n--fake-ext-blobs\n    Create fake ext blobs with dummy content\n\n--force-missing-bintools FORCE_MISSING_BINTOOLS\n    Comma-separated list of bintools to consider missing\n\nbinman bintool-docs\n-------------------\n\nUsage::\n\n    binman bintool-docs [-h]\n\nThis outputs documentation for the bintools in rST format. See\n`Bintool Documentation`_.\n\nbinman entry-docs\n-----------------\n\nUsage::\n\n    binman entry-docs [-h]\n\nThis outputs documentation for the entry types in rST format. See\n`Entry Documentation`_.\n\nbinman ls\n---------\n\nUsage::\n\n    binman ls [-h] -i IMAGE [paths ...]\n\nPositional arguments:\n\npaths\n    Paths within file to list (wildcard)\n\nPptions:\n\n-h, --help\n    show help message and exit\n\n-i IMAGE, --image IMAGE\n    Image filename to list\n\nThis lists an image, showing its contents. See `Listing images`_.\n\nbinman extract\n--------------\n\nUsage::\n\n    binman extract [-h] [-F FORMAT] -i IMAGE [-f FILENAME] [-O OUTDIR] [-U]\n        [paths ...]\n\nPositional arguments:\n\nPaths\n    Paths within file to extract (wildcard)\n\nOptions:\n\n-h, --help\n    show help message and exit\n\n-F FORMAT, --format FORMAT\n    Select an alternative format for extracted data\n\n-i IMAGE, --image IMAGE\n    Image filename to extract\n\n-f FILENAME, --filename FILENAME\n    Output filename to write to\n\n-O OUTDIR, --outdir OUTDIR\n    Path to directory to use for output files\n\n-U, --uncompressed\n    Output raw uncompressed data for compressed entries\n\nThis extracts the contents of entries from an image. See\n`Extracting files from images`_.\n\nbinman replace\n--------------\n\nUsage::\n\n    binman replace [-h] [-C] -i IMAGE [-f FILENAME] [-F] [-I INDIR] [-m]\n        [paths ...]\n\nPositional arguments:\n\npaths\n    Paths within file to replace (wildcard)\n\nOptions:\n\n-h, --help\n    show help message and exit\n\n-C, --compressed\n    Input data is already compressed if needed for the entry\n\n-i IMAGE, --image IMAGE\n    Image filename to update\n\n-f FILENAME, --filename FILENAME\n    Input filename to read from\n\n-F, --fix-size\n    Don't allow entries to be resized\n\n-I INDIR, --indir INDIR\n    Path to directory to use for input files\n\n-m, --map\n    Output a map file for the updated image\n\nThis replaces one or more entries in an existing image. See\n`Replacing files in an image`_.\n\nbinman test\n-----------\n\nUsage::\n\n    binman test [-h] [-P PROCESSES] [-T] [-X] [tests ...]\n\nPositional arguments:\n\ntests\n    Test names to run (omit for all)\n\nOptions:\n\n-h, --help\n    show help message and exit\n\n-P PROCESSES, --processes PROCESSES\n    set number of processes to use for running tests. This defaults to the\n    number of CPUs on the machine\n\n-T, --test-coverage\n    run tests and check for 100% coverage\n\n-X, --test-preserve-dirs\n    Preserve and display test-created input directories; also preserve the\n    output directory if a single test is run (pass test name at the end of the\n    command line\n\nbinman tool\n-----------\n\nUsage::\n\n    binman tool [-h] [-l] [-f] [bintools ...]\n\nPositional arguments:\n\nbintools\n    Bintools to process\n\nOptions:\n\n-h, --help\n    show help message and exit\n\n-l, --list\n    List all known bintools\n\n-f, --fetch\n    Fetch a bintool from a known location. Use `all` to fetch all and `missing`\n    to fetch any missing tools.\n\n\nTechnical details\n=================\n\nOrder of image creation\n-----------------------\n\nImage creation proceeds in the following order, for each entry in the image.\n\n1. AddMissingProperties() - binman can add calculated values to the device\ntree as part of its processing, for example the offset and size of each\nentry. This method adds any properties associated with this, expanding the\ndevice tree as needed. These properties can have placeholder values which are\nset later by SetCalculatedProperties(). By that stage the size of sections\ncannot be changed (since it would cause the images to need to be repacked),\nbut the correct values can be inserted.\n\n2. ProcessFdt() - process the device tree information as required by the\nparticular entry. This may involve adding or deleting properties. If the\nprocessing is complete, this method should return True. If the processing\ncannot complete because it needs the ProcessFdt() method of another entry to\nrun first, this method should return False, in which case it will be called\nagain later.\n\n3. GetEntryContents() - the contents of each entry are obtained, normally by\nreading from a file. This calls the Entry.ObtainContents() to read the\ncontents. The default version of Entry.ObtainContents() calls\nEntry.GetDefaultFilename() and then reads that file. So a common mechanism\nto select a file to read is to override that function in the subclass. The\nfunctions must return True when they have read the contents. Binman will\nretry calling the functions a few times if False is returned, allowing\ndependencies between the contents of different entries.\n\n4. GetEntryOffsets() - calls Entry.GetOffsets() for each entry. This can\nreturn a dict containing entries that need updating. The key should be the\nentry name and the value is a tuple (offset, size). This allows an entry to\nprovide the offset and size for other entries. The default implementation\nof GetEntryOffsets() returns {}.\n\n5. PackEntries() - calls Entry.Pack() which figures out the offset and\nsize of an entry. The 'current' image offset is passed in, and the function\nreturns the offset immediately after the entry being packed. The default\nimplementation of Pack() is usually sufficient.\n\nNote: for sections, this also checks that the entries do not overlap, nor extend\noutside the section. If the section does not have a defined size, the size is\nset large enough to hold all the entries. For entries that are explicitly marked\nas overlapping, this check is skipped.\n\n6. SetImagePos() - sets the image position of every entry. This is the absolute\nposition 'image-pos', as opposed to 'offset' which is relative to the containing\nsection. This must be done after all offsets are known, which is why it is quite\nlate in the ordering.\n\n7. SetCalculatedProperties() - update any calculated properties in the device\ntree. This sets the correct 'offset' and 'size' vaues, for example.\n\n8. ProcessEntryContents() - this calls Entry.ProcessContents() on each entry.\nThe default implementatoin does nothing. This can be overriden to adjust the\ncontents of an entry in some way. For example, it would be possible to create\nan entry containing a hash of the contents of some other entries. At this\nstage the offset and size of entries should not be adjusted unless absolutely\nnecessary, since it requires a repack (going back to PackEntries()).\n\n9. ResetForPack() - if the ProcessEntryContents() step failed, in that an entry\nhas changed its size, then there is no alternative but to go back to step 5 and\ntry again, repacking the entries with the updated size. ResetForPack() removes\nthe fixed offset/size values added by binman, so that the packing can start from\nscratch.\n\n10. WriteSymbols() - write the value of symbols into the U-Boot SPL binary.\nSee 'Access to binman entry offsets at run time' below for a description of\nwhat happens in this stage.\n\n11. BuildImage() - builds the image and writes it to a file\n\n12. WriteMap() - writes a text file containing a map of the image. This is the\nfinal step.\n\n\n.. _`External tools`:\n\nExternal tools\n--------------\n\nBinman can make use of external command-line tools to handle processing of\nentry contents or to generate entry contents. These tools are executed using\nthe 'tools' module's Run() method. The tools generally must exist on the PATH,\nbut the --toolpath option can be used to specify additional search paths to\nuse. This option can be specified multiple times to add more than one path.\n\nFor some compile tools binman will use the versions specified by commonly-used\nenvironment variables like CC and HOSTCC for the C compiler, based on whether\nthe tool's output will be used for the target or for the host machine. If those\naren't given, it will also try to derive target-specific versions from the\nCROSS_COMPILE environment variable during a cross-compilation.\n\nIf the tool is not available in the path you can use BINMAN_TOOLPATHS to specify\na space-separated list of paths to search, e.g.::\n\n   BINMAN_TOOLPATHS=\"/tools/g12a /tools/tegra\" binman ...\n\n\n.. _`External blobs`:\n\nExternal blobs\n--------------\n\nBinary blobs, even if the source code is available, complicate building\nfirmware. The instructions can involve multiple steps and the binaries may be\nhard to build or obtain. Binman at least provides a unified description of how\nto build the final image, no matter what steps are needed to get there.\n\nBinman also provides a `blob-ext` entry type that pulls in a binary blob from an\nexternal file. If the file is missing, binman can optionally complete the build\nand just report a warning. Use the `-M/--allow-missing` option to enble this.\nThis is useful in CI systems which want to check that everything is correct but\ndon't have access to the blobs.\n\nIf the blobs are in a different directory, you can specify this with the `-I`\noption.\n\nFor U-Boot, you can use set the BINMAN_INDIRS environment variable to provide a\nspace-separated list of directories to search for binary blobs::\n\n   BINMAN_INDIRS=\"odroid-c4/fip/g12a \\\n       odroid-c4/build/board/hardkernel/odroidc4/firmware \\\n       odroid-c4/build/scp_task\" binman ...\n\nNote that binman fails with exit code 103 when there are missing blobs. If you\nwish binman to continue anyway, you can pass `-W` to binman.\n\n\nCode coverage\n-------------\n\nBinman is a critical tool and is designed to be very testable. Entry\nimplementations target 100% test coverage. Run 'binman test -T' to check this.\n\nTo enable Python test coverage on Debian-type distributions (e.g. Ubuntu)::\n\n   $ sudo apt-get install python-coverage python3-coverage python-pytest\n\n\nExit status\n-----------\n\nBinman produces the following exit codes:\n\n0\n    Success\n\n1\n    Any sort of failure - see output for more details\n\n103\n    There are missing external blobs or bintools. This is only returned if\n    -M is passed to binman, otherwise missing blobs return an exit status of 1.\n    Note, if -W is passed as well as -M, then this is converted into a warning\n    and will return an exit status of 0 instead.\n\n\nU-Boot environment variables for binman\n---------------------------------------\n\nThe U-Boot Makefile supports various environment variables to control binman.\nAll of these are set within the Makefile and result in passing various\nenvironment variables (or make flags) to binman:\n\nBINMAN_DEBUG\n    Enables backtrace debugging by adding a `-D` argument. See\n    .\n\nBINMAN_INDIRS\n    Sets the search path for input files used by binman by adding one or more\n    `-I` arguments. See .\n\nBINMAN_TOOLPATHS\n    Sets the search path for external tool used by binman by adding one or more\n    `--toolpath` arguments. See .\n\nBINMAN_VERBOSE\n    Sets the logging verbosity of binman by adding a `-v` argument. See\n    .\n\n\nError messages\n--------------\n\nThis section provides some guidance for some of the less obvious error messages\nproduced by binman.\n\n\nExpected __bss_size symbol\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n   binman: Node '/binman/u-boot-spl-ddr/u-boot-spl/u-boot-spl-bss-pad':\n      Expected __bss_size symbol in spl/u-boot-spl\n\nThis indicates that binman needs the `__bss_size` symbol to be defined in the\nSPL binary, where `spl/u-boot-spl` is the ELF file containing the symbols. The\nsymbol tells binman the size of the BSS region, in bytes. It needs this to be\nable to pad the image so that the following entries do not overlap the BSS,\nwhich would cause them to be overwritte by variable access in SPL.\n\nThis symbols is normally defined in the linker script, immediately after\n_bss_start and __bss_end are defined, like this::\n\n    __bss_size = __bss_end - __bss_start;\n\nYou may need to add it to your linker script if you get this error.\n\n\nConcurrent tests\n----------------\n\nBinman tries to run tests concurrently. This means that the tests make use of\nall available CPUs to run.\n\n To enable this::\n\n   $ sudo apt-get install python-subunit python3-subunit\n\nUse '-P 1' to disable this. It is automatically disabled when code coverage is\nbeing used (-T) since they are incompatible.\n\n\nDebugging tests\n---------------\n\nSometimes when debugging tests it is useful to keep the input and output\ndirectories so they can be examined later. Use -X or --test-preserve-dirs for\nthis.\n\n\nRunning tests on non-x86 architectures\n--------------------------------------\n\nBinman's tests have been written under the assumption that they'll be run on a\nx86-like host and there hasn't been an attempt to make them portable yet.\nHowever, it's possible to run the tests by cross-compiling to x86.\n\nTo install an x86 cross-compiler on Debian-type distributions (e.g. Ubuntu)::\n\n  $ sudo apt-get install gcc-x86-64-linux-gnu\n\nThen, you can run the tests under cross-compilation::\n\n  $ CROSS_COMPILE=x86_64-linux-gnu- binman test -T\n\nYou can also use gcc-i686-linux-gnu similar to the above.\n\n\nWriting new entries and debugging\n---------------------------------\n\nThe behaviour of entries is defined by the Entry class. All other entries are\na subclass of this. An important subclass is Entry_blob which takes binary\ndata from a file and places it in the entry. In fact most entry types are\nsubclasses of Entry_blob.\n\nEach entry type is a separate file in the tools/binman/etype directory. Each\nfile contains a class called Entry_<type> where <type> is the entry type.\nNew entry types can be supported by adding new files in that directory.\nThese will automatically be detected by binman when needed.\n\nEntry properties are documented in entry.py. The entry subclasses are free\nto change the values of properties to support special behaviour. For example,\nwhen Entry_blob loads a file, it sets content_size to the size of the file.\nEntry classes can adjust other entries. For example, an entry that knows\nwhere other entries should be positioned can set up those entries' offsets\nso they don't need to be set in the binman decription. It can also adjust\nentry contents.\n\nMost of the time such essoteric behaviour is not needed, but it can be\nessential for complex images.\n\nIf you need to specify a particular device-tree compiler to use, you can define\nthe DTC environment variable. This can be useful when the system dtc is too\nold.\n\nTo enable a full backtrace and other debugging features in binman, pass\nBINMAN_DEBUG=1 to your build::\n\n   make qemu-x86_defconfig\n   make BINMAN_DEBUG=1\n\nTo enable verbose logging from binman, base BINMAN_VERBOSE to your build, which\nadds a -v<level> option to the call to binman::\n\n   make qemu-x86_defconfig\n   make BINMAN_VERBOSE=5\n\n\nBuilding sections in parallel\n-----------------------------\n\nBy default binman uses multiprocessing to speed up compilation of large images.\nThis works at a section level, with one thread for each entry in the section.\nThis can speed things up if the entries are large and use compression.\n\nThis feature can be disabled with the '-T' flag, which defaults to a suitable\nvalue for your machine. This depends on the Python version, e.g on v3.8 it uses\n12 threads on an 8-core machine. See ConcurrentFutures_ for more details.\n\nThe special value -T0 selects single-threaded mode, useful for debugging during\ndevelopment, since dealing with exceptions and problems in threads is more\ndifficult. This avoids any use of ThreadPoolExecutor.\n\n\nCollecting data for an entry type\n---------------------------------\n\nSome entry types deal with data obtained from others. For example,\n`Entry_mkimage` calls the `mkimage` tool with data from its subnodes::\n\n    mkimage {\n        args = \"-n test -T script\";\n\n        u-boot-spl {\n        };\n\n        u-boot {\n        };\n    };\n\nThis shows mkimage being passed a file consisting of SPL and U-Boot proper. It\nis created by calling `Entry.collect_contents_to_file()`. Note that in this\ncase, the data is passed to mkimage for processing but does not appear\nseparately in the image. It may not appear at all, depending on what mkimage\ndoes. The contents of the `mkimage` entry are entirely dependent on the\nprocessing done by the entry, with the provided subnodes (`u-boot-spl` and\n`u-boot`) simply providing the input data for that processing.\n\nNote that `Entry.collect_contents_to_file()` simply concatenates the data from\nthe different entries together, with no control over alignment, etc. Another\napproach is to subclass `Entry_section` so that those features become available,\nsuch as `size` and `pad-byte`. Then the contents of the entry can be obtained by\ncalling `super().BuildSectionData()` in the entry's BuildSectionData()\nimplementation to get the input data, then write it to a file and process it\nhowever is desired.\n\nThere are other ways to obtain data also, depending on the situation. If the\nentry type is simply signing data which exists elsewhere in the image, then\nyou can use `Entry_collection`  as a base class. It lets you use a property\ncalled `content` which lists the entries containing data to be processed. This\nis used by `Entry_vblock`, for example::\n\n    u_boot: u-boot {\n    };\n\n    vblock {\n        content = <&u_boot &dtb>;\n        keyblock = \"firmware.keyblock\";\n        signprivate = \"firmware_data_key.vbprivk\";\n        version = <1>;\n        kernelkey = \"kernel_subkey.vbpubk\";\n        preamble-flags = <1>;\n    };\n\n    dtb: u-boot-dtb {\n    };\n\nwhich shows an image containing `u-boot` and `u-boot-dtb`, with the `vblock`\nimage collecting their contents to produce input for its signing process,\nwithout affecting those entries, which still appear in the final image\nuntouched.\n\nAnother example is where an entry type needs several independent pieces of input\nto function. For example, `Entry_fip` allows a number of different binary blobs\nto be placed in their own individual places in a custom data structure in the\noutput image. To make that work you can add subnodes for each of them and call\n`Entry.Create()` on each subnode, as `Entry_fip` does. Then the data for each\nblob can come from any suitable place, such as an `Entry_u_boot` or an\n`Entry_blob` or anything else::\n\n    atf-fip {\n        fip-hdr-flags = /bits/ 64 <0x123>;\n        soc-fw {\n            fip-flags = /bits/ 64 <0x123456789abcdef>;\n            filename = \"bl31.bin\";\n        };\n\n        u-boot {\n            fip-uuid = [fc 65 13 92 4a 5b 11 ec\n                    94 35 ff 2d 1c fc 79 9c];\n        };\n    };\n\nThe `soc-fw` node is a `blob-ext` (i.e. it reads in a named binary file) whereas\n`u-boot` is a normal entry type. This works because `Entry_fip` selects the\n`blob-ext` entry type if the node name (here `soc-fw`) is recognised as being\na known blob type.\n\nWhen adding new entry types you are encouraged to use subnodes to provide the\ndata for processing, unless the `content` approach is more suitable. Consider\nwhether the input entries are contained within (or consumed by) the entry, vs\njust being 'referenced' by the entry. In the latter case, the `content` approach\nmakes more sense. Ad-hoc properties and other methods of obtaining data are\ndiscouraged, since it adds to confusion for users.\n\nHistory / Credits\n-----------------\n\nBinman takes a lot of inspiration from a Chrome OS tool called\n'cros_bundle_firmware', which I wrote some years ago. That tool was based on\na reasonably simple and sound design but has expanded greatly over the\nyears. In particular its handling of x86 images is convoluted.\n\nQuite a few lessons have been learned which are hopefully applied here.\n\n\nDesign notes\n------------\n\nOn the face of it, a tool to create firmware images should be fairly simple:\njust find all the input binaries and place them at the right place in the\nimage. The difficulty comes from the wide variety of input types (simple\nflat binaries containing code, packaged data with various headers), packing\nrequirments (alignment, spacing, device boundaries) and other required\nfeatures such as hierarchical images.\n\nThe design challenge is to make it easy to create simple images, while\nallowing the more complex cases to be supported. For example, for most\nimages we don't much care exactly where each binary ends up, so we should\nnot have to specify that unnecessarily.\n\nNew entry types should aim to provide simple usage where possible. If new\ncore features are needed, they can be added in the Entry base class.\n\n\nTo do\n-----\n\nSome ideas:\n\n- Use of-platdata to make the information available to code that is unable\n  to use device tree (such as a very small SPL image). For now, limited info is\n  available via linker symbols\n- Allow easy building of images by specifying just the board name\n- Support building an image for a board (-b) more completely, with a\n  configurable build directory\n- Detect invalid properties in nodes\n- Sort the fdtmap by offset\n- Output temporary files to a different directory\n- Rationalise the fdt, fdt_util and pylibfdt modules which currently have some\n  overlapping and confusing functionality\n- Update the fdt library to use a better format for Prop.value (the current one\n  is useful for dtoc but not much else)\n- Figure out how to make Fdt support changing the node order, so that\n  Node.AddSubnode() can support adding a node before another, existing node.\n  Perhaps it should completely regenerate the flat tree?\n- Support images which depend on each other\n\n--\nSimon Glass <sjg@chromium.org>\n7/7/2016\n\n.. _ConcurrentFutures: https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "binary-manager",
    "package_url": "https://pypi.org/project/binary-manager/",
    "platform": null,
    "project_url": "https://pypi.org/project/binary-manager/",
    "project_urls": {
      "Bug Tracker": "https://source.denx.de/groups/u-boot/-/issues",
      "Homepage": "https://u-boot.readthedocs.io/en/latest/develop/package/index.html"
    },
    "release_url": "https://pypi.org/project/binary-manager/0.0.2/",
    "requires_dist": [
      "pylibfdt",
      "u-boot-pylib",
      "dtoc"
    ],
    "requires_python": ">=3.7",
    "summary": "Binman firmware-packaging tool",
    "version": "0.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16995137,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "de94376185ec3e9fd8d5bd5f3489b6cde58b18bf0c22305be496e4ddc46657f9",
          "md5": "5f97ebef05f820c2f0e9a0139d1f669d",
          "sha256": "93751ac3d1d5eaa7832aaad192bb3b05848160da5866270b14856e449737fa07"
        },
        "downloads": -1,
        "filename": "binary_manager-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5f97ebef05f820c2f0e9a0139d1f669d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 218139,
        "upload_time": "2023-02-23T15:45:43",
        "upload_time_iso_8601": "2023-02-23T15:45:43.867705Z",
        "url": "https://files.pythonhosted.org/packages/de/94/376185ec3e9fd8d5bd5f3489b6cde58b18bf0c22305be496e4ddc46657f9/binary_manager-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2b70d9b2203bf25279afe9afc82a762de7074ae26b816804be68569a68360e4f",
          "md5": "b79dde3202c263c27dfb4f44f46b7507",
          "sha256": "7ae9356e66ca140b1c713894a46bfc20cb7f2025a64704941095a218a0313c02"
        },
        "downloads": -1,
        "filename": "binary-manager-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "b79dde3202c263c27dfb4f44f46b7507",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 209663,
        "upload_time": "2023-02-23T15:45:46",
        "upload_time_iso_8601": "2023-02-23T15:45:46.650690Z",
        "url": "https://files.pythonhosted.org/packages/2b/70/d9b2203bf25279afe9afc82a762de7074ae26b816804be68569a68360e4f/binary-manager-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "de94376185ec3e9fd8d5bd5f3489b6cde58b18bf0c22305be496e4ddc46657f9",
        "md5": "5f97ebef05f820c2f0e9a0139d1f669d",
        "sha256": "93751ac3d1d5eaa7832aaad192bb3b05848160da5866270b14856e449737fa07"
      },
      "downloads": -1,
      "filename": "binary_manager-0.0.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "5f97ebef05f820c2f0e9a0139d1f669d",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 218139,
      "upload_time": "2023-02-23T15:45:43",
      "upload_time_iso_8601": "2023-02-23T15:45:43.867705Z",
      "url": "https://files.pythonhosted.org/packages/de/94/376185ec3e9fd8d5bd5f3489b6cde58b18bf0c22305be496e4ddc46657f9/binary_manager-0.0.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2b70d9b2203bf25279afe9afc82a762de7074ae26b816804be68569a68360e4f",
        "md5": "b79dde3202c263c27dfb4f44f46b7507",
        "sha256": "7ae9356e66ca140b1c713894a46bfc20cb7f2025a64704941095a218a0313c02"
      },
      "downloads": -1,
      "filename": "binary-manager-0.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "b79dde3202c263c27dfb4f44f46b7507",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 209663,
      "upload_time": "2023-02-23T15:45:46",
      "upload_time_iso_8601": "2023-02-23T15:45:46.650690Z",
      "url": "https://files.pythonhosted.org/packages/2b/70/d9b2203bf25279afe9afc82a762de7074ae26b816804be68569a68360e4f/binary-manager-0.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}