{
  "info": {
    "author": "OtoSense",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# recode\nMake codecs for fixed size structured chunks serialization and deserialization of\nsequences, tabular data, and time-series.\n\nTo install:\t```pip install recode```\n\n[Docs here](https://otosense.github.io/recode/module_docs/recode.html)\n\nMake codecs for fixed size structured chunks serialization and deserialization of\nsequences, tabular data, and time-series.\n\nThe easiest and bigest bang for your buck is ``mk_codec``\n\n```python\n>>> from recode import mk_codec\n>>> encoder, decoder = mk_codec()\n```\n\n``encoder`` will encode a list (or any iterable) of numbers into bytes\n\n```python\n>>> b = encoder([0, -3, 3.14])\n>>> b\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xc0\\x1f\\x85\\xebQ\\xb8\\x1e\\t@'\n\n```\n\n``decoder`` will decode those bytes to get you back your numbers\n\n```python\n>>> decoder(b)\n[0.0, -3.0, 3.14]\n```\n\nThere's only really one argument you need to know about in ``mk_codec``.\nThe first argument, called `chk_format`, which is a string of characters from\nthe \"Format\" column of the python \n[format characters](https://docs.python.org/3/library/struct.html#format-characters)\n\nThe length of the string specifies the number of \"channels\",\nand each individual character of the string specifies the kind of encoding you should\napply to each \"channel\" (hold your horses, we'll explain).\n\nThe one we've just been through is in fact\n\n```python\n>>> encoder, decoder = mk_codec('d')\n```\n\nThat is, it will expect that your data is a list of numbers, and they'll be encoded\nwith the 'd' format character, that is 8-bytes doubles.\nThat default is goo because it gives you a lot of room, but if you knew that you\nwould only be dealing with 2-byte integers (as in most WAV audio waveforms),\nyou would have chosen `h`:\n\n```python\n>>> encoder, decoder = mk_codec('h')\n```\n\nWhat about those channels?\nWell, some times you need to encode/decode multi-channel streams, such as:\n\n```python\n>>> multi_channel_stream = [[3, -1], [4, -1], [5, -9]]\n```\n\nSay, for example, if you were dealing with stereo waveform\n(with the standard PCM_16 format), you'd do it this way:\n\n```python\n>>> encoder, decoder = mk_codec('hh')\n>>> pcm_bytes = encoder(iter(multi_channel_stream))\n>>> pcm_bytes\nb'\\x03\\x00\\xff\\xff\\x04\\x00\\xff\\xff\\x05\\x00\\xf7\\xff'\n>>> decoder(pcm_bytes)\n[(3, -1), (4, -1), (5, -9)]\n```\n\n\nThe `n_channels` and `chk_size_bytes` arguments are there if you want to assert\nthat your number of channels and chunk size are what you expect.\nAgain, these are just for verification, because we know how easy it is to\nmisspecify the `chk_format`, and how hard it can be to notice that we did.\n\nIt is advised to use these in any production code, for the sanity of everyone!\n\n```python\n>>> mk_codec('hhh', n_channels=2)\nTraceback (most recent call last):\n  ...\nAssertionError: You said there'd be 2 channels, but I inferred 3\n>>> mk_codec('hhh', chk_size_bytes=3)\nTraceback (most recent call last):\n  ...\nAssertionError: The given chk_size_bytes 3 did not match the inferred (from chk_format) 6\n```\n\nFinally, so far we've done it this way:\n\n\n```python\n>>> encoder, decoder = mk_codec('hHifd')\n```\n\nBut see that what's actually returned is a NAMED tuple, which means that you can\ncan also get one object that will have `.encode` and `.decode` properties:\n\n```python\n>>> codec = mk_codec('hHifd')\n>>> to_encode = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\n>>> encoded = codec.encode(to_encode)\n>>> decoded = codec.decode(encoded)\n>>> decoded\n[(1, 2, 3, 4.0, 5.0), (6, 7, 8, 9.0, 10.0)]\n```\n\nAnd you can checkout the properties of your encoder and decoder (they\nshould be the same)\n\n```python\n>>> codec.encode.chk_format\n'hHifd'\n>>> codec.encode.n_channels\n5\n>>> codec.encode.chk_size_bytes\n24\n```\n\n\n# Further functionality and under-the-hood peeps\n\nThis section shows various examples of recode and it how it can be used with:\n- Single channel numerical streams\n- Multi-channel numerical streams\n- DataFrames\n- Iterators\n\n\n```python\nfrom recode import (ChunkedEncoder, \n                    ChunkedDecoder, \n                    MetaEncoder, \n                    MetaDecoder, \n                    IterativeDecoder, \n                    StructCodecSpecs, \n                    specs_from_frames,\n                    frame_to_meta,\n                    meta_to_frame)\n```\n\n## Quick run through\n\nFirst define the frame you want to encode\n\n\n```python\nframe = [1,2,3]\n```\n\nNext define the specifications for that encoding\n\n\n```python\nspecs = StructCodecSpecs(chk_format='h')\nspecs\n```\n\n\n\n\n    StructCodecSpecs(chk_format='h', n_channels=1, chk_size_bytes=2)\n\n\n\nNext define an encoder and encode your frame to bytes\n\n\n```python\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\nb = encoder(frame)\nb\n```\n\n\n\n\n    b'\\x01\\x00\\x02\\x00\\x03\\x00'\n\n\n\nOnce you need your original frame again, define a decoder and decode your frame\n\n\n```python\ndecoder = ChunkedDecoder(specs.chk_to_frame)\ndecoded_frames = list(decoder(b))\ndecoded_frames\n```\n\n\n\n\n    [1, 2, 3]\n\n\n\n## Step-by-step explanation\n\n### Define your StructCodecSpecs\n\nStructCodecSpecs is used to define the specs for making codecs for fixed size structured chunks serialization and deserialization of sequences, tabular data, and time-series. This definition is based on format strings of the [python struct module](https://docs.python.org/3/library/struct.html#format-strings).\n\nThere are two ways to define StructCodecSpecs, the first being to explicitly \ndefine it using the StructCodecSpecs class. \nStructCodecSpecs takes three arguments: `chk_format`, `n_channels`, \nand `chk_size_bytes`. \n\nOnly `chk_format` is required, \nas `n_channels` and `chk_size_bytes` can be determined based on `chk_format`. \nIf `n_channels` or  `chk_size_bytes` are given, they will be used to \nassert that the values inferred from `chk_format` match.\n\nIf this is not the case, then do not provide an argument for `n_channels` \nand instead pass a string with the format character matching the data type for \neach channel in the frame to `chk_format`. \nFor example if the first channel \ncontains integers and the second contains floats, then `chk_format = 'hd'`.\n\n\n```python\nframe = [1,2,3]\nspecs = StructCodecSpecs(chk_format='h')\nspecs\n```\n\n\n\n\n    StructCodecSpecs(chk_format='h', n_channels=1, chk_size_bytes=2)\n\n\n\nThe second way to define StructCodecSpecs is to use `specs_from_frames` which will implictly define StructCodecSpecs based on the frame that is going to be encoded/decoded. This function will return a tuple containing an iterator of the passed frame and the defined StructCodecSpecs. The first element of the tuple can be ignored if the frame passed is not an iterator.\n\n\n```python\n_, specs = specs_from_frames(frame)\nspecs\n```\n\n\n\n\n    StructCodecSpecs(chk_format='h', n_channels=1, chk_size_bytes=2)\n\n\n\nIf frame is an iterator, then redefine frame as the first argument of the tuple so the first element of frame is not lost for encoding.\n\n\n```python\nframe = iter([[1,2], [3,4]])\nframe, specs = specs_from_frames(frame)\nspecs, list(frame)\n```\n\n\n\n\n    (StructCodecSpecs(chk_format='hh', n_channels=2, chk_size_bytes=4),\n     [[1, 2], [3, 4]])\n\n\n\n### Define your Encoder\n\nYour Encoder will allow you to, you guessed it, encode your frames! There are two Encoders currently defined in recode: `ChunkedEncoder` and `MetaEncoder`.\n\n`ChunkedEncoder` should be your goto encoder for sequences, while `MetaEncoder` works best for tabular data (currently must be in the format of list of dicts).\n\n\n```python\nframe = [1,2,3]\n_, specs = specs_from_frames(frame)\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\nb = encoder(frame)\nb\n```\n\n    b'\\x01\\x00\\x02\\x00\\x03\\x00'\n\n\n\nWhen using a `MetaEncoder`, an extra argument named frame_to_meta is required, which can be easily imported from recode!\n\n\n```python\nframe = [{'foo': 1, 'bar': 1}, {'foo': 2, 'bar': 2}, {'foo': 3, 'bar': 4}]\n_, specs = specs_from_frames(frame)\nencoder = MetaEncoder(frame_to_chk=specs.frame_to_chk, frame_to_meta=frame_to_meta)\nb = encoder(frame)\nb\n```\n\n    b'\\x07\\x00foo.bar\\x01\\x00\\x01\\x00\\x02\\x00\\x02\\x00\\x03\\x00\\x04\\x00'\n\n\n\n### Define your Decoder\n\nNext up your Decoder will allow you to decode your encoded bytes. There are three Encoders currently defined in recode: `ChunkedDecoder`, `IterativeDecoder`, and `MetaDecoder`.\n\nEither `ChunkedDecoder` or `IterativeDecoder` will work well for sequences, with the only difference being that `IterativeDecoder` returns an iterator of decoded chunks while `ChunkedDecoder` returns a mapping which can be converted to an iterable. `MetaDecoder` works best for tabular data encoded with `MetaEncoder`. \n\n\n```python\nframe = [1,2,3]\n_, specs = specs_from_frames(frame)\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(specs.chk_to_frame)\nb = encoder(frame)\nlist(decoder(b))\n```\n\n    [1, 2, 3]\n\n\n\nAs is shown in the following example, an `IterativeDecoder` will return an unpack_iterator which which can easily be converted to a standard iterable like a list, or be used as an iterator.\n\n\n```python\nframe = [[1,1],[2,2]]\n_, specs = specs_from_frames(frame)\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = IterativeDecoder(chk_to_frame=specs.chk_to_frame)\nb = encoder(frame)\niter_frames = decoder(b)\nprint(type(iter_frames))\nnext(iter_frames), next(iter_frames)\n```\n\n    <class 'unpack_iterator'>\n    ((1, 1), (2, 2))\n\n\n\nWhen using a `MetaDecoder`, an extra argument named meta_to_frame is required, which can be easily imported from recode!\n\n\n```python\nframe = [{'foo': 1, 'bar': 1}, {'foo': 2, 'bar': 2}, {'foo': 3, 'bar': 4}]\n_, specs = specs_from_frames(frame)\nencoder = MetaEncoder(frame_to_chk=specs.frame_to_chk, frame_to_meta=frame_to_meta)\ndecoder = MetaDecoder(chk_to_frame=specs.chk_to_frame, meta_to_frame=meta_to_frame)\nb = encoder(frame)\ndecoded_frames = decoder(b)\ndecoded_frames\n```\n\n    [{'foo': 1, 'bar': 1}, {'foo': 2, 'bar': 2}, {'foo': 3, 'bar': 4}]\n\n\n\n## Encoding a waveform\n\n### Create a synthetic waveform using `hum`\n\n\n```python\nfrom hum.gen.sine_mix import freq_based_stationary_wf\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nDFLT_N_SAMPLES = 21 * 2048\nDFLT_SR = 44100\n```\n\n\n```python\nwf_mix = freq_based_stationary_wf(freqs=(200, 400, 600, 800), weights=None,\n                             n_samples = DFLT_N_SAMPLES, sr = DFLT_SR)\nplt.plot(wf_mix[:300]);\n```\n\n\n    \n![png](notebooks/recode_demo_files/recode_demo_35_0.png)\n    \n\n\n\n```python\nwf_mix\n```\n\n\n\n\n    array([0.        , 0.07114157, 0.14170624, ..., 0.49480205, 0.54853009,\n           0.5979443 ])\n\n\n\n### Encode the wf\n\n\n```python\nspecs = StructCodecSpecs('d')\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)\nb = encoder(wf_mix)\nb[:100]\n```\n\n\n\n\n    b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1b:\\x11\\x8dU6\\xb2?\\xb8!\\xa2\\x15n#\\xc2?\\xe6I\\xedz\\x15\\x06\\xcb?L;\\xe6\\xfah\\xd8\\xd1?}\\x8c\\x9b\\x9a\\xf5\\x08\\xd6?D\\xcc\\xf1\\x897\\x0c\\xda?\\xe3\\xc5\\xbeb/\\xda\\xdd?DE\\xb6K\\xb6\\xb5\\xe0?\\x82|\\xfcz\\x90\\\\\\xe2?\\xae3:$\\x99\\xde\\xe3?\\x1e\\x95\\xbe\\xef$9\\xe5?\\x81\\xd7\\xdc\\xec'\n\n\n\n### Decode and compare to wf_mix\n\n\n```python\ndecoded_wf_mix = decoder(b)\nplt.plot(decoded_wf_mix[:300]);\n```\n\n\n    \n![png](notebooks/recode_demo_files/recode_demo_40_0.png)\n    \n\n\n\n```python\nnp.all(decoded_wf_mix == wf_mix)\n```\n\n\n\n\n    True\n\n\n\n## Encoding a pandas dataframe\n\n\n```python\nimport pandas as pd\n```\n\n### Create/import your dataframe\n\n\n```python\ndf = pd.DataFrame(data = [[1,2,3],[4,5,6]], columns = ['foo', 'bar', 'set'])\ndf\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>foo</th>\n      <th>bar</th>\n      <th>set</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4</td>\n      <td>5</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n### Prep the dataframe for encoding\n\n\n```python\nframe = df.to_dict('records')\nframe\n```\n\n\n\n\n    [{'foo': 1, 'bar': 2, 'set': 3}, {'foo': 4, 'bar': 5, 'set': 6}]\n\n\n\n### Encode the list of dicts\n\n\n```python\n_, specs = specs_from_frames(frame)\nencoder = MetaEncoder(frame_to_chk=specs.frame_to_chk, frame_to_meta=frame_to_meta)\ndecoder = MetaDecoder(chk_to_frame=specs.chk_to_frame, meta_to_frame=meta_to_frame)\nb = encoder(frame)\nb\n```\n\n\n\n\n    b'\\x0b\\x00foo.bar.set\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00'\n\n\n\n\n```python\ndecoded_frame = decoder(b)\ndecoded_frame\n```\n\n\n\n\n    [{'foo': 1, 'bar': 2, 'set': 3}, {'foo': 4, 'bar': 5, 'set': 6}]\n\n\n\n\n```python\ndecoded_df = pd.DataFrame(decoded_frame)\nprint(np.all(decoded_df == df))\ndecoded_df\n```\n\n    True\n\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>foo</th>\n      <th>bar</th>\n      <th>set</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4</td>\n      <td>5</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n## Miscellaneous information\n\n### Byte order, Size, and Alignment\n\nThis table provides the characters associated with Byte order, Size, and Alignment. If one of these characters is not given as the first character of the format string, then `@` will be assumed. More information about Byte order, Size, and Alignment can be found [here](https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment).\n\n|Character|Byte order|Size|Alignment|\n|---------|----------|----|---------|\n|@|native|native|native|\n|=|native|standard|none|\n|<|little-endian|standard|none|\n|>|big-endian|standard|none|\n|!|network (=big-endian)|standard|none|\n\n\n# Full Examples\n\n## Single channel numerical stream\n\n```python\nfrom recode import StructCodecSpecs, ChunkedEncoder, ChunkedDecoder\nspecs = StructCodecSpecs(chk_format='h')\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)\nframes = [1, 2, 3]\nb = encoder(frames)\nassert b == b'\\x01\\x00\\x02\\x00\\x03\\x00'\ndecoded_frames = list(decoder(b))\nassert decoded_frames == frames\n```\n\n\n## Multi-channel numerical stream\n```python\nfrom recode import StructCodecSpecs, ChunkedEncoder, ChunkedDecoder\nspecs = StructCodecSpecs(chk_format='@hh', n_channels = 2)\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)\nframes = [(1, 2), (3, 4), (5, 6)]\nb = encoder(frames)\nassert b == b'\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00'\ndecoded_frames = list(decoder(b))\nassert decoded_frames == frames\n```\n\n\n## Iterative decoder\n```python\nfrom recode import StructCodecSpecs, ChunkedEncoder, IterativeDecoder\nspecs = StructCodecSpecs(chk_format = 'hdhd')\nencoder = ChunkedEncoder(frame_to_chk = specs.frame_to_chk)\ndecoder = IterativeDecoder(chk_to_frame = specs.chk_to_frame)\nframes = [(1,1.1,1,1.1),(2,2.2,2,2.2),(3,3.3,3,3.3)]\nb = encoder(frames)\niter_frames = decoder(b)\nassert next(iter_frames) == frames[0]\nnext(iter_frames)\n```    \n\n\t(2, 2.2, 2, 2.2)\n\n\n\n## DataFrame (as list of dicts) using MetaEncoder/MetaDecoder\n```python\nfrom recode import StructCodecSpecs, MetaEncoder, MetaDecoder, frame_to_meta, meta_to_frame\ndata = [{'foo': 1.1, 'bar': 2.2}, {'foo': 513.23, 'bar': 456.1}, {'foo': 32.0, 'bar': 6.7}]\nspecs = StructCodecSpecs(chk_format='dd', n_channels = 2)\nencoder = MetaEncoder(frame_to_chk = specs.frame_to_chk, frame_to_meta = frame_to_meta)\ndecoder = MetaDecoder(chk_to_frame = specs.chk_to_frame, meta_to_frame = meta_to_frame)\nb = encoder(data)\nassert decoder(b) == data\n```\n\n\n## Implicitly define codec specs based on frames\n\n```python\nfrom recode import specs_from_frames, ChunkedEncoder, ChunkedDecoder\nframes = [1,2,3]\n_, specs = specs_from_frames(frames)\nencoder = ChunkedEncoder(frame_to_chk = specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)\nb = encoder(frames)\nassert b == b'\\x01\\x00\\x02\\x00\\x03\\x00'\ndecoded_frames = list(decoder(b))\ndecoded_frames\n```\n\n\t[1, 2, 3]\n\n\n## Implicit definition of iterator\n```python\nfrom recode import specs_from_frames, ChunkedEncoder, IterativeDecoder\nframes = iter([[1.1,2.2],[3.3,4.4]])\nframes, specs = specs_from_frames(frames)\nencoder = ChunkedEncoder(frame_to_chk = specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)\nb = encoder(frames)\ndecoded_frames = list(decoder(b))\nassert decoded_frames == [(1.1,2.2),(3.3,4.4)]\n```\n\n# More\n\n\n## Example of recode functionality to read and write audio files\n\nIn the below example we can see that the functionality of reading and writing audio to bytes is replicated in `recode`. \nAn example of a waveform audio file is first created using `mk_wf`. \nThen, that example wave form is converted to bytes using `BytesIO` and `soundfile.write`. \nThen, that same example wave form is converted to bytes using `recode` functionality. \nFinally it can be seen through the assertions that `soundfile`'s read/write and `recode`'s encode/decode provide \nthe same functionality for audio files (aside from the header in `soundfile` as a result of the .wav format).\n\n```python\nimport soundfile as sf\nfrom io import BytesIO\nfrom enum import Enum\nimport numpy as np\nfrom recode import ChunkedDecoder, ChunkToFrame, ChunkedEncoder, StructCodecSpecs\n\nclass Kind(Enum):\n    random = 'random'\n    increasing = 'increasing'\n\ndef mk_wf(n_samples=2048, kind: Kind=Kind.random, **kwargs):\n    if kind == Kind.random:\n        dtype_str = kwargs.get('num_type', 'int16')\n        if dtype_str.startswith('int'):\n            low = kwargs.get('low', -30000)\n            high = kwargs.get('high', 30000)\n            wf = np.random.randint(low=low, high=high, size=n_samples, dtype=dtype_str)\n        else:\n            raise TypeError(\"Don't know how to handle this case\")\n    else:\n        raise TypeError(\"Don't know how to handle this case\")\n    return wf\n\nwf = mk_wf(25)\nsr = 10000\n\nfile = BytesIO()\nsf.write(file, wf, sr, format = 'WAV')\nfile.seek(0)\nb = file.read()\n\nspecs = StructCodecSpecs('h')\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(chk_size_bytes=specs.chk_size_bytes, \n                         chk_to_frame=specs.chk_to_frame, \n                         n_channels=specs.n_channels)\nd = encoder(wf)\n\nassert d == b[44:]\n\nsf_read = sf.read(BytesIO(b), dtype='int16')\nrecode_read = list(decoder(d))\n\nassert np.all(sf_read[0] == recode_read)\nassert np.all(recode_read == wf)\nassert np.all(sf_read[0] == wf)\n```\n\n## Compare performance of IterativeDecoder and ChunkedDecoder\n\nBoth `IterativeDecoder` and `ChunkedDecoder` work well with encoded sequences. \nAdditionally, an `IterativeDecoder` can replace the functionality of a `ChunkedDecoder` as the iterator \nit returns can easily be converted to a list. \nBecause of this we will compare the efficiency of `IterativeDecoder` and `ChunkedDecoder` to see if we should replace the \nfunctionality of `ChunkedDecoder` with `IterativeDecoder`.\n\n```python\nfrom hum.gen.sine_mix import freq_based_stationary_wf\nfrom recode import (ChunkedEncoder, \n                    ChunkedDecoder, \n                    IterativeDecoder, \n                    StructCodecSpecs)\n```\n\nCreate a synthetic waveform to test both decoders on:\n\n```python\nDFLT_N_SAMPLES = 21 * 2048\nDFLT_SR = 44100\n\nwf_mix = freq_based_stationary_wf(freqs=(200, 400, 600, 800), weights=None,\n                             n_samples = DFLT_N_SAMPLES*300, sr = DFLT_SR)\n```\n\nDefine the decoders and encode the waveform:\n\n```python\nspecs = StructCodecSpecs('d')\nencoder = ChunkedEncoder(frame_to_chk=specs.frame_to_chk)\ndecoder = ChunkedDecoder(\n    chk_size_bytes=specs.chk_size_bytes,\n    chk_to_frame=specs.chk_to_frame,\n    n_channels=specs.n_channels\n)\nidecoder = IterativeDecoder(chk_to_frame = specs.chk_to_frame_iter)\nb = encoder(wf_mix)\n```\n\nHelper function so the output of the decoders are in the same format:\n\n```python\ndef it_to_list(it):\n    frame = list(it)\n    frame = [item for tup in frame for item in tup]\n    return frame\n```\n\nPerformance of `ChunkedDecoder`:\n\n```python\n%timeit -r 2 -n 5 list(decoder(b))\n```\n```\n5.59 s ± 14.5 ms per loop (mean ± std. dev. of 2 runs, 5 loops each)\n```\n\nPerformance of `IterativeDecoder`:\n\n```python\n%timeit -r 2 -n 5 it_to_list(idecoder(b))\n```\n```\n2.04 s ± 13.4 ms per loop (mean ± std. dev. of 2 runs, 5 loops each)\n```\n\nFrom these results, we can clearly see that we should replace the functionality of `ChunkedDecoder` with `IterativeDecoder` \nas it is nearly three times more efficient.",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/otosense/recode",
    "keywords": "",
    "license": "apache-2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "recode",
    "package_url": "https://pypi.org/project/recode/",
    "platform": "any",
    "project_url": "https://pypi.org/project/recode/",
    "project_urls": {
      "Homepage": "https://github.com/otosense/recode"
    },
    "release_url": "https://pypi.org/project/recode/0.1.26/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Tools to make codecs for time-series serialization and deserialization.",
    "version": "0.1.26",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15538213,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "533cbf6e79f2be965db1f5e61492b919ca7eab103a0da40cdd9872e5511235c2",
          "md5": "866be460ec174bd356152b608acededa",
          "sha256": "88ed8289d2c9b6eb0c410d3903b7acae4d659bb8a513c2a5e1b8ccecef80c27c"
        },
        "downloads": -1,
        "filename": "recode-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "866be460ec174bd356152b608acededa",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 7264,
        "upload_time": "2021-06-18T18:48:09",
        "upload_time_iso_8601": "2021-06-18T18:48:09.021055Z",
        "url": "https://files.pythonhosted.org/packages/53/3c/bf6e79f2be965db1f5e61492b919ca7eab103a0da40cdd9872e5511235c2/recode-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6511b75be752f0f09d8e9e27072ad3d4686425daf84fd8221af74a7cc986a8d8",
          "md5": "dfe22af78fd4c44c74ea675cd107729e",
          "sha256": "c4c430113dd6b6fb8f393561d39f35ffffbe375ade41cebda9ba67f1822bcb2a"
        },
        "downloads": -1,
        "filename": "recode-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "dfe22af78fd4c44c74ea675cd107729e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3023,
        "upload_time": "2021-06-18T18:48:10",
        "upload_time_iso_8601": "2021-06-18T18:48:10.679226Z",
        "url": "https://files.pythonhosted.org/packages/65/11/b75be752f0f09d8e9e27072ad3d4686425daf84fd8221af74a7cc986a8d8/recode-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bee39fddeebfc4df32b9828e567884d82f4932f1b66b5fb5ccdee19fa71e9829",
          "md5": "104cd434133f7033dd39200abac023d9",
          "sha256": "31283c23381c1c3027a488f50f6597dcbb9bc4d8d370acef84662212b3d88c7e"
        },
        "downloads": -1,
        "filename": "recode-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "104cd434133f7033dd39200abac023d9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 6927,
        "upload_time": "2021-06-18T18:49:13",
        "upload_time_iso_8601": "2021-06-18T18:49:13.179927Z",
        "url": "https://files.pythonhosted.org/packages/be/e3/9fddeebfc4df32b9828e567884d82f4932f1b66b5fb5ccdee19fa71e9829/recode-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "31f538aab24536f527a1f126feb102d9579f181c164b433bbfd06e92a99c3f5e",
          "md5": "cf7a10f1e165333a1e0ee43c911d7f55",
          "sha256": "87a16b8e09c32bc8d40719c9fda7a1b985be6bce19eb17b2723ea2de1e118047"
        },
        "downloads": -1,
        "filename": "recode-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "cf7a10f1e165333a1e0ee43c911d7f55",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 7578,
        "upload_time": "2021-06-18T22:28:45",
        "upload_time_iso_8601": "2021-06-18T22:28:45.754470Z",
        "url": "https://files.pythonhosted.org/packages/31/f5/38aab24536f527a1f126feb102d9579f181c164b433bbfd06e92a99c3f5e/recode-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "45d4766baec7816c754578bcb8b65c064cba53f122ffa96fe7d810c8ee2e5712",
          "md5": "ad6b2ac770d98eb94f853f1ea774b4e6",
          "sha256": "54113f94e004de39232114f125ea39b6857cfe307ca9683b918ad5d8f79b1f64"
        },
        "downloads": -1,
        "filename": "recode-0.1.10.tar.gz",
        "has_sig": false,
        "md5_digest": "ad6b2ac770d98eb94f853f1ea774b4e6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15814,
        "upload_time": "2021-06-25T15:03:42",
        "upload_time_iso_8601": "2021-06-25T15:03:42.931595Z",
        "url": "https://files.pythonhosted.org/packages/45/d4/766baec7816c754578bcb8b65c064cba53f122ffa96fe7d810c8ee2e5712/recode-0.1.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a4b6d9b58a592b88b7652b2319d2ea37a55a5e06a53f458ef86078bf1a8db2d1",
          "md5": "029f795d65edba9a8a2967d7a6bb6d0f",
          "sha256": "3d0c9891054be0af3c2544150aa342e476884fb73e734c8a97061dcf0cd18219"
        },
        "downloads": -1,
        "filename": "recode-0.1.11.tar.gz",
        "has_sig": false,
        "md5_digest": "029f795d65edba9a8a2967d7a6bb6d0f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15813,
        "upload_time": "2021-07-02T14:36:44",
        "upload_time_iso_8601": "2021-07-02T14:36:44.410182Z",
        "url": "https://files.pythonhosted.org/packages/a4/b6/d9b58a592b88b7652b2319d2ea37a55a5e06a53f458ef86078bf1a8db2d1/recode-0.1.11.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.12": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e28348093e2aa32e18d9cf58d019e84ff3b7077254436f86a65cd4feac40f4f2",
          "md5": "38d5454c3a2aeaa523fa978cf1e339a6",
          "sha256": "a29478bc7ff8104889c58035d0f02505dca445530d887941d86ce09a0e7e88ce"
        },
        "downloads": -1,
        "filename": "recode-0.1.12.tar.gz",
        "has_sig": false,
        "md5_digest": "38d5454c3a2aeaa523fa978cf1e339a6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15807,
        "upload_time": "2021-09-06T22:21:46",
        "upload_time_iso_8601": "2021-09-06T22:21:46.122779Z",
        "url": "https://files.pythonhosted.org/packages/e2/83/48093e2aa32e18d9cf58d019e84ff3b7077254436f86a65cd4feac40f4f2/recode-0.1.12.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.13": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b166909eef5552954f8f46523f254f7f2d3d7e3d154cc46548d04e76862cbedf",
          "md5": "2f3c5a8f2ec6aa0ee25c2a49e454fefa",
          "sha256": "fcff46d82a90c9b31a153432ab8e30dead71ee43c9507a377dc63bc8291d2913"
        },
        "downloads": -1,
        "filename": "recode-0.1.13.tar.gz",
        "has_sig": false,
        "md5_digest": "2f3c5a8f2ec6aa0ee25c2a49e454fefa",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15807,
        "upload_time": "2021-09-06T22:25:28",
        "upload_time_iso_8601": "2021-09-06T22:25:28.018784Z",
        "url": "https://files.pythonhosted.org/packages/b1/66/909eef5552954f8f46523f254f7f2d3d7e3d154cc46548d04e76862cbedf/recode-0.1.13.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.14": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "30020a383abefe71d67234c2946bf32b61b2b3610f489e2e9e1bbd436f022c0b",
          "md5": "9a86e11e3f12c6d4732d589a05064e97",
          "sha256": "9c2c015a92fb615d3d5eb43a04e21fcd002d562f1a6af8457c55a3f35422e17a"
        },
        "downloads": -1,
        "filename": "recode-0.1.14.tar.gz",
        "has_sig": false,
        "md5_digest": "9a86e11e3f12c6d4732d589a05064e97",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15808,
        "upload_time": "2021-09-06T22:26:22",
        "upload_time_iso_8601": "2021-09-06T22:26:22.674865Z",
        "url": "https://files.pythonhosted.org/packages/30/02/0a383abefe71d67234c2946bf32b61b2b3610f489e2e9e1bbd436f022c0b/recode-0.1.14.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.15": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4858870edf021d68cb85cd9400122d5a620d97bba8aed3edb6f51c65978a6a9e",
          "md5": "a4df84b4347bd87c87b5fd4275fea58e",
          "sha256": "160c8baf2ef480d351c90ca5c2fa6138a637d368b66a1cc61c20d5b6eda3cb68"
        },
        "downloads": -1,
        "filename": "recode-0.1.15.tar.gz",
        "has_sig": false,
        "md5_digest": "a4df84b4347bd87c87b5fd4275fea58e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 16205,
        "upload_time": "2021-10-12T18:25:00",
        "upload_time_iso_8601": "2021-10-12T18:25:00.644884Z",
        "url": "https://files.pythonhosted.org/packages/48/58/870edf021d68cb85cd9400122d5a620d97bba8aed3edb6f51c65978a6a9e/recode-0.1.15.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.16": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b5d8ae33a8af6c7c99b7dfb50e1ac9ed74d3e14da7e7fab832307a1eedca27f8",
          "md5": "b864d31dd3d19139bd983f978332ada3",
          "sha256": "6f958bed446db5dc57e78000399f3be160d2fb17a0cb0eab20c22242915d83a8"
        },
        "downloads": -1,
        "filename": "recode-0.1.16.tar.gz",
        "has_sig": false,
        "md5_digest": "b864d31dd3d19139bd983f978332ada3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18685,
        "upload_time": "2021-11-10T19:54:07",
        "upload_time_iso_8601": "2021-11-10T19:54:07.071318Z",
        "url": "https://files.pythonhosted.org/packages/b5/d8/ae33a8af6c7c99b7dfb50e1ac9ed74d3e14da7e7fab832307a1eedca27f8/recode-0.1.16.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.17": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3c3357220cdedba457fcfbaa177a71ea50cbb52dd798d37c566394fde509abee",
          "md5": "1942bfdbd0267d226b5508fc3107f80c",
          "sha256": "5cc5da21bd5ee28e8ff26ac44553a694005121b97b4e474d0214766ac250bb7c"
        },
        "downloads": -1,
        "filename": "recode-0.1.17.tar.gz",
        "has_sig": false,
        "md5_digest": "1942bfdbd0267d226b5508fc3107f80c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 20444,
        "upload_time": "2021-11-10T20:47:52",
        "upload_time_iso_8601": "2021-11-10T20:47:52.354354Z",
        "url": "https://files.pythonhosted.org/packages/3c/33/57220cdedba457fcfbaa177a71ea50cbb52dd798d37c566394fde509abee/recode-0.1.17.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.18": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b874c1fcfd77c54d70bfad42573c24f788d2f7474a87920776560c4d0e1765d6",
          "md5": "0cffdaf4a6941bb0e1541193b010511a",
          "sha256": "3df9eae07733acff36edb3e7f20cfb676d76699b3b528113f3f3e00fb00cfd89"
        },
        "downloads": -1,
        "filename": "recode-0.1.18.tar.gz",
        "has_sig": false,
        "md5_digest": "0cffdaf4a6941bb0e1541193b010511a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23149,
        "upload_time": "2021-11-12T00:19:59",
        "upload_time_iso_8601": "2021-11-12T00:19:59.802759Z",
        "url": "https://files.pythonhosted.org/packages/b8/74/c1fcfd77c54d70bfad42573c24f788d2f7474a87920776560c4d0e1765d6/recode-0.1.18.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.19": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9406ada4a0e41dbfb0d6ec6a088f526c05cb75c82ee93555ca02b631742df73a",
          "md5": "d910c56a9910f7f4c877194bc5ca7ecb",
          "sha256": "6fdbf08cabd97ed895d97451f75bae4d77f7b3484dc8cef455dd11e75413f017"
        },
        "downloads": -1,
        "filename": "recode-0.1.19.tar.gz",
        "has_sig": false,
        "md5_digest": "d910c56a9910f7f4c877194bc5ca7ecb",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24320,
        "upload_time": "2021-11-12T01:53:03",
        "upload_time_iso_8601": "2021-11-12T01:53:03.121560Z",
        "url": "https://files.pythonhosted.org/packages/94/06/ada4a0e41dbfb0d6ec6a088f526c05cb75c82ee93555ca02b631742df73a/recode-0.1.19.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "86d9ca5c582a53f8c78d50b7dff3eee319fdf7a511af7ba50571a48f1ec5f4ee",
          "md5": "4d375157c794eed510f7aefe230a84ee",
          "sha256": "dbbe4a2fb10673aae7144aaf929209ab5d7ed289e2da9e2f272e2bf05403fda7"
        },
        "downloads": -1,
        "filename": "recode-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "4d375157c794eed510f7aefe230a84ee",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 7658,
        "upload_time": "2021-06-21T13:12:35",
        "upload_time_iso_8601": "2021-06-21T13:12:35.952512Z",
        "url": "https://files.pythonhosted.org/packages/86/d9/ca5c582a53f8c78d50b7dff3eee319fdf7a511af7ba50571a48f1ec5f4ee/recode-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.20": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "31a72bb54a0af2030521064eb45e7c83707eac3ea0ee5cca0757370e2f7be64c",
          "md5": "9e629ba0417f3d6326e70dcc4c193a1b",
          "sha256": "8a7c6db760d2f7ea62fc195a79d8870a1c1f4be81d413d29f153561830bdee5b"
        },
        "downloads": -1,
        "filename": "recode-0.1.20.tar.gz",
        "has_sig": false,
        "md5_digest": "9e629ba0417f3d6326e70dcc4c193a1b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24412,
        "upload_time": "2021-11-19T20:25:05",
        "upload_time_iso_8601": "2021-11-19T20:25:05.326433Z",
        "url": "https://files.pythonhosted.org/packages/31/a7/2bb54a0af2030521064eb45e7c83707eac3ea0ee5cca0757370e2f7be64c/recode-0.1.20.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.21": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9c603933ec8d1b69d9ff2410ddcb183f237ea9019bff4b23a8b96df2a1bae5ff",
          "md5": "71ebef02990254723c19a59ce581e4e5",
          "sha256": "1173df70e790813ba77919bade6fb55d4985054fdf19edc0ba4762548789982f"
        },
        "downloads": -1,
        "filename": "recode-0.1.21.tar.gz",
        "has_sig": false,
        "md5_digest": "71ebef02990254723c19a59ce581e4e5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24321,
        "upload_time": "2021-11-19T20:27:55",
        "upload_time_iso_8601": "2021-11-19T20:27:55.948904Z",
        "url": "https://files.pythonhosted.org/packages/9c/60/3933ec8d1b69d9ff2410ddcb183f237ea9019bff4b23a8b96df2a1bae5ff/recode-0.1.21.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.22": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7fa8be099b890b94979d6c9e01cb388443be67ec5522810e98568f7c7c2b9e90",
          "md5": "5bab20f747daf0d888ccd676ad40b8f3",
          "sha256": "3dcb49557ac7e6f2f2de92c66cdedafd36dbbc23d703dd033421b907cf6e2f7a"
        },
        "downloads": -1,
        "filename": "recode-0.1.22.tar.gz",
        "has_sig": false,
        "md5_digest": "5bab20f747daf0d888ccd676ad40b8f3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24466,
        "upload_time": "2021-12-13T23:27:30",
        "upload_time_iso_8601": "2021-12-13T23:27:30.574765Z",
        "url": "https://files.pythonhosted.org/packages/7f/a8/be099b890b94979d6c9e01cb388443be67ec5522810e98568f7c7c2b9e90/recode-0.1.22.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.23": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "063b507a76832ce6aaa03903e5b4d74fe44e44f9418c15677876c39fb7f28c3d",
          "md5": "4ddf7550eec6bfb05591994dade59f1d",
          "sha256": "c3d0fe895cb818583e919308631564a4bb98e34efe642c24037ff8d566684e95"
        },
        "downloads": -1,
        "filename": "recode-0.1.23.tar.gz",
        "has_sig": false,
        "md5_digest": "4ddf7550eec6bfb05591994dade59f1d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24507,
        "upload_time": "2022-07-20T22:17:32",
        "upload_time_iso_8601": "2022-07-20T22:17:32.399063Z",
        "url": "https://files.pythonhosted.org/packages/06/3b/507a76832ce6aaa03903e5b4d74fe44e44f9418c15677876c39fb7f28c3d/recode-0.1.23.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.24": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f43dd58212f9ebc2ab195e25f78f2ca064799547f91a725a85760af1eeaf5abe",
          "md5": "7962336371cb3175206c3434b61fae78",
          "sha256": "50604dbe4b537689589ff2aab1fa36e74e7b937fb0216073371180fcb5970df1"
        },
        "downloads": -1,
        "filename": "recode-0.1.24.tar.gz",
        "has_sig": false,
        "md5_digest": "7962336371cb3175206c3434b61fae78",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24589,
        "upload_time": "2022-07-20T23:20:58",
        "upload_time_iso_8601": "2022-07-20T23:20:58.716185Z",
        "url": "https://files.pythonhosted.org/packages/f4/3d/d58212f9ebc2ab195e25f78f2ca064799547f91a725a85760af1eeaf5abe/recode-0.1.24.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.25": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "087df965b974b935bfa8d27df82c8626921655bd4c4dd7916dca20e86a1fa89c",
          "md5": "e9bca0e78b70910fd70ddcb3b92abd88",
          "sha256": "999101400024a16704fc120deef01b1979a8a08f3ad98c270625a6ad96d18e06"
        },
        "downloads": -1,
        "filename": "recode-0.1.25.tar.gz",
        "has_sig": false,
        "md5_digest": "e9bca0e78b70910fd70ddcb3b92abd88",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24589,
        "upload_time": "2022-07-21T22:54:12",
        "upload_time_iso_8601": "2022-07-21T22:54:12.957634Z",
        "url": "https://files.pythonhosted.org/packages/08/7d/f965b974b935bfa8d27df82c8626921655bd4c4dd7916dca20e86a1fa89c/recode-0.1.25.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.26": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "deeb63c12428da65adebbaa1b4c8e256a1e05d4691f7136a4c78c29568429682",
          "md5": "986ca344070be9f526c7395b856f2426",
          "sha256": "bfd0e4172ec5aacad064ca18f175c677adc712698875b636b37c0641754f2531"
        },
        "downloads": -1,
        "filename": "recode-0.1.26.tar.gz",
        "has_sig": false,
        "md5_digest": "986ca344070be9f526c7395b856f2426",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24589,
        "upload_time": "2022-10-26T14:22:52",
        "upload_time_iso_8601": "2022-10-26T14:22:52.462023Z",
        "url": "https://files.pythonhosted.org/packages/de/eb/63c12428da65adebbaa1b4c8e256a1e05d4691f7136a4c78c29568429682/recode-0.1.26.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "20119741a29a6c154121b1e4ed59953e205422637cc0d15395c7bb92df26b2e1",
          "md5": "68e3858db87a23b704f2ec69258adcb4",
          "sha256": "40b28ad67a537558dc9f1624a1ffedb601c069b48649118964b3b639a886e61b"
        },
        "downloads": -1,
        "filename": "recode-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "68e3858db87a23b704f2ec69258adcb4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 8245,
        "upload_time": "2021-06-21T19:34:13",
        "upload_time_iso_8601": "2021-06-21T19:34:13.159380Z",
        "url": "https://files.pythonhosted.org/packages/20/11/9741a29a6c154121b1e4ed59953e205422637cc0d15395c7bb92df26b2e1/recode-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5a55e2f1b9c0926376d2cba8bb9889c29bd53f95f85666a5d770e03a23df6bdf",
          "md5": "ba3f7e75e17e1340a72aff3f05df6ec2",
          "sha256": "535244dd0f2c0e5f491cea8aa69402afbd56d319bbee7f3928ad73da8b843f8d"
        },
        "downloads": -1,
        "filename": "recode-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "ba3f7e75e17e1340a72aff3f05df6ec2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 9028,
        "upload_time": "2021-06-22T14:32:17",
        "upload_time_iso_8601": "2021-06-22T14:32:17.139450Z",
        "url": "https://files.pythonhosted.org/packages/5a/55/e2f1b9c0926376d2cba8bb9889c29bd53f95f85666a5d770e03a23df6bdf/recode-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "be5103e84819a312b49f91904b8261a40a703c37133a3b7e87881fc3558598ba",
          "md5": "950a36fa587015a75e9eecc91f8c2bf6",
          "sha256": "a6af0c3254459eb2bc4ea80d8308a3a0b8fcb2b6f2de643ed75d5af25b737521"
        },
        "downloads": -1,
        "filename": "recode-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "950a36fa587015a75e9eecc91f8c2bf6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 9960,
        "upload_time": "2021-06-22T20:13:59",
        "upload_time_iso_8601": "2021-06-22T20:13:59.192741Z",
        "url": "https://files.pythonhosted.org/packages/be/51/03e84819a312b49f91904b8261a40a703c37133a3b7e87881fc3558598ba/recode-0.1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e11788031a56f3ebff79905c01697dd700a0e7c4733a3e211ae8b12f77083302",
          "md5": "75f5bb736368eb6af3c13ab01f7a9e33",
          "sha256": "e92fae3a6526490af9c8a0dc24ade326e8274a833fa6e10bb688ea635305ce36"
        },
        "downloads": -1,
        "filename": "recode-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "75f5bb736368eb6af3c13ab01f7a9e33",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 10007,
        "upload_time": "2021-06-23T15:34:02",
        "upload_time_iso_8601": "2021-06-23T15:34:02.333412Z",
        "url": "https://files.pythonhosted.org/packages/e1/17/88031a56f3ebff79905c01697dd700a0e7c4733a3e211ae8b12f77083302/recode-0.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0376102b2ef0a9e83872c2bacff14c3909946ba74383f489478542c34854c8dc",
          "md5": "c6af2fab77e729b52a2903f063b73b68",
          "sha256": "2112629deb07409ab48d30a600feaa346c99cc8bcc63ae49024e499fca894877"
        },
        "downloads": -1,
        "filename": "recode-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "c6af2fab77e729b52a2903f063b73b68",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15853,
        "upload_time": "2021-06-24T19:58:34",
        "upload_time_iso_8601": "2021-06-24T19:58:34.867806Z",
        "url": "https://files.pythonhosted.org/packages/03/76/102b2ef0a9e83872c2bacff14c3909946ba74383f489478542c34854c8dc/recode-0.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ce8a9d43705268e78ec5e7bda26a3c3c9c617a0106f427fd41cceae1192112b1",
          "md5": "17ed42593b99ae665995e21be7f7cc43",
          "sha256": "6b4651c785ddcf644c05b2c4b9dd31fdea6a7ddc1b44265555cc722c918c6a65"
        },
        "downloads": -1,
        "filename": "recode-0.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "17ed42593b99ae665995e21be7f7cc43",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15622,
        "upload_time": "2021-06-24T20:04:47",
        "upload_time_iso_8601": "2021-06-24T20:04:47.348113Z",
        "url": "https://files.pythonhosted.org/packages/ce/8a/9d43705268e78ec5e7bda26a3c3c9c617a0106f427fd41cceae1192112b1/recode-0.1.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "40737d18a20061bf5d4a2ca248f0e14bb067c8d8827264172eda7f75c169374d",
          "md5": "c54383e8aff20778c38f733495e6388b",
          "sha256": "328613fee72bead03450a5461d645a1321da3d7474eac0bc7b6019a2d15eaf9a"
        },
        "downloads": -1,
        "filename": "recode-0.1.9.tar.gz",
        "has_sig": false,
        "md5_digest": "c54383e8aff20778c38f733495e6388b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15752,
        "upload_time": "2021-06-25T14:58:51",
        "upload_time_iso_8601": "2021-06-25T14:58:51.825550Z",
        "url": "https://files.pythonhosted.org/packages/40/73/7d18a20061bf5d4a2ca248f0e14bb067c8d8827264172eda7f75c169374d/recode-0.1.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "deeb63c12428da65adebbaa1b4c8e256a1e05d4691f7136a4c78c29568429682",
        "md5": "986ca344070be9f526c7395b856f2426",
        "sha256": "bfd0e4172ec5aacad064ca18f175c677adc712698875b636b37c0641754f2531"
      },
      "downloads": -1,
      "filename": "recode-0.1.26.tar.gz",
      "has_sig": false,
      "md5_digest": "986ca344070be9f526c7395b856f2426",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 24589,
      "upload_time": "2022-10-26T14:22:52",
      "upload_time_iso_8601": "2022-10-26T14:22:52.462023Z",
      "url": "https://files.pythonhosted.org/packages/de/eb/63c12428da65adebbaa1b4c8e256a1e05d4691f7136a4c78c29568429682/recode-0.1.26.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}