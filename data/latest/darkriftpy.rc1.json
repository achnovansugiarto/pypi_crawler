{
  "info": {
    "author": "Anton Dobriakov",
    "author_email": "anton.dobryakov@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Framework :: AsyncIO",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# DarkRiftPy\nDarkRiftPy is [Darkrift2](https://www.darkriftnetworking.com/) written in\nPython 3. The implementation is fully compatible with the original version. So\nyou can write a client side on Python that connects to a Darkrift2 server\nwritten in C# using the original Darkrift2 library, and vice versa.  \n\nDarkRiftPy is built on top of\n[asyncio](https://docs.python.org/3/library/asyncio.html), Python's standard\nasynchronus I/O library, and provides a convenient high-level async/await API.  \n\n## Installation\n\n```console\n$ python3 -m pip install darkriftpy\n\n```\n\n## Quick usage example\n\nA simple exampls contains two separate scripts `client.py` and `server.py` for\nclient and server respectively.  \n\nAfter client is connected to the server the latter waits for a darkrift message\nwith tag 1, which contains a list of int32 integers in the payload. Once the\nmessage with tag 1 is received, the server starts to randomly select a value\nfrom the given list and sends it back to the client.\n\n`client.py`:  \n\n```python\nimport asyncio\nimport random\n\n\nimport darkriftpy\n\n\nRND_POOL = 20\n\nMIN_INT32 = (2 ** 31) * -1\nMAX_INT32 = 2 ** 31 - 2\n\n\nasync def process_message(message: darkriftpy.DarkriftMessage) -> None:\n    if message.tag != 2:\n        raise ValueError(\"wrong message received\")\n\n    num = message.get_reader().read_int32()\n    print(f\"the server chose the number: {num}\")\n\n\nasync def main() -> None:\n    try:\n        async with darkriftpy.connect(\"127.0.0.1\", 4296, 4296) as client:\n            items = [random.randint(MIN_INT32, MAX_INT32) for _ in range(RND_POOL)]\n\n            writer = darkriftpy.DarkriftWriter()\n            writer.write_int32s(items)\n\n            await client.send(darkriftpy.DarkriftMessage(1, writer.bytes))\n\n            async for message in client:\n                await process_message(message)\n\n            print(\"connection has been closed by the server\")\n\n    except ConnectionError:\n        print(\"failed to connect to the server\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n`server.py`:  \n\n```python\nimport asyncio\nimport random\n\n\nimport darkriftpy\n\n\nasync def handle_client(client: darkriftpy.DarkriftClient) -> None:\n    message = await client.recv()\n\n    if message.tag != 1:\n        raise RuntimeError(\"wrong client message received\")\n\n        client.close()\n        await client.wait_closed()\n        return\n\n    reader = message.get_reader()\n    items = reader.read_int32s()\n\n    while True:\n        writer = darkriftpy.DarkriftWriter()\n        writer.write_int32(random.choice(items))\n\n        try:\n            await client.send(darkriftpy.DarkriftMessage(2, writer.bytes))\n        except darkriftpy.ConnectionClosedError:\n            print(f\"the client({client.connection_id}) has been disconnected\")\n            await client.wait_closed()\n            return\n\n        await asyncio.sleep(1)\n\n\nasync def main() -> None:\n    async with darkriftpy.serve(handle_client, \"127.0.0.1\", 4296, 4296) as server:\n        await asyncio.Future()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## User defined messages\n\n`darkriftpy` provides a convinient way to create/send/receive user-defined\nmessages. There is a `Message` class that can be used as a base class for\nuser-defined ones. The Darkrift tag of a user-defined message is defined by\npassing the keyword `tag` argument in the class definition:  \n\n```python\nimport darkriftpy\n\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    ...\n\n```\n\nFor now, the `ChooseMessage` message contains no payload. Since the\n`ChooseMessage` class is implicitly decorated with the\n[@dataclass](https://docs.python.org/3/library/dataclasses.html?highlight=dataclass#dataclasses.dataclass)\ndecorator, the user can define class variables with [type\nannotations](https://docs.python.org/3/glossary.html#term-variable-annotation)\nwhich will be automatically deserialized from or serialized to a binary stream\nusing `DarkriftReader` and `DarkriftWriter` classes. Only the following native\ntypes can be used as a class variable type: `str`, `bytes`, `bool`, `float`.\nSince [Darkrift2](https://www.darkriftnetworking.com/) allows to use types\nwhich are not natively available in python, the `darkriftpy.types` module\nprovides\n[NewType](https://docs.python.org/3/library/typing.html?highlight=newtype#typing.NewType)\nextensions to cover all the required Darkrift2 types.  \n\n```python\nimport darkriftpy\nfrom darkriftpy.types import int32\n\n\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    items: list[int32]\n\n```\n\nAs you can see we used the `int32` type from the `darkriftpy.types` module to\ndefine 4 byte signed integer. Since the `ChooseMessage` class is implicitly\ndecorated with the\n[@dataclass](https://docs.python.org/3/library/dataclasses.html?highlight=dataclass#dataclasses.dataclass)\ndecorator and there is no custom constructor, the following constructor will be\ncreated automatically:  `__init__(self, items: lsit[int32])`  \n\nTherefore, the `ChooseMessage` class can be instantiated as follows:  \n\n```python\nimport random\n\n\nimport darkriftpy\nfrom darkriftpy.types import int32\n\n\nMIN_INT32 = (2 ** 31) * -1\nMAX_INT32 = 2 ** 31 - 2\n\n\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    items: list[int32]\n\n\nmessage = ChooseMessage([random.randint(MIN_INT32, MAX_INT32) for _ in range(10)])\n\n# message.items contains a list with 10 int32 integers\n\n```\n\nSince the `darkriftpy.Message` is inherited from `darkriftpy.DarkriftMessage`\nthe user-defined message can be passed as is to the `send` method of the\n`darkriftpy.DarkriftClient` object.  \n\nTo convert a received `darkriftpy.DarkriftMessage` message to the user-defined\none, the user can do the following:  \n\n```python\n...\n\nclient: darkriftpy.DarkriftClient\nmessage: darkriftpy.DarkriftMessage = await client.recv()\n\ntry:\n    choose_message = ChooseMessage.read(message.get_reader())\nexcept RuntimeError:\n    # failed to parse the received message\n    ...\n\nprint(choose_message.items)\n\n```\n\nThe `darkriftpy` package provides the `MessageContainer` class to\nsimplify the message serialization and de-siarilization.  \n\n```python\nimport darkriftpy\nfrom darkriftpy.types import int32\n\n\nmessages = darkriftpy.MessageContainer()\n\n\n@messages.add\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    items: list[int32]\n\n\n@messages.add\nclass ChoiceMessage(darkriftpy.Message, tag=2):\n    item: int32\n\n...\n\nclient: darkriftpy.DarkriftClient\nmessage: darkriftpy.DarkriftMessage = await client.recv()\n\ntry:\n    msg = messages.convert(message)\nexcept RuntimeError:\n    # failed to convert the received darkrift message\n    # to the user-defined one\n\nif isinstance(msg, ChooseMessage):\n    print(msg.items)\nelif isinstance(msg, ChoiceMessage):\n    print(msg.item)\n\n```\n\nWe used the `add` method of the `MessageContainer` class as decorator to add\nthe user-defined class into the message container `messages`.  \nThe `convert` method of the `MessageContainer` class allows us to convert a raw\ndarkrift message to the user-defined specific one.  \n\nUsing all these we can create a client wrapper that will return already\ndeserialized messages.  \n\n```python\nfrom collections.abc import AsyncIterator\n\n\nimport darkriftpy\n\n\nclass Client:\n    def __init__(\n        self, client: darkriftpy.DarkriftClient, messages: darkriftpy.MessageContainer\n    ):\n        self._client = client\n        self._messages = messages\n\n    async def recv(self) -> darkriftpy.DarkriftMessage:\n        message = await self._client.recv()\n\n        try:\n            return self._messages.convert(message)\n        except RuntimeError:\n            # just return the message as is\n            pass\n\n        return message\n\n    async def send(self, message: darkriftpy.DarkriftMessage, reliable: bool = True) -> None:\n        await self._client.send(message, reliable)\n\n    def __aiter__(self) -> AsyncIterator[darkriftpy.DarkriftMessage]:\n        return self\n\n    async def __anext__(self) -> darkriftpy.DarkriftMessage:\n        \"\"\"\n        Returns the next message.\n\n        Stop iteration when the connection is closed.\n\n        \"\"\"\n        try:\n            return await self.recv()\n        except darkrift.ConnectionClosedError:\n            raise StopAsyncIteration()\n\n```\n\nSo now we can use the client wrapper to send and receive user specified\nmessages.\n\nLet's update the first example to use all described features.\n\n`client.py`:  \n\n```python\nimport asyncio\nimport random\nfrom collections.abc import AsyncIterator\n\nimport darkriftpy\nfrom darkriftpy.types import int32\n\n\nRND_POOL = 20\n\nMIN_INT32 = (2 ** 31) * -1\nMAX_INT32 = 2 ** 31 - 2\n\n\nmessages = darkriftpy.MessageContainer()\n\n\n@messages.add\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    items: list[int32]\n\n\n@messages.add\nclass ChoiceMessage(darkriftpy.Message, tag=2):\n    item: int32\n\n\nclass Client:\n    def __init__(\n        self, client: darkriftpy.DarkriftClient, messages: darkriftpy.MessageContainer\n    ):\n        self._client = client\n        self._messages = messages\n\n    async def recv(self) -> darkriftpy.DarkriftMessage:\n        message = await self._client.recv()\n\n        try:\n            return self._messages.convert(message)\n        except RuntimeError:\n            # just return the message as is\n            pass\n\n        return message\n\n    async def send(\n        self, message: darkriftpy.DarkriftMessage, reliable: bool = True\n    ) -> None:\n        await self._client.send(message, reliable)\n\n    def __aiter__(self) -> AsyncIterator[darkriftpy.DarkriftMessage]:\n        return self\n\n    async def __anext__(self) -> darkriftpy.DarkriftMessage:\n        \"\"\"\n        Returns the next message.\n\n        Stop iteration when the connection is closed.\n\n        \"\"\"\n        try:\n            return await self.recv()\n        except darkrift.ConnectionClosedError:\n            raise StopAsyncIteration()\n\n\nasync def process_message(message: darkriftpy.DarkriftMessage) -> None:\n    if not isinstance(message, ChoiceMessage):\n        raise ValueError(\"wrong message received\")\n\n    print(f\"the server chose the number: {message.item}\")\n\n\nasync def main():\n    try:\n        c: darkriftpy.DarkriftClient\n        async with darkriftpy.connect(\"127.0.0.1\", 4296, 4296) as c:\n            client = Client(c, messages)\n            choose_message = ChooseMessage(\n                [random.randint(MIN_INT32, MAX_INT32) for _ in range(RND_POOL)]\n            )\n\n            await client.send(choose_message)\n\n            async for message in client:\n                await process_message(message)\n\n            print(\"Connection has been closed by the server\")\n\n    except ConnectionError:\n        print(\"failed to connect to the server\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\n`server.py`:  \n\n```python\nimport asyncio\nimport random\nfrom collections.abc import AsyncIterator\n\nimport darkriftpy\nfrom darkriftpy.types import int32\n\n\nmessages = darkriftpy.MessageContainer()\n\n\n@messages.add\nclass ChooseMessage(darkriftpy.Message, tag=1):\n    items: list[int32]\n\n\n@messages.add\nclass ChoiceMessage(darkriftpy.Message, tag=2):\n    item: int32\n\n\nclass Client:\n    def __init__(\n        self, client: darkriftpy.DarkriftClient, messages: darkriftpy.MessageContainer\n    ):\n        self._client = client\n        self._messages = messages\n\n    async def recv(self) -> darkriftpy.DarkriftMessage:\n        message = await self._client.recv()\n\n        try:\n            return self._messages.convert(message)\n        except RuntimeError:\n            # just return the message as is\n            pass\n\n        return message\n\n    async def send(\n        self, message: darkriftpy.DarkriftMessage, reliable: bool = True\n    ) -> None:\n        await self._client.send(message, reliable)\n\n    def __aiter__(self) -> AsyncIterator[darkriftpy.DarkriftMessage]:\n        return self\n\n    async def __anext__(self) -> darkriftpy.DarkriftMessage:\n        \"\"\"\n        Returns the next message.\n\n        Stop iteration when the connection is closed.\n\n        \"\"\"\n        try:\n            return await self.recv()\n        except darkrift.ConnectionClosedError:\n            raise StopAsyncIteration()\n\n\nasync def handle_client(c: darkriftpy.DarkriftClient) -> None:\n    client = Client(c, messages)\n\n    message = await client.recv()\n    if not isinstance(message, ChooseMessage):\n        raise RuntimeError(\"wrong client message received\")\n\n        c.close()\n        await c.wait_closed()\n        return\n\n    while True:\n        choice_message = ChoiceMessage(random.choice(message.items))\n\n        try:\n            await client.send(choice_message)\n        except darkriftpy.ConnectionClosedError:\n            print(f\"the client({c.connection_id}) has been disconnected\")\n            await c.wait_closed()\n            return\n\n        await asyncio.sleep(1)\n\n\nasync def main():\n    async with darkriftpy.serve(handle_client, \"127.0.0.1\", 4296, 4296) as server:\n        await asyncio.Future()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\n\n## TODO\n\n [  ] - Add multiprocessing support to improve performance and scalability\n (Fork + Multiplexing I/O).  \n [  ] - Cover the codebase with tests ;).  \n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/dobryak/darkriftpy",
    "keywords": "",
    "license": "GPL3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "darkriftpy",
    "package_url": "https://pypi.org/project/darkriftpy/",
    "platform": "",
    "project_url": "https://pypi.org/project/darkriftpy/",
    "project_urls": {
      "Homepage": "https://github.com/dobryak/darkriftpy"
    },
    "release_url": "https://pypi.org/project/darkriftpy/0.1.0/",
    "requires_dist": [
      "pybinio (~=0.1.0)"
    ],
    "requires_python": ">=3.9",
    "summary": "DarkriftPy is a Python implementation of DarkRift2",
    "version": "0.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11597813,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4dfdfeea8ae4fc2ca428dca099cd6c932d31d249d96d19ea788fe44512e52db8",
          "md5": "94e155d09dd10e95e82a473d788b96d7",
          "sha256": "9607b43d0b79f1934cae44a03a0c762d98b4de614a5bbf6b2e9c424d8bb4e5c8"
        },
        "downloads": -1,
        "filename": "darkriftpy-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "94e155d09dd10e95e82a473d788b96d7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 22691,
        "upload_time": "2021-09-30T22:18:54",
        "upload_time_iso_8601": "2021-09-30T22:18:54.816977Z",
        "url": "https://files.pythonhosted.org/packages/4d/fd/feea8ae4fc2ca428dca099cd6c932d31d249d96d19ea788fe44512e52db8/darkriftpy-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4dfdfeea8ae4fc2ca428dca099cd6c932d31d249d96d19ea788fe44512e52db8",
        "md5": "94e155d09dd10e95e82a473d788b96d7",
        "sha256": "9607b43d0b79f1934cae44a03a0c762d98b4de614a5bbf6b2e9c424d8bb4e5c8"
      },
      "downloads": -1,
      "filename": "darkriftpy-0.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "94e155d09dd10e95e82a473d788b96d7",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.9",
      "size": 22691,
      "upload_time": "2021-09-30T22:18:54",
      "upload_time_iso_8601": "2021-09-30T22:18:54.816977Z",
      "url": "https://files.pythonhosted.org/packages/4d/fd/feea8ae4fc2ca428dca099cd6c932d31d249d96d19ea788fe44512e52db8/darkriftpy-0.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}