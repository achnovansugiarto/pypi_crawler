{
  "info": {
    "author": "TNO MPC Lab",
    "author_email": "mpclab@tno.nl",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering :: Artificial Intelligence",
      "Topic :: Scientific/Engineering :: Information Analysis",
      "Topic :: Security :: Cryptography",
      "Typing :: Typed"
    ],
    "description": "# TNO MPC Lab - MPyC - Secure Learning\n\nThe TNO MPC lab consists of generic software components, procedures, and functionalities developed and maintained on a regular basis to facilitate and aid in the development of MPC solutions. The lab is a cross-project initiative allowing us to integrate and reuse previously developed MPC functionalities to boost the development of new protocols and solutions.\n\nThe package tno.mpc.mpyc.secure_learning is part of the TNO Python Toolbox.\n\nThis library has been developed with funding from different projects.\n\nIn particular, the basic building blocks and an initial version of this library have been developed within the VP AI program (2018) and the ERP AI program (2019), including an SVM model and initial versions of other models.\n\nThe current secure logistic regression model has been developed within the TKI HTSM LANCELOT project, a research collaboration between [TNO](https://www.tno.nl/en/), [IKNL](https://iknl.nl/) and [Janssen](http://www.janssen.com/).\n\nLANCELOT is partly funded by PPS-surcharge for Research and Innovation of the Dutch Ministry of Economic Affairs and Climate Policy.\n\nThe secure lasso regression model has been developed in the BigMedilytics project. This project has received funding from the European Unionâ€™s Horizon 2020 research and innovation program under Grant Agreement No. 780495.\n\nIn collaboration with the MPC Lab, BigMedilytics, LANCELOT, [NLAIC](https://nlaic.com/en/about-nl-aic/) and [Appl.AI](https://www.tno.nl/en/focus-areas/artificial-intelligence/), contributed to a restructuring of the codebase to ensure a generic reusable library which can be expanded with other models and functionalities.\n\n*Limitations in (end-)use: the content of this software package may solely be used for applications that comply with international export control laws.*  \n*This implementation of cryptographic software has not been audited. Use at your own risk.*\n\n## Content Explanation\n\nImplementation based on Secure Multi-Party Computation (MPC) for training and evaluating of several machine learning models.\nIt makes use of the [MPyC](https://pypi.org/project/mpyc/) framework.\n\n## Features\n\nThe library implements secure versions of popular machine learning methods in the form of MPC protocols.\nThe underlying MPC functionalities are provided by the MPyC framework.\n\nThe library contains both regression and classification algorithms.\n\nIn particular, linear regression is implemented, with l2-penalty (Ridge), l1-penalty (Lasso), or a combination of both (ElasticNets).\nFor what concerns classification problems, Support Vector Machines (SVM) are implemented, as well as logistic \"regression\".\nFor the latter, the user can choose between an accurate implementation of the logistic function, and an approximated, but faster version.\nl1 and/or l2 penalties can also be selected.\n\nThe library allows users to choose either the gradient-descent or the SAG solver in order to train the implemented models.\n\n## Limitations\n\nCurrently, no code is provided to securely apply the trained models.\n\n## Documentation\n\nDocumentation of the tno.mpc.mpyc.secure_learning package can be found [here](https://docs.mpc.tno.nl/mpyc/secure_learning/1.1.1).\n\n## Install\n\nEasily install the tno.mpc.mpyc.secure_learning package using pip:\n```console\n$ python -m pip install tno.mpc.mpyc.secure_learning\n```\n\n### Note:\nA significant performance improvement can be achieved by installing the GMPY2 library.\n```console\n$ python -m pip install 'tno.mpc.mpyc.secure_learning[gmpy]'\n```\n\nIf you wish to run the tests you can use:\n```console\n$ python -m pip install 'tno.mpc.mpyc.secure_learning[tests]'\n```\n\n## Usage\n\nRun these examples as `python example.py --no-log` to suppress the MPyC barrier logging. Append the argument `-M 3` to simulate a three-party protocol.\n\n### Example Usage\n\n<details>\n<summary><b>Click here for an example of securely training a simple linear regression model with L2 penalty (Ridge).</b></summary>\n\n\n> `example.py`\n> ```python\n> import numpy as np\n> from mpyc.runtime import mpc\n> from sklearn import datasets\n> from sklearn.linear_model import Ridge as RidgeSK\n> \n> import tno.mpc.mpyc.secure_learning.test.plaintext_utils.plaintext_objective_functions as plain_obj\n> from tno.mpc.mpyc.secure_learning import PenaltyTypes, Ridge, SolverTypes\n> \n> # Notice that we use the entire dataset to train the model\n> n_samples = 50\n> n_features = 5\n> # Fixed random state for reproducibility\n> random_state = 3\n> tolerance = 1e-4\n> \n> secnum = mpc.SecFxp(l=64, f=32)\n> \n> \n> def get_mpc_data(X, y):\n>     X_mpc = [[secnum(x, integral=False) for x in row] for row in X.tolist()]\n>     y_mpc = [secnum(y, integral=False) for y in y.tolist()]\n>     return X_mpc, y_mpc\n> \n> \n> def distribute_data_over_players(X_mpc, y_mpc):\n>     X_shared = [mpc.input(row, senders=0) for row in X_mpc]\n>     y_shared = mpc.input(y_mpc, senders=0)\n>     return X_shared, y_shared\n> \n> \n> async def ridge_regression_example():\n>     print(\"Ridge regression with gradient descent method\")\n>     alpha = 0.2\n> \n>     # Create regression dataset\n>     X, y = datasets.make_regression(\n>         n_samples=n_samples,\n>         n_features=n_features,\n>         noise=25.0,\n>         random_state=random_state,\n>     )\n>     X = np.array(X)\n>     y = np.array(y)\n>     X_mpc, y_mpc = get_mpc_data(X, y)\n> \n>     async with mpc:\n>         X_shared, y_shared = distribute_data_over_players(X_mpc, y_mpc)\n> \n>     # Train secure model\n>     model = Ridge(solver_type=SolverTypes.GD, alpha=alpha)\n>     async with mpc:\n>         coef_ = await model.compute_coef_mpc(\n>             X_shared,\n>             y_shared,\n>             tolerance=tolerance,\n>         )\n> \n>     # Results of secure model\n>     objective = plain_obj.objective(X, y, coef_, \"linear\", PenaltyTypes.L2, alpha)\n>     print(\"Securely obtained coefficients:\", coef_)\n>     print(\"* objective:\", objective)\n> \n>     # Train plaintext model\n>     model_sk = RidgeSK(\n>         alpha=len(X) * alpha,\n>         solver=\"saga\",\n>         random_state=random_state,\n>         fit_intercept=True,\n>     )\n>     model_sk.fit(X, y)\n> \n>     # Results of plaintext model\n>     coef_sk = np.append([model_sk.intercept_], model_sk.coef_).tolist()\n>     objective_sk = plain_obj.objective(X, y, coef_sk, \"linear\", PenaltyTypes.L2, alpha)\n>     print(\"Sklearn obtained coefficients: \", coef_sk)\n>     print(\"* objective:\", objective_sk)\n> \n> \n> if __name__ == \"__main__\":\n>     mpc.run(ridge_regression_example())\n> ```\n\n</details>\n\n<details>\n<summary><b>Click here for an example of securely training a logistic regression model with L1 penalty.</b></summary>\n\n> `example.py`\n> ```python\n> import numpy as np\n> from mpyc.runtime import mpc\n> from sklearn import datasets\n> from sklearn.linear_model import LogisticRegression as LogisticRegressionSK\n> \n> import tno.mpc.mpyc.secure_learning.test.plaintext_utils.plaintext_objective_functions as plain_obj\n> from tno.mpc.mpyc.secure_learning import (\n>     ClassWeightsTypes,\n>     ExponentiationTypes,\n>     Logistic,\n>     PenaltyTypes,\n>     SolverTypes,\n> )\n> \n> # Notice that we use the entire dataset to train the model\n> n_samples = 50\n> n_features = 5\n> # Fixed random state for reproducibility\n> random_state = 3\n> tolerance = 1e-4\n> \n> \n> secnum = mpc.SecFxp(l=64, f=32)\n> \n> \n> def get_mpc_data(X, y):\n>     X_mpc = [[secnum(x, integral=False) for x in row] for row in X.tolist()]\n>     y_mpc = [secnum(y, integral=False) for y in y.tolist()]\n>     return X_mpc, y_mpc\n> \n> \n> def distribute_data_over_players(X_mpc, y_mpc):\n>     X_shared = [mpc.input(row, senders=0) for row in X_mpc]\n>     y_shared = mpc.input(y_mpc, senders=0)\n>     return X_shared, y_shared\n> \n> \n> def sklearn_class_weights_dict(y):\n>     n_class_1 = sum([((y_i + 1) / 2) for y_i in y])\n>     n_class_0 = len(y) - n_class_1\n> \n>     w_0 = len(y) / (2 * n_class_0)\n>     w_1 = len(y) / (2 * n_class_1)\n> \n>     return {-1: w_0, 1: w_1}\n> \n> \n> async def logistic_regression_example():\n>     print(\n>         \"Classification (Logistic regression) with l1 penalty, with gradient descent method\"\n>     )\n>     alpha = 0.1\n> \n>     # Create classification dataset\n>     X, y = datasets.make_classification(\n>         n_samples=n_samples,\n>         n_features=n_features,\n>         n_informative=1,\n>         n_redundant=0,\n>         n_classes=2,\n>         n_clusters_per_class=1,\n>         random_state=random_state,\n>         shift=0,\n>         weights=[0.25, 0.75],\n>     )\n>     # Transform labels from {0, 1} to {-1, +1}.\n>     y = [-1 if x == 0 else 1 for x in y]\n>     X = np.array(X)\n>     y = np.array(y)\n>     X_mpc, y_mpc = get_mpc_data(X, y)\n> \n>     async with mpc:\n>         X_shared, y_shared = distribute_data_over_players(X_mpc, y_mpc)\n> \n>     # Train secure model with approximation of logistic function (faster, less accurate)\n>     model = Logistic(\n>         solver_type=SolverTypes.GD,\n>         exponentiation=ExponentiationTypes.APPROX,\n>         penalty=PenaltyTypes.L1,\n>         alpha=alpha,\n>         class_weights_type=ClassWeightsTypes.BALANCED,\n>     )\n>     async with mpc:\n>         coef_approx = await model.compute_coef_mpc(\n>             X_shared, y_shared, tolerance=tolerance\n>         )\n> \n>     class_weights_dict = model.reveal_class_weights(y_shared)\n> \n>     # Results of secure model (approximated logistic function)\n>     objective_approx = plain_obj.objective(\n>         X, y, coef_approx, \"logistic\", PenaltyTypes.L1, alpha, class_weights_dict\n>     )\n>     print(\n>         \"Securely obtained coefficients (approximated exponentiation):\",\n>         coef_approx,\n>     )\n>     print(\"* objective:\", objective_approx)\n>     print(\"Class weights dictionary:\", class_weights_dict)\n>     # Train secure model with exact logistic function (slower, more accurate)\n>     model = Logistic(\n>         solver_type=SolverTypes.GD,\n>         exponentiation=ExponentiationTypes.EXACT,\n>         penalty=PenaltyTypes.L1,\n>         alpha=alpha,\n>         class_weights_type=ClassWeightsTypes.BALANCED,\n>     )\n>     async with mpc:\n>         coef_exact = await model.compute_coef_mpc(\n>             X_shared, y_shared, tolerance=tolerance\n>         )\n> \n>     # Results of secure model (exact logistic function)\n>     objective_exact = plain_obj.objective(\n>         X,\n>         y,\n>         coef_exact,\n>         \"logistic\",\n>         PenaltyTypes.L1,\n>         alpha,\n>         class_weights_dict,\n>     )\n>     print(\n>         \"Securely obtained coefficients (exact exponentiation):       \",\n>         coef_exact,\n>     )\n>     print(\"* objective:\", objective_exact)\n>     print(\"Class weights dictionary:\", class_weights_dict)\n>     # Train plaintext model\n>     model_sk = LogisticRegressionSK(\n>         solver=\"saga\",\n>         random_state=random_state,\n>         fit_intercept=True,\n>         penalty=\"l1\",\n>         C=1 / (len(X) * alpha),\n>         class_weight=\"balanced\",\n>     )\n> \n>     class_weights_dict_sk = sklearn_class_weights_dict(y)\n>     model_sk.fit(X, y)\n>     coef_sk = np.append([model_sk.intercept_], model_sk.coef_).tolist()\n> \n>     # Results of plaintest model\n>     objective_sk = plain_obj.objective(\n>         X, y, coef_sk, \"logistic\", PenaltyTypes.L1, alpha\n>     )\n>     print(\"Sklearn obtained coefficients:                               \", coef_sk)\n>     print(\"* objective:\", objective_sk)\n> \n> \n> if __name__ == \"__main__\":\n>     mpc.run(logistic_regression_example())\n> ```\n\n</details>\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://pypi.org/project/tno.mpc.mpyc.secure_learning/#files",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://mpc.tno.nl/",
    "keywords": "TNO,MPC,multi-party computation,secure learning,regression,lasso,logistic,SVM,ridge",
    "license": "Apache License, Version 2.0",
    "maintainer": "TNO MPC Lab",
    "maintainer_email": "mpclab@tno.nl",
    "name": "tno.mpc.mpyc.secure-learning",
    "package_url": "https://pypi.org/project/tno.mpc.mpyc.secure-learning/",
    "platform": "any",
    "project_url": "https://pypi.org/project/tno.mpc.mpyc.secure-learning/",
    "project_urls": {
      "Documentation": "https://docs.mpc.tno.nl/mpyc/secure_learning/1.1.1",
      "Download": "https://pypi.org/project/tno.mpc.mpyc.secure_learning/#files",
      "Homepage": "https://mpc.tno.nl/",
      "Source Code": "https://github.com/TNO-MPC/mpyc.secure_learning"
    },
    "release_url": "https://pypi.org/project/tno.mpc.mpyc.secure-learning/1.1.1/",
    "requires_dist": [
      "mpyc",
      "numpy",
      "tno.mpc.mpyc.exponentiation (>=1.6.0)",
      "tno.mpc.mpyc.stubs (>=0.4.2)",
      "typing-extensions",
      "scikit-learn",
      "gmpy2 (>=2.1.0) ; extra == 'gmpy'",
      "numpy (>=1.21) ; extra == 'tests'",
      "pytest ; extra == 'tests'",
      "pytest-asyncio ; extra == 'tests'"
    ],
    "requires_python": "",
    "summary": "Machine learning using Secure Multi-Party Computation",
    "version": "1.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13874942,
  "releases": {
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5b6a841e4eef1ae529d16f8b525d065c930ee12d80f0f168fdc9b8b5868a2816",
          "md5": "e4dcfd13b051b5da6964416454de97ee",
          "sha256": "ba7aefbfe826bebd1cc8e966b6865f68541f36d9f8515127dc4f22864c849ba7"
        },
        "downloads": -1,
        "filename": "tno.mpc.mpyc.secure_learning-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e4dcfd13b051b5da6964416454de97ee",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 57737,
        "upload_time": "2021-10-22T16:35:39",
        "upload_time_iso_8601": "2021-10-22T16:35:39.345576Z",
        "url": "https://files.pythonhosted.org/packages/5b/6a/841e4eef1ae529d16f8b525d065c930ee12d80f0f168fdc9b8b5868a2816/tno.mpc.mpyc.secure_learning-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6d8cda3170541baa345d6442fb593af7a8537d60f561fd837ec2fcade429e05d",
          "md5": "3ae015f387120edaf1fe0de1bf7ee26b",
          "sha256": "8d8db0f8dbd95909228defca2331d2dbe4e1a712b7b024e86000e9333b31a1a6"
        },
        "downloads": -1,
        "filename": "tno.mpc.mpyc.secure_learning-0.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3ae015f387120edaf1fe0de1bf7ee26b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 55115,
        "upload_time": "2021-12-28T15:41:43",
        "upload_time_iso_8601": "2021-12-28T15:41:43.210597Z",
        "url": "https://files.pythonhosted.org/packages/6d/8c/da3170541baa345d6442fb593af7a8537d60f561fd837ec2fcade429e05d/tno.mpc.mpyc.secure_learning-0.2.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "30c3334257b3f06694b2c2c0a9b2e1fff3b608a821c3da7962c0981f1a01f907",
          "md5": "dd5769d4542835849144105bdef864c6",
          "sha256": "4b6fff14f1f0933ac56d9e2ce8cd9b40427b6010b12e58f9c7a4084f22eb24a7"
        },
        "downloads": -1,
        "filename": "tno.mpc.mpyc.secure_learning-1.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "dd5769d4542835849144105bdef864c6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 56750,
        "upload_time": "2022-05-20T06:51:52",
        "upload_time_iso_8601": "2022-05-20T06:51:52.614349Z",
        "url": "https://files.pythonhosted.org/packages/30/c3/334257b3f06694b2c2c0a9b2e1fff3b608a821c3da7962c0981f1a01f907/tno.mpc.mpyc.secure_learning-1.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "30c3334257b3f06694b2c2c0a9b2e1fff3b608a821c3da7962c0981f1a01f907",
        "md5": "dd5769d4542835849144105bdef864c6",
        "sha256": "4b6fff14f1f0933ac56d9e2ce8cd9b40427b6010b12e58f9c7a4084f22eb24a7"
      },
      "downloads": -1,
      "filename": "tno.mpc.mpyc.secure_learning-1.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "dd5769d4542835849144105bdef864c6",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 56750,
      "upload_time": "2022-05-20T06:51:52",
      "upload_time_iso_8601": "2022-05-20T06:51:52.614349Z",
      "url": "https://files.pythonhosted.org/packages/30/c3/334257b3f06694b2c2c0a9b2e1fff3b608a821c3da7962c0981f1a01f907/tno.mpc.mpyc.secure_learning-1.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}