{
  "info": {
    "author": "Alex Tkachenko",
    "author_email": "preusx.dev@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Utilities"
    ],
    "description": "# Django Legate\n\nSimple to django guardian, but defines user permissions for models based on some general relation.\n\nFor example: Company -> Blog post. Add a `blog.change_post` permission to User+Company to add an ability for user to edit all companies block posts.\n\n## Installation\n\n```sh\npip install px-django-legate\n```\n\nDepends on: [px-django-combinable-groups](https://pypi.org/project/px-django-combinable-groups/).\n\nIn `settings.py`:\n\n```python\nINSTALLED_APPS += [\n  # ...\n  'django.contrib.auth',\n  # ...\n  # Depends on:\n  'pxd_tree.adjacency_list',\n  'pxd_combinable_groups',\n  'pxd_legate',\n]\n\nPXD_LEGATE = {\n  # Will automatically add content types to admin interface.\n  'ADMIN_REGISTER_CONTENT_TYPE': True,\n  # Will automatically add permissions to admin interface.\n  'ADMIN_REGISTER_PERMISSION': True,\n}\n```\n\n## Usage\n\n### Assign permissions\n\n```python\nfrom pxd_legate.services import assigner\nfrom pxd_combinable_groups.services import permissions_collector\n\n\n# To add additional access capabilities to user for some \"root\" objects:\naccesses = assigner.add_access(\n  # User identifier\n  user.id,\n  # Any number of objects to add access to\n  [company_1, company_2],\n  # List of additional permissions to add. Optional.\n  permission_ids=permissions_collector.keys_to_ids((\n    'blog.view_post', 'blog.change_post'\n  )),\n  # You may also add groups, not only the permissions. Optional.\n  group_ids=[1, 2, 3],\n)\n\n# Opposite to adding access, you may also partially withdraw it:\naccesses = assigner.withdraw_access(\n  user.id,\n  [company_1],\n  permission_ids=[4, 5], # Optional\n  group_ids=None, # Optional\n)\n\n# To completely remove user access to some root object there is `remove_access`\n# method:\nassigner.remove_access(user.id, [company_2])\n\n# This method sets user permissions \"strictly\" to a provided values:\naccesses = assigner.set_access(\n  user.id,\n  [company_1],\n  # Whatever the permissions user had before, now he will have only a\n  # 'blog.view_post' permission.\n  # Optional. But be careful! Passing an empty list `[]` will remove\n  # all permissions at all. Only `None` will tell method that there is\n  # no need to do something with `permission_ids`.\n  permission_ids=permissions_collector.keys_to_ids(['blog.view_post']),\n  # Same as for `permission_ids` goes here.\n  # With such a value we removing groups from access object entirely.\n  group_ids=[],\n  # For such value groups wil stay untouched.\n  group_ids=None,\n)\n```\n\n**Be careful!** Method `set_access` optional parameters are optional only if they're `None`. Empty list `[]` is also a value. Check comments higher.\n\n### Check permissions\n\nChecker service provides `Checker` class. You will need to create separate checker class for every model your'e going to check access for.\n\n```python\nfrom pxd_legate.services import checker\nfrom pxd_combinable_groups.services import permissions_collector\n\n\nposts_checker = checker.Checker(\n  # Model for what your'e going to check user's access.\n  Post,\n  # Full path to a root object to check access against.\n  'department__company',\n  # Root model to check access info. Optional.\n  root_model=Company,\n  # Special comparator object. Instance of `checker.CheckCMP`.\n  # It will be used to compare passed permission_ids with existing ones.\n  # There are 2 built in:\n  # - `checker.ALL_CMP` - User must have all permission_ids.\n  # - `checker.ANY_CMP` - User must have any of provided permission_ids.\n  cmp=checker.ALL_CMP,\n  # Determines whether the user personal permissions should be checked.\n  # So in case of user has it's own permission not to add additional\n  # check mechanics into the query.\n  # It's `True` by default, but there might be cases when there is no such\n  # check required.\n  should_check_global=True,\n)\n\n# To check whether the user can do something with some object:\ncan_edit = posts_checker.for_object(\n  # Object to check access to.\n  some_post,\n  # User.\n  user,\n  # Permission ids to check user's abilities. Optional.\n  permission_ids=permissions_collector.keys_to_ids(['blog.change_post']),\n  # For cases with a different comparison method you may provide a custom\n  # comparator. Event without `permission_ids` at all.\n  cmp=None,\n)\n\n# QuerySet can also be filtered base on the user's ability to do\n# something with it:\nonly_editable = posts_checker.for_queryset(\n  # QuerySet to filter.\n  Post.objects.all(),\n  # User.\n  user,\n  # Permission ids to check user's abilities. Optional.\n  permission_ids=permissions_collector.keys_to_ids(['blog.change_post']),\n  # For cases with a different comparison method you may provide a custom\n  # comparator. Event without `permission_ids` at all.\n  cmp=None,\n  # It will be passed to a `with_annotation` method(see next).\n  annotation_field_name=None,\n)\n```\n\nUnderneath the `for_queryset` method checker uses `with_annotation`.\nIt could be used for more complex situations.\nFor example some model has two root models, where user access can be defined.\n\n```python\nposts_department_checker = checker.Checker(\n  Post, 'department', root_model=Department,\n)\ncompany_field, query = posts_checker.with_annotation(\n  Post.objects.all(),\n  user,\n  permission_ids=permissions_collector.keys_to_ids(['blog.change_post']),\n  cmp=None,\n  # Name of the field that check annotation will be inserted into.\n  # Could be empty. In that case it will be auto-generated.\n  annotation_field_name=None,\n)\ndepartment_field, query = posts_department_checker.with_annotation(\n  # Query from above will again be \"checked\".\n  query,\n  user,\n  permission_ids=permissions_collector.keys_to_ids(['blog.change_post']),\n)\n\nonly_editable = query.filter(\n  # It has access through the company.\n  models.Q(**{company_field: True})\n  | # Or\n  # Through it's department.\n  models.Q(**{department_field: True})\n)\n```\n\n#### Checkers registry\n\nTo make your life easier there is a checkers Registry class **since [`0.1.1`]**.\n\nIt combines separate checker calls into a single object with identical interface.\n\nRegistry can be used for multiple models and also there could be any number of checkers to run for a particular model.\n\nRegistry class has the same methods `.for_object`, `.for_queryset`, `.with_annotation` as any checker has. The difference is that registry will combine all checkers to check user's access.\n\n```python\nfrom pxd_legate.services import checker, registry\n\nall_registry = registry.Registry(\n  # Comparators for registry has similar interface as checkers CMP objects,\n  # but they are different in terms of passed values, so be careful.\n  # By default any passed checker makes object accessible:\n  cmp=registry.ANY_CMP,\n  # Should registry raise exception if there is no checker available for\n  # currently passed object's model.\n  # By default mechanics ignores that situation and marks all objects as\n  # accessible.\n  raise_noncheckable=False,\n)\n\n# Adding a posts checker to registry.\nposts_checker = all_registry.add(checker.Checker(\n  Post,\n  'department__company',\n  root_model=Company,\n))\n# Another posts checker added. Now they both will check\nposts_department_checker = all_registry.add(checker.Checker(\n  Post, 'department', root_model=Department,\n))\n# Added checker for other model. There will be no conflicts.\n# Registry will use only the checkers for a currently passed model for any\n# access check run.\ndepartment_checker = all_registry.add(checker.Checker(\n  Department, 'company', root_model=Company,\n))\n\n# Here both previously registered checkers for posts will run and if any\n# of it will be successful then that object will be resolved as accessible.\nposts = all_registry.for_queryset(\n  Post.objects.all(),\n  user,\n  permission_ids=permissions_collector.keys_to_ids(['blog.change_post']),\n)\n# `department_checker` will run here.\ndepartments = all_registry.for_queryset(\n  Department.objects.all(),\n  user,\n  permission_ids=permissions_collector.keys_to_ids(['organization.change_department']),\n)\n\n# As there is no checkers for the Company model there is nothing will\n# happen here and the return value will be the same queryset that was\n# passed down.\ncompanies = all_registry.for_queryset(\n  Company.objects.all(),\n  user,\n  permission_ids=permissions_collector.keys_to_ids(['organization.change_company']),\n  # In case when registry was registered with `raise_noncheckable` as True, or\n  # same parameter passed to check method with True value - error will raise.\n  # Here will be used value passed on registry creation.\n  raise_noncheckable=None,\n)\n```\n\n### Get user's permission\n\nEach checker and registry object has a `get_permissions` methods that returns a set of user available permission identifiers.\n\n```python\nfrom pxd_legate.services import checker, registry\n\nall_registry = registry.Registry()\nposts_checker = all_registry.add(checker.Checker(\n  Post, 'department__company', root_model=Company,\n))\n\n# This will call `get_permissions` method on all checkers that registered\n# for an object's model.\nall_registry.get_permissions(post_1, user_object)\n# > {1,2,3,4}\n\n# If there is no checkers available empty set will be returned.\nall_registry.get_permissions(department_1, user_object)\n# > set()\n```\n\nAlso there are a utilities to get user permissions info for a root objects.\n\n```python\nfrom pxd_legate.services import gatherer\n\n# There are utils to gather user's permissions for root objects.\n\n# This will find all ObjectAccess objects:\ngatherer.objects_for_user(\n  # User object to gather for.\n  user_object,\n  # Root objects list.\n  [any_root_obj_1, any_root_obj_2, ...],\n)\n# > [ObjectAccess(), ObjectAccess()]\n\n# And this one will collect all user's permission ids for any type of objects.\ngatherer.permissions_for_user(\n  # User object to gather for.\n  user_object,\n  # Root objects list.\n  [any_root_obj_1, any_root_obj_2, ...],\n)\n# > [1,2,3,4,...]\n```\n\n### Access manual change\n\nIf your going to change `ObjectAccess` manually then after that you must gather actual permissions that it has.\n\nIn Administration panel it's already done.\n\nThere is a simple service for that:\n\n```python\nfrom pxd_legate.services import gatherer\n\nany_object = ObjectAccess.objects.first()\n\n# Some changes happening...\n\ngatherer.gather_object_accesses(\n  # You should gather accesses in bulk. It's faster.\n  [any_object]\n)\n```\n# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [0.1.4]\n### Fixed\n- Global permissions check in Checker now uses default auth backends.\n\n## [0.1.3]\n### Added\n- Checker permission gatherers.\n\n## [0.1.2]\n### Added\n- Permissions gatherers.\n\n## [0.1.1]\n### Added\n- Checkers Registry mechanics.\n\n## [0.1.0]\nInitial version.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "px-django-legate",
    "package_url": "https://pypi.org/project/px-django-legate/",
    "platform": null,
    "project_url": "https://pypi.org/project/px-django-legate/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/px-django-legate/0.1.4/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Django permissions delegation utils.",
    "version": "0.1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14921154,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cb0f8d070ce7bdd34b81bf83f76cf022198e98bf1d1c170ca4f85b3c094ce0f5",
          "md5": "911cb149fc00e52d4ca90726f5ac6949",
          "sha256": "ac801bf156085806226e1b13fe76e0c3433f1bc9b00baa73b6a777f457abe32d"
        },
        "downloads": -1,
        "filename": "px-django-legate-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "911cb149fc00e52d4ca90726f5ac6949",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 12428,
        "upload_time": "2022-08-05T09:59:37",
        "upload_time_iso_8601": "2022-08-05T09:59:37.802239Z",
        "url": "https://files.pythonhosted.org/packages/cb/0f/8d070ce7bdd34b81bf83f76cf022198e98bf1d1c170ca4f85b3c094ce0f5/px-django-legate-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a1e38275cca439de00fd3b455428f79e7176b4b4be8691442143c050f051f207",
          "md5": "d2eb3008675c6f19157ac687ef547d19",
          "sha256": "8ceaabda584fe8358741603050cf19b10629b8753d0ab7ca2b17a1dfea3ca579"
        },
        "downloads": -1,
        "filename": "px-django-legate-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d2eb3008675c6f19157ac687ef547d19",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 14161,
        "upload_time": "2022-08-11T10:38:25",
        "upload_time_iso_8601": "2022-08-11T10:38:25.476885Z",
        "url": "https://files.pythonhosted.org/packages/a1/e3/8275cca439de00fd3b455428f79e7176b4b4be8691442143c050f051f207/px-django-legate-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7e60c3be3dbee0e7d903a671aad58d72b7afd2a78c0f4754344746d2eb71026f",
          "md5": "efc708b64b595a69889168275ba7854b",
          "sha256": "5d2f243d2ed2c97b44ba9f8470ccbb765377f241af03a618fe9f0463a8e075c8"
        },
        "downloads": -1,
        "filename": "px-django-legate-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "efc708b64b595a69889168275ba7854b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 14872,
        "upload_time": "2022-08-12T11:36:58",
        "upload_time_iso_8601": "2022-08-12T11:36:58.626161Z",
        "url": "https://files.pythonhosted.org/packages/7e/60/c3be3dbee0e7d903a671aad58d72b7afd2a78c0f4754344746d2eb71026f/px-django-legate-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "48b82928503dafcc94704d1ed4bb364efa6ed642b4e0d5f36101c265f6d7985c",
          "md5": "34e644e9ed5a2a467f299509a302cc14",
          "sha256": "7a7b06bd3e01e68e338cfa7d33ff958f9216e2cb294bc07c05c46247220204a6"
        },
        "downloads": -1,
        "filename": "px-django-legate-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "34e644e9ed5a2a467f299509a302cc14",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 15094,
        "upload_time": "2022-08-12T15:33:50",
        "upload_time_iso_8601": "2022-08-12T15:33:50.795465Z",
        "url": "https://files.pythonhosted.org/packages/48/b8/2928503dafcc94704d1ed4bb364efa6ed642b4e0d5f36101c265f6d7985c/px-django-legate-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f02d0270a262528544778d0d95e1d36d28af36a929b07d803620ae55ba56fe77",
          "md5": "14d29bc02ca910dd7935e69b11aabfbf",
          "sha256": "e5f6759e0e5d9dbd7693c6244ee2a3d2dcf2c86eb470906c423cac69ce379fed"
        },
        "downloads": -1,
        "filename": "px-django-legate-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "14d29bc02ca910dd7935e69b11aabfbf",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 14891,
        "upload_time": "2022-08-29T07:04:18",
        "upload_time_iso_8601": "2022-08-29T07:04:18.295208Z",
        "url": "https://files.pythonhosted.org/packages/f0/2d/0270a262528544778d0d95e1d36d28af36a929b07d803620ae55ba56fe77/px-django-legate-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f02d0270a262528544778d0d95e1d36d28af36a929b07d803620ae55ba56fe77",
        "md5": "14d29bc02ca910dd7935e69b11aabfbf",
        "sha256": "e5f6759e0e5d9dbd7693c6244ee2a3d2dcf2c86eb470906c423cac69ce379fed"
      },
      "downloads": -1,
      "filename": "px-django-legate-0.1.4.tar.gz",
      "has_sig": false,
      "md5_digest": "14d29bc02ca910dd7935e69b11aabfbf",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 14891,
      "upload_time": "2022-08-29T07:04:18",
      "upload_time_iso_8601": "2022-08-29T07:04:18.295208Z",
      "url": "https://files.pythonhosted.org/packages/f0/2d/0270a262528544778d0d95e1d36d28af36a929b07d803620ae55ba56fe77/px-django-legate-0.1.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}