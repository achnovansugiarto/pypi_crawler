{
  "info": {
    "author": "Gael Lederrey",
    "author_email": "gael.lederrey@epfl.ch",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Natural Language :: English",
      "Programming Language :: Python :: 3"
    ],
    "description": "[![Development Status](https://img.shields.io/badge/Development%20Status-3%20--%20Alpha-green)](https://pypi.org/search/?c=Development+Status+%3A%3A+3+-+Alpha)\r\n[![PyPi Shield](https://img.shields.io/pypi/v/DATGAN.svg)](https://pypi.python.org/pypi/DATGAN)\r\n[![Downloads](https://pepy.tech/badge/datgan)](https://pepy.tech/project/datgan)\r\n\r\n# DATGAN\r\n\r\nDirected Acyclic Tabular GAN (**DATGAN**) for integrating expert knowledge in synthetic tabular data generation.\r\n\r\n- License: [GPLv3](https://github.com/glederrey/DATGAN/blob/master/LICENSE)\r\n- Development Status: [Alpha](https://pypi.org/search/?q=&o=&c=Development+Status+%3A%3A+3+-+Alpha)\r\n- Homepage: https://github.com/glederrey/DATGAN\r\n\r\n## Overview\r\n\r\nThe **DATGAN** is a synthesizer for tabular data. It uses LSTM cells to generate synthetic data for continuous and\r\ncategorical variable types. In addition, a Directed Acyclic Graph (DAG) can be provided to represent the structure\r\nbetween the variables and help the model perform better. This model integrates two types of conditionality: rejection by\r\nsampling and conditional inputs.\r\n\r\n## Requirements\r\n\r\nThe current version of the **DATGAN** works with Python>=3.7 and Tensorflow==2.8.0. Previous versions of Python have not\r\nbeen tested and are thus blocked. Therefore, we recommend the user set up\r\na [virtualenv](https://virtualenv.pypa.io/en/latest/). An installation guide is provided to help with the installation\r\nof the library.\r\n\r\n## Installation\r\n\r\nWe provide a [complete installation guide](https://github.com/glederrey/DATGAN/blob/master/INSTALL.md) using conda and\r\nsetting up a virtualenv. Please follow this guide to properly set up everything and ensure that you can use the DATGAN\r\nas intended.\r\n\r\n## Testing the DATGAN\r\n\r\nOnce you have followed the installation guide, you can clone this repository and use the notebooks provided in the\r\nfolder [example](https://github.com/glederrey/DATGAN/tree/main/example) to train the **DATGAN** and use the evaluation\r\nmetrics provided in this repository.\r\n\r\n# Data Format\r\n\r\n## Input\r\n\r\nThe **DATGAN** uses tabular data loaded with the `pandas` library. This table must follow these rules:\r\n\r\n- has no missing values\r\n- has columns of types `int`, `float`, `str` or `bool`.\r\n- each column contains data of only one type.\r\n\r\n**NOTE**: It is crucial to identify continuous and categorical variables/columns. A general rule of thumb is that any\r\ndiscrete distributions with a large number of categories should be considered continuous and then rounded.\r\n\r\n## Output\r\n\r\nThe output of the **DATGAN** is a table of synthetic data with the same columns as the input table and as many rows as\r\nrequested.\r\n\r\n# Tutorial\r\n\r\nThis short tutorial will guide you through a series of steps that will help you get started with the most basic usage\r\nof **DATGAN** to generate samples from a given dataset.\r\n\r\nWhile all the methods are explained below, you can use the built-in helper function to get a reminder of the different\r\nfunctions used in this library. Just run the following lines:\r\n\r\n```python\r\nimport datgan\r\n\r\nhelp(datgan)\r\n```\r\n\r\n### 1. Load the data and provide info about it\r\n\r\nThe first step is to load the data, which we will use to fit the **DATGAN**. We provide the **CMAP** (Chicago\r\nMetropolitan Agency for Planning) dataset in the example folder. It is a travel survey dataset for the city of Chicago.\r\nThe dataset has already been cleaned compared to the original dataset. It contains 15 columns and 8'929 rows.\r\n\r\nYou can load this dataset using `pandas.` You also need to provide the data type for each column. For the moment, only\r\ntwo possibilities are implemented: `continuous` and `categorical.` For `continuous` columns, you can pass more\r\ninformation to the model, such as:\r\n\r\n- `discrete` [**mandatory**]: Boolean value to indicate if the synthetic value has to be rounded when sampling\r\n- `bounds` [**optional**]: Values of the bounds. While sampling synthetic data, all values outside the bounds will be\r\n  discarded.\r\n- `enforce_bounds` [**optional**]: Instead of removing synthetic data generated outside the bounds, we will clip the\r\n  values to the bounds.   (*This can be useful in the case of a mixed distribution with a peak of values close to the\r\n  lower or the upper bound.*)\r\n- `apply_func` [**optional**]: You can provide a lambda function that will be applied before the encoding step and when\r\n  sampling the final values. This can help train models on distributions that are more difficult to represent by GMMs, *\r\n  e.g.* exponential distributions.\r\n\r\n```python\r\nimport pandas as pd\r\nimport numpy as np\r\n\r\ndf = pd.read_csv('./data/CMAP.csv', index_col=False)\r\n\r\ndata_info = {\r\n    'distance': {\r\n        'type': 'continuous',\r\n        'bounds': [0.0, np.infty],\r\n        'discrete': False,\r\n        'apply_func': (lambda x: np.log(x + 1)),\r\n    },\r\n    'age': {\r\n        'type': 'continuous',\r\n        'bounds': [0, 100],\r\n        'enforce_bounds': True,\r\n        'discrete': True\r\n    },\r\n    'departure_time': {\r\n        'type': 'continuous',\r\n        'bounds': [0, 23.999],\r\n        'discrete': False\r\n    }\r\n}\r\n\r\n# For the categorical columns, we can simply add them using a for loop\r\nfor c in df.columns:\r\n    if c not in data_info.keys():\r\n        data_info[c] = {'type': 'categorical'}\r\n```\r\n\r\n> **WARNING:** While using a lambda function in the  `apply_func` parameters, we use the `pynverse` library to compute the inverse of the given function. Therefore, with more complex functions, it is possible to get Warnings while sampling the final synthetic data. This is a normal behavior when `pynverse` is having trouble computing the inverse of some values.\r\n\r\n### 2. Create a DAG\r\n\r\nThe second step consists in creating the DAG for the DATGAN. The DAG is created using the library `networkx` from\r\nPython. The only constraint while creating the DAG is that it should not contain any cycle (by definition). In the\r\narticle, we give more details on creating the DAG. However, this process can still be cumbersome and requires trials and\r\nerrors to obtain a good DAG. (*We highly recommend using a \"visualization\" tool to create the DAG.*)\r\n\r\nBelow, we provide an example of a DAG for the CMAP dataset. First, the picture shows a visual representation of the DAG.\r\nThe colors of the nodes show the categories of variables: purple corresponds to individuals, blue to households, and red\r\nto trips. The image shows that nodes can be the source and the target of multiple edges. While the direction of the\r\nedges do not play an important role, we recommend having as few sink nodes as possible. The \r\n[**DATGAN** article](https://arxiv.org/abs/2203.03489) provides more details on building the DAG.\r\n\r\n![Visualization of the DAG for the CMAP dataset](https://github.com/glederrey/DATGAN/blob/master/assets/DAG_CMAP.png?raw=true)\r\n\r\nThe above DAG is represented in the `networkx` library as the following way:\r\n```python\r\nimport networkx as nx\r\n\r\ngraph = nx.DiGraph()\r\ngraph.add_edges_from([\r\n    (\"age\", \"license\"),\r\n    (\"age\", \"education_level\"),\r\n    (\"gender\", \"work_status\"),\r\n    (\"education_level\", \"work_status\"),\r\n    (\"education_level\", \"hh_income\"),\r\n    (\"work_status\", \"hh_income\"),\r\n    (\"hh_income\", \"hh_descr\"),\r\n    (\"hh_income\", \"hh_size\"),\r\n    (\"hh_size\", \"hh_vehicles\"),\r\n    (\"hh_size\", \"hh_bikes\"),\r\n    (\"work_status\", \"trip_purpose\"),\r\n    (\"trip_purpose\", \"departure_time\"),\r\n    (\"trip_purpose\", \"distance\"),\r\n    (\"travel_dow\", \"choice\"),\r\n    (\"distance\", \"choice\"),\r\n    (\"departure_time\", \"choice\"),\r\n    (\"hh_vehicles\", \"choice\"),\r\n    (\"hh_bikes\", \"choice\"),\r\n    (\"license\", \"choice\"),\r\n    (\"education_level\", \"hh_size\"),\r\n    (\"work_status\", \"hh_descr\"),\r\n    (\"work_status\", \"hh_size\"),\r\n    (\"hh_income\", \"hh_bikes\"),\r\n    (\"hh_income\", \"hh_vehicles\"),\r\n    (\"trip_purpose\", \"choice\")\r\n])\r\n```\r\n\r\nIf your DAG contains node that are not connected to any other nodes, you still need to add them. To do this, you can\r\nuse the `add_node` method of the `DiGraph` object.\r\n\r\n```python\r\ngraph.add_node(\"single_node\")\r\n```\r\n\r\nIf you do not know how to create your DAG, it is possible not to provide any DAG to the model. However, in this case,\r\nthe model will define a _linear_ DAG, _i.e._ each variable in the dataset is linked to the next one following the order\r\nof the columns. It can be helpful to test the model quickly. However, it will reduce the model's performance, as shown\r\nin the article.\r\n\r\nTo help build the DAG and know which edge should be added, we implemented a function named `advise` that computes\r\nPearson and Spearman correlations and then suggests some links that could be added to the DAG. The suggested links are\r\nthe ones with the highest correlations.\r\n\r\n```python\r\nimport datgan\r\n\r\ndatgan.advise(df, graph, plot_graphs=True)\r\n```\r\n\r\nResults (without the graphs) should look like this:\r\n\r\n```\r\nYou might want to add the following edges in your DAG (direction not given here):\r\n  - license <-> education_level\r\n  - license <-> work_status\r\n  - hh_vehicles <-> hh_descr\r\n  - hh_bikes <-> age\r\n  - hh_size <-> age\r\n```\r\n\r\n### 3. Create a DATGAN instance\r\n\r\nThe next step is to import **DATGAN** and create an instance of the model. There are no required parameters for the\r\nmodel. However, we advise you to set up the basic parameters such as the output folder (`output`), batch\r\nsize (`batch_size`), and the number of epochs (`num_epochs`).\r\n\r\n```python\r\noutput_folder = './output/'\r\nbatch_size = 1116\r\n\r\nfrom datgan import DATGAN\r\n\r\ndatgan = DATGAN(output=output_folder, batch_size=batch_size, num_epochs=1000)\r\n```\r\n\r\n> **NOTE:** Setting up a suitable batch size is really important. A batch size too big will make the model crash due to memory error, while one that is too small will make the model slower to train. Trials and errors are required depending on your hardware. In addition, it is good to find a batch size such that `len(df) % batch_size` is as small as possible since the last batch of data is dropped if it is smaller than the batch size.\r\n\r\n### 4. Preprocess the data (optional)\r\n\r\nThe fourth step consists in preprocessing the data. This step is optional since it is automatically done in the next\r\nstep if skipped right now. We propose to do the preprocessing in advance because it usually takes a bit of time. And if\r\nyou want to try multiple parameters with the **DATGAN**, you do not have to preprocess the data every time. Therefore,\r\nit is possible to do it before fitting the model and saving it somewhere.\r\n\r\n```python\r\ndatgan.preprocess(df, data_info, preprocessed_data_path='./encoded_data')\r\n```\r\n\r\n> **NOTE 1:** If you decide to change any values in the metadata dictionary `data_info`, you must preprocess the data again. However, since the preprocessing of the continuous variable is random, you will not be able to sample a model trained on a previous preprocessed dataset with the current one. Therefore, we advise not to delete the previous preprocessed dataset.\r\n>\r\n> **NOTE 2:** In the folder `preprocessed_data_path/continuous`, you will find PNG files of the continuous distributions. These pictures can be used to make sure that the Variational Gaussian Mixtures (VGM) were correctly trained for each continuous distribution. It can be especially useful if the user is trying to use a lambda function.\r\n\r\n### 5. Fit the model\r\n\r\nOnce you have a **DATGAN** instance, you can call the method `fit` and pass the following parameters:\r\n\r\n- `data`: the original DataFrame\r\n- `graph`: the `networkx` DAG\r\n- `continuous_columns`: the list of continuous columns\r\n- `preprocessed_data_path`: the path to the preprocessed data if done in Step 4 or the path where to save them.\r\n\r\n```python\r\ndatgan.fit(df, data_info, graph, preprocessed_data_path='./encoded_data')\r\n```\r\n\r\n> **NOTE:** Depending on the verbose level, the model will show different types of information. The standard level is 1, displaying a progress bar for the whole training process. With level 2, the model will display information at each epoch. With level 0, the model will not print any information.\r\n\r\n### 6. Sample new data\r\n\r\nOnce the model has been fitted, you can generate new synthetic data by calling the function `sample`. You have to\r\nprovide the desired number of samples.\r\n\r\n```python\r\nsamples = datgan.sample(len(df))\r\nsamples.to_csv('./data/synthetic.csv', index=False)\r\n```\r\n\r\n### 7. Save and load a model (optional)\r\n\r\nFitting the model can take a substantial amount of time. It is, thus, better to avoid fitting a new model every time we\r\nneed to generate samples. We advise to save checkpoints of the model while it is training. However, if you do not want\r\nto do that, the model will always keep the latest checkpoint once it has finished training. You can, thus, load it at\r\nany time afterward.\r\n\r\nYou can simply call the function `load` with the parameters used while fitting the model to load the model. To save\r\nmemory, we only save the parameters of the Generator and Discriminator. Therefore, more information is required to load\r\nthe model.\r\n\r\n```python\r\nnew_datgan = datgan.load(df, graph, preprocessed_data_path='./encoded_data')\r\n```\r\n\r\n> **NOTE:** This can be replaced by using the function `fit` once again. Since the model has already been trained, it will just load it.\r\n\r\n## Conditionality\r\n\r\nConditionality can be used in two different ways. The first one is done after training the **DATGAN** model. You can\r\nprovide a dictionary of desired values and passes it to the sampling method. The **DATGAN** model uses rejection\r\nsampling to provide the desired output. The second method consists in training the **DATGAN** using conditional inputs.\r\nTo use the second conditionality, the model has to be trained again.\r\n\r\n### Rejection sampling\r\n\r\nIn the `sample` function of the **DATGAN**, you must provide a dictionary as follows:\r\n\r\n- **categorical variables:** string or list of strings for the desired categories.\r\n- **continuous variables:** lambda function returning a boolean value.\r\n\r\nFor example, suppose you want only to generate synthetic data about men under 30 years old. In that case, you can\r\nprovide the following dictionary to the `sample` function.\r\n\r\n```python\r\ncond_dict = {'age': lambda x: x < 30, 'gender': '0'}\r\n\r\nsamples = datgan.sample(len(df), cond_dict=cond_dict)\r\nsamples.to_csv('./data/synthetic.csv', index=False)\r\n```\r\n\r\n> **WARNING:** Since the **DATGAN** is using rejection sampling to provide the desired values, you cannot provide a conditional dictionary that is too restrictive. This will significantly slow the sampling process and even make it fail. In some specific cases, you can set the parameter `timeout` to `False` if you do not want the sampling process to be stopped.\r\n\r\n### Conditional inputs\r\n\r\nThe conditional inputs are columns present in the original dataset. To train the **DATGAN** model, you need to provide\r\nthe list of columns you want to consider as conditional inputs. For example, suppose you want the age, gender, and trip\r\npurpose to be conditional inputs. In that case, you can initialize the **DATGAN** model this way:\r\n\r\n```python\r\ndatgan = DATGAN(output=output_folder,\r\n                batch_size=batch_size,\r\n                num_epochs=1000,\r\n                conditional_inputs=['age', 'gender', 'trip_purpose'])\r\n```\r\n\r\nSuppose the model is initialized in such a way. In that case, it will automatically transform the DAG. Each of the\r\nconditional variables is considered a source node in the DAG. It will then train the generator using the values for\r\nthese variables as inputs. Finally, to sample the synthetic data, you need to provide a `pandas.DataFrame` or a `dict`\r\nwith columns/keys corresponding to the conditional inputs defined in the initialization. You do not need to care about\r\nthe size of the DataFrame since the model automatically samples values from it. You can, thus, provide any values you\r\nwant (a subset of the original dataset, unique values, or values generated by another model on another dataset.)\r\n\r\nIn addition, the rejection sampling conditionality can be used alongside the conditional inputs. You have to provide the\r\ndictionary of conditionals alongside the new input data.\r\n\r\n# Model parameters\r\n\r\nSuppose you want to change the default behavior of `DATGAN`, such as using a different batch size or the total number of\r\nepochs. In that case, you can do so by passing additional arguments when creating the **DATGAN** instance or using its\r\ntwo main functions.\r\n\r\n## Initialize the model (`DATGAN.__init__`)\r\n\r\n| Name                 |    Type     |   Default    | Explanation                                                                                                                                                                                                                  |\r\n|:---------------------|:-----------:|:------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `loss_function`      |    `str`    |    `None`    | Name of the loss function to be used. If not specified, it will choose between `'WGAN'` and `'WGGP'` depending on the ratio of continuous and categorical columns. Only accepts the values `'SGAN'`, `'WGAN'`, and `'WGGP'`. |\r\n| `label_smoothing`    |    `str`    |    `'TS'`    | Type of label smoothing. Only accepts the values `'TS'`, `'OS'`, and `'NO'`.                                                                                                                                                 |\r\n| `output`             |    `str`    | `'./output'` | Path to store the model and its artifacts.                                                                                                                                                                                   |\r\n| `gpu`                |    `int`    |    `None`    | Model will automatically try to use GPU if tensorflow can use CUDA. However, this parameter allows you to choose which GPU you want to use.                                                                                  |\r\n| `num_epochs`         |    `int`    |    `100`     | Number of epochs to use during training.                                                                                                                                                                                     |\r\n| `batch_size`         |    `int`    |    `500`     | Size of the batch to feed the model at each step.                                                                                                                                                                            |\r\n| `save_checkpoints`   |   `bool`    |    `True`    | Whether to store checkpoints of the model after each training epoch.                                                                                                                                                         |\r\n| `restore_session`    |   `bool`    |    `True`    | Whether continue training from the last checkpoint.                                                                                                                                                                          |\r\n| `learning_rate`      |   `float`   |    `None`    | Learning rate. The value will be set according to the chosen loss function if set to None.                                                                                                                                   |\r\n| `g_period`           |    `int`    |    `None`    | Every `g_period` steps, train the generator once. (Used to train the discriminator more than the generator) By default, it will choose values according to the chosen loss function.                                         |\r\n| `l2_reg`             |   `bool`    |    `None`    | Tell the model to use L2 regularization while training both NNs. By default, it only applies the L2 regularization when using the SGAN loss function.                                                                        |\r\n| `z_dim`              |    `int`    |    `200`     | Dimension of the noise vector used as an input to the generator.                                                                                                                                                             |\r\n| `num_gen_rnn`        |    `int`    |    `100`     | Size of the hidden units in the LSTM cell.                                                                                                                                                                                   |\r\n| `num_gen_hidden`     |    `int`    |     `50`     | Size of the hidden layer used on the generator's output to act as a convolution.                                                                                                                                             |\r\n| `num_dis_layers`     |    `int`    |     `1`      | Number of layers for the discriminator.                                                                                                                                                                                      |\r\n| `num_dis_hidden`     |    `int`    |    `100`     | Size of the hidden layers in the discriminator.                                                                                                                                                                              |\r\n| `noise`              |   `float`   |    `0.2`     | Upper bound to the gaussian noise added to the label smoothing. (only used if `label_smoothing` is set to `'TS'` or `'OS'`)                                                                                                  |\r\n| `conditional_inputs` | `list[str]` |    `None`    | List of variables in the dataset that are used as conditional inputs to the model.                                                                                                                                           | \r\n| `verbose`            |    `int`    |     `1`      | Level of verbose. 0 means no print, 1 means that some details will be printed, 2 is mostly used for debugging purposes.                                                                                                      |\r\n\r\n## Training the model (`DATGAN.fit`)\r\n\r\n| Name                   |        Type        | Default | Explanation                                                                                                                               |\r\n|:-----------------------|:------------------:|:-------:|:------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `data`                 | `pandas.DataFram`  |         | Original dataset                                                                                                                          |\r\n| `metadata`             |       `dict`       | `None`  | Dictionary containing information about the data in the DataFrame.                                                                        |\r\n| `dag`                  | `networkx.DiGraph` | `None`  | Directed Acyclic Graph representing the relations between the variables. If no dag is provided, the algorithm will create a linear DAG.   |\r\n| `preprocess_data_path` |       `str`        | `None`  | Path to an existing preprocessor. If None is given, the model will preprocess the data and save it under `self.output + '/encoded_data'`. |\r\n\r\n## Sampling synthetic data (`DATGAN.sample`)\r\n\r\n| Name          |             Type             | Default | Explanation                                                                                                                            |\r\n|:--------------|:----------------------------:|:-------:|:---------------------------------------------------------------------------------------------------------------------------------------|\r\n| `num_samples` |            `int`             |         | Number of rows in the generated synthetic dataset.                                                                                     |\r\n| `inputs`      | `dict` or `pandas.DataFrame` | `None`  | Optional input data. **Must** be provided if the model was training with some conditional inputs in the variable `conditional_inputs`. |                              |         |                                                                                           |\r\n| `cond_dict`   |            `dict`            | `None`  | Dictionary for the rejection sampling conditionality.                                                                                  |\r\n| `sampling`    |            `str`             |  `SS`   | Sampling strategy. Only accepts the following values: `'SS'`, `'SA'`, `'AS'`, and `'AA'`.                                              |\r\n| `timeout`     |            `bool`            | `True`  | Timeout to stop sampling if the model cannot generated the required data in `cond_dict`.                                               |\r\n\r\nWhen sampling the synthetic data, you can choose between multiple sampling strategies. `S` means we are using simulation\r\nto sample the data, `A` indicates that the model uses argmax. The first letter corresponds to continuous variables and\r\nthe second to categorical variables. Therefore, `SA` means we're using simulation for continuous variables and argmax\r\nfor categorical variables.\r\n\r\n# Tips and tricks\r\n\r\nWhile the **DATGAN** model will automatically choose its parameters if none are provided, we highly recommend the user\r\nto \"play\" with them. The most important ones are the following:\r\n\r\n- `loss_function` Generally, the `WGAN` loss function works better on datasets with more categorical columns than\r\n  continuous. It is the contrary for the `WGGP` loss. The `SGAN` loss seems to perform a bit less good than the other\r\n  two in the specific cases. However, it seems to perform ok in any case.\r\n- `g_period` This parameter is critical when using either the `WGAN` or the `WGGP` loss. Generally, the latter requires\r\n  a lot more discriminator training than the previous. However, it might be interesting to test different values to see\r\n  which leads to the best results.\r\n- `l2_reg` The L2 regularization is \"mandatory\" for the `SGAN` loss and \"forbidden\" for the `WGAN` loss. The user can\r\n  test these other configurations, but it will lead to worse results. However, for the `WGGP` loss, there are no\r\n  specific rules on whether to apply it or not. Therefore, it might be interesting to test this parameter as well.\r\n- `learning_rate` It has been fixed depending on the loss function. However, as for any optimization problem, playing\r\n  with the learning rate to find the optimal value is always important.\r\n\r\n# Contributing\r\n\r\nIf you want to participate in the development of this model, you can write a Github issue and give us your suggestions\r\nor directly prepare a Pull Request. (However, it would be better first to discuss the content of the PR.)\r\n\r\n# Acknowledgements\r\n\r\nWe want to thank the authors of the [**TGAN**](https://arxiv.org/abs/1811.11264) model, the authors of the \r\n[**CTGAN**](https://arxiv.org/abs/1907.00503) model, and the authors of the \r\n[**CTAB-GAN**](https://arxiv.org/abs/2102.08369) model. These three models have greatly inspired the **DATGAN** model.\r\n\r\n# Citation\r\n\r\nIf you use DATGAN or its evaluation metrics for any of your projects, please cite the following work:\r\n> \"[Lederrey G., Hillel T., Bierlaire M., *DATGAN: Integrating Expert Knowledge into Deep Learning for Synthetic Tabular Data*, arXiv preprint arXiv:2203.03489 (2022)](https://arxiv.org/abs/2203.03489)\"\r\n\r\nThe original code for this article can be found in this Github repository: https://github.com/glederrey/SynthPop.\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/glederrey/DATGAN",
    "keywords": "DATGAN,GAN,Synthetic Tabular Data,Population Synthesis",
    "license": "GPLv3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "datgan",
    "package_url": "https://pypi.org/project/datgan/",
    "platform": null,
    "project_url": "https://pypi.org/project/datgan/",
    "project_urls": {
      "Homepage": "https://github.com/glederrey/DATGAN"
    },
    "release_url": "https://pypi.org/project/datgan/2.1.10/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Generative adversarial network with integrated expert knowledge for synthesizing tabular data",
    "version": "2.1.10",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14128611,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f740cfa51a280329a579d2d57787c7e781b1694728373a5aa3240ab32c7b5987",
          "md5": "7548ec9eda5df54d7aa80a2273192588",
          "sha256": "e54d21e7356976309f667c5cfe9a46554e23aef0981cf6bbcf13b740f6df55de"
        },
        "downloads": -1,
        "filename": "datgan-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7548ec9eda5df54d7aa80a2273192588",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 37127,
        "upload_time": "2022-01-12T16:41:04",
        "upload_time_iso_8601": "2022-01-12T16:41:04.748027Z",
        "url": "https://files.pythonhosted.org/packages/f7/40/cfa51a280329a579d2d57787c7e781b1694728373a5aa3240ab32c7b5987/datgan-1.0.tar.gz",
        "yanked": true,
        "yanked_reason": null
      }
    ],
    "1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "be63903c1a31152272f656a98af13bbd2468e1203aa6913142cfa92d598968e2",
          "md5": "baa8f07757639c264d2cbaf04413b875",
          "sha256": "724c5fd944d7ef8f9c984f76e344cd473d3f7a346c8950ec1afe74ec8be3cb2d"
        },
        "downloads": -1,
        "filename": "datgan-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "baa8f07757639c264d2cbaf04413b875",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 44656,
        "upload_time": "2022-01-12T17:48:15",
        "upload_time_iso_8601": "2022-01-12T17:48:15.956910Z",
        "url": "https://files.pythonhosted.org/packages/be/63/903c1a31152272f656a98af13bbd2468e1203aa6913142cfa92d598968e2/datgan-1.1.tar.gz",
        "yanked": true,
        "yanked_reason": null
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9fccb09a1002b9314be15de30fe6a0aac12e6861169ee376c723e6cf75163dc8",
          "md5": "71c7b07daf8be9e1059c43afb5647a1b",
          "sha256": "58d1da239cf3c60d43faf1eb1afaae5aab807da0aae24b36f12199dab1f981bb"
        },
        "downloads": -1,
        "filename": "datgan-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "71c7b07daf8be9e1059c43afb5647a1b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 44883,
        "upload_time": "2022-01-17T09:10:11",
        "upload_time_iso_8601": "2022-01-17T09:10:11.071136Z",
        "url": "https://files.pythonhosted.org/packages/9f/cc/b09a1002b9314be15de30fe6a0aac12e6861169ee376c723e6cf75163dc8/datgan-1.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5e92be4088857ca57343c132b612ed2da5b071b70668191f2a9ab3b6eaa0639f",
          "md5": "792ea6298e7cb28163d579007b8ad4e0",
          "sha256": "2af9d3fb18d3b3ffc78c91571b9661070bb16613350f7a90d095015b59f95758"
        },
        "downloads": -1,
        "filename": "datgan-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "792ea6298e7cb28163d579007b8ad4e0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 49152,
        "upload_time": "2022-03-01T19:20:52",
        "upload_time_iso_8601": "2022-03-01T19:20:52.994518Z",
        "url": "https://files.pythonhosted.org/packages/5e/92/be4088857ca57343c132b612ed2da5b071b70668191f2a9ab3b6eaa0639f/datgan-2.0.0.tar.gz",
        "yanked": true,
        "yanked_reason": null
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d3afc9a92b5e271194d3c81160a17c3b85c552b096dcb2b07293a0cf248765ed",
          "md5": "b4f213d0a46709050160a2b0fc22c566",
          "sha256": "3d72340f06615229733b04af7cf910e38c3a33aad32876bb397ce97fd6bc29c1"
        },
        "downloads": -1,
        "filename": "datgan-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b4f213d0a46709050160a2b0fc22c566",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 50972,
        "upload_time": "2022-03-04T11:40:41",
        "upload_time_iso_8601": "2022-03-04T11:40:41.842939Z",
        "url": "https://files.pythonhosted.org/packages/d3/af/c9a92b5e271194d3c81160a17c3b85c552b096dcb2b07293a0cf248765ed/datgan-2.0.1.tar.gz",
        "yanked": true,
        "yanked_reason": "No need for this version"
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "30c9b4c4da17f10720218835f58e3620a116fd4e6c2d5eebe8c94800967d06f9",
          "md5": "704061ced3f19f74fea253895a1342cc",
          "sha256": "7d1a00572df39ae63b8763b04994ea3a798095259ffa4d1068000a0bbd2aa099"
        },
        "downloads": -1,
        "filename": "datgan-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "704061ced3f19f74fea253895a1342cc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 56065,
        "upload_time": "2022-03-17T15:36:51",
        "upload_time_iso_8601": "2022-03-17T15:36:51.330900Z",
        "url": "https://files.pythonhosted.org/packages/30/c9/b4c4da17f10720218835f58e3620a116fd4e6c2d5eebe8c94800967d06f9/datgan-2.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "43778e866ccf36274637bc2ade0af373c3173effd6bdf257d687e874f4f37b8e",
          "md5": "ac71240f02128d289125d585889cb4be",
          "sha256": "4c0f418cb1a01530ec9e10fc58f5b3223b4bd205c89aa78b59abfb3a38b54fe5"
        },
        "downloads": -1,
        "filename": "datgan-2.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ac71240f02128d289125d585889cb4be",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 57835,
        "upload_time": "2022-03-22T13:54:59",
        "upload_time_iso_8601": "2022-03-22T13:54:59.136734Z",
        "url": "https://files.pythonhosted.org/packages/43/77/8e866ccf36274637bc2ade0af373c3173effd6bdf257d687e874f4f37b8e/datgan-2.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c9f9535ba732246847c5aa17ffc54b5461ba6fdf7edb33832fceee35cfef275",
          "md5": "2969e0340f6b3d9cee8fcce9018155eb",
          "sha256": "d0b99c7f5f4e3f93d2dc1263a206e46a734c715bc6ce0e71069055c674acf80b"
        },
        "downloads": -1,
        "filename": "datgan-2.1.10.tar.gz",
        "has_sig": false,
        "md5_digest": "2969e0340f6b3d9cee8fcce9018155eb",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 3558384,
        "upload_time": "2022-06-14T14:48:58",
        "upload_time_iso_8601": "2022-06-14T14:48:58.038282Z",
        "url": "https://files.pythonhosted.org/packages/8c/9f/9535ba732246847c5aa17ffc54b5461ba6fdf7edb33832fceee35cfef275/datgan-2.1.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f0f79618bb6f9695b163b06b28dd95367b587e4ec52b87e0b8aea480348c72c0",
          "md5": "d5f4464385f255aedb492fdb33fc911b",
          "sha256": "dc108a509ca5c83fd25e511eb306b0ac26261b19237725babdef88e9fc27b93e"
        },
        "downloads": -1,
        "filename": "datgan-2.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "d5f4464385f255aedb492fdb33fc911b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 59691,
        "upload_time": "2022-03-24T13:07:06",
        "upload_time_iso_8601": "2022-03-24T13:07:06.101991Z",
        "url": "https://files.pythonhosted.org/packages/f0/f7/9618bb6f9695b163b06b28dd95367b587e4ec52b87e0b8aea480348c72c0/datgan-2.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c1755d6ada3ec6f1956e304d37ebaaa4812181ceb424877cd066159beaa4ff52",
          "md5": "15132648504ce654f3ff41b18b034975",
          "sha256": "ec6c95621c345a682cb484d3fcb53d61e6b6e5946d9161e6b52949ad27121b1d"
        },
        "downloads": -1,
        "filename": "datgan-2.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "15132648504ce654f3ff41b18b034975",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59689,
        "upload_time": "2022-03-31T12:05:14",
        "upload_time_iso_8601": "2022-03-31T12:05:14.130619Z",
        "url": "https://files.pythonhosted.org/packages/c1/75/5d6ada3ec6f1956e304d37ebaaa4812181ceb424877cd066159beaa4ff52/datgan-2.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a272d499e16d1cfa9fa9a0653c3515a7196081711049e4551b4d344141b1bc3f",
          "md5": "501c7a16ddea76ef3963a768feed7e81",
          "sha256": "23dcd468977691f03db99fff0d88caa577c28b0fb088fd4456b8c74126ead432"
        },
        "downloads": -1,
        "filename": "datgan-2.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "501c7a16ddea76ef3963a768feed7e81",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59718,
        "upload_time": "2022-03-31T14:14:53",
        "upload_time_iso_8601": "2022-03-31T14:14:53.902021Z",
        "url": "https://files.pythonhosted.org/packages/a2/72/d499e16d1cfa9fa9a0653c3515a7196081711049e4551b4d344141b1bc3f/datgan-2.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "370b3d4e92f95f3530f8c0e2bb48350d37009c0ac17430fa860f496421379dd2",
          "md5": "8d47e21b7b5e45bedbf4d826a8f12f1d",
          "sha256": "515d58ac3211605f7994341fc934f51a51e80462a932efedc3b34bfa66c29803"
        },
        "downloads": -1,
        "filename": "datgan-2.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "8d47e21b7b5e45bedbf4d826a8f12f1d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 49383,
        "upload_time": "2022-04-14T11:24:04",
        "upload_time_iso_8601": "2022-04-14T11:24:04.727540Z",
        "url": "https://files.pythonhosted.org/packages/37/0b/3d4e92f95f3530f8c0e2bb48350d37009c0ac17430fa860f496421379dd2/datgan-2.1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a192c6ab08b286ac6e01b029fb9838879fa01aa3e80af53768536971e66ac7fa",
          "md5": "9c43a388edda791a4bcf4c53d997c5d8",
          "sha256": "ece89e2f785f93c46850a100ce2d0b004cac7896cca9892e0a92cebca715fd01"
        },
        "downloads": -1,
        "filename": "datgan-2.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "9c43a388edda791a4bcf4c53d997c5d8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60970,
        "upload_time": "2022-04-26T11:34:48",
        "upload_time_iso_8601": "2022-04-26T11:34:48.173538Z",
        "url": "https://files.pythonhosted.org/packages/a1/92/c6ab08b286ac6e01b029fb9838879fa01aa3e80af53768536971e66ac7fa/datgan-2.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6968e6b4fdecbd346d09a6d6868e5bc181610ba528b2c68e785007314426c97d",
          "md5": "0c739a41b384ee52138a09ba558daf84",
          "sha256": "14e590debd137a3cc7ef3c150b36cb1401e90c74a6b8bdcd8bc32eb8bf7b746e"
        },
        "downloads": -1,
        "filename": "datgan-2.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "0c739a41b384ee52138a09ba558daf84",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60972,
        "upload_time": "2022-04-29T11:46:22",
        "upload_time_iso_8601": "2022-04-29T11:46:22.652027Z",
        "url": "https://files.pythonhosted.org/packages/69/68/e6b4fdecbd346d09a6d6868e5bc181610ba528b2c68e785007314426c97d/datgan-2.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6f60525a87c6f1b24b8394c67262f52ea4c5ff4484e8ab377975f1ce79d0eab0",
          "md5": "0279831fc3c83a9b43fc1976d6dff1d7",
          "sha256": "370ba734780c2abff3f07ab3bfd2b8f9783e321895d965a0f38c8906b99965ca"
        },
        "downloads": -1,
        "filename": "datgan-2.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "0279831fc3c83a9b43fc1976d6dff1d7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 3558226,
        "upload_time": "2022-04-30T15:38:21",
        "upload_time_iso_8601": "2022-04-30T15:38:21.046609Z",
        "url": "https://files.pythonhosted.org/packages/6f/60/525a87c6f1b24b8394c67262f52ea4c5ff4484e8ab377975f1ce79d0eab0/datgan-2.1.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fae33f6e02f06fe198e526142b7976828135485150322d52c4ddd8741fbe721e",
          "md5": "cfb74fa27afaec92f9670df6eeadb251",
          "sha256": "e42ba627a8670a10daf9110a797f4ed7ad8fb72fc362d65befb63802c5dbb8ae"
        },
        "downloads": -1,
        "filename": "datgan-2.1.9.tar.gz",
        "has_sig": false,
        "md5_digest": "cfb74fa27afaec92f9670df6eeadb251",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 3558281,
        "upload_time": "2022-05-12T13:21:31",
        "upload_time_iso_8601": "2022-05-12T13:21:31.619593Z",
        "url": "https://files.pythonhosted.org/packages/fa/e3/3f6e02f06fe198e526142b7976828135485150322d52c4ddd8741fbe721e/datgan-2.1.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8c9f9535ba732246847c5aa17ffc54b5461ba6fdf7edb33832fceee35cfef275",
        "md5": "2969e0340f6b3d9cee8fcce9018155eb",
        "sha256": "d0b99c7f5f4e3f93d2dc1263a206e46a734c715bc6ce0e71069055c674acf80b"
      },
      "downloads": -1,
      "filename": "datgan-2.1.10.tar.gz",
      "has_sig": false,
      "md5_digest": "2969e0340f6b3d9cee8fcce9018155eb",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 3558384,
      "upload_time": "2022-06-14T14:48:58",
      "upload_time_iso_8601": "2022-06-14T14:48:58.038282Z",
      "url": "https://files.pythonhosted.org/packages/8c/9f/9535ba732246847c5aa17ffc54b5461ba6fdf7edb33832fceee35cfef275/datgan-2.1.10.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}