{
  "info": {
    "author": "Alex Z",
    "author_email": "alexchunggh@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Tutorial\n\nLast modification: Alex Z 26/10/2020\n\n## 1.Introduction\n\nThis small package is used to ease the validation process of input data in mine model. It supports the input workbook version 116D and those with the same structures.\n\nAs prerequisites, the user should already have the following python packages: **[Networkx](https://networkx.org/documentation/stable/install.html), [Pandas](https://pandas.pydata.org/), [Numpy](https://numpy.org/), [Matplotlib](https://matplotlib.org/)**.\n\nIn terms of usage, it is recommended to apply this package in Jupyter Notebook or other interactive tools. An example file ‘UseCases.ipynb’ is provided in the example directroy, which should be opened in Jupyter Notebook.\n\n## 2.Import data\n\nTo apply this package, first put the python file ‘PlantVisualization.py’ in the same directory and import it.\n\n```python\nimport Input-Analyzor as ia\n```\n\nSecond, import the input workbook by giving a valid path. It will return a dictionary that contains most of the equipment details in Pandas.DataFrame.\n\n```python\ndata_dict = ia.access_data(r'./src/KD2_116d_l8f8u4_66%.xlsb')\n```\n\nThe keys and referring equipment details are as this table below. The data can be viewed easily, for example crushers, by using `data_dict[1]`\n\nKeys | Equipment details\n--- | ---\n|1|Crusher\n|2|Screen\n|3|Conveyor\n|4|Bin\n|5|Stockpile group\n|6|Apron feeder\n|8|Percentage splitter\n|9|Priority feeder\n|21|Screen destination\n|22|Screen percentage\n\n## 3.Create a directed graph\n\nWe can also create a directed graph of all equipment based on the data dictionary we just generated by doing this. In the directed graph, all equipment will be defined as nodes, the connection between will be defined as directed edge.\n\nIn the code below, we need to pass the data_dict we just generated and define how many ore types are used in the input workbook.\nThe graph can be saved and read as gpickle file.\n\n```python\nep_map = ia.generate_graph(data_dict, ore_type_num=9)\n```\n\n```python\n# save graph as pickle and read it\nnx.write_gpickle(ep_map, \"KD2_109C.gpickle\")\nep_map = nx.read_gpickle(\"KD2_109C.gpickle\")\nep_map = pd.read_pickle('KD2_109C.gpickle')\n```\n\nAs the graph is stored as a dictionary, once the graph is generated, you can easily access the information of equipment or the connection between them. For example, if I want to know the process rate of ‘SC2311’, just need to use\n\n```python\nep_map.nodes['SC2311']['rate']\n```\n\nor if you want to know all the attributes of ‘SC2311’, just use\n\n```python\nep_map.nodes['SC2311']\n```\n\nTo get all possible out edges from ‘SC2311’, it will also show the percentage going to each edge.\n\n```python\nep_map['SC2311']\n```\n\nOr, to access a specific edge if it exists.\n\n```python\nep_map['SC2311']['CV2244']\n```\n\n## 4.Mass splits calculation\n\n### **Calculation**\n\nAs one of the most useful features :smirk:, the graph can calculate the throughput to each equipment by giving it a source and the input tones.\n\n```python\n# calculate split pct from CS75LG to BX2301\npct_split_CS75LG = ia.calculate_split_from_node(ep_map, 'CS75LG', end_node=['BX2301'] ,input_pct=100000, ore_type_id=3, max_sc_visited=1)\n```\n\nThe example above calculates the mass split from ‘CS75LG’ to ‘BX2301’ with input 100000. It returns a dictionary with equipment names as keys and split throughput as values.\n\n```end_node``` is a list of nodes where the calculation will stop. The calculation will continue until no sub nodes are found if the ```end_node``` is not defined.\n\n```ore_type_id``` also need to be defined because different ore types have different split percentages in screens.\n\n‘max_sc_visited’ means how many times an entity can go through the same screen. If it is set to 0, the calculation will skip all the edges in loops while exiting the screen at the first visit. If it is set to 1, it will only skip the looping edges at the second visit.\n\nNumbers greater than 1 are not recommended as it will significantly increase the calculation time.\n\n### **Recalculation**\n\nThe returned mass splits dictionary can be also used in the next calculation, so users can stack many calculations on the same mass splits dictionary.\nFor example, the code below is the calculation continued from the previous one. ‘BX2301’ is used as source node, and the previous mass split dictionary is passed to the next calculation.\n\n```python\n# get the start node input in the next calculation\nprevious_input = pct_split_CS75LG['BX2301']\n# make the input of the last node input 0 to prevent double counting\npct_split_CS75LG['BX2301'] = 0\n\n# keep calculating the splits by passing the old dictionary.\npct_split_total = ia.calculate_split_from_node(ep_map, 'BX2301', end_node=[], pct_split=pct_split_CS75LG, input_pct=previous_input, ore_type_id=ore_type, max_sc_visited=1)\n```\n\nThis method can be used to reduce the time and memory cost of calculation if there are to many screens and splits.\nThe results of calculation should be used in basic test to make sure the model behave as what is defined in the input workbook.\n\n## 5.Simplification\n\nFor the purpose of simplifying the flow in visualization, a functionality is made to merge a set of equipment into a single node.\n\n```python\n# generate simple graph and pct_split by merging equipment\nsimple_ep_map, merged_pct_split = ia.simplified_graph(ep_map, pct_split=None, print_merged_process=False)\n```\n\nEquipment, that are in the same type, with similar names (the first 4 char) and same source, will be merged to a single node.\n\nFor example, BN1311, BN1321… to BN1381, which are fed by the same tripper, will be merged as a new node ‘BN1321-81’. The rates, capacity will be also inherited from the nodes that are merged and multiplied by their number. This process will keep going on until there are no more nodes to merge.\n\nThe simplified version of graph should be used in validation and it does not support the mass split calculation. However, the mass split calculation can also be merged by passing it to the function.\n\n## 6.Visualization\n\nThe graph can be visualized on ```matplotlib.plot.fig```.\n\nThe code below first positioning all the nodes sourced from ‘CS75LG’ based on DFS.\n\nNext it passes the graph ‘ep_map’, the position dictionary ‘pos_dfs’ and the mass split results ‘pct_split_total’ to the function.\n\nThe results is the flow chart below. In the flow chart, green means source while red means destination. Different equipment types will have different node shapes.\n\nIt is a fact that the flow chart is messy and need to be improved :sweat_smile:, but hopefully it can still give some knowledge about how the flows go.\n\n```python\n# get position dict from a specific start node\npos_dfs = ia.get_pos(ep_map, end_node=['CV2241','CV2153'], h_dis=2, v_dis=2, start_node='CS75LG')\n\n# visualize the connection\nfig = ia.draw_map(ep_map, pos_dfs, pct_split=pct_split_total)\n```\n![output_example](https://github.riotinto.org/IOps-Strategy-Simulation-Modelling/Input-Analyzor/blob/master/src/example_vis_output.png?raw=true)\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.riotinto.org/IOps-Strategy-Simulation-Modelling/Input-Analyzor",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "input-analyzor",
    "package_url": "https://pypi.org/project/input-analyzor/",
    "platform": "",
    "project_url": "https://pypi.org/project/input-analyzor/",
    "project_urls": {
      "Homepage": "https://github.riotinto.org/IOps-Strategy-Simulation-Modelling/Input-Analyzor"
    },
    "release_url": "https://pypi.org/project/input-analyzor/0.0.2/",
    "requires_dist": [
      "pyxlsb (>=1.0.6)",
      "matplotlib (==3.2.0)",
      "networkx (>=2.4)",
      "numpy (>=1.18.1)",
      "pandas (>=1.0.1)"
    ],
    "requires_python": ">=3.6",
    "summary": "Arena mine model input analyzor, working with excel input workbook 116D",
    "version": "0.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8662915,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "574f46aa701ebfb851b2a74d759c9b12db074807ba9ef9c116304931458d0b5d",
          "md5": "694d8ef3f1f313678de319d0676ec0ef",
          "sha256": "e0837619e2b096202ecb5f9bf6d22c779be4bd1a1a38f3597ab0fa18dce65aea"
        },
        "downloads": -1,
        "filename": "input_analyzor-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "694d8ef3f1f313678de319d0676ec0ef",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 17030,
        "upload_time": "2020-11-15T08:52:41",
        "upload_time_iso_8601": "2020-11-15T08:52:41.996320Z",
        "url": "https://files.pythonhosted.org/packages/57/4f/46aa701ebfb851b2a74d759c9b12db074807ba9ef9c116304931458d0b5d/input_analyzor-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1358334eee2255eb040e5d429959fac107bda309afc0e47477dcc2de4ed52a4e",
          "md5": "288f8aa79ab52e9b57e4b52f836388c8",
          "sha256": "cdc9fc87561b6c04672e2167c79be1adf87cbb1dc97f0a34b194534fc598afa5"
        },
        "downloads": -1,
        "filename": "input_analyzor-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "288f8aa79ab52e9b57e4b52f836388c8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 15912,
        "upload_time": "2020-11-15T08:52:43",
        "upload_time_iso_8601": "2020-11-15T08:52:43.646128Z",
        "url": "https://files.pythonhosted.org/packages/13/58/334eee2255eb040e5d429959fac107bda309afc0e47477dcc2de4ed52a4e/input_analyzor-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4e1ea8e7323e2a0fdb6fafe261365004e3c5c38dd031a6eecf9f534993a00529",
          "md5": "0899ed5468885b97656918e53349c743",
          "sha256": "b222e0dc53766874b3709f84384480a56cbe46d9787743361ce46203ee8c0b28"
        },
        "downloads": -1,
        "filename": "input_analyzor-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0899ed5468885b97656918e53349c743",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 17090,
        "upload_time": "2020-11-15T10:06:13",
        "upload_time_iso_8601": "2020-11-15T10:06:13.827525Z",
        "url": "https://files.pythonhosted.org/packages/4e/1e/a8e7323e2a0fdb6fafe261365004e3c5c38dd031a6eecf9f534993a00529/input_analyzor-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "148f841722c03cd81c873579137359aed1cc300dcffbce64285db5665fab82be",
          "md5": "200f5d42194ba3c183d7f8b63d16a31d",
          "sha256": "37b2acbb583fb0f8f021796ac39e07692be957b158ec3528bce013fd48c91861"
        },
        "downloads": -1,
        "filename": "input_analyzor-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "200f5d42194ba3c183d7f8b63d16a31d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 16007,
        "upload_time": "2020-11-15T10:06:15",
        "upload_time_iso_8601": "2020-11-15T10:06:15.237992Z",
        "url": "https://files.pythonhosted.org/packages/14/8f/841722c03cd81c873579137359aed1cc300dcffbce64285db5665fab82be/input_analyzor-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4e1ea8e7323e2a0fdb6fafe261365004e3c5c38dd031a6eecf9f534993a00529",
        "md5": "0899ed5468885b97656918e53349c743",
        "sha256": "b222e0dc53766874b3709f84384480a56cbe46d9787743361ce46203ee8c0b28"
      },
      "downloads": -1,
      "filename": "input_analyzor-0.0.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0899ed5468885b97656918e53349c743",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 17090,
      "upload_time": "2020-11-15T10:06:13",
      "upload_time_iso_8601": "2020-11-15T10:06:13.827525Z",
      "url": "https://files.pythonhosted.org/packages/4e/1e/a8e7323e2a0fdb6fafe261365004e3c5c38dd031a6eecf9f534993a00529/input_analyzor-0.0.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "148f841722c03cd81c873579137359aed1cc300dcffbce64285db5665fab82be",
        "md5": "200f5d42194ba3c183d7f8b63d16a31d",
        "sha256": "37b2acbb583fb0f8f021796ac39e07692be957b158ec3528bce013fd48c91861"
      },
      "downloads": -1,
      "filename": "input_analyzor-0.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "200f5d42194ba3c183d7f8b63d16a31d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 16007,
      "upload_time": "2020-11-15T10:06:15",
      "upload_time_iso_8601": "2020-11-15T10:06:15.237992Z",
      "url": "https://files.pythonhosted.org/packages/14/8f/841722c03cd81c873579137359aed1cc300dcffbce64285db5665fab82be/input_analyzor-0.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}