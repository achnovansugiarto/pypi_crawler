{
  "info": {
    "author": "Nickovic Dejan, Tomoya Yamaguchi",
    "author_email": "dejan.nickovic@ait.ac.at, tomoya.yamaguchi@toyota.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: BSD License",
      "Programming Language :: C++",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->\n\n**Table of Contents**\n\n\n\n- [About](#about)\n\n- [Installation](#installation)\n\n  - [Install prerequisites for RTAMT installation](#install-prerequisites-for-rtamt-installation)\n\n  - [Option 1: Install Python package version](#option-1-install-python-package-version)\n\n  - [Option 2: Build the tool](#option-2-build-the-tool)\n\n    - [Clone the repository](#clone-the-repository)\n\n    - [Build CPP libraries](#build-cpp-libraries)\n\n    - [Install RTAMT](#install-rtamt)\n\n    - [uninstall RTAMT](#uninstall-rtamt)\n\n  - [test RTAMT](#test-rtamt)\n\n- [Theory](#theory)\n\n  - [Specification Language](#specification-language)\n\n- [Usage](#usage)\n\n  - [Example Usage](#example-usage)\n\n    - [Discrete-time online monitor](#discrete-time-online-monitor)\n\n    - [Dense-time online monitor](#dense-time-online-monitor)\n\n  - [Dense-time Offline Monitor](#dense-time-offline-monitor)\n\n  - [Discrete-time Specifics](#discrete-time-specifics)\n\n    - [Working with time units and timing assumptions](#working-with-time-units-and-timing-assumptions)\n\n- [References](#references)\n\n\n\n<!-- markdown-toc end -->\n\n\n\n# About\n\n\n\nRTAMT is a Python (2- and 3-compatible) library for monitoring of Signal Temporal Logic (STL).\n\nThe library implements algorithms offline and online monitoring of discrete-time and dense-time STL.\n\nThe online monitors support the bounded future fragment of STL.\n\nThe online discrete-time part of the library has an optimized C++ back-end.\n\n\n\n# Installation\n\n\n\n## Install prerequisites for RTAMT installation\n\n\n\n```bash\n\nsudo apt install libboost-all-dev\n\nsudo apt install python-dev\n\nsudo apt install python-pip\n\n```\n\n\n\nIf your want to extend the specification language, you may need the ANTLR4 parser generator.\n\n\n\n```bash\n\nsudo apt install antlr4\n\n```\n\n\n\nYou will also need CMake version 3.12 or higher if you need to build the CPP backend.\n\n\n\n```bash\n\nsudo apt install cmake\n\n```\n\n\n\nIn our experience, Ubuntu 16.04, 18.04 don't support the versions in default. You can check [our manual intallation of cmake](README_cmake.md).\n\n\n\n## Option 1: Install Python package version\n\n\n\nWe provide Python package version of RTAMT.\n\n\n\nfor Python 2\n\n\n\n```bash\n\nsudo pip2 install rtamt\n\n```\n\n\n\nfor Python 3\n\n\n\n```bash\n\nsudo pip3 install rtamt\n\n```\n\n\n\n## Option 2: Build the tool\n\n\n\n### Clone the repository\n\n\n\n```bash\n\ngit clone https://github.com/nickovic/rtamt\n\n```\n\n\n\n### Build CPP libraries\n\n\n\nThis step is needed only if you want to use the CPP backend and\n\ncan be skipped if you want to use pure Python monitors.\n\n\n\nfor Python 2\n\n\n\n```bash\n\ncd rtamt/rtamt\n\nmkdir build\n\ncd build\n\ncmake -DPythonVersion=2 ../\n\nmake\n\n```\n\n\n\nfor Python 3\n\n\n\n```bash\n\ncd rtamt/rtamt\n\nmkdir build\n\ncd build\n\ncmake -DPythonVersion=3 ../\n\nmake\n\n```\n\n\n\n### Install RTAMT\n\n\n\nfor Python 2\n\n\n\n```bash\n\ncd rtamt/\n\nsudo pip2 install .\n\n```\n\n\n\nfor Python 3\n\n\n\n```bash\n\ncd rtamt/\n\nsudo pip3 install .\n\n```\n\n\n\n### uninstall RTAMT\n\n\n\nfor Python 2\n\n\n\n```bash\n\nsudo pip2 uninstall rtamt\n\n```\n\n\n\nfor Python 3\n\n\n\n```bash\n\nsudo pip3 uninstall rtamt\n\n```\n\n\n\n## test RTAMT\n\n\n\nfor Python 2\n\n\n\n```bash\n\ncd rtamt/\n\npython2 -m unittest discover tests/\n\n```\n\n\n\nfor Python 3\n\n\n\n```bash\n\ncd rtamt/\n\npython3 -m unittest discover tests/\n\n```\n\n\n\n# Theory\n\n\n\nRTAMT is a Python library for offline and online monitoring of (bounded-future)  \n\nSignal Temporal Logic (STL). The library is inspired by several theoretical and practical  \n\nworks:\n\n\n\n- The bounded-future fragment of STL is inspired by [2]\n\n- The interface-aware interpretation of STL quantitative semantics is inspired by [3]\n\n- The periodic-sampling interpretation of specifications (even in presence of timestamps that are not prefectly periodic) is inpired by [4]\n\n- The translation of bounded-future STL to \"equirobust\" past STL prior to the online monitoring phase is inspired by [2]\n\n\n\n## Specification Language\n\n\n\nRTAMT supports Signal Temporal Logic (STL) and interface-aware STL (IA-STL).\n\n\n\nThe library supports a variant of STL with past and future temporal operators as well as basic arithmetic and absolute value operators.  \n\nSemantics of STL is defined in terms of a robustness degree `rho(phi,w,t)`, a function defined over real numbers extended with `+inf` and `-inf` that takes as input an STL specification `phi`, an input signal `w` and time index `t`, and computes how far is the signal `w` at time `t` from satisfying/violating `phi`. The robustness degree function is defined inductively as follows (`c` is a real constant, `x` is a variable, `w_x(t)` denotes the value of `w` projected to `x` at time `t`, `a,b` are rational constants such that `0 <= a <= b` and `|w|` is the length of `w`):\n\n\n\n```txt\n\n% Constant\n\nrho(c,w,t) = c\n\n\n\n% Variable\n\nrho(x,w,t) = w_x(t)\n\n\n\n% Absolute value, exponentials\n\nrho(abs(phi),w,t) = |rho(phi,w,t)|\n\nrho(exp(phi),w,t) = e**rho(phi,w,t)\n\nrho(pow(phi1, phi2),w,t) = rho(phi1,w,t)**rho(phi2,w,t)\n\n\n\n% Arithmetic operators\n\nrho(phi + psi,w,t) = rho(phi,w,t) + rho(psi,w,t)\n\nrho(phi - psi,w,t) = rho(phi,w,t) - rho(psi,w,t)\n\nrho(phi * psi,w,t) = rho(phi,w,t) * rho(psi,w,t)\n\nrho(phi / psi,w,t) = rho(phi,w,t) / rho(psi,w,t)\n\n\n\n% Numeric predicates\n\nrho(phi <= psi,w,t) = rho(psi,w,t) - rho(phi,w,t) \n\nrho(phi < psi,w,t) = rho(psi,w,t) - rho(phi,w,t)\n\nrho(phi >= psi,w,t) = rho(phi,w,t) - rho(psi,w,t)\n\nrho(phi > psi,w,t) = rho(phi,w,t) - rho(psi,w,t)\n\nrho(phi == psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|\n\nrho(phi !== psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|\n\n\n\n% Boolean operators\n\nrho(not(phi),w,t) = -rho(phi,w,t)\n\nrho(phi or psi,w,t) = max(rho(phi,w,t),rho(psi,w,t))\n\nrho(phi and psi,w,t) = min(rho(phi,w,t),rho(psi,w,t))\n\nrho(phi -> psi,w,t) = max(-rho(phi,w,t),rho(psi,w,t))\n\nrho(phi <-> psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|\n\nrho(phi xor psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|\n\n\n\n% Events\n\nrho(rise(phi),w,t) = rho(phi,w,t)                     if t=0\n\n                     min(-rho(phi,w,t-1),rho(phi,w,t) otherwise\n\nrho(fall(phi),w,t) = -rho(phi,w,t)                    if t=0\n\n                     min(rho(phi,w,t-1),-rho(phi,w,t) otherwise\n\n\n\n% Past untimed temporal operators\n\nrho(prev phi,w,t) = -inf            if t<=0\n\n                    rho(phi,w,t-1) otherwise\n\nrho(once phi,w,t) = max_{t' in [0,t]} rho(phi,w,t')\n\nrho(historically phi,w,t) = min_{t' in [0,t]} rho(phi,w,t')\n\nrho(phi since psi,w,t) = max_{t' in [0,t]}(min(rho(psi,w,t'), min_{t'' in (t',t]} rho(phi,w,t'')))\n\n\n\n% Past timed temporal operators\n\nrho(once[a,b] phi,w,t) = -inf                                                            if t-a < 0\n\n                         max_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')           otherwise\n\nrho(historically[a,b] phi,w,t) = inf                                                     if t-a < 0\n\n                                 min_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')   otherwise\n\nrho(phi since[a,b] psi,w,t) = -inf                                                       if t-a < 0 \n\n                              max_{t' in ([0,t] intersect [t-a,t-b]} (min(rho(psi,w,t'), \n\n                              min_{t'' in (t',t]} rho(phi,w,t'')))          otherwise\n\n\n\n% Future untimed temporal operators\n\nrho(next phi,w,t) = rho(phi,w,t+1)\n\nrho(eventually phi,w,t) = max_{t' in [t,|w|]} rho(phi,w,t')\n\nrho(always phi,w,t) = min_{t' in [t, |w|]} rho(phi,w,t')\n\nrho(phi until psi,w,t) = max_{t' in [t,|w|] min(rho(psi,w,t'), \n\n                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise\n\n\n\n\n\n% Future timed temporal operators\n\nrho(eventually[a,b] phi,w,t) = -inf                                                     if t+a >= |w|\n\n                               max_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')    otherwise\n\nrho(always[a,b] phi,w,t) = inf                                                          if t+a >= |w|\n\n                           min_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')        otherwise\n\nrho(phi until[a,b] psi,w,t) = -inf                                                      if t+a >= |w|\n\n                              max_{t' in ([0,t] intersect [t+a,t+b]}(min(rho(psi,w,t'), \n\n                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise   \n\n```\n\n\n\nWe define the robustness degree `rho(phi,w)` as `rho(phi,w,0)`.\n\n\n\nThere are several important points to note about the above syntax and semantics:\n\n\n\n- In the online monitoring mode, the library allows only bounded-future STL specifications, meaning that _unbounded_ future operators `always` `eventually` and `until` cannot appear in the specification.  \n\n- The `prev` and `next` operators are valid only under the discrete-time interpretation of STL\n\n- The `unless` operator is added as syntactic sugar - `phi unless[a,b] psi = always[0,b] phi or phi until[a,b] psi\n\n\n\nWe can see from the semantics of bounded-future STL that the direct evaluation of a formula `phi` at time `t` may depend on inputs at `t'>t` that have not arrived yet.\n\nThe library monitors bounded-future STL formulas with a fixed _delay_. In order to compute `rho(phi,w,t)`, the monitor waits for all inputs required to evaluate `phi` to become available before computing the robustness degree. This delay is fixed and depends on the specification. For instance, the specification `always((req >= 3) -> eventually[0:2]always[0:3](gnt >= 3)`is evaluated with delay `5` - the time needed to capture all inputs required for evaluating bounded `eventually` and `always` operators. We refer the reader to [2] for algorithmic details regarding monitoring with delay.\n\n\n\n# Usage\n\n\n\nThe API provides two monitoring classes:\n\n\n\n- `STLDiscreteTimeSpecification` for discrete-time monitors\n\n- `STLDenseTimeSpecification` for dense-time monitors\n\n\n\nBoth classes implement online and offline monitors:\n\n\n\n- `update` method is used for online evaluation\n\n. `evaluate` method is used for offline evaluation\n\n\n\n## Example Usage\n\n\n\n### Discrete-time online monitor\n\n\n\n```python\n\nimport sys\n\nimport rtamt\n\n\n\ndef monitor():\n\n    # # stl\n\n    spec = rtamt.STLSpecification()\n\n    spec.declare_var('a', 'float')\n\n    spec.declare_var('b', 'float')\n\n    spec.spec = 'eventually[0,1] (a >= b)'\n\n\n\n    try:\n\n        spec.parse()\n\n        spec.pastify()\n\n    except rtamt.RTAMTException as err:\n\n        print('RTAMT Exception: {}'.format(err))\n\n        sys.exit()\n\n\n\n    rob = spec.update(0, [('a', 100.0), ('b', 20.0)])\n\n    print('time=' + str(0) + ' rob=' + str(rob))\n\n\n\n    rob = spec.update(1, [('a', -1.0), ('b', 2.0)])\n\n    print('time=' + str(0) + ' rob=' + str(rob))\n\n\n\n    rob = spec.update(2, [('a', -2.0), ('b', -10.0)])\n\n    print('time=' + str(0) + ' rob=' + str(rob))\n\n\n\nif __name__ == '__main__':\n\n    monitor()\n\n```\n\n\n\n### Dense-time online monitor\n\n\n\n```python\n\nimport sys\n\nimport rtamt\n\n\n\ndef monitor():\n\n    a1 = [(0, 3), (3, 2)]\n\n    b1 = [(0, 2), (2, 5), (4, 1), (7, -7)]\n\n\n\n    a2 = [(5, 6), (6, -2), (8, 7), (11, -1)]\n\n    b2 = [(10, 4)]\n\n\n\n    a3 = [(13, -6), (15, 0)]\n\n    b3 = [(15, 0)]\n\n\n\n    # # stl\n\n    spec = rtamt.STLDenseTimeSpecification()\n\n    spec.name = 'STL dense-time specification'\n\n    spec.declare_var('a', 'float')\n\n    spec.spec = 'a>=2'\n\n    try:\n\n        spec.parse()\n\n    except rtamt.STLParseException as err:\n\n        print('STL Parse Exception: {}'.format(err))\n\n        sys.exit()\n\n\n\n    rob = spec.update(['a', a1], ['b', b1])\n\n    print('rob: ' + str(rob))\n\n\n\n    rob = spec.update(['a', a2], ['b', b2])\n\n    print('rob: ' + str(rob))\n\n\n\n    rob = spec.update(['a', a3], ['b', b3])\n\n    print('rob: ' + str(rob))\n\n\n\nif __name__ == '__main__':\n\n    monitor()\n\n```\n\n\n\n## Dense-time Offline Monitor\n\n\n\n```python\n\nimport sys\n\nimport rtamt\n\n\n\ndef monitor():\n\n\n\n    req = [[0.0, 0.0], [3.0, 6.0], [5.0, 0.0], [11.0, 0.0]]\n\n    gnt = [[0.0, 0.0], [7.0, 6.0], [9.0, 0.0], [11.0, 0.0]]\n\n    \n\n    spec = rtamt.STLDenseTimeSpecification()\n\n    spec.name = 'STL Dense-time Offline Monitor'\n\n    spec.declare_var('req', 'float')\n\n    spec.declare_var('gnt', 'float')\n\n    spec.declare_var('out', 'float')\n\n    spec.set_var_io_type('req', 'input')\n\n    spec.set_var_io_type('gnt', 'output')\n\n    spec.spec = 'out = always((req>=3) implies (eventually[0:5](gnt>=3)))'\n\n    try:\n\n        spec.parse()\n\n        spec.pastify()\n\n    except rtamt.STLParseException as err:\n\n        print('STL Parse Exception: {}'.format(err))\n\n        sys.exit()\n\n\n\n    rob = spec.evaluate(['req', req], ['gnt', gnt])\n\n\n\n    print('Robustness: {}'.format(rob))\n\n\n\nif __name__ == '__main__':\n\n    # Process arguments\n\n    monitor()\n\n```\n\n\n\n## Discrete-time Specifics\n\n\n\n### Working with time units and timing assumptions\n\n\n\nThe default unit in RTAMT is seconds, and the default expected period between two consecutive input samples is `1s` with `10%` tolerance.  \n\nThe following program uses these default values to implicitely set up the monitor.  \n\nThe specification intuitively states that whenever the `req` is above `3`, eventually within `5s` `gnt` also goes above `3`.  \n\nThe user feeds the monitor with values timestamped _exactly_ `1s` apart from each other. It follows that the periodic sampling assumption holds.\n\n\n\nRTAMT counts how many times the periodic sampling assumption has been violated up to the moment of being invoked via the `sampling_violation_counter` member.  \n\nIn this example, this violation obviously occurs `0` times.\n\n\n\n```python\n\n# examples/documentation/time_units_1.py\n\nimport sys\n\nimport rtamt\n\n\n\ndef monitor():\n\n    spec = rtamt.STLDiscreteTimeSpecification()\n\n    spec.name = 'Bounded-response Request-Grant'\n\n\n\n    spec.declare_var('req', 'float')\n\n    spec.declare_var('gnt', 'float')\n\n    spec.declare_var('out', 'float')\n\n\n\n    spec.spec = 'out = always((req>=3) implies (eventually[0:5](gnt>=3)))'\n\n\n\n    try:\n\n        spec.parse()\n\n        spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n        spec.update(1, [('req', 0.45), ('gnt', 0.12)])\n\n        spec.update(2, [('req', 0.78), ('gnt', 0.18)])\n\n        nb_violations = spec.sampling_violation_counter // nb_violations = 0\n\n    except rtamt.STLParseException as err:\n\n        print('STL Parse Exception: {}'.format(err))\n\n        sys.exit()\n\n\n\nif __name__ == '__main__':\n\n    # Process arguments\n\n    monitor()\n\n}\n\n```\n\n\n\nThe same program, but with slightly different timestamps still reports `0` number of periodic sampling assumption violations. This is because the difference between all consecutive sampling timestamps remains within the (implicitely) specified `10%` tolerance.\n\n\n\n```python\n\n# examples/documentation/time_units_2.py\n\n    ...\n\n    spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])\n\n    spec.update(1.98, [('req', 0.78), ('gnt', 0.18)])\n\n    nb_violations = spec.sampling_violation_counter // nb_violations = 0\n\n    ....\n\n```\n\n\n\nOn the other hand, the following sequence of inputs results in `1` reported violation of periodic sampling assumption.\n\nThis is because the third input is `1.12s` away from the second sample, which is `12%` above the assumed `1s` period.\n\n\n\n```python\n\n# examples/documentation/time_units_3.py\n\n    ...\n\n    spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])\n\n    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])\n\n    nb_violations = spec.sampling_violation_counter // nb_violations = 1\n\n```\n\n\n\nThis same sequence of inputs results in `0` reported violation of periodic sampling assumption if we explicitely set the sampling period tolerance value to `20%`.  \n\n\n\n```python\n\n# examples/documentation/time_units_4.py\n\n    ...\n\n    spec.set_sampling_period(1, 's', 0.2)\n\n    ...\n\n    spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])\n\n    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])\n\n    nb_violations = spec.sampling_violation_counter // nb_violations = 0\n\n```\n\n\n\nThe user can also explicitely set the default unit, as well as the expected period and tolerance. In that case, the user must ensure that the timing bounds declared in the specification are divisible by the sampling period. The following specification is correct, since the sampling period is set to `500ms`, the default unit is set to seconds, and the specification implicitely defines the bound from `0.5s = 500ms` and `1.5s = 1500ms`, i.e. between `1` amd `3` sampling periods.\n\n\n\n```python\n\n# examples/documentation/time_units_5.py\n\n    ...\n\n    spec.unit = 's'\n\n    spec.set_sampling_period(500, 'ms', 0.1)\n\n    ...\n\n    spec.spec = 'out = always((req>=3) implies (eventually[0.5:1.5](gnt>=3)))'\n\n    ...\n\n    spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n    spec.update(0.5, [('req', 0.45), ('gnt', 0.12)])\n\n    spec.update(1, [('req', 0.78), ('gnt', 0.18)])\n\n    nb_violations = spec.sampling_violation_counter // nb_violations = 0\n\n}\n\n```\n\n\n\nThe following defines the same program, but now with `ms` as the default unit.\n\n\n\n```python\n\n # examples/documentation/time_units_6.py\n\n    ...\n\n    spec.unit = 'ms'\n\n    spec.set_sampling_period(500, 'ms', 0.1)\n\n    ...\n\n    spec.spec = 'out = always((req>=3) implies (eventually[500:1500](gnt>=3)))'\n\n    ...\n\n    spec.update(0, [('req', 0.1), ('gnt', 0.3)])\n\n    spec.update(500, [('req', 0.45), ('gnt', 0.12)])\n\n    spec.update(1000, [('req', 0.78), ('gnt', 0.18)])\n\n    nb_violations = spec.sampling_violation_counter // nb_violations = 0\n\n}\n\n```\n\n\n\nThe following program throws an exception - the temporal bound is defined between `500ms` and `1500ms`, while the sampling period equals to `1s = 1000ms`.\n\n\n\n```python\n\n# examples/documentation/time_units_7.py\n\n    ...\n\n    spec.unit = 'ms'\n\n    spec.set_sampling_period(1, 's', 0.1)\n\n    ...\n\n    spec.spec = 'out = always((req>=3) implies (eventually[500:1500](gnt>=3)))'\n\n    ...\n\n    spec.parse()\n\n    ...\n\n    \n\n}\n\n```\n\n\n\nFinally, the following program is correct, because the temporal bound is explicitely defined between `500s` and `1500s`, while the sampling period equals to `1s`.\n\n\n\n```python\n\n# examples/documentation/time_units_8.py\n\n    ...\n\n    spec.unit = 'ms'\n\n    spec.set_sampling_period(1, 's', 0.1)\n\n    ...\n\n    spec.spec = 'out = always((req>=3) implies (eventually[500s:1500s](gnt>=3)))'\n\n    ...\n\n    spec.parse()\n\n    ...\n\n```\n\n\n\n# References\n\n\n\n- [1] Dejan Nickovic, Tomoya Yamaguchi: RTAMT: Online Robustness Monitors from STL. CoRR abs/2005.11827 (2020)\n\n- [2] Stefan Jaksic, Ezio Bartocci, Radu Grosu, Reinhard Kloibhofer, Thang Nguyen, Dejan Nickovic: From signal temporal logic to FPGA monitors. MEMOCODE 2015: 218-227\n\n- [3] Thomas Ferrère, Dejan Nickovic, Alexandre Donzé, Hisahiro Ito, James Kapinski: Interface-aware signal temporal logic. HSCC 2019: 57-66\n\n- [4] Thomas A. Henzinger, Zohar Manna, Amir Pnueli: What Good Are Digital Clocks? ICALP 1992: 545-558\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/nickovic/rtamt",
    "keywords": "",
    "license": "BSD",
    "maintainer": "",
    "maintainer_email": "",
    "name": "rtamt",
    "package_url": "https://pypi.org/project/rtamt/",
    "platform": null,
    "project_url": "https://pypi.org/project/rtamt/",
    "project_urls": {
      "Homepage": "https://github.com/nickovic/rtamt"
    },
    "release_url": "https://pypi.org/project/rtamt/0.3/",
    "requires_dist": [
      "antlr4-python3-runtime (>=4.5)"
    ],
    "requires_python": ">=3.5",
    "summary": "Library for specification-based online monitoring.",
    "version": "0.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13291721,
  "releases": {
    "0.2.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "079a8addda0fc9f1b40ce8a35ced253433cc5f38ebfaa9446f88ba0eb8b98de0",
          "md5": "5f5881d56c3fa13ddfaed31c150ad8e0",
          "sha256": "2135c9cf836082eb51fa81fb6a99cbe91f9c8b3b6471b1caad39614d4ef8cadd"
        },
        "downloads": -1,
        "filename": "rtamt-0.2.5-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5f5881d56c3fa13ddfaed31c150ad8e0",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": null,
        "size": 1539912,
        "upload_time": "2021-10-16T21:11:44",
        "upload_time_iso_8601": "2021-10-16T21:11:44.653196Z",
        "url": "https://files.pythonhosted.org/packages/07/9a/8addda0fc9f1b40ce8a35ced253433cc5f38ebfaa9446f88ba0eb8b98de0/rtamt-0.2.5-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "66d10da2d5f267652167a60d0d7002ecb60e2d0250cd5c1be7c94b576a86eb05",
          "md5": "5ce9960cde449be46125c44a2b6c80ba",
          "sha256": "b77f38f271a21ab82b208c280f8f5d6d3d657cf6bb05f1cb406505cbca88b541"
        },
        "downloads": -1,
        "filename": "rtamt-0.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5ce9960cde449be46125c44a2b6c80ba",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 1405619,
        "upload_time": "2021-10-16T21:11:49",
        "upload_time_iso_8601": "2021-10-16T21:11:49.336885Z",
        "url": "https://files.pythonhosted.org/packages/66/d1/0da2d5f267652167a60d0d7002ecb60e2d0250cd5c1be7c94b576a86eb05/rtamt-0.2.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2256f9c61b79fd71f7bea5f14c9fcb94828c4498257ceae30567a1b67d599953",
          "md5": "89abd058a9c503d0e55bf4cb70d4c966",
          "sha256": "1ee2d2e1f0607d61ee79ab72373f7e835c3bd82f1afdfeb8e369a12d4e96b5b9"
        },
        "downloads": -1,
        "filename": "rtamt-0.2.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "89abd058a9c503d0e55bf4cb70d4c966",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7",
        "size": 229855,
        "upload_time": "2022-03-25T10:00:56",
        "upload_time_iso_8601": "2022-03-25T10:00:56.166220Z",
        "url": "https://files.pythonhosted.org/packages/22/56/f9c61b79fd71f7bea5f14c9fcb94828c4498257ceae30567a1b67d599953/rtamt-0.2.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0d370bcb23a899f5887c06b5ff389f108f3a473d8093b2832c8d7455b187c7f3",
          "md5": "6b7ba7cb92ac7995938ef9ab62317928",
          "sha256": "16ac899afe36c2c4d49c6db7b561f27e13fe83d2e621a7a46ebdf4157c8f658e"
        },
        "downloads": -1,
        "filename": "rtamt-0.2.8.tar.gz",
        "has_sig": false,
        "md5_digest": "6b7ba7cb92ac7995938ef9ab62317928",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7",
        "size": 127330,
        "upload_time": "2022-03-25T10:00:59",
        "upload_time_iso_8601": "2022-03-25T10:00:59.317115Z",
        "url": "https://files.pythonhosted.org/packages/0d/37/0bcb23a899f5887c06b5ff389f108f3a473d8093b2832c8d7455b187c7f3/rtamt-0.2.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e38aa03d954f0a3d81195be14ca9d72c60fcd7e2a4fb53d6206d0637e5bca232",
          "md5": "c0e29eddbf649858bd4db2dd1dff264b",
          "sha256": "ee3d0e6aa85e9f116655622358169e34a2ba81081167af706ac698e8e403e8e5"
        },
        "downloads": -1,
        "filename": "rtamt-0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c0e29eddbf649858bd4db2dd1dff264b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.5",
        "size": 203441,
        "upload_time": "2022-03-25T10:16:38",
        "upload_time_iso_8601": "2022-03-25T10:16:38.649532Z",
        "url": "https://files.pythonhosted.org/packages/e3/8a/a03d954f0a3d81195be14ca9d72c60fcd7e2a4fb53d6206d0637e5bca232/rtamt-0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9c35a3718af0019deb14dde02b2df1d1911e6c2de9b0411cb22687e768bbaa50",
          "md5": "e313725257ec96182611e49cf595936b",
          "sha256": "8411f0234f6227bc5c63ef4b148c7ac44c84dcf894e0910bb7f8be06392dee6d"
        },
        "downloads": -1,
        "filename": "rtamt-0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e313725257ec96182611e49cf595936b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 106345,
        "upload_time": "2022-03-25T10:16:40",
        "upload_time_iso_8601": "2022-03-25T10:16:40.998914Z",
        "url": "https://files.pythonhosted.org/packages/9c/35/a3718af0019deb14dde02b2df1d1911e6c2de9b0411cb22687e768bbaa50/rtamt-0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e38aa03d954f0a3d81195be14ca9d72c60fcd7e2a4fb53d6206d0637e5bca232",
        "md5": "c0e29eddbf649858bd4db2dd1dff264b",
        "sha256": "ee3d0e6aa85e9f116655622358169e34a2ba81081167af706ac698e8e403e8e5"
      },
      "downloads": -1,
      "filename": "rtamt-0.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "c0e29eddbf649858bd4db2dd1dff264b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.5",
      "size": 203441,
      "upload_time": "2022-03-25T10:16:38",
      "upload_time_iso_8601": "2022-03-25T10:16:38.649532Z",
      "url": "https://files.pythonhosted.org/packages/e3/8a/a03d954f0a3d81195be14ca9d72c60fcd7e2a4fb53d6206d0637e5bca232/rtamt-0.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9c35a3718af0019deb14dde02b2df1d1911e6c2de9b0411cb22687e768bbaa50",
        "md5": "e313725257ec96182611e49cf595936b",
        "sha256": "8411f0234f6227bc5c63ef4b148c7ac44c84dcf894e0910bb7f8be06392dee6d"
      },
      "downloads": -1,
      "filename": "rtamt-0.3.tar.gz",
      "has_sig": false,
      "md5_digest": "e313725257ec96182611e49cf595936b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 106345,
      "upload_time": "2022-03-25T10:16:40",
      "upload_time_iso_8601": "2022-03-25T10:16:40.998914Z",
      "url": "https://files.pythonhosted.org/packages/9c/35/a3718af0019deb14dde02b2df1d1911e6c2de9b0411cb22687e768bbaa50/rtamt-0.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}