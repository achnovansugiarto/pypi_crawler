{
  "info": {
    "author": "Tobias Rawald",
    "author_email": "pyrqa@gmx.net",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "Intended Audience :: Financial and Insurance Industry",
      "Intended Audience :: Healthcare Industry",
      "Intended Audience :: Manufacturing",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering :: Artificial Intelligence",
      "Topic :: Scientific/Engineering :: Mathematics",
      "Topic :: Scientific/Engineering :: Physics"
    ],
    "description": "PyRQA\n=====\n\nHighlights\n----------\n\n-  Perform recurrence analysis on long time series in a time efficient\n   manner using the OpenCL framework.\n-  Conduct recurrence quantification analysis (*RQA*) and cross\n   recurrence quantification analysis (*CRQA*).\n-  Compute recurrence plots (*RP*) and cross recurrence plots (*CRP*).\n-  Compute unthresholded recurrence plots (*URP*) and unthresholded\n   cross recurrence plots (*UCRP*).\n-  Conduct joint recurrence quantification analysis (*JRQA*) and compute\n   joint recurrence plots (*JRP*).\n-  Employ the euclidean, maximum or taxicab metric for determining state\n   similarity.\n-  Choose the fixed radius or radius corridor neighbourhood condition.\n-  Use univariate time series or pre-embedded time series as input data.\n-  Select either the half, single or double floating point precision for\n   conducting the analytical computations.\n-  Leverage machine learning techniques that automatically choose the\n   fastest from a set of implementations.\n-  Apply the computing capabilities of GPUs, CPUs and other platforms\n   that support OpenCL.\n-  Use multiple computing devices of the same or different type in\n   parallel.\n\nTable of Contents\n-----------------\n\n1.  `General Information <#general-information>`__\n2.  `Recommended Citation <#recommended-citation>`__\n3.  `Installation <#installation>`__\n4.  `OpenCL Setup <#opencl-setup>`__\n5.  `Usage <#usage>`__\n6.  `Performance Tuning <#performance-tuning>`__\n7.  `Testing <#testing>`__\n8.  `Origin <#origin>`__\n9.  `Acknowledgements <#acknowledgements>`__\n10. `Publications <#publications>`__\n11. `Development Status <#development-status>`__\n12. `Release Notes <#release-notes>`__\n\nGeneral Information\n-------------------\n\nPyRQA is a tool to conduct recurrence analysis in a massively parallel\nmanner using the OpenCL framework. It is designed to efficiently process\ntime series consisting of hundreds of thousands of data points.\n\nPyRQA supports the computation of the following quantitative measures:\n\n-  Recurrence rate (*RR*)\n-  Determinism (*DET*)\n-  Average diagonal line length (*L*)\n-  Longest diagonal line length (*L\\_max*)\n-  Divergence (*DIV*)\n-  Entropy diagonal lines (*L\\_entr*)\n-  Laminarity (*LAM*)\n-  Trapping time (*TT*)\n-  Longest vertical line length (*V\\_max*)\n-  Entropy vertical lines (*V\\_entr*)\n-  Average white vertical line length (*W*)\n-  Longest white vertical line length (*W\\_max*)\n-  Longest white vertical line length divergence (*W\\_div*)\n-  Entropy white vertical lines (*W\\_entr*)\n\nPyRQA additionally allows to create the corresponding recurrence plot,\nwhich can be exported as an image file.\n\nRecommended Citation\n--------------------\n\nPlease acknowledge the use of PyRQA by citing the following publication.\n\n    Rawald, T., Sips, M., Marwan, N. (2017): PyRQA - Conducting\n    Recurrence Quantification Analysis on Very Long Time Series\n    Efficiently. - Computers and Geosciences, 104, pp. 101-108.\n\nInstallation\n------------\n\nPyRQA and all of its dependencies can be installed via the following\ncommand.\n\n.. code:: bash\n\n    pip install PyRQA\n\nOpenCL Setup\n------------\n\nThe analytical implementations provided by PyRQA rely on features that\nare part of *OpenCL 1.1*, which is a fairly mature standard and\nsupported by a large number of platforms. The OpenCL computing devices\nemployed need to support at least this version to being able to use\nPyRQA.\n\nIt may be required to install additional software, e.g., runtimes or\ndrivers, to execute PyRQA on computing devices such as GPUs and CPUs.\nReferences to vendor-specific information are presented below.\n\n*AMD*:\n\n-  https://www.amd.com/en/support\n-  https://github.com/RadeonOpenCompute/ROCm\n-  https://community.amd.com/community/devgurus/opencl\n-  https://www.amd.com/en/support/kb/release-notes/amdgpu-installation\n\n*ARM*:\n\n-  https://developer.arm.com/docs/100614/0312\n\n*Intel*:\n\n-  https://software.intel.com/en-us/articles/opencl-drivers\n-  https://software.intel.com/en-us/articles/sdk-for-opencl-gsg\n\n*NVIDIA*:\n\n-  https://developer.nvidia.com/opencl\n-  https://developer.nvidia.com/cuda-downloads\n\n*Vendor-independent*:\n\n-  http://portablecl.org\n\nUsage\n-----\n\nThe following subsections depict the usage of PyRQA. Each subsection\nfocuses on specific functionality that is provided by the package. The\npresentation of expected output shall ensure the reproducibility of the\nanalytical results.\n\nBasic Computations\n~~~~~~~~~~~~~~~~~~\n\nRQA computations are conducted as follows.\n\n.. code:: python\n\n    from pyrqa.time_series import TimeSeries\n    from pyrqa.settings import Settings\n    from pyrqa.analysis_type import Classic\n    from pyrqa.neighbourhood import FixedRadius\n    from pyrqa.metric import EuclideanMetric\n    from pyrqa.computation import RQAComputation\n    data_points = [0.1, 0.5, 1.3, 0.7, 0.8, 1.4, 1.6, 1.2, 0.4, 1.1, 0.8, 0.2, 1.3]\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2)\n    settings = Settings(time_series,\n                        analysis_type=Classic,\n                        neighbourhood=FixedRadius(0.65),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=1)\n    computation = RQAComputation.create(settings,\n                                        verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 2\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    RQA Result:\n    ===========\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 2\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.371901\n    Determinism (DET): 0.411765\n    Average diagonal line length (L): 2.333333\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.636514\n    Laminarity (LAM): 0.400000\n    Trapping time (TT): 2.571429\n    Longest vertical line length (V_max): 4\n    Entropy vertical lines (V_entr): 0.955700\n    Average white vertical line length (W): 2.538462\n    Longest white vertical line length (W_max): 6\n    Longest white vertical line length inverse (W_div): 0.166667\n    Entropy white vertical lines (W_entr): 0.839796\n\n    Ratio determinism / recurrence rate (DET/RR): 1.107190\n    Ratio laminarity / determinism (LAM/DET): 0.971429\n\nThe corresponding recurrence plot is created likewise. Note that the\nparameter ``theiler_corrector`` is ignored regarding the creation of the\nplot.\n\n.. code:: python\n\n    from pyrqa.computation import RPComputation\n    from pyrqa.image_generator import ImageGenerator\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'recurrence_plot.png')\n\nCross Recurrence Analysis\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA further offers the opportunity to conduct cross recurrence\nanalysis (*CRQA* and *CRP*), in addition to the classic recurrence\nanalysis (*RQA* and *RP*). For this purpose, two time series of\npotentially different length are provided as input. Note that the\ncorresponding computations require to set the same value regarding the\nembedding dimension. Two different time delay values may be used\nregarding the first and the second time series. To enable cross\nrecurrence analysis, the parameter ``analysis_type`` has to be changed\nfrom ``Classic`` to ``Cross``, when creating the ``Settings`` object. A\n*CRQA* example is given below.\n\n.. code:: python\n\n    from pyrqa.analysis_type import Cross\n    data_points_x = [0.9, 0.1, 0.2, 0.3, 0.5, 1.7, 0.4, 0.8, 1.5]\n    time_series_x = TimeSeries(data_points_x,\n                               embedding_dimension=2,\n                               time_delay=1)\n    data_points_y = [0.3, 1.3, 0.6, 0.2, 1.1, 1.9, 1.3, 0.4, 0.7, 0.9, 1.6]\n    time_series_y = TimeSeries(data_points_y,\n                               embedding_dimension=2,\n                               time_delay=2)\n    time_series = (time_series_x,\n                   time_series_y)\n    settings = Settings(time_series,\n                        analysis_type=Cross,\n                        neighbourhood=FixedRadius(0.73),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=0)\n    computation = RQAComputation.create(settings,\n                                        verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 2\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    CRQA Result:\n    ============\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 2\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.319444\n    Determinism (DET): 0.521739\n    Average diagonal line length (L): 2.400000\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.673012\n    Laminarity (LAM): 0.434783\n    Trapping time (TT): 2.500000\n    Longest vertical line length (V_max): 3\n    Entropy vertical lines (V_entr): 0.693147\n    Average white vertical line length (W): 3.500000\n    Longest white vertical line length (W_max): 8\n    Longest white vertical line length inverse (W_div): 0.125000\n    Entropy white vertical lines (W_entr): 1.424130\n\n    Ratio determinism / recurrence rate (DET/RR): 1.633270\n    Ratio laminarity / determinism (LAM/DET): 0.833333\n\nThe corresponding cross recurrence plot is created likewise.\n\n.. code:: python\n\n    from pyrqa.computation import RPComputation\n    from pyrqa.image_generator import ImageGenerator\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'cross_recurrence_plot.png')\n\nNeighbourhood Condition Selection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA currently supports the fixed radius as well as the radius corridor\nneighbourhood condition. While the first refers to a single radius, the\nlatter requires the assignment of an inner and outer radius. The\nspecific condition is passed using the parameter ``neighbourhood`` to\nthe constructor of a ``Settings`` object. The creation of a fixed radius\nand a radius corridor neighbourhood is presented below.\n\n.. code:: python\n\n    from pyrqa.neighbourhood import FixedRadius, RadiusCorridor\n    fixed_radius = FixedRadius(radius=0.43)\n    radius_corridor = RadiusCorridor(inner_radius=0.32, \n                                     outer_radius=0.86)          \n\nUnthresholded Recurrence Plots\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA allows to create unthresholded *RP*\\ s and *CRP*\\ s by selecting\nthe ``Unthresholded`` neighbourhood condition. This results in a\nnon-binary matrix, containing the mutual distances between the system\nstates, based on the similarity measure selected. PyRQA provides\nfunctionality to normalize these distances to values between ``0`` and\n``1``. Additionally, the normalized matrix can be represented as a\ngrayscale image. Darker shades of grey indicate smaller distances\nwhereas lighter shades of grey indicate larger distances. An example on\nhow to create an unthresholded cross recurrence plot is given below.\n\n.. code:: python\n\n    from pyrqa.neighbourhood import Unthresholded\n    settings = Settings(time_series,\n                        analysis_type=Cross,\n                        neighbourhood=Unthresholded(),\n                        similarity_measure=EuclideanMetric)\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_unthresholded_recurrence_plot(result.recurrence_matrix_reverse_normalized,\n                                                      'unthresholded_cross_recurrence_plot.png')\n\nJoint Recurrence Analysis\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn addition to classic and cross recurrence analysis, PyRQA provides\nfunctionality to conduct joint recurrence analysis. This includes in\nparticular joint recurrence quantification analysis (*JRQA*) as well as\njoint recurrence plot (*JRP*). On an abstract level, a joint recurrence\nplot is a combination of two individual plots, both having the same\nextent regarding the *X* and *Y* axis. Regarding PyRQA, each of those\ntwo plots may either be of the analysis type ``Classic`` or ``Cross``,\npotentially having different characteristics regarding:\n\n-  Time series data,\n-  Embedding dimension,\n-  Time delay,\n-  Neighbourhood condition, and\n-  Similarity measure.\n\nIn contrast, the same value for ``theiler_corrector`` is expected\nregarding the quantitative analysis. Note that a joint recurrence plot\nby definition relies on thresholded input plots, eliminating the\napplication of the ``Unthresholded`` neighbourhood condition.\n\nThe settings of the two individual plots are encapsulated in a\n``JointSettings`` object. The quantification of joint recurrence plots\nis based on the same measures as for recurrence plots and cross\nrecurrence plots. An example on how to conduct *JRQA* is given below.\n\n.. code:: python\n\n    from pyrqa.computation import JRQAComputation\n    from pyrqa.metric import MaximumMetric, TaxicabMetric\n    from pyrqa.settings import JointSettings\n    data_points_1 = [1.0, 0.7, 0.5, 0.1, 1.7, 1.5, 1.2, 0.4, 0.6, 1.5, 0.8, 0.3]\n    time_series_1 = TimeSeries(data_points,\n                               embedding_dimension=3,\n                               time_delay=1)\n    settings_1 = Settings(time_series_1,\n                          analysis_type=Classic,\n                          neighbourhood=RadiusCorridor(inner_radius=0.14,\n                                                       outer_radius=0.97),\n                          similarity_measure=MaximumMetric,\n                          theiler_corrector=1)\n    data_points_2_x = [0.7, 0.1, 1.1, 1.4, 1.0, 0.5, 1.0, 1.9, 1.7, 0.9, 1.5, 0.6]\n    time_series_2_x = TimeSeries(data_points_2_x,\n                                 embedding_dimension=2,\n                                 time_delay=1)\n    data_points_2_y = [0.4, 0.7, 0.9, 0.3, 1.9, 1.3, 1.2, 0.2, 1.1, 0.6, 0.8, 0.1, 0.5]\n    time_series_2_y = TimeSeries(data_points_2_y,\n                                 embedding_dimension=2,\n                                 time_delay=2)\n    time_series_2 = (time_series_2_x,\n                     time_series_2_y)\n    settings_2 = Settings(time_series_2,\n                          analysis_type=Cross,\n                          neighbourhood=FixedRadius(0.83),\n                          similarity_measure=TaxicabMetric,\n                          theiler_corrector=1)\n    joint_settings = JointSettings(settings_1,\n                                   settings_2)\n    computation = JRQAComputation.create(joint_settings,\n                                         verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 1\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    JRQA Result:\n    ============\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 1\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.157025\n    Determinism (DET): 0.263158\n    Average diagonal line length (L): 2.500000\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.693147\n    Laminarity (LAM): 1.000000\n    Trapping time (TT): 1.000000\n    Longest vertical line length (V_max): 1\n    Entropy vertical lines (V_entr): 0.000000\n    Average white vertical line length (W): 3.960000\n    Longest white vertical line length (W_max): 11\n    Longest white vertical line length inverse (W_div): 0.090909\n    Entropy white vertical lines (W_entr): 1.588760\n\n    Ratio determinism / recurrence rate (DET/RR): 1.675900\n    Ratio laminarity / determinism (LAM/DET): 3.800000\n\nThe corresponding joint recurrence plot is created likewise.\n\n.. code:: python\n\n    from pyrqa.computation import JRPComputation\n    computation = JRPComputation.create(joint_settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'joint_recurrence_plot.png')\n\nTime Series Embedding\n~~~~~~~~~~~~~~~~~~~~~\n\nThe previous examples refer to one or multiple univariate time series as\ninput data. These ``TimeSeries`` are embedded in multi-dimensional space\nusing the time delay method. In addition, PyRQA allows to analyze time\nseries that are already embedded in multi-dimensional space. These\n``EmbeddedSeries`` are represented as a list of *m*-dimensional arrays,\nwhere *m* refers to the embedding dimension. An example of using a\npre-embedded series considering recurrence quantification analysis is\ngiven below.\n\n.. code:: python\n\n    from pyrqa.time_series import EmbeddedSeries\n    data_points = [[0.1, 1.3], [0.5, 0.7], [1.3, 0.8], [0.7, 1.4], [0.8, 1.6], [1.4, 1.2], [1.6, 0.4], [1.2, 1.1], [0.4, 0.8], [1.1, 0.2], [0.8, 1.3]]\n    embedded_series = EmbeddedSeries(data_points)\n    settings = Settings(embedded_series,\n                        analysis_type=Classic,\n                        neighbourhood=FixedRadius(0.65),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=1)\n    computation = RQAComputation.create(settings,\n                                        verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 2\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    RQA Result:\n    ===========\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 2\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.371901\n    Determinism (DET): 0.411765\n    Average diagonal line length (L): 2.333333\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.636514\n    Laminarity (LAM): 0.400000\n    Trapping time (TT): 2.571429\n    Longest vertical line length (V_max): 4\n    Entropy vertical lines (V_entr): 0.955700\n    Average white vertical line length (W): 2.538462\n    Longest white vertical line length (W_max): 6\n    Longest white vertical line length inverse (W_div): 0.166667\n    Entropy white vertical lines (W_entr): 0.839796\n\n    Ratio determinism / recurrence rate (DET/RR): 1.107190\n    Ratio laminarity / determinism (LAM/DET): 0.971429\n\nNote that this example corresponds to the introductory example, which\ndemonstrates the basic usage. It differs regarding the representation of\nthe multi-dimensional vectors. ``EmbeddedSeries`` objects can be used\nwhile conducting recurrence analysis, cross recurrence analysis as well\nas joint recurrence analysis. This refers to performing quantitative\nanalyses as well as creating recurrence plots. Regarding cross and joint\nrecurrence analysis ``TimeSeries`` objects may be combined with\n``EmbeddedSeries`` objects.\n\nCustom OpenCL Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe previous examples use the default OpenCL environment. A custom\nenvironment can also be created via command line input. For this\npurpose, the parameter ``command_line`` has to be set to ``True``, when\ncreating an ``OpenCL`` object.\n\n.. code:: python\n\n    from pyrqa.opencl import OpenCL\n    opencl = OpenCL(command_line=True)\n\nThe OpenCL platform as well as the computing devices can also be\nselected manually using their identifiers.\n\n.. code:: python\n\n    opencl = OpenCL(platform_id=0,\n                    device_ids=(0,))\n\nThe ``OpenCL`` object generated is passed as a parameter while creating\na computation object.\n\n.. code:: python\n\n    computation = RPComputation.create(settings,\n                                       verbose=True,\n                                       opencl=opencl)\n\nFloating Point Precision\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA allows to specify the precision of the time series data, which in\nturn determines the precision of the computations conducted by the\nOpenCL devices. Currently, the following precisions are supported:\n\n-  Half precision (16-bit),\n-  Single precision (32-bit), and\n-  Double precision (64-bit).\n\nBy default, the single precision is applied. Note that not all\nprecisions may be supported by the OpenCL devices employed. Furthermore,\nthe selected precision influences the performance of the computations on\na particular device.\n\nThe precision is set by specifying the corresponding data type, short\n``dtype``, of the time series data. The following example depicts the\nusage of double precision floating point values.\n\n.. code:: python\n\n    import numpy as np\n    data_points = [0.1, 0.5, 1.3, 0.7, 0.8, 1.4, 1.6, 1.2, 0.4, 1.1, 0.8, 0.2, 1.3]\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2,\n                             dtype=np.float64)\n\nPerformance Tuning\n------------------\n\nPyRQA offers the opportunity to reduce the runtime of analytical\ncomputations using performance tuning. There is a distinction between\nmanual as well as automatic performance tuning. Both aspects are\nhighlighted in the following subsections. Note that every analytical\nmethod implemented by PyRQA can be executed without conducting\nperformance tuning. Nonetheless, it may enable significant runtime\nreductions regarding the analysis of very long time series.\n\nAdaptive Implementation Selection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAdaptive implementation selection allows to automatically select well\nperforming implementations regarding RQA and recurrence plot\ncomputations provided by PyRQA. The approach dynamically adapts the\nselection to the current computational scenario as well as the\nproperties of the OpenCL devices employed. The selection is performed\nusing one of multiple strategies, each referred to as ``selector``. They\nrely on a set of customized implementation ``variants``, which may be\nparameterized using a set of keyword arguments called\n``variants_kwargs``. Note that the same selection strategies can be used\nfor *RQA* and *CRQA*, *RP* and *CRP*, *URP* and *UCRP* as well as *JRQA*\nand *JRP* computations.\n\n.. code:: python\n\n    from pyrqa.variants.rqa.radius.column_no_overlap_materialisation_bit_no_recycling import ColumnNoOverlapMaterialisationBitNoRecycling\n    from pyrqa.variants.rqa.radius.column_no_overlap_materialisation_bit_recycling import ColumnNoOverlapMaterialisationBitRecycling\n    from pyrqa.variants.rqa.radius.column_no_overlap_materialisation_byte_no_recycling import ColumnNoOverlapMaterialisationByteNoRecycling\n    from pyrqa.variants.rqa.radius.column_no_overlap_materialisation_byte_recycling import ColumnNoOverlapMaterialisationByteRecycling\n    from pyrqa.variants.rqa.radius.column_no_overlap_no_materialisation import ColumnNoOverlapNoMaterialisation\n    from pyrqa.variants.rqa.radius.column_overlap_materialisation_bit_no_recycling import ColumnOverlapMaterialisationBitNoRecycling\n    from pyrqa.variants.rqa.radius.column_overlap_materialisation_bit_recycling import ColumnOverlapMaterialisationBitRecycling\n    from pyrqa.variants.rqa.radius.column_overlap_materialisation_byte_no_recycling import ColumnOverlapMaterialisationByteNoRecycling\n    from pyrqa.variants.rqa.radius.column_overlap_materialisation_byte_recycling import ColumnOverlapMaterialisationByteRecycling\n    from pyrqa.variants.rqa.radius.column_overlap_no_materialisation import ColumnOverlapNoMaterialisation\n    from pyrqa.selector import EpsilonGreedySelector\n    data_points = [0.1, 0.5, 1.3, 0.7, 0.8, 1.4, 1.6, 1.2, 0.4, 1.1, 0.8, 0.2, 1.3]\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2)\n    settings = Settings(time_series,\n                        analysis_type=Classic,\n                        neighbourhood=FixedRadius(0.65),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=1)\n    computation = RQAComputation.create(settings,\n                                        selector=EpsilonGreedySelector(explore=10),\n                                        variants=(ColumnNoOverlapMaterialisationBitNoRecycling,\n                                                  ColumnNoOverlapMaterialisationBitRecycling,\n                                                  ColumnNoOverlapMaterialisationByteNoRecycling,\n                                                  ColumnNoOverlapMaterialisationByteRecycling,\n                                                  ColumnNoOverlapNoMaterialisation,\n                                                  ColumnOverlapMaterialisationBitNoRecycling,\n                                                  ColumnOverlapMaterialisationBitRecycling,\n                                                  ColumnOverlapMaterialisationByteNoRecycling,\n                                                  ColumnOverlapMaterialisationByteRecycling,\n                                                  ColumnOverlapNoMaterialisation))\n\nInput Data Overlapping\n~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA comprises a set of ``variants`` for each analytical method, which\ndiffer regarding certain implementation details. The specific\ncharacteristics of each variant are reflected in its name. The naming\nconvention is applied accordingly to all analytical methods.\n\nOne criterion is the way how the input data is represented within the\nmemory of the computing devices. The multi-dimensional vectors may\neither be stored column-wise or row-wise. Considering ``TimeSeries``\nobjects, to which the time delay method is applied, the columns may\nadditionally be stored in an overlapped fashion. This allows leveraging\ndata compression as well as potential runtime reductions. Using\n``EmbeddedSeries`` objects as input data, the multi-dimensional vectors\nmay only be stored non-overlapping. As an example, variants referring to\nthe joint recurrence quantification analysis are mentioned below.\n\n.. code:: python\n\n    from pyrqa.variants.jrqa.radius.column_no_overlap_materialisation_byte_no_recycling import ColumnNoOverlapMaterialisationByteNoRecycling\n    from pyrqa.variants.jrqa.radius.row_no_overlap_materialisation_byte_no_recycling import RowNoOverlapMaterialisationByteNoRecycling\n    from pyrqa.variants.jrqa.radius.column_overlap_materialisation_byte_no_recycling import ColumnOverlapMaterialisationByteNoRecycling\n\nNote that these variants have the same implementation characteristics,\nexcept from the representation of the input data. Only those variants\nthat store the input data non-overlapping may be applied to\n``EmbeddedSeries`` objects. By default, non-overlapping variants are\nselected.\n\nOpenCL Compiler Optimisations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOpenCL compiler optimisations aim at improving the performance of the\noperations conducted by the computing devices. Regarding PyRQA, they are\ndisabled by default to ensure the comparability of the analytical\nresults. They can be enabled by assigning the value ``True`` to the\ncorresponding keyword argument ``optimisations_enabled``.\n\n.. code:: python\n\n    computation = RQAComputation.create(settings,\n                                        selector=EpsilonGreedySelector(explore=10),\n                                        variants=(ColumnNoOverlapMaterialisationBitNoRecycling,\n                                                  ColumnNoOverlapMaterialisationBitRecycling,\n                                                  ColumnNoOverlapMaterialisationByteNoRecycling,\n                                                  ColumnNoOverlapMaterialisationByteRecycling,\n                                                  ColumnNoOverlapNoMaterialisation,\n                                                  ColumnOverlapMaterialisationBitNoRecycling,\n                                                  ColumnOverlapMaterialisationBitRecycling,\n                                                  ColumnOverlapMaterialisationByteNoRecycling,\n                                                  ColumnOverlapMaterialisationByteRecycling,\n                                                  ColumnOverlapNoMaterialisation),\n                                        variants_kwargs={'optimisations_enabled': True})\n\nLoop Unrolling\n~~~~~~~~~~~~~~\n\nBesides gaining drastic performance improvements using parallel\ncomputing techniques, parts of the PyRQA kernel processing rely on\nloops. OpenCL offers the opportunity to leverage additional performance\nimprovements by unrolling these loops. This is conducted by the OpenCL\ncompiler that is applied to the kernel functions. Note that loop\nunrolling may not be supported by all OpenCL platforms.\n\nPyRQA offers the opportunity to manually specify loop unrolling factors\nthat can be passed as a tuple when creating a selector. While creating a\ncomputation object, each factor is combined with each implementation\nvariant. The resulting combinations are further used regarding adaptive\nimplementation selection. An example on how to specify loop unrolling\nfactors is given below.\n\n.. code:: python\n\n    from pyrqa.selector import EpsilonFirstSelector\n    selector = EpsilonFirstSelector(explore=15,\n                                    loop_unroll_factors=(1,2,4,8,16,32))\n\nSubmatrix Edge Length\n~~~~~~~~~~~~~~~~~~~~~\n\nDuring the analytical processing, PyRQA subdivides the recurrence matrix\ninto a number of submatrices. To get more information on the recurrence\nmatrix partitioning, please refer to the publications mentioned below.\nThe corresponding parameter ``edge_length`` can be set while creating a\ncomputation object.\n\n.. code:: python\n\n    computation = RQAComputation.create(settings,\n                                        edge_length=12800)\n\nNote that the edge length has to be chosen such that a submatrix fits in\nthe memory of the OpenCL computing devices. Experiments have shown that\nvalues between ``10000`` and ``20000`` are a reasonable choice.\nNonetheless, values outside of these boundaries may lead to lower\nruntimes for specific computational scenarios. Furthermore, recurrence\nmatrices with a smaller extent than the value of ``edge_length`` are\nprocessed without being partitioned.\n\nTesting\n-------\n\nPyRQA provides a single-threaded baseline implementation for each\nanalytical method. These implementations do not use OpenCL\nfunctionality. They serve as a ground truth regarding the analytical\ncomputations. The basic tests for all supported analytical methods can\nbe executed cumulatively.\n\n.. code:: bash\n\n    python -m pyrqa.test\n\nThe complete set of tests can be executed by adding the option\n``--all``.\n\n.. code:: bash\n\n    python -m pyrqa.test --all\n\nNote that there might occur minor deviations regarding the analytical\nresults. These deviations may stem from varying precisions regarding the\ncomputing devices employed.\n\nOrigin\n------\n\nThe PyRQA package was initiated by computer scientists from the\nHumboldt-Universität zu Berlin (https://www.hu-berlin.de) and the GFZ\nGerman Research Centre for Geosciences (https://www.gfz-potsdam.de).\n\nAcknowledgements\n----------------\n\nWe would like to thank Norbert Marwan from the Potsdam Institute for\nClimate Impact Research (https://www.pik-potsdam.de) for his continuous\nsupport of the project. Please visit his website\nhttp://recurrence-plot.tk/ for further information on recurrence\nanalysis. Initial research and development of PyRQA was funded by the\nDeutsche Forschungsgemeinschaft (https://www.dfg.de/).\n\nPublications\n------------\n\nThe underlying computational approach of PyRQA is described in detail\nwithin the following thesis, which is openly accessible at\nhttps://edoc.hu-berlin.de/handle/18452/19518.\n\n    Rawald, T. (2018): Scalable and Efficient Analysis of Large\n    High-Dimensional Data Sets in the Context of Recurrence Analysis,\n    PhD Thesis, Berlin : Humboldt-Universität zu Berlin, 299 p.\n\nSelected aspects of the computational approach are presented within the\nfollowing publications.\n\n    Rawald, T., Sips, M., Marwan, N., Dransch, D. (2014): Fast\n    Computation of Recurrences in Long Time Series. - In: Marwan, N.,\n    Riley, M., Guiliani, A., Webber, C. (Eds.), Translational\n    Recurrences. From Mathematical Theory to Real-World Applications,\n    (Springer Proceedings in Mathematics and Statistics ; 103), p.\n    17-29.\n\n    Rawald, T., Sips, M., Marwan, N., Leser, U. (2015): Massively\n    Parallel Analysis of Similarity Matrices on Heterogeneous Hardware.\n    - In: Fischer, P. M., Alonso, G., Arenas, M., Geerts, F. (Eds.),\n    Proceedings of the Workshops of the EDBT/ICDT 2015 Joint Conference\n    (EDBT/ICDT), (CEUR Workshop Proceedings ; 1330), p. 56-62.\n\nDevelopment Status\n------------------\n\nThe development status of the PyRQA package is considered as *Beta*.\nPlease send feature requests and bug reports to the email address that\nis listed in the project metadata.\n\nRelease Notes\n-------------\n\n8.0.0\n~~~~~\n\n-  Usage of pre-embedded time series as input data.\n-  Addition of variants referring to non-overlapping column-wise storage\n   of input data.\n-  Refactoring of the public API.\n-  Updated documentation.\n\n7.0.1\n~~~~~\n\n-  Modification of the build configuration.\n-  Updated documentation.\n\n7.0.0\n~~~~~\n\n-  Addition of two variants regarding joint recurrence quantification\n   analysis computations.\n-  Removal of obsolete source code.\n-  Refactoring of the public API.\n-  Updated documentation.\n\n6.0.0\n~~~~~\n\n-  Addition of the joint recurrence quantification analysis (*JRQA*) and\n   joint recurrence plot (*JRP*) computations.\n-  Refactoring of the test implementation.\n-  Refactoring of the public API.\n-  Updated documentation.\n\n5.1.0\n~~~~~\n\n-  Addition of the unthresholded recurrence plot (*URP*) and\n   unthresholded cross recurrence plot (*UCRP*) computations.\n-  Updated documentation.\n\n5.0.0\n~~~~~\n\n-  Refactoring of the public API.\n-  Updated documentation.\n\n4.1.0\n~~~~~\n\n-  Usage of two different time delay values regarding the cross\n   recurrence plot (*CRP*) and cross recurrence quantification analysis\n   (*CRQA*).\n-  Updated documentation.\n\n4.0.0\n~~~~~\n\n-  Addition of the cross recurrence plot (*CRP*) and cross recurrence\n   quantification analysis (*CRQA*) computations.\n-  Addition of the radius corridor neighbourhood condition for\n   determining state similarity.\n-  Addition of an additional variant regarding recurrence plot\n   computations.\n-  Renaming of directories and classes referring to recurrence plot\n   computations.\n-  Removal of obsolete source code.\n-  Updated documentation.\n\n3.0.0\n~~~~~\n\n-  Source code cleanup.\n-  Renaming of the implementation variants regarding RQA and recurrence\n   plot processing.\n-  Removal of the module ``file_reader.py``. Please refer for example to\n   ``numpy.genfromtxt`` to read data from files (see\n   https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html).\n-  Updated documentation.\n\n2.0.1\n~~~~~\n\n-  Updated documentation.\n\n2.0.0\n~~~~~\n\n-  Major refactoring.\n-  Removal of operator and variant implementations that do not refer to\n   OpenCL brute force computing.\n-  Time series data may be represented using half, single and double\n   precision floating point values, which is reflected in the\n   computations on the OpenCL devices.\n-  Several changes to the public API.\n\n1.0.6\n~~~~~\n\n-  Changes to the public API have been made, e.g., to the definition of\n   the settings. This leads to an increase in the major version number\n   (see https://semver.org/).\n-  Time series objects either consist of one or multiple series. The\n   former requires to specify a value for the embedding delay as well as\n   the time delay parameter.\n-  Regarding the RQA computations, minimum line lengths are now\n   specified on the result object. This allows to compute quantitative\n   results using different lengths without having to inspect the matrix\n   using the same parametrisation multiple times.\n-  Modules for selecting well-performing implementations based on greedy\n   selection strategies have been added. By default, the selection pool\n   consists of a single pre-defined implementation.\n-  Operators and implementation variants based on multidimensional\n   search trees and grid data structures have been added.\n-  The diagonal line based quantitative measures are modified regarding\n   the semantics of the Theiler corrector.\n-  The creation of the OpenCL environment now supports device fission.\n\n0.1.0\n~~~~~\n\n-  Initial release.",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "nonlinear,time series analysis,dynamical system,recurrence quantification analysis,RQA,cross recurrence quantification analysis,CRQA,joint recurrence quantification analysis,JRQA,recurrence plot,RP,cross recurrence plot,CRP,joint recurrence plot,JRP",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "PyRQA",
    "package_url": "https://pypi.org/project/PyRQA/",
    "platform": "",
    "project_url": "https://pypi.org/project/PyRQA/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/PyRQA/8.0.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Recurrence analysis in a massively parallel manner using the OpenCL framework.",
    "version": "8.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9338251,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "317ddee51c852ad8a4d23c8a1184df779499863b80978349fef574c024a19f91",
          "md5": "b37236bea985352cf256f326ca3f9f7a",
          "sha256": "957894bb11598bd34451014e919a939437554f38ee4469d58e4f995173f8942f"
        },
        "downloads": -1,
        "filename": "PyRQA-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b37236bea985352cf256f326ca3f9f7a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 43864,
        "upload_time": "2015-07-29T12:56:19",
        "upload_time_iso_8601": "2015-07-29T12:56:19.638686Z",
        "url": "https://files.pythonhosted.org/packages/31/7d/dee51c852ad8a4d23c8a1184df779499863b80978349fef574c024a19f91/PyRQA-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "44da1d21750c6d9750655167d662702a37155f9838f467747d5e26e3c2e148f6",
          "md5": "0b8ed5c63eca77f0bbac24267a2143fc",
          "sha256": "51ef476c904a832f533a44cd2f6d5d547a830626ce0ce6f675684dd650f68dc9"
        },
        "downloads": -1,
        "filename": "PyRQA-1.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "0b8ed5c63eca77f0bbac24267a2143fc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 68578,
        "upload_time": "2018-09-14T23:19:35",
        "upload_time_iso_8601": "2018-09-14T23:19:35.982229Z",
        "url": "https://files.pythonhosted.org/packages/44/da/1d21750c6d9750655167d662702a37155f9838f467747d5e26e3c2e148f6/PyRQA-1.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8caf83d38daab097d0deb3b9c254090ddd98ed3f1e70d00a405c765111890662",
          "md5": "53ee829492755c8cc12b06b1ebd7b981",
          "sha256": "0664b2a16e91db95f32d81d3c195ceda6d892912ca5bb51ece594a2ca982e337"
        },
        "downloads": -1,
        "filename": "PyRQA-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "53ee829492755c8cc12b06b1ebd7b981",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 57227,
        "upload_time": "2018-12-19T21:19:53",
        "upload_time_iso_8601": "2018-12-19T21:19:53.480321Z",
        "url": "https://files.pythonhosted.org/packages/8c/af/83d38daab097d0deb3b9c254090ddd98ed3f1e70d00a405c765111890662/PyRQA-2.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2b731fcc91ae4ca0d6db828a83b0f6320ab50ae204c425bb2e0582c1a5acc979",
          "md5": "d53dc2a14473aa78e3a868f7d8a6795e",
          "sha256": "8976cb8fe68617f7c9bf5fe7aba0f162b46c44770f5797ea6d3f4e0311ff0477"
        },
        "downloads": -1,
        "filename": "PyRQA-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d53dc2a14473aa78e3a868f7d8a6795e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 57803,
        "upload_time": "2019-02-02T15:21:22",
        "upload_time_iso_8601": "2019-02-02T15:21:22.111284Z",
        "url": "https://files.pythonhosted.org/packages/2b/73/1fcc91ae4ca0d6db828a83b0f6320ab50ae204c425bb2e0582c1a5acc979/PyRQA-2.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9b0c45f68282cd84b886a6bf8767523c43f03f34d64eb89a67bef89ca15eeec2",
          "md5": "f36da0bdc0c02cbacad1a713de76bf61",
          "sha256": "b59a6fd6b5cfe64c2fc4b8afe860c84fe9a3542414a59e92229fab60c1c39874"
        },
        "downloads": -1,
        "filename": "PyRQA-3.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f36da0bdc0c02cbacad1a713de76bf61",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 55957,
        "upload_time": "2019-04-06T20:20:54",
        "upload_time_iso_8601": "2019-04-06T20:20:54.324163Z",
        "url": "https://files.pythonhosted.org/packages/9b/0c/45f68282cd84b886a6bf8767523c43f03f34d64eb89a67bef89ca15eeec2/PyRQA-3.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "4.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "43901f458ba9cd67b9226e89f8a3d87eb4af8ed7001a109b270b813781e3a3e9",
          "md5": "1cd31dfa8736c708e77a10b9b8d4fd6f",
          "sha256": "1de307d314ee3ba883cd37f289f533d75e182546632922c36df5d82b89514e5f"
        },
        "downloads": -1,
        "filename": "PyRQA-4.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1cd31dfa8736c708e77a10b9b8d4fd6f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 62199,
        "upload_time": "2019-07-26T20:29:16",
        "upload_time_iso_8601": "2019-07-26T20:29:16.404027Z",
        "url": "https://files.pythonhosted.org/packages/43/90/1f458ba9cd67b9226e89f8a3d87eb4af8ed7001a109b270b813781e3a3e9/PyRQA-4.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "4.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e4a61b0bde8e880644237a1ce9e05bd8c989eff9dceaef03881183ab5e0ebb3f",
          "md5": "05aa50db558796d64cbe25a8b305bb57",
          "sha256": "ed6a44c3da4a570407a40783fd6b375211d676ab26c45209e84695165a4f07a1"
        },
        "downloads": -1,
        "filename": "PyRQA-4.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "05aa50db558796d64cbe25a8b305bb57",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 62740,
        "upload_time": "2019-11-10T11:37:25",
        "upload_time_iso_8601": "2019-11-10T11:37:25.086343Z",
        "url": "https://files.pythonhosted.org/packages/e4/a6/1b0bde8e880644237a1ce9e05bd8c989eff9dceaef03881183ab5e0ebb3f/PyRQA-4.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "5.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c65f24204b1723aa4179cc0734ac1896df5130f7ed44786a59032be86345e301",
          "md5": "1b1ae64a4e439555a0e6ad72014434bc",
          "sha256": "d6aa839b2fb0582437e5833c7a80232828cc753cd177290bcc891c3c17fd273f"
        },
        "downloads": -1,
        "filename": "PyRQA-5.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1b1ae64a4e439555a0e6ad72014434bc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 62325,
        "upload_time": "2020-02-17T17:18:38",
        "upload_time_iso_8601": "2020-02-17T17:18:38.021819Z",
        "url": "https://files.pythonhosted.org/packages/c6/5f/24204b1723aa4179cc0734ac1896df5130f7ed44786a59032be86345e301/PyRQA-5.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "5.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ad162668edb2320aadd35728a307501d18e5655513c20bdd75199ec84458d741",
          "md5": "eee4fa30a83a807c4efeca06ac541c33",
          "sha256": "7f488517ba94e075eb60c890ed097468121e727330b7d9308de87a7920c7eaac"
        },
        "downloads": -1,
        "filename": "PyRQA-5.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "eee4fa30a83a807c4efeca06ac541c33",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 67921,
        "upload_time": "2020-04-03T18:05:50",
        "upload_time_iso_8601": "2020-04-03T18:05:50.109120Z",
        "url": "https://files.pythonhosted.org/packages/ad/16/2668edb2320aadd35728a307501d18e5655513c20bdd75199ec84458d741/PyRQA-5.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "6.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b378332fdc6b9a1618670166ca5dc59649a3acefe3a3e81674bff7f9f8b0eef0",
          "md5": "456ad370e7f076f28f0c046339e7b63a",
          "sha256": "e51cc3341ca8bebdf660719f47bf9d853841cc37d3e54296275f54715d678fd9"
        },
        "downloads": -1,
        "filename": "PyRQA-6.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "456ad370e7f076f28f0c046339e7b63a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 77522,
        "upload_time": "2020-04-29T18:16:16",
        "upload_time_iso_8601": "2020-04-29T18:16:16.096817Z",
        "url": "https://files.pythonhosted.org/packages/b3/78/332fdc6b9a1618670166ca5dc59649a3acefe3a3e81674bff7f9f8b0eef0/PyRQA-6.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "7.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c54ee867a5fb8c614b39e8681435093c6a3da664c6e29d6e62ec6d79f8851127",
          "md5": "7ecdbd6b48a291623ebff284786d0bd6",
          "sha256": "e6dce69e3908052b4fe67245e36c210c562989a8337071cf086caec14b7db19a"
        },
        "downloads": -1,
        "filename": "PyRQA-7.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7ecdbd6b48a291623ebff284786d0bd6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 81665,
        "upload_time": "2020-05-24T16:21:10",
        "upload_time_iso_8601": "2020-05-24T16:21:10.254344Z",
        "url": "https://files.pythonhosted.org/packages/c5/4e/e867a5fb8c614b39e8681435093c6a3da664c6e29d6e62ec6d79f8851127/PyRQA-7.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "7.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6fd7a734381e66e261a8a512d96e045251de1491adddf9f0fe82fcc10dab0405",
          "md5": "f0ebba6bc2b658625b2f92d926abfead",
          "sha256": "2e9a5c0673587154e4771bbae7ae0dfb66b230e621ae45886e96658e6f10f9d1"
        },
        "downloads": -1,
        "filename": "PyRQA-7.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f0ebba6bc2b658625b2f92d926abfead",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 81678,
        "upload_time": "2020-05-30T17:22:37",
        "upload_time_iso_8601": "2020-05-30T17:22:37.467822Z",
        "url": "https://files.pythonhosted.org/packages/6f/d7/a734381e66e261a8a512d96e045251de1491adddf9f0fe82fcc10dab0405/PyRQA-7.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "8.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "53375a1a5f35cd45606e1ac8365f1a18732f012e089394b76ab9c44d8cb16fcc",
          "md5": "385ea6da93c543340d0bc15aeb80434c",
          "sha256": "04e5bb203bd992dfb15f152bb2efd0e9fbfc488e0815e7bc8727edbc9543bcfc"
        },
        "downloads": -1,
        "filename": "PyRQA-8.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "385ea6da93c543340d0bc15aeb80434c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 99336,
        "upload_time": "2021-02-06T18:37:25",
        "upload_time_iso_8601": "2021-02-06T18:37:25.741486Z",
        "url": "https://files.pythonhosted.org/packages/53/37/5a1a5f35cd45606e1ac8365f1a18732f012e089394b76ab9c44d8cb16fcc/PyRQA-8.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "53375a1a5f35cd45606e1ac8365f1a18732f012e089394b76ab9c44d8cb16fcc",
        "md5": "385ea6da93c543340d0bc15aeb80434c",
        "sha256": "04e5bb203bd992dfb15f152bb2efd0e9fbfc488e0815e7bc8727edbc9543bcfc"
      },
      "downloads": -1,
      "filename": "PyRQA-8.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "385ea6da93c543340d0bc15aeb80434c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 99336,
      "upload_time": "2021-02-06T18:37:25",
      "upload_time_iso_8601": "2021-02-06T18:37:25.741486Z",
      "url": "https://files.pythonhosted.org/packages/53/37/5a1a5f35cd45606e1ac8365f1a18732f012e089394b76ab9c44d8cb16fcc/PyRQA-8.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}