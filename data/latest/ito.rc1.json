{
  "info": {
    "author": "Rex Sutton",
    "author_email": "noreply@nospam.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "- [<span class=\"toc-section-number\">1</span>\n    Introduction](#introduction)\n  - [<span class=\"toc-section-number\">2</span> Exotic Derivative\n    Example](#exotic-derivative-example)\n  - [<span class=\"toc-section-number\">3</span> Basic\n    Facilities](#basic-facilities)\n      - [<span class=\"toc-section-number\">3.1</span> Special\n        Characters](#special-characters)\n      - [<span class=\"toc-section-number\">3.2</span>\n        Keywords](#keywords)\n      - [<span class=\"toc-section-number\">3.3</span> White\n        Space](#white-space)\n      - [<span class=\"toc-section-number\">3.4</span>\n        Comments](#comments)\n      - [<span class=\"toc-section-number\">3.5</span> Basic\n        Types](#basic-types)\n      - [<span class=\"toc-section-number\">3.6</span> Arithmetic\n        Operators](#arithmetic-operators)\n      - [<span class=\"toc-section-number\">3.7</span> Comparison\n        Operators](#comparison-operators)\n      - [<span class=\"toc-section-number\">3.8</span> Logical\n        Operators](#logical-operators)\n      - [<span class=\"toc-section-number\">3.9</span> If](#if)\n      - [<span class=\"toc-section-number\">3.10</span> Lists](#lists)\n  - [<span class=\"toc-section-number\">4</span>\n    Definitions](#definitions)\n      - [<span class=\"toc-section-number\">4.1</span>\n        Functions](#functions)\n          - [<span class=\"toc-section-number\">4.1.1</span>\n            Binding](#binding)\n      - [<span class=\"toc-section-number\">4.2</span> Payment\n        Flows](#payment-flows)\n  - [<span class=\"toc-section-number\">5</span> Built In\n    Functions](#built-in-functions)\n      - [<span class=\"toc-section-number\">5.1</span> Observe](#observe)\n      - [<span class=\"toc-section-number\">5.2</span> Boolean\n        Functions](#boolean-functions)\n      - [<span class=\"toc-section-number\">5.3</span> Numerical\n        Functions](#numerical-functions)\n      - [<span class=\"toc-section-number\">5.4</span> Key\n        Functions](#key-functions)\n      - [<span class=\"toc-section-number\">5.5</span> Date\n        Functions](#date-functions)\n      - [<span class=\"toc-section-number\">5.6</span> List\n        Functions](#list-functions)\n      - [<span class=\"toc-section-number\">5.7</span> Infix\n        Operators](#infix-operators)\n  - [<span class=\"toc-section-number\">6</span> Known\n    Issues](#known-issues)\n      - [<span class=\"toc-section-number\">6.1</span> Type Checks Do Not\n        Propagate](#type-checks-do-not-propagate)\n      - [<span class=\"toc-section-number\">6.2</span> Partial Function\n        Definitions with Multiple Floating\n        Arguments](#partial-function-definitions-with-multiple-floating-arguments)\n      - [<span class=\"toc-section-number\">6.3</span> List Definition\n        Without All Constructors Can Give A Runtime\n        Error](#list-definition-without-all-constructors-can-give-a-runtime-error)\n      - [<span class=\"toc-section-number\">6.4</span> Ordering of List\n        Definitions](#ordering-of-list-definitions)\n\n# Introduction\n\nIto is an interpreter for a domain specific language, for the\ndescription of financial derivatives with a relatively simple structure.\nIto is free to use for individual or academic research. In a commercial\nsetting you are recommended to consult with the author. Ito is named in\nhonour of Kiyoshi Itô, a Japanese mathematician who made fundamental\ncontributions to the theory of stochastic processes.\n\nIn Ito a financial derivative is defined by a document that contains a\nlist of definitions. In particular a definition can be used to define\npayment flows. Typically payment flows are defined as functions of\nfinancial observables such as interest rates, foreign exchange rates,\ninflation indices, or the prices of stocks or commodities.\n\nPayment flows are also described by a date, currency and direction. The\ndate on which the flow has the potential to occur and the currency in\nwhich money changes hands. The direction is used to indicate the\nexpected direction of money, either towards the writer of the document\nor away to the other counterparty.\n\nFinancial observables are identified by ‘keys’. Their value at a given\ndate is sampled using the built in ‘observe’ function. There are other\nbuilt in functions for common calculations and it is possible to define\nnew functions.\n\nFunctions are composed of expressions, combining their arguments with\noperations and other potentially user defined functions.\n\nUsing Ito, a definition can be queried for a list of dependent\nobservables and by providing a suitable ordered array of their values,\npayments flows can be evaluated.\n\nThis functionality is useful when running an analysis based on Monte\nCarlo simulation as the specifics of the financial derivative can be\ndecoupled from the Monte Carlo simulation.\n\nThe following sections describe the Ito language in more detail.\n\n# Exotic Derivative Example\n\nThe listing below gives an example of an exotic equity derivative\ndefined in Ito. This product was taken from the discussion in chapter\n10, Exotic Cliquets, The volatility surface: a practitioner’s guide. The\nproduct is described as a \"Locally Capped Globally Floored Cliquet\". Ito\nallows the description of this product in a few lines.\n\n    #\n    underlying = \"STOXX\";\n    #\n    minCoupon = 0.02;\n    #\n    currency = \"EUR\";\n    #\n    notionalAmount = 1.0;\n    #\n    get notionalAmount * coupon[1] in currency on couponDates[1];\n    get notionalAmount * coupon[2] in currency on couponDates[2];\n    get notionalAmount * coupon[3] in currency on couponDates[3];\n    #\n    coupon[c] = max[sumReturns[c], minCoupon];\n    #\n    sumReturns[c] = sum[resetReturns[endDates[c], startDates[c]]];\n    #\n    resetReturns[{}, {}] = {};\n    resetReturns[t:ts, tm:tms] = min[max[r[t, tm], -0.01],  0.01] : resetReturns[ts, tms];\n    #\n    r[t, tMinus] = performance[s[t], s[tMinus]];\n    #\n    performance[st,stMinus] = (st - stMinus) / stMinus;\n    #\n    s[t] = Observe[underlying, t];\n    #\n    startDates[c] = dropTail[resetDates[c]];\n    #\n    endDates[c] = dropHead[resetDates[c]];\n    #\n    couponDates[1] = '2002-12-02';\n    couponDates[2] = '2003-12-02';\n    couponDates[3] = '2004-12-02';\n    #\n    resetDates[1] = {\n    '2002-01-02',\n    '2002-02-02',\n    '2002-03-02',\n    '2002-04-02',\n    '2002-05-02',\n    '2002-06-02',\n    '2002-07-02',\n    '2002-08-02',\n    '2002-09-02',\n    '2002-10-02',\n    '2002-11-02',\n    '2002-11-25'};\n    #\n    resetDates[2] = {\n    '2003-01-02',\n    '2003-02-02',\n    '2003-03-02',\n    '2003-04-02',\n    '2003-05-02',\n    '2003-06-02',\n    '2003-07-02',\n    '2003-08-02',\n    '2003-09-02',\n    '2003-10-02',\n    '2003-11-02',\n    '2003-11-25'\n    };\n    #\n    resetDates[3] = {\n    '2004-01-02',\n    '2004-02-02',\n    '2004-03-02',\n    '2004-04-02',\n    '2004-05-02',\n    '2004-06-02',\n    '2004-07-02',\n    '2004-08-02',\n    '2004-09-02',\n    '2004-10-02',\n    '2004-11-02',\n    '2004-11-25'\n    };\n    #\n    # remove the head (first entry) from the list\n    dropHead[{}] = {};\n    dropHead[{x}] = {};\n    dropHead[x:xs] = xs;\n    # remove the tail (last entry) from the list\n    dropTail[{}] = {};\n    dropTail[{x}] = {};\n    dropTail[x:xs] = x : dropTail[xs];\n    # minimum of two numbers.\n    min[x,y] = if x < y then x else y endif;\n    # maximum of two numbers.\n    max[x,y] = if x < y then y else x endif;\n    # sum of a list of numbers\n    sum[{}] = 0;\n    sum[{x}] = x;\n    sum[x:xs] = x + sum[xs];\n    \"\"\"\n\n# Basic Facilities\n\n## Special Characters\n\nThe character ‘;’ is used to mark the end of definitions. The character\n‘=’ is used to introduce a definition. The square brackets ‘\\[’ and\n‘\\]’ are used to define and call functions. See the section on\ndefinitions for more information.\n\nStandard characters such as \\(+\\) and \\(<\\) are used to represent\noperations on floating point numbers, for more information see the\nsection on infix operators.\n\nThe character ‘:’ is used to prepend to lists see the section\n[3.10](#lists).\n\n## Keywords\n\nThe tokens, ‘if’, ‘then’, ‘elseif‘ and ‘endif’ are used in if\nstatements, see the section [3.9](#if). The tokens ‘get’ and ‘pay’ are\nused to define payments.\n\n## White Space\n\nA new line, space or tab may be placed anywhere in a definition to\nimprove the readability of the definition.\n\n## Comments\n\nComments are written using the hash character, ‘\\#’. All characters on\nthe same line beyond the hash character are ignored.\n\n## Basic Types\n\nThe language has the following basic types:-\n\n  - Floating point numbers.\n\n  - Booleans, truth values.\n\n  - Dates.\n\n  - Keys.\n\nBasic types have literal representations; see the listing below for\nexamples. Boolean types have one of the possible literal values ‘true’\nand ‘false’. Dates are enclosed with single quotes in ‘YYYY-MM-DD’\nformat. Keys are enclosed in double quotes and may consist of an\narbitrary length of alpha-numeric characters and the character ‘.’ .\n\n    # Literal examples.\n    #\n    # Floating point numbers\n        notional = 100.0;\n    #\n    # Booleans\n        physicalDelivery = true;\n    #\n    # Dates\n        expiryDate = '2013-07-21';\n    #\n    # Keys\n        ftse = \".FTSE\";\n\n## Arithmetic Operators\n\nThe standard arithmetic operators for floating point numbers are\navailable, \\(+\\), \\(-\\), \\(*\\), \\(/\\) for addition, subtraction,\nmultiply and divide respectively. The operator order and precedence is\nas ‘expected’ and brackets, \\((\\), \\()\\), are available. Negation is\ncarried out by prefix with the \\(-\\) character.\n\n## Comparison Operators\n\nThe operators \\(<\\), \\(>\\), \\(<=\\) and \\(>=\\) are available for floating\npoint numbers and have the meanings, “less than ”, “greater than”, “less\nthan or equal” and “greater than or equal” respectively. The operators\nevaluate to the boolean type, ‘true’ or ‘false’ values.\n\n## Logical Operators\n\nThe operators to test for equality and in-equality are available for\nfloating point numbers, they are denoted with \\(==\\) and \\(!=\\)\ncharacters respectively. Both operators evaluate to a boolean type. Note\na succession of two “equals” characters should not be confused with a\nsingle “equals” character which has another meaning described in section\n[4](#definitions).\n\nThe logical operators “and” and “or” are available for boolean types,\nrepresented by the characters \\(\\&\\&\\) and \\(||\\) respectively and they\nhave their usual meanings. Both operators evaluate to a boolean type.\n\nLogical negation is carried out by prefix with the \\(!\\) character.\n\n## If\n\nExpressions that resolve to boolean type may be used to perform\nbranching using the keywords “if”, “then”, “else”, “elseif” and “endif’.\nSee the listing below for an example.\n\n    # If example.\n    #\n    # The maximum of two numbers\n        max[a,b] = if a < b then b else a endif;\n    #\n    # The sign of a floating point number.\n        signum[x] = \n            if x<0 then\n                -1\n            elseif x > 0\n                1\n            else\n                0\n            endif;\n\n## Lists\n\nLists may be constructed in two ways, either as a comma separated list\nof literals enclosed in curly brackets. \\(\\{\\), \\(\\}\\), or using the\nprefix operator \\(:\\). An empty list is denoted by the an empty pair of\ncurly braces \\({}\\). Lists can be viewed as a sequence of prefix\noperations, terminated by the empty list. All elements of a list must\nhave the same type. See the listing below for an example.\n\n    # List example.\n    # The empty list\n        emptyList = {};\n    # Some integers\n        someIntegers = {1,2,3};\n    # Cons operator\n        someMoreIntegers = 1 : {2,3};\n\nNote the prefix operator takes on the left hand side, an item whose type\nshould equal that of the elements of the list on the right hand side.\n\n# Definitions\n\nA definition may be used to define aliases for constant basic types,\nintroduce new functions and payment flows. There are two parts to a\ndefinition, the left hand-side of the definition and the right hand\nside, which appear on the left hand side of the definition operator and\nthe right hand side respectively. The definition operator is identified\nby the character \\(=\\).\n\nThe left hand side of a definition introduces an identifier into the\ndocument. An identifier is a sequence of letters from the alphabet. An\nidentifier is accessible from all points in the document and hence there\ncannot be two definitions with the same left hand side. It is not\nnecessary, or indeed always possible, to introduce identifiers in the\norder they are used, although this may improve readability (however see\nknown issues).\n\n## Functions\n\nFunctions are introduced using the definition operator. The left hand\nside of the definition takes the form of an identifier, followed by a\ncomma delimited list of function argument enclosed in square brackets,\n\\([\\), \\(]\\). The right hand side of the definition is an expression\ncombining the arguments with operations and other user defined functions\nor built in functions. See the listing for simple examples.\n\nFunction arguments on the right hand side may be identifiers, literals\nor a list formed using the concatenation operator. Functions can be\nformed by a sequence of definitions with unique literal or list\narguments. Such definitions are referred to as partial function\ndefinitions. In particular function arguments of the form of a\nconcatenated list can be used to define divide and conquer style\nalgorithms. For an example see the listing below.\n\n    # List function example\n        minElement[{x}] = x;\n        minElement[x:xs] = min[x, minElement[xs] ];\n\nFunction argument identifiers must be unique on the left-hand side of\nthe definition and take precedence in the right hand side over\nidentifiers with the same name defined in other parts of the document.\n\nFunctions can be recursive for an example see the listing below.\n\n    # Recursive function example\n        factorial[1] = 1;\n        factorial[x] = x * factorial[x-1];\n\nFunctions may take other functions as arguments, for an example see the\nlisting below.\n\n    # Function as argument examples\n    #\n    # A function that builds a list, by applying a function to each member.\n    apply[f,{}] = {};\n    apply[f,x:xs] = f[x] : apply[f,xs];\n\n### Binding\n\nNew functions may be constructed by binding, that is for functions of\nmore than one argument, fixing the value of an argument. A function is\nbound by writing the function identifier followed by the application\noperator ‘@’ and a literal or an identifier. Arguments can be bound from\nleft to right in sequence. For an example see the listing below.\n\n    # Function binding examples\n    # map applies a function to each list member\n    map[f,{}] = {};\n    map[f,x:xs] = f[x] : map[f,xs];\n    # expression to add 2 to each member of a list.\n    map[Add@2, {1,2,3}];\n\n## Payment Flows\n\nPayment flows are defined using the the keywords “get” or “pay”, for an\nexample see the listing below. Payment flows may result in zero money\nchanging hands and therefore can be viewed as indicating the potential\nfor a payment to occur on a given date in a given currency.\n\n    # Payment Examples\n    #\n    # Fixed payment.\n    pay 100 in \"EUR\" on '2013-07-01';\n    #\n    # call option payment\n    get max[Observe[\"index1\",'2013-07-01']-100,0] in \"EUR\" on '2013-07-01';\n\n# Built In Functions\n\n## Observe\n\nThe observe function is used to record the value of financial observable\nidentified by a key on at particular point in time, identified by a\ndate. The function behaves in a way which removes the units and\ncurrency, if any, from the observable being observed. The first argument\nis the key that refers to the observable, the second is the date that\ndefines when the observable is observed. See the listing below for an\nexample.\n\n    # Observe Examples\n    #\n    Observe[\".FTSE\",'2013-01-01']\n\n## Boolean Functions\n\nThe table below lists built in functions with boolean operands, see the\nsection [5.7](#infix-operators) for equivalent infix operators.\n\n| **<span>Identifier</span>** | **<span>Function Type</span>** | **<span>Comment</span>** |\n| :-------------------------- | :----------------------------: | :----------------------- |\n| Not                         |             Unary              | Logical not operator.    |\n| And                         |             Binary             | Logical and operator.    |\n| Or                          |             Binary             | Logical or operator.     |\n\n## Numerical Functions\n\nThe table below lists built in functions with floating point number\noperands, see the section [5.7](#infix-operators) for infix operators if\napplicable.\n\n| **<span>Identifier</span>** | **<span>Function Type</span>** | **<span>Comment</span>**                        |\n| :-------------------------- | :----------------------------: | :---------------------------------------------- |\n| Neg                         |             Unary              | Negation.                                       |\n| Add                         |             Binary             | Addition.                                       |\n| Sub                         |             Binary             | Subtraction.                                    |\n| Mul                         |             Binary             | Multiplication.                                 |\n| Div                         |             Binary             | Division.                                       |\n| Equal                       |            Bin Pred            | Equality.                                       |\n| NotEqual                    |            Bin Pred            | Inequality.                                     |\n| LessThan                    |            Bin Pred            | Less than.                                      |\n| GreaterThan                 |            Bin Pred            | Greater than.                                   |\n| LessThanOrEqual             |            Bin Pred            | Less than or equal.                             |\n| GreaterThanOrEqual          |            Bin Pred            | Greater than or equal.                          |\n| Pow                         |             Binary             | Raise first operand to power of second operand. |\n| Sqrt                        |             Unary              | Square root of operand.                         |\n| Fabs                        |             Unary              | Absolute value of operand.                      |\n| Exp                         |             Unary              | Exponential of operand.                         |\n| Log                         |             Unary              | Natural logarithm of operand.                   |\n| LogTen                      |             Unary              | Base ten logarithm of operand.                  |\n\n## Key Functions\n\nThe table below lists built in functions with key operands.\n\n| **<span>Identifier</span>** | **<span>Function Type</span>** | **<span>Comment</span>** |\n| :-------------------------- | :----------------------------: | :----------------------- |\n| StringEqual                 |            Bin Pred            | Equality.                |\n| StringNotEqual              |            Bin Pred            | Inequality.              |\n\n## Date Functions\n\nThe table below lists built in functions with date operands.\n\n| **<span>Identifier</span>** | **<span>Function Type</span>** | **<span>Comment</span>** |\n| :-------------------------- | :----------------------------: | :----------------------- |\n| DateEqual                   |            Bin Pred            | Equality.                |\n| DateNotEqual                |            Bin Pred            | Inequality.              |\n| DateLessThan                |            Bin Pred            | Less than.               |\n| DateGreaterThan             |            Bin Pred            | Greater than.            |\n| DateLessThanOrEqual         |            Bin Pred            | Less than or equal.      |\n| DateGreaterThanOrEqual      |            Bin Pred            | Greater than or equal.   |\n\n## List Functions\n\nThe table below lists built in functions with list operands.\n\n| **<span>Identifier</span>** | **<span>Function Type</span>** | **<span>Comment</span>** |\n| :-------------------------- | :----------------------------: | :----------------------- |\n| Cons                        |             Lists              | Prepend to list.         |\n\n## Infix Operators\n\nThe table below lists built in functions that have equivalent infix\noperators.\n\n| **<span>Identifier</span>** | **<span>Operand Type</span>** | **<span>Operator Type</span>** | **<span>Operator</span>** |\n| :-------------------------- | :---------------------------: | :----------------------------: | :-----------------------: |\n| Not                         |             Bool              |             Unary              |           \\(!\\)           |\n| And                         |             Bool              |             Binary             |         \\(\\&\\&\\)          |\n| Or                          |             Bool              |             Binary             |          \\(\\|\\)           |\n| Neg                         |             Float             |             Unary              |           \\(-\\)           |\n| Add                         |             Float             |             Binary             |           \\(+\\)           |\n| Sub                         |             Float             |             Binary             |           \\(-\\)           |\n| Mul                         |             Float             |             Binary             |           \\(*\\)           |\n| Div                         |             Float             |             Binary             |           \\(/\\)           |\n| Equal                       |             Float             |           Bin Pred.            |          \\(==\\)           |\n| NotEqual                    |             Float             |           Bin Pred.            |          \\(==\\)           |\n| LessThan                    |             Float             |           Bin Pred.            |           \\(<\\)           |\n| GreaterThan                 |             Float             |           Bin Pred.            |           \\(>\\)           |\n| LessThanOrEqual             |             Float             |           Bin Pred.            |          \\(<=\\)           |\n| GreaterThanOrEqual          |             Float             |           Bin Pred.            |          \\(>=\\)           |\n| Cons                        |             Lists             |         List prepend.          |           \\(:\\)           |\n\n# Known Issues\n\nIto is intended for research purposes, whilst most features are tested\nand work, there are some known issues which can be worked around. Please\nreport any new issues to the author.\n\n## Type Checks Do Not Propagate\n\nIto is type-checked, however type errors are not currently propagated.\nThe example in the listing below illustrates this issue.\n\n    observeDate = {'2001-01-01', '2002-01-01'};\n    # replacing the line above with the commented lines below,\n    # passes a date rather than a list of dates to observe\n    # head[{}] = {};\n    # head[x:xs] = x;\n    # observeDate = head[{'2001-01-01', '2002-01-01'}];\n    pay Observe[\"FTSE\", observeDate] in \"GBP\" on '2011-09-03';\n\n## Partial Function Definitions with Multiple Floating Arguments\n\nIt is possible to define functions using partial definitions. Where\nthere is more than one argument, and all those arguments are floating\npoint values, an error will be raised. The example in the listing below\nillustrates this issue.\n\n    f[1, 1] = 100.0;\n    f[1, 2] = 10.0;\n    pay f[1,1] in \"GBP\" on '2011-09-03';\n\n## List Definition Without All Constructors Can Give A Runtime Error\n\nIf definitions are defined for a list, and not all list constructors are\nhandled, a runtime error is emitted, without propagating useful\ninformation. This issue can interact with the issue below. The example\nin the listing below illustrates this issue.\n\n    head[{}] = 0.0;\n    get head[{100.0}] in \"GBP\" on '2011-09-03';\n\n## Ordering of List Definitions\n\nPiecewise definitions involving lists are sensitive to the order the\ndefinitions are introduced in. In some circumstances this can lead to an\nunexpected runtime error. The example in the listing below illustrates\nthis issue.\n\n    dropTail[x:xs] = x : dropTail[xs];\n    dropTail[{x}] = {};\n    # re-ordering as in the comment below fixes the definition of drop tail.\n    # dropTail[{x}] = {};\n    # dropTail[x:xs] = x : dropTail[xs];\n    # you might think the addition of the line below would fix things but it doesn't.\n    # dropTail[{}] = {};\n    len[{}] = 0;\n    len[x:xs] = 1 + len[xs];\n    get len[dropTail[{1,2,3}]] * Observe[\"FTSE\", '2001-02-02'] in \"GBP\" on '2011-09-03';\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rexsutton/vollab",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ito",
    "package_url": "https://pypi.org/project/ito/",
    "platform": "",
    "project_url": "https://pypi.org/project/ito/",
    "project_urls": {
      "Bug Tracker": "https://github.com/rexsutton/vollab/issues",
      "Homepage": "https://github.com/rexsutton/vollab"
    },
    "release_url": "https://pypi.org/project/ito/0.0.2/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "A domain specific language for the description of financial derivatives.",
    "version": "0.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10119591,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "74e10ac4754fa228c3d30793c913a3626735cf9a4a71f2463f0c69aeffa443b6",
          "md5": "a35c9985caf3e03942e97e65414685f7",
          "sha256": "0ba034e325ec340ca174103659f5f53a802cd6570250a68f1924993f432f3b0a"
        },
        "downloads": -1,
        "filename": "ito-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a35c9985caf3e03942e97e65414685f7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 2624598,
        "upload_time": "2021-04-20T14:38:12",
        "upload_time_iso_8601": "2021-04-20T14:38:12.696230Z",
        "url": "https://files.pythonhosted.org/packages/74/e1/0ac4754fa228c3d30793c913a3626735cf9a4a71f2463f0c69aeffa443b6/ito-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "74e10ac4754fa228c3d30793c913a3626735cf9a4a71f2463f0c69aeffa443b6",
        "md5": "a35c9985caf3e03942e97e65414685f7",
        "sha256": "0ba034e325ec340ca174103659f5f53a802cd6570250a68f1924993f432f3b0a"
      },
      "downloads": -1,
      "filename": "ito-0.0.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a35c9985caf3e03942e97e65414685f7",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 2624598,
      "upload_time": "2021-04-20T14:38:12",
      "upload_time_iso_8601": "2021-04-20T14:38:12.696230Z",
      "url": "https://files.pythonhosted.org/packages/74/e1/0ac4754fa228c3d30793c913a3626735cf9a4a71f2463f0c69aeffa443b6/ito-0.0.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}