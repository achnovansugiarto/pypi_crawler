{
  "info": {
    "author": "Rostislav Matveev",
    "author_email": "rostislav.matveev@googlemail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: End Users/Desktop",
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: Python :: 3.6",
      "Topic :: Desktop Environment :: Window Managers :: FVWM"
    ],
    "description": "# fvwmpy -- framework for developing FVWM modules in python\n\nThis module defines class `fvwmpy`, that can be used by itself or as a\nbase for derived classes for writing FVWM modules.  \n#### Version fvwmpy_v1.2.0\n## License\nThis module is released under GPL-3.0 license.\n\n## Declaration\nI love FVWM\n\n## Features\n- Simple interface for communication with the window manager.\n- Asyncronous access to the packet queue.\n- Possibility of maintaining dynamically updated list of windows and\n  their properties.\n- Possibility to iterate over windows satisfying given conditions.  \n- Possibility of dynamically changing configuration\n- Simple interface for accessing FVWM's variables and infostore\n  database.\n- Compatible with tkinter\n- Simple interface for masking packets from FVWM\n- Support for the concept of module aliases\n\nA simple example of a module using fvwmpy may be written along the\nfollowing lines \n```\n#!/usr/bin/python3\nimport fvwmpy\n\nclass myfvwmmodule(fvwmpy.fvwmpy):\n    def h_config(self,pack):\n        # process config lines from FVWM database\n\t\n    def h_handler1(self,pack):\n        # respond to the pack\n\n    def h_handler2(self,pack):\n        # respond to the pack\n    ...\n\nm = myfvwmmodule()\nm.logger.setLevel(fvwmpy.L_DEBUG)\n\n### Keep FVWM mute while we are setting things up\nm.mask       = 0\nm.syncmask   = 0\nm.nograbmask = 0\n\n### Check command line arguments\nfor arg in m.args:\n   # process arg\n\n### If we want to dynamically update configuration:\nm.register_handler(fvwmpy.M_SENDCONFIG, m.h_config)\n\n### If we want to keep config database up to date:\nm.register_handler(fvwmpy.M_SENDCONFIG, m.h_saveconfig)\n\n\n### If we want to have up to date list of windows\nm.register_handler(fvwmpy.M_FOR_WINLIST, m.h_updatewl)\n\n### Register handlers\nm.register_handler(mask1,m.h_handler1)\nm.register_handler(mask2,m.h_handler2)\n...\n\n### set masks\nm.mask       = <some mask>\nm.syncmask   = <some smask>\nm.nograbmask = <some ngmask>\n\n### for up to date winlist\nm.mask |= fvwmpy.M_FOR_WINLIST\n\n### for updating config dynamically\nm.mask |= fvwmpy.M_SENDCONFIG \n\n### If we want FVWM to wait while we update config\nm.syncmask |= fvwmpy.M_SENDCONFIG\nm.register_handler(fvwmpy.M_SENDCONFIG, m.h_unlock)\n\n### Tell FVWM that we are ready\nm.finishedconfig()\n\n### Fill the config database\nm.getconfig()\n\n### Read FVWM's database of module configuration lines and parse them\nm.getconfig(m.h_config)\n\n### Fill the winlist database\nm.getwinlist()\n\n### Do some other module stuff\nm.info(' Looks like FVWM manages {} windows now',len(m.winlist))\n...\n\n### If the module is persistent (listens to FVWM and executes handlers)\nm.run()\n### otherwise\nm.exit()\n```\n\nMore snippets and examples are below.\n\n## Structure of the `fvwmpy` module\n\nThe module define the following constants, functions and classes.\n\n### Constants\nThe following constants are defined within the module\n\n- **`fvwmpy.C_*`**\n\n  Integers.\n  \n  These constants refer to FVWM decoration contexts.\n  See [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) for the complete \n  list and definitions. \n\n- **`fvwmpy.contextnames`**, **`fvwmpy.contextcodes`**\n\n  `fvwmpy.contextnames` is a dictionary with keys being contexts, and\n  values -- character strings containing the names of the\n  corresponding context.\n\n  `fvwmpy.contextcodes` is the inverse of the `fvwmpy.contextnames`\n  dictionary.\n\n- **`fvwmpy.M[X]_*`**\n\n  Integers.\n  \n  Types of packets send from FVWM to the module. See section\n  **packets** and \n  [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) for the\n  full list and meaning of packet types and other details.  In\n  addition the following masks are defined:\n\n  - `fvwmpy.M_ALL` - matches all packet types;\n  - `fvwmpy.M_FOR_WINLIST`\n    matches packets emitted by FVWM during response to\n    *'Send_WindowList'* command and `fvwmpy.M_DESTROY_WINDOW` and\n    `fvwmpy.M_ADD_WINDOW`\n  - `fvwmpy.M_FOR_CONFIG` -- mask matching all packets emitted by FVWM\n    in response to *'Send_ConfigInfo'* command and `fvwmpy.M_SENDCONFIG`\n\n- **`fvwmpy.packetnames`**, **`fvwmpy.packetcodes`**\n\n  `fvwmpy.packetnames` is a dictionary for converting packet types to their names.\n  E.g.\n\n  `fvwmpy.packetnames[fvwmpy.MX_LEAVE_WINDOW] == 'MX_LEAVE_WINDOW'`\n\n  `fvwmpy.packetcodes` is the inverse dictionary of `fvwmpy.packetnames`\n\n- **`fvwmpy.FVWM_PACK_START`** and **`fvwmpy.FVWM_PACK_START_b`**\n\n  Delimiter used by FVWM to tag the start of each packet.\n  `FVWM_PACK_START` is an integer and `FVWM_PACK_START_b` is its\n  bytes representation.\n\n- **`fvwmpy.FINISHED`** and **`fvwmpy.NOT_FINISHED`**\n\n  bytearrays containing tags to be sent to FVWM at the end of every\n  message to notify whether module intends to continue or has finished\n  working and is about to exit.\n\n- **`fvwmpy.LONG_SIZE`**\n\n  Integer. The size of C's long in bytes.\n\n- **`fvwmpy.FVWM_STR_CODEX`**\n\n  String. Codex for en/de-coding strings during communication with FVWM.\n\n- **`fvwmpy.VERSION`**\n\n  String. Naturally contains information about current version of the\n  module.\n\n- **`fvwmpy.L_CRITICAL`**, **`fvwmpy.L_ERROR`**, **`fvwmpy.L_WARN`**,\n  **`fvwmpy.L_INFO`**, **`fvwmpy.L_DEBUG`**, **`fvwmpy.L_NOTSET`**\n\n  Integer.\n  \n  Constants for setting logging level. Instances of `fvwmpy.fvwmpy`\n  and `fvwmpy._packet_queue` have their own loggers.  Logging level\n  can be set like this `object.logger.setLevel(fvwmpy.L_DEBUG)` to see\n  a lot of output from inner working of these objects. See also\n  `object.debug`,...,`object.critical` methods below.\n\n### Exceptions\n\n- **`fvwmpy.FvwmPyException`**\n\n  Base exception from which others are derived.\n\n- **`fvwmpy.FvwmLaunch`**\n\n  This exception is raised when the module can not start up normally,\n  e.g it is not executed by FVWM, pipes can not be opened, etc.\n\n- **`fvwmpy.IllegalOperation`**\n\n  raised when one trying restore masks without saving them first, etc.\n  It is also raised when one attempts to assign to FVWM variables (not\n  infostore)\n\n- **`fvwmpy.FvwmError`**\n\n  raised when FVWM does not understand communication from the\n  module or the other way around.\n\n- **`fvwmpy.PipeDesync`**\n\n  This exception is raised if pipe desyncronization is detected,\n  e.g. when the packet from FVWM does not have begin-tag or when the\n  content of the packet does not match its format.\n  Instances of `fvwmpy._packet_queue` class have method `._resync()` to seek the\n  stream to the next pack. See **packet queue** section for more details.\n\n  \n### Helper functions\n\n- **`fvwmpy.split_mask(mask)`**\n\n  `mask` is a mask used for packet matching.\n  \n  Returns a tuple of all packet types, that match the given mask.\n  If all the packet types in the list are bitwise `or`ed, one gets the\n  `mask` back.\n\n- **`fvwmpy.unique_id()`**\n\n  Returns a unique string, which almost guarantied not to match\n  anything ever sent by FVWM. Can be used for tagging *'SendReply'*\n  FVWM-command. Each invocation returns a different string.\n\n- **`fvwmpy.picker(mask=None,**kwargs)`**\n\n  Returns a callable object, that can be called on a packet and\n  returns boolean value. See **Picker factory** section for more details.\n\n- **`fvwmpy.glob(globstring)`**, **`fvwmpy.Glob(globstring)`**\n  \n  Both create glob patterns, against which you can match other\n  strings.\n  \n  `globstring` is a string, that may contain '\\*' and '?' characters\n  and '[chars]' substrings.  Pattern '[chars]' may also contain ranges\n  like '[a-z0-9]'.  Wildcard '\\*' matches any substring, '?' matches\n  any single character.  '[chars]' matches any single character which\n  is one of 'chars'.  To match '\\*' or '?' literally, use the\n  corresponding character enclosed in '[]'.\n\n  When [gG]lob instance is compared to another string with `==` or `!=`\n  operator, it checks whether another string matches the pattern.\n\n  E.g. `'abc*efg?xyz' == glob('*c[*]EFg[?]x??')` returns `True`.\n\n  The difference between `glob` and `Glob` is that in the former\n  matching is case insensitive, while objects of the later match\n  string in a case-sensitive way, so\n  `'abc*efg?xyz' == Glob('*c[*]EFg[?]x??')`  will be `False`.\n\n\n### Class `fvwmpy.fvwmpy`\n\n`m=fvwmpy.fvwmpy()`\n\nInstances of `fvwmpy` have the following attributes and methods\n\n#### Attributes\n\n- **`m.me`**\n\n  String. The name of the executable file containing the module\n\n- **`m.alias`**\n\n  String. Alias of the module. Alias is guessed from the command line\n  arguments of the module during initialization. If the first\n  command line argument does not start with '-', then it is assumed to\n  be the alias of the module. Then `m.alias` is set (which affects\n  logging functions and pruning of configuration lines) and this\n  argument is not included in `m.args`. If the first argument is a\n  single '-', then it is also removed from `m.args` and `m.alias` will\n  be the same as `m.me`.  `m.alias` can not be changed afterwards.\n\n  This alias guessing seems to be consistent with what FVWM does.\n  So module with alias 'FvwmAkaModule' will receive strings sent by\n  `SendToModule FvwmAkaModule <string>` and can be terminated by\n  `KillModule FvwmAkaModule` command.\n\n- **`m.args`**\n\n  List of strings. Contains command line arguments of the module. \n  If the first argument does not start with '-', then it is assumed to\n  be the alias of the module. Then `m.alias` is set (which affects\n  logging functions and pruning of configuration lines) and this\n  argument is not included in `m.args`. If the first argument is a\n  single '-', then it is also removed from `m.args`.\n  \n  -  If the module FvwmMyModule is invoked by FVWM command\n     ```\n     Module FvwmMyModule FvwmAkaModule arg1 arg2 ...\n     ```\n     then `m.alias == 'FvwmAkaModule'` and `m.args == ['arg1', 'arg2', ...]`\n  \n  -  If the module is invoked by\n     ```\n     Module FvwmMyModule - FvwmAkaModule arg1 arg2 ...\n     ```\n     then `m.alias == 'FvwmMyModule'` and\n     `m.args == ['FvwmAkaModule', 'arg1', 'arg2', ...]`\n\n  -  If the module is invoked by\n     ```\n     Module FvwmMyModule -geometry 200x200+24+0 ...\n     ```\n     then `m.alias == 'FvwmMyModule'` and\n     `m.args == ['-geometry', '200x200+24+0', ...]`\n  \n- **`m.mask`**\n\n  Integer. Mask for communication from FVWM. The mask controls what\n  kind of packets FVWM sends to the module. The normal and extended (bits\n  higher then 32) masks are treated the same, so, for example\n  `m.mask = fvwmpy.MX_LEAVE_WINDOW | fvwmpy.M_VISIBLE_NAME`\n  is a legal instruction with intended consequences.\n\n  Setting the mask to a new value will trigger communication with FVWM\n  to let it know the new value, but only if the new value is\n  different from the old, so no unnecessary communication takes\n  place. Note, that if you previously changed the mask by some other\n  method (sending an appropriate message to FVWM) the new value might\n  not be communicated to the window manager when executing `m.mask =\n  <new_value>`. Methods `m.push_mask()` and `m.restore_mask()` are\n  safe to use in this respect.\n\n  Every time new mask is set by `m.mask = newmask`,\n  `m.mask_setter_hook('mask',newmask)` is called.\n  `m.mask_setter_hook(...)` does nothing by default, but you may\n  overload it, for example, to communicate new value of the mask to\n  other parts of the program, e.g. gui.\n\n  \n  See `fvwmpy.M[X]_*` for possible values of masks and interpretation\n  thereof.\n\n  See also `m.push_masks(...)` and `m.restore_masks()` methods for\n  temporarily changing masks.\n  \n  See [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) for\n  the explanation of the concepts of masking.\n  \n- **`m.syncmask`** and **`m.nograbmask`**\n\n  are similar to `m.mask` but contain values of syncmask and\n  nograbmask, respectively. When new value is set,\n  `m.mask_setter_hook('syncmask',newmask)` or\n  `m.mask_setter_hook('nograbmask',newmask)` is called.\n\n- **`m.context_window`**\n\n  Integer. Contains id of the window in whose context the module was\n  started or 0 if the module was executed outside of any window context.\n  This will be used for all methods requiring context_window parameter\n  if `None` is passed.\n  \n- **`m.context_deco`**\n\n  Window decoration context in which module was started or 0 if  the\n  module was executed outside of any window context. See `fvwmpy.C_*`\n  and [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) for\n  explanation of decoration contexts.\n\n- **`m.logger`**\n\n  A logger object associated with the instance.  You may call\n  `m.logger.setLevel(<new_level>)` to change the severity threshold\n  for logging messages.  Here `<new_level>` is one of the `fvwmpy.L_*`\n  constants described above. `m.logger.getEffectiveLevel()` is the\n  current level.  See also `m.debug`,...,`m.critical` methods below.\n  The default level is `fvwmpy.L_WARN`, which keeps it relatively quiet.\n  \n- **`m.config`**\n\n  `m.config` is the database containing information sent by FVWM\n  during execution of *Send_ConfigInfo* command and with `M_SENDCONFIG`\n  packets. See also `m.getconfig()` method and `m.h_saveconfig()` handler.\n  For more details see section **Config database** below.\n\n- **`m.winlist`** \n\n  `m.winlist` is the database of windows known to FVWM indexed by\n  window id's. It can be filled by calling `m.getwinlist()` method. It\n  is also possible to arrange to have `m.winlist` to be up to date at\n  all times. See information on `m.h_updatewl` handler.\n  \n  `m.winlist` inherits from `dict`. `m.winlist[<window_id>]` is an\n  instance of `fvwmpy._window` class and contains all the information\n  about the window, that FVWM cares to communicate to us.\n  For more details see **winlist database** below\n\n  In addition to the usual `dict` methods it also has method\n  `w.winlist.filter(conditions)` which return an iterator for cycling\n  through windows satisfying conditions. It is described in more\n  details in **winlist database** section.\n  \n- **`m.handlers`**\n\n  A dictionary whose keys are packet types and values are lists of\n  handler functions, each of which takes one argument, which is a\n  packet.\n  Initially all lists are empty. It is not advised to access it directly.\n  See  `m.register_handler()`,  `m.unregister_handler()`,\n  `m.clear_handlers()`, `m.registered_handler()` and\n  `m.call_handlers()` methods and **handlers** section below.\n\n- **`m.var`** and **`m.infostore`**\n\n  These are special objects providing access to FVWM variables and\n  infostore database.\n  \n  See section **FVWM variables and infostore** below.\n\n- **`m.packets`**\n\n  A packets queue from FVWM.\n  \n  See **Packets** section for the description and the structure of the\n  packet data type.\n\n#### Methods\n\n     For all methods requiring context_window parameter if `None` is\n     given, module's own context window is assumed.\n\n- **`m.debug()`**, **`m.info()`**, **`m.warn()`**,\n  **`m.error()`** and **`m.critical()`**\n\n  logging functions. They should be called\n\n  `m.<log_fcn>(message_string, *arguments)`\n  \n  and use `message_string.format(*arguments)` formatting paradigm.\n  Logging messages are directed to *stderr*. For the module\n  *stderr*-stream will be the same as for FVWM. Logging functions\n  print the severity level followed by the alias of the module\n  followed by the formatted message. The behavior of these functions\n  is affected by the value returned by\n  `m.logger.getEffectiveLevel()`. Only messages with severity not less\n  then that level will be printed.  Use\n  `m.logger.setLevel(value)` to change logging level.\n  \n- **`m.sendmessage(msg, context_window=None, finished=False)`**\n\n  Send a (possibly multi-line) message to FVWM for execution in the\n  context of `context_window`.\n\n  `msg` is a multi-line string conatining FVWM commands. Empty lines\n  (only with white spaces) are ignored. For example the following\n  works\n  ```\n  cmds=\"\"\" Focus \n  WarpToWindow {} {} \"\"\"\n  m.sendmessage(cmds.format(30,50), context_window = wid )\n  ```\n  If `context_window` is not given or `None`, then the window context\n  will be equal to the context window of the module (that is\n  `m.context_window`). If `context_window==0`, then FVWM executes\n  commands without window context.\n\n  If `finished` then FVWM will be notified that the module is done\n  working and is about to exit soon.\n\n  Every time `m.sendmessage(...)` is executed `m.sendmessage_hook()`\n  with the same arguments will also be called.\n  `m.sendmessage_hook()` does nothing, but can be overloaded, for\n  example, to let GUI part know that a message was sent.\n\n- **`m.getreply(msg,context_window=None,timeout=0.5)`**\n\n  Send string message `msg` to FVWM and request to send it back in the\n  context `context_window`.  If `timeout` is given and not `None`, then\n  return not later then after timeout seconds. If for some reason no\n  reply was received from FVWM, `None` is returned.\n\n  There is no need to change masks before/after invoking this method,\n  it works independently of the current values of masks and does not\n  change them.\n\n  This method works reliably independently whether there are unhandled\n  packets in the packet queue. The reply will be picked and removed\n  from the queue and returned. The following code works correctly.\n  \n  ```\n  ### Pollute the queue\n  m.push_masks(M_FOR_WINLIST|MX_REPLY,0,0)\n  m.sendmessage('Send_WindowList')\n  m.sendmessage('Send_Reply unrelated reply')\n  m.restore_masks()\n  ### Now packet queue is full of packets\n  \n  w_name = m.getreply('$[w.name]',context_window=123456789)\n  ### reply packet is found in the queue and is removed from it\n  \n  # do something with  w_name\n  # handle packets remaining in the queue\n  ```\n\n- **`m.getconfig(handler=None, match=None,timeout=0.5)`**\n\n  Ask FVWM for configuration info. Each received packet is passed to\n  the `handler`. This method returns `True` upon successful operation\n  or `False` if something went wrong, pehaps `M_END_CONFIG_INFO`\n  packet was not received for timeout seconds.\n  (Experimentation shows that FVWM needs not more then 0.05 seconds to\n  send config under normal circumstances)\n  \n  `handler` must be `None` or a callable taking one argument, which is a\n  packet of type matching `fvwmpy.M_FOR_CONFIG`. If `handler` is not\n  supplied or is `None`, then the default handler `m.h_saveconfig` is\n  used. `m.h_saveconfig` just fills `m.config` database with the\n  information received from FVWM. See section **Config database** below. \n\n  `match` must be `None` or a string to match module configuration\n  lines against.  If not supplied then `'*' + m.alias` is assumed.  If\n  `match == \"\"` then all configuration lines for all modules are\n  received and processed.\n\n  There is no need to change masks before/after invoking this method,\n  it works independently of the current values of masks and does not\n  change them.\n\n  This method works reliably independently of the state of the packet\n  queue. Even if the queue is not empty at the start of this call,\n  configuration packets will be found in the queue and removed from\n  it. So the following works reliably\n  ```\n  ### Pollute the queue\n  m.push_masks(M_FOR_WINLIST|MX_REPLY,0,0)\n  m.sendmessage('Send_WindowList')\n  m.restore_masks()\n\n  ### Now queue is full of packets\n  m.getconfig()\n  ### m.config is updated and config messages are removed from the\n  ### queue\n\n  # handle the packets remaining in the queue\n  ```\n  If you want to keep config database up to date all the time, then\n  include the following\n  ```\n  m.getconfig()\n  m.register_handler(fvwmpy.M_SENDCONFIG, m.h_saveconfig)\n  m.mask |= fvwmpy.M_SENDCONFIG\n  ```\n  somewhere in your code.\n\n  See **Config database** for more information and how to have config\n  database up to date all the time.\n\n- **`m.getwinlist(handler = None,timeout=0.5)`**\n\n  Ask FVWM for the list of all windows it manages. Each packet\n  received in response is passed to the handler. Return `True` if\n  operation was successful. Wait for at most timeout seconds for\n  `M_END_WINLIST` packet from FVWM before returning.\n\n  `handler` should be a callable taking one argument, which is a\n  packet of type matching `fvwmpy.M_FOR_WINLIST`. If `handler` is not\n  supplied then default handler `m.h_updatewl` is used. `m.h_updatewl`\n  simply updates `m.winlist` database with the information received\n  from FVWM. It also understands `fvwmpy.M_ADD_WINDOW` and\n  `fvwmpy.M_DESTROY_WINDOW` packets removing/adding the corresponding\n  entries from the database.\n\n  It is not necessary to adjust the values of the masks before or\n  after invoking `fvwmpy.getwinlist()`. It works independently of the\n  current values of masks and preserves them.\n  \n  This method works reliably independently of the state of the packet\n  queue. Even if queue is not empty at the start of this call,\n  `fvwmpy.M_FOR_WINDOWLIST`-type packets will be found in the queue and removed from\n  it. So the following works reliably\n  ```\n  ### Pollute the queue\n  m.push_masks(M_FOR_WINLIST|MX_REPLY,0,0)\n  m.sendmessage('Send_ConfigInfo')\n  m.restore_masks()\n  ### Now queue is full of packets\n\n  ### Mute FVWM\n  m.mask = 0\n\n  m.getwinlist()\n  ### m.winlist is updated and the corresponding packets are\n  ### removed from the queue\n\n  ### m.mask is still 0\n  \n  # handle the packets remaining in the queue\n  ```\n\n  Note that `m.getwinlist()` will also pick packets of type\n  `M_ADD_WINDOW` or `M_DESTROY_WINDOW` (these packets are not send in\n  response *'Send_WindowList'* request, but correspond to events in\n  FVWM) and they will be also removed from the queue.\n  \n  If you want to keep `m.winlist` up to date all the time, then\n  include the following\n  ```\n  m.getwinlist()\n  m.register_handler(fvwmpy.M_FOR_WINLIST, m.h_updatewl)\n  m.mask |= fvwmpy.M_FOR_WINLIST\n  ```\n  somewhere in your code.\n  \n- **`m.finishedstartup()`**\n\n  Tell FVWM that the module has finished setting things up and is ready to\n  start working.\n\n- **`m.exit(n=0)`**\n\n  Clean up and exit with exit status `n`.\n  See also `m.h_exit()` handler.\n\n- **`m.unlock(finished=False)`**\n\n  During synchronous operations, tell FVWM that module is ready to\n  continue working and is listening to FVWM.\n\n  If `finished` then notify FVWM that the module is about to exit.\n\n- **`m.push_masks(mask,syncmask,nograbmask)`**\n\n  Set mask, syncmask and nograbmask to new values temporarily.\n  If any of the values is `None` than the corresponding mask is left\n  unchanged.\n  \n  It is possible to have several embedded\n  `m.push_masks`--`m.restore_masks` constructs.\n\n- **`m.restore_masks()`**\n\n  Restore masks previously overridden by `m.push_masks`.\n  If mask stack is empty (more `m.restore_masks()`'s then\n  `m.push_masks()`'s)\n  `fvwmpy.IllegalOperation` exception is raised.\n\n- **`m.register_handler(mask, handler)`**\n\n  Register `handler` for packets of type matching `mask`.\n  The default mainloop executes all the handlers for all matching\n  packets in the order they were registered.\n\n  `handler` should be a callable taking one argument, which is a\n  packet of type matching `mask` and should be capable of processing\n  such a packet. Handlers should not raise any non-terminal exceptions.\n\n  If `handler` is already registered previously for some packet types,\n  it will not be registered again, neither it will be moved to the end\n  of execution queue for that type. If you want to move some registered\n  handler to the end of the queue, you have to unregister it first.\n\n  There are some predefined packet handlers, (see below) but one could\n  define more as functions or as methods in the derived class.\n  \n- **`m.unregister_handler(mask, handler)`**\n\n  Remove handler from the execution queue for the packets matching\n  `mask`. It is **not** an error to try to unregister a handler, which\n  is not registered. So, for example,\n  ```\n  m.unregister_handler(fvwmpy.M_ALL, m.h_handler)\n  ```\n  removes `m.h_handler` from all queues where it is present.\n\n- **`m.call_handlers(pack)`**\n\n  Execute all handlers in the queue corresponding to the `pack`'s\n  packet type passing packet `pack` to them. The default mainloop calls\n  `m.call_handlers()` on all packets received from FVWM except those\n  which are removed from the queue by `m.get*` methods or\n  `m.packets.pick(...,keep=False)` method.\n\n- **`m.clear_handlers(mask)`**\n\n  Clear all execution queues for packets matching `mask`.\n\n- **`m.registered_handler(handler)`**\n\n  Return the mask for the queues where handler is registered.\n\n- **`m.run()`**\n\n  Enter mainloop which simply reads packets from FVWM and for each\n  packet executes handlers in the queue, until\n  `m.exit()` or `m.h_exit()` method is called. It could be overloaded\n  in the derived class.\n  \n##### Supplied handlers\n\n- **`m.h_saveconfig(pack)`**\n\n  Packets type: `M_FOR_CONFIG`\n  \n  This handler is capable of processing packets matching\n  `fvwmpy.M_FOR_CONFIG|fvwmpy.M_SENDCONFIG`. It simply records the\n  information in `m.config` database. You can insert the following\n  lines in your code to keep the database up to date\n  \n  ```\n  m.getconfig()\n  m.register_handler(fvwmpy.M_FOR_CONFIG, m.h_saveconfig)\n  m.mask |= fvwmpy.M_SENDCONFIG | fvwmpy.M_CONFIG_INFO\n  ### If you want to process config in a synchronous manner\n  m.register_handler(fvwmpy.M_FOR_CONFIG, m.h_unlock)\n  m.syncmask |= fvwmpy.M_SENDCONFIG | fvwmpy.M_FOR_CONFIG\n  ```\n  `m.h_saveconfig(pack)` does not send *NOP UNLOCK* command to FVWM.\n  In case you want to process configuration information synchronously\n  register  `m.h_unlock` after `m.h_saveconfig`.\n\n- **`m.h_unlock(pack)`**\n\n  Packets type: `M_ALL`\n\n  This handler completely ignores its argument and sends the *NOP UNLOCK*\n  command to FVWM. FVWM waits for *NOP UNLOCK* after sending packets\n  matching `m.syncmask`, so it make sense to always\n  ```\n  m.register_handler(m.syncmask,m.h_unlock)\n  ```\n  after all other handlers are added.\n  If syncmask changes one should\n  ```\n  m.unregister_handler(fvwmpy.M_ALL, m.h_unlock)\n  m.register_handler(m.syncmask, m.h_unlock)\n  ```\n  to make sure that  `m.h_unlock` is the last one in the queues\n  \n- **`m.h_exit(pack)`**\n\n  Packet types: `M_ALL`\n\n  This handler ignores its argument, cleans things up and terminates the\n  module.\n\n- **`m.h_nop(pack)`**\n\n  Packet types: `M_ALL`\n\n  Do nothing.\n  \n- **`m.h_updatewl(pack)`**\n\n  Packet types: `M_FOR_WINLIST | M_ADD_WINDOW | M_DESTROY_WINDOW`\n  \n  This handler is capable to process packets matching\n  `fvwmpy.M_FOR_WINLIST|M_ADD_WINDOW|M_DESTROY_WINDOW`. It uses\n  information in the packet to update `m.winlist` database.\n  \n  \n#### FVWM variables and InfoStore\n\nInstances of `fvwmpy.fvwmpy` have two special objects `m.var` and\n`m.infostore`, which provide access to FVWM variables and FVWM\ninfostore database in a transparent manner.\n\n  The value of a variable (even non-existent) is always a string.\n  If variable `no.such.var` does not exist in FVWM environment,\n  the access methods below will return the literal string\n  `'$[no.such.var]'`. It is client's business to check for this and to\n  perform type casting, when necessary.\n\n  The behavior of infostore database is analogous.\n\n- **`m.var`**\n\n  One can access FVWM variables in two ways\n\n  1. `m.var.<var_name_with_underscores>` will be equal to the value of\n      FVWM variable as a string. FVWM variables often have a dot in\n      their names. To use this method you have to replace dots with\n      underscores. That is `m.var.w_id` will return the value\n      `$[w.id]`.  You can not assign to or delete FVWM variables, so\n      `m.var.w_id = <value>` or `del m.var.w_id` will raise\n      `fvwmpy.IllegalOperation()` exception.\n\n   2. `m.var('var_name1',...,context_window=None)` will return a tuple\n      with string-values of variables, whose names are given as string\n      arguments. It is not necessary (but allowed) to replace dots\n      with underscore in variable names, when using this method. If\n      `context_window == None` then module's context_window is\n      assumed. If `context_window == 0` then variable values are\n      obtained outside of any context.\n\n  The second method obtains all variable values in one communication\n  cycle with FVWM, so it is preferable, when values of several\n  variables are needed.\n\n  It is not possible to get value of a variable, whose name contains\n  underscore. To the best of my knowledge there are no such variables,\n  at least none are mentioned in the FVWM man pages.\n\n- **`m.infostore`**\n\n  Similarly, one can access FVWM infostore database in two ways\n\n  1. `m.infostore.<var_name_with_underscores>` will be equal to the\n      value of FVWM infostore variable as a string. You have to\n      replace dots with underscores in variable names. For example\n      `m.infostore.my_variable` will return the FVWM's expansion of\n      `$[infostore.my.variable]`.  You can also assign to or delete\n      FVWM infostore variables, so `m.infostore.my_variable = <value>`\n      or `del m.infostore.my_variable` are legal.\n\n  2. Similarly `m.infostore('var_name1',...)` will return a tuple with\n      string-values of variables, whose names are given as string\n      arguments. It is not necessary (but allowed) to replace dots\n      with underscore in variable names.\n\n  The second method obtains all variable values in one communication cycle\n  with FVWM, so it is preferable, when values of several variables are needed.\n   \n  Beware that it is not possible to get the value of, assign to, or\n  delete an infostore variable, whose name contains underscore.\n\nAccess methods for both FVWM variables and infostore variables work\nreliably independently of the state of the packet queue. So you can\nhave some stale packets in the queue and still get the correct values.\n  \nNote that each access attempt results in communication with FVWM, so it\nis better access once and store values, if needed.\n```\n### Bad practice, 4 communication cycles with FVWM\narea      = int(m.var.w_width) * int(m.var.w_height)\nperimeter = 2*int(m.var.w_width) + 2*int(m.var.w_height)\n\n### Good practice, 1 communication with FVWM\nwidth, height = map( int, m.var('w.width','w.height') )\narea      = width * height\nperimeter = 2 * (width + height)\n```\n\n\n#### Winlist database **`m.winlist`**\n\n`m.winlist` is a dictionary of windows indexed by window id's.  Each\nwindow is an instance of `fvwmpy._window` class and has the attributes\nand methods listed below. \n\nm.winlist has all the usual methods inherited from `dict`\nand one extra described below.\n\n- **`m.winlist.filter(conditions)`**\n\n  This method returns an iterator that cycle through windows matching\n  `conditions`\n\n  `conditions` is a string containing the same conditions that are\n  allowed in FVWM's conditional commands. See FVWM manual pages for\n  explanations. For formatting convenience `conditions` may be a\n  multi-line string. As an example look at the following (not very useful)\n  snippet\n  ```\n  condition = \"\"\"\n  \t      !FixedSize, !FixedPosition, \n  \t      !Shaded,!Iconic,CurrentPage\n  \t      !Fvwm*, !stalonetray\n  \t      \"\"\"\n  for w in m.windowlist.filter(condition):\n      dx = max( w.wdx//2, w.hints_min_width  )\n      dy = max( w.wdy//2, w.hints_min_height )\n      m.sendmessage( 'Resize {}p {}p'.format(dx,dy),\n      \t\t     context_window=w.window        )\n  ```\n  \n  Note that `winlist.filter` may have troubles, if the\n  winlist database is not up to date.\n\n  Winlist has \\_\\_str\\_\\_ method which gives some nice human readable\n  representation of entire database. The following very simple module\n  will print the database into the file when it is instructed to\n  do so by FVWM command *'SendToModule MyModule dumpwinlist'*\n  \n  ```\n  class MyModule(fvwmpy.fvwmpy):\t\t\t\t\t\n      def h_dumpwinlist(self,p):\n          if p.string == glob('dumpwinlist *'):\n              with open('winlist.txt','wt') as file:\n                  print(self.winlist,file=file)\n          elif p.string == glob('exit *'):\n              self.exit()\n\n  m=MyModule()\n  m.register_handler(fvwmpy.M_STRING,m.h_dumpwinlist)\n  m.register_handler(fvwmpy.M_FOR_WINLIST,m.h_updatewl)\n  m.finishedconfig()\n  \n  m.mask       = fvwmpy.M_STRING | fvwmpy.M_FOR_WINLIST\n  m.syncmask   = 0\n  m.nograbmask = 0\n  m.getwinlist()\n  m.run()\n  ```\n  \n##### Attributes and methods of instances of `fvwmpy._window` class.\n\n  For more comprehensive information and meaning of different\n  attributes refer to [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) and\n  consult **fvwm.h, window_flags.h, Module.h vpacket.h** files in FVWM\n  source tree.\n\n  Each value of `m.winlist` is `fvwmpy._window` object.\n  `fvwmpy._window` inherits from `dict`. For syntactic convenience\n  values of the dictionary can also be accessed as attributes via\n  `w.key`, which is completely equivalent to `w['key']`. Also both\n  raise `KeyError()` exception, if the key/attribute is missing.\n\n  The attributes/keys are\n\n- **`w.window`** window id\n- **`w.frame`** id of the frame window\n- **`w.wx`**, **`w.wy`** x,y location of the window’s frame\n- **`w.wdx`**, **`w.wdy`** width and height of the window’s frame\n- **`w.desk`** desktop number\n- **`w.layer`** layer\n- **`w.hints_base_width`**, **`w.hints_base_height`** window base width\n  and height\n- **`w.hints_width_inc`**, **`w.hints_height_inc`** window resize\n  width/height increment \n- **`w.orig_hints_width_inc`**, **`w.orig_hints_height_inc`**\n  original window resize width/height increment \n- **`w.hints_min_width`**, **`w.hints_min_height`**,\n  **`w.hints_max_width`**, **`w.hints_max_height`** \n  window minimum/maximum width/height\n- **`w.icon_w`** icon label window id, or 0\n- **`w.icon_pixmap_w`** icon pixmap window id, or 0\n- **`w.hints_win_gravity`** window gravity\n- **`w.text_pixel`** pixel value of the text color\n- **`w.back_pixel`** pixel value of the window border color\n- **`w.ewmh_hint_layer`** ewmh layer\n- **`w.ewmh_hint_desktop`** ewmh desktop\n- **`w.ewmh_window_type`** ewmh window type\n- **`w.title_height`** window title height\n- **`w.border_width`** border width\n- **`w.flags`** is a bytearray containing style flags and action\n  flags. See also `w.flag()` method.\n- **`w.win_name`** window name\n- **`w.ico_name`** icon name\n- **`w.win_vis_name`** window visible name\n- **`w.ico_vis_name`** icon visible name\n- **`w.res_class`** resolution class\n- **`w.res_name`** resolution name\n- **`w.mini_ico_dx`**, **`w.mini_ico_dy`** **ToDo these**\n- **`w.mini_ico_depth`**\n- **`w.winid_pix`**\n- **`w.winid_mask`**\n- **`w.mini_ico_filename`** **NOTE** there seems to be a bug in\n  FVWM. This value can not be decoded to a meaningful string with\n  neither 'ascii' nor 'utf8' codex.\n- **`w.ico_filename`**\n- **`w.flag(i)`** returns the value of the i^th flag as 0/1 integer.\n\n  **ToDo:** access flags by meaningful names.\n\n  **ToDo:** It seems that FVWM sends window position relative to the\n  current viewport. Shall we recalculate it to be absolute within the\n  desk? \n  \nThe winlist database is filled by `m.getwinlist()` method.\nYou can keep it up to date, see examples above.\n\n#### Config database **`m.config`**\n`m.config` is a database of configuration information sent in response\nto *Send_ConfigInfo* command. It is a list of strings, each is a\nmodule configuration line.\n\n  **Note:** Each configuration line is concatenation of module name and\n  configuration parameters without any delimiter. So the line\n  `*FvwmMymodule:Geometry 100x100+0-0` in FVWM's config is passed to\n  the module as '*FvwmMymoduleGeometry 100x100+0-0'. I am not sure\n  whether this is a FVWM bug or intentional.\n\n\nIn addition it has the following attributes\n\n- **`m.config.DesktopSize`** the size of the desktop (in pages)\n- **`m.config.ImagePath`** a tuple of strings, each is the path where FVWM\n  searches for images\n- **`m.config.XineramaConfig`** a tuple of integers. See FVWM manual pages\n  for the meaning.\n- **`m.config.ClickTime`** integer. Click time in milliseconds\n- **`m.config.IgnoreModifiers`** tuple of integers. Modifiers that are ignored.\n- **`m.config.colorsets`** list of colorsets, each represented as a list of\n  strings.\n\n  **ToDo:** We really need to parse colorsets and create meaningful\n  access to them.\n\n`m.config` has \\_\\_str\\_\\_ method that returns human readable\nrepresentation of the database. The following module prints config\ndatabase to the file when instructed by `SendToModule MyModule\ndumpconfig` command.\n\n```\nfrom fvwmpy import *\n\nclass MyModule(fvwmpy):\t\t\t\t\t\n    def h_cmd(self,p):\n        if p.string == glob('dumpwinlist *'):\n            self.info('Save window list to winlist.txt')\n            with open('winlist.txt','wt') as file:\n                print(self.winlist,file=file)\n        if p.string == glob('dumpconfig *'):\n            self.info('Save config to config.txt')\n            with open('config.txt','wt') as file:\n                print(self.config,file=file)\n        elif p.string == glob('exit *'):\n            self.info('Exiting...')\n            self.exit()\n\nm=MyModule()\nm.register_handler(M_STRING,      m.h_cmd)\nm.register_handler(M_FOR_WINLIST, m.h_updatewl)\nm.register_handler(M_SENDCONFIG,  m.h_saveconfig)\n  \nm.mask       = ( M_STRING     | M_FOR_WINLIST |\n                 M_FOR_CONFIG | M_SENDCONFIG    )\nm.syncmask   = 0\nm.nograbmask = 0\n\nm.finishedconfig()\n\nm.getwinlist()\nm.getconfig()\nm.run()\t\n```\n\n\n### Packet queue\n\nAn instance of `fvwmpy.fvwmpy` class has attribute `m.packets` that\nrepresents the queue of packets from FVWM. The structure of each packet\ndata type is described below.\n`m.packets` is an object of `fvwmpy._packet_queue` class.\nOne can change the level of logging produced by `m.packets` by calling\n`m.packets.logger.setLevel(<new_level>)` where <new_level> is\none of `fvwmpy.L_*` constants described above. The default level is\n`fvwmpy.L_WARN`, which makes it mostly quiet.\n\nThe packets are read from the FVWM-to-module pipe asynchronously and\nput into the queue for processing by the module.\n\n`m.packets` has the following attributes and methods\n\n- **`m.packets.__len__`**\n\n  You can see how many packets are waiting to be handled with\n  `len(m.packets)`.\n\n- **`m.packets.__bool__`**\n\n  `bool(m.packets)` returns `True` iff the queue is not empty.\n\n- **`m.packets.clear()`**\n\n  Empty the queue discarding all of its content.\n\n- **`m.packets.read(keep=False,timeout=None)`**\n\n  Returns and removes the packet from the top of the queue. If queue\n  is empty and `timeout` is `None` it waits for the packet to arrive.\n  If queue is empty and `timeout` is given and not `None`,\n  return value `None`, if no packet arrived in the pipe during timeout\n  seconds. \n\n- **`m.packets.peek(timeout=None)`**\n\n  This is like `m.packets.read` method, except the packet remains in\n  the queue and will be returned with the next `m.packets.read` or\n  `m.packets.peek` call, unless it will have been  `m.packets.pick()`'ed\n  meanwhile.\n  \n- **`m.packets.pick(picker, until=None, keep=False, timeout=0.500)`**\n\n  Return all packets from the queue for which\n  `picker` evaluates to true, possibly removing them from the queue,\n  depending on the parameter `keep`. The queue is searched until\n  packet for which `until` evaluates to true is found.\n  Even if no packets are found, return after `timeout` seconds.\n  \n  **Note:** the return value is always a `tuple`, even if returning\n  one or zero packets.\n\n  - `picker` must be a callable, taking a packet as a single parameter\n    and returning boolean value. It is used to prune the queue.  See\n    **Picker factory** for creating pickers.\n\n  - `until` is the same type as `picker`. The search in the queue will\n    be terminated once the packet for which `until` evaluated to\n    `True` is encountered. If not given or `None` then `until` is set\n    to be equal to `picker`. In that case the first (oldest) packet\n    matching `picker` will be found and returned (if it arrives within\n    `timeout` seconds).\n\n  - `keep` is a boolean that indicates whether packets should be\n    removed from the queue.\n\n  - `timeout`  indicates how many seconds shall\n    the method wait for `until(p)==True`-packet. If `timeout` is `None`,\n    wait indefinitely.\n      \n  Examples:\n\n  ```\n  from fvwmpy import *\n\n  m=fvwmpy()\n  ...\n  \n  ### Find all config lines about colorsets in he queue\n  packs = m.packets.pick( picker = picker( mask   = M_FOR_CONFIG,\n                                           string = glob(\"colorset*\") ),\n                          until  = picker( mask = M_END_CONFIG_INFO ) )\n\n  ### Find the oldest MX_ENTER_WINDOW PACKET\n  (pack,) = m.packets.pick( picker = picker( mask = M_ENTER_WINDOW ))\n\n  ### Find all `SendToModule`-messages from FVWM until this moment\n  tag = unique_id()\n  m.sendmessage(\"SendReply {}\".format(tag))\n  packs = m.packets.pick (picker = picker(mask=M_STRING),\n                          until  = picker(mask=MX_REPLY,\n                                          string=glob(tag)))\n\n  ### In the last example MX_REPLY packet will not be returned and\n  ### will remain in the queue. If this is undesired change the last\n  ### line to\n  end   = picker(mask=MX_REPLY,string=glob(tag))\n  pick  = picker(mask=M_STRING) | end\n  packs = m.packets.pick (picker=pick, until=end)\n  ```\n  \n##### FVWM packets\n\n`m.packets.{read,peek,pick}()` return an instance of `fvwmpy._packet`\nclass, which inherits from `dict`. Values can also be accessed via\n`p.key` or `p['key']` which are completely equivalent in that both\nraise `KeyError()` exception, if the key is missing.\n\nThe available keys/attributes depend on the packet and described below\nfor all types of packets. See [FVWM module\n  interface](https://www.fvwm.org/Archive/ModuleInterface/) when each\n  packet is sent and what information it contains.\n\nAny packet has always the following attributes\n- **`p.ptype`** - Integer. Type of the packet. See `fvwmpy.M[X]_*` constants.\n- **`p.name`** - String. Type of the packet as a character string\n  matching `glob('MX_*|M_*')`. This is a property, there is no\n  corresponding key in the dictionary.\n- **`p.time`** - Integer. Time stamp\n- **`p.body`** - Bytearray. The raw body of the packet without the header.\n\nOther attributes/keys depend on the packet. Below they are listed for\neach type of packets.\n\n- **`fvwmpy.M_NEW_PAGE`**\n  - **`p.px`**, **`p.py`** - Integer. Coordinates of the NW corner of the current\n    viewport.\n  - **`p.desk`** - Integer. Current desk number.\n  - **`p.max_x`**, **`p.max_y`** - Integer. Sizes of the current viewport.\n  - **`p.nx`**, **`p.ny`** - Integer. Number of pages in the desktop\n    in x- and y-directions.\n\n- **`fvwmpy.M_NEW_DESK`**\n  - **`p.desk`** - Integer. Current desk number.\n\n- **`fvwmpy.M_OLD_ADD_WINDOW`**, **`fvwmpy.M_EXTENDED_MSG`**,\n  **`fvwmpy.M_UNKNOWN1`**, **`fvwmpy.END_WINDOWLIST`**,\n  **`M_END_CONFIG_INFO`** \n\n  None\n\n\n- **`fvwmpy.M_RAISE_WINDOW`**, **`fvwmpy.M_LOWER_WINDOW`**,\n  **`fvwmpy.M_DESTROY_WINDOW`**, **`fvwmpy.M_MAP`**, **`fvwmpy.M_WINDOWSHADE`**,\n  **`fvwmpy.M_DEWINDOWSHADE`**, **`fvwmpy.MX_ENTER_WINDOW`**,\n  **`fvwmpy.MX_LEAVE_WINDOW`**\n  - **`p.window`** - Integer. Window id\n  - **`p.frame`** - Integer. Frame window id\n\n- **`fvwmpy.M_FOCUS_CHANGE`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.focus_change_type`**\n  - **`p.text_pix`**\n  - **`p.border_pix`**\n\n- **`fvwmpy.M_ICONIFY`**, **`fvwmpy.M_DEICONIFY`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.ix`**,  **`p.iy`** - These and below are integers.\n  - **`p.idx`**,  **`p.idy`**\n  - **`p.fx`**,  **`p.fy`**\n  - **`p.fdx`**,  **`p.fdy`**\n\n- **`fvwmpy.M_WINDOW_NAME`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.win_name`** - String. Name of the window.\n\n- **`fvwmpy.M_ICON_NAME`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.ico_name`** - String. Name of the icon window.\n\n- **`fvwmpy.M_RES_CLASS`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.res_class`** - String.\n\n- **`fvwmpy.M_RES_NAME`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.res_name`** - String.\n\n- **`fvwmpy.M_ICON_LOCATION`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.ix`**, **`p.iy`** - These and below are integers.\n  - **`p.idx`**, **`p.dy`**\n\n- **`fvwmpy.M_ERROR`**, **`fvwmpy.M_CONFIG_INFO`**,\n  **`fvwmpy.M_SENDCONFIG`**\n  - **`p.string`** - String. The content depends on the type of the packet.\n\n- **`fvwmpy.M_ICON_FILE`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.ico_filename`** - String. Name of the image file. \n\n- **`fvwmpy.M_DEFAULTICON`**\n  - **`p.ico_defaultfilename`** - Supposed to be a string, but FVWM\n  seems to send garbage.\n\n- **`fvwmpy.M_STRING`**, **`fvwmpy.MX_REPLY`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.string`** - String.\n\n- **`fvwmpy.M_MINI_ICON`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.mini_ico_dx`**, **`p.mini_ico_dy`** - Integer.\n  - **`p.mini_ico_depth`** - Integer\n  - **`p.winid_pix`**\n  - **`p.winid_mask`**\n  - **`p.mini_ico_filename`** - String.\n\n- **`fvwmpy.M_VISIBLE_NAME`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.win_vis_name`** - String.\n\n- **`fvwmpy.M_RESTACK`**\n  - **`p.win_stack`** - List of triples of integers.\n\n- **`fvwmpy.MX_VISIBLE_ICON_NAME`**\n  - **`p.window`** - As above.\n  - **`p.frame`** - As above.\n  - **`p.ico_vis_name`** - String.\n\n- **`fvwmpy.MX_PROPERTY_CHANGE`**\n  - **`p.prop_type`** - Integer\n  - **`p.val_1`**,  **`p.val_2`** - Integer\n  - **`p.prop_str`** - String.\n\n- **`fvwmpy.ADD_WINDOW`**, **`fvwmpy.M_CONFIGURE_WINDOW`**\n  The attributes of the packets of these types are the same as the\n  first 29 attributes of an instance of `fvwmpy._window` class above\n  (up to and including `w.flags`)\n  \n**ToDo:** Details of the packet attributes above.\n\n### Picker factory\n\nThe `fvwmpy` module defines a special class `fvwmpy.picker` that can be\nused for creating callables that take a packet as an argument and\nreturn a boolean value. There are two invocation signatures\n\n- **`fvwmpy.picker(fcn=None)`**\n\n  `fcn` is a callable with packet as an argument or `None`. \n  Return a callable (picker object) equivalent to the `fcn` in the sense that\n  `fvwmpy.picker(fcn)(p) == bool(fcn(p))` for any packet `p`.\n\n  If `fcn` is `None` then return a picker object, that is always True.\n\n- **`fvwmpy.picker(mask=None,**kwargs)`** \n\n  Returns a callable object, that can be called on a packet and\n  returns boolean value.\n\n  If\n  ```\n  pck = picker(mask=M, key1=val1, key2=val2,...)\n  ```\n\n  then `pck(p)` returns `True` iff the packet `p` matches mask `M` and has\n  key:value pairs `key1:val1`, `key2:val2`,...\n\n  If one of the keys is missing in packet `p`, then the return value\n  of `pck(p)` is `False`. If mask is `None`, then no mask matching is performed.\n  \n  In place of `val1`, `val2`, you can use `glob` and `Glob` objects ,\n  described above to check matching of strings against glob\n  patterns. See examples below.\n\n  `fvwmpy.picker` objects can be conjoined with `|`, `&` or unary `~`\n  operators. The resulting picker evaluated on packet `p` returns\n  value which is `or`, `and` or `not` of the value(s) of operand(s)\n  evaluated on `p`. These operators short-circuit from left to\n  right. You can build arbitrary boolean polynomials with picker\n  objects and the above operators.\n\n  For example, if\n  ```\n  pck1 = (\n           picker(win_name=glob('Fvwm*')  ) |\n           picker(res_name=glob('*term*') )\n         )\n\n  pck2 = picker(mask = M_ENTER_WINDOW|M_LEAVE_WINDOW, window=1234567)\n  \n  pck3 = picker(window = 987654321) & ~picker(mask=M_DESTROY_WINDOW)\n  ```\n  then `pck1(p)` will be true iff\n  packet `p` has key 'win_name' with a string value starting with 'fvwm' OR\n  if `p` has key 'res_name' with a value containing  'term'.\n\n  `pck2(p)` will be only true for packets emitted by FVWM when\n  pointer enters of leaves window with `id==1234567`.\n\n  `pck3(p)` will evaluate true on all packets related to window with\n  `id==987654321` except `M_DESTROY_WINDOW` packet.\n  \n  `picker` objects are handy for `m.packets.pick()` method, described\n  above and also for use in packet handlers.\n  \n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/rostislav-matveev/FvwmPy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "fvwmpy",
    "package_url": "https://pypi.org/project/fvwmpy/",
    "platform": "",
    "project_url": "https://pypi.org/project/fvwmpy/",
    "project_urls": {
      "Bug Tracker": "https://github.com/rostislav-matveev/FvwmPy/issues",
      "Homepage": "https://github.com/rostislav-matveev/FvwmPy"
    },
    "release_url": "https://pypi.org/project/fvwmpy/1.2.0/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Simple and flexible interface to develop FVWM modules",
    "version": "1.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12937191,
  "releases": {
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8df25523204da9e0a2a18ae5e559727f6e484c67f60fb24855885d6fbb033aaa",
          "md5": "0dca26c2896d7ec2dcc0eabffb141fdc",
          "sha256": "2e63f91000c0eb60aa631cfb721b536c7ac0be0ab779bb1474d37df0b08d7106"
        },
        "downloads": -1,
        "filename": "fvwmpy-1.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0dca26c2896d7ec2dcc0eabffb141fdc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 43867,
        "upload_time": "2022-02-14T17:20:37",
        "upload_time_iso_8601": "2022-02-14T17:20:37.664425Z",
        "url": "https://files.pythonhosted.org/packages/8d/f2/5523204da9e0a2a18ae5e559727f6e484c67f60fb24855885d6fbb033aaa/fvwmpy-1.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e60ad2e13fcdbbddbf9deacbc0e39d413efe0caf380f3ab245ad2d69230ca865",
          "md5": "38d79e9590d8b8c2a569e3db3dc5e396",
          "sha256": "474b39a38aa09ca6e7e0d2c8e14f8b65dd863919a8c71c1b57c446bac0d6d708"
        },
        "downloads": -1,
        "filename": "fvwmpy-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "38d79e9590d8b8c2a569e3db3dc5e396",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 67606,
        "upload_time": "2022-02-14T17:20:40",
        "upload_time_iso_8601": "2022-02-14T17:20:40.452236Z",
        "url": "https://files.pythonhosted.org/packages/e6/0a/d2e13fcdbbddbf9deacbc0e39d413efe0caf380f3ab245ad2d69230ca865/fvwmpy-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1fbd0f418bf72da28dadd7d940265a17773ec5e32b93da8c68b052dd6980cf35",
          "md5": "bcf7398cd2d5c0b4a958dc17a6efd823",
          "sha256": "e6dcf6f68f3ae3c94bbf02a136b2d6e0f85a0e01fbfc587c9c75b88ba9fe45da"
        },
        "downloads": -1,
        "filename": "fvwmpy-1.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "bcf7398cd2d5c0b4a958dc17a6efd823",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 45161,
        "upload_time": "2022-02-18T18:00:28",
        "upload_time_iso_8601": "2022-02-18T18:00:28.319998Z",
        "url": "https://files.pythonhosted.org/packages/1f/bd/0f418bf72da28dadd7d940265a17773ec5e32b93da8c68b052dd6980cf35/fvwmpy-1.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d282b7cbb0dd101f83360194e7d4d2c9c6d116e441bd04e7f58f44fef0add202",
          "md5": "49dfc187e52c3c039a9503c7e7a61725",
          "sha256": "e5d0ae43b50ee9eb362e7fad2ca99da84d0dbe0ce374b3df2edc12486c25271d"
        },
        "downloads": -1,
        "filename": "fvwmpy-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "49dfc187e52c3c039a9503c7e7a61725",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 69340,
        "upload_time": "2022-02-18T18:00:31",
        "upload_time_iso_8601": "2022-02-18T18:00:31.210263Z",
        "url": "https://files.pythonhosted.org/packages/d2/82/b7cbb0dd101f83360194e7d4d2c9c6d116e441bd04e7f58f44fef0add202/fvwmpy-1.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1fbd0f418bf72da28dadd7d940265a17773ec5e32b93da8c68b052dd6980cf35",
        "md5": "bcf7398cd2d5c0b4a958dc17a6efd823",
        "sha256": "e6dcf6f68f3ae3c94bbf02a136b2d6e0f85a0e01fbfc587c9c75b88ba9fe45da"
      },
      "downloads": -1,
      "filename": "fvwmpy-1.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "bcf7398cd2d5c0b4a958dc17a6efd823",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 45161,
      "upload_time": "2022-02-18T18:00:28",
      "upload_time_iso_8601": "2022-02-18T18:00:28.319998Z",
      "url": "https://files.pythonhosted.org/packages/1f/bd/0f418bf72da28dadd7d940265a17773ec5e32b93da8c68b052dd6980cf35/fvwmpy-1.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d282b7cbb0dd101f83360194e7d4d2c9c6d116e441bd04e7f58f44fef0add202",
        "md5": "49dfc187e52c3c039a9503c7e7a61725",
        "sha256": "e5d0ae43b50ee9eb362e7fad2ca99da84d0dbe0ce374b3df2edc12486c25271d"
      },
      "downloads": -1,
      "filename": "fvwmpy-1.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "49dfc187e52c3c039a9503c7e7a61725",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 69340,
      "upload_time": "2022-02-18T18:00:31",
      "upload_time_iso_8601": "2022-02-18T18:00:31.210263Z",
      "url": "https://files.pythonhosted.org/packages/d2/82/b7cbb0dd101f83360194e7d4d2c9c6d116e441bd04e7f58f44fef0add202/fvwmpy-1.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}