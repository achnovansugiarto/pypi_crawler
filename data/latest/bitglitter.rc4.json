{
  "info": {
    "author": "Mark Michon",
    "author_email": "markkmichon@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "![BitGlitter Logo](https://i.imgur.com/pX8b4Dy.png)\n\nLatest: `v2.0.0`\n\n### Python Library (you are here) | [Electron Desktop App](https://github.com/MarkMichon1/BitGlitter) | [Python Backend For App](https://github.com/MarkMichon1/BitGlitter-Backend)\n\n## âš¡ Store and transfer files using high-performance animated barcodes\n\n![BitGlitter Sample GIF](https://i.imgur.com/lPFR5kA.gif) \n\n**[Discord Server](https://discord.gg/t9uv2pZ)** \n[![Downloads](https://pepy.tech/badge/bitglitter)](https://pepy.tech/project/bitglitter)\n\n**[Youtube video of a real stream transferring ~80KB/s of data](https://youtu.be/TIKEEA2mXrI)**\n\nBitGlitter is an easy to use Python library that lets you embed data inside ordinary pictures or video.  Store and host\nfiles wherever images or videos can be hosted.  The carrier for data is the 'blocks' within the frames and not\nthe file itself, and there are various measures to read imperfect distorted frames.  What this means for you is streams\nare resistant to compression and distortion, and aren't broken by things such as format changes, metadata changes, etc.\nBitGlitter gives you a unique way to make your data more portable.\n\n![Frame Demo](https://i.imgur.com/Pgq4h1o.png)\n\nSample frame taken from video using default settings, holding 2.7 KB of data\n\n### Using ordinary barcodes as a launchpad\n\nBarcodes and QR codes are everywhere.  They embed binary data (0's and 1's) in them, symbolized as black and white.  While\nthey are pretty constrained in the real world, using them for digital transfer removes many of those limits.  What if you\ncould have multiple barcodes (frames), that if read sequentially could have the capacity of many thousands of individual\nones?  What if we added colors to the barcodes, so a given barcode could have 2x, 6x, 24x the capacity?  What if we greatly\nincreased the size of the frames to lets say the size of a standard 1080p video, so the frames once again increase their\ncapacity by a couple orders of magnitude.  Combine all of these together, and you're able to move serious amounts of \ndata.  This is BitGlitter.\n\n![BitGlitter Default Palettes](https://i.imgur.com/T6CiFOf.png)\n\n+ **Designed to survive what breaks existing steganography schemes:** BitGlitter doesn't rely on reading the exact stream that\nit outputs at write.  Because the data is in the video data itself and not in any metadata or byte format embedded in it,\nits resistant to format changes, resolution changes, compression, corruption, and other distortion.  Not much different\nfrom how barcodes in real life are resistant.\n+ **Hardened against frame corruption:** Virtually all video/image hosting social media type sites run your multimedia \nfiles through compression to minimize their file size.  This can cause compression artifacts (visual distortions) to \nappear.  In lossless steganography, this will completely corrupt the data, rendering it unreadable.  Not BitGlitter.  \nTaking in the palette used in the stream, it will \"snap\" incorrect colors to their nearest value, allowing you to read \ndata from frames that have gone though a gauntlet of compression.  The default write settings have been tested on \nseveral major sites, and were tweaked until there was 100% readability across tens of thousands of test frames.\n+ **Fully configurable stream creation:** While the default values cover most uses, you have full control of the write parameters:\n  + **Color set:** 8 default palettes to choose from that provide higher performance or greater file integrity.  You can\n  even make your own custom palettes (more on that below)\n  + **Block size:** These are the colorful squares that hold data.  They can be as small as one pixel, or as large as\n  you'd like.  Larger block sizes gives you greater data integrity, and smaller block sizes increase data capacity per\n  frame.\n  + **Frame dimensions:** Whether you want to output 144p compatible videos or 8K, it does it all.\n  + **Frame rate:** If its a non-zero whole number, yep\n  + **Output mode:**  Choose from either an MP4 video output, or a series of PNG images (BitGlitter accepts and reads both),\n  giving you greater flexibility on where you can host your data.\n+ **Built in file integrity:** Metadata, files, and the stream and frames themselves are protected with SHA-256 hashes.\nOnly valid data is accepted.\n+ **Built in encryption and file masking:** Encrypt your files with AES-256, and optionally the file manifest as well, \nmasking its contents until the correct key is used.\n+ **Built in compression:** Payloads are compressed using max zlib settings prior to rendering, to minimize stream \nsize.  No need to zip or rar your files prior.\n+ **Supports very large streams:** Current protocol can handle up to one [exabyte](https://en.wikipedia.org/wiki/Byte#Multiple-byte_units)\nin size, or ~4.3 billion rendered frames.  Put simply, there's no practical limit to your stream's size.\n\n![Custom Color Showcase](https://i.imgur.com/o4xa0Fq.png)\n\n### What is possible with various configurations?\n\nBecause everything can be customized, you can have completely different outputs with vastly different performance\ncharacteristics (data integrity vs performance).  In **bold** is the default parameters used which have been \nconsistently readable on major social media sites.  This is all new territory, what is readable can likely be tweaked and increased even more.\n\n| Number of Colors in Palette \t| Bits of Data Per Block \t| Frame Resolution        \t| Block Size in Pixels \t| Frame Dimensions (w * h in blocks) \t| Frames Rate \t| Data Throughput \t| Lossless? \t|\n|:---------------------------:\t|------------------------\t|-------------------------\t|----------------------\t|------------------------------------\t|-------------\t|-----------------\t|-----------\t|\n| 2                           \t| 1                      \t| 640 x 480 (480p)        \t| 20                   \t| 32 x 24                            \t| 30 FPS      \t| 1.56 KB/s       \t| No        \t|\n| 4                           \t| 2                      \t| 1280 x 720 (720p)       \t| 20                   \t| 64 x 36                            \t| 30 FPS      \t| 15.96 KB/s      \t| No        \t|\n| 8                           \t| 3                      \t| 1280 x 720 (720p)       \t| 20                   \t| 64 x 36                            \t| 30 FPS      \t| 24.6 KB/s       \t| No        \t|\n| 16                          \t| 4                      \t| 1920 x 1080 (1080p)     \t| 24                   \t| 80 x 45                            \t| 30 FPS      \t| 52.68 KB/s      \t| No        \t|\n| **64**                      \t| **6**                  \t| **1920 x 1080 (1080p)** \t| **24**               \t| **80 x 45**                        \t| **30 FPS**  \t| **79.68 KB/s**  \t| **No**    \t|\n| 64                          \t| 6                      \t| 1920 x 1080 (1080p)     \t| 24                   \t| 80 x 45                            \t| 60 FPS      \t| 159.36 KB/s     \t| No        \t|\n| 16,777,216                  \t| 24                     \t| 1920 x 1080 (1080p)     \t| 5                    \t| 384 x 216                          \t| 30 FPS      \t| 7.46 MB/s       \t| Yes       \t|\n| 16,777,216                  \t| 24                     \t| 3840 x 2160 (4K)        \t| 5                    \t| 768 x 432                          \t| 60 FPS      \t| 59.71 MB/s      \t| Yes       \t|\n\n### Installation\n\nIn addition to downloading the code from Github, you can also grab it directly from PyPI:\n\n`pip install bitglitter`\n\n###**The 2 Core Functions of BitGlitter**\n\nIgnoring the bells and whistles for now, all you need to use BitGlitter is `write()` and `read()`.  Both use an assortment\nof default arguments to remove a lot of the complexity starting out.\n\n+ `write()` takes your files and directories, and creates the BitGlitter stream (either as a video of a collection of \nimages).\n+ `read()` scans your BitGlitter encoded files and outputs the files/directories embedded in it.\n\n### write() -- converting files and directories into BitGlitter streams\n\nWe'll go a bit more in depth now.\n\n`write()` is the function that inputs files and turns them into a BitGlitter stream.  There are quite a few arguments\nto customize the stream, but there is only one required argument.  Everything else has defaults.\n\n`input_path` is an absolute path pointing to the file or directory you'd like convert into a stream.\n\n`preset_nickname=None` takes in a string name for a preset.  Learn more below in **Preset Functions**.\n\n`stream_name=''` **required** argument to name your stream, which will be encoded into the metadata of the stream when\nread.  150 character limit.\n\n`stream_description=''` serves as a text field to optionally put a description for the stream.  No character limit.\n\n`output_directory=None` is a string for the absolute path of an existing directory you'd like the stream to output to.is where you can optionally define the path of where the created media is outputted.  By default, the stream outputs in a \"Render Output\"\n folder within the library's directory.\n\n`output_mode='video'` controls the type of output you will have created.  Your two choices are `'video'`,\nor `'image'`.  Video outputs a single .mp4 file, whereas image output returns all of the frames.\n\n`stream_name_file_output=False` controls if outputted files will use the stream's SHA-256 hash as a name, or the \nprovided name (`stream_name`) for the stream.  By default, it uses the SHA-256, a 64 character hexadecimal 'fingerprint'\nof the stream.\n\n`max_cpu_cores=0` determines how many CPU cores you'd like to use when rendering frames.  0 is default, which is\nmaximum.\n\n`compression_enabled=True` enables or disables compression of your data, prior to rendering into frames.  \nThis is enabled by default.\n\n`encryption_key=''` optionally encrypts your data with AES-256.  By default, this is disabled.  The stream will not be\nable to be read unless the reader successfully inputs this.\n\n`file_mask_enabled=False` toggles whether you want the stream manifest to be encrypted or not when your stream itself is\nencrypted.  What this means is simpler terms is the contents of the stream will be hidden until or unless the correct\nencryption key is inputted.  If set to False, the full contents of the stream will be visible.  This only does anything\nwhen an encryption key is used.\n\n`scrypt_N=14`, `scrypt_R=8` and `scrypt_P=1` allow you to customize the parameters of the `scrypt` key \nderivation function.  You shouldn't touch this if you don't know what is.  Only change these settings if you're \ncomfortable with cryptography, and you know what you're doing!  It's worth noting `scrypt_N` uses its argument as 2^n.\nFinally, if you're changing these numbers, they MUST be manually added when using read functionality, otherwise \ndecryption will fail.  Custom values are deliberately not transmitted in the stream for security reasons. Your end users\nof the stream must know these parameters if they are changed, otherwise BitGlitter will use the default parameters when\ndecrypting.\n\n`stream_palette_id='6'` sets the palette used in the stream, after initialization headers are ran.  Takes a string of\nthe palette's palette_id.\n\n`pixel_width=24` sets how many pixels wide each 'block' is when rendered on screen.  24 pixels is default.  This is one \nof those values that have a large impact on readability.  Having them overly large will make reading it easier, but will\nresult in less efficient frames and require substantially longer streams.  Making them very small will greatly increase \ntheir efficiency, but at the same time a lot more susceptible to read failures if the files are shrunk, or otherwise\ndistorted.  This default value offers a nice middleground.\n\n`block_height=45` sets how many blocks tall the frame will be, by default this is set to 45 (which along with \n`block_width`, creates a perfect 1080p sized frame).\n\n`block_width=80` sets how many blocks wide the frame will be.  By default this is set to 80.\n\n`frames_per_second=30` sets how many frames per second the video will play at, assuming `output_mode = \"video\"` is used.\n\nFinally we have several arguments to control logging.\n\n`logging_level='info'` determines what level logging messages get outputted.  It accepts three arguments- `info` is\ndefault and only shows core status data during `read()` and `write()`.  `'debug'`  shows info level messages as well as\ndebug messages from the various processes.  Boolean `False` disables logging altogether.\n\n`logging_stdout_output=True` sets whether logging messages are displayed on the screen or not.  Only accepts booleans.\nEnabled by default.\n\n`logging_txt_output=False` determines whether logging messages are saved as text files or not.  Only accepts type \n`bool`. Disabled by default.  If set to `True`, a log folder will be created, and text files will be automatically saved\nthere.\n\n`save_statistics=False` saves some fun statistics about your usage of the program- total number of blocks rendered,\ntotal frames rendered, and total payload data rendered.  This updates after each successful write session.  Functions\nto interact with this data are below.\n\n**These default values transmit data at about 80 KB/s.**  This is a safe starting point that should be pretty resistant to\ncorruption.\n\n### read() -- converting BitGlitter streams back into directories and files\n\n`read()` is how we input BitGlitter streams (whether images or video), and output the files and directories encoded in\nthem.  There are several other functions included to interact with these streams (changing the encryption key to decrypt\nthe stream, removing one or all streams, changing its save path, etc).  Check out **Read Functions** below to learn more.\n\nLike with `write()`, the only argument required is the input path (`file_path`), except in this case it only accepts \nfiles.  Supported video formats are `.avi, .flv, .mov, .mp4, .wmv` and supported image formats are `.bmp, .jpeg, .jpg, \n.png, .webp`.  Can accept a string with a single absolute file path (image or video), or a list of strings of absolute \nfile paths.  Lists can only contain image files, videos must be one at a time.  **Important:**  When inputting image\nfiles, it is important to add the first few frames containing metadata FIRST, before adding the rest of the standard\npayload type frames.  This metadata gives the reader important data on palettes, stream configuration, and on the payload\nitself.  Some frames may be recognized as corrupted when this data is lacking.  Once metadata is received, the order of\nimages to input becomes irrelevant, and the library takes care of the rest.\n\n`stop_at_metadata_load=False` This will break out of the function *if* metadata for the stream is read.  This allows you\nto view the metadata and manifest (file/directory contents) of the stream itself, to verify the values for yourself.  From\nthere, you can choose to either re-read the file and continue getting the files, or delete it.  This is a security feature\nto double check what the contents are, before you extract the files onto your computer.  Please note that this will only\nrun **once** per stream.  When re-ran, the stream will continue to read and decode the files (if enabled in the arguments).\n\n`auto_unpackage_stream=True` controls whether files embedded in the stream should be extracted during read as the frame data\nbecomes available to do so.  This lets you extract all files that are available each time read concludes if enabled.  If\ndisabled, you can unpackage files using the function `unpackage(stream_sha256)`.  For more information, go to **Read Functions**\n\n`auto_delete_finished_stream=True` deletes all stream metadata and temporary files from your system once the read is\ncomplete, leaving you only with the decoded files pulled from the stream.  In most cases you probably wouldn't change this,\nbut in the event you want to view the data, you can do so here.\n\n`output_directory=None` sets where files will be written as they become available through decoding.  Takes in a string\nof an absolute path of an existing file directory.  This is \"set and forget\", in the sense the first time a stream is\nrecognized/created during read, the output path will be bound to the stream.  Subsequent read() calls for other frames \nwill continue to have the outputted files going to the right place.\n\n`bad_frame_strikes=25` Sets how many corrupted frames the reader is to detect before it aborts out of a video.  \nThis allows you to break out of a stream relatively quickly if the video or images are substantially corrupted, without \nneeding to iterate over each frame.  If this is set to 0, it will disable strikes altogether and attempt to read every \nframe regardless of the level of corruption.\n\n`max_cpu_cores=0` determines the amount of CPU cores to use, like `write()`.  The default value of 0\nsets it to maximum available.\n\n`block_height_override=False` and `block_width_override=False` allow you to manually input the stream's block height and \nblock width.  Normally you'll never need to use this, as these values are automatically obtained as the frame is locked\nonto.  But for a badly corrupted or compressed frame, this may not be the case.  By using the override, the reader will\nattempt to lock onto the screen given these parameters.  Both must be filled in order for the override to work.\n\n`encryption_key=None` is where you add the encryption key to decrypt the stream.  Like argument `output_directory`, you only\nneed this argument once, and it will bind to that save.\n\n`scrypt_n=14`, `scrypt_r=8`, and `scrypt_p=1` are values that control scrypt password hashing if your stream is encrypted.\nThese only need to be touched if the stream creator changed the default values during `write()`.  IF that is the case,\nthese values must be identical to the values used during write; decryption won't work even with the correct encryption\nkey.  Please note that you can change these values even after `read()` `with attempt_password()`.  See **Read Functions**\nbelow for more information.\n\n`logging_level='info'`, `logging_stdout_output=True`, `logging_txt_output=False`, and `save_statistics=False` are \narguments as well.  These are seen in `write()` as well; read their descriptions above to see what these do.\n\n### Custom Color Palette Functions\n\nIf you aren't happy with the 8 'official' palettes included with the library, you also have the freedom to create and \nuse your own, to have them match with whatever aesthetic/style or performance you want.  The entire process is very simple.\nThere is nothing you have to do for other people to read streams using your custom palettes; the software automagically\n'learns' and adds them through a special header on the stream, which then gives the ability for others to use your palette\nas well.  If you want to share your palette with others without them needing to read a BitGlitter stream, we got you \ncovered.  Custom palettes can also be imported and exported with [Base64](https://en.wikipedia.org/wiki/Base64) encoded \nshare strings.\n\n`add_custom_palette(palette_name, color_set, nickname='', palette_description='')` Creates a custom palette.  Once it has\nbeen created, a string of its unique ID is returned to you (a SHA-256 of its values as well as a timestamp, making it more\nor less entirely unique to that palette).\n\n+ `palette_name` is the its name which will it will be saved as.  It has a max length of 50 characters.\n\n+ `palette_description` is an optional field to include a brief description that will be attached with it.  It has a max\nlength of 100 characters.\n\n+ `color_set` Is the actual colors that will be used in it.  It can be a list of lists, or a tuple of tuples (no \ndifference) of [RGB24](https://en.wikipedia.org/wiki/RGB_color_model) values.  Heres an example to give you a better \nidea: `color_set=((0, 255, 0), (0, 0, 255))`.  There are a few constraints you must follow:\n  + No two identical values can be added.  For instance, the color black with the same RGB values twice.  Each color used\nmust be unique!  The more 'different' the colors are in terms of their values, the better.\n  + A minimum of two colors must be used.\n  + You must have 2^n total colors (2, 4, 8, 16, 32, etc), with up to 256 currently supported.\n\n+ `nickname` is an optional field that is a shorter, simple way to remember and use the palette, rather than its long\ngenerated ID.  Both serve as a unique way to identify the palette.\n\n`return_palette(palette_id=None, palette_nickname=None)` Returns a dictionary object of all of the palettes values.\n\n`edit_nickname_to_custom_palette(palette_id, existing_nickname, new_nickname)` Allows you to change the nickname of the \npalette.  Please note that the nickname must be unique, and no other palettes may already be using it.\n\n`export_palette_base64(palette_id=None, palette_nickname=None)` Export any of your custom palettes using this.  It returns\na share code which anyone can use to import your palette.\n\n`import_palette_base64(base64_string)` Import palettes from a unique share code (see directly above).\n\n`generate_sample_frame(directory_path, palette_id=None, palette_nickname=None, all_palettes=False, include_default=False,\npixel_width=20, block_height=20, block_width=20)` \nGenerates a small 'thumbprint' frame of a palette, giving you an idea of how it would appear in a normal rendering.  \n`directory_path` is an existing directory in which it will be saved. `all_palettes` toggles whether you want to get a \nsample from a specific palette (using `palette_id` or `palette_nickname`) or all palettes saved.  `include_default` toggles\nwhether you want to include all default palettes in the generated output, or if you only want to generate custom palettes.\nThe last 3 arguments let you control the exact size of the frames.  You can also use this function to generate artwork\nor cool looking wallpapers using the palettes as well.\n\n`return_all_palettes()` Returns a list of dictionary objects of all palettes in your database.\n\n`return_default_palettes()` Returns a list of dictionary objects of all default palettes in your database.\n\n`return_custom_palettes()` Returns a list of dictionary objects of all custom palettes in your database.\n\n`remove_custom_palette(palette_id, nickname)` Deletes a custom palette.\n\n`remove_custom_palette_nickname(palette_id, existing_nickname)` Removes the nickname from a given palette.  This doesn't\nremove the palettes themselves, and they can still be accessible through their palette ID.\n\n`remove_all_custom_palette_nicknames()` Removes all nicknames from all custom palettes.  As said directly above, this only\nremoves the nickname, not the actual palette.\n\n`remove_all_custom_palettes()` Deletes all custom palettes, leaving only the default (hardwired) palettes.\n\n### Read Functions\n\nDuring the read process, persistent data is stored in a sqlite database tracking its state.  These functions give you a\nlook inside, as well as some greater control of the reads themselves.  BitGlitter automatically deletes temporary byte\ndata for frames as soon as it can (ie, files can begin to be unpackaged).  What remains of finished streams is a small,\nminimal view of their internal state, as well as stream metadata.  Be aware that the `read()` argument \n`auto_delete_finished_stream=True` (default) will automatically delete these when the stream is fully decoded (ie, all frames\nare accounted for).  For more information read about `auto_delete_finished_stream` above.\n\nFinal note before proceeding- many of these functions you'll see `stream_sha256`; this is a string of the stream's \nSHA-256 hash.\n\n`unpackage(stream_sha256)` If `unpackage_files=False` was an argument in read(), this will unpackage the stream (or as\nmuch as it can from what has been scanned and decoded).  A dictionary object will be returned that either outlines\nthe actions taken, or the error(s) why unpackaging cannot take place (yet)\n\n`return_single_read(stream_sha256, advanced=False)` Returns a basic dictionary object of stream read's state. Some fields\nmay be empty depending on its state, or how many metadata headers have been decoded so far.  Setting `advanced` to \n`True` will return all state data (for development, debugging, or if you're just curious).  Returns `False` if SHA-256 \nmatches no existing stream.\n\n`return_all_read_information(advanced=False)` Returns a list of dictionary objects of all of the stream read states\nin your database.  For more information on what `advanced` does, look directly above this.\n\n`update_decrypt_values(stream_sha256, decryption_key=None, scrypt_n=None, scrypt_r=None, scrypt_p=None)`\nUpdates values to decrypt the stream.  From here, you have two paths:  If file masking is enabled on the stream,\n`attempt_metadata_decrypt()` will decrypt the metadata header (necessary for extracting files from binary data), and\nfrom there you can `unpackage()`.  Otherwise if file masking is disabled but the stream is encrypted, you can go straight\nto unpacking.\n\n`attempt_metadata_decrypt(stream_sha256)` will attempt to decrypt the metadata from your read stream (if it is\nencrypted with file masking enabled), using your supplied decryption parameters (decryption key, scrypt N, scrypt R,\nscrypt P).  Returns a dictionary object with the decoded metadata; if there is any error, it will return a brief explanation.\n\n`return_stream_manifest(stream_sha256, return_as_json=False)` Returns an overview of all files included in the given \nstream, as well as their file size, and SHA-256 hash.  Nested directory structures (if applicable) and file data are \nincluded in the returned object.  Keys are quite short to minimize manifest size when being transmitted.\n\n+ For directories:  `n` directory name, `f` files in that directory (not including subdirectories), `s` subdirectories for\nthat given directory.\n\n+ For files: `fn` file name, `rs` raw file size (its true size), `rh` raw file hash (its true SHA-256 hash), `ps` \nprocessed file size (its packaged size when being transmitted), `ph` processed file hash (its packaged SHA-256 hash when \nbeing transmitted). Files are compressed in transit (unless you explicitly disable it in `write()` settings), hence the\nalternate size and hash for them.\n\n`return_as_json` controls the format of the returned output.  If set to `False`, it returns a dictionary object; if \n`True`, it will send a JSON string.\n\n`remove_partial_save(stream_sha256)` Completely removes the stream read from the database.  Be aware that read argument\n`auto_delete_finished_stream` automatically does this if enabled for the stream.\n\n`remove_all_partial_save_data()` Removes all stream reads from the database.\n\n`update_stream_read(stream_sha256, auto_delete_finished_stream=None, auto_unpackage_stream=None)` Is where you can\nupdate behavior when the stream unpackages.\n\n`blacklist_stream_sha256(stream_sha256)` Disallow a specific SHA-256 hash of a stream to be read on your client.  Will\nalso remove the Stream Read containing that hash as well, if it exists.\n\n`return_all_blacklist_sha256()` Returns a list of all blacklisted SHA-256 hashes as strings.\n\n`remove_blacklist_sha256(stream_sha256)` Removes a specific SHA-256 hash.  Returns `True` or `False` depending on whether\nit existed.\n\n`remove_all_blacklist_sha256()` Removes all SHA-256 hashes from the blacklist.\n\n`return_stream_frame_data(stream_sha256)` Returns a list of dict objects with data about all read/decoded frames.  Warning:\ndepending on stream size, this may be a long/resource intensive function to perform.\n\n`return_stream_file_data(stream_sha256)` Returns a list of dict objects with data about all files read from the manifest.\nYou'll get access to their name, file size, SHA-256 hash, whether they are eligible to be unpackaged, if they were already\nunpackaged, and other less user-friendly internal state data.\n\n`return_stream_progress_data(stream_sha256)` Returns a list of dict objects with data about current 'slices' of the stream\nyou're able to unpackage.  These index numbers are 0-based and are for bits; this is the internal system BitGlitter uses\nto determine eligible files.\n\n`verify_is_bitglitter_file(file_path)` Allows you to quickly test whether a given image or video is a valid BitGlitter \nstream or not, without relying on `read()` and possibly saving anything to the database.  Attempts to lock onto the \nframe and read/decode the initializer header; it will return a boolean value whether that was successful or not.\n\n### Preset Functions\n\nPresets allow you to define `write()` behavior (geometry, palettes, etc) and save it with a nickname, so you can \nquickly and easily use your favorite configurations with a single string, without needing to explictly state all \nparameters every time.\n\n`add_new_preset(nickname, output_mode='video', compression_enabled=True, scrypt_n=14, scrypt_r=8, scrypt_p=1,\nstream_palette_id='6', header_palette_id='6', pixel_width=24, block_height=45, block_width=80, frames_per_second=30)`\nis how you add a new preset.  Please note all of its default arguments are identical to default `write` arguments.  For\nmore information on each of these arguments, check out the `write()` section for arguments above.\n\n`return_preset_data(nickname)` returns a dictionary object returning the full state of the preset.\n\n`return_all_preset_data()` returns a list of all of the presets as dictionaries.\n\n`remove_preset(nickname)` removes the preset with the `nickname` you gave it.\n\n`remove_all_presets()` removes all saved presets.\n\n### Statistics Functions\n\n`output_stats()` Returns a dictionary object displaying the following data for both reads and writes: blocks processed,\nframes processed, data processed.\n\n`clear_stats()` All statistics reset back to zero.\n\n### General Functions\n\n`remove_session()` Resets the entire state of the library.  Removes statistics data, all saved streams, saved presets,\nand saved palettes.  All settings get reverted to default, and default/included palettes are re-added.  This can't be undone.\n\n`return_settings()` Returns a dictionary object of all settings.\n\n`update_settings(read_path=None, read_bad_frame_strikes=None, enable_bad_frame_strikes=None, \n                    write_path=None, log_txt_path=None, log_output=None, logging_level=None, maximum_cpu_cores=None,\n                    save_statistics=None, output_stream_title=None)` Allows you to update any of the settings.  Use caution\nwhen changing these, as it could potentially result in crashes for invalid values.\n\n![Splitter](https://i.imgur.com/tozbtUz.png)\n\n### Roadmap\n\nHere are a few possible directions this can move in which would increase its usefulness and versatility:\n- **Command line functionality:** Ability to read and write BitGlitter streams as well as use the rest of the built-in\nfunctions, straight from the terminal.\n- **\"Splash Screen\":** At the end of streams, include some cool looking rendered animation with the project logo, a \nbrief explanation of what it is, and a URL to download the software.  People not knowing what BitGlitter is will now\nhave an idea as well as a way to download it, increasing usage and fueling development of the project.  Could also\ninclude metadata about the stream itself.\n- **Inline streams:** Have a stream embedded in another (non-BitGlitter) video, allowing for data to be read inside\na normal, human-friendly video.  Rather than taking up the full video screen, the stream could be a bar on the top or\nbottom of the screen, or any arbitrary shape (perhaps even animated).  This allows content creators to 'attach' files\nto their videos, much like you can attach arbitrary files to an email.\n- **Moving heavy lifting away from Python:** While libraries like `cv2` and `numpy` are used which utilize C++, pure\nPython is used in a few heavily used functions (thousands of times per second).  Moving these to Rust or C++ would \nsubstantially speed up the software, and make new use cases possible...\n- **Livestream capabilities:** BitGlitter streams can be 'broadcast' over live video.  Reader would be able to detect\ndata streams through visual or audio cues from the multimedia, and can process/decode on the fly.  BitGlitter streams \nare no longer restricted to 'static' files, but are open to any kind of live-streaming data, which can be optionally\ncompressed/encrypted through the original feature set.\n\n### Contributing\n\n**Let me know of your ideas and suggestions!**  There are many directions this technology can go in, and with enough interest\nyour ideas can be future additions to this core library (as well as the desktop app).  If you're looking to help with \ndeveloping it.... awesome.  All I ask is you're skilled with Python, and can write clean and structured code.  I went\nout of my way to have clear variable and function names as well as a decent amount of comments scattered throughout the\nlibrary- it should be relatively easy to get up to speed to understand how BitGlitter works underneath the hood.\n\nDrop in and say hi on the Discord server:\n\n**https://discord.gg/t9uv2pZ**\n\n### Disclaimer\n\nThere are a few points worth bringing up on using this library:\n\n+ **Output sizes can be huge.** At the end of the day, we're using far less dense storage mediums (color data in image and video \nframes) to hold and transmit good amounts of data.  The payback, however, is giving you much greater portability in how\nor where you can store, host, and transmit it.  Depending on the settings, stream size can be 1.01x-100x+ the size of the\npayload itself.  Start with relatively smaller files when starting out with this library to get a better feel for this.  \nFor now until we get a better feel for how people are using it and how things can be fine-tuned, its a fair assumption that\nBitGlitter is best suited for payloads less than 50-100MB.\n+ **This library is completely experimental:** In its current state, BitGlitter is merely a proof of concept to see if\ndoing this was possible and if there is interest.  It started as one of my first projects learning Python and programming\nas a whole.  There is made by one person, but I'm doing my best to create a well-rounded product that accomplishes what \nits designed to do.\n\nPlease use the issues page or let me know on Discord if there is something not working.\n\n### Acknowledgements\nThank you to [Tanmay Mishra](https://github.com/tmishra3) for giving me guidance during planning of the library, as well\nas its initial development. A big thank you to [Jack Robison](https://github.com/jackrobison) as well for his continued\nwisdom.\n\n**The third party libraries that make BitGlitter possible:**\n\n+ `bitstring` - Bit manipulation\n+ `cryptography` - Cryptographic functions\n+ `numpy` - Formatting frames as high performance array during read()\n+ `opencv-python` - Video loading, frame rendering, scanning and frame manipulation.\n+ `SQLAlchemy` - Managing all persistent data\n\n# MIT License\nÂ© 2021 - âˆž Mark Michon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated \ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the \nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\n persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the \nSoftware.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR \nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR \nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/MarkMichon1/BitGlitter-Python",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "BitGlitter",
    "package_url": "https://pypi.org/project/BitGlitter/",
    "platform": "",
    "project_url": "https://pypi.org/project/BitGlitter/",
    "project_urls": {
      "Homepage": "https://github.com/MarkMichon1/BitGlitter-Python"
    },
    "release_url": "https://pypi.org/project/BitGlitter/2.0.0/",
    "requires_dist": [
      "bitstring (==3.1.9)",
      "cryptography (==3.4.8)",
      "opencv-python (==4.5.3.56)",
      "SQLAlchemy (==1.4.25)"
    ],
    "requires_python": "",
    "summary": "⚡ Embed data payloads inside of ordinary images or video, through high performance 2-D matrix codes.",
    "version": "2.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12437370,
  "releases": {
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "97a2c89c1498b106af58489039aa0d829c02a15138fe019315c0e7cb20bd4b2e",
          "md5": "5e87e8e90c82f0fcd5bf72f725d6a3d9",
          "sha256": "c5b127e20889513cea906b420f45f900c7c9e4ecf870f63aaf4b95747ec333ee"
        },
        "downloads": -1,
        "filename": "BitGlitter-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5e87e8e90c82f0fcd5bf72f725d6a3d9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 12748612,
        "upload_time": "2019-05-24T23:25:45",
        "upload_time_iso_8601": "2019-05-24T23:25:45.306062Z",
        "url": "https://files.pythonhosted.org/packages/97/a2/c89c1498b106af58489039aa0d829c02a15138fe019315c0e7cb20bd4b2e/BitGlitter-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "566ec5ea3c02e1c57e116a3686736f5814b2611e019427d080d97ea0a2f6d517",
          "md5": "a939d1d930a1b88a70b992d3518021db",
          "sha256": "19613812e5143728807ae8c8be9a36e25dbc44b2c8ce6707647367d379545506"
        },
        "downloads": -1,
        "filename": "BitGlitter-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "a939d1d930a1b88a70b992d3518021db",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 5380593,
        "upload_time": "2019-05-24T23:25:56",
        "upload_time_iso_8601": "2019-05-24T23:25:56.429282Z",
        "url": "https://files.pythonhosted.org/packages/56/6e/c5ea3c02e1c57e116a3686736f5814b2611e019427d080d97ea0a2f6d517/BitGlitter-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0bc48044bd40c777f15f843dad9994b54a6598f6e45aec0c79ac9fecae994416",
          "md5": "c18ebef5750e3f5584a2fdd012c29f9b",
          "sha256": "bdcc28b9614756339230245f44010150250b32e5272d4bd21f1d78b70d303330"
        },
        "downloads": -1,
        "filename": "BitGlitter-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "c18ebef5750e3f5584a2fdd012c29f9b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 2879233,
        "upload_time": "2019-06-06T18:45:33",
        "upload_time_iso_8601": "2019-06-06T18:45:33.351702Z",
        "url": "https://files.pythonhosted.org/packages/0b/c4/8044bd40c777f15f843dad9994b54a6598f6e45aec0c79ac9fecae994416/BitGlitter-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2669086114635f8437920407cd4d4ebd617a87e048ebfd4f23b6eff6c0e18a1b",
          "md5": "0492fdd08a229567cfeb44c817330555",
          "sha256": "1f7f1e12b4201451c53c8b7e4651bd2d010ab02e782719573a12fc43ae2e641d"
        },
        "downloads": -1,
        "filename": "BitGlitter-1.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0492fdd08a229567cfeb44c817330555",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 77904,
        "upload_time": "2019-11-27T05:42:28",
        "upload_time_iso_8601": "2019-11-27T05:42:28.591192Z",
        "url": "https://files.pythonhosted.org/packages/26/69/086114635f8437920407cd4d4ebd617a87e048ebfd4f23b6eff6c0e18a1b/BitGlitter-1.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5416a40772016ddc6bb8d833967f1c738c3fdd86dea0b7cfa8c0689d4c172566",
          "md5": "ad6cac0eafe8cc9f28729c5d6b3d38c3",
          "sha256": "157019c50a3f3585672328540dd8bd34fd85064b9370774567187e09ec7dbe60"
        },
        "downloads": -1,
        "filename": "BitGlitter-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "ad6cac0eafe8cc9f28729c5d6b3d38c3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 73473,
        "upload_time": "2019-11-27T05:42:29",
        "upload_time_iso_8601": "2019-11-27T05:42:29.861946Z",
        "url": "https://files.pythonhosted.org/packages/54/16/a40772016ddc6bb8d833967f1c738c3fdd86dea0b7cfa8c0689d4c172566/BitGlitter-1.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a007e50c06180100ca92c5d26567d94cc3b5d487bf2f0dd0979586b07a5d6c93",
          "md5": "6a5d87ee0f542a9426df0b4908f153e1",
          "sha256": "b2b98c2b4b7cfc1e45a12d539250e7b7496a361955729cb6ea4d2aaa0cc6776a"
        },
        "downloads": -1,
        "filename": "BitGlitter-2.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6a5d87ee0f542a9426df0b4908f153e1",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 8990623,
        "upload_time": "2021-12-30T03:50:42",
        "upload_time_iso_8601": "2021-12-30T03:50:42.352642Z",
        "url": "https://files.pythonhosted.org/packages/a0/07/e50c06180100ca92c5d26567d94cc3b5d487bf2f0dd0979586b07a5d6c93/BitGlitter-2.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d828e07d0c560de9ffeb50ab230d58d24e767fce0660f85375026e2b8c96955e",
          "md5": "ed5c0a7e8a8b3a5d8f11d38bcfe3e202",
          "sha256": "9cf8de30fd87fb89ac76209253d9a6fd6b39bfa21eb1d43a0204732241833f7f"
        },
        "downloads": -1,
        "filename": "BitGlitter-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ed5c0a7e8a8b3a5d8f11d38bcfe3e202",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 7762872,
        "upload_time": "2021-12-30T03:50:47",
        "upload_time_iso_8601": "2021-12-30T03:50:47.939468Z",
        "url": "https://files.pythonhosted.org/packages/d8/28/e07d0c560de9ffeb50ab230d58d24e767fce0660f85375026e2b8c96955e/BitGlitter-2.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a007e50c06180100ca92c5d26567d94cc3b5d487bf2f0dd0979586b07a5d6c93",
        "md5": "6a5d87ee0f542a9426df0b4908f153e1",
        "sha256": "b2b98c2b4b7cfc1e45a12d539250e7b7496a361955729cb6ea4d2aaa0cc6776a"
      },
      "downloads": -1,
      "filename": "BitGlitter-2.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6a5d87ee0f542a9426df0b4908f153e1",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 8990623,
      "upload_time": "2021-12-30T03:50:42",
      "upload_time_iso_8601": "2021-12-30T03:50:42.352642Z",
      "url": "https://files.pythonhosted.org/packages/a0/07/e50c06180100ca92c5d26567d94cc3b5d487bf2f0dd0979586b07a5d6c93/BitGlitter-2.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d828e07d0c560de9ffeb50ab230d58d24e767fce0660f85375026e2b8c96955e",
        "md5": "ed5c0a7e8a8b3a5d8f11d38bcfe3e202",
        "sha256": "9cf8de30fd87fb89ac76209253d9a6fd6b39bfa21eb1d43a0204732241833f7f"
      },
      "downloads": -1,
      "filename": "BitGlitter-2.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "ed5c0a7e8a8b3a5d8f11d38bcfe3e202",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 7762872,
      "upload_time": "2021-12-30T03:50:47",
      "upload_time_iso_8601": "2021-12-30T03:50:47.939468Z",
      "url": "https://files.pythonhosted.org/packages/d8/28/e07d0c560de9ffeb50ab230d58d24e767fce0660f85375026e2b8c96955e/BitGlitter-2.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}