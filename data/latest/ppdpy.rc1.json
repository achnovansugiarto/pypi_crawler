{
  "info": {
    "author": "Eric J. Kinoshita",
    "author_email": "eric.void@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# PPDPY\n\nPPDPY - \"Preprocessor Directives for Python\" - is a minimal templating library.\nUse code like preprocessor directives (or compiler instructions) to make a plain\ntext into dynamic template.\n\nCurrently there is only one type of directive: conditionals. The conditionals\naccepts simple logic expressions with boolean symbols.\n\n## Installing\n\n    $ pip install ppdpy\n\n## Quick Start\n\nSuppose you have a template file named \"mytemplate.txt\" with the following contents:\n\n    line 1\n    #if a or b\n    line 2\n    #elif c\n    line 3\n    #else\n    line 4\n    #endif\n    line 5\n\nThen this file can be rendered like this:\n\n    >>> import ppdpy\n    >>> with open('mytemplate.txt') as f:\n    ...     template = ppdpy.compile(f)\n    >>>\n    >>> print(template.render({'a'}))\n    line 1\n    line 2\n    line 5\n\n    >>> print(template.render({'b'}))\n    line 1\n    line 2\n    line 5\n\n    >>> print(template.render({'c'}))\n    line 1\n    line 3\n    line 5\n\n    >>> print(template.render({}))\n    line 1\n    line 4\n    line 5\n\nThe ppdpy module has the following functions:\n\n* `render(file, symbols)` render a file using the given set of symbols, and returns the rendered string;\n* `renders(text, symbols)` render a string using the given set of symbols, and returns the rendered string;\n* `compile(file)` compiles a file, and returns a template object that can be rendered later;\n* `compiles(text)` compiles a string, and returns a template object that can be rendered later.\n\n### Example use case - SQL\n\nThis template engine can be used with any kind of text files, but the main use\ncase this library was implemented for was to manipulate raw SQL files.\n\nPPDPY is minimal, but it can prove itself handy when used with raw SQL\nqueries. The following example outputs queries to be used with pyscopg2\n(PostgreSQL).\n\n    select channel.id, channel.name, membership.joined_at\n\n    #if select_unread_count\n        ,(select coalesce(count(*), 0) from messages m\n          where m.channel_id = channel.id\n            and m.sender_id != chat_user.id\n            and (last_read.id IS NULL OR m.sent_at > last_read.sent_at)\n        ) as unread_count\n    #endif\n\n    from channel\n\n        inner join membership\n        on membership.channel_id = channel.id\n\n        inner join chatuser\n        on chat_user.id = membership.chat_user_id\n\n    #if select_unread_count\n        left join message last_read\n        on last_read.id = membership.last_read_id\n        and last_read.channel_id = channel.id\n    #endif\n\n    where chat_user.id = %(user_id)s\n\n    #if filter_by_status\n        and channel.status = %(status_filter)s\n    #endif\n\n    order by\n    #if order_by_join_date\n        membership.joined_at\n    #elif order_by_readcount\n        4\n    #else\n        channel.name\n    #endif\n\n    #if sort_descending\n        DESC\n    #else\n        ASC\n    #endif\n\nUsually there are very complex SQL commands that are hard to write using ORMs.\nEither ORMs does not have the necessary features to write this kind of queries at\nall, or the resulting code is unmaintainable - very complicated and unreadable,\nand certainly very difficult fix or change it later.\n\nAnd sometimes using Raw SQL is not viable, because ORMs allows us to dynamically\nchange the selected columns, the joined tables, the where filters and the\nsorting columns and directions. A more \"traditional\" SQL approach would be to\ncreate multiple SQL files (or strings) for the combinations of the desired\nqueries, but you would end up with lots of similar files  to do slightly\ndifferent things (what is also bad for maintainability).\n\nAnother solution would be to use raw SQL with \"manual\" string manipulation. But\nfrankly, this is not nice and also bad for maintainability.\n\nSince PPDPY considers its input as plain text, any kind of text file can be used (not just SQL).\n\n\n## API\n\nThe `ppdpy` module contains the following functions.\n\n`def render(file, symbols):` receives a file pointer and a set of strings,\nand returns the rendered string. The set of strings is used to evaluate\nthe expressions in the template, and each string a symbol that computes to `True`.\nSymbols are computed to `False` if they are not present in the strings set.\n\n    >>> import ppdpy\n    >>> with open('testfile.txt') as f:\n    ...     print(ppdpy.render(f, {'test'}))\n    foobar\n    test block reached\n\nOther iterable types are accepted on the `symbols` argument. They are\nconverted to `set` internally. Also, dictionaries are accepted.\nIn this case the keys of the dictionary will be used as symbols.\nInternally, it runs `symbols = set(symbols.keys())`.\n\n`def renders(text, symbols):` the same as `render`, but receives a string\nat the first argument.\n\n    >>> print(ppdpy.renders(\"\"\"foobar\n    #if test\n    test block reached\n    #endif\n    \"\"\", {'test'}))\n    foobar\n    test block reached\n\n`def compile(file):` compiles the contents of a file and returns a `Template` object,\nwhich can be used to render it later.\n\n    >>> import ppdpy\n    >>> with open('testfile.txt') as f:\n    ...     template = ppdpy.compile(f)\n    >>>\n    >>> template.render({'test'})\n    foobar\n    test block reached\n\n`def compiles(text):` compiles the given string and returns a `Template` object.\n\n    >>> import ppdpy\n    >>> template = ppdpy.compiles(\"\"\"foobar\n    #if test\n    test block reached\n    #endif\n    \"\"\")\n    >>>\n    >>> template.render({'test'})\n    foobar\n    test block reached\n    >>> template.render({})\n    foobar\n\n`def set_directive_prefix(prefix):` use this to change the directive prefix, if\nthe file type you want to render uses the `#` char as special (like comments).\nThis function will set the directive prefix globally.\n\nThe prefix can be of any length, containing any char of the following: digits,\nASCII letters and punctuation (refer to Python's string module).\nInvisible characters (like spaces, tabs and line breaks) are not allowed.\n\n### Template object\n\nThe template object only has the following method:\n\n`def render(self, symbols):` renders the template with the given symbols (set of strings)\nand returns the rendered string.\n\n## Exceptions\n\n`ppdpy.exceptions.DirectiveSyntaxError` is raised when there are errors related to directives.\n\n`ppdpy.exceptions.ExpressionSyntaxError` is raised when there are errors related to the boolean expressions.\n\n## Directives\n\nAll directives starts with `#` char, and it must be the first visible char in\nthe line to be considered as a directive. For example, all the following lines are\nconsidered as directives:\n\n    #if something\n        #if another_thing\n        #else\n      #endif\n    #endif\n\nThe available directives are:\n\n* `#if` starts a conditional block;\n* `#elif` is an else-if conditional block, to create composite conditional blocks (optional);\n* `#else` is the \"fallback\" conditional block - if none of the previous blocks calculates to True,\n  then this block is rendered (optional);\n* `#endif` ends a conditional block.\n\nThe directives are **case insensitive**, so `#IF something` is equal to `#if something`.\n\n### Examples:\n\nSimple conditional block:\n\n    #if my_symbol\n    foobar\n    #endif\n\nSimple conditional with else block:\n\n    #if my_symbol\n    foobar\n    #else\n    noop\n    #endif\n\nConditional block with elif:\n\n    #if my_symbol\n    foobar\n    #elif other_symbol\n    fuzzbuzz\n    #endif\n\nConditional block with elif and else:\n\n    #if my_symbol\n    foobar\n    #elif other_symbol\n    fuzzbuzz\n    #else\n    noop\n    #endif\n\nNested conditional blocks are supported. For example:\n\n    #if a and b\n        foo\n        #if c or d\n            bar\n        #else\n            test\n        #endif\n    #endif\n\n## Expressions\n\nThe expressions supported by `#if` and `#elif` directives are basic boolean logic with\nthese operators: `and`, `or` and `not`. These operators are **case insensitive**\nExamples of supported expressions:\n\n* `#if a`\n* `#if not a`\n* `#if a and b`\n* `#if a and not b`\n* `#if a or b`\n* `#if a or not b`\n* `#if a and (b or c)`\n* `#if a and not (b or c)`\n* `#IF a AND NOT (b OR c)`\n* etc.\n\nThe `not` and `and` operators has higher precedence, and the `or` operator has lower\nprecedence. So `a and b or c` is the same as `(a and b) or c`, and `not a or b`\nis the same as `(not a) or b`.\n\nThe symbols are simple strings, and only the following characters are not considered as\npart of a symbol: parentheses, whitespace, tabs, linebreaks, and other\ninvisible characters. The symbols are **case sensitive**.\n\nWhen rendering, the symbols in the expression are checked against the symbols set\npassed during the \"render\" call. For example, when the `#if foobar` expression\nis executed, it checks if the \"foobar\" string is present on the symbols set.\n\nExamples of supported symbols:\n\n* `#if a`\n* `#if a1`\n* `#if mysymbol`\n* `#if MySymbol`\n* `#if MYSYMBOL`\n* `#if my_symbol`\n* `#if my-symbol`\n* `#if MY_SYMBOL`\n* `#if MY-SYMBOL`\n\nEach of the symbols above is considered a distinct one.\n\nMore exotic symbols such as `$my@symbol!` or `{my[symbol]}?` can work, but it\nis advised to not use them since it may change in the future.\n\nParenthesis in the symbols will produce errors. `#if my(symbol)` is parsed as\n`#if my ( symbol )`, and `DirectiveSyntaxError` will be thrown.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ericvoid/ppdpy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ppdpy",
    "package_url": "https://pypi.org/project/ppdpy/",
    "platform": "",
    "project_url": "https://pypi.org/project/ppdpy/",
    "project_urls": {
      "Homepage": "https://github.com/ericvoid/ppdpy"
    },
    "release_url": "https://pypi.org/project/ppdpy/0.0.1/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Minimal templating using preprocessor directives",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7262988,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3c3f8e49a51186974be17f8a04a46bf371ef4669cb06c5125f5554bb860c96b5",
          "md5": "2a1e05933a53387ea74c0d0960e99e5a",
          "sha256": "6d2d15abb83ece21a47fa0fb553ff99f1a202e5aa5f83049f624dd4de338ecd7"
        },
        "downloads": -1,
        "filename": "ppdpy-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2a1e05933a53387ea74c0d0960e99e5a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 13005,
        "upload_time": "2020-05-17T18:26:59",
        "upload_time_iso_8601": "2020-05-17T18:26:59.573459Z",
        "url": "https://files.pythonhosted.org/packages/3c/3f/8e49a51186974be17f8a04a46bf371ef4669cb06c5125f5554bb860c96b5/ppdpy-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bedf9d26f8a6d081b3b168a37225c9ed1051f7c0720c0a29cd6a5c6e9693bc38",
          "md5": "ce4622eff8408b8375d8f93d557aa389",
          "sha256": "6ffb311e9f2030bec459de41bdc1d1e41a0008e396d1510dbf6fe467b353d5e0"
        },
        "downloads": -1,
        "filename": "ppdpy-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ce4622eff8408b8375d8f93d557aa389",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 14585,
        "upload_time": "2020-05-17T18:27:01",
        "upload_time_iso_8601": "2020-05-17T18:27:01.949872Z",
        "url": "https://files.pythonhosted.org/packages/be/df/9d26f8a6d081b3b168a37225c9ed1051f7c0720c0a29cd6a5c6e9693bc38/ppdpy-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3c3f8e49a51186974be17f8a04a46bf371ef4669cb06c5125f5554bb860c96b5",
        "md5": "2a1e05933a53387ea74c0d0960e99e5a",
        "sha256": "6d2d15abb83ece21a47fa0fb553ff99f1a202e5aa5f83049f624dd4de338ecd7"
      },
      "downloads": -1,
      "filename": "ppdpy-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2a1e05933a53387ea74c0d0960e99e5a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 13005,
      "upload_time": "2020-05-17T18:26:59",
      "upload_time_iso_8601": "2020-05-17T18:26:59.573459Z",
      "url": "https://files.pythonhosted.org/packages/3c/3f/8e49a51186974be17f8a04a46bf371ef4669cb06c5125f5554bb860c96b5/ppdpy-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bedf9d26f8a6d081b3b168a37225c9ed1051f7c0720c0a29cd6a5c6e9693bc38",
        "md5": "ce4622eff8408b8375d8f93d557aa389",
        "sha256": "6ffb311e9f2030bec459de41bdc1d1e41a0008e396d1510dbf6fe467b353d5e0"
      },
      "downloads": -1,
      "filename": "ppdpy-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "ce4622eff8408b8375d8f93d557aa389",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 14585,
      "upload_time": "2020-05-17T18:27:01",
      "upload_time_iso_8601": "2020-05-17T18:27:01.949872Z",
      "url": "https://files.pythonhosted.org/packages/be/df/9d26f8a6d081b3b168a37225c9ed1051f7c0720c0a29cd6a5c6e9693bc38/ppdpy-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}