{
  "info": {
    "author": "Ilan Schnell",
    "author_email": "ilanschnell@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 6 - Mature",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Python Software Foundation License",
      "Operating System :: OS Independent",
      "Programming Language :: C",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Utilities"
    ],
    "description": "bitarray: efficient arrays of booleans\n======================================\n\nThis library provides an object type which efficiently represents an array\nof booleans.  Bitarrays are sequence types and behave very much like usual\nlists.  Eight bits are represented by one byte in a contiguous block of\nmemory.  The user can select between two representations: little-endian\nand big-endian.  All functionality is implemented in C.\nMethods for accessing the machine representation are provided, including the\nability to import and export buffers.  This allows creating bitarrays that\nmapped are to other objects, including memory-mapped files.\n\n\nKey features\n------------\n\n* The bit endianness can be specified for each bitarray object, see below.\n* Sequence methods: slicing (including slice assignment and deletion),\n  operations ``+``, ``*``, ``+=``, ``*=``, the ``in`` operator, ``len()``\n* Fast methods for encoding and decoding variable bit length prefix codes.\n* Bitwise operations: ``~``, ``&``, ``|``, ``^``, ``<<``, ``>>`` (as well as\n  their in-place versions ``&=``, ``|=``, ``^=``, ``<<=``, ``>>=``).\n* Packing and unpacking to other binary data formats, e.g. ``numpy.ndarray``.\n* Bitarray objects support the buffer protocol (both importing and\n  exporting buffers).\n* ``frozenbitarray`` objects which are hashable\n* Pickling and unpickling of bitarray objects.\n* Sequential search\n* Extensive test suite with over 400 unittests.\n* Utility module ``bitarray.util``:\n\n  * conversion to hexadecimal string\n  * serialization\n  * pretty printing\n  * conversion to integers\n  * creating Huffman codes\n  * various count functions\n  * other helpful functions\n\n\nInstallation\n------------\n\nIf you have a working C compiler, you can simply:\n\n.. code-block:: shell-session\n\n    $ pip install bitarray\n\nIf you rather want to use precompiled binaries, you can:\n\n* ``conda install bitarray`` (both the default Anaconda repository as well\n  as conda-forge support bitarray)\n* download Windows wheels from\n  `Chris Gohlke <https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray>`__\n\nOnce you have installed the package, you may want to test it:\n\n.. code-block:: shell-session\n\n    $ python -c 'import bitarray; bitarray.test()'\n    bitarray is installed in: /Users/ilan/bitarray/bitarray\n    bitarray version: 2.3.4\n    sys.version: 2.7.15 (default, Mar  5 2020, 14:58:04) [GCC Clang 9.0.1]\n    sys.prefix: /Users/ilan/Mini3/envs/py27\n    pointer size: 64 bit\n    sizeof(size_t): 8\n    sizeof(bitarrayobject): 80\n    PY_UINT64_T defined: 1\n    DEBUG: 0\n    .........................................................................\n    .........................................................................\n    ................................................................\n    ----------------------------------------------------------------------\n    Ran 407 tests in 0.483s\n\n    OK\n\nYou can always import the function test,\nand ``test().wasSuccessful()`` will return ``True`` when the test went well.\n\n\nUsing the module\n----------------\n\nAs mentioned above, bitarray objects behave very much like lists, so\nthere is not too much to learn.  The biggest difference from list\nobjects (except that bitarray are obviously homogeneous) is the ability\nto access the machine representation of the object.\nWhen doing so, the bit endianness is of importance; this issue is\nexplained in detail in the section below.  Here, we demonstrate the\nbasic usage of bitarray objects:\n\n.. code-block:: python\n\n    >>> from bitarray import bitarray\n    >>> a = bitarray()         # create empty bitarray\n    >>> a.append(1)\n    >>> a.extend([1, 0])\n    >>> a\n    bitarray('110')\n    >>> x = bitarray(2 ** 20)  # bitarray of length 1048576 (uninitialized)\n    >>> len(x)\n    1048576\n    >>> bitarray('1001 011')   # initialize from string (whitespace is ignored)\n    bitarray('1001011')\n    >>> lst = [1, 0, False, True, True]\n    >>> a = bitarray(lst)      # initialize from iterable\n    >>> a\n    bitarray('10011')\n    >>> a.count(1)\n    3\n    >>> a.remove(0)            # removes first occurrence of 0\n    >>> a\n    bitarray('1011')\n\nLike lists, bitarray objects support slice assignment and deletion:\n\n.. code-block:: python\n\n    >>> a = bitarray(50)\n    >>> a.setall(0)            # set all elements in a to 0\n    >>> a[11:37:3] = 9 * bitarray('1')\n    >>> a\n    bitarray('00000000000100100100100100100100100100000000000000')\n    >>> del a[12::3]\n    >>> a\n    bitarray('0000000000010101010101010101000000000')\n    >>> a[-6:] = bitarray('10011')\n    >>> a\n    bitarray('000000000001010101010101010100010011')\n    >>> a += bitarray('000111')\n    >>> a[9:]\n    bitarray('001010101010101010100010011000111')\n\nIn addition, slices can be assigned to booleans, which is easier (and\nfaster) than assigning to a bitarray in which all values are the same:\n\n.. code-block:: python\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = True\n    >>> a\n    bitarray('01001001001001000000')\n\nThis is easier and faster than:\n\n.. code-block:: python\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = 5 * bitarray('1')\n    >>> a\n    bitarray('01001001001001000000')\n\nNote that in the latter we have to create a temporary bitarray whose length\nmust be known or calculated.  Another example of assigning slices to Booleans,\nis setting ranges:\n\n.. code-block:: python\n\n    >>> a = bitarray(30)\n    >>> a[:] = 0         # set all elements to 0 - equivalent to a.setall(0)\n    >>> a[10:25] = 1     # set elements in range(10, 25) to 1\n    >>> a\n    bitarray('000000000011111111111111100000')\n\n\nBitwise operators\n-----------------\n\nBitarray objects support the bitwise operators ``~``, ``&``, ``|``, ``^``,\n``<<``, ``>>`` (as well as their in-place versions ``&=``, ``|=``, ``^=``,\n``<<=``, ``>>=``).  The behavior is very much what one would expect:\n\n.. code-block:: python\n\n    >>> a = bitarray('101110001')\n    >>> ~a  # invert\n    bitarray('010001110')\n    >>> b = bitarray('111001011')\n    >>> a ^ b\n    bitarray('010111010')\n    >>> a &= b\n    >>> a\n    bitarray('101000001')\n    >>> a <<= 2\n    >>> a\n    bitarray('100000100')\n    >>> b >> 1\n    bitarray('011100101')\n\nThe C language does not specify the behavior of negative shifts and\nof left shifts larger or equal than the width of the promoted left operand.\nThe exact behavior is compiler/machine specific.\nThis Python bitarray library specifies the behavior as follows:\n\n* the length of the bitarray is never changed by any shift operation\n* blanks are filled by 0\n* negative shifts raise ``ValueError``\n* shifts larger or equal to the length of the bitarray result in\n  bitarrays with all values 0\n\n\nBit endianness\n--------------\n\nUnless explicitly converting to machine representation, using\nthe ``.tobytes()``, ``.frombytes()``, ``.tofile()`` and ``.fromfile()``\nmethods, as well as using ``memoryview``, the bit endianness will have no\neffect on any computation, and one can skip this section.\n\nSince bitarrays allows addressing individual bits, where the machine\nrepresents 8 bits in one byte, there are two obvious choices for this\nmapping: little-endian and big-endian.\n\nWhen dealing with the machine representation of bitarray objects, it is\nrecommended to always explicitly specify the endianness.\n\nBy default, bitarrays use big-endian representation:\n\n.. code-block:: python\n\n    >>> a = bitarray()\n    >>> a.endian()\n    'big'\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('01000001')\n    >>> a[6] = 1\n    >>> a.tobytes()\n    b'C'\n\nBig-endian means that the most-significant bit comes first.\nHere, ``a[0]`` is the lowest address (index) and most significant bit,\nand ``a[7]`` is the highest address and least significant bit.\n\nWhen creating a new bitarray object, the endianness can always be\nspecified explicitly:\n\n.. code-block:: python\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('10000010')\n    >>> a.endian()\n    'little'\n\nHere, the low-bit comes first because little-endian means that increasing\nnumeric significance corresponds to an increasing address.\nSo ``a[0]`` is the lowest address and least significant bit,\nand ``a[7]`` is the highest address and most significant bit.\n\nThe bit endianness is a property of the bitarray object.\nThe endianness cannot be changed once a bitarray object is created.\nWhen comparing bitarray objects, the endianness (and hence the machine\nrepresentation) is irrelevant; what matters is the mapping from indices\nto bits:\n\n.. code-block:: python\n\n    >>> bitarray('11001', endian='big') == bitarray('11001', endian='little')\n    True\n\nBitwise operations (``|``, ``^``, ``&=``, ``|=``, ``^=``, ``~``) are\nimplemented efficiently using the corresponding byte operations in C, i.e. the\noperators act on the machine representation of the bitarray objects.\nTherefore, it is not possible to perform bitwise operators on bitarrays\nwith different endianness.\n\nWhen converting to and from machine representation, using\nthe ``.tobytes()``, ``.frombytes()``, ``.tofile()`` and ``.fromfile()``\nmethods, the endianness matters:\n\n.. code-block:: python\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'\\x01')\n    >>> a\n    bitarray('10000000')\n    >>> b = bitarray(endian='big')\n    >>> b.frombytes(b'\\x80')\n    >>> b\n    bitarray('10000000')\n    >>> a == b\n    True\n    >>> a.tobytes() == b.tobytes()\n    False\n\nAs mentioned above, the endianness can not be changed once an object is\ncreated.  However, you can create a new bitarray with different endianness:\n\n.. code-block:: python\n\n    >>> a = bitarray('111000', endian='little')\n    >>> b = bitarray(a, endian='big')\n    >>> b\n    bitarray('111000')\n    >>> a == b\n    True\n\n\nBuffer protocol\n---------------\n\nBitarray objects support the buffer protocol.  They can both export their\nown buffer, as well as import another object's buffer.  To learn more about\nthis topic, please read `buffer protocol <https://github.com/ilanschnell/bitarray/blob/master/doc/buffer.rst>`__.  There is also an example that shows how\nto memory-map a file to a bitarray: `mmapped-file.py <https://github.com/ilanschnell/bitarray/blob/master/examples/mmapped-file.py>`__\n\n\nVariable bit length prefix codes\n--------------------------------\n\nThe ``.encode()`` method takes a dictionary mapping symbols to bitarrays\nand an iterable, and extends the bitarray object with the encoded symbols\nfound while iterating.  For example:\n\n.. code-block:: python\n\n    >>> d = {'H':bitarray('111'), 'e':bitarray('0'),\n    ...      'l':bitarray('110'), 'o':bitarray('10')}\n    ...\n    >>> a = bitarray()\n    >>> a.encode(d, 'Hello')\n    >>> a\n    bitarray('111011011010')\n\nNote that the string ``'Hello'`` is an iterable, but the symbols are not\nlimited to characters, in fact any immutable Python object can be a symbol.\nTaking the same dictionary, we can apply the ``.decode()`` method which will\nreturn a list of the symbols:\n\n.. code-block:: python\n\n    >>> a.decode(d)\n    ['H', 'e', 'l', 'l', 'o']\n    >>> ''.join(a.decode(d))\n    'Hello'\n\nSince symbols are not limited to being characters, it is necessary to return\nthem as elements of a list, rather than simply returning the joined string.\nThe above dictionary ``d`` can be efficiently constructed using the function\n``bitarray.util.huffman_code()``.  I also wrote `Huffman coding in Python\nusing bitarray <http://ilan.schnell-web.net/prog/huffman/>`__ for more\nbackground information.\n\nWhen the codes are large, and you have many decode calls, most time will\nbe spent creating the (same) internal decode tree objects.  In this case,\nit will be much faster to create a ``decodetree`` object, which can be\npassed to bitarray's ``.decode()`` and ``.iterdecode()`` methods, instead\nof passing the prefix code dictionary to those methods itself:\n\n.. code-block:: python\n\n    >>> from bitarray import bitarray, decodetree\n    >>> t = decodetree({'a': bitarray('0'), 'b': bitarray('1')})\n    >>> a = bitarray('0110')\n    >>> a.decode(t)\n    ['a', 'b', 'b', 'a']\n    >>> ''.join(a.iterdecode(t))\n    'abba'\n\nThe ``decodetree`` object is immutable and unhashable, and it's sole purpose\nis to be passed to bitarray's `.decode()` and `.iterdecode()` methods.\n\n\nFrozenbitarrays\n---------------\n\nA ``frozenbitarray`` object is very similar to the bitarray object.\nThe difference is that this a ``frozenbitarray`` is immutable, and hashable,\nand can therefore be used as a dictionary key:\n\n.. code-block:: python\n\n    >>> from bitarray import frozenbitarray\n    >>> key = frozenbitarray('1100011')\n    >>> {key: 'some value'}\n    {frozenbitarray('1100011'): 'some value'}\n    >>> key[3] = 1\n    Traceback (most recent call last):\n        ...\n    TypeError: frozenbitarray is immutable\n\n\nReference\n=========\n\nbitarray version: 2.3.4 -- `change log <https://github.com/ilanschnell/bitarray/blob/master/doc/changelog.rst>`__\n\nIn the following, ``item`` and ``value`` are usually a single bit -\nan integer 0 or 1.\n\n\nThe bitarray object:\n--------------------\n\n``bitarray(initializer=0, /, endian='big', buffer=None)`` -> bitarray\n   Return a new bitarray object whose items are bits initialized from\n   the optional initial object, and endianness.\n   The initializer may be of the following types:\n\n   ``int``: Create a bitarray of given integer length.  The initial values are\n   uninitialized.\n\n   ``str``: Create bitarray from a string of ``0`` and ``1``.\n\n   ``iterable``: Create bitarray from iterable or sequence or integers 0 or 1.\n\n   Optional keyword arguments:\n\n   ``endian``: Specifies the bit endianness of the created bitarray object.\n   Allowed values are ``big`` and ``little`` (the default is ``big``).\n   The bit endianness effects the buffer representation of the bitarray.\n\n   ``buffer``: Any object which exposes a buffer.  When provided, ``initializer``\n   cannot be present (or has to be ``None``).  The imported buffer may be\n   readonly or writable, depending on the object type.\n\n   New in version 2.3: optional ``buffer`` argument.\n\n\n**A bitarray object supports the following methods:**\n\n``all()`` -> bool\n   Return True when all bits in the array are True.\n   Note that ``a.all()`` is faster than ``all(a)``.\n\n\n``any()`` -> bool\n   Return True when any bit in the array is True.\n   Note that ``a.any()`` is faster than ``any(a)``.\n\n\n``append(item, /)``\n   Append ``item`` to the end of the bitarray.\n\n\n``buffer_info()`` -> tuple\n   Return a tuple containing:\n\n   0. memory address of buffer\n   1. buffer size (in bytes)\n   2. bit endianness as a string\n   3. number of unused padding bits\n   4. allocated memory for the buffer (in bytes)\n   5. memory is read-only\n   6. buffer is imported\n   7. number of buffer exports\n\n\n``bytereverse(start=0, stop=<end of buffer>, /)``\n   Reverse the bit order for the bytes in range(start, stop) in-place.\n   The start and stop indices are given in terms of bytes (not bits).\n   By default, all bytes in the buffer are reversed.\n   Note: This method only changes the buffer; it does not change the\n   endianness of the bitarray object.\n\n   New in version 2.2.5: optional ``start`` and ``stop`` arguments.\n\n\n``clear()``\n   Remove all items from the bitarray.\n\n   New in version 1.4.\n\n\n``copy()`` -> bitarray\n   Return a copy of the bitarray.\n\n\n``count(value=1, start=0, stop=<end of array>, /)`` -> int\n   Count the number of occurrences of ``value`` in the bitarray.\n\n   New in version 1.1.0: optional ``start`` and ``stop`` arguments.\n\n\n``decode(code, /)`` -> list\n   Given a prefix code (a dict mapping symbols to bitarrays, or ``decodetree``\n   object), decode the content of the bitarray and return it as a list of\n   symbols.\n\n\n``encode(code, iterable, /)``\n   Given a prefix code (a dict mapping symbols to bitarrays),\n   iterate over the iterable object with symbols, and extend the bitarray\n   with the corresponding bitarray for each symbol.\n\n\n``endian()`` -> str\n   Return the bit endianness of the bitarray as a string (``little`` or ``big``).\n\n\n``extend(iterable, /)``\n   Append all items from ``iterable`` to the end of the bitarray.\n   If the iterable is a string, each ``0`` and ``1`` are appended as\n   bits (ignoring whitespace and underscore).\n\n\n``fill()`` -> int\n   Add zeros to the end of the bitarray, such that the length of the bitarray\n   will be a multiple of 8, and return the number of bits added (0..7).\n\n\n``find(sub_bitarray, start=0, stop=<end of array>, /)`` -> int\n   Return the lowest index where sub_bitarray is found, such that sub_bitarray\n   is contained within ``[start:stop]``.\n   Return -1 when sub_bitarray is not found.\n\n   New in version 2.1.\n\n\n``frombytes(bytes, /)``\n   Extend bitarray with raw bytes.  That is, each append byte will add eight\n   bits to the bitarray.\n\n\n``fromfile(f, n=-1, /)``\n   Extend bitarray with up to n bytes read from the file object f.\n   When n is omitted or negative, reads all data until EOF.\n   When n is provided and positive but exceeds the data available,\n   ``EOFError`` is raised (but the available data is still read and appended.\n\n\n``index(sub_bitarray, start=0, stop=<end of array>, /)`` -> int\n   Return the lowest index where sub_bitarray is found, such that sub_bitarray\n   is contained within ``[start:stop]``.\n   Raises ``ValueError`` when the sub_bitarray is not present.\n\n\n``insert(index, value, /)``\n   Insert ``value`` into the bitarray before ``index``.\n\n\n``invert(index=<all bits>, /)``\n   Invert all bits in the array (in-place).\n   When the optional ``index`` is given, only invert the single bit at index.\n\n   New in version 1.5.3: optional ``index`` argument.\n\n\n``iterdecode(code, /)`` -> iterator\n   Given a prefix code (a dict mapping symbols to bitarrays, or ``decodetree``\n   object), decode the content of the bitarray and return an iterator over\n   the symbols.\n\n\n``itersearch(sub_bitarray, /)`` -> iterator\n   Searches for the given sub_bitarray in self, and return an iterator over\n   the start positions where bitarray matches self.\n\n\n``pack(bytes, /)``\n   Extend the bitarray from bytes, where each byte corresponds to a single\n   bit.  The byte ``b'\\x00'`` maps to bit 0 and all other characters map to\n   bit 1.\n   This method, as well as the unpack method, are meant for efficient\n   transfer of data between bitarray objects to other python objects\n   (for example NumPy's ndarray object) which have a different memory view.\n\n\n``pop(index=-1, /)`` -> item\n   Return the i-th (default last) element and delete it from the bitarray.\n   Raises ``IndexError`` if bitarray is empty or index is out of range.\n\n\n``remove(value, /)``\n   Remove the first occurrence of ``value`` in the bitarray.\n   Raises ``ValueError`` if item is not present.\n\n\n``reverse()``\n   Reverse all bits in the array (in-place).\n\n\n``search(sub_bitarray, limit=<none>, /)`` -> list\n   Searches for the given sub_bitarray in self, and return the list of start\n   positions.\n   The optional argument limits the number of search results to the integer\n   specified.  By default, all search results are returned.\n\n\n``setall(value, /)``\n   Set all elements in the bitarray to ``value``.\n   Note that ``a.setall(value)`` is equivalent to ``a[:] = value``.\n\n\n``sort(reverse=False)``\n   Sort the bits in the array (in-place).\n\n\n``to01()`` -> str\n   Return a string containing '0's and '1's, representing the bits in the\n   bitarray.\n\n\n``tobytes()`` -> bytes\n   Return the byte representation of the bitarray.\n\n\n``tofile(f, /)``\n   Write the byte representation of the bitarray to the file object f.\n\n\n``tolist()`` -> list\n   Return a list with the items (0 or 1) in the bitarray.\n   Note that the list object being created will require 32 or 64 times more\n   memory (depending on the machine architecture) than the bitarray object,\n   which may cause a memory error if the bitarray is very large.\n\n\n``unpack(zero=b'\\x00', one=b'\\x01')`` -> bytes\n   Return bytes containing one character for each bit in the bitarray,\n   using the specified mapping.\n\n\nOther objects:\n--------------\n\n``frozenbitarray(initializer=0, /, endian='big', buffer=None)`` -> frozenbitarray\n   Return a frozenbitarray object, which is initialized the same way a bitarray\n   object is initialized.  A frozenbitarray is immutable and hashable.\n   Its contents cannot be altered after it is created; however, it can be used\n   as a dictionary key.\n\n   New in version 1.1.\n\n\n``decodetree(code, /)`` -> decodetree\n   Given a prefix code (a dict mapping symbols to bitarrays),\n   create a binary tree object to be passed to ``.decode()`` or ``.iterdecode()``.\n\n   New in version 1.6.\n\n\nFunctions defined in the `bitarray` module:\n-------------------------------------------\n\n``bits2bytes(n, /)`` -> int\n   Return the number of bytes necessary to store n bits.\n\n\n``get_default_endian()`` -> string\n   Return the default endianness for new bitarray objects being created.\n   Unless ``_set_default_endian()`` is called, the return value is ``big``.\n\n   New in version 1.3.\n\n\n``test(verbosity=1, repeat=1)`` -> TextTestResult\n   Run self-test, and return unittest.runner.TextTestResult object.\n\n\nFunctions defined in `bitarray.util` module:\n--------------------------------------------\n\nThis sub-module was add in version 1.2.\n\n``zeros(length, /, endian=None)`` -> bitarray\n   Create a bitarray of length, with all values 0, and optional\n   endianness, which may be 'big', 'little'.\n\n\n``urandom(length, /, endian=None)`` -> bitarray\n   Return a bitarray of ``length`` random bits (uses ``os.urandom``).\n\n   New in version 1.7.\n\n\n``pprint(bitarray, /, stream=None, group=8, indent=4, width=80)``\n   Prints the formatted representation of object on ``stream``, followed by a\n   newline.  If ``stream`` is ``None``, ``sys.stdout`` is used.  By default, elements\n   are grouped in bytes (8 elements), and 8 bytes (64 elements) per line.\n   Non-bitarray objects are printed by the standard library\n   function ``pprint.pprint()``.\n\n   New in version 1.8.\n\n\n``make_endian(bitarray, /, endian)`` -> bitarray\n   When the endianness of the given bitarray is different from ``endian``,\n   return a new bitarray, with endianness ``endian`` and the same elements\n   as the original bitarray.\n   Otherwise (endianness is already ``endian``) the original bitarray is returned\n   unchanged.\n\n   New in version 1.3.\n\n\n``rindex(bitarray, value=1, start=0, stop=<end of array>, /)`` -> int\n   Return the rightmost (highest) index of ``value`` in bitarray.\n   Raises ``ValueError`` if the value is not present.\n\n   New in version 2.3.0: optional ``start`` and ``stop`` arguments.\n\n\n``strip(bitarray, /, mode='right')`` -> bitarray\n   Return a new bitarray with zeros stripped from left, right or both ends.\n   Allowed values for mode are the strings: ``left``, ``right``, ``both``\n\n\n``count_n(a, n, /)`` -> int\n   Return lowest index ``i`` for which ``a[:i].count() == n``.\n   Raises ``ValueError``, when n exceeds total count (``a.count()``).\n\n\n``parity(a, /)`` -> int\n   Return the parity of bitarray ``a``.\n   This is equivalent to ``a.count() % 2`` (but more efficient).\n\n   New in version 1.9.\n\n\n``count_and(a, b, /)`` -> int\n   Return ``(a & b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n\n``count_or(a, b, /)`` -> int\n   Return ``(a | b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n\n``count_xor(a, b, /)`` -> int\n   Return ``(a ^ b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n\n``subset(a, b, /)`` -> bool\n   Return ``True`` if bitarray ``a`` is a subset of bitarray ``b``.\n   ``subset(a, b)`` is equivalent to ``(a & b).count() == a.count()`` but is more\n   efficient since we can stop as soon as one mismatch is found, and no\n   intermediate bitarray object gets created.\n\n\n``ba2hex(bitarray, /)`` -> hexstr\n   Return a string containing the hexadecimal representation of\n   the bitarray (which has to be multiple of 4 in length).\n\n\n``hex2ba(hexstr, /, endian=None)`` -> bitarray\n   Bitarray of hexadecimal representation.  hexstr may contain any number\n   (including odd numbers) of hex digits (upper or lower case).\n\n\n``ba2base(n, bitarray, /)`` -> str\n   Return a string containing the base ``n`` ASCII representation of\n   the bitarray.  Allowed values for ``n`` are 2, 4, 8, 16, 32 and 64.\n   The bitarray has to be multiple of length 1, 2, 3, 4, 5 or 6 respectively.\n   For ``n=16`` (hexadecimal), ``ba2hex()`` will be much faster, as ``ba2base()``\n   does not take advantage of byte level operations.\n   For ``n=32`` the RFC 4648 Base32 alphabet is used, and for ``n=64`` the\n   standard base 64 alphabet is used.\n\n   See also: `Bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   New in version 1.9.\n\n\n``base2ba(n, asciistr, /, endian=None)`` -> bitarray\n   Bitarray of the base ``n`` ASCII representation.\n   Allowed values for ``n`` are 2, 4, 8, 16, 32 and 64.\n   For ``n=16`` (hexadecimal), ``hex2ba()`` will be much faster, as ``base2ba()``\n   does not take advantage of byte level operations.\n   For ``n=32`` the RFC 4648 Base32 alphabet is used, and for ``n=64`` the\n   standard base 64 alphabet is used.\n\n   See also: `Bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   New in version 1.9.\n\n\n``ba2int(bitarray, /, signed=False)`` -> int\n   Convert the given bitarray to an integer.\n   The bit-endianness of the bitarray is respected.\n   ``signed`` indicates whether two's complement is used to represent the integer.\n\n\n``int2ba(int, /, length=None, endian=None, signed=False)`` -> bitarray\n   Convert the given integer to a bitarray (with given endianness,\n   and no leading (big-endian) / trailing (little-endian) zeros), unless\n   the ``length`` of the bitarray is provided.  An ``OverflowError`` is raised\n   if the integer is not representable with the given number of bits.\n   ``signed`` determines whether two's complement is used to represent the integer,\n   and requires ``length`` to be provided.\n\n\n``serialize(bitarray, /)`` -> bytes\n   Return a serialized representation of the bitarray, which may be passed to\n   ``deserialize()``.  It efficiently represents the bitarray object (including\n   its endianness) and is guaranteed not to change in future releases.\n\n   See also: `Bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   New in version 1.8.\n\n\n``deserialize(bytes, /)`` -> bitarray\n   Return a bitarray given the bytes representation returned by ``serialize()``.\n\n   See also: `Bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   New in version 1.8.\n\n\n``vl_encode(bitarray, /)`` -> bytes\n   Return variable length binary representation of bitarray.\n   This representation is useful for efficiently storing small bitarray\n   in a binary stream.  Use ``vl_decode()`` for decoding.\n\n   See also: `Variable length bitarray format <https://github.com/ilanschnell/bitarray/blob/master/doc/variable_length.rst>`__\n\n   New in version 2.2.\n\n\n``vl_decode(stream, /, endian=None)`` -> bitarray\n   Decode binary stream (an integer iterator, or bytes object), and return\n   the decoded bitarray.  This function consumes only one bitarray and leaves\n   the remaining stream untouched.  ``StopIteration`` is raised when no\n   terminating byte is found.\n   Use ``vl_encode()`` for encoding.\n\n   See also: `Variable length bitarray format <https://github.com/ilanschnell/bitarray/blob/master/doc/variable_length.rst>`__\n\n   New in version 2.2.\n\n\n``huffman_code(dict, /, endian=None)`` -> dict\n   Given a frequency map, a dictionary mapping symbols to their frequency,\n   calculate the Huffman code, i.e. a dict mapping those symbols to\n   bitarrays (with given endianness).  Note that the symbols are not limited\n   to being strings.  Symbols may may be any hashable object (such as ``None``).\n\n\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ilanschnell/bitarray",
    "keywords": "",
    "license": "PSF",
    "maintainer": "",
    "maintainer_email": "",
    "name": "bitarray-binary",
    "package_url": "https://pypi.org/project/bitarray-binary/",
    "platform": "",
    "project_url": "https://pypi.org/project/bitarray-binary/",
    "project_urls": {
      "Homepage": "https://github.com/ilanschnell/bitarray"
    },
    "release_url": "https://pypi.org/project/bitarray-binary/2.3.4/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "pre-build version of bitarray: efficient arrays of booleans -- C extension",
    "version": "2.3.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12196713,
  "releases": {
    "2.3.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0fa31ff9404c29311521988e4e95db79f7383dae4ab81e9d9f41b3afbfd1bb13",
          "md5": "935e037df4e151f12f6421b446511af8",
          "sha256": "87e2bf51952690b45928aaab36a11deb82210f7eac58b70e284764d2d62df52c"
        },
        "downloads": -1,
        "filename": "bitarray_binary-2.3.4-cp38-cp38-manylinux1_x86_64.whl",
        "has_sig": false,
        "md5_digest": "935e037df4e151f12f6421b446511af8",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 188723,
        "upload_time": "2021-12-03T01:25:27",
        "upload_time_iso_8601": "2021-12-03T01:25:27.047757Z",
        "url": "https://files.pythonhosted.org/packages/0f/a3/1ff9404c29311521988e4e95db79f7383dae4ab81e9d9f41b3afbfd1bb13/bitarray_binary-2.3.4-cp38-cp38-manylinux1_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0fa31ff9404c29311521988e4e95db79f7383dae4ab81e9d9f41b3afbfd1bb13",
        "md5": "935e037df4e151f12f6421b446511af8",
        "sha256": "87e2bf51952690b45928aaab36a11deb82210f7eac58b70e284764d2d62df52c"
      },
      "downloads": -1,
      "filename": "bitarray_binary-2.3.4-cp38-cp38-manylinux1_x86_64.whl",
      "has_sig": false,
      "md5_digest": "935e037df4e151f12f6421b446511af8",
      "packagetype": "bdist_wheel",
      "python_version": "cp38",
      "requires_python": null,
      "size": 188723,
      "upload_time": "2021-12-03T01:25:27",
      "upload_time_iso_8601": "2021-12-03T01:25:27.047757Z",
      "url": "https://files.pythonhosted.org/packages/0f/a3/1ff9404c29311521988e4e95db79f7383dae4ab81e9d9f41b3afbfd1bb13/bitarray_binary-2.3.4-cp38-cp38-manylinux1_x86_64.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}