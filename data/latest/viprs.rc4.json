{
  "info": {
    "author": "Shadi Zabad",
    "author_email": "shadi.zabad@mail.mcgill.ca",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Topic :: Scientific/Engineering",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# `viprs`: Variational Inference of Polygenic Risk Scores\n\n[![PyPI pyversions](https://img.shields.io/pypi/pyversions/viprs.svg)](https://pypi.python.org/pypi/viprs/)\n[![PyPI version fury.io](https://badge.fury.io/py/viprs.svg)](https://pypi.python.org/pypi/viprs/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n`viprs` is a python package that implements scripts and utilities for running variational inference \nalgorithms on genome-wide association study (GWAS) data for the purposes polygenic risk estimation. \n\nHighlighted features:\n\n- The coordinate ascent algorithms are written in `cython` for improved speed and efficiency.\n- The code is written in object-oriented form, allowing the user to extend and experiment with existing implementations.\n- We provide scripts for fitting the model with different priors on the effect size: `VIPRSAlpha`, `VIPRSMix`, etc.\n- We also provide scripts for different hyperparameter tuning strategies, including: Grid search, Bayesian optimization, Bayesian model averaging.\n\n**NOTE**: The codebase is still in active development and some of interfaces or data structures will be \nreplaced or modified in future releases.\n\n## Table of Contents\n\n- [Installation](#Installation)\n- [Getting started](#getting-started)\n- [Features and Configurations](#features-and-configurations)\n  - [(1) Evaluating `viprs` with training and test data](#1-evaluating-viprs-with-training-and-test-data)\n  - [(2) Grid search and validation](#2-grid-search-and-validation)\n- [Commandline scripts](#commandline-scripts)\n- [Download LD matrices](#download-ld-matrices)\n- [Frequently Asked Questions (FAQs)](#frequently-asked-questions-faqs)\n- [Citations](#citations) \n\n\n## Installation\n\n`viprs` is now available on the python package index `pypi` and \ncan be minimally installed using the package installer `pip`:\n\n```shell\npip install viprs\n```\n\nTo access the full functionalities of `viprs`, however, it is recommended that \nyou install the full list of dependencies:\n\n```shell\npip install viprs[full]\n```\n\nTo use `viprs` on a shared computing cluster, we recommend installing it in a \n`python` virtual environment. For example:\n\n```shell\nmodule load python/3.8\npython -m venv viprs_env\nsource viprs_env/bin/activate\npip install --upgrade pip\npip install viprs\n```\n\nFinally, if you wish to install the package from source, \nyou can directly clone the GitHub repository and install it locally \nas follows:\n\n```\ngit clone https://github.com/shz9/viprs.git\ncd viprs\nmake install\n```\n\n## Getting started\n\n`viprs` is a `python` package for fitting Bayesian Polygenic Risk Score (PRS) models to summary statistics \nderived from Genome-wide Association Studies (GWASs). To showcase the interfaces and functionalities of the package \nas well as the data structures that power it, we will start with a simple example. \n\nGenerally, summary statistics-based PRS methods require access to **(1)** GWAS summary statistics for the \ntrait of interest and **(2)** Linkage-Disequilibrium (LD) matrices from an appropriately-matched reference panel (e.g. \nthe 1000G dataset). For the first item, we will use summary statistics for standing height from the `fastGWA` catalogue. \nFor the second item, we will use genotype data on chromosome 22 for a subset of 378 European samples from the \n1000G project. This small dataset is shipped with the python package `magenpy`.\n\nTo start, let's import the required `python` modules:\n\n```python\nimport magenpy as mgp\nimport viprs as vp\n```\n\nThen, we will use `magenpy` to read the 1000G genotype dataset and *automatically* match it with the GWAS \nsummary statistics from `fastGWA`:\n\n```python\n# Load genotype and GWAS summary statistics data (chromosome 22):\ngdl = mgp.GWADataLoader(bed_files=mgp.tgp_eur_data_path(),\n                        sumstats_files=mgp.ukb_height_fastGWA_path(),\n                        sumstats_format=\"fastGWA\")\n```\n\nOnce the genotype and summary statistics data are read by `magenpy`, we can go ahead and compute \nthe LD (or SNP-by-SNP correlation) matrix:\n\n```python\n# Compute LD using the shrinkage estimator (Wen and Stephens 2010):\ngdl.compute_ld(\"shrinkage\",\n               output_dir=\"temp\",\n               genetic_map_ne=11400, # effective population size (Ne)\n               genetic_map_sample_size=183,\n               threshold=1e-3)\n```\n\nBecause of the small sample size of the reference panel, here we recommend using the `shrinkage` estimator \nfor LD from Wen and Stephens (2010). The shrinkage estimator results in compact and sparse LD matrices that are \nmore robust than the sample LD. The estimator requires access to information about the genetic map, such as \nthe position of each SNP in centi Morgan, the effective population size, and the sample size used to \nestimate the genetic map.\n\nGiven the LD information from the reference panel, we can next fit the VIPRS model to the summary statistics data:\n\n```python\n# Initialize VIPRS, passing it the GWADataLoader object\nv = vp.VIPRS(gdl)\n# Invoke the .fit() method to obtain posterior estimates\nv.fit()\n```\n\nOnce the model converges, we can generate PRS estimates for height for the 1000G samples by simply \ninvoking the `.predict()` method:\n\n```python\nv.predict()\n# array([ 0.01944202,  0.00597704,  0.07329462, ..., 0.06666187,  0.05251297,  0.00359018])\n```\n\nTo examine posterior estimates for the model parameters, you can simply invoke the `.to_table()` method:\n\n```python\nv.to_table()\n#       CHR         SNP A1 A2       PIP          BETA      VAR_BETA\n# 0       22    rs131538  A  G  0.006107 -5.955517e-06  1.874619e-08\n# 1       22   rs9605903  C  T  0.005927  5.527188e-06  1.774252e-08\n# 2       22   rs5746647  G  T  0.005015  1.194178e-07  1.120063e-08\n# 3       22  rs16980739  T  C  0.008331 -1.335695e-05  3.717944e-08\n# 4       22   rs9605923  A  T  0.006181  6.334971e-06  1.979157e-08\n# ...    ...         ... .. ..       ...           ...           ...\n# 15930   22   rs8137951  A  G  0.006367 -6.880591e-06  2.059650e-08\n# 15931   22   rs2301584  A  G  0.179406 -7.234545e-04  2.597197e-06\n# 15932   22   rs3810648  G  A  0.008000  1.222151e-05  3.399927e-08\n# 15933   22   rs2285395  A  G  0.005356  3.004282e-06  1.349082e-08\n# 15934   22  rs28729663  A  G  0.005350 -2.781053e-06  1.351239e-08\n#\n# [15935 rows x 7 columns]\n```\n\nHere, `PIP` is the **P**osterior **I**nclusion **P**robability under the variational density, while \n`BETA` and `VAR_BETA` are the posterior mean and variance for the effect size, respectively. \nFor the purposes of prediction, we only need the `BETA` column. You can also examine the \ninferred hyperparameters of the model by invoking the `.to_theta_table()` method:\n\n```python\nv.to_theta_table()\n#           Parameter     Value\n# 0  Residual_variance  0.994231\n# 1       Heritability  0.005736\n# 2  Proportion_causal  0.015887\n# 3         sigma_beta  0.000021\n```\n\nNote that here, the SNP heritability only considers the contribution of variants on \nchromosome 22.\n\n## Features and Configurations \n\n### (1) Evaluating `viprs` with training and test data\n\nHere, we will go through an artificial example on simulated \nphenotypes using a subset of 387 individuals from the 1000 Genomes dataset. To begin, let's use the python \npackage `magenpy` to simulate a quantitative trait where 1% of the variants \nare causal and the SNP heritability set to `0.8`:\n\n```python\ng_sim = mgp.GWASimulator(mgp.tgp_eur_data_path(),\n                         pi=(.99, .01),\n                         h2=0.8)\ng_sim.simulate()\ng_sim.to_phenotype_table()\n#          FID      IID  phenotype\n# 0    HG00096  HG00096  -1.787443\n# 1    HG00097  HG00097   0.282521\n# 2    HG00099  HG00099   0.532999\n# 3    HG00100  HG00100   0.781203\n# 4    HG00101  HG00101   0.081900\n# ..       ...      ...        ...\n# 373  NA20815  NA20815   0.898588\n# 374  NA20818  NA20818   1.549989\n# 375  NA20819  NA20819  -0.259188\n# 376  NA20826  NA20826  -0.044187\n# 377  NA20828  NA20828   2.254222\n#\n# [378 rows x 3 columns]\n```\n\nTo obtain a realistic setting where the training data is separate from the test data, next we are going to \nrandomly split the samples into 80% training and 20% testing:\n\n```python\ntraining_gdl, test_gdl = g_sim.split_by_samples(proportions=[.8, .2])\nprint(\"Number of training samples:\", training_gdl.sample_size)\n# Number of training samples: 314\nprint(\"Number of test samples:\", test_gdl.sample_size)\n# Number of test samples: 64\n```\n\nUsing the training data, we will compute LD matrices and perform GWAS \non the simulated phenotype:\n\n```python\n# Compute LD using the shrinkage estimator:\ntraining_gdl.compute_ld('shrinkage',\n                        output_dir='temp',\n                        genetic_map_ne=11400, # effective population size (Ne)\n                        genetic_map_sample_size=183,\n                        threshold=1e-3)\n# Perform GWAS on the simulated phenotype:\ntraining_gdl.perform_gwas()\n```\n\nAnd that is all we need to fit the `VIPRS` method to the training data! To perform model fit,\nsimply pass the `g_sim` object to `VIPRS` and then invoke the `.fit()` method:\n\n```python\nv = vp.VIPRS(training_gdl)\nv.fit()\n```\n\nIf everything works as expected, the method will converge reasonably fast and you should be able to \nuse object to perform predictions on the test set. Once convergence is achieved, you can compute \npolygenic risk scores (PRSs) for the test samples. This can be simply done by invoking the `.predict()` method and \npassing the `test_gdl` object as an argument, as follows:\n\n```python\ntest_prs = v.predict(test_gdl)\n```\n\nFor the sake of comparison, we will also include the PRS based on the marginal effect sizes from GWAS:\n\n```python\nnaive_prs = test_gdl.predict(beta={c: ss.marginal_beta for c, ss in training_gdl.sumstats_table.items()})\n```\n\nTo evaluate the accuracy of the polygenic score, you can use some of the provided metrics with the `viprs` package. \nFor quantitative traits, it is customary to report the prediction R^2, or the proportion \nof variance explained by the PRS:\n\n```python\nfrom viprs.eval.metrics import r2 \nr2(test_prs, test_gdl.sample_table.phenotype)\n# 0.171429\n```\n\nThe prediction R^2 here is much lower than we would expect, given our simulation \nscenario. This is again largely due to the small sample size that we are working with and \nthe noise this induces on the estimates of LD, GWAS summary statistics, etc. For reference, \nwe can compare this to the R^2 from the \"naive\" PRS estimator:\n\n```python\nr2(naive_prs, test_gdl.sample_table.phenotype)\n# 0.169567\n```\n\nIn this artificial setting, `viprs` results in minor improvements in prediction accuracy \non the test set compared to the naive PRS estimator. However, as we show in our manuscript, this \nimprovement is more pronounced when we use larger sample sizes for both GWAS and the LD reference panel.\n\n### (2) Grid search and validation\n\nIn our manuscript, we found that VIPRS paired with grid search with a held-out validation set \nperforms favorably compared to the vanilla model. Here, we will illustrate how to use the grid search functionalities \nimplemented in the `viprs` package. To start, let's use the same simulation scenario as before:\n\n```python\ng_sim = mgp.GWASimulator(mgp.tgp_eur_data_path(),\n                         pi=(.99, .01),\n                         h2=0.8)\ng_sim.simulate()\ng_sim.to_phenotype_table()\n#         FID      IID  phenotype\n# 0    HG00096  HG00096  -0.283120\n# 1    HG00097  HG00097   0.060302\n# 2    HG00099  HG00099  -0.571485\n# 3    HG00100  HG00100   1.145548\n# 4    HG00101  HG00101   0.535409\n# ..       ...      ...        ...\n# 373  NA20815  NA20815   0.214542\n# 374  NA20818  NA20818  -0.986338\n# 375  NA20819  NA20819  -0.056678\n# 376  NA20826  NA20826   0.119752\n# 377  NA20828  NA20828   0.889052\n# \n# [378 rows x 3 columns]\n```\n\nThen, we will split this small dataset into 70% training, 15% validation, and 15% testing:\n\n```python\ntraining_gdl, validation_gdl, test_gdl = g_sim.split_by_samples(proportions=[.7, .15, .15])\nprint(\"Number of training samples:\", training_gdl.sample_size)\n# Number of training samples: 251\nprint(\"Number of validation samples:\", validation_gdl.sample_size)\n# Number of validation samples: 66\nprint(\"Number of test samples:\", test_gdl.sample_size)\n# Number of test samples: 61\n```\n\nAs before, we will compute the LD and perform GWAS on the training samples:\n\n```python\n# Compute LD using the shrinkage estimator:\ntraining_gdl.compute_ld('shrinkage',\n                        output_dir='temp',\n                        genetic_map_ne=11400, # effective population size (Ne)\n                        genetic_map_sample_size=183,\n                        threshold=1e-3)\n# Perform GWAS on the simulated phenotype:\ntraining_gdl.perform_gwas()\n```\n\nFor a simple baseline, we'll examine the performance of the standard VIPRS model \nwithout any grid search:\n\n```python\nv = vp.VIPRS(training_gdl).fit()\n```\n\nOnce converged, for this simulation scenario, the standard VIPRS results in the following prediction R^2:\n\n```python\nfrom viprs.eval.metrics import r2\nr2(v.predict(test_gdl), test_gdl.sample_table.phenotype)\n0.168073\n```\n\nTo see how grid search would perform in comparison, first we construct a grid \nfor some of the hyperparameters of interest, including `pi` and `sigma_epsilon`, the \nproportion of causal variants and the residual variance, respectively:\n\n```python\n# Create a grid:\ngrid = vp.HyperparameterGrid()\n# Generate a grid for pi using 5 equidistant grid points:\ngrid.generate_pi_grid(steps=5, n_snps=training_gdl.n_snps)\n# Generate a grid for sigma epsilon using 5 equidistant grid points:\ngrid.generate_sigma_epsilon_grid(steps=5)\n```\n\nThis will generate a grid of 5x5=25 hyperparameter settings that we will search over. \nTo fit the VIPRS model with this grid, we can simply use the `GridSearch` class, passing it \nthe training data as well as the grid that we just created:\n\n```python\nvgv_gs = vp.VIPRSGridSearch(training_gdl, grid)\nvgv_gs = vgv_gs.fit()\nvgv.select_best_model(validation_gdl=validation_gdl, criterion='validation')\n```\n\nHere, in order to make use of the held-out validation data, we pass it the `GridSearch` object and \nwe also specify that the objective that we wish to optimize is the `validation` R^2. When we call `.fit()` on \nthe `GridSearch` object, it will fit 25 different VIPRS models, each with a different hyperparameter setting \nand then choose the one with the best predictive performance on the held-out validation set.\n\nGiven this \"best\" model, we can using to make predictions and test prediction accuracy on the held-out test set:\n\n```python\nr2(vgv.predict(test_gdl), test_gdl.sample_table.phenotype)\n# 0.167938\n```\n\nIn this case, the prediction R^2 is actually marginally lower than standard VIPRS model, which can happen in some \ncases, as illustrated in the simulation results in our manuscript. As our results showed, the main advantage of \nthe `GridSearch` module will be when applied on real phenotypes or when there are some mismatches between \nthe LD reference panel and the GWAS summary statistics.\n\n## Commandline scripts\n\nIf you are not comfortable programming in `python` and would like to access some of the functionalities \nof `viprs` with minimal interaction with `python` code, we packaged a number of commandline \nscripts that can be useful for some downstream applications.\n\nThe binaries that are currently supported are:\n\n1) `viprs_fit`: For performing model fit and estimating the posterior for the effect sizes.\n2) `viprs_score`: For generating polygenic scores for new test samples.\n3) `viprs_evaluate`: For evaluating the predictive performance of PRS methods.\n\nOnce you install `viprs` via `pip`, these scripts will be added to the system `PATH` \nand you can invoke them directly from the commandline, as follows:\n\n```shell\n$ viprs_fit -h\n\n        **********************************************\n                    _____\n            ___   _____(_)________ ________________\n            __ | / /__  / ___  __ \\__  ___/__  ___/\n            __ |/ / _  /  __  /_/ /_  /    _(__  )\n            _____/  /_/   _  .___/ /_/     /____/\n                          /_/\n        Variational Inference of Polygenic Risk Scores\n        Version: 0.0.2 | Release date: June 2022\n        Author: Shadi Zabad, McGill University\n        **********************************************\n        < Fit VIPRS model to GWAS summary statistics >\n    \nusage: viprs_fit [-h] -l LD_DIR -s SUMSTATS_PATH --output-file OUTPUT_FILE [--sumstats-format {fastGWA,custom,plink,magenpy,COJO}] [--snp SNP] [--a1 A1] [--n-per-snp N_PER_SNP]\n                 [--z-score Z_SCORE] [--beta BETA] [--se SE] [--temp-dir TEMP_DIR] [--validation-bed VALIDATION_BED] [--validation-pheno VALIDATION_PHENO]\n                 [--validation-keep VALIDATION_KEEP] [-m {VIPRS,VIPRSMix,VIPRSAlpha}] [--annealing-schedule {harmonic,linear,geometric}] [--annealing-steps ANNEALING_STEPS]\n                 [--initial-temperature INITIAL_TEMPERATURE] [--n-components N_COMPONENTS] [--prior-mult PRIOR_MULT] [--hyp-search {EM,BMA,GS,BO}]\n                 [--grid-metric {validation,pseudo_validation,ELBO}] [--opt-params OPT_PARAMS] [--pi-grid PI_GRID] [--pi-steps PI_STEPS] [--sigma-epsilon-grid SIGMA_EPSILON_GRID]\n                 [--sigma-epsilon-steps SIGMA_EPSILON_STEPS] [--sigma-beta-grid SIGMA_BETA_GRID] [--sigma-beta-steps SIGMA_BETA_STEPS] [--h2-informed-grid] [--compress] [--genomewide]\n                 [--backend {xarray,plink}] [--max-attempts MAX_ATTEMPTS] [--use-multiprocessing] [--n-jobs N_JOBS]\n\nCommandline arguments for fitting the VIPRS models\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -l LD_DIR, --ld-panel LD_DIR\n                        The path to the directory where the LD matrices are stored. Can be a wildcard of the form ld/chr_*\n  -s SUMSTATS_PATH, --sumstats SUMSTATS_PATH\n                        The summary statistics directory or file. Can be a wildcard of the form sumstats/chr_*\n  --output-file OUTPUT_FILE\n                        The output file where to store the inference results. Only include the prefix, the extensions will be added automatically.\n  --sumstats-format {fastGWA,custom,plink,magenpy,COJO}\n                        The format for the summary statistics file(s).\n  --snp SNP             The column name for the SNP rsID in the summary statistics file (custom formats).\n  --a1 A1               The column name for the effect allele in the summary statistics file (custom formats).\n  --n-per-snp N_PER_SNP\n                        The column name for the sample size per SNP in the summary statistics file (custom formats).\n  --z-score Z_SCORE     The column name for the z-score in the summary statistics file (custom formats).\n  --beta BETA           The column name for the beta (effect size estimate) in the summary statistics file (custom formats).\n  --se SE               The column name for the standard error in the summary statistics file (custom formats).\n  --temp-dir TEMP_DIR   The temporary directory where to store intermediate files.\n  --validation-bed VALIDATION_BED\n                        The BED files containing the genotype data for the validation set. You may use a wildcard here (e.g. \"data/chr_*.bed\")\n  --validation-pheno VALIDATION_PHENO\n                        A tab-separated file containing the phenotype for the validation set. The expected format is: FID IID phenotype (no header)\n  --validation-keep VALIDATION_KEEP\n                        A plink-style keep file to select a subset of individuals for the validation set.\n  -m {VIPRS,VIPRSMix,VIPRSAlpha}, --model {VIPRS,VIPRSMix,VIPRSAlpha}\n                        The PRS model to fit\n  --annealing-schedule {harmonic,linear,geometric}\n                        The type of schedule for updating the temperature parameter in deterministic annealing.\n  --annealing-steps ANNEALING_STEPS\n                        The number of deterministic annealing steps to perform.\n  --initial-temperature INITIAL_TEMPERATURE\n                        The initial temperature for the deterministic annealing procedure.\n  --n-components N_COMPONENTS\n                        The number of non-null Gaussian mixture components to use with the VIPRSMix model (i.e. excluding the spike component).\n  --prior-mult PRIOR_MULT\n                        Prior multipliers on the variance of the non-null Gaussian mixture component.\n  --hyp-search {EM,BMA,GS,BO}\n                        The strategy for tuning the hyperparameters of the model. Options are EM (Expectation-Maximization), GS (Grid search), BO (Bayesian Optimization), and BMA\n                        (Bayesian Model Averaging).\n  --grid-metric {validation,pseudo_validation,ELBO}\n                        The metric for selecting best performing model in grid search.\n  --opt-params OPT_PARAMS\n                        The hyperparameters to tune using GridSearch/BMA/Bayesian optimization (comma-separated).Possible values are pi, sigma_beta, and sigma_epsilon. Or a combination\n                        of them.\n  --pi-grid PI_GRID     A comma-separated grid values for the hyperparameter pi (see also --pi-steps).\n  --pi-steps PI_STEPS   The number of steps for the (default) pi grid. This will create an equidistant grid between 1/M and (M-1)/M on a log10 scale, where M is the number of SNPs.\n  --sigma-epsilon-grid SIGMA_EPSILON_GRID\n                        A comma-separated grid values for the hyperparameter sigma_epsilon (see also --sigma-epsilon-steps).\n  --sigma-epsilon-steps SIGMA_EPSILON_STEPS\n                        The number of steps for the (default) sigma_epsilon grid.\n  --sigma-beta-grid SIGMA_BETA_GRID\n                        A comma-separated grid values for the hyperparameter sigma_beta (see also --sigma-beta-steps).\n  --sigma-beta-steps SIGMA_BETA_STEPS\n                        The number of steps for the (default) sigma_beta grid.\n  --h2-informed-grid    Construct a grid for sigma_epsilon/sigma_beta based on informed estimates of the trait heritability.\n  --compress            Compress the output files\n  --genomewide          Fit all chromosomes jointly\n  --backend {xarray,plink}\n                        The backend software used for computations on the genotype matrix.\n  --max-attempts MAX_ATTEMPTS\n                        The maximum number of model restarts (in case of optimization divergence issues).\n  --use-multiprocessing\n                        Use multiprocessing where applicable. For now, this mainly affects the GridSearch/Bayesian Model Averaging implementations.\n  --n-jobs N_JOBS       The number of processes/threads to launch for the hyperparameter search (default is 1, but we recommend increasing this depending on system capacity).\n```\n\n```shell\n$ viprs_score -h\n\n        **********************************************\n                    _____\n            ___   _____(_)________ ________________\n            __ | / /__  / ___  __ \\__  ___/__  ___/\n            __ |/ / _  /  __  /_/ /_  /    _(__  )\n            _____/  /_/   _  .___/ /_/     /____/\n                          /_/\n        Variational Inference of Polygenic Risk Scores\n        Version: 0.0.2 | Release date: June 2022\n        Author: Shadi Zabad, McGill University\n        **********************************************\n        < Compute polygenic scores for test samples >\n\nusage: viprs_score [-h] -f FIT_FILES --bed-files BED_FILES --output-file OUTPUT_FILE [--temp-dir TEMP_DIR] [--keep KEEP] [--extract EXTRACT] [--backend {xarray,plink}]\n                   [--n-threads N_THREADS] [--compress]\n\nCommandline arguments for generating polygenic scores\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -f FIT_FILES, --fit-files FIT_FILES\n                        The path to the file(s) with the output parameter estimates from VIPRS. You may use a wildcard here (e.g. \"prs/chr_*.fit\")\n  --bed-files BED_FILES\n                        The BED files containing the genotype data. You may use a wildcard here (e.g. \"data/chr_*.bed\")\n  --output-file OUTPUT_FILE\n                        The output file where to store the polygenic scores (with no extension).\n  --temp-dir TEMP_DIR   The temporary directory where to store intermediate files.\n  --keep KEEP           A plink-style keep file to select a subset of individuals for the test set.\n  --extract EXTRACT     A plink-style extract file to select a subset of SNPs for scoring.\n  --backend {xarray,plink}\n                        The backend software used for computations with the genotype matrix.\n  --n-threads N_THREADS\n                        The number of threads to use for computations.\n  --compress            Compress the output file\n```\n\n```shell\n$ viprs_evaluate -h\n\n     **************************************************\n                    _____\n            ___   _____(_)________ ________________\n            __ | / /__  / ___  __ \\__  ___/__  ___/\n            __ |/ / _  /  __  /_/ /_  /    _(__  )\n            _____/  /_/   _  .___/ /_/     /____/\n                          /_/\n        Variational Inference of Polygenic Risk Scores\n        Version: 0.0.2 | Release date: June 2022\n        Author: Shadi Zabad, McGill University\n     **************************************************\n       < Evaluate the predictive performance of PRS >\n\nusage: viprs_evaluate [-h] --prs-file PRS_FILE --phenotype-file PHENO_FILE [--phenotype-likelihood {binomial,gaussian}] --output-file OUTPUT_FILE [--covariate-file COVARIATE_FILE]\n\nCommandline arguments for evaluating polygenic score estimates\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --prs-file PRS_FILE   The path to the PRS file (expected format: FID IID PRS, tab-separated)\n  --phenotype-file PHENO_FILE\n                        The path to the phenotype file. The expected format is: FID IID phenotype (no header), tab-separated.\n  --phenotype-likelihood {binomial,gaussian}\n                        The phenotype likelihood (\"gaussian\" for continuous, \"binomial\" for case-control).\n  --output-file OUTPUT_FILE\n                        The output file where to store the evaluation metrics (with no extension).\n  --covariate-file COVARIATE_FILE\n                        A file with covariates for the samples included in the analysis. This tab-separated file should not have a header and the first two columns should be the FID\n                        and IID of the samples.\n```\n\n\n## Download LD matrices\n\nTo run the `viprs` software, you may need access to pre-computed LD matrices. Here, we provide access to pre-computed LD matrices\nfrom the UK Biobank (UKB) dataset:\n\n- LD matrices derived from the \"White British\" cohort (N=50,000) in the UKB: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.7036625.svg)](https://doi.org/10.5281/zenodo.7036625)\n\n\nYou can also use the `data_utils` module from the `viprs` package to download those \ndata sources. For example, to download the UKB LD matrices listed above, you can do \nthe following:\n\n```python\nimport viprs as vp\n\n# Download all matrices from Zenodo:\nvp.download_ukb_wb_ld_matrix('data/ld/')\n\n# Download LD matrices for chromosomes 21 and 22:\nvp.download_ukb_wb_ld_matrix('data/ld/', chromosome=[21, 22])\n\n```\n\nThis will download the LD matrix to a sub-folder in the working directory called `data/ld`. We will add more utilities \nlike this in the future to streamline PRS model training and testing.\n\n## Frequently Asked Questions (FAQs)\n\n- **How do I create my own LD matrices and store them in formats compatible with `viprs`?**\n\nYou can use the software package [magenpy](https://github.com/shz9/magenpy) to compute LD matrices \nfrom any reference genotype dataset. `magenpy` provides interfaces for computing LD matrices \nusing 3 commonly used LD estimators: `shrinkage`, `windowed` (or banded), and `block\n`-based LD matrices. Check the relevant documentation [here](https://github.com/shz9/magenpy#3-calculating-ld-matrices).\n\n\n## Citations\n\nShadi Zabad, Simon Gravel, Yue Li. **Fast and Accurate Bayesian Polygenic Risk Modeling with Variational Inference**. (2022)\n\n```bibtex\n@article {\n    Zabad2022.05.10.491396,\n    author = {Zabad, Shadi and Gravel, Simon and Li, Yue},\n    title = {Fast and Accurate Bayesian Polygenic Risk Modeling with Variational Inference},\n    elocation-id = {2022.05.10.491396},\n    year = {2022},\n    doi = {10.1101/2022.05.10.491396},\n    publisher = {Cold Spring Harbor Laboratory},\n    URL = {https://www.biorxiv.org/content/early/2022/05/11/2022.05.10.491396},\n    journal = {bioRxiv}\n}\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/shz9/viprs",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "viprs",
    "package_url": "https://pypi.org/project/viprs/",
    "platform": null,
    "project_url": "https://pypi.org/project/viprs/",
    "project_urls": {
      "Homepage": "https://github.com/shz9/viprs"
    },
    "release_url": "https://pypi.org/project/viprs/0.0.4/",
    "requires_dist": [
      "numpy",
      "scipy",
      "pandas",
      "tqdm",
      "magenpy (>=0.0.5)",
      "statsmodels",
      "scikit-learn",
      "psutil",
      "Cython ; extra == 'full'",
      "scikit-optimize (==0.8.1) ; extra == 'full'",
      "seaborn ; extra == 'full'"
    ],
    "requires_python": "",
    "summary": "Variational Inference of Polygenic Risk Scores (VIPRS)",
    "version": "0.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15014564,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a30fb0b2dfec35d6d08b2e4844ecbbc615d6d9508878339f5c12a936151dae22",
          "md5": "ae736e02019825168ea5f73de8ba4501",
          "sha256": "a3a562534c0c5c7dfecb950e7ca8f69b5b43a2b00121314c8a064c17d5c59979"
        },
        "downloads": -1,
        "filename": "viprs-0.0.1-cp37-cp37m-macosx_10_9_x86_64.whl",
        "has_sig": false,
        "md5_digest": "ae736e02019825168ea5f73de8ba4501",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 584241,
        "upload_time": "2022-06-28T07:54:25",
        "upload_time_iso_8601": "2022-06-28T07:54:25.454308Z",
        "url": "https://files.pythonhosted.org/packages/a3/0f/b0b2dfec35d6d08b2e4844ecbbc615d6d9508878339f5c12a936151dae22/viprs-0.0.1-cp37-cp37m-macosx_10_9_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6c78182d9551b88d7018772fa46b79165a8cda6e34c940dbb06f7ced581a06e1",
          "md5": "7243db7cf67b88eb2a490aa81c0eb2e5",
          "sha256": "c7ed618faedae6ba0b7aa0a9fb68e0fa594f64231db6a19f713683fa9945af1c"
        },
        "downloads": -1,
        "filename": "viprs-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "7243db7cf67b88eb2a490aa81c0eb2e5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 43711,
        "upload_time": "2022-06-28T07:54:27",
        "upload_time_iso_8601": "2022-06-28T07:54:27.336113Z",
        "url": "https://files.pythonhosted.org/packages/6c/78/182d9551b88d7018772fa46b79165a8cda6e34c940dbb06f7ced581a06e1/viprs-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "41090214a9eb4ca78d57522665e28d90cff1ccf6280d6a02411c217216a7aab3",
          "md5": "75153162daef987bb71472665d7b3327",
          "sha256": "a9817f436f81080844b33703870ea63f601b8b0a2898e078e64346c36bbe1c67"
        },
        "downloads": -1,
        "filename": "viprs-0.0.2-cp37-cp37m-macosx_10_9_x86_64.whl",
        "has_sig": false,
        "md5_digest": "75153162daef987bb71472665d7b3327",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 584296,
        "upload_time": "2022-06-28T23:55:28",
        "upload_time_iso_8601": "2022-06-28T23:55:28.605838Z",
        "url": "https://files.pythonhosted.org/packages/41/09/0214a9eb4ca78d57522665e28d90cff1ccf6280d6a02411c217216a7aab3/viprs-0.0.2-cp37-cp37m-macosx_10_9_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9d15039cd732699a25190f0cee0498c41195dc808ac4c6206000d45ea2ba1454",
          "md5": "7159dce6620af6df4f3e28883d269d4a",
          "sha256": "61667e8a0e6eb14a57f1ffd69509518f37a3c3714913b00130e1f3ecd069e653"
        },
        "downloads": -1,
        "filename": "viprs-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "7159dce6620af6df4f3e28883d269d4a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 43645,
        "upload_time": "2022-06-28T23:55:31",
        "upload_time_iso_8601": "2022-06-28T23:55:31.203075Z",
        "url": "https://files.pythonhosted.org/packages/9d/15/039cd732699a25190f0cee0498c41195dc808ac4c6206000d45ea2ba1454/viprs-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "404f26dc0bd6fa5efc6137756e576e98c51a80dc26a1b5b7426e4a0eb100124e",
          "md5": "1f96601ad13cbb3732f59d47624d215e",
          "sha256": "cba0e3376cf293bbe9e5082f3615574339158a34237eb6c42430426995351c99"
        },
        "downloads": -1,
        "filename": "viprs-0.0.3-cp37-cp37m-macosx_10_9_x86_64.whl",
        "has_sig": false,
        "md5_digest": "1f96601ad13cbb3732f59d47624d215e",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 845090,
        "upload_time": "2022-09-06T22:23:20",
        "upload_time_iso_8601": "2022-09-06T22:23:20.331191Z",
        "url": "https://files.pythonhosted.org/packages/40/4f/26dc0bd6fa5efc6137756e576e98c51a80dc26a1b5b7426e4a0eb100124e/viprs-0.0.3-cp37-cp37m-macosx_10_9_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2b5bb81c9b96a63ce0b67e7c740de4179ec5f202ce876a06cc50f76c8d760473",
          "md5": "ca699cc14ad5a723a853e4f9b11ee514",
          "sha256": "36763d9ff68a557b8a075c72c6495ee5e4330e3d9b42cf38a2420c49b15cc543"
        },
        "downloads": -1,
        "filename": "viprs-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "ca699cc14ad5a723a853e4f9b11ee514",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 55273,
        "upload_time": "2022-09-06T22:23:22",
        "upload_time_iso_8601": "2022-09-06T22:23:22.201308Z",
        "url": "https://files.pythonhosted.org/packages/2b/5b/b81c9b96a63ce0b67e7c740de4179ec5f202ce876a06cc50f76c8d760473/viprs-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "039c5543ab4839d64a34d2dc08d1da1eefb674bd9fd3a9a1a1ecbd52867c4981",
          "md5": "134a74592bff3122fe85bb10439bc82b",
          "sha256": "64bc14afdc3e506745e00dc3abdc49ab8f729ffef8662fbe0ac8285f8580d583"
        },
        "downloads": -1,
        "filename": "viprs-0.0.4-cp37-cp37m-macosx_10_9_x86_64.whl",
        "has_sig": false,
        "md5_digest": "134a74592bff3122fe85bb10439bc82b",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 845280,
        "upload_time": "2022-09-07T04:09:31",
        "upload_time_iso_8601": "2022-09-07T04:09:31.461904Z",
        "url": "https://files.pythonhosted.org/packages/03/9c/5543ab4839d64a34d2dc08d1da1eefb674bd9fd3a9a1a1ecbd52867c4981/viprs-0.0.4-cp37-cp37m-macosx_10_9_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ec83529f9c385b4bc2011bf58d0db8eb8d0b38170708dcd9a04860b8b53ed3b8",
          "md5": "ae6b4bd6050245450201179d91399bd5",
          "sha256": "a62c3bc3bc5cfc90d40b8cd0c5d8c77ebef3f05261162a5e151078083b11c61c"
        },
        "downloads": -1,
        "filename": "viprs-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "ae6b4bd6050245450201179d91399bd5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 55249,
        "upload_time": "2022-09-07T04:09:33",
        "upload_time_iso_8601": "2022-09-07T04:09:33.516208Z",
        "url": "https://files.pythonhosted.org/packages/ec/83/529f9c385b4bc2011bf58d0db8eb8d0b38170708dcd9a04860b8b53ed3b8/viprs-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "039c5543ab4839d64a34d2dc08d1da1eefb674bd9fd3a9a1a1ecbd52867c4981",
        "md5": "134a74592bff3122fe85bb10439bc82b",
        "sha256": "64bc14afdc3e506745e00dc3abdc49ab8f729ffef8662fbe0ac8285f8580d583"
      },
      "downloads": -1,
      "filename": "viprs-0.0.4-cp37-cp37m-macosx_10_9_x86_64.whl",
      "has_sig": false,
      "md5_digest": "134a74592bff3122fe85bb10439bc82b",
      "packagetype": "bdist_wheel",
      "python_version": "cp37",
      "requires_python": null,
      "size": 845280,
      "upload_time": "2022-09-07T04:09:31",
      "upload_time_iso_8601": "2022-09-07T04:09:31.461904Z",
      "url": "https://files.pythonhosted.org/packages/03/9c/5543ab4839d64a34d2dc08d1da1eefb674bd9fd3a9a1a1ecbd52867c4981/viprs-0.0.4-cp37-cp37m-macosx_10_9_x86_64.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ec83529f9c385b4bc2011bf58d0db8eb8d0b38170708dcd9a04860b8b53ed3b8",
        "md5": "ae6b4bd6050245450201179d91399bd5",
        "sha256": "a62c3bc3bc5cfc90d40b8cd0c5d8c77ebef3f05261162a5e151078083b11c61c"
      },
      "downloads": -1,
      "filename": "viprs-0.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "ae6b4bd6050245450201179d91399bd5",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 55249,
      "upload_time": "2022-09-07T04:09:33",
      "upload_time_iso_8601": "2022-09-07T04:09:33.516208Z",
      "url": "https://files.pythonhosted.org/packages/ec/83/529f9c385b4bc2011bf58d0db8eb8d0b38170708dcd9a04860b8b53ed3b8/viprs-0.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}