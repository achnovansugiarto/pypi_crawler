{
  "info": {
    "author": "hwd404",
    "author_email": "hwd404@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# FOLD-R-PP\nThe implementation details of FOLD-R++ algorithm and how to use it are described here. The target of FOLD-R++ algorithm is to learn an answer set program for a classification task. Answer set programs are logic programs that permit negation of predicates and follow the stable model semantics for interpretation. The rules generated are essentially default rules. Default rules (with exceptions) closely model human thinking.\n\n## Installation\n\n<code>\n\t\n    python3 -m pip install foldrpp\n\t\n</code>\n\n### Prerequisites\nThe FOLD-R++ algorithm is developed with only python3. No extra library is needed.\n<!-- Numpy is the only dependency:\n\n<code>\n\t\n\tpython3 -m pip install numpy\n\t\n</code> -->\n\n## Instruction\n### Data preparation\n\nThe FOLD-R++ algorithm takes tabular data as input, the first line for the tabular data should be the feature names of each column.\nThe FOLD-R++ algorithm does not have to encode the data for training. It can deal with numerical, categorical, and even mixed type features (one column contains both categorical and numerical values) directly.\nHowever, the numerical features should be identified before loading the data, otherwise they would be dealt like categorical features (only literals with = and != would be generated).\n\nThere are many UCI example datasets that have been used to pre-populate the **data** directory. Code for preparing these datasets has already been added to datasets.py.\n\n\nFor example, the UCI kidney dataset can be loaded with the following code:\n\n<code>\n\t\n    attrs = ['age', 'bp', 'sg', 'al', 'su', 'rbc', 'pc', 'pcc', 'ba', 'bgr', 'bu', 'sc', 'sod', 'pot', 'hemo', 'pcv',\n             'wbcc', 'rbcc', 'htn', 'dm', 'cad', 'appet', 'pe', 'ane']\n    nums = ['age', 'bp', 'sg', 'bgr', 'bu', 'sc', 'sod', 'pot', 'hemo', 'pcv', 'wbcc', 'rbcc']\n    model = Classifier(attrs=attrs, numeric=nums, label='label', pos='ckd')\n\n    data = model.load_data('data/kidney/kidney.csv')\n    data_train, data_test = split_data(data, ratio=0.8, rand=True)\n\n    X_train, Y_train = split_xy(data_train)\n    X_test,  Y_test = split_xy(data_test)\n\t\n</code>\n\n**attrs** lists all the features needed, **nums** lists all the numerical features, **label** is the name of the output classification label, **pos** indicates the positive value of the label, **model** is an initialized classifier object with the configuration of kidney dataset. **Note: For binary classification tasks, the label value with more examples should be selected as the label's positive value**.\n\n### Training\nThe FOLD-R++ algorithm generates an explainable model that is represented by an answer set program for classification tasks. Here's a training example for kidney dataset:\n\n<code>\n\t\n    model.fit(X_train, Y_train, ratio=0.5)\n\t\n</code>\n\nNote that the hyperparameter **ratio** in **fit** function can be set by the user, and ranges between 0 and 1. Default value is 0.5. This hyperparameter represents the ratio of training examples that are part of the exception to the examples implied by only the default conclusion part of the rule. We recommend that the user experiment with this hyperparameter by trying different values to produce a ruleset with the best F1 score. A range between 0.2 and 0.5 is recommended for experimentation.\n\nThe rules generated by foldrpp will be stored in the model object. These rules are organized in a nested intermediate representation. The nested rules will be automatically flattened and decoded to conform to the syntax of answer set programs by calling **print_asp** function: \n\n<code>\n\t\n    model.print_asp()\n\t\n</code>\n\nAn answer set program, compatible with the s(CASP) answer set programming system, is printed as shown below. The s(CASP) system is a system for direclty executing predicate answer set programs in a query-driven manner.\n\n<code>\n\n\t% the answer set program generated by foldr++:\n\tlabel(X,'ckd') :- sc(X,N11), N11>1.2. \n\tlabel(X,'ckd') :- sg(X,N2), N2=<1.015. \n\tlabel(X,'ckd') :- hemo(X,N14), N14=<12.7. \n\tlabel(X,'ckd') :- not al(X,'0'), sg(X,N2), N2=<1.025. \n\tlabel(X,'ckd') :- su(X,'2'). \n\t% acc 1.0 p 1.0 r 1.0 f1 1.0\n\t% foldr++ costs:  0:00:00.016192 \n\t\n</code>\n\n### Testing in Python\nGiven **X_test**, a list of test data samples, the Python **predict** function will predict the classification outcome for each of these data samples. \n\n<code>\n\t\n\tY_test_hat = model.predict(X_test)\n\n</code>\n\nThe **classify** function can also be used to classify a single data sample.\n\t\n<code>\n\t\n\ty_test_hat = model.classify(x_test)\n\n</code>\n\n#### The code of the above examples can be found in **main.py**. The examples below with more datasets and more functions can be found in **example.py**\n\n### Save model and Load model\n\n<code>\n\t\n    save_model_to_file(model, 'example.model')\n    model2 = load_model_from_file('example.model')\n    save_asp_to_file(model2, 'example.lp')\n\n</code>\n\nA trained model can be saved to a file with **save_model_to_file** function. **load_model_from_file** function helps load model from file.\nThe generated ASP program can be saved to a file with **save_asp_to_file** function.\n\t\n### Explanation and Proof Tree\n\nFOLD-R++ provides simple format explanation for predictions with **explain** function, the parameter **all_flag** means whether or not to list all the answer sets. \n\n<code>\n\t\n\tmodel.explain(X_test[i], all_flag=True)\n\t\n</code>\n\nHere is an example for a instance from cars dataset. The generated answer set program is :\n\n<code>\n\t\n\t% cars dataset 1728 7\n\tlabel(X,'negative') :- persons(X,'2'). \n\tlabel(X,'negative') :- safety(X,'low'). \n\tlabel(X,'negative') :- buying(X,'vhigh'), maint(X,'high'). \n\tlabel(X,'negative') :- maint(X,'vhigh'), not buying(X,'low'), not ab4(X). \n\tlabel(X,'negative') :- lugboot(X,'small'), safety(X,'med'), buying(X,'high'). \n\tab1(X) :- lugboot(X,'small'), safety(X,'med'). \n\tab2(X) :- doors(X,'2'), not lugboot(X,'big'), safety(X,'med'). \n\tab3(X) :- doors(X,'2'), lugboot(X,'small'), persons(X,'more'). \n\tab4(X) :- buying(X,'med'), not ab1(X), not ab2(X), not ab3(X). \n\t% acc 0.9538 p 1.0 r 0.935 f1 0.9664\n\t% foldr++ costs:  0:00:00.029924 \n\n</code>\n\nAnd the generated justification for an instance predicted as positive:\n\n<code>\n\t\n\tExplanation for example number 13 :\n\tanswer 1:\n\t[T]label(X,'negative') :- [T]persons(X,'2'). \n\t{'persons: 2'}\n\tanswer 2:\n\t[T]label(X,'negative') :- [T]safety(X,'low'). \n\t{'safety: low'}\n\tanswer 3:\n\t[F]ab4(X) :- [F]buying(X,'med'), not [U]ab1(X), not [U]ab2(X), not [U]ab3(X). \n\t[T]label(X,'negative') :- [T]maint(X,'vhigh'), not [F]buying(X,'low'), not [F]ab4(X). \n\t{'buying: high', 'maint: vhigh'}\n\n</code>\n\nThere are 3 answers have been generated for the current instance, because **all_flag** has been set as True when calling **explain** function. Only 1 answer will be generated if **all_flag** is False. In the generated answers, each literal has been tagged with a label. **[T]** means True, **[F]** means False, and **[U]** means unnecessary to evaluate. And the smallest set of features of the instance is listed for each answer.\n\nFOLD-R++ also provide proof tree for predictions with **proof** function, the parameter **all_flag** means whether or not to list all the answer sets. \n\n<code>\n\t\n\tmodel.proof(X_test[i], all_flag=True)\n\t\n</code>\n\t\nAnd generate proof tree for the instance above:\n\n<code>\n\t\n\tProof Trees for example number 13 :\n\tanswer 1:\n\tlabel(X,'negative') DOES HOLD because \n\t\tthe value of persons is '2' which should equal '2' (DOES HOLD) \n\t{'persons: 2'}\n\tanswer 2:\n\tlabel(X,'negative') DOES HOLD because \n\t\tthe value of safety is 'low' which should equal 'low' (DOES HOLD) \n\t{'safety: low'}\n\tanswer 3:\n\tlabel(X,'negative') DOES HOLD because \n\t\tthe value of maint is 'vhigh' which should equal 'vhigh' (DOES HOLD) \n\t\tthe value of buying is 'high' which should not equal 'low' (DOES HOLD) \n\t\texception ab4 DOES NOT HOLD because \n\t\t\tthe value of buying is 'high' which should equal 'med' (DOES NOT HOLD) \n\t{'buying: high', 'maint: vhigh'}\n\n</code>\n\nFor an instance predicted as negative, there' no answer set. Instead, the explaination has to list the rebuttals for all the possible rules, and the parameter **all_flag** will be ignored:\n\n<code>\n\t\n\tExplanation for example number 15 :\n\trebuttal 1:\n\t[F]label(X,'negative') :- [F]persons(X,'2'). \n\t{'persons: more'}\n\trebuttal 2:\n\t[F]label(X,'negative') :- [F]safety(X,'low'). \n\t{'safety: med'}\n\t... ...\n\trebuttal 5:\n\t[F]label(X,'negative') :- [T]lugboot(X,'small'), [T]safety(X,'med'), [F]buying(X,'high'). \n\t{'lugboot: small', 'safety: med', 'buying: med'}\n\n</code>\n\n<code>\n\n\tProof Trees for example number 15 :\n\trebuttal 1:\n\tlabel(X,'negative') DOES NOT HOLD because \n\t\tthe value of persons is 'more' which should equal '2' (DOES NOT HOLD) \n\t{'persons: more'}\n\trebuttal 2:\n\tlabel(X,'negative') DOES NOT HOLD because \n\t\tthe value of safety is 'med' which should equal 'low' (DOES NOT HOLD) \n\t{'safety: med'}\n\t... ...\n\trebuttal 5:\n\tlabel(X,'negative') DOES NOT HOLD because \n\t\tthe value of lugboot is 'small' which should equal 'small' (DOES HOLD) \n\t\tthe value of safety is 'med' which should equal 'med' (DOES HOLD) \n\t\tthe value of buying is 'med' which should equal 'high' (DOES NOT HOLD) \n\t{'lugboot: small', 'safety: med', 'buying: med'}\n\n</code>\n\t\n## Citation\n\n<code>\n\n\t@misc{wang2022foldr,\n\t      title={FOLD-R++: A Scalable Toolset for Automated Inductive Learning of Default Theories from Mixed Data}, \n\t      author={Huaduo Wang and Gopal Gupta},\n\t      year={2022},\n\t      eprint={2110.07843},\n\t      archivePrefix={arXiv},\n\t      primaryClass={cs.LG}\n\t}\n\n</code>\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/hwd404/FOLD-R-PP",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "foldrpp",
    "package_url": "https://pypi.org/project/foldrpp/",
    "platform": "",
    "project_url": "https://pypi.org/project/foldrpp/",
    "project_urls": {
      "Homepage": "https://github.com/hwd404/FOLD-R-PP"
    },
    "release_url": "https://pypi.org/project/foldrpp/0.0.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12943253,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "03d9d508be89516328edcc65308871001fdf0c4c714f4966600eeed7be14cf6e",
          "md5": "012d160a9272ad3287bf0fb68482ee4e",
          "sha256": "ee102510d970a76a86d90a554fb2f9015019eaad80b25347e5d0b2419f7675c5"
        },
        "downloads": -1,
        "filename": "foldrpp-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "012d160a9272ad3287bf0fb68482ee4e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13496,
        "upload_time": "2022-02-19T08:49:36",
        "upload_time_iso_8601": "2022-02-19T08:49:36.065040Z",
        "url": "https://files.pythonhosted.org/packages/03/d9/d508be89516328edcc65308871001fdf0c4c714f4966600eeed7be14cf6e/foldrpp-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "03d9d508be89516328edcc65308871001fdf0c4c714f4966600eeed7be14cf6e",
        "md5": "012d160a9272ad3287bf0fb68482ee4e",
        "sha256": "ee102510d970a76a86d90a554fb2f9015019eaad80b25347e5d0b2419f7675c5"
      },
      "downloads": -1,
      "filename": "foldrpp-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "012d160a9272ad3287bf0fb68482ee4e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 13496,
      "upload_time": "2022-02-19T08:49:36",
      "upload_time_iso_8601": "2022-02-19T08:49:36.065040Z",
      "url": "https://files.pythonhosted.org/packages/03/d9/d508be89516328edcc65308871001fdf0c4c714f4966600eeed7be14cf6e/foldrpp-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}