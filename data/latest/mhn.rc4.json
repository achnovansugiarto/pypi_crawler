{
  "info": {
    "author": "Stefan Vocht, Kevin Rupp, Y. Linda Hu",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# *mhn*: A Python package to efficiently compute Mutual Hazard Networks\r\n\r\nMutual Hazard Networks (MHN) were first introduced by [Schill et al. (2019)](https://academic.oup.com/bioinformatics/article/36/1/241/5524604)\r\nand are used to model cancer progression.  \r\nThis Python package can be used to work with MHNs. It includes functions that were part of the\r\noriginal R implementation as well as functions that make use of state-space restriction \r\nto make learning a new MHN from cancer data faster and more efficient. Furthermore, it\r\nalso contains functions to work with data for which the samples' ages are known and can\r\ntherefore be considered while learning an MHN (see [Rupp et al. (2021)](https://arxiv.org/abs/2112.10971)).  \r\nThere are optimizer classes for data with known sample ages as well as for data without, which make learning a new MHN possible with\r\nonly a few lines of code.  \r\n\r\n## Documentation\r\n\r\nA detailed documentation of the *mhn* package is available [here](https://learnmhn.readthedocs.io/en/latest/index.html).\r\n\r\n## Install the mhn package\r\n\r\nYou can install the mhn package using pip:\r\n\r\n```bash\r\npip install mhn\r\n```\r\n\r\nAfter completing the installation of this package you should be able to import it by calling\r\n```python\r\nimport mhn\r\n```\r\n\r\nIf a new version of the mhn package is available, you can upgrade your installation with\r\n```bash\r\npip install --upgrade mhn\r\n```\r\n\r\n## A quick overview\r\n\r\nThe package contains the original MHN functions implemented in Python. You import them from ``mhn.original``:\r\n\r\n```python\r\nfrom mhn.original import Likelihood, ModelConstruction, RegularizedOptimization, UtilityFunctions\r\n```\r\nYou can train an MHN using state-space restriction. The corresponding functions\r\ncan be imported with\r\n```python\r\nfrom mhn.ssr import state_space_restriction, state_containers\r\n```\r\nThe functions that make use of the known ages of samples can be imported via\r\n```python\r\nfrom mhn.ssr import matrix_exponential\r\n```\r\n\r\n## Using the CUDA implementation to accelerate score computations\r\nIf your device has an Nvidia GPU, you can accelerate the computation of the log-likelihood score and its gradient for\r\nboth the full and the restricted state-space with CUDA. \r\nFor that you have to have CUDA and the CUDA compiler\r\ninstalled on your device. You can check that in the terminal with\r\n```bash\r\nnvcc --version\r\n```\r\nIf this command is recognized, then CUDA should be installed on your device.  \r\nYou can also use the following function of the ```state_space_restriction``` submodule:\r\n```python\r\nfrom mhn.ssr import state_space_restriction\r\n\r\nprint(state_space_restriction.cuda_available())\r\n\r\n# the three possible results are also available as constants:\r\n# CUDA_AVAILABLE, CUDA_NOT_AVAILABLE, CUDA_NOT_FUNCTIONAL\r\n\r\nif state_space_restriction.cuda_available() == state_space_restriction.CUDA_AVAILABLE:\r\n    print('CUDA is available')\r\n\r\nif state_space_restriction.cuda_available() == state_space_restriction.CUDA_NOT_AVAILABLE:\r\n    print('CUDA compiler nvcc was not present during installation')\r\n\r\nif state_space_restriction.cuda_available() == state_space_restriction.CUDA_NOT_FUNCTIONAL:\r\n    print('CUDA compiler nvcc available but CUDA functions not working. Check CUDA installation')\r\n```\r\n\r\nBe especially aware of the ```CUDA_NOT_FUNCTIONAL``` case: This means that the CUDA compiler\r\nis installed on your device but basic functionalities like allocating memory on the GPU\r\nare not working as expected. In this case\r\nsomething is probably wrong with your CUDA drivers and you should check your CUDA\r\ninstallation.\r\n\r\nIf you installed ``nvcc`` after installing the ``mhn`` package, you have to\r\nreinstall this package to gain access to the CUDA functions.\r\n\r\n## How to train a new MHN\r\n\r\nThe simplest way to train a new MHN is to import the ```optimizers``` module and\r\nuse the ```StateSpaceOptimizer``` class.\r\n```python\r\nfrom mhn.optimizers import StateSpaceOptimizer\r\nopt = StateSpaceOptimizer()\r\n```\r\nWe can specify the data that we want our MHN to be trained on:\r\n```python\r\nopt.load_data_matrix(data_matrix)\r\n```\r\nMake sure, that the binary numpy matrix ```data_matrix``` is set to ```dtype=np.int32```, else you \r\nmight get an error. Alternatively, if your training data is stored in a CSV file, you can call\r\n```python\r\nopt.load_data_from_csv(filename, delimiter)\r\n```\r\nwhere ```delimiter``` is the delimiter separating the items in the CSV file (default: ``','``). \r\nInternally, this method uses pandas' ```read_csv()``` function to extract the data from the CSV file.\r\nAll additional keyword arguments given to this method will be passed on to that\r\npandas function. This means parameters like ```usecols``` or ```skiprows``` of the ```read_csv()```\r\nfunction can also be used as parameters for this method.  \r\nIf you want to make sure that the matrix was loaded correctly, you can get \r\nthe loaded matrix with\r\n\r\n```python\r\nloaded_matrix = opt.training_data\r\n```\r\nIf you work with a CUDA-capable device, you can choose which device you want to use to \r\ntrain a new MHN:\r\n```python\r\n# uses both CPU and GPU depending on the number of mutations in the individual sample\r\nopt.set_device(StateSpaceOptimizer.Device.AUTO)\r\n# use the CPU to compute log-likelihood score and gradient\r\nopt.set_device(StateSpaceOptimizer.Device.CPU)\r\n# use the GPU to compute log-likelihood score and gradient\r\nopt.set_device(StateSpaceOptimizer.Device.GPU)\r\n# you can also access the Device enum directly with an Optimizer object\r\nopt.set_device(opt.Device.AUTO)\r\n```\r\nYou could also change the initial theta that is the starting point for training, which by default\r\nis an independence model, with\r\n```python\r\nopt.set_init_theta(init_theta)\r\n```\r\nIf you want to regularly save the progress during training you can use\r\n```python\r\nopt.save_progress(steps=-1, always_new_file=False, filename='theta_backup.npy')\r\n```\r\nThe parameters of this method are  \r\n``steps`` (default: ``-1``): if positive, the number of iterations between two progress storages  \r\n``always_new_file`` (default: ``False``): if True, creates a new file for every progress storage, \r\nelse the former progress file is overwritten each time  \r\n``filename`` (default: ``\"theta_backup.npy\"``): the file name of the progress file.\r\n\r\nLastly, you could specify a callback function that is called after each training step\r\n```python\r\ndef some_callback_function(theta: np.ndarray):\r\n    pass\r\n\r\nopt.set_callback_func(some_callback_function)\r\n```\r\n\r\nFinally, you can train a new MHN with\r\n```python\r\nfrom mhn.optimizers import StateSpaceOptimizer\r\nopt = StateSpaceOptimizer()\r\nopt = opt.load_data_from_csv(filename, delimiter)\r\nopt.train()\r\n```\r\nSome important parameters of the ``train`` method include  \r\n``lam`` (default: ``0``), which is\r\nthe lambda tuning parameter to control L1 regularization,  \r\n``maxit`` (default: ``5000``), which is the maximum\r\nnumber of training iterations,  \r\n```reltol``` (default: ``1e-7``), which is the gradient norm at which the training terminates and  \r\n```round_result``` (default: ``True``), which, if set to True, rounds the result to two decimal places  \r\n  \r\nThe resulting MHN is returned by the ```train()``` method, but can also be obtained\r\nfrom the ```result``` parameter:\r\n```python\r\nnew_mhn = opt.result\r\n```\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mhn",
    "package_url": "https://pypi.org/project/mhn/",
    "platform": null,
    "project_url": "https://pypi.org/project/mhn/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/mhn/0.0.9/",
    "requires_dist": null,
    "requires_python": ">=3.8",
    "summary": "A package to train and work with Mutual Hazard Networks",
    "version": "0.0.9",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17354796,
  "releases": {
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f426bbe26f4b6f31266ca02979b64f2f3270d1a36ce1322601f317d07c750240",
          "md5": "1f537aa9fbd51f1fa29e41152b65db67",
          "sha256": "f227b0f797d75df2b3f8b0eaba3ce1ed740341a2283c82552a2d52ac164dbe7f"
        },
        "downloads": -1,
        "filename": "mhn-0.0.6-cp38-cp38-win_amd64.whl",
        "has_sig": false,
        "md5_digest": "1f537aa9fbd51f1fa29e41152b65db67",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": ">=3.8",
        "size": 786106,
        "upload_time": "2023-03-04T23:23:04",
        "upload_time_iso_8601": "2023-03-04T23:23:04.284484Z",
        "url": "https://files.pythonhosted.org/packages/f4/26/bbe26f4b6f31266ca02979b64f2f3270d1a36ce1322601f317d07c750240/mhn-0.0.6-cp38-cp38-win_amd64.whl",
        "yanked": true,
        "yanked_reason": "not installable on CUDA capable devices"
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d2244fe51b43dc8697ff0b847cabc6acb446a00d9c71362425f4bd9e813d2593",
          "md5": "15c53afd8525d41586805416870a7081",
          "sha256": "8bd4579135e84cfd25edf2ba2f6551e00f9f7518e0d607ea68825b3129816083"
        },
        "downloads": -1,
        "filename": "mhn-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "15c53afd8525d41586805416870a7081",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 1106055,
        "upload_time": "2023-03-04T23:23:07",
        "upload_time_iso_8601": "2023-03-04T23:23:07.174536Z",
        "url": "https://files.pythonhosted.org/packages/d2/24/4fe51b43dc8697ff0b847cabc6acb446a00d9c71362425f4bd9e813d2593/mhn-0.0.6.tar.gz",
        "yanked": true,
        "yanked_reason": "not installable on CUDA capable devices"
      }
    ],
    "0.0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a78724cb241427182dd43493b00dff7e8f9a6b415a097658da93632568528765",
          "md5": "169b704083f819a8cb2d6327aaad57b1",
          "sha256": "d8651c0f9171e39f6dfa70fa824c86b22a7db6d5bcda005353c9d6fd608a2c00"
        },
        "downloads": -1,
        "filename": "mhn-0.0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "169b704083f819a8cb2d6327aaad57b1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 1106098,
        "upload_time": "2023-03-05T14:18:31",
        "upload_time_iso_8601": "2023-03-05T14:18:31.771352Z",
        "url": "https://files.pythonhosted.org/packages/a7/87/24cb241427182dd43493b00dff7e8f9a6b415a097658da93632568528765/mhn-0.0.7.tar.gz",
        "yanked": true,
        "yanked_reason": "not installable on CUDA capable devices"
      }
    ],
    "0.0.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3ba10d19b95f39da60af8aa123e0886cb4b578e1b03de64ef2be927c8ea31e01",
          "md5": "6277461e729fa83da5105ec2a6718c6e",
          "sha256": "99c53350b5cd5c9c69a2bbd04628479919c613d308af5b2274e0bf105d42de09"
        },
        "downloads": -1,
        "filename": "mhn-0.0.8.tar.gz",
        "has_sig": false,
        "md5_digest": "6277461e729fa83da5105ec2a6718c6e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 50452,
        "upload_time": "2023-03-06T18:22:26",
        "upload_time_iso_8601": "2023-03-06T18:22:26.996241Z",
        "url": "https://files.pythonhosted.org/packages/3b/a1/0d19b95f39da60af8aa123e0886cb4b578e1b03de64ef2be927c8ea31e01/mhn-0.0.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1cefff4796ee073b5cc45c8393f492654dc7144b79e5348f85cded722984d02e",
          "md5": "ecb74a0707353f09b9ed92e95e5c2b3f",
          "sha256": "ddef3755ce2e2df65826f13a634139edb5b0bf9ca97c14b3ef730419b34fd57e"
        },
        "downloads": -1,
        "filename": "mhn-0.0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "ecb74a0707353f09b9ed92e95e5c2b3f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 52113,
        "upload_time": "2023-03-19T16:25:57",
        "upload_time_iso_8601": "2023-03-19T16:25:57.999409Z",
        "url": "https://files.pythonhosted.org/packages/1c/ef/ff4796ee073b5cc45c8393f492654dc7144b79e5348f85cded722984d02e/mhn-0.0.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1cefff4796ee073b5cc45c8393f492654dc7144b79e5348f85cded722984d02e",
        "md5": "ecb74a0707353f09b9ed92e95e5c2b3f",
        "sha256": "ddef3755ce2e2df65826f13a634139edb5b0bf9ca97c14b3ef730419b34fd57e"
      },
      "downloads": -1,
      "filename": "mhn-0.0.9.tar.gz",
      "has_sig": false,
      "md5_digest": "ecb74a0707353f09b9ed92e95e5c2b3f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 52113,
      "upload_time": "2023-03-19T16:25:57",
      "upload_time_iso_8601": "2023-03-19T16:25:57.999409Z",
      "url": "https://files.pythonhosted.org/packages/1c/ef/ff4796ee073b5cc45c8393f492654dc7144b79e5348f85cded722984d02e/mhn-0.0.9.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}