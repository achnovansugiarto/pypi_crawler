{
  "info": {
    "author": "Don Smiley",
    "author_email": "ds@sidorof.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Environment :: Console",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Adaptive Technologies",
      "Topic :: Scientific/Engineering",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "# Thymus-Timeseries\n\nAn intuitive library tracking dates and timeseries in common using numpy\narrays.\n\nWhen working with arrays of timeseries, the manipulation process can easily cause mismatching sets of arrays in time, arrays in the wrong order, slow down the analysis, and lead to generally spending more time to ensure consistency.\n\nThis library attempts to address the problem in a way that enables ready access to the current date range, but stays out of your way most of the time. Essentially, this library is a wrapper around numpy arrays.\n\nThis library grew out of the use of market and trading data. The timeseries is typically composed of regular intervals but with gaps such as weekends and holidays. In the case of intra-day data, there are interuptions due to periods when the market is closed or gaps in trading.\n\nWhile the library grew from addressing issues associated with market data, the implementation does not preclude use in other venues. Direct access to the numpy arrays is expected and the point of being able to use the library.\n\n## Dependencies\n\nOther than NumPy being installed, there are no other requirements.\n\n## Installation\n\n```pip install thymus-timeseries```\n\n## A Brief Look at Capabilities.\n\n### Creating a Small Sample Timeseries Object\n\nAs a first look, we will create a small timeseries object and show a few ways\nthat it can used. For this example, we will use daily data.\n\nfrom datetime import datetime\nimport numpy as np\n\nfrom thymus.timeseries import Timeseries\n\nts = Timeseries()\n\n#### Elements of Timeseries()\n\n* **key:**  An optional identifier for the timeseries.\n* **columns:** Defaults to None but is an an optional list of column names for the data.\n* **frequency:** Defaults to `d`, the **d** in this case refers to the default daily data. current frequencies supported are `sec`, `min`, `h`, `d`, `w`, `m`, `q`, `y`.\n\n* **dseries:** This is a numpy array of dates in numeric format.\n\n* **tseries:** This is a numpy array of data. most of the work takes place here.\n\n* **end-of-period:**  Defaults to True indicating that the data is as of the end of the period. This only comes into play when converting from one frequency to another and will be ignored for the moment.\n\n\nWhile normal usage of the timeseries object would involve pulling data from a database and inserting data into the timeseries object, we will use a quick-and-dirty method of inputting some data. Dates are stored as either ordinals or timestamps, avoiding clogging up memory with large sets of datetime objects. Because it is daily data, ordinals will be used for this example.\n```\nts = Timeseries()\n\nstart_date = datetime(2015, 12, 31).toordinal()\n\nts.dseries = start_date + np.arange(10)\nts.tseries = np.arange(10)\n\nts.make_arrays()\n```\nWe created an initial timeseries object. It starts at the end of 2015 and continues for 10 days. Setting the values in **dseries** and **tseries** can be somewhat sloppy. For example, a list could be assigned initially to either **dseries** (the dates) and a numpy array to **tseries** (the values).\n\nThe use of the **make_arrays()** function converts the date series to an int32 array (because they are ordinal values) and **tseries** to a float64 array. The idea is that the data might often enter the timeseries object as lists, but then be converted to arrays of appropriate format for use.\n\nThe completed timeseries object is:\n```\n    print(ts)\n\n    <Timeseries>\n    key:\n    columns: None\n    frequency: d\n    daterange: ('2015-12-31', '2016-01-09')\n    end-of-period: True\n    shape: (10,)\n```\nYou can see the date range contained in the date series. The shape refers to the shape of the **tseries** array. **key** and **columns** are free-form, available to update as appropriate to identify the timeseries and content of the columns. Again, the **end-of-period** flag can be ignored right now.\n\n## Selection\n\nSelection of elements is the same as numpy arrays. Currently, our sample has\n10 elements.\n```\n    print(ts[:5])\n\n    <Timeseries>\n    key:\n    columns: []\n    frequency: d\n    daterange: ('2015-12-31', '2016-01-04')\n    end-of-period: True\n    shape: (5,)\n```\nNote how the date range above reflects the selected elements.\n```\nts1 = ts % 2 == 0\nts1.tseries\n[True False True False True False True False True False]\n```\nWe can isolate the dates of even numbers: note that `tseries`, not the timeseries obj, is explicitly used with `np.argwhere`.  More on when to operate directly on tseries later.\n```\nevens = np.argwhere((ts % 2 == 0).tseries)\n\nts_even = ts[evens]\n```\nThis just prints a list of date and value pairs only useful with very small sets (or examples like this)\n```\nprint(ts_even.items('str'))\n\n('2015-12-31', '[0.0]')\n('2016-01-02', '[2.0]')\n('2016-01-04', '[4.0]')\n('2016-01-06', '[6.0]')\n('2016-01-08', '[8.0]')\n```\n\n### Date-based Selection\n\nSo let us use a slightly larger timeseries. 1000 rows 2 columns of data. And,\nuse random values to ensure uselessness.\n```\n    ts = Timeseries()\n\n    start_date = datetime(2015, 12, 31).toordinal()\n\n    ts.dseries = start_date + np.arange(1000)\n    ts.tseries = np.random.random((1000, 2))\n\n    ts.make_arrays()\n\n    print(ts)\n\n    <Timeseries>\n    key:\n    columns: []\n    frequency: d\n    daterange: ('2015-12-31', '2018-09-25')\n    end-of-period: True\n    shape: (1000, 2)\n```\n\nYou can select on the basis of date ranges, but first we will use a row number\ntechnique that is based on slicing. This function is called **trunc()** for\ntruncation.\n\n#### Normal Truncation\nYou will end up with a timeseries with row 100 through 499. This provides in-place execution.\n```\nts.trunc(start=100, finish=500)\n\n# this version returns a new timeseries, effective for chaining.\nts1 = ts.trunc(start=100, finish=500, new=True)\n```\n#### Truncation by Date Range\nBut suppose you want to select a specific date range? This leads to the next\nfunction, **truncdate()**.\n```\n    # select using datetime objects\n    ts1 = ts.truncdate(\n        start=datetime(2017, 1, 1),\n        finish=datetime(2017, 12, 31),\n        new=True)\n\n    print(ts1)\n\n    <Timeseries>\n    key:\n    columns: []\n    frequency: d\n    daterange: ('2017-01-01', '2017-12-31')\n    end-of-period: True\n    shape: (365, 2)\n```\nAs you might expect, the timeseries object has a date range of all the days\nduring 2017. But see how this is slightly different than slicing. When you use\n`truncdate()` it selects everything within the date range *inclusive* of the\nending date as well. The idea is to avoid having to always find one day after\nthe date range that you want to select to accommodate slicing behavior. This\nway is more convenient in this context.\n\nYou can also convert data from a higher frequency to a lower frequency. Suppose we needed monthly data for 2017 from our timeseries.\n\n```\nstart = datetime(2017, 1, 1)\nfinish = datetime(2017, 12, 31)\nts1 = ts.truncdate(start=start, finish=finish, new=True).convert('m')\n\nprint(ts1.items('str'))\n\n('2017-01-31', '[0.1724835781570483, 0.9856812220255055]')\n('2017-02-28', '[0.3855043513164875, 0.30697511661843124]')\n('2017-03-31', '[0.7067982987769881, 0.7680886691626396]')\n('2017-04-30', '[0.07770763295126926, 0.04697651222041588]')\n('2017-05-31', '[0.4473657194650975, 0.49443624153533783]')\n('2017-06-30', '[0.3793816656495891, 0.03646544387811124]')\n('2017-07-31', '[0.2783335012003322, 0.5144979569785825]')\n('2017-08-31', '[0.9261879195281345, 0.6980224313957553]')\n('2017-09-30', '[0.09531834159018227, 0.5435208082899813]')\n('2017-10-31', '[0.6865842769906441, 0.7951735180348887]')\n('2017-11-30', '[0.34901775001111657, 0.7014208950555662]')\n('2017-12-31', '[0.4731393617405252, 0.630488855197775]')\n```\n\nOr yearly. In this case, we use a flag that governs whether to include the partial period leading up to the last year. The default includes it. However, when unwanted the flag, **include_partial** can be set to False.\n```\nts1 = ts.convert('y', include_partial=True)\n\nprint(ts1.items('str'))\n\n('2015-12-31', '[0.2288539210230056, 0.288320541664724]')\n('2016-12-31', '[0.5116274142615629, 0.21680312154651182]')\n('2017-12-31', '[0.4731393617405252, 0.630488855197775]')\n('2018-09-25', '[0.7634145837512148, 0.32026411425902257]')\n\nts2 = ts.convert('y', include_partial=False)\n\nprint(ts2.items('str'))\n\n('2015-12-31', '[[0.2288539210230056, 0.288320541664724]]')\n('2016-12-31', '[[0.5116274142615629, 0.21680312154651182]]')\n('2017-12-31', '[[0.4731393617405252, 0.630488855197775]]')\n```\n\n## Points\nSometimes when examining a `tseries`, a particular point stands out and you want to investigate it further. When was it? Since this package separates dates and values by design, there needs to be a quick way to find this out.\n\nThere are two ways to do this. Suppose the value in question is row 100.\n```\nrow = 100\n# would give you the ordinal/timestamp date\nts.dseries[row]\n\n# gives a datetime object.\ndatetime.fromordinal(ts.dseries[row])\n```\nThis is not particularly difficult, but you do enough times, it feels laborious. To cut down on the typing, there is another way.\n```\nUsage:\n    get_point(rowdate=None, row_no=None)\n\nrow = 100\npoint = ts.get_point(row_no=100)\n\nprint(point)\n\n<Point: row_no: 100, date: 2020-04-10, [48.3886577  48.48543501 48.58221233 48.67898964 48.77576696] />\n\n```\nThis gives all the information in one place, the row number, a meaningful date, and the values of interest.\n\nThe point object created contains attributes:\n* **ts:** The originating timeseries.\n* **row_no:** The location within the data.\n* **date:** This ordinal/timestamp in the data\n* **date_str:** This method shows the date in string format.\n* **datetime:** This method shows the date as datetime object.\n* **values:** The values contained in the row.\n\nNote that the `Point` class is designed to be an active window into your data. Changing an item in values is a direct change to the timeseries.\n\nChanging the `row_no` shifts contents of `values` to reflect the data in the new row.\n\n### Columns\nIf you use columns in your timeseries, you can also improve your output.\n```\nts.columns = [\"dog\", \"cat\", \"squirrel\", \"cow\", \"monkeys\"]\n\nprint(point)\n\n<Point: row_no: 100, date: 2020-04-10,\n  dog: 48.38865769863544\n  cat: 48.48543501403271\n  squirrel: 48.58221232942998\n  cow: 48.678989644827254\n  monkey: 48.77576696022452 />\n```\nThe point object uses the columns of the timeseries to create attributes.\n\nThe point object now has created the following attributes:\n* **ts:** The originating timeseries.\n* **row_no:** The location within the data.\n* **date:** This ordinal/timestamp in the data\n* **date_str:** This method shows the date in string format.\n* **datetime:** This method shows the date as  datetime object.\n* **values:** The values contained in the row.\n\nNew Attributes:\n\n* **dog:** Column 0\n* **cat:** Column 1\n* **squirrel:** Column 2\n* **cow:** Column 3\n* **monkey:** Column 4\n\nJust as `values` is a direct window, these attributes are also a direct window. Changing `point.dog` affects the `tseries[row_no][0]` value.\n\nWith just a few columns of data, it is not hard to remember which is which. However, more columns become increasingly unwieldy.\n\n### Iteration\nBecause the `Point` class automatically changes as the row number changes, it can also be used for iteration. A subclassed Point can provide easy programmatic access for calculations and updates with meaningful variable names.\n\n## Combining Timeseries\n\nSuppose you want to combine multiple timeseries together that are of different lengths? In this case we assume that the two timeseries end on the same date, but one has a longer tail than the other. However, the operation that you need requires common dates.\n\nBy **combine** we mean instead of two timeseries make one timeseries that has\nthe columns of both.\n```\n    ts_short = Timeseries()\n    ts_long = Timeseries()\n\n    end_date = datetime(2016, 12, 31)\n\n    ts_short.dseries = [\n            (end_date + timedelta(days=-i)).toordinal()\n            for i in range(5)]\n\n    ts_long.dseries = [\n            (end_date + timedelta(days=-i)).toordinal()\n            for i in range(10)]\n\n    ts_short.tseries = np.zeros((5))\n    ts_long.tseries = np.ones((10))\n\n    ts_short.make_arrays()\n    ts_long.make_arrays()\n\n    ts_combine = ts_short.combine(ts_long)\n\n    print(ts.items('str'))\n\n    ('2016-12-31', '[0.0, 1.0]')\n    ('2016-12-30', '[0.0, 1.0]')\n    ('2016-12-29', '[0.0, 1.0]')\n    ('2016-12-28', '[0.0, 1.0]')\n    ('2016-12-27', '[0.0, 1.0]')\n```\nThe combine function has a couple variations. While it can be helpful to automatically discard the unwanted rows, you can also enforce that combining does not take place if the number of rows do not match. Also, you can build out the missing information with padding to create a timeseries that has\nthe length of the longest timeseries.\n```\n# this would raise an error -- the two are different lengths\nts_combine = ts_short.combine(ts_long discard=False)\n\n# this combines, and fills 99 as a missing value\nts_combine = ts_short.combine(ts_long discard=False, pad=99)\n\nprint(ts_combine.items('str'))\n('2016-12-31', '[0.0, 1.0]')\n('2016-12-30', '[0.0, 1.0]')\n('2016-12-29', '[0.0, 1.0]')\n('2016-12-28', '[0.0, 1.0]')\n('2016-12-27', '[0.0, 1.0]')\n('2016-12-26', '[99.0, 1.0]')\n('2016-12-25', '[99.0, 1.0]')\n('2016-12-24', '[99.0, 1.0]')\n('2016-12-23', '[99.0, 1.0]')\n('2016-12-22', '[99.0, 1.0]')\n```\nThe combining can also receive multiple timeseries.\n```\nts_combine = ts_short.combine([ts_long, ts_long, ts_long])\n\nprint(ts_combine.items('str'))\n('2016-12-31', '[0.0, 1.0, 1.0, 1.0]')\n('2016-12-30', '[0.0, 1.0, 1.0, 1.0]')\n('2016-12-29', '[0.0, 1.0, 1.0, 1.0]')\n('2016-12-28', '[0.0, 1.0, 1.0, 1.0]')\n('2016-12-27', '[0.0, 1.0, 1.0, 1.0]')\n```\n## Splitting Timeseries\n\nIn some ways it would make sense to mirror the **combine()** function\nwith a **split()** from an aesthetic standpoint. However, splitting is very\nstraight-forward without such a function. For example, suppose you want a\ntimeseries that only has the the first two columns from our previous example.\nAs you can see in the ts_split tseries, the first two columns were taken.\n```\n    ts_split = ts_combine[:, :2]\n\n    print(ts_split.items('str'))\n    ('2016-12-31', '[0.0, 1.0]')\n    ('2016-12-30', '[0.0, 1.0]')\n    ('2016-12-29', '[0.0, 1.0]')\n    ('2016-12-28', '[0.0, 1.0]')\n    ('2016-12-27', '[0.0, 1.0]')\n```\n\n## Arithmetic Operations\n\nWe have combined timeseries together to stack up rows in common. In\naddition, we looked at the issue of mismatched lengths. Now we will look at\narithmetic approaches and some of the design decisions and tradeoffs associated\nwith mathematical operations.\n\nWe will start with the **add()** function. First, if we assume that all we are\nadding together are arrays that have exactly the same dateseries, and\ntherefore the same length, and we assume they have exactly the same number of\ncolumns, then the whole question becomes trivial. If we relax those\nconstraints, then some choices need to be made.\n\nWe will use the long and short timeseries from the previous example.\n```\n    # this will fail due to dissimilar lengths\n    ts_added = ts_short.add(ts_long, match=True)\n\n    # this will work\n    ts_added = ts_short.add(ts_long, match=False)\n\n    [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]\n```\nThe **add()** function checks to see if the number of columns match. If they do\nnot an error is raised. If the **match** flag is True, then it also checks\nthat all the dates in both timeseries match prior to the operation.\n\nIf **match** is False, then as long as the columns are compatible, the\noperation can take place. It also supports the concept of sparse arrays as\nwell. For example, suppose you have a timeseries that is primary, but you would\nlike to add in a timeseries values from only a few dates within the range. This\nfunction will find the appropriate dates adding in the values at just those\nrows.\n\nTo summarize, all dates in common to both timeseries will be included in the\nnew timeseries if **match** is False.\n\nBecause the previous function is somewhat specialized, you can assume that the\nchecking of common dates and creating the new timeseries can be somewhat slower\nthan other approaches.\n\nIf we assume some commonalities about our timeseries, then we can do our work\nin a more intuitive fashion.\n\n### Assumptions of Commonality\n\nLet us assume that our timeseries might be varying in length, but we absolutely\nknow what either our starting date or ending date is. And, let us assume that\nall the dates for the periods in common to the timeseries match.\n\nIf we accept those assumptions, then a number of operations become quite easy.\n\nThe timeseries object can accept simple arithmetic as if it is an array. It\nautomatically passes the values on to the **tseries** array. If the two arrays\nare not the same length the longer array is truncated to the shorter length. So\nif you were add two arrays together that end at the same date, you would want\nto sort them latest date to earliest date using the function\n**sort_by_date()**.\n\n### Examples\n```\n# starting tseries\nts.tseries\n[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9.]\n\n(ts + 3).tseries\n[  3.   4.   5.   6.   7.   8.   9.  10.  11.  12.]\n\n# Also, reverse (__radd__)\n(3 + ts).tseries\n[  3.   4.   5.   6.   7.   8.   9.  10.  11.  12.]\n\n# of course not just addition\n5 * ts.tseries\n[  0.   5.  10.  15.  20.  25.  30.  35.  40.  45.]\n```\nAlso, in-place operations. But first, we will make a copy.\n```\nts1 = ts.clone()\nts1.tseries /= 3\nprint(ts1.tseries)\n[0.0\n0.3333333333333333\n0.6666666666666666\n1.0\n1.3333333333333333\n1.6666666666666667\n2.0\n2.3333333333333335\n2.6666666666666665\n3.0]\n\nts1 = ts ** 3\nts1.tseries\n0.0\n1.0\n8.0\n27.0\n64.0\n125.0\n216.0\n343.0\n512.0\n729.0\n\nts1 = 10 ** ts\nts1.tseries\n[1.0\n10.0\n100.0\n1000.0\n10000.0\n100000.0\n1000000.0\n10000000.0\n100000000.0\n1000000000.0]\n```\n\nIn other words, the normal container functions you can use with numpy arrays\nare available to the timeseries objects. The following container functions for\narrays are supported.\n```\n__pow__ __add__ __rsub__ __sub__    __eq__      __ge__   __gt__   __le__\n__lt__  __mod__ __mul__  __ne__     __radd__    __rmod__ __rmul__ __rpow__\n__abs__ __pos__ __neg__  __invert__ __rdivmod__ __rfloordiv__\n__floordiv__ __truediv__\n__rtruediv__ __divmod__\n\n__and__ __or__ __ror__ __rand__ __rxor__ __xor__ __rshift__\n__rlshift__ __lshift__ __rrshift__\n\n__iadd__ __ifloordiv__ __imod__ __imul__ __ipow__ __isub__\n__itruediv__]\n\n__iand__ __ilshift__ __ior__ __irshift__ __ixor__\n```\n### Functions of Arrays Not Supported\n\nThe purpose the timeseries objects is to implement an intuitive usage of\ntimeseries objects in a fashion that is consistent with NumPy. However, it is\nnot intended to replace functions that are better handled explicitly with\nthe **dseries** and **tseries** arrays directly. The difference will be clear\nby comparing the list of functions for the timeseries object versus a numpy array. Most of the functions of the timeseries object is related to handling the commonality of date series with time series. You can see that the bulk of the thymus functions relate to maintenance of the coordination betwee the date series and timeseries. The meat of the functions still lie with the\nnumpy arrays by design.\n\n```\n# timeseries members and functions:\nts.add                   ts.daterange             ts.get_pcdiffs           ts.series_direction\nts.as_dict               ts.datetime_series       ts.header                ts.set_ones\nts.as_json               ts.dseries               ts.if_dseries_match      ts.set_zeros\nts.as_list               ts.end_date              ts.if_tseries_match      ts.shape\nts.clone                 ts.end_of_period         ts.items                 ts.sort_by_date\nts.closest_date          ts.extend                ts.key                   ts.start_date\nts.columns               ts.fmt_date              ts.lengths               ts.trunc\nts.combine               ts.frequency             ts.make_arrays           ts.truncdate\nts.common_length         ts.get_date_series_type  ts.months                ts.tseries\nts.convert               ts.get_datetime          ts.replace               ts.years\nts.date_native           ts.get_diffs             ts.reverse\nts.date_string_series    ts.get_duped_dates       ts.row_no\n\n# numpy functions in the arrays\nts.tseries.T             ts.tseries.cumsum        ts.tseries.min           ts.tseries.shape\nts.tseries.all           ts.tseries.data          ts.tseries.nbytes        ts.tseries.size\nts.tseries.any           ts.tseries.diagonal      ts.tseries.ndim          ts.tseries.sort\nts.tseries.argmax        ts.tseries.dot           ts.tseries.newbyteorder  ts.tseries.squeeze\nts.tseries.argmin        ts.tseries.dtype         ts.tseries.nonzero       ts.tseries.std\nts.tseries.argpartition  ts.tseries.dump          ts.tseries.partition     ts.tseries.strides\nts.tseries.argsort       ts.tseries.dumps         ts.tseries.prod          ts.tseries.sum\nts.tseries.astype        ts.tseries.fill          ts.tseries.ptp           ts.tseries.swapaxes\nts.tseries.base          ts.tseries.flags         ts.tseries.put           ts.tseries.take\nts.tseries.byteswap      ts.tseries.flat          ts.tseries.ravel         ts.tseries.tobytes\nts.tseries.choose        ts.tseries.flatten       ts.tseries.real          ts.tseries.tofile\nts.tseries.clip          ts.tseries.getfield      ts.tseries.repeat        ts.tseries.tolist\nts.tseries.compress      ts.tseries.imag          ts.tseries.reshape       ts.tseries.tostring\nts.tseries.conj          ts.tseries.item          ts.tseries.resize        ts.tseries.trace\nts.tseries.conjugate     ts.tseries.itemset       ts.tseries.round         ts.tseries.transpose\nts.tseries.copy          ts.tseries.itemsize      ts.tseries.searchsorted  ts.tseries.var\nts.tseries.ctypes        ts.tseries.max           ts.tseries.setfield      ts.tseries.view\nts.tseries.cumprod       ts.tseries.mean          ts.tseries.setflags\n```\n### Other Date Functions\n\nVariations on a theme:\n```\n# truncation\nts.truncdate(\n    start=datetime(2017, 1, 1),\n    finish=datetime(2017, 12, 31))\n\n# just start date etc.\nts.truncdate(\n    start=datetime(2017, 1, 1))\n\n# this was in date order but suppose it was in reverse order?\n# this result will give the same answer\nts1 = ts.truncdate(\n    start=datetime(2017, 1, 1),\n    new=True)\n\nts.reverse()\n\nts1 = ts.truncdate(\n    start=datetime(2017, 1, 1),\n    new=True)\n\n# use the date format native to the dateseries (ordinal / timestamp)\nts1 = ts.truncdate(\n    start=datetime(2017, 1, 1).toordinal(),\n    new=True)\n\n# suppose you start with a variable that represents a date range\n# date range can be either a list or tuple\nts.truncdate(\n    [datetime(2017, 1, 1), datetime(2017, 12, 31)])\n```\n## Assorted Date Functions\n```\n# native format\nts.daterange()\n(735963, 735972)\n\n# str format\nts.daterange('str')\n('2015-12-31', '2016-01-09')\n\n# datetime format\nts.daterange('datetime')\n(datetime.datetime(2015, 12, 31, 0, 0), datetime.datetime(2016, 1, 9, 0, 0))\n\n# native format\nts.start_date(); ts.end_date()\n735963  735972\n\n# str format\nts.start_date('str'); ts.end_date('str')\n2015-12-31  2016-01-09\n\n# datetime format\nts.start_date('datetime'); ts.end_date('datetime')\n2015-12-31 00:00:00  2016-01-09 00:00:00\n```\nSometimes it is helpful to find a particular row based on the date. Also, that date might not be in the dateseries, and so, the closest date will suffice.\n\nWe will create a sample timeseries to illustrate.\n```\nts = Timeseries()\nts.dseries = []\nts.tseries = []\n\nstart_date = datetime(2015, 12, 31)\nfor i in range(40):\n    date = start_date + timedelta(days=i)\n    if date.weekday() not in [5, 6]:   # skipping weekends\n\n        ts.dseries.append(date.toordinal())\n        ts.tseries.append(i)\n\nts.make_arrays()\n\n# row_no, date\n(0, '2015-12-31')\n(1, '2016-01-01')\n(2, '2016-01-04')\n(3, '2016-01-05')\n(4, '2016-01-06')\n(5, '2016-01-07')\n(6, '2016-01-08')\n(7, '2016-01-11')\n(8, '2016-01-12')\n(9, '2016-01-13')\n(10, '2016-01-14')\n(11, '2016-01-15')\n(12, '2016-01-18')\n(13, '2016-01-19')\n(14, '2016-01-20')\n(15, '2016-01-21')\n(16, '2016-01-22')\n(17, '2016-01-25')\n(18, '2016-01-26')\n(19, '2016-01-27')\n(20, '2016-01-28')\n(21, '2016-01-29')\n(22, '2016-02-01')\n(23, '2016-02-02')\n(24, '2016-02-03')\n(25, '2016-02-04')\n(26, '2016-02-05')\n(27, '2016-02-08')\n\ndate1 = datetime(2016, 1, 7)    # existing date within date series\ndate2 = datetime(2016, 1, 16)   # date falling on a weekend\ndate3 = datetime(2015, 6, 16)   # date prior to start of date series\ndate4 = datetime(2016, 3, 8)    # date after to end of date series\n\n# as datetime and in the series\nexisting_row = ts.row_no(rowdate=date1, closest=1)\n5\n\nexisting_date = ts.closest_date(rowdate=date1, closest=1)\nprint(datetime.fromordinal(existing_date))\n2016-01-07 00:00:00\n\n# as datetime but date not in series\nnext_row = ts.row_no(rowdate=date2, closest=1)\n12\n\nnext_date = ts.closest_date(rowdate=date2, closest=1)\nprint(datetime.fromordinal(next_date))\n2016-01-18 00:00:00\n\nprev_row = ts.row_no(rowdate=date2, closest=-1)\n11\n\nprev_date = ts.closest_date(rowdate=date2, closest=-1)\nprint(datetime.fromordinal(prev_date))\n2016-01-15 00:00:00\n\n# this will fail -- date is outside the date series\n# as datetime but date not in series, look for earlier date\nts.closest_date(rowdate=date3, closest=-1)\n\n# this will fail -- date is outside the date series\nts.closest_date(rowdate=date4, closest=1)\n```\n## Functions by Category\n\n### Output\n\n#### Timeseries\n##### **ts.to_dict()**\n\nReturns the time series as a dict with the date as the key.\n\nUsage:\n    self.to_dict(dt_fmt=None, data_list=False)\n\nThis has been reworked to include all fields of the timeseries\nrather than just dates and times, so header informtion is now included.\n\nFor flexibility, the date can be formatted in various ways:\n* dt_fmt=None Native format depending on frequency                         but converted to string.\n* dt_fmt='datetime' Datetime objects.\n* dt_fmt='str' Converts dates to string using constants                         `timeseries.FMT_DATE` or `timeseries.FMT_IDATE`, depending on the timeseries type.\n\n* data_list A boolean that signals whether dates should be used as keys in a dict for the values, or whether the dates and values are output as a list.\n\nThis matters because some operations are necessary to target\nspecific dates, but it does not preserve order. Or, if data_list\nis True, then the combination of dates and values are output as\na list and order is maintained.\n\n##### **ts.to_json()**\n\nThis function returns the timeseries in JSON format.\n\nUsage:\n    self.as_json(indent=2, dt_fmt=str, data_list=True)\n\ndt_fmt options are the same as for to_dict\n\n##### **ts.to_list()**\n\nReturns the timeseries as a list.\n\n#### Point\n##### **point.to_dict()**\nThis function returns a dict of the point variables.\n\nUsage:\n    to_dict(dt_fmt=None)\n\nParameters:\n    dt_fmt: (None|str) : Format choice is \"str\" or \"datetime\"\n\nReturns:\n    point (dict)\n\nTypical output:\n```\npoint.to_dict(dt_fmt=\"str\")\n\n{\n  \"row_no\": 100,\n  \"date\": \"2020-04-10\",\n  \"dog\": 48.38865769863544,\n  \"cat\": 48.48543501403271,\n  \"squirrel\": 48.58221232942998,\n  \"cow\": 48.678989644827254,\n  \"monkeys\": 48.77576696022452\n}\n\n```\n\n### Miscellaneous\n#### ts.header()\n\nThis function returns a dict of the non-timeseries data.\n\n#### ts.items(fmt=None)\n\nThis function returns the date series and the time series as if it\nis in one list. The term items used to suggest the iteration of dicts\nwhere items are the key, value combination.\n\nif fmt == 'str':\n    the dates are output as strings\n\n#### ts.months(include_partial=True)\n\nThis function provides a quick way to summarize daily (or less)\nas monthly data.\n\nIt is basically a pass-through to the convert function with more\ndecoration of the months.\n\nUsage:\n\n    months(include_partial=True)\n\n    returns a dict with year-month as keys\n\n#### ts.years(include_partial=True)\n\nThis function provides a quick way to summarize daily (or less)\nas yearly data.\n\nIt is basically a pass-through to the convert function with more\ndecoration of the years.\n\nUsage:\n\nyears(include_partial=True)\n\nreturns a dict with year as keys\n\n#### ts.datetime_series()\n\nThis function returns the dateseries converted to a list of\ndatetime objects.\n\n#### ts.date_string_series(dt_fmt=None)\n\nThis function returns a list of the dates in the timeseries as\nstrings.\n\nUsage:\n    self.date_string_series(dt_fmt=None)\n\ndt_fmt is a datetime mask to alter the default formatting.\n\n### Array Manipulation\n\n#### ts.add(ts, match=True)\n\nAdds two timeseries together.\n\nif match is True:\n    means there should be a one to one corresponding date in each time\n    series.  If not raise error.\nelse:\n    means that timeseries with sporadic or missing dates can be added\n\nNote: this does not evaluate whether both timeseries have the same\n        number of columns. It will fail if they do not.\n\nReturns the timeseries. Not in-place.\n\n#### ts.clone()\n\nThis function returns a copy of the timeseries.\n\n#### ts.combine(tss, discard=True, pad=None)\n\nThis function combines timeseries into a single array. Combining in\nthis case means accumulating additional columns of information.\n\nTruncation takes place at the end of rows. So if the timeseries is\nsorted from latest dates to earliest dates, the older values would be\nremoved.\n\nUsage:\n    self.combine(tss, discard=True, pad=None)\n\nThink of tss as the plural of timeseries.\n\nIf discard:\n    Will truncate all timeseries lengths down to the shortest\n    timeseries.\n\nif discard is False:\n    An error will be raised if the all the lengths do not match\n\n    unless:\n        if pad is not None:\n            the shorter timeseries will be padded with the value pad.\n\nReturns the new ts.\n\n#### ts.common_length(*ts)\n\nThis static method trims the lengths of timeseries and returns the\ntimeseries trimmed to the same length.\n\nThe idea is that in order to do array operations there must be a\ncommon length for each timeseries.\n\nReflecting the bias for using timeseries sorted from latest info to\nearlier info, truncation takes place at the end of the array. That\nway older less important values are removed if necessary.\n\nUsage:\n    ts1_new, ts2_new = self.common_length(ts1, ts2)\n    [ts1, ts2, ..., ts_n] = self.common_length(*ts)\n\n#### ts.convert(new_freq, include_partial=True, **kwargs)\n\nThis function returns the timeseries converted to another frequency,\nsuch as daily to monthly.\n\nUsage:\n    convert(new_freq, include_partial=True, **kwargs)\n\nThe only kwarg is\n    weekday=<some value>\n\nThis is used when converting to weekly data. The weekday number\ncorresponds to the the datetime.weekday() function.\n\n#### ts.extend(ts, overlay=True)\n\nThis function combines a timeseries to another, taking into account the\npossibility of overlap.\n\nThis assumes that the frequency is the same.\n\nThis function is chiefly envisioned to extend a timeseries with\nadditional dates.\n\nUsage:\n    self.extend(ts, overlay=True)\n\nIf overlay is True then the incoming timeseries will overlay\nany values that are duplicated.\n\n#### ts.trunc(start=None, finish=None, new=False)\n\nThis function truncates in place, typically.\n\ntruncate from (start:finish)\nremember start is lowest number, latest date\n\nThis truncation works on the basis of slicing, so\nfinish is not inclusive.\n\nUsage:\n    self.trunc(start=None, finish=None, new=False)\n\n#### ts.truncdate(start=None, finish=None, new=False)\n\nThis function truncates in place on the basis of dates.\n\nUsage:\n    self.truncdate(start=None, finish=None, new=False)\n\nstart and finish are dates, input as either datetime or the actual\ninternal format of the **dseries** (ordinals or timestamps).\n\nIf the dates are not actually in the list, the starting date will\nbe the next viable date after the start date requested. If the finish\ndate is not available, the previous date from the finish date will be\nthe last.\n\nIf new is True, the timeseries will not be modified in place. Rather\na new timeseries will be returned instead.\n\n#### ts.replace(ts, match=True)\n\nThis function replaces values where the dates match an incoming\ntimeseries. So if the incoming date on the timeseries matches, the\nvalue in the current timeseries will be replaced by the incoming\ntimeseries.\n\nUsage:\n    self.replace(ts, match=True)\n\nIf match is False, the incoming timseries may have dates not found in\nthe self timeseries.\n\nReturns the modified timeseries. Not in place.\n\n#### ts.reverse()\n\n        This function does in-place reversal of the timeseries and dateseries.\n\n#### ts.get_diffs()\n\nThis function gets the differences between values from date to date in\nthe timeseries.\n\n#### ts.get_pcdiffs()\n\nThis function gets the percent differences between values in the\ntimeseries.\n\nNo provision for dividing by zero here.\n\n#### ts.set_ones(fmt=None, new=False)\n\nThis function converts an existing timeseries to ones using the same\nshape as the existing timeseries.\n\nIt is used as a convenience to create an empty timeseries with a\nspecified date range.\n\nif fmt use as shape\n\nusage:\n    set_ones(self, fmt=None, new=False)\n\n#### ts.set_zeros(fmt=None, new=False)\n\nThis function converts an existing timeseries to zeros using the same\nshape as the existing timeseries.\n\nIt is used as a convenience to create an empty timeseries with a\nspecified date range.\n\nif fmt use as shape\n\nusage:\n    set_zeros(self, fmt=None, new=False)\n\n#### ts.sort_by_date(reverse=False, force=False)\n\nThis function converts a timeseries to either date order or reverse\ndate order.\n\nUsage:\n    sort_by_date(self, reverse=False, force=False)\n\nIf reverse is True, then order will be newest to oldest.\nIf force is False, the assumption is made that comparing the first\nand last date will determine the current order of the timeseries. That\nwould mean that unnecessary sorting can be avoided. Also, if the order\nneeds to be reversed, the sort is changed via the less expensive\nreverse function.\n\nIf dates and values are in no particular order, with force=True, the\nactual sort takes place.\n\nThis function changes the data in-place.\n\n### Evaluation\n\n#### ts.daterange(fmt=None)\n\nThis function returns the starting and ending dates of the timeseries.\n\nUsage:\n\n    self.daterange()\n        (735963, 735972)\n\n    self.daterange('str')\n        ('2015-12-31', '2016-01-09')\n\n    self.daterange('datetime')\n        (datetime(2015, 12, 31, 0, 0),\n         datetime.datetime(2016, 1, 9, 0, 0))\n\n#### ts.start_date(fmt=None)\n\nThis function returns the starting date of the timeseries in its\nnative value, timestamp or ordinal.\n\nIf fmt is 'str' returns in string format\nIf fmt is 'datetime' returns in string format\n\n#### ts.end_date(fmt=None)\n\nThis funtcion returns the ending date of the timeseries in its native\nvalue, timestamp or ordinal.\n\nIf fmt is 'str' returns in string format\nIf fmt is 'datetime' returns in string format\n\n#### ts.get_duped_dates()\n\nThis function pulls dates that are duplicated. This is to be used to\nlocate timeseries that are faulty.\n\nUsage:\n    get_duped_dates()\n\n    returns [[odate1, count], [odate2, count]]\n\n#### ts.series_direction()\n\nif a lower row is a lower date, then 1 for ascending\nif a lower row is a higher date then -1 for descending\n\n#### ts.get_date_series_type()\n\nThis function returns the date series type associated with the\ntimeseries.  The choices are TS_ORDINAL or TS_TIMESTAMP.\n\n#### ts.if_dseries_match(ts)\n\nThis function returns True if the date series are the same.\n\n#### ts.if_tseries_match(ts)\n\nThis function returns True if the time series are the same.\n\n### Utilities\n\n#### ts.date_native(date)\n\nThis awkwardly named function returns a date in the native format of the timeseries, namely ordinal or timestamp.\n\n#### ts.row_no(rowdate, closest=0, no_error=False)\n\nShows the row in the timeseries\n\nUsage:\n    ts.row(rowdate=<datetime>)\n    ts.row(rowdate=<date as either ordinal or timestamp>)\n\nReturns an error if the date is not found in the index\n\nif closest is invoked:\n    closest = 1\n        find the closest date after the rowdate\n    closest = -1\n        find the closest date before the rowdate\n\nIf no_error\n    returns -1 instead of raising an error if the date was\n    outside of the timeseries.\n\n#### ts.get_datetime(date)\n\nThis function returns a date as a datetime object. This takes into account the type of date stored in **dseries**.\n\nUsage:\n    self.get_datetime(date)\n\n#### ts.lengths()\n\nThis function returns the lengths of both the date series and time series. Both numbers are included in case a mismatch has occurred.\n\n#### ts.shape()\n\nThis function return the shape of the timeseries. This is a shortcut\nto putting in ts.tseries.shape.\n\n#### ts.fmt_date(numericdate, dt_type, dt_fmt=None)\n\nThis static method accepts a date and converts it to the format used in the timeseries.\n\n#### ts.make_arrays()\n\nConvert the date and time series lists (if so) to numpy arrays\n\n#### ts.get_fromDB(**kwargs)\n\nThis is just a stub to suggest a viable name for getting data from a database.\n\n#### ts.save_toDB(**kwargs):\n\nThis is just a stub to suggest a viable name for saving data to a database.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://sidorof.github.io/Thymus-timeseries/",
    "keywords": "timeseries,time series",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "thymus-timeseries",
    "package_url": "https://pypi.org/project/thymus-timeseries/",
    "platform": "",
    "project_url": "https://pypi.org/project/thymus-timeseries/",
    "project_urls": {
      "Homepage": "https://sidorof.github.io/Thymus-timeseries/"
    },
    "release_url": "https://pypi.org/project/thymus-timeseries/0.2.5/",
    "requires_dist": [
      "numpy",
      "check-manifest ; extra == 'dev'",
      "unittest ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "An intuitive library tracking dates and timeseries in common using NumPy arrays.",
    "version": "0.2.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9274632,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7dc30aa4805f69955b2bea48759fd618fd3a7c170685c68442d937400187d815",
          "md5": "5d57d4be4789951d2469fde2c75c2dde",
          "sha256": "fd3078e59f60c789c284b3de68b5600309a140421435a79b03552f537f804e60"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.1.0.linux-x86_64.tar.gz",
        "has_sig": false,
        "md5_digest": "5d57d4be4789951d2469fde2c75c2dde",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 36435,
        "upload_time": "2016-09-03T18:34:35",
        "upload_time_iso_8601": "2016-09-03T18:34:35.961002Z",
        "url": "https://files.pythonhosted.org/packages/7d/c3/0aa4805f69955b2bea48759fd618fd3a7c170685c68442d937400187d815/thymus-timeseries-0.1.0.linux-x86_64.tar.gz",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a5823d5aeb39b80894f088109d638a9697b89e9cbcfc6f4e15e4e116b4f3799e",
          "md5": "8b44e52b31efbc8ca90728442d47ed0c",
          "sha256": "ad757d46ae206c7f5f75adbe59587290b0da998b8e924eea799c4cfa80f524ba"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "8b44e52b31efbc8ca90728442d47ed0c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 62212,
        "upload_time": "2016-09-03T18:34:39",
        "upload_time_iso_8601": "2016-09-03T18:34:39.150265Z",
        "url": "https://files.pythonhosted.org/packages/a5/82/3d5aeb39b80894f088109d638a9697b89e9cbcfc6f4e15e4e116b4f3799e/thymus-timeseries-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "12f896e69c8c74d5a3638e7661e4e59f790008018c4898279bd5fbfc471729b5",
          "md5": "0950d0817ec08d54dd56b4f38b94835a",
          "sha256": "aad5d79a24e01dae9f62f7b1c394db43afff26ce1b46008f4e0d5c85974b7973"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0950d0817ec08d54dd56b4f38b94835a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 62434,
        "upload_time": "2016-09-07T14:01:56",
        "upload_time_iso_8601": "2016-09-07T14:01:56.587821Z",
        "url": "https://files.pythonhosted.org/packages/12/f8/96e69c8c74d5a3638e7661e4e59f790008018c4898279bd5fbfc471729b5/thymus-timeseries-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "14abd8cdbdaa624d8e6266505923f9e4d193d0d14afe0ecbbed65e40f462719b",
          "md5": "450a86303d93b998d6f33441f8c1c4b0",
          "sha256": "9316aab0e02a9e3242783ae3afd1f55eaf7c05e2b00e96321018ef2d8a631d31"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "450a86303d93b998d6f33441f8c1c4b0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 29684,
        "upload_time": "2019-06-02T03:04:59",
        "upload_time_iso_8601": "2019-06-02T03:04:59.166122Z",
        "url": "https://files.pythonhosted.org/packages/14/ab/d8cdbdaa624d8e6266505923f9e4d193d0d14afe0ecbbed65e40f462719b/thymus_timeseries-0.1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d54b44f2270ecb356ca21540291984d41d25f024f0eb7ed76c41e2fc99339005",
          "md5": "4fcf42665b393c1ba922d69cba4f4710",
          "sha256": "b0a236b27e7e3738a97253c17faf9071d3f695ccc94a197a5b71756c5d1c8dd1"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "4fcf42665b393c1ba922d69cba4f4710",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 140721,
        "upload_time": "2019-06-02T03:05:03",
        "upload_time_iso_8601": "2019-06-02T03:05:03.102089Z",
        "url": "https://files.pythonhosted.org/packages/d5/4b/44f2270ecb356ca21540291984d41d25f024f0eb7ed76c41e2fc99339005/thymus-timeseries-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ed745ffbe9183984edb8edac2da91a84ff508d56d03845e3c5789e6748945989",
          "md5": "52d159b0ed0062bc83727272f6bd86a1",
          "sha256": "b95ab752d6408fc9ddef55200572f43274f9dd184ae2611509996df958eb9b79"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.0-py3.7.egg",
        "has_sig": false,
        "md5_digest": "52d159b0ed0062bc83727272f6bd86a1",
        "packagetype": "bdist_egg",
        "python_version": "3.7",
        "requires_python": null,
        "size": 54791,
        "upload_time": "2020-10-25T21:41:45",
        "upload_time_iso_8601": "2020-10-25T21:41:45.176308Z",
        "url": "https://files.pythonhosted.org/packages/ed/74/5ffbe9183984edb8edac2da91a84ff508d56d03845e3c5789e6748945989/thymus_timeseries-0.2.0-py3.7.egg",
        "yanked": true,
        "yanked_reason": "Typo"
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0ff18be40b4c9b425d235987e36b7702647e82732a3092fe5c553703a1064fb3",
          "md5": "2c39006204cfe81cf2722308904726e0",
          "sha256": "65223695de207231f22f2d81f7f9b31d189661a8bbbe76a68c62efb8113fcc22"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.1-py3.7.egg",
        "has_sig": false,
        "md5_digest": "2c39006204cfe81cf2722308904726e0",
        "packagetype": "bdist_egg",
        "python_version": "3.7",
        "requires_python": null,
        "size": 54795,
        "upload_time": "2020-10-25T21:51:13",
        "upload_time_iso_8601": "2020-10-25T21:51:13.298551Z",
        "url": "https://files.pythonhosted.org/packages/0f/f1/8be40b4c9b425d235987e36b7702647e82732a3092fe5c553703a1064fb3/thymus_timeseries-0.2.1-py3.7.egg",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e35395ba76a87dead6c50951eb375efce495e784bf11de7c61eff802927accac",
          "md5": "2e987114749a49430a740b6fb87a22e5",
          "sha256": "a4f2ddbbb1d82e68ed67ed384d39375c104ef5551386ba891de35bae49287bf6"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.2-py3.7.egg",
        "has_sig": false,
        "md5_digest": "2e987114749a49430a740b6fb87a22e5",
        "packagetype": "bdist_egg",
        "python_version": "3.7",
        "requires_python": null,
        "size": 54830,
        "upload_time": "2020-10-26T01:19:15",
        "upload_time_iso_8601": "2020-10-26T01:19:15.017458Z",
        "url": "https://files.pythonhosted.org/packages/e3/53/95ba76a87dead6c50951eb375efce495e784bf11de7c61eff802927accac/thymus_timeseries-0.2.2-py3.7.egg",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5f07172fc2ccd34861df92b6923dcf485397ec13fbe4ce8dd37e3082fe7f8d4e",
          "md5": "9ea4cf2dd7757843bd173f08c5d66549",
          "sha256": "09909af79205dfb330064f06894f19350e4c733b4edee04cd0a631e98e0d5cb5"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9ea4cf2dd7757843bd173f08c5d66549",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 30005,
        "upload_time": "2020-10-26T01:19:12",
        "upload_time_iso_8601": "2020-10-26T01:19:12.706787Z",
        "url": "https://files.pythonhosted.org/packages/5f/07/172fc2ccd34861df92b6923dcf485397ec13fbe4ce8dd37e3082fe7f8d4e/thymus_timeseries-0.2.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6c720e3344e02d150d461e8236851bf91045a048584fa175a7c930b870fe2a4b",
          "md5": "a421e25908edafb9f86a18f307a737a6",
          "sha256": "ad33c36ccf1390df36811eb8b3c4c5324dda66fd5b653e92a4a6de468ccb3d8c"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a421e25908edafb9f86a18f307a737a6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 109555,
        "upload_time": "2020-10-26T01:19:18",
        "upload_time_iso_8601": "2020-10-26T01:19:18.188401Z",
        "url": "https://files.pythonhosted.org/packages/6c/72/0e3344e02d150d461e8236851bf91045a048584fa175a7c930b870fe2a4b/thymus-timeseries-0.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8b05d928f1f3f9487260c276f8f4c2296b64be4bdd0628de365779bc615b2607",
          "md5": "ea336ec3e2dd0ab962fc65c96a249c03",
          "sha256": "7f56cdf0713ed041b72e68d8e2d9dc254b33170dd842d6df8cd070e25f438153"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.3-py3.7.egg",
        "has_sig": false,
        "md5_digest": "ea336ec3e2dd0ab962fc65c96a249c03",
        "packagetype": "bdist_egg",
        "python_version": "3.7",
        "requires_python": null,
        "size": 55021,
        "upload_time": "2020-10-26T15:45:15",
        "upload_time_iso_8601": "2020-10-26T15:45:15.750194Z",
        "url": "https://files.pythonhosted.org/packages/8b/05/d928f1f3f9487260c276f8f4c2296b64be4bdd0628de365779bc615b2607/thymus_timeseries-0.2.3-py3.7.egg",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4c2e1b9d4d696b7b616a351f9e0d6522bb73a2ea288dc4d471ce1bb7e9457b09",
          "md5": "a632b3169eaa41cf0acebc6296d39126",
          "sha256": "37fffef1c381b97be9600611c90b4b6fcbf59636dd495470be7bae54b9bae60b"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a632b3169eaa41cf0acebc6296d39126",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 30088,
        "upload_time": "2020-10-26T15:45:13",
        "upload_time_iso_8601": "2020-10-26T15:45:13.008714Z",
        "url": "https://files.pythonhosted.org/packages/4c/2e/1b9d4d696b7b616a351f9e0d6522bb73a2ea288dc4d471ce1bb7e9457b09/thymus_timeseries-0.2.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1560b10653ceb2544eaa21baf25a80c4facbdc6f5eb23702f3f5129967b96ee5",
          "md5": "acb2eac4082aa7444618e20cd0d5c18e",
          "sha256": "2b67f75e7fd71613e5ab8e2311cfb37bfe6989836b1a7b84ab9479d3a08bd9b5"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "acb2eac4082aa7444618e20cd0d5c18e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 110104,
        "upload_time": "2020-10-26T15:45:18",
        "upload_time_iso_8601": "2020-10-26T15:45:18.785178Z",
        "url": "https://files.pythonhosted.org/packages/15/60/b10653ceb2544eaa21baf25a80c4facbdc6f5eb23702f3f5129967b96ee5/thymus-timeseries-0.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "82ecf9f18d1f0bd0e1969692a1f7a266e548a348a40382ea30b0e1132bb41291",
          "md5": "6aab6c7f0d0c5d2339e9647bc80f91e3",
          "sha256": "88fb93e5fdf5d181c9753483026a1805ee46321ca93431db887c4694800366d5"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.4-py3.7.egg",
        "has_sig": false,
        "md5_digest": "6aab6c7f0d0c5d2339e9647bc80f91e3",
        "packagetype": "bdist_egg",
        "python_version": "3.7",
        "requires_python": null,
        "size": 55290,
        "upload_time": "2021-01-09T23:46:49",
        "upload_time_iso_8601": "2021-01-09T23:46:49.340935Z",
        "url": "https://files.pythonhosted.org/packages/82/ec/f9f18d1f0bd0e1969692a1f7a266e548a348a40382ea30b0e1132bb41291/thymus_timeseries-0.2.4-py3.7.egg",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "97350ccfd8694dbcfeafe1f8430b13f7d6afdd9c5a9cbc9eb525f2abf6abad1d",
          "md5": "ad5a01d985bebf8966bd5d91ca04b230",
          "sha256": "c428b753a41010d2cb9e0d0fc381f45ecc1047454d0a8afd11f736b3f6b558a0"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ad5a01d985bebf8966bd5d91ca04b230",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 30151,
        "upload_time": "2021-01-09T23:46:47",
        "upload_time_iso_8601": "2021-01-09T23:46:47.067919Z",
        "url": "https://files.pythonhosted.org/packages/97/35/0ccfd8694dbcfeafe1f8430b13f7d6afdd9c5a9cbc9eb525f2abf6abad1d/thymus_timeseries-0.2.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "190e7241bf3ac45b343da8f53c3d85b016d7233e7852d740ed02b32e41e88279",
          "md5": "a9b97bba896e76e6bbcfaf766e5c5f56",
          "sha256": "3bdf3df47fd34576e343e841f007bd225e0f3f4395be4b5da9648cf48e288100"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "a9b97bba896e76e6bbcfaf766e5c5f56",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 113246,
        "upload_time": "2021-01-09T23:46:52",
        "upload_time_iso_8601": "2021-01-09T23:46:52.483560Z",
        "url": "https://files.pythonhosted.org/packages/19/0e/7241bf3ac45b343da8f53c3d85b016d7233e7852d740ed02b32e41e88279/thymus-timeseries-0.2.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9c9d7dd9fcdefc0e4f8edc8d1cd68f3a9d5f83fc90903a936d0311a4a09fb8bc",
          "md5": "1d1917b57d34defc609b6221efc6c3cb",
          "sha256": "f00fbbcd98131b24af6b14b87f7b1861da48a9c831733eb107f7f5f225651654"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.5-py3.9.egg",
        "has_sig": false,
        "md5_digest": "1d1917b57d34defc609b6221efc6c3cb",
        "packagetype": "bdist_egg",
        "python_version": "3.9",
        "requires_python": null,
        "size": 61518,
        "upload_time": "2021-01-30T19:58:37",
        "upload_time_iso_8601": "2021-01-30T19:58:37.485076Z",
        "url": "https://files.pythonhosted.org/packages/9c/9d/7dd9fcdefc0e4f8edc8d1cd68f3a9d5f83fc90903a936d0311a4a09fb8bc/thymus_timeseries-0.2.5-py3.9.egg",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7c8b654a58c63ec3443ed4957c2a98d0493792f7d7f7a25a6dd034faa2892bbd",
          "md5": "0370ee5fea56fac123aabc79a539a008",
          "sha256": "435a0403a7eab39a6235d4f8b04c23eddbb48af8893e6eb82039c3cf7da75237"
        },
        "downloads": -1,
        "filename": "thymus_timeseries-0.2.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0370ee5fea56fac123aabc79a539a008",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 33253,
        "upload_time": "2021-01-30T19:58:34",
        "upload_time_iso_8601": "2021-01-30T19:58:34.896147Z",
        "url": "https://files.pythonhosted.org/packages/7c/8b/654a58c63ec3443ed4957c2a98d0493792f7d7f7a25a6dd034faa2892bbd/thymus_timeseries-0.2.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "643715665035027b465bdb432140a3791b639c8790254ef7e30f98001289fd8a",
          "md5": "abcbca0890d6c6d3b785a527fad0f555",
          "sha256": "56773eb3b82842e52a77777e091e42a62c3a0236ea59d124e61c775a9d294210"
        },
        "downloads": -1,
        "filename": "thymus-timeseries-0.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "abcbca0890d6c6d3b785a527fad0f555",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 143396,
        "upload_time": "2021-01-30T19:58:40",
        "upload_time_iso_8601": "2021-01-30T19:58:40.584400Z",
        "url": "https://files.pythonhosted.org/packages/64/37/15665035027b465bdb432140a3791b639c8790254ef7e30f98001289fd8a/thymus-timeseries-0.2.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9c9d7dd9fcdefc0e4f8edc8d1cd68f3a9d5f83fc90903a936d0311a4a09fb8bc",
        "md5": "1d1917b57d34defc609b6221efc6c3cb",
        "sha256": "f00fbbcd98131b24af6b14b87f7b1861da48a9c831733eb107f7f5f225651654"
      },
      "downloads": -1,
      "filename": "thymus_timeseries-0.2.5-py3.9.egg",
      "has_sig": false,
      "md5_digest": "1d1917b57d34defc609b6221efc6c3cb",
      "packagetype": "bdist_egg",
      "python_version": "3.9",
      "requires_python": null,
      "size": 61518,
      "upload_time": "2021-01-30T19:58:37",
      "upload_time_iso_8601": "2021-01-30T19:58:37.485076Z",
      "url": "https://files.pythonhosted.org/packages/9c/9d/7dd9fcdefc0e4f8edc8d1cd68f3a9d5f83fc90903a936d0311a4a09fb8bc/thymus_timeseries-0.2.5-py3.9.egg",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7c8b654a58c63ec3443ed4957c2a98d0493792f7d7f7a25a6dd034faa2892bbd",
        "md5": "0370ee5fea56fac123aabc79a539a008",
        "sha256": "435a0403a7eab39a6235d4f8b04c23eddbb48af8893e6eb82039c3cf7da75237"
      },
      "downloads": -1,
      "filename": "thymus_timeseries-0.2.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0370ee5fea56fac123aabc79a539a008",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 33253,
      "upload_time": "2021-01-30T19:58:34",
      "upload_time_iso_8601": "2021-01-30T19:58:34.896147Z",
      "url": "https://files.pythonhosted.org/packages/7c/8b/654a58c63ec3443ed4957c2a98d0493792f7d7f7a25a6dd034faa2892bbd/thymus_timeseries-0.2.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "643715665035027b465bdb432140a3791b639c8790254ef7e30f98001289fd8a",
        "md5": "abcbca0890d6c6d3b785a527fad0f555",
        "sha256": "56773eb3b82842e52a77777e091e42a62c3a0236ea59d124e61c775a9d294210"
      },
      "downloads": -1,
      "filename": "thymus-timeseries-0.2.5.tar.gz",
      "has_sig": false,
      "md5_digest": "abcbca0890d6c6d3b785a527fad0f555",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 143396,
      "upload_time": "2021-01-30T19:58:40",
      "upload_time_iso_8601": "2021-01-30T19:58:40.584400Z",
      "url": "https://files.pythonhosted.org/packages/64/37/15665035027b465bdb432140a3791b639c8790254ef7e30f98001289fd8a/thymus-timeseries-0.2.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}