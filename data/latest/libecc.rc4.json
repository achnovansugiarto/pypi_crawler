{
  "info": {
    "author": "Alden Torres",
    "author_email": "aldenml@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Topic :: Security :: Cryptography"
    ],
    "description": "# ecc\n\n[![macOS](https://github.com/aldenml/ecc/actions/workflows/macos.yml/badge.svg?branch=master)](https://github.com/aldenml/ecc/actions/workflows/macos.yml)\n[![Linux](https://github.com/aldenml/ecc/actions/workflows/linux.yml/badge.svg?branch=master)](https://github.com/aldenml/ecc/actions/workflows/linux.yml)\n[![Windows](https://github.com/aldenml/ecc/actions/workflows/windows.yml/badge.svg?branch=master)](https://github.com/aldenml/ecc/actions/workflows/windows.yml)\n[![PyPI version](https://badge.fury.io/py/libecc.svg)](https://badge.fury.io/py/libecc)\n\nThis is the python binding of the [ecc](https://github.com/aldenml/ecc) library.\n\nIt is a WebAssembly compilation with a thin layer on\ntop to expose the cryptographic primitives.\n\n### Features\n\n- [OPRF](#oprf-oblivious-pseudo-random-functions-using-ristretto255)\n- [OPAQUE](#opaque-the-opaque-asymmetric-pake-protocol)\n- [Two-Round Threshold Schnorr Signatures with FROST](#two-round-threshold-schnorr-signatures-with-frost)\n- [Ethereum BLS Signature](#ethereum-bls-signature)\n- [BLS12-381 Pairing](#bls12-381-pairing)\n- [Proxy Re-Encryption (PRE)](#proxy-re-encryption-pre)\n\n### OPRF Oblivious pseudo-random functions using ristretto255\n\nThis is an implementation of [draft-irtf-cfrg-voprf-08](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-08)\nciphersuite **OPRF(ristretto255, SHA-512)** using `libsodium`.\n\nThere are two variants in this protocol: a *base* mode and *verifiable* mode. In the\nbase mode, a client and server interact to compute `output = F(skS, input, info)`,\nwhere `input` is the client's private input, `skS` is the server's private key, `info`\nis the public input, and `output` is the computation output. The client learns `output`\nand the server learns nothing. In the verifiable mode, the client also receives proof\nthat the server used `skS` in computing the function.\n\nThe flow is shown below (from the irtf draft):\n```\n  Client(input, info)                               Server(skS, info)\n  ----------------------------------------------------------------------\n  blind, blindedElement = Blind(input)\n\n                             blindedElement\n                               ---------->\n\n                 evaluatedElement = Evaluate(skS, blindedElement, info)\n\n                             evaluatedElement\n                               <----------\n\n  output = Finalize(input, blind, evaluatedElement, blindedElement, info)\n```\n\nIn the verifiable mode of the protocol, the server additionally\ncomputes a proof in Evaluate. The client verifies this proof using\nthe server's expected public key before completing the protocol and\nproducing the protocol output.\n\n### OPAQUE The OPAQUE Asymmetric PAKE Protocol\n\nThis is an implementation of [draft-irtf-cfrg-opaque-07](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-07)\nusing `libsodium`.\n\nOPAQUE consists of two stages: registration and authenticated key\nexchange. In the first stage, a client registers its password with\nthe server and stores its encrypted credentials on the server, but\nthe server never knows what the password it.\n\nThe registration flow is shown below (from the irtf draft):\n```\n       creds                                   parameters\n         |                                         |\n         v                                         v\n       Client                                    Server\n       ------------------------------------------------\n                   registration request\n                ------------------------->\n                   registration response\n                <-------------------------\n                         record\n                ------------------------->\n      ------------------------------------------------\n         |                                         |\n         v                                         v\n     export_key                                 record\n```\n\nIn the second stage, the client outputs two values, an \"export_key\" (matching\nthat from registration) and a \"session_key\". The server outputs a single value\n\"session_key\" that matches that of the client.\n\nThe authenticated key exchange flow is shown below (from the irtf draft):\n```\n       creds                             (parameters, record)\n         |                                         |\n         v                                         v\n       Client                                    Server\n       ------------------------------------------------\n                      AKE message 1\n                ------------------------->\n                      AKE message 2\n                <-------------------------\n                      AKE message 3\n                ------------------------->\n      ------------------------------------------------\n         |                                         |\n         v                                         v\n   (export_key, session_key)                  session_key\n```\n\nThe public API for implementing the protocol is:\n\n- Client\n```\nopaque_ristretto255_sha512_CreateRegistrationRequest\nopaque_ristretto255_sha512_FinalizeRequest\nopaque_ristretto255_sha512_3DH_ClientInit\nopaque_ristretto255_sha512_3DH_ClientFinish\n```\n\n- Server\n```\nopaque_ristretto255_sha512_CreateRegistrationResponse\nopaque_ristretto255_sha512_3DH_ServerInit\nopaque_ristretto255_sha512_3DH_ServerFinish\n```\n\n### Two-Round Threshold Schnorr Signatures with FROST\n\nThis is an implementation of [draft-irtf-cfrg-frost-02](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-frost-02)\nusing `libsodium`.\n\nThe draft presents a two-round signing variant of FROST, a Flexible Round-Optimized Schnorr Threshold signature\nscheme. FROST signatures can be issued after a threshold number of entities cooperate to issue a signature,\nallowing for improved distribution of trust and redundancy with respect to a secret key.\n\nUnlike signatures in a single-party setting, threshold signatures require cooperation among a threshold number\nof signers each holding a share of a common private key. The security of threshold schemes in general assume\nthat an adversary can corrupt strictly fewer than a threshold number of participants.\n\nThis implementation follows the trusted dealer key generation documented in the Appendix B of the draft\nusing Shamir and Verifiable Secret Sharing.\n\n### Ethereum BLS Signature\n\nEthereum uses BLS signatures as specified in the IETF\ndraft [draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04)\nciphersuite `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`. This library provides the following API:\n\n```\necc_sign_eth_bls_KeyGen\necc_sign_eth_bls_SkToPk\necc_sign_eth_bls_KeyValidate\necc_sign_eth_bls_Sign\necc_sign_eth_bls_Verify\necc_sign_eth_bls_Aggregate\necc_sign_eth_bls_FastAggregateVerify\necc_sign_eth_bls_AggregateVerify\n```\n\nBLS is a digital signature scheme with aggregation properties that can be applied to signatures\nand public keys. For this reason, in the context of blockchains, BLS signatures are used for\nauthenticating transactions, votes during the consensus protocol, and to reduce the bandwidth\nand storage requirements.\n\n### BLS12-381 Pairing\n\nIn the context of pairing friendly elliptic curves, a pairing is a map `e: G1xG2 -> GT` such\nthat for each a, b, P and Q\n```\ne(a * P, b * Q) = e(P, Q)^(a * b)\n```\nYou can use this to obtain such pairings:\n```js\nconst libecc = await libecc_module();\n\nconst a = new Uint8Array(32);\nconst b = new Uint8Array(32);\nlibecc.ecc_bls12_381_scalar_random(a);\nlibecc.ecc_bls12_381_scalar_random(b);\n\nconst aP = new Uint8Array(96);\nconst bQ = new Uint8Array(192);\n\nlibecc.ecc_bls12_381_g1_scalarmult_base(aP, a); // a * P\nlibecc.ecc_bls12_381_g2_scalarmult_base(bQ, b); // b * Q\n\nconst pairing = new Uint8Array(576);\nlibecc.ecc_bls12_381_pairing(pairing, aP, bQ); // e(a * P, b * Q)\n```\n\nRead more at:<br/>\nhttps://hackmd.io/@benjaminion/bls12-381 <br/>\nhttps://en.wikipedia.org/wiki/Pairing-based_cryptography\n\n### Proxy Re-Encryption (PRE)\n\nWith a pairing-friendly elliptic curve and a well-defined pairing operation,\nyou can implement a proxy re-encryption scheme. This library provides an\nimplementation using BLS12-381.\n\nExample of how to use it:\n```js\n// client A setup public/private keys and signing keys\nconst keysA = await pre_schema1_KeyGen();\nconst signingA = await pre_schema1_SigningKeyGen();\n\n// client B setup public/private keys (signing keys are not used here)\nconst keysB = await pre_schema1_KeyGen();\n\n// proxy server setup signing keys\nconst signingProxy = await pre_schema1_SigningKeyGen();\n\n// client A select a plaintext message, this message\n// in itself is random, but can be used as a seed\n// for symmetric encryption keys\nconst message = await pre_schema1_MessageGen();\n\n// client A encrypts the message to itself, making it\n// possible to send this ciphertext to the proxy.\nconst ciphertextLevel1 = await pre_schema1_Encrypt(message, keysA.pk, signingA);\n\n// client A sends ciphertextLevel1 to the proxy server and\n// eventually client A allows client B to see the encrypted\n// message, in this case the proxy needs to re-encrypt\n// ciphertextLevel1 (without ever knowing the plaintext).\n// In order to do that, the client A needs to create a re-encryption\n// key that the proxy can use to perform such operation.\n\n// client A creates a re-encryption key that the proxy can use\n// to re-encrypt the ciphertext (ciphertextLevel1) in order for\n// client B be able to recover the original message\nconst reEncKey = await pre_schema1_ReKeyGen(keysA.sk, keysB.pk, signingA);\n\n// the proxy re-encrypt the ciphertext ciphertextLevel1 with such\n// a key that allows client B to recover the original message\nconst ciphertextLevel2 = await pre_schema1_ReEncrypt(\n    ciphertextLevel1,\n    reEncKey,\n    signingA.spk, keysB.pk,\n    signingProxy\n);\n\n// client B is able to decrypt ciphertextLevel2 and the result\n// is the original plaintext message\nconst messageDecrypted = await pre_schema1_DecryptLevel2(\n    ciphertextLevel2,\n    keysB.sk, signingProxy.spk\n);\n\n// now both client A and client B share the same plaintext message\n// messageDecrypted is equal to message\n```\n\nRead more at:<br/>\n\"A Fully Secure Unidirectional and Multi-user Proxy Re-encryption Scheme\" by H. Wang and Z. Cao, 2009 <br/>\n\"A Multi-User CCA-Secure Proxy Re-Encryption Scheme\" by Y. Cai and X. Liu, 2014 <br/>\n\"Cryptographically Enforced Orthogonal Access Control at Scale\" by B. Wall and P. Walsh, 2018 <br/>\nhttps://en.wikipedia.org/wiki/Proxy_re-encryption\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/aldenml/ecc",
    "keywords": "elliptic-curves,crypto,hash,sha256,sha512,ed25519,ristretto255,bls12-381,oprf,opaque,pake,apake,authentication,bls-signature,proxy-re-encryption,hkdf,threshold-cryptography,threshold-signature",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "libecc",
    "package_url": "https://pypi.org/project/libecc/",
    "platform": "",
    "project_url": "https://pypi.org/project/libecc/",
    "project_urls": {
      "Bug Tracker": "https://github.com/aldenml/ecc/issues",
      "Homepage": "https://github.com/aldenml/ecc"
    },
    "release_url": "https://pypi.org/project/libecc/1.0.11/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "elliptic curves crypto functions",
    "version": "1.0.11",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13074545,
  "releases": {
    "1.0.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eec453f32d77b3ca1512d473b736efedb15cc7db9090791ca5cdf89d40ddc5f5",
          "md5": "e536d104a93d2c632f93d1c800b0e5bf",
          "sha256": "07c46592b067faa1e4b995cef04c517c5fc6477964a8d6be6da90b234540fca9"
        },
        "downloads": -1,
        "filename": "libecc-1.0.10-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e536d104a93d2c632f93d1c800b0e5bf",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 1053811,
        "upload_time": "2022-02-05T03:47:32",
        "upload_time_iso_8601": "2022-02-05T03:47:32.624097Z",
        "url": "https://files.pythonhosted.org/packages/ee/c4/53f32d77b3ca1512d473b736efedb15cc7db9090791ca5cdf89d40ddc5f5/libecc-1.0.10-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4c7a20afb071498bf82aa9014f6567a00687b81f9ac688ee167a6d34c9729b4c",
          "md5": "6736f172fc0dac615b10a115b128aafe",
          "sha256": "1f7011558d51056fe3cd9a2b9b52fbb3b4e3016be9a224ae4a772625a6abaebc"
        },
        "downloads": -1,
        "filename": "libecc-1.0.11-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6736f172fc0dac615b10a115b128aafe",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 1098211,
        "upload_time": "2022-03-04T00:41:45",
        "upload_time_iso_8601": "2022-03-04T00:41:45.648631Z",
        "url": "https://files.pythonhosted.org/packages/4c/7a/20afb071498bf82aa9014f6567a00687b81f9ac688ee167a6d34c9729b4c/libecc-1.0.11-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1ad0e304456fee33d0c543f98601746b7f3ae09af11d422fac95c5f3055d67ff",
          "md5": "afde4587e807d5fd24f4ec8b1fd75a6a",
          "sha256": "523ffb518df0e8d53b21f5d8072b3e588ea7e2d182404323c9cf3410dc73f426"
        },
        "downloads": -1,
        "filename": "libecc-1.0.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "afde4587e807d5fd24f4ec8b1fd75a6a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 818933,
        "upload_time": "2022-01-24T02:46:26",
        "upload_time_iso_8601": "2022-01-24T02:46:26.065188Z",
        "url": "https://files.pythonhosted.org/packages/1a/d0/e304456fee33d0c543f98601746b7f3ae09af11d422fac95c5f3055d67ff/libecc-1.0.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d36ece2e5b7aeedf38ac8263e4be7c6caf06cca41dbd89cc000fb3afbabedeb1",
          "md5": "e1d349aa7d3dea2c7e6a540723714b0d",
          "sha256": "4187fa67fae0e8e0d52f56f71059d8eea6f9d7b5285ef617b804731961f0527d"
        },
        "downloads": -1,
        "filename": "libecc-1.0.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e1d349aa7d3dea2c7e6a540723714b0d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 818439,
        "upload_time": "2022-01-28T17:28:27",
        "upload_time_iso_8601": "2022-01-28T17:28:27.349658Z",
        "url": "https://files.pythonhosted.org/packages/d3/6e/ce2e5b7aeedf38ac8263e4be7c6caf06cca41dbd89cc000fb3afbabedeb1/libecc-1.0.9-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4c7a20afb071498bf82aa9014f6567a00687b81f9ac688ee167a6d34c9729b4c",
        "md5": "6736f172fc0dac615b10a115b128aafe",
        "sha256": "1f7011558d51056fe3cd9a2b9b52fbb3b4e3016be9a224ae4a772625a6abaebc"
      },
      "downloads": -1,
      "filename": "libecc-1.0.11-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6736f172fc0dac615b10a115b128aafe",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 1098211,
      "upload_time": "2022-03-04T00:41:45",
      "upload_time_iso_8601": "2022-03-04T00:41:45.648631Z",
      "url": "https://files.pythonhosted.org/packages/4c/7a/20afb071498bf82aa9014f6567a00687b81f9ac688ee167a6d34c9729b4c/libecc-1.0.11-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}