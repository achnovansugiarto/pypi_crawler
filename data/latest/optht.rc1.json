{
  "info": {
    "author": "N. Benjamin Erichson, Steven Dahdah",
    "author_email": "erichson@berkeley.edu, Steven.Dahdah@mail.mcgill.ca",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "Optimal Hard Threshold for Matrix Denoising\n*******************************************\n\nOff-the-shelf method for determining the optimal singular value truncation\n(hard threshold) for matrix denoising.\n\nThe method gives the optimal location both in the case of the known or unknown\nnoise level.\n\nExample\n*******\n![example](https://raw.githubusercontent.com/Benli11/data/master/img/optHT2.png)\n![example2](https://raw.githubusercontent.com/Benli11/data/master/img/optHT3.png)\n\nReproduce the example\n*********************\n\nCreate some data:\n\n```python\nimport numpy as np\nimport scipy as sci\nimport matplotlib.pyplot as plt\nfrom optht import optht\n\nt = np.arange(-2,2, 0.01)\n\nUtrue = np.array(( [np.cos(17*t) * np.exp(-t**2) , np.sin(11*t)] )).T\nStrue = np.array(( [2, 0], [0, .5] ))\nVtrue = np.array(( [np.sin(5*t) * np.exp(-t**2) , np.cos(13*t)] )).T\n\n# construct image\nX = Utrue.dot(Strue).dot(Vtrue.T)\n\n# define the noise level and add\nsigma = 0.5\nX_noisy = X + sigma * np.random.standard_normal(X.shape)\n```\n\nCompute the singular value decomposition (SVD):\n\n```python\nU, s, Vh = np.linalg.svd(X_noisy, full_matrices=False)\n```\n\nDetermine optimal hard threshold and reconstruct image\n```python\nk = optht(X_noisy, sv=s, sigma=None)\nX_denoised = (U[:, range(k)] * s[range(k)]).dot(Vh[range(k),:])\n```\n\nPlot the results:\n\n```python\nplt.subplot(131)\nplt.imshow(X, cmap='gray', interpolation='bicubic')\nplt.title('Original image')\nplt.axis('off')\n\nplt.subplot(132)\nplt.imshow(X_noisy, cmap='gray', interpolation='bicubic')\nplt.title('Noisy image, sigma=%s' % sigma)\nplt.axis('off')\n\nplt.subplot(133)\nplt.imshow(X_denoised, cmap='gray', interpolation='bicubic')\nrmseSVD = np.sqrt(np.sum( ( X - X_denoised )**2 ) / np.sum(X**2))\nplt.title('Denoised image,  nrmse=%s ' % np.round(rmseSVD, 2))\nplt.axis('off')\nplt.show()\n```\n\nPlot the singular value spectrum:\n\n```python\nplt.plot( (np.arange(1,s.shape[0]+1)), np.log(s), c='b', marker='o', linestyle='--')\nplt.xlabel('k', fontsize=25)\nplt.ylabel('Log-scaled singular values')\nplt.tick_params(axis='x') \nplt.tick_params(axis='y') \nplt.title('Singular value spectrum')\nplt.axvline(k, c='r', linewidth=2, linestyle='--')\nplt.show()\n```\n\nAuthors & Acknowledgments\n*****\n\n* Thanks to Steven Dahdah for refactoring the code into a Python package.\n* Thanks to Bill Tubbs for style edits and a few typo corrections.\n* Thanks to  @nish-ant for adding fixes to make the code Python 3 compatible.\n\n\nNotes\n*****\n* Code is adapted from Matan Gavish and David L. Donoho, see [1].\nCorresponding MATLAB code can be found\n[here](https://purl.stanford.edu/vg705qn9070)\n\nReferences\n**********\n[1] Gavish, Matan, and David L. Donoho.\n\"The optimal hard threshold for singular values is 4/sqrt(3)\"\nIEEE Transactions on Information Theory 60.8 (2014): 5040-5053.\nhttp://arxiv.org/abs/1305.5870\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/erichson/optht",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "optht",
    "package_url": "https://pypi.org/project/optht/",
    "platform": "",
    "project_url": "https://pypi.org/project/optht/",
    "project_urls": {
      "Bug Tracker": "https://github.com/erichson/optht/issues",
      "Homepage": "https://github.com/erichson/optht"
    },
    "release_url": "https://pypi.org/project/optht/0.2.0/",
    "requires_dist": [
      "numpy",
      "scipy"
    ],
    "requires_python": ">=3.6",
    "summary": "Optimal hard threshold for matrix denoising",
    "version": "0.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10970078,
  "releases": {
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0b24eacb4ba15cb39dbd87f9ed615c2acbb4f90101976584210e2fe43b10851c",
          "md5": "0c4a807e627afdc3e05173057876184f",
          "sha256": "e09453b29aa51bc5ed9ef6b4071cdd0d4b355f97c6902398b9c183fb506c96f8"
        },
        "downloads": -1,
        "filename": "optht-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0c4a807e627afdc3e05173057876184f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 5306,
        "upload_time": "2021-07-21T20:02:27",
        "upload_time_iso_8601": "2021-07-21T20:02:27.878758Z",
        "url": "https://files.pythonhosted.org/packages/0b/24/eacb4ba15cb39dbd87f9ed615c2acbb4f90101976584210e2fe43b10851c/optht-0.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0d4bf2e6e2ad35bd18a70113f9dfa7697024aaf38f75b6a47622c6ab28d262af",
          "md5": "975c8738532d7f796b9dbfbcb6ea9c6d",
          "sha256": "757c3606392cfef788b879ebc6bcaacedef6f1e44bbd6df49d3689a445cd948e"
        },
        "downloads": -1,
        "filename": "optht-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "975c8738532d7f796b9dbfbcb6ea9c6d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 3945,
        "upload_time": "2021-07-21T20:02:29",
        "upload_time_iso_8601": "2021-07-21T20:02:29.839731Z",
        "url": "https://files.pythonhosted.org/packages/0d/4b/f2e6e2ad35bd18a70113f9dfa7697024aaf38f75b6a47622c6ab28d262af/optht-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0b24eacb4ba15cb39dbd87f9ed615c2acbb4f90101976584210e2fe43b10851c",
        "md5": "0c4a807e627afdc3e05173057876184f",
        "sha256": "e09453b29aa51bc5ed9ef6b4071cdd0d4b355f97c6902398b9c183fb506c96f8"
      },
      "downloads": -1,
      "filename": "optht-0.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0c4a807e627afdc3e05173057876184f",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 5306,
      "upload_time": "2021-07-21T20:02:27",
      "upload_time_iso_8601": "2021-07-21T20:02:27.878758Z",
      "url": "https://files.pythonhosted.org/packages/0b/24/eacb4ba15cb39dbd87f9ed615c2acbb4f90101976584210e2fe43b10851c/optht-0.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0d4bf2e6e2ad35bd18a70113f9dfa7697024aaf38f75b6a47622c6ab28d262af",
        "md5": "975c8738532d7f796b9dbfbcb6ea9c6d",
        "sha256": "757c3606392cfef788b879ebc6bcaacedef6f1e44bbd6df49d3689a445cd948e"
      },
      "downloads": -1,
      "filename": "optht-0.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "975c8738532d7f796b9dbfbcb6ea9c6d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 3945,
      "upload_time": "2021-07-21T20:02:29",
      "upload_time_iso_8601": "2021-07-21T20:02:29.839731Z",
      "url": "https://files.pythonhosted.org/packages/0d/4b/f2e6e2ad35bd18a70113f9dfa7697024aaf38f75b6a47622c6ab28d262af/optht-0.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}