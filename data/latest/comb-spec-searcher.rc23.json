{
  "info": {
    "author": "Permuta Triangle",
    "author_email": "permutatriangle@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Education",
      "Topic :: Scientific/Engineering :: Mathematics"
    ],
    "description": "Combinatorial Specification Searcher\n====================================\n.. image:: https://travis-ci.org/PermutaTriangle/comb_spec_searcher.svg?branch=master\n    :alt: Travis\n    :target: https://travis-ci.org/PermutaTriangle/comb_spec_searcher\n.. image:: https://img.shields.io/coveralls/github/PermutaTriangle/comb_spec_searcher.svg\n    :alt: Coveralls\n    :target: https://coveralls.io/github/PermutaTriangle/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/v/comb_spec_searcher.svg\n    :alt: PyPI\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/l/comb_spec_searcher.svg\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/pyversions/comb_spec_searcher.svg\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n.. image:: http://img.shields.io/badge/readme-tested-brightgreen.svg\n    :alt: Travis\n    :target: https://travis-ci.org/PermutaTriangle/comb_spec_searcher\n.. image:: https://requires.io/github/PermutaTriangle/comb_spec_searcher/requirements.svg?branch=master\n     :target: https://requires.io/github/PermutaTriangle/comb_spec_searcher/requirements/?branch=master\n     :alt: Requirements Status\n.. image:: https://zenodo.org/badge/121520109.svg\n   :target: https://zenodo.org/badge/latestdoi/121520109\n\nThe ``comb_spec_searcher`` package contains code for combinatorial\nexploration.\n\nIf this code is useful to you in your work, please consider citing it. To generate a\nBibTeX entry (or another format), click the \"DOI\" badge above and locate the \"Cite As\"\nsection.\n\nInstalling\n----------\n\nTo install ``comb_spec_searcher`` on your system, run:\n\n.. code:: bash\n\n       pip install comb_spec_searcher\n\nIt is also possible to install comb_spec_searcher in development mode to\nwork on the source code, in which case you run the following after\ncloning the repository:\n\n.. code:: bash\n\n       ./setup.py develop\n\nCombinatorial exploration\n-------------------------\n\nA (combinatorial) class is a set of objects with a notion of size such\nthat there are finitely many objects of each size. One of the primary\ngoals of enumerative combinatorics is to count how many objects of each\nsize there are in a class. One method for doing this is to find a\n(combinatorial) specification, which is a collection of (combinatorial)\nrules that describe how to build a class from other classes using\nwell-defined constructors. Such a specification can then be used to\ncount the number of objects of each size.\n\n*Combinatorial exploration* is a systematic application of strategies to\ncreate rules about a class of interest, until a specification can be\nfound. This package can be used to perform this process automatically.\nSee the `Combinatorial Exploration\nproject <https://permutatriangle.github.io/papers/2019-02-27-combex.html>`__\nand `Christian Bean’s PhD\nthesis <https://opinvisindi.is/handle/20.500.11815/1184>`__ for more details.\n\nThe remainder of this README will be an example of how to use this\npackage for performing combinatorial exploration on a specific class,\nnamely words avoiding consecutive patterns.\n\nAvoiding consecutive patterns in words\n--------------------------------------\n\nA word ``w`` over an alphabet ``Σ`` is a string consisting of letters\nfrom ``Σ``. We say that ``w`` contains the word ``p`` if there is a\nconsecutive sequence of letters in ``w`` equal to ``p``. We say ``w``\navoids ``p`` if it does not contain ``p``. In this context, we call\n``p`` a pattern. In ``python``, this containment check can be checked\nusing ``in``.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CombinatorialObject\n\n   >>> class Word(str, CombinatorialObject):\n   ...     def size(self):\n   ...         return str.__len__(self)\n\n   >>> w = Word(\"acbabcabbb\")\n   >>> p = Word(\"abcab\")\n   >>> p in w\n   True\n\nFor an alphabet ``Σ`` and a set of patterns ``P`` we define ``Σ*(P)`` to\nbe the set of words over ``Σ`` that avoid every pattern in ``P``. These\nare the classes that we will count. Of course, these all form regular\nlanguages, but it will serve as a good example of how to use the\n``comb_spec_searcher`` package.\n\nThe first step is to create the classes that will be used for\ndiscovering the underlying structure of the class of interest. In this\ncase, considering the prefix of the words is what we need. We then\ncreate a new python ``class`` representing this that inherits from\n``CombinatorialClass`` which can be imported from\n``comb_spec_searcher``.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CombinatorialClass\n\n\n   >>> class AvoidingWithPrefix(CombinatorialClass[Word]):\n   ...     def __init__(self, prefix, patterns, alphabet, just_prefix=False):\n   ...         self.alphabet = frozenset(alphabet)\n   ...         self.prefix = Word(prefix)\n   ...         self.patterns = frozenset(map(Word, patterns))\n   ...         self.just_prefix = just_prefix # this will be needed later\n\nInheriting from ``CombinatorialClass`` requires you to implement a few\nfunctions for combinatorial exploration: ``is_empty``, ``to_jsonable``,\n``__eq__``, ``__hash__``, ``__repr__``, and ``__str__``.\n\nWe will start by implementing the dunder methods (the ones with double\nunderscores) required. The ``__eq__`` method is particularly important\nas the ``CombinatorialSpecificationSearcher`` will use it to recognise\nif the same class appears multiple times.\n\n.. code:: python\n\n   ...     # The dunder methods required to perform combinatorial exploration\n   ...\n   ...     def __eq__(self, other):\n   ...         return (self.alphabet == other.alphabet and\n   ...                 self.prefix == other.prefix and\n   ...                 self.patterns == other.patterns and\n   ...                 self.just_prefix == other.just_prefix)\n   ...\n   ...     def __hash__(self):\n   ...         return hash(hash(self.prefix) + hash(self.patterns) +\n   ...                     hash(self.alphabet) + hash(self.just_prefix))\n   ...\n   ...     def __str__(self):\n   ...         prefix = self.prefix if self.prefix else '\"\"'\n   ...         if self.just_prefix:\n   ...             return \"The word {}\".format(prefix)\n   ...         return (\"Words over {{{}}} avoiding {{{}}} with prefix {}\"\n   ...                 \"\".format(\", \".join(l for l in self.alphabet),\n   ...                           \", \".join(p for p in self.patterns),\n   ...                           prefix))\n   ...\n   ...     def __repr__(self):\n   ...         return \"AvoidingWithPrefix({}, {}, {}\".format(repr(self.prefix),\n   ...                                                       repr(self.patterns),\n   ...                                                       repr(self.alphabet))\n\nPerhaps the most important function to be implemented is the\n``is_empty`` function. This should return ``True`` if there are no\nobjects of any size in the class, otherwise ``False``. If it is not\ncorrectly implemented it may lead to tautological specifications. For\nexample, in our case the class is empty if and only if the prefix\ncontains a pattern to be avoided.\n\n.. code:: python\n\n   ...     def is_empty(self):\n   ...         return any(p in self.prefix for p in self.patterns)\n\nThe final function required is ``to_jsonable``. This is primarily for\nthe output, and only necessary for saving the output. It should be in a\nformat that can be interpretated by ``json``. What is important is that\nthe ``from_dict`` function is written in such a way that for any class\n``c`` we have ``CombinatorialClass.from_dict(c.to_jsonable()) == c``.\n\n.. code:: python\n\n   ...     def to_jsonable(self):\n   ...         return {\"prefix\": self.prefix,\n   ...                 \"patterns\": tuple(sorted(self.patterns)),\n   ...                 \"alphabet\": tuple(sorted(self.alphabet)),\n   ...                 \"just_prefix\": int(self.just_prefix)}\n   ...\n   ...     @classmethod\n   ...     def from_dict(cls, data):\n   ...         return cls(data['prefix'],\n   ...                    data['patterns'],\n   ...                    data['alphabet'],\n   ...                    bool(int(data['just_prefix'])))\n\nWe also add some methods that we will need to get the enumerations of the\nobjects later.\n\n.. code:: python\n\n   ...     def is_atom(self):\n   ...        \"\"\"Return True if the class contains a single word.\"\"\"\n   ...        return self.just_prefix\n   ...\n   ...     def minimum_size_of_object(self):\n   ...        \"\"\"Return the size of the smallest object in the class.\"\"\"\n   ...        return len(self.prefix)\n\nOur ``CombinatorialClass`` is now ready. What is left to do is create\nthe strategies that the ``CombinatorialSpecificationSearcher`` will use\nfor performing combinatorial exploration. This is given in the form of a\n``StrategyPack`` which can be imported from ``comb_spec_searcher`` that\nwe will populate in the remainder of this example.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import AtomStrategy, StrategyPack\n   >>> pack = StrategyPack(initial_strats=[],\n   ...                     inferral_strats=[],\n   ...                     expansion_strats=[],\n   ...                     ver_strats=[AtomStrategy()],\n   ...                     name=(\"Finding specification for words avoiding \"\n   ...                           \"consecutive patterns.\"))\n\nStrategies are functions that take as input a class ``C`` and produce\nrules about ``C``. The types of strategies are as follows: -\n``initial_strats``: yields rules for classes - ``inferral_strats``:\nreturns a single equivalence rule - ``expansion_strats``: yields rules\nfor classes - ``ver_strats``: returns a rule when the count of a class\nis known.\n\nIn our pack we have already added the AtomStrategy. This will verify any\ncombinatorial class that is an atom, in particular this is determined by the\n``is_atom`` method we implemented on ``CombinatorialClass``. To get the\nenumeration at the end, the strategy also uses the method\n``minimum_size_of_object`` on ``CombinatorialClass``. As we've implemented\nthese two methods already, we are free to use the ``AtomStrategy``.\n\nNow we will create our first strategy. Every word over the alphabet ``Σ``\nstarting with prefix ``p`` is either just ``p`` or has prefix ``pa`` for some\n``a`` in ``Σ``. This rule is splitting the original into disjoint subsets. We\ncall a rule using disjoint union a ``DisjointUnionStrategy``. Although in this\ncase thereis a unique rule created by the strategy, strategies are assumed to\ncreate multiple rules, and as such should be implemented as generators.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import DisjointUnionStrategy\n\n\n   >>> class ExpansionStrategy(DisjointUnionStrategy[AvoidingWithPrefix, Word]):\n   ...     def decomposition_function(self, avoiding_with_prefix):\n   ...        if not avoiding_with_prefix.just_prefix:\n   ...           alphabet, prefix, patterns = (\n   ...                 avoiding_with_prefix.alphabet,\n   ...                 avoiding_with_prefix.prefix,\n   ...                 avoiding_with_prefix.patterns,\n   ...           )\n   ...           children = [AvoidingWithPrefix(prefix, patterns, alphabet, True)]\n   ...           for a in alphabet:\n   ...                 ends_with_a = AvoidingWithPrefix(prefix + a, patterns, alphabet)\n   ...                 children.append(ends_with_a)\n   ...           return tuple(children)\n   ...\n   ...     def formal_step(self):\n   ...        return \"Either just the prefix, or append a letter from the alphabet\"\n   ...\n   ...     def forward_map(self, avoiding_with_prefix, word, children=None):\n   ...        \"\"\"\n   ...        The backward direction of the underlying bijection used for object\n   ...        generation and sampling.\n   ...        \"\"\"\n   ...        assert isinstance(word, Word)\n   ...        if children is None:\n   ...           children = self.decomposition_function(avoiding_with_prefix)\n   ...           assert children is not None\n   ...        if len(word) == len(avoiding_with_prefix.prefix):\n   ...           return (word,) + tuple(None for i in range(len(children) - 1))\n   ...        for idx, child in enumerate(children[1:]):\n   ...           if word[: len(child.prefix)] == child.prefix:\n   ...                 return (\n   ...                    tuple(None for _ in range(idx + 1))\n   ...                    + (word,)\n   ...                    + tuple(None for _ in range(len(children) - idx - 1))\n   ...                 )\n   ...\n   ...     def __str__(self):\n   ...        return self.formal_step()\n   ...\n   ...     def __repr__(self):\n   ...        return self.__class__.__name__ + \"()\"\n   ...\n   ...     @classmethod\n   ...     def from_dict(cls, d):\n   ...        return cls()\n\n\nThe final strategy we will need is one that peels off much as possible\nfrom the front of the prefix ``p`` such that the avoidance conditions\nare unaffected. This should then give a rule that is a cartesian product\nof the part that is peeled off together with the words whose prefix is\nthat of the remainder of the original prefix. We call rules whose\nconstructor is cartesian product a ``DecompositionRule``.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CartesianProductStrategy\n\n\n   >>> class RemoveFrontOfPrefix(CartesianProductStrategy[AvoidingWithPrefix, Word]):\n   ...     def decomposition_function(self, avoiding_with_prefix):\n   ...        \"\"\"If the k is the maximum size of a pattern to be avoided, then any\n   ...        occurrence using indices further to the right of the prefix can use at\n   ...        most the last k - 1 letters in the prefix.\"\"\"\n   ...        if not avoiding_with_prefix.just_prefix:\n   ...           safe = self.index_safe_to_remove_up_to(avoiding_with_prefix)\n   ...           if safe > 0:\n   ...                 prefix, patterns, alphabet = (\n   ...                    avoiding_with_prefix.prefix,\n   ...                    avoiding_with_prefix.patterns,\n   ...                    avoiding_with_prefix.alphabet,\n   ...                 )\n   ...                 start_prefix = prefix[:safe]\n   ...                 end_prefix = prefix[safe:]\n   ...                 start = AvoidingWithPrefix(start_prefix, patterns, alphabet, True)\n   ...                 end = AvoidingWithPrefix(end_prefix, patterns, alphabet)\n   ...                 return (start, end)\n   ...\n   ...     def index_safe_to_remove_up_to(self, avoiding_with_prefix):\n   ...        prefix, patterns = (\n   ...           avoiding_with_prefix.prefix,\n   ...           avoiding_with_prefix.patterns,\n   ...        )\n   ...        # safe will be the index of the prefix in which we can remove upto without\n   ...        # affecting the avoidance conditions\n   ...        m = max(len(p) for p in patterns) if patterns else 1\n   ...        safe = max(0, len(prefix) - m + 1)\n   ...        for i in range(safe, len(prefix)):\n   ...           end = prefix[i:]\n   ...           if any(end == patt[: len(end)] for patt in patterns):\n   ...                 break\n   ...           safe = i + 1\n   ...        return safe\n   ...\n   ...     def formal_step(self):\n   ...        return \"removing redundant prefix\"\n   ...\n   ...     def backward_map(self, avoiding_with_prefix, words, children=None):\n   ...        \"\"\"\n   ...        The forward direction of the underlying bijection used for object\n   ...        generation and sampling.\n   ...        \"\"\"\n   ...        assert len(words) == 2\n   ...        assert isinstance(words[0], Word)\n   ...        assert isinstance(words[1], Word)\n   ...        if children is None:\n   ...           children = self.decomposition_function(avoiding_with_prefix)\n   ...           assert children is not None\n   ...        yield Word(words[0] + words[1])\n   ...\n   ...     def forward_map(self, comb_class, word, children=None):\n   ...        \"\"\"\n   ...        The backward direction of the underlying bijection used for object\n   ...        generation and sampling.\n   ...        \"\"\"\n   ...        assert isinstance(word, Word)\n   ...        if children is None:\n   ...           children = self.decomposition_function(comb_class)\n   ...           assert children is not None\n   ...        return Word(children[0].prefix), Word(word[len(children[0].prefix) :])\n   ...\n   ...     @classmethod\n   ...     def from_dict(cls, d):\n   ...        return cls()\n   ...\n   ...     def __str__(self):\n   ...        return self.formal_step()\n   ...\n   ...     def __repr__(self):\n   ...        return self.__class__.__name__ + \"()\"\n\nWith these three strategies we are now ready to perform combinatorial\nexploration using the following pack.\n\n.. code:: python\n\n   >>> pack = StrategyPack(initial_strats=[RemoveFrontOfPrefix()],\n   ...                     inferral_strats=[],\n   ...                     expansion_strats=[[ExpansionStrategy()]],\n   ...                     ver_strats=[AtomStrategy()],\n   ...                     name=(\"Finding specification for words avoiding \"\n   ...                           \"consecutive patterns.\"))\n\nFirst we need to create the combinatorial class we want to count. For\nexample, consider the words over the alphabet ``{a, b}`` that avoid\n``ababa`` and ``babb``. This class can be created using our initialise\nfunction.\n\n.. code:: python\n\n   >>> prefix = ''\n   >>> patterns = ['ababa', 'babb']\n   >>> alphabet = ['a', 'b']\n   >>> start_class = AvoidingWithPrefix(prefix, patterns, alphabet)\n\nWe can then initialise our ``CombinatorialSpecificationSearcher``, and\nuse the ``auto_search`` function which will return a\n``CombinatorialSpecification`` assuming one is found (which in this case always\nwill).\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CombinatorialSpecificationSearcher\n\n\n   >>> searcher = CombinatorialSpecificationSearcher(start_class, pack)\n   >>> spec = searcher.auto_search()\n   >>> # spec.show() will display the specification in your browser\n\nNow that we have a ``CombinatorialSpecification``, the obvious\nthing we want to do is find the generating function for the class that\ncounts the number of objects of each size. This can be done by using the\n``get_genf`` methods on ``CombinatorialSpecification``.\n\nFinally, in order to get initial terms, you will also need to implement\nthe ``objects_of_size`` function which should yield all of the objects\nof a given size in the class.\n\n.. code:: python\n\n   >>> from itertools import product\n\n   >>> def objects_of_size(self, size):\n   ...     \"\"\"Yield the words of given size that start with prefix and avoid the\n   ...     patterns. If just_prefix, then only yield that word.\"\"\"\n   ...     def possible_words():\n   ...         \"\"\"Yield all words of given size over the alphabet with prefix\"\"\"\n   ...         if len(self.prefix) > size:\n   ...            return\n   ...         for letters in product(self.alphabet,\n   ...                                 repeat=size - len(self.prefix)):\n   ...             yield Word(self.prefix + \"\".join(a for a in letters))\n   ...\n   ...     if self.just_prefix:\n   ...         if size == len(self.prefix) and not self.is_empty():\n   ...             yield Word(self.prefix)\n   ...         return\n   ...     for word in possible_words():\n   ...         if all(patt not in word for patt in self.patterns):\n   ...             yield word\n   >>> AvoidingWithPrefix.objects_of_size = objects_of_size\n\nWith these in place if we then call the ``get_genf`` function\n\n.. code:: python\n\n   >>> spec.get_genf()\n   -(x + 1)*(x**2 - x + 1)**2*(x**2 + x + 1)/(x**6 + x**3 - x**2 + 2*x - 1)\n\nwe see that the the generating function is\n``F = -(x**7 + x**5 + x**4 + x**3 + x**2 + 1)/(x**6 + x**3 - x**2 + 2*x - 1)``.\n\nMoreover, we can get directly the number of objects by size with the method\n`count_objects_of_size`.\n\n.. code:: python\n\n   >>> [spec.count_objects_of_size(i) for i in range(11)]\n   [1, 2, 4, 8, 15, 27, 48, 87, 157, 283, 511]\n\nYou can now try this yourself using the file ``example.py``, which can\ncount any set of words avoiding consecutive patterns.\n\nNow we will demonstrate how a bijection can be found between classes.\nWe will first need a couple of imports.\n\n.. code:: python\n\n   >>> from comb_spec_searcher.bijection import ParallelSpecFinder\n   >>> from comb_spec_searcher.isomorphism import Bijection\n\nWe start by defining our two classes that we wish to find a bijection between.\n\n.. code:: python\n\n   >>> prefix1 = ''\n   >>> patterns1 = [\"00\"]\n   >>> alphabet1 = ['0', '1']\n   >>> class1 = AvoidingWithPrefix(prefix1, patterns1, alphabet1)\n   >>> prefix2 = ''\n   >>> patterns2 = [\"bb\"]\n   >>> alphabet2 = ['a', 'b']\n   >>> class2 = AvoidingWithPrefix(prefix2, patterns2, alphabet2)\n\nTo find a bijection we expand the universe given a pack for both classes\nand try to construct specifications that are parallel.\n\n.. code:: python\n\n   >>> searcher1 = CombinatorialSpecificationSearcher(class1, pack)\n   >>> searcher2 = CombinatorialSpecificationSearcher(class2, pack)\n\nWe get two parallel specs if successful, ``None`` otherwise.\n\n.. code:: python\n\n   >>> specs = ParallelSpecFinder(searcher1, searcher2).find()\n\nWe then construct the bijection from the parallel specifications.\n\n.. code:: python\n\n   >>> bijection = Bijection.construct(*specs)\n\nWe can use the `Bijection` object to map (either way) sampled objects\nfrom the sepcifications.\n\n.. code:: python\n\n   >>> for i in range(10):\n   ...     for w in bijection.domain.generate_objects_of_size(i):\n   ...         assert w == bijection.inverse_map(bijection.map(w))\n   ...     for w in bijection.codomain.generate_objects_of_size(i):\n   ...         assert w == bijection.map(bijection.inverse_map(w))\n   ...\n\nWhether we find a bijection or not (when one exists) is highly\ndependent on the packs chosen.\n\nCiting\n######\n\nIf you found this library helpful with your research and would like to cite us,\nyou can use the following `BibTeX`_ or go to `Zenodo`_ for alternative formats.\n\n.. _BibTex: https://zenodo.org/record/4944021/export/hx#.YMcpIC2l30o\n\n.. _Zenodo: https://doi.org/10.5281/zenodo.4944020\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/PermutaTriangle/comb_spec_searcher",
    "keywords": "enumerative combinatorics combinatorial specification counting",
    "license": "BSD-3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "comb-spec-searcher",
    "package_url": "https://pypi.org/project/comb-spec-searcher/",
    "platform": null,
    "project_url": "https://pypi.org/project/comb-spec-searcher/",
    "project_urls": {
      "Homepage": "https://github.com/PermutaTriangle/comb_spec_searcher",
      "Source": "https://github.com/PermutaTriangle/comb_spec_searcher",
      "Tracker": "https://github.com/PermutaTriangle/comb_spec_searcher/issues"
    },
    "release_url": "https://pypi.org/project/comb-spec-searcher/4.2.0/",
    "requires_dist": null,
    "requires_python": ">=3.8",
    "summary": "A library for performing combinatorial exploration.",
    "version": "4.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16477179,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5ab097e8ed3ac923abca077221f7b4ca8529de6ed2d304f0cef9238197f4de83",
          "md5": "579c732385da80b3ecfa898972cdb6be",
          "sha256": "f8b8463d2155e013940185feb2ed0471a73b5ca623cef52de9e3cf2fc3a371c6"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "579c732385da80b3ecfa898972cdb6be",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 37207,
        "upload_time": "2019-05-28T14:20:40",
        "upload_time_iso_8601": "2019-05-28T14:20:40.891718Z",
        "url": "https://files.pythonhosted.org/packages/5a/b0/97e8ed3ac923abca077221f7b4ca8529de6ed2d304f0cef9238197f4de83/comb_spec_searcher-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "69098fbf254b3cd4fb2a4c1c031a3ed0193089f412c5045aa0ac0ccbfe235066",
          "md5": "77a4d470cf0a42a04211b26124d188ae",
          "sha256": "eb1b63d2c813e090afaad13a96ebac86436c4e74df197e03e5c0d3e1e8dbf4fe"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "77a4d470cf0a42a04211b26124d188ae",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 39398,
        "upload_time": "2019-08-26T15:08:48",
        "upload_time_iso_8601": "2019-08-26T15:08:48.193469Z",
        "url": "https://files.pythonhosted.org/packages/69/09/8fbf254b3cd4fb2a4c1c031a3ed0193089f412c5045aa0ac0ccbfe235066/comb_spec_searcher-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "79d9a52d9198702efde2ddd0217973485966602f6e582d4dc4f911a4d4f7cd5e",
          "md5": "9d3655476280ce8df57f948679a4750c",
          "sha256": "59c1115b7a1e299df18859880acbe309837d31f2dfc79c2c9cde1e383d5cddb7"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "9d3655476280ce8df57f948679a4750c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 39396,
        "upload_time": "2019-08-26T17:01:43",
        "upload_time_iso_8601": "2019-08-26T17:01:43.106153Z",
        "url": "https://files.pythonhosted.org/packages/79/d9/a52d9198702efde2ddd0217973485966602f6e582d4dc4f911a4d4f7cd5e/comb_spec_searcher-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7cdfdf26af38316cb5837a24d192575dc07b79c96a0999efb1e143f6a74ebe21",
          "md5": "5e8550277aec1c1d08e3dc38ce684210",
          "sha256": "62138211bcb17b760296b091c22de1e599abdbc1ee5dc516a4eba9636e4b89e0"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "5e8550277aec1c1d08e3dc38ce684210",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 41268,
        "upload_time": "2019-09-06T15:02:27",
        "upload_time_iso_8601": "2019-09-06T15:02:27.001177Z",
        "url": "https://files.pythonhosted.org/packages/7c/df/df26af38316cb5837a24d192575dc07b79c96a0999efb1e143f6a74ebe21/comb_spec_searcher-0.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a11da87fa3e6302793a6c712f75d1b6eb074de14a65eb4ed19f9bd335cdcd4ba",
          "md5": "62b342f8f140a43cd3d60e97651ffc06",
          "sha256": "c91c091744b515484fd40fa5acebd8353e650b37218acd8a593aed6c4b02a8ff"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "62b342f8f140a43cd3d60e97651ffc06",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 36195,
        "upload_time": "2020-01-20T10:49:49",
        "upload_time_iso_8601": "2020-01-20T10:49:49.886856Z",
        "url": "https://files.pythonhosted.org/packages/a1/1d/a87fa3e6302793a6c712f75d1b6eb074de14a65eb4ed19f9bd335cdcd4ba/comb_spec_searcher-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7bfc9fcb6d3231f6960196d9a7112fcce131fba597689e7dbaa4df4207562e8c",
          "md5": "afdd179d6ecc45d43ede331024001926",
          "sha256": "3d3420a29dca7ef3e3fafff8b46ca481aa5f49e315c395a2ffc14b7da5b52bae"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "afdd179d6ecc45d43ede331024001926",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 41531,
        "upload_time": "2020-02-20T12:38:35",
        "upload_time_iso_8601": "2020-02-20T12:38:35.929859Z",
        "url": "https://files.pythonhosted.org/packages/7b/fc/9fcb6d3231f6960196d9a7112fcce131fba597689e7dbaa4df4207562e8c/comb_spec_searcher-0.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "65fefe8dc03a66e0915de3d2addfab0fea19ad9365f1e20f40d0673155cbc2ce",
          "md5": "6e37fa19f8420950f667984e29f3cb4e",
          "sha256": "d7864a654457b5c31225ec9f218b4be05b7dbbfa39002cb66f6c519f5b29a558"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6e37fa19f8420950f667984e29f3cb4e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 42199,
        "upload_time": "2020-03-30T15:43:11",
        "upload_time_iso_8601": "2020-03-30T15:43:11.991213Z",
        "url": "https://files.pythonhosted.org/packages/65/fe/fe8dc03a66e0915de3d2addfab0fea19ad9365f1e20f40d0673155cbc2ce/comb_spec_searcher-0.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c55c882714094716254aa6d43963df1371da978f757a0acd6edf35fcd3bec651",
          "md5": "f26ed87345ba348f4c54ab1b7eab9834",
          "sha256": "6aba7a28a318dcb156e1bf8ef6cd32af4e34ed1e7aefcb81fe4a97512c90d9d1"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f26ed87345ba348f4c54ab1b7eab9834",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 51348,
        "upload_time": "2020-06-11T19:21:24",
        "upload_time_iso_8601": "2020-06-11T19:21:24.695601Z",
        "url": "https://files.pythonhosted.org/packages/c5/5c/882714094716254aa6d43963df1371da978f757a0acd6edf35fcd3bec651/comb_spec_searcher-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d42943a891c84771b931c13b0aae7b2b27fe34b33e11003c0e342945fdf2783a",
          "md5": "9c7140e371cef7d711bcb6155533e227",
          "sha256": "6927abf711992f7bf287b47d77d1a82a1062c2d45aefffe44b9dec3bdb58e3f6"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "9c7140e371cef7d711bcb6155533e227",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 52463,
        "upload_time": "2020-06-17T10:27:42",
        "upload_time_iso_8601": "2020-06-17T10:27:42.026516Z",
        "url": "https://files.pythonhosted.org/packages/d4/29/43a891c84771b931c13b0aae7b2b27fe34b33e11003c0e342945fdf2783a/comb_spec_searcher-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e5f9b06e0faf908cb56a7329a1865e65efddd916befd623b9831ef028ad0207b",
          "md5": "71bc5b20ec173ae16295c01294c10e44",
          "sha256": "f909c642596b8dadf85cebe2334dffabb279be9a0456cb5368234aa3d56eec43"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "71bc5b20ec173ae16295c01294c10e44",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 52561,
        "upload_time": "2020-06-18T14:25:06",
        "upload_time_iso_8601": "2020-06-18T14:25:06.469339Z",
        "url": "https://files.pythonhosted.org/packages/e5/f9/b06e0faf908cb56a7329a1865e65efddd916befd623b9831ef028ad0207b/comb_spec_searcher-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a22dfae76b2ee7879067d270af1285b7ac7feb75a9b0b417a017da406f4a1e01",
          "md5": "ce2f53db3bb880fec6eeac8dadd67690",
          "sha256": "c300bb843c4325464340340283eb880cebaab0692fac89bd1566d5ded1dc5348"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ce2f53db3bb880fec6eeac8dadd67690",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 55829,
        "upload_time": "2020-06-29T15:34:07",
        "upload_time_iso_8601": "2020-06-29T15:34:07.372093Z",
        "url": "https://files.pythonhosted.org/packages/a2/2d/fae76b2ee7879067d270af1285b7ac7feb75a9b0b417a017da406f4a1e01/comb_spec_searcher-1.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "056a5267a581cda73b1ea2574cf78bebd19a939d73ee879c7d7b90d054e3cd0a",
          "md5": "06d7e8f180daa0a01285803ec0c16ea8",
          "sha256": "a6fd52f23055ebc7ac2b5d026a683d36c89be139ca4e11e9c159a9ce22ec7b98"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-1.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "06d7e8f180daa0a01285803ec0c16ea8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 56693,
        "upload_time": "2020-07-07T15:42:20",
        "upload_time_iso_8601": "2020-07-07T15:42:20.947921Z",
        "url": "https://files.pythonhosted.org/packages/05/6a/5267a581cda73b1ea2574cf78bebd19a939d73ee879c7d7b90d054e3cd0a/comb_spec_searcher-1.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fccb6af4f815dfcb092d534241267899bfe460c36303a3c91dc7e19a8f0ab33d",
          "md5": "9ca5abf858465cd71c6b4cbd21d0e196",
          "sha256": "f1acbb8fb1755dfdb5297f9cfa40d4469d74bf4c5be6d547c6246cbdd2b6123d"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9ca5abf858465cd71c6b4cbd21d0e196",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 57840,
        "upload_time": "2020-07-17T10:25:16",
        "upload_time_iso_8601": "2020-07-17T10:25:16.574808Z",
        "url": "https://files.pythonhosted.org/packages/fc/cb/6af4f815dfcb092d534241267899bfe460c36303a3c91dc7e19a8f0ab33d/comb_spec_searcher-2.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c36d2281c8d336516fcf71e4ab904211d0d49dd16304fbffc2e778f3ccf96274",
          "md5": "9f678276175715ced3128122d4673d8c",
          "sha256": "db6ee238bec999521477b70938949df2ce95b77b1d2fcf476f19e2719328f5be"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "9f678276175715ced3128122d4673d8c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 161057,
        "upload_time": "2020-08-06T14:30:35",
        "upload_time_iso_8601": "2020-08-06T14:30:35.238870Z",
        "url": "https://files.pythonhosted.org/packages/c3/6d/2281c8d336516fcf71e4ab904211d0d49dd16304fbffc2e778f3ccf96274/comb_spec_searcher-2.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fc7607a5f7d8618bd78c66ca994230fd5bf69a173311f2c102f6d5368d370af9",
          "md5": "30d31a63c92774fefe4dbce7090699a0",
          "sha256": "0daf7ac1ac1e6e7b3a15f82a46739675377181a313b2025cdf4495d2fc403a97"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "30d31a63c92774fefe4dbce7090699a0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 161119,
        "upload_time": "2020-08-06T15:15:50",
        "upload_time_iso_8601": "2020-08-06T15:15:50.882416Z",
        "url": "https://files.pythonhosted.org/packages/fc/76/07a5f7d8618bd78c66ca994230fd5bf69a173311f2c102f6d5368d370af9/comb_spec_searcher-2.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5af9bed2ef14aeb73b264fab10cf4622aac85f61a27e2eb989e66b499161e1ef",
          "md5": "ee4f55e46d1130eee7096ef3f2d3d28c",
          "sha256": "8fd9d78fdf7237c4898c09f5605a986579153fa8ff2ea52a28182bc90c9f18a7"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ee4f55e46d1130eee7096ef3f2d3d28c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 183170,
        "upload_time": "2020-08-11T16:26:27",
        "upload_time_iso_8601": "2020-08-11T16:26:27.110313Z",
        "url": "https://files.pythonhosted.org/packages/5a/f9/bed2ef14aeb73b264fab10cf4622aac85f61a27e2eb989e66b499161e1ef/comb_spec_searcher-2.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "efb7e967b48743e167b05c98560c755e5ca52144423272b67a83d71769d9bf4b",
          "md5": "ee401f9d78de780f2129e947f844d8ac",
          "sha256": "9a6e2d6320ca493edfab80907fb091dbe5eac45675736bdcb45205ac16141285"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ee401f9d78de780f2129e947f844d8ac",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 183226,
        "upload_time": "2020-09-10T14:20:34",
        "upload_time_iso_8601": "2020-09-10T14:20:34.489515Z",
        "url": "https://files.pythonhosted.org/packages/ef/b7/e967b48743e167b05c98560c755e5ca52144423272b67a83d71769d9bf4b/comb_spec_searcher-2.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "136729df29fc680218a3c6af67122f84660768a5f41fc747b3dbbc0bd1c56239",
          "md5": "c5657786ac2f12b162529c988abfef59",
          "sha256": "b9db4d334569568c9568b88cff8746984ce143f24b60adc9754ebe3f87ab61f6"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c5657786ac2f12b162529c988abfef59",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 183125,
        "upload_time": "2020-10-28T12:37:31",
        "upload_time_iso_8601": "2020-10-28T12:37:31.531312Z",
        "url": "https://files.pythonhosted.org/packages/13/67/29df29fc680218a3c6af67122f84660768a5f41fc747b3dbbc0bd1c56239/comb_spec_searcher-2.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5192fa08a43ae844b9617e78d14269db26df6da8c390c0ae19a111035cbdb8dc",
          "md5": "ebf95d05e6e3e5d38817d1ba82236d3f",
          "sha256": "005000b469cbe0fc43c04ae56aaa9d646032870b641df6f768e33306b7f9fd04"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-2.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ebf95d05e6e3e5d38817d1ba82236d3f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 184147,
        "upload_time": "2020-11-11T13:18:58",
        "upload_time_iso_8601": "2020-11-11T13:18:58.165770Z",
        "url": "https://files.pythonhosted.org/packages/51/92/fa08a43ae844b9617e78d14269db26df6da8c390c0ae19a111035cbdb8dc/comb_spec_searcher-2.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1e76d575d17a8c1c97d57e5dab0b76a7bdfe7426327414ae279411ed958d0f51",
          "md5": "6c75b2fa5e64e67ede9d283763e8e904",
          "sha256": "51a83e93d0a794596ef5fb013ffb8a88deb504d09d6e5de56bfe1d697f8d71b2"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-3.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6c75b2fa5e64e67ede9d283763e8e904",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 191210,
        "upload_time": "2021-01-04T12:30:03",
        "upload_time_iso_8601": "2021-01-04T12:30:03.422900Z",
        "url": "https://files.pythonhosted.org/packages/1e/76/d575d17a8c1c97d57e5dab0b76a7bdfe7426327414ae279411ed958d0f51/comb_spec_searcher-3.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "4.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "49e2f62d3eb81e128a37c29dc434c57c16b98e4602825f78c6cbd97ce5d7e808",
          "md5": "735f772807140b783e69b0f3d621f969",
          "sha256": "33ea1eef90cdcd29fdf6ffe8191df81d0f9dec59d47317517a56f02092f82d2c"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-4.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "735f772807140b783e69b0f3d621f969",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 212390,
        "upload_time": "2021-06-14T16:01:56",
        "upload_time_iso_8601": "2021-06-14T16:01:56.922906Z",
        "url": "https://files.pythonhosted.org/packages/49/e2/f62d3eb81e128a37c29dc434c57c16b98e4602825f78c6cbd97ce5d7e808/comb_spec_searcher-4.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "4.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b5a0e9f94a6f410474b916a2c72f085b0cbc9994d4c58cd1409f8ceedee06c8e",
          "md5": "c5d2f30ef25f9feb52e6e2c8d0e3e596",
          "sha256": "f7785a6c910eacb603d8f55940d46980af2a0f73debe76310e803d5de9342318"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-4.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c5d2f30ef25f9feb52e6e2c8d0e3e596",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 213835,
        "upload_time": "2022-01-17T10:06:32",
        "upload_time_iso_8601": "2022-01-17T10:06:32.335908Z",
        "url": "https://files.pythonhosted.org/packages/b5/a0/e9f94a6f410474b916a2c72f085b0cbc9994d4c58cd1409f8ceedee06c8e/comb_spec_searcher-4.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "4.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1e6f23490fd155fb125e57dd34a1281f0580171002d5707fab392caabb0a675e",
          "md5": "d285c3f92b48f61145f2fc4971dc4e08",
          "sha256": "92df33f189dad10c7a5ee06a3ee305f383859e32718a09aa97a395154fecbfd7"
        },
        "downloads": -1,
        "filename": "comb_spec_searcher-4.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d285c3f92b48f61145f2fc4971dc4e08",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 213884,
        "upload_time": "2023-01-18T22:10:07",
        "upload_time_iso_8601": "2023-01-18T22:10:07.214180Z",
        "url": "https://files.pythonhosted.org/packages/1e/6f/23490fd155fb125e57dd34a1281f0580171002d5707fab392caabb0a675e/comb_spec_searcher-4.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "1e6f23490fd155fb125e57dd34a1281f0580171002d5707fab392caabb0a675e",
        "md5": "d285c3f92b48f61145f2fc4971dc4e08",
        "sha256": "92df33f189dad10c7a5ee06a3ee305f383859e32718a09aa97a395154fecbfd7"
      },
      "downloads": -1,
      "filename": "comb_spec_searcher-4.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "d285c3f92b48f61145f2fc4971dc4e08",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 213884,
      "upload_time": "2023-01-18T22:10:07",
      "upload_time_iso_8601": "2023-01-18T22:10:07.214180Z",
      "url": "https://files.pythonhosted.org/packages/1e/6f/23490fd155fb125e57dd34a1281f0580171002d5707fab392caabb0a675e/comb_spec_searcher-4.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}