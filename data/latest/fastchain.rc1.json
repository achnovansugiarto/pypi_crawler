{
  "info": {
    "author": "MARSO Adnan",
    "author_email": "mediadnan@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Scientific/Engineering",
      "Topic :: Software Development",
      "Topic :: Utilities",
      "Typing :: Typed"
    ],
    "description": "\n# fastchain\n\n[![Tests](https://github.com/mediadnan/fastchain/actions/workflows/tests.yml/badge.svg)](https://github.com/mediadnan/fastchain/actions/workflows/tests.yml)\n![Python versions](https://img.shields.io/pypi/pyversions/fastchain)\n![PyPI version](https://img.shields.io/pypi/v/fastchain)\n![License MIT](https://img.shields.io/github/license/mediadnan/fastchain)\n\n**fastchain** *(functions' chain)* is a python3 tool aiming to ease piping functions by safely chaining\nresults from a function to the other sequentially or simultaneously and reporting failures without breaking the main program.\n\nIt provides tools needed for designing a process pipeline like grouping and branching, tools for creating\nyour own components, and tools for monitoring and debugging the chain process. All with easy and pythonic syntax. \n\nThis system designed based on a philosophy of  **low-latency** use in favour of **cold-starts**,\nin other words the chain and its components should be prepared when your program starts and be ready for use\nwith minimal to no configuration needed, keep it in mind when designing your chains and completely\nseparate configuration state *(constant process values)* that each function needs from pure input data that it expects,\nthat will improve the performance of your program for sure.\nAnd for this reason it is recommended and best suited to live\nin running images or any running service instead of a serverless function.\n\n## The main benefits\n- **Automation** :\n    Automate any data processing pipelines just by passing your functions in the right logical order,\n    then you just need to call one and the rest will be performed automatically.\n- **Decoupling** :\n  Lowers code dependency, so you can create components and function in different\n  modules and call them in one place, no function needs to know about the other.\n- **Cohesiveness** :\n    Encourages you to create functions that have a single responsibility and chain them as units instead\n    of chaining a function that has it internal sequence.\n- **Flexibility** :\n    Refactoring a sequence is a lot easier and safer, you can easily modify the structure of your process \n    flow, combine two, or reuse a part of one in the other.\n- **Scalability** :\n    Adding more functionality and branching is simpler, you can nest as many structures as you need and design\n    complex flows faster.\n- **Simplicity** :\n    Providing and easy and intuitive syntax, you don't need to learn a lot to start using it\n    because you get what you expect, and it's easier to visualize the process flow by just looking at the structure.\n- **Typing** :\n    Encourages you to use annotations *(type hinting)*, you'll get more support, warnings and debugging\n    information if you use type hints, but you can still skip it...\n- **Isolation** :\n    Each of your functions is converted into a node that runs safely, if it fails *(raises an exception)*\n    your main program will not break but only this chain will stop and report the issue.\n- **Monitoring** :\n    You can plug a callback function into the chain, it will be called with a report after each time this \n    chain is executed, and if any failure occurs the reporter will pinpoint the source and give you detailed information \n    about the issue reducing the debugging time and effort. You can also activate logging, so you get live log feeds after each step.\n- **Performance** :\n    This library has been developed with performance in mind, and it will always aim for improving it by time\n    as long as there is room for better optimization.\n- **Support** : \n    This is an actively maintained project, I myself rely on it in other projects and if there's any discovered\n    bug it will soon be fixed, after all it's fully tested and test cases will be added regularly.\n- **Standalone** :\n    This project has no third party dependencies that need to be installed, it only relies on the python\n    standard libraries.\n- **Integrability** :\n    It is easy to use it with other libraries and frameworks as it is a thin layer around your functions,\n    and it supports either ways of integration, to be integrated in or to integrate other tools.\n\n## The need\nAs a lazy developer among many, repetitive tasks such as validating and handling errors *(or any tedious\ntask)* for each step is tiring and takes away the joy and focus from the main idea of a program,\n``fastchain`` was created mainly to automate chaining functions for data processing purposes\ndesigned to live on a remote server and get notified if an anomaly occurs \nwithout breaking the whole system and be able to adapt quickly to change, \nreducing the refactoring energy you have to put if one of your sources changed slightly.\n\nRead more about this tool, it might just be a solution or an improvement for one of your projects.\n\n## Audience\nThis is just a utility not a complete framework, the targeted audience are developers the do any kind\nof data processing with a series of functions that could fail at any step.\n\n## Installation\n\nYou can pip-install it **fastchain** by running the command\n````bash\npip install fastchain\n````\n\n## Main API\n\nThis package contains some funny names that you'll get used to, but when you read ***'chainable function'***\nthat means a functions that takes exactly one positional argument *(or one positional first argument and optional others)*\nand returns a value, that value will be the input for the next ***chainable function*** and so on...\n\n### *fastchain.Chain*\nThe main objects that you'll be using are ``Chain`` instances, \nthe constructor takes the following arguments:\n  + ****chainables*** are positional arguments that define the structure of your workflow, this is where\n    you'll be passing your *chainable functions* and other supported types that will be shown in the examples bellow,\n    passing no chainable will raise a ``ValueError``.\n  + ***title*** is a required keyword argument, it must be a non-empty string, \n    and it should be unique in your program. this string is what identifies your chain in reports, logs ...\n    the chain will warn you if you duplicate names.\n  + ***callback*** is an optional keyword argument default to None, and it should be a function that \n    will be called back when the chain call ends, it must take the Report object as the only (positional) argument\n    and return nothing. Even as it's optional it is highly recommended to pass it because this is a major \n    benefit of this package.\n  + ***log*** is an optional keyword argument default to False, if set to true; the errors will be\n    logged using the standard logging module.\n\nA **chain** can be called with an input value and return the last output result.\n\n##### Example\nLet say that we want to calculate the rounded square root of a number given as a string,\n\n````python\nfrom math import sqrt\nfrom fastchain import Chain\n\nrounded_square_root = Chain(float, sqrt, round, title='rounded_square_root', callback=print)\n\nif __name__ == '__main__':\n    result = rounded_square_root(\"   17  \")\n    assert result == 4\n    assert isinstance(result, int)\n````\nThe result will be an integer 4, this simple sequence works like this:\n\n    \"   17  \" -> [float] -> 17.0 -> [sqrt] -> 4.123105625617661 -> [round] -> 4\n\n*In fact this is overly simplified for example purposes, stripping out the decision nodes...*\n\nThe chain will also report that ```3``` operations succeeded and ```0``` failed.\n\nIn fact, we passed the builtin ``print`` function as callback,\nthe report will be printed to the standard output like this:\n````\n================================================================================\nREPORT: 'rounded_square_root'\nSUMMARY: all components have succeeded\n    3 completed components (3 completed operations)\n    0 failed components (0 failed operations)\n================================================================================\n````\n\nNow if we call ``square_root`` with an invalid string like ``\"a34\"`` the chain will fail at the first function :\n\n    \"a34\" -> [float] !! \"ValueError: could not convert string to float: 'a34'\" -> None\n\nThis time the chain will report ```0``` operations succeeded and ```1``` failed, the Report object will contain\nall the information in case of failure such as the exception object itself (*Exception type, exception message and traceback ...*) , \nthe full title of the failing component *(function)* in this case it will be ```'rounded_square_root :: float (0, 0)'```,\nit follows this pattern ``[chain's name] :: [component's name] [absolute position]`` and ```(0, 0)``` means the first component\non the main sequence, the given input, the returned output, the root and the previous components.\n\nThe string aspect of the report will be as this:\n\n````\n================================================================================\nREPORT: 'rounded_square_root'\nSUMMARY: no component has succeeded\n    0 completed components (0 completed operations)\n    1 failed components (1 failed operations)\n--------------------------------------------------------------------------------\nFAILURES:\n  rounded_square_root :: float (0, 0):\n    - input: 'a34'\n      output: None\n      error: ValueError(\"could not convert string to float: 'a34'\")\n      root: '([float(?) -> ?] => [sqrt(?) -> ?] => [round(?) -> ?])'\n      previous: 'None'\n================================================================================\n````\n\nThere might be other failing scenarios for example if we pass ```\"-5\"``` to ``square_root`` :\n    \n    \"-5\" -> [float] -> -5.0 -> [sqrt] !! \"ValueError: math domain error\" -> None\n\nAnd that will report ```1``` operations succeeded and ```1``` failed ...\n\n---\n\n### *fastchain.chainable*\nThis is a wrapper function that lets you pass some additional metadata together with the functions,\nit takes a function as a positional argument and these two optional keyword arguments:\n\n+ **title** is optional, and it must be a non-empty ``str``, this will override the name of the decorated function. \n if no title is passed the default will be the function's ``__qualname__``.\n+ **default** is optional, it specifies the default value to be returned in case of failure, the default is ``None``.\n\n``chainable`` can be used in two different ways, either as a function :\n\n````python\nfrom fastchain import chainable\n\n\ndef func(number: int) -> int:\n    return 2 * number\n\n\nnew_func = chainable(func, title='double')\n````\n\nor as a decorator\n\n````python\nfrom fastchain import chainable\n\n\n@chainable(title='double')\ndef func(number: int) -> int:\n    return number * 2\n````\n\nAnd this is useful in cases like the following :\n\n+ **Use case 1: renaming a function such as lambda functions to be more informative** : \n````python\nChain( ..., chainable(lambda x: x*2, title='double'), ..., title=... )\n````\n*Now if the function fails at this function the reported name will be ``'double'`` instead of ``'<lambda>'``* \n\n*It is bad practice to pass a raw lambda function, naming them makes it easy to identify.*\n+ **Use case 2: setting the default value if the function fails** :\n````python\nChain( ..., chainable(int, default=0), ..., title=... )\n````\n*If the function fails here the returned value will be ``0`` instead of ``None``*\n\n*This is useful when the type or value matters regardless of the success state, and that if you're using a strict\nvalidation system such as ``pydantic``*\n\n*Note that you can use both ``chainable(lambda x: x*2, title='double', default=0)``* or \nnone ``chainable(lambda x: x*2)``, but using none is the same as passing ``lambda x: x*2`` itself.  \n\n---\n### *fastchain.funfact*\n``funfact`` stands for **function factory**, it is a decorator, and it has the same purpose as ``fastchain.chainable()``\nbut it decorates higher order functions *(or function factories)* and those are functions that produce functions.\nthis is useful when you need to prepare some settings then output a function...\n\nYou need to use this decorator in scenarios like those:\n\n+ **Use case 1: need to prepare some state to be ready for use**\n\n````python\nfrom fastchain import funfact\n\n\n@funfact\ndef my_func(*args, **kwargs):\n    def func(arg: list[str]) -> str:\n        pass\n\n    # do some expensive initializations and preparations\n    # based on *args and **kwargs\n    return func\n````\n``my_func`` now takes **args* and ***kwargs* and two extra keyword arguments \n***title*** and ***default*** like ``chainable()``\n\nCalling ``my_func`` now acts like calling ``chainable`` they both return a ``Wrapper``\nobject that's used by ``Chain`` to create the right component.\n\nThis\n````python\n@funfact\ndef function_factory(*args, **kwargs):\n    def func(a: int) -> bool:\n        pass\n    # some code here\n    return func\n\nfun_config = function_factory(..., default=False)\n````\n\nIs similar to this\n\n````python\ndef function_factory(*args, **kwargs):\n    def func(a: int) -> bool:\n        pass\n    # some code here\n    return func\n\nfun_config = chainable(function_factory(...), default=False)\n````\n\n*The only difference here as we didn't specify the **title**, the first one will be ``'function_factory'``\nand the second one will be ``'function_factory.<locals>.func'``*\n\n+ **Use case 2: need to slightly modify the behaviour of the function**\n````python\n@funfact\ndef power(exponent: int):\n    def func(base: float) -> float:\n        return base ** exponent\n    return func\n\nmain_chain = Chain(..., power(2, title='square'), ..., power(3, title='cube'))\n````\n+ **Use case 3: need to output a different functions for different a configurations**\n````python\n@funfact\ndef some_func(validate: bool = False):\n    def func_with_validations(a: str) -> str:\n        ...\n    def func_optimized_no_validations(a: str) -> str:\n        ...\n    # some code here\n    return func_with_validations if validate else func_optimized_no_validations\n````\n+ **Use case 4: need to use it as a class decorator**\n````python\n@funfact\nclass MyCallable:\n    def __init__(self, *args, **kwargs):\n        ...\n\n    def __call__(self, arg: list[int]) -> int:\n        ...\n````\n\n*If you want to use the class approach, you definitely **must** implement\nthe ``__call__`` dunder method, otherwise an exception will be raised.*\n\n*And if you call MyCallable without specifying the title, the default title will be **``MyCallable instance``***\n\n---\n\n# Chain design options\n## Map option\nThis option useful when you have a function that returns a list, a tuple or any iterable, and you need to apply\nthe next function to each item instead of applying it to all the collection at once. for this ***fastchain*** offers\nan easy syntax to mark the next functions as function that need to be mapped, and that by passing ``'*'`` before them.\n\n##### Example\nLet's do some arithmetics again, consider that we have this string ``\"-134.76, 103.4 , -89.34\"``\nand we need to extract the rounded absolute value of each number.\n\n````python\nfrom fastchain import Chain, funfact\n\n\n@funfact\ndef str_split(sep: str = None):\n    def split(text: str) -> list[str]:\n        return text.split(sep)\n\n    if not (isinstance(sep, str) or sep is None):\n        raise ValueError('sep must be a string')\n    return split\n\n\nabs_rounded_values = Chain(\n    str_split(',', title='split_by_commas', default=[]),\n    '*',\n    float,\n    abs,\n    round,\n    title=\"abs_rounded_values\"\n)\n\nif __name__ == '__main__':\n    result = abs_rounded_values(\"-134.76, 103.4 , -89.34\")\n    assert list(result) == [135, 103, 89]\n````\n\nIt works like this:\n\n                                                                      | \"-134.76\" -> (float) -...-> (round) -> 135 |\n    \"-134.76, 103.4 , -89.34\" -> (split) -> [\"-134.76\", ...] -> (*) ->| \" 103.4 \" -> (float) -...-> (round) -> 103 | -> (list) -> [135, 103, 89]\n                                                                      | \" -89.34\" -> (float) -...-> (round) -> 89  |\n\n*Again this is overly simplified, the ``ChainMapperOption`` produces a generator, it gets evaluated **lazily**\nwhen we applied ``list()``. and this is an optimization detail*\n\n*And yes, we can choose the type of collection (e.g ``list``, ``tuple``, ``set``, ...) right inside the chain,\nrefer to the next examples down bellow...*\n\n##### Advantages *(Reminder)*\n\nBasically you can achieve the same result by creating a function like this :\n````python\ndef abs_rounded_values(text: str, sep=','):\n    \"\"\"gets the absolute rounded values from a string of numbers\"\"\"\n    return (round(abs(float(item))) for item in text.split(sep))\n````\nBut using a chain instead of function that do it all has better advantages :\n1. It gives you **flexibility**, so you can insert, substitute or remove a step in your workflow in one place.\n2. It gives you **scalability**, the chain parses its elements recursively, so you can nest and group workflows\nas deep as you need, more on that down bellow.\n3. It gives you **readability**, you can easily see and design the structure of your workflow.\n4. It gives you **fault tolerance** and **debugging information**, and that is the most important:\n\nImagine that you have a backend app, and you get ```\"534,abc\"``` , the app will break when trying to \nconvert ``'abc'`` into a ``float``, or you need to refactor your functions and add some nested ``try...except``\nblocks and manually then add specific handlers for each step then attach some callback, maybe add some loggings...,\nand you see that gets uglier quickly, and it's far less scalable and more error-prone...\n\nBy using the fist approach (``fastchain.Chain``), this is handled by default, in case of failures like this,\nit will return a default value without breaking your code,\nand calling your report callback with all the details,\nthe report callback can be a function that you create, it should get the report object and perform some logic on it,\nlike analysing it, and then dispatching some kind of event *such as sending notifications...*\n\n---\n\n## Grouping option\nThis is used for grouping a sequence of chainable functions, by default there is only one group, and it's the main \nsequence you provide to ``fastchain.Chain``, but in some cases you might need to use subgroups, and you do that by\nsurrounding the chainable functions by ``()``.\n\nThis is mostly needed to mark an end for a mapped sequence.\n\n##### Example\nSay that we have this raw data feed :\n\n``\"text-1, text-2, text-3\"``\n\nAnd we want it to be like this :\n\n````html\n<main>\n    <div>text-1</div>\n    <div>text-2</div>\n    <div>text-3</div>\n</main>\n````\n\nThe code can be like that :\n\n````python\nfrom fastchain import Chain, funfact, chainable\n\n\n@funfact\ndef add_tag(tag_name: str, ):\n    def tag_func(text: str) -> str:\n        return f\"<{tag_name}>{text}</{tag_name}>\"\n\n    return tag_func\n\n\npipeline = Chain(\n    (\n        chainable(lambda x: x.split(','), title='split_articles'),\n        '*',\n        str.strip,\n        add_tag('div', title='add_div_tag'),\n    ),\n    chainable(lambda x: ''.join(x), title='join_articles'),\n    add_tag('main', title='add_main_tag'),\n    title='str_to_html_pipeline'\n)\n````\n\nThe steps are performed like :\n\n                                                                   | \"text-1\"  -> \"text-1\" -> \"<div>text-1</div>\" |                       \n    \"text-1, text-2, text-3\" -> [\"text-1\", \" text-2\", \" text-3\"] ->| \" text-2\" -> \"text-2\" -> \"<div>text-2</div>\" | -> \"<div>text-1</div><div>text-2</div><div>text-3</div> ->\"<main><div>text-1</div><div>text-2</div><div>text-3</div></main>\"\n                                                                   | \" text-3\" -> \"text-3\" -> \"<div>text-3</div>\" |\n\nWithout grouping the fist part, the results wouldn't be reunited, here's two cases :\n##### With grouping ``()``\n\n                                          |-> [str.strip] -> [add_div_tag] |\n    (start) -> [split_articles] -> [*] -> |-> [str.strip] -> [add_div_tag] |-> [join_articles] -> [add_main_tag] -> (end)\n                                          |-> [str.strip] -> [add_div_tag] |\n\n##### Without grouping ``()``\n\n                                          |-> [str.strip] -> [add_div_tag] -> [join_articles] -> [add_main_tag] |\n    (start) -> [split_articles] -> [*] -> |-> [str.strip] -> [add_div_tag] -> [join_articles] -> [add_main_tag] |-> (end)\n                                          |-> [str.strip] -> [add_div_tag] -> [join_articles] -> [add_main_tag] |\n\n*Grouping is also required when creating a sub-chain, the example bellow makes use of that*\n\n*Elements between ```()``` get packed into a ``ChainGroup`` object.*\n\n*``ChainGroup`` objects fails if **ANY** of it elements fail.*\n\n---\n\n## Branching option\nThis option is useful when you get to a step that needs to be branched, in other words multiple sub-chains depends on\nthe same previous result, each branch should have a unique name, the syntax for this is a ``dict``\nthat maps branches' names ``str`` to a chainable function, group of chainables, a dictionary or any other supported option...\n\nYou can achieve this by providing a dictionary of instructions (called Chain model) and getting back a dictionary of results.\n\n##### Example\n\nLet say we have a string representing a list of numbers ``\"1, 2, 4, 3, 2, 4, 0, 1, 8, 9, 0, 1, 4, 2, 1, 2, 2, 4, 1, 0, 6\"``\nand we want to perform some statistics on them.\n\n````python\nfrom statistics import mode, mean, median\nfrom fastchain import Chain, chainable\n\nanalyze_numbers = Chain(\n    (\n        chainable(lambda x: x.split(','), title='split_by_commas'),\n        '*',\n        int\n    ),\n    {\n        'max': max,\n        'min': min,\n        'mode': mode,\n        'mean': (mean, chainable(lambda dn: round(dn, 2), title='round_2d')),\n        'median': median,\n    },\n    title='analyze_numbers'\n)\n\nif __name__ == '__main__':\n    from pprint import pp\n\n    result = analyze_numbers(\"1, 2, 4, 3, 2, 4, 0, 1, 8, 9, 0, 1, 4, 2, 1, 2, 2, 4, 1, 0, 6\")\n    pp(result)\n````\n\nThe result will be like that:\n\n`````\n{'max': 9, 'min': 0, 'mode': 1, 'mean': 2.71, 'median': 2}\n`````\n\nIf everything goes without failing, the process will be like that :\n\n                                                         analyze_numbers / max   : (1, 2, ...) -> 9                          |\n                                        | '1'  -> 1 |    analyze_numbers / min   : (1, 2, ...) -> 0                          |\n    \"1, 2, ...\"  -> [\"1\", \" 2\", ...] -> | ' 2' -> 2 | -> analyze_numbers / mode  : (1, 2, ...) -> 1                          |-> {'max': 9, ...}\n                                        |    ...    |    analyze_numbers / median: (1, 2, ...) -> 2                          |\n                                                         analyze_numbers / mean  : (1, 2, ...) -> 2.7142857142857144 -> 2,71 |\n\nIf a failure occurs in the third step ``(int)``, the error will be reported under the title ``analyze_numbers :: int (0, 0, 2)``\nwith ``analyze_numbers`` being the title of the chain ``int`` being the name of the node and ``(0, 0, 2)`` being its\nabsolute position *(second 0 indicates the first subgroup and 2 indicates the third item in it)*\n\nBut if a failure occurs inside the model, say in ``round`` function, the error will be reported under the title\n``analyze_numbers / mean :: round_2d (0, 1, 1)`` giving you the branch information, the component's name and the position, \nas it is the second in its main chain.\n\n*The ``dict`` gets converted into a ``ChainModel`` object*\n\n*``ChainModel`` objects fails if **ALL** it branches fail.*\n\n---\n## More\nThis is just an introduction, ``fastchain`` documentation is intended to be created later and that will cover in depth\nusage and more example, it will also cover object documentation ``ChainModel``, ``ChainGroup``, ``ChainFunc``, and \n``Report`` objects.\n\nMeanwhile, if you're an early user, those objects support ``help()`` method and can be represented with ``repr()``,\nand everything is *typed* and has it own *docstring*.\nAfter all this project is fully based on python, explore it yourself, it'll be fun.\n\n# Upcoming features\n+ Support for concurrency, to allow async functions or a mix of coroutines and normal functions and better performance for IO bound operations.\n+ Serialization of chains *(json probably)*, and make it possible to modify and load predefined chains without touching the code.\n+ Adding more predefined utilities, templates and shortcuts for frequent structures. \n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/mediadnan/fastchain",
    "keywords": "chain,function,pipe,flow,processing",
    "license": "MIT",
    "maintainer": "MARSO Adnan",
    "maintainer_email": "",
    "name": "fastchain",
    "package_url": "https://pypi.org/project/fastchain/",
    "platform": null,
    "project_url": "https://pypi.org/project/fastchain/",
    "project_urls": {
      "Homepage": "https://github.com/mediadnan/fastchain",
      "bug-tracker": "https://github.com/mediadnan/fastchain/issues"
    },
    "release_url": "https://pypi.org/project/fastchain/1.0.1/",
    "requires_dist": [
      "mypy (==0.960) ; extra == 'testing'",
      "mypy-extensions (==0.4.3) ; extra == 'testing'",
      "pytest (==7.1.2) ; extra == 'testing'",
      "pytest-cov (==3.0.0) ; extra == 'testing'"
    ],
    "requires_python": ">=3.8",
    "summary": "tool for chain functions easily and safely",
    "version": "1.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14603325,
  "releases": {
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d435c48331dc88950d36f758b8ea28712fe70079f72c8292dd69c61b8bac7bb2",
          "md5": "13edc94e20339dd07a78cdf86b8a0b52",
          "sha256": "8ea37b0f481e03aaddfccb998daa06e9f02cf04a18077994716b3a201b0e7d64"
        },
        "downloads": -1,
        "filename": "fastchain-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "13edc94e20339dd07a78cdf86b8a0b52",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 21692,
        "upload_time": "2022-06-26T16:16:12",
        "upload_time_iso_8601": "2022-06-26T16:16:12.740469Z",
        "url": "https://files.pythonhosted.org/packages/d4/35/c48331dc88950d36f758b8ea28712fe70079f72c8292dd69c61b8bac7bb2/fastchain-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8af11919b98a8cf719cd5eace432c7db5402025e1f0c68b684534dac263b255c",
          "md5": "7bef1c4598ae6948463f4082f96f59bc",
          "sha256": "7400f74b19b5cec51308ebbc258191923d067d58147a1645b5604dc47ae3209d"
        },
        "downloads": -1,
        "filename": "fastchain-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "7bef1c4598ae6948463f4082f96f59bc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 28395,
        "upload_time": "2022-06-26T16:16:14",
        "upload_time_iso_8601": "2022-06-26T16:16:14.698043Z",
        "url": "https://files.pythonhosted.org/packages/8a/f1/1919b98a8cf719cd5eace432c7db5402025e1f0c68b684534dac263b255c/fastchain-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d435c48331dc88950d36f758b8ea28712fe70079f72c8292dd69c61b8bac7bb2",
        "md5": "13edc94e20339dd07a78cdf86b8a0b52",
        "sha256": "8ea37b0f481e03aaddfccb998daa06e9f02cf04a18077994716b3a201b0e7d64"
      },
      "downloads": -1,
      "filename": "fastchain-1.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "13edc94e20339dd07a78cdf86b8a0b52",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 21692,
      "upload_time": "2022-06-26T16:16:12",
      "upload_time_iso_8601": "2022-06-26T16:16:12.740469Z",
      "url": "https://files.pythonhosted.org/packages/d4/35/c48331dc88950d36f758b8ea28712fe70079f72c8292dd69c61b8bac7bb2/fastchain-1.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8af11919b98a8cf719cd5eace432c7db5402025e1f0c68b684534dac263b255c",
        "md5": "7bef1c4598ae6948463f4082f96f59bc",
        "sha256": "7400f74b19b5cec51308ebbc258191923d067d58147a1645b5604dc47ae3209d"
      },
      "downloads": -1,
      "filename": "fastchain-1.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "7bef1c4598ae6948463f4082f96f59bc",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 28395,
      "upload_time": "2022-06-26T16:16:14",
      "upload_time_iso_8601": "2022-06-26T16:16:14.698043Z",
      "url": "https://files.pythonhosted.org/packages/8a/f1/1919b98a8cf719cd5eace432c7db5402025e1f0c68b684534dac263b255c/fastchain-1.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}