{
  "info": {
    "author": "TNO MPC Lab",
    "author_email": "mpclab@tno.nl",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Security :: Cryptography",
      "Typing :: Typed"
    ],
    "description": "# TNO MPC Lab - Protocols - Secure Inner Join\n\nThe TNO MPC lab consists of generic software components, procedures, and functionalities developed and maintained on a regular basis to facilitate and aid in the development of MPC solutions. The lab is a cross-project initiative allowing us to integrate and reuse previously developed MPC functionalities to boost the development of new protocols and solutions.\n\nThe package tno.mpc.protocols.secure_inner_join is part of the TNO Python Toolbox.\n\nThe research activities that led to this protocol and implementation took place in the BigMedilytics project that received funding from the European Union's Horizon 2020 research and innovation program under grant agreement No. 780495.  \nWithin the [LANCELOT](https://www.tno.nl/en/about-tno/news/2021/11/lancelot-new-collaboration-between-iknl-and-tno-to-enable-privacy-preserving-analyses-on-cancer-related-data/) project, a collaboration between TNO, IKNL and Janssen, TNO developed and implemented secure approximate matching solutions on top of this. LANCELOT is partly funded by PPS-surcharge for Research and Innovation of the Dutch Ministry of Economic Affairs and Climate Policy.\n\n*Limitations in (end-)use: the content of this software package may solely be used for applications that comply with international export control laws.*  \n*This implementation of cryptographic software has not been audited. Use at your own risk.*\n\n## Documentation\n\nDocumentation of the tno.mpc.protocols.secure_inner_join package can be found [here](https://docs.mpc.tno.nl/protocols/secure_inner_join/1.0.0).\n\n## Install\n\nEasily install the tno.mpc.protocols.secure_inner_join package using pip:\n```console\n$ python -m pip install tno.mpc.protocols.secure_inner_join\n```\n\nIf you wish to run the tests you can use:\n```console\n$ python -m pip install 'tno.mpc.protocols.secure_inner_join[tests]'\n```\n\n### Note:\nA significant performance improvement can be achieved by installing the GMPY2 library.\n```console\n$ python -m pip install 'tno.mpc.protocols.secure_inner_join[gmpy]'\n```\n\n## Protocol description\nWe consider a three-party setting with two data owners and one helper party. The protocol is passively secure and a visual representation of the protocol is shown below.\n\nFor more information see [Blog: Identifying heart failure patients at high risk using MPC](https://medium.com/applied-mpc/identifying-heart-failure-patients-at-high-risk-using-mpc-ab8900e75295) and/or [Video: Identifying heart failure risks with Multi-Party Computation](https://youtu.be/hvBb80eXuZg).\n\n*Note:* more information on the secure approximate matching (fuzzy matching) protocol is found [here](#secure-approximate-matching-fuzzy-matching).\n\n![Protocol diagram](https://raw.githubusercontent.com/TNO-MPC/protocols.secure_inner_join/main/assets/protocol_description.svg)\n\n## Usage\n\nThe protocol is asymmetric. To run the protocol you need to run separate instances, one for the helper party and one for each data party (at least two data parties are required).\n\n<details>\n<summary>\nExact matching\n\n</summary>\n\n*Note*: Identifiers are assumed to be unique.\n \n> `example_usage.py`\n> ```python\n> \"\"\"\n>     Example usage for performing secure set intersection with a variable number of players\n>     Run four separate instances e.g.,\n>     $ python example_usage.py -p Alice\n>     $ python example_usage.py -p Bob\n>     $ python example_usage.py -p Charlie\n>     $ python example_usage.py -p Henri\n> \n>     This protocol can be run with any number of data parties that is greater than or equal to 2. A helper party (Henri)\n>     is always required\n> \"\"\"\n> import argparse\n> import asyncio\n> from typing import Optional\n> \n> import pandas as pd\n> \n> from tno.mpc.communication import Pool\n> \n> from tno.mpc.protocols.secure_inner_join import DatabaseOwner, Helper\n> \n> \n> def parse_args():\n>     parser = argparse.ArgumentParser()\n>     parser.add_argument(\n>         \"-p\",\n>         \"--player\",\n>         help=\"Name of the sending player\",\n>         type=str.lower,\n>         required=True,\n>         choices=(\"alice\", \"bob\", \"charlie\", \"henri\"),\n>     )\n>     args = parser.parse_args()\n>     return args\n> \n> \n> async def main(player_instance):\n>     await player_instance.run_protocol()\n>     if player_instance.identifier in player_instance.data_parties:\n>         print(\"Gathered shares:\")\n>         print(player_instance.feature_names)\n>         print(player_instance.shares)\n> \n> \n> if __name__ == \"__main__\":\n>     # Parse arguments and acquire configuration parameters\n>     args = parse_args()\n>     player = args.player\n>     parties = {\n>         \"alice\": {\"address\": \"127.0.0.1\", \"port\": 8080},\n>         \"bob\": {\"address\": \"127.0.0.1\", \"port\": 8081},\n>         \"charlie\": {\"address\": \"127.0.0.1\", \"port\": 8082},\n>         \"henri\": {\"address\": \"127.0.0.1\", \"port\": 8083},\n>     }\n> \n>     port = parties[player][\"port\"]\n>     del parties[player]\n> \n>     pool = Pool()\n>     pool.add_http_server(port=port)\n>     for name, party in parties.items():\n>         assert \"address\" in party\n>         pool.add_http_client(\n>             name, party[\"address\"], port=party[\"port\"] if \"port\" in party else 80\n>         )  # default port=80\n> \n>     df: Optional[pd.DataFrame] = None\n>     if player == \"henri\":\n>         player_instance = Helper(\n>             data_parties=(\"alice\", \"bob\", \"charlie\"),\n>             identifier=player,\n>             pool=pool,\n>         )\n>     else:\n>         if player == \"alice\":\n>             df = pd.DataFrame(\n>                 {\n>                     \"identifier\": [\"Thomas\", \"Michiel\", \"Bart\", \"Nicole\", \"Alex\"],\n>                     \"feature_A1\": [2, -1, 3, 1, 0],\n>                     \"feature_A2\": [12.5, 31.232, 23.11, 8.3, 20.44],\n>                 }\n>             )\n>         elif player == \"bob\":\n>             df = pd.DataFrame(\n>                 {\n>                     \"identifier\": [\n>                         \"Thomas\",\n>                         \"Victor\",\n>                         \"Bart\",\n>                         \"Michiel\",\n>                         \"Tariq\",\n>                         \"Alex\",\n>                     ],\n>                     \"feature_B1\": [5, 231, 30, 40, 42, 11],\n>                     \"feature_B2\": [10, 2, 1, 8, 6, 5],\n>                 }\n>             )\n>         elif player == \"charlie\":\n>             df = pd.DataFrame(\n>                 {\n>                     \"identifier\": [\"Bart\", \"Thomas\", \"Michiel\", \"Robert\"],\n>                     \"feature_B1\": [-1, -5, 100, 23.3],\n>                     \"feature_B2\": [10, 12, 8, 5],\n>                 }\n>             )\n>         player_instance = DatabaseOwner(\n>             data_parties=(\"alice\", \"bob\", \"charlie\"),\n>             identifier=player,\n>             identifiers=df[[\"identifier\"]].to_numpy(dtype=str),\n>             data=df.to_numpy(dtype=object)[:, 1:, None],\n>             feature_names=tuple(df.columns[1:]),\n>             pool=pool,\n>         )\n> \n>     loop = asyncio.get_event_loop()\n>     loop.run_until_complete(main(player_instance))\n> ```\n \nRun four separate instances specifying the players:\n```console\n$ python example_usage.py -p Alice\n$ python example_usage.py -p Bob\n$ python example_usage.py -p Charlie\n$ python example_usage.py -p Henri\n```\nThis protocol can be run with any number of data parties that is greater than or equal to 2. A helper party (Henri) is always required.\n\n</details>\n\n<details>\n<summary>\nFuzzy/approximate matching\n\n</summary>\n\n> `data/player_1.csv`\n> ```csv\n> first_name,last_name,date_of_birth,zip6_code,gender_at_birth,correct_match_A\n> Tomas,Roijackers,09-01-1874,1234AB,M,-1\n> Tomas,Rooiakkers,06-12-1874,1232XY,M,3\n> Tomas,Rooijackers,16-02-1875,5712DX,M,5\n> Tomas,Roijackers,09-01-1874,7521LS,M,4\n> Thomas,Rooijakkers,09-01-1874,1234AB,M,1\n> Thomas,Rooijakkers,06-12-1874,1234AB,F,-2\n> Thomas,Rooijakkers,09-01-1830,1234AB,M,-3\n> Thomas,Someone-else,01-01-1873,6789CD,M,-4\n> Victor,Li,09-01-1823,6231LI,M,-5\n> Bart,Kamphoorst,07-06-1872,3412CD,M,6\n> Michiel,Marcus,06-05-1874,1382SH,M,2\n> Tariq,Bontekoe,24-12-1873,8394HG,M,-6\n> ```\n\n> `data/player_2.csv`\n> ```csv\n> first_name,last_name,date_of_birth,zip6_code,gender_at_birth,correct_match_B\n> Michiel,Marcus,06-05-1874,1234AB,M,2\n> Thomas,Rooijakkers,09-01-1874,8972ZX,M,-1\n> Thomas,Rooijakkers,09-01-1874,1234AB,M,1\n> Thomas,Rooijakkers,06-12-1874,1234AB,M,3\n> Thomas,Rooijakkers,17-02-1876,5634AB,M,5\n> Thomas,Rooijakkers,09-01-1874,7534CD,M,4\n> Bart,Kamphorst,06-06-1872,3412CD,M,6\n> Bart,Who,06-12-1875,3231CD,M,-2\n> Nicole,Gervasoni,30-01-1877,3411AS,F,-3\n> ```\n\n> `example_usage.py`\n> ```python\n> \"\"\"\n>     Example usage for performing secure fuzzy matching with a variable number of players\n>     Run three separate instances e.g.,\n>     $ python example_usage.py -p Alice\n>     $ python example_usage.py -p Bob\n>     $ python example_usage.py -p Henri\n> \n>     This protocol can be run with any number of data parties that is greater than or equal to 2. A helper party (Henri)\n>     is always required\n> \"\"\"\n> import argparse\n> import asyncio\n> \n> import pandas as pd\n> \n> from tno.mpc.communication import Pool\n> \n> from tno.mpc.protocols.secure_inner_join import DatabaseOwner, Helper\n> \n> \n> def parse_args():\n>     parser = argparse.ArgumentParser()\n>     parser.add_argument(\n>         \"-p\",\n>         \"--player\",\n>         help=\"Name of the sending player\",\n>         type=str.lower,\n>         required=True,\n>         choices=(\"alice\", \"bob\", \"henri\"),\n>     )\n>     args = parser.parse_args()\n>     return args\n> \n> \n> async def main(player_instance):\n>     await player_instance.run_protocol()\n>     if player_instance.identifier in player_instance.data_parties:\n>         print(\"Gathered shares:\")\n>         print(player_instance.feature_names)\n>         print(player_instance.shares)\n> \n> \n> async def generate_instance(player):\n>     parties = {\n>         \"alice\": {\"address\": \"127.0.0.1\", \"port\": 8080},\n>         \"bob\": {\"address\": \"127.0.0.1\", \"port\": 8081},\n>         \"charlie\": {\"address\": \"127.0.0.1\", \"port\": 8082},\n>         \"henri\": {\"address\": \"127.0.0.1\", \"port\": 8083},\n>     }\n> \n>     port = parties[player][\"port\"]\n>     del parties[player]\n> \n>     pool = Pool()\n>     pool.add_http_server(port=port)\n>     for name, party in parties.items():\n>         assert \"address\" in party\n>         pool.add_http_client(\n>             name, party[\"address\"], port=party[\"port\"] if \"port\" in party else 80\n>         )  # default port=80\n> \n>     if player == \"henri\":\n>         player_instance = Helper(\n>             data_parties=(\"alice\", \"bob\"),\n>             identifier=player,\n>             pool=pool,\n>         )\n>     else:\n>         if player == \"alice\":\n>             df = pd.read_csv(\"data/player_1.csv\")\n>         elif player == \"bob\":\n>             df = pd.read_csv(\"data/player_2.csv\")\n>         player_instance = DatabaseOwner(\n>             data_parties=(\"alice\", \"bob\"),\n>             identifier=player,\n>             identifiers=df[\n>                 [\n>                     \"first_name\",\n>                     \"last_name\",\n>                     \"date_of_birth\",\n>                     \"zip6_code\",\n>                     \"gender_at_birth\",\n>                 ]\n>             ].to_numpy(dtype=str),\n>             identifiers_phonetic=df[[\"first_name\", \"last_name\"]].to_numpy(dtype=str),\n>             identifiers_phonetic_exact=df[[\"gender_at_birth\"]].to_numpy(dtype=str),\n>             identifier_date=df[[\"date_of_birth\"]].to_numpy(dtype=str),\n>             identifier_zip6=df[[\"zip6_code\"]].to_numpy(dtype=str),\n>             data=df.to_numpy(dtype=object)[:, -1, None],\n>             feature_names=(df.columns[-1],),\n>             pool=pool,\n>         )\n> \n>     await main(player_instance)\n>     return player_instance\n> \n> \n> if __name__ == \"__main__\":\n>     # Parse arguments and acquire configuration parameters\n>     args = parse_args()\n>     player = args.player\n>     loop = asyncio.new_event_loop()\n>     loop.run_until_complete(generate_instance(player))\n> ```\n \n\nRun three separate instances specifying the players:\n```console\n$ python example_usage.py -p Alice\n$ python example_usage.py -p Bob\n$ python example_usage.py -p Henri\n```\nThis protocol can be run with any number of data parties that is greater than or equal to 2. A helper party (Henri) is always required.\n\nCombining the shares should result in (possibly different order):\n```\n[\n  [1 1]\n  [3 3]\n  [6 6]\n  [5 5]\n  [2 2]\n  [4 4]\n]\n```\n\n</details>\n\n# Secure Approximate Matching (Fuzzy Matching)\n\nWithin the [LANCELOT](https://www.tno.nl/en/about-tno/news/2021/11/lancelot-new-collaboration-between-iknl-and-tno-to-enable-privacy-preserving-analyses-on-cancer-related-data/) project, a collaboration between TNO, IKNL and Janssen, TNO developed and implemented secure approximate matching solutions.\n\nWe wish to match two (or more) datasets based on a set of identifying attributes per records, which are available in all datasets. The following attributes were mentioned to be (often) available by the LANCELOT partners:\n- First name\n- Last name\n- Date of birth\n- Gender-at-birth\n- Place of birth\n- Postal code\n\nThere a couple of challenges we wish to resolve\n- There is no identifier\n- There is no unique pseudo-identifier\n- We cannot reveal attributes of the records\n- There are mistakes in the attributes\n- Typos\n- Slightly mismatching data\n\nThe proposed solution can cope with one-off (or more, based on configurable parameters) mistakes in date of birth, and zip2 postal code as well as for mistakes in names (speech-to-text, a subset of possible typos).\n\n## Overview of protocol/algorithm steps\n\n### Setting\nWe consider a setting with (at least) two data owners and a single helper party. The helper party learns the size of the data sets and the size of the intersection, but nothing else. The data owners learn the size of the intersection, the number of features in the other data set(s) and end up with an additive sharing of the intersection. More specifically, for every attribute (data entry) for every matched record a distributed additive share is constructed. These additive shares serve the purpose of secure input for follow-up analysis, where they can be recombined in the encrypted domain to perform computations on the secure inner join.\n\n### High-over steps\nWe first aim to find exact matches securely, i.e., matches where all of the identifying attributes match exactly. On the unmatched remaining data we perform an approximate matching protocol. In summary,\n1. Exact matching,\n2. Approximate matching (on unmatched remaining data).\n\n#### Exact matching\nAs described in https://www.tno.nl/en/tno-insights/articles/identifying-highrisk-factors-diseases and https://youtu.be/hvBb80eXuZg. Steps data owners,\n\n1. Concatenate identifying features into single identifier\n2. Hash concatenation using salted hashing\n3. Encrypt your data features (those that you wish to use for follow-up analysis) using partially homomorphic encryption (Paillier scheme of which you do own the secret key)\n4. Share the hashes along with the encrypted data with the helper party\n7) Generate a masking table[^masking] of the size of the matched data\n8) Encrypt the masking using the public key of the other data owner(s)\n9) Share encrypted masking with the helper party\n12. Decrypt masked encryption of own data to get your masked, matched data\n13. The plaintext masking combined with the masked data equals the plaintext inner join (additive sharing between data parties)\n\n[^masking]: A masking table is a table consisting of randomly generated numbers, which is used to mask (securely hide) the original values of another table of the same dimensions.\n\nSteps helper:\n\n5) Match hashes of data owners (and thereby find the encrypted inner join)\n6) Communicate the size of the intersection to data parties\n10. Subtract masking from the computed inner join\n11. Share masked encryptions of the inner join with there respective data owners\n\nNote: salts are shared between data owners, but **not** with the helper party.\n\n#### Approximate matching\nTo cope with mismatches due to minor mistakes in the data we introduced some additional substeps in the above steps 2. and 5.\n\n2. Prepare hashes  \n  a) Hash concatenation using salted hashing  \n  b) Determine phonetic encoding of the concatenation of first name and last name  \n  c) Add features that should match exactly to this encoding  \n  d) Hash encoding using salted hashing  \n  e) Encode date of birth and 2-zipcode into a (salted) locality-sensitive hash (LSH)  \n  f) Mask locality sensitive hashes (using a seeded random bit mask, all data owners should know and use the same seed)\n\n5) Determine matching  \n  a) Match exact hashes of data owners  \n  b) Match encoded (approximate) hashes of data owners on remaining data  \n  c) Filter encoded matches, which are not necessarily unique, by computing their respective LSH distance  \n  d) Pick the \"best\" matches which satisfy preset constraints on the distances (thresholds)  \n  e) Combine the computed exact and approximate matches into a single (encrypted) inner join\n\n## Assumptions, choices and tackled challenges\n\n### Phonetic encoding\nApplying phonetic encodings on names can be viewed as transforming your data from a high-dimensional space to a space of smaller dimension. In this process, we lose information. This loss of information is beneficial, as this could add in finding similar names. More specifically by transforming written names to their phonetic representation, we can find similarly names based on pronunciation/speech.\n\nAn important things to note is that this helps us to match data that contains misinterpreted/misspelled names by the individual that entered the data (speech-to-text mistakes), and some (but not all) typo's. Typo's are only filtered when they do not influence the pronunciation according to the phonetic algorithm. E.g. \"Jan Janssen\" > 'YANYANSN', \"Jan Jahnssen\" > 'YANYANSN', 'Jan Jansen' > 'YANYANSN', \"Jan Jasnsen\" > 'YANYASNSN'.\n\nWhen applying an phonetic algorithm, we have to decide what the base language should be. It seems to make most sense, as we want to catch speech-to-text errors here, that one should use the mother tongue of the individual that entered the data. \n\nFor our use-case, it is the most likely mother tongue of the person entering the data. As there is no State of the Art phonetic encoding algorithm available for the Dutch language, or Dutch names, we decided that `phonem`[^phonem] would be the best option. The phonem algorithm specifically targets German(ic) names and produces human-interpretable encodings. (Dutch is a West Germanic language)\n\n[^phonem]: [Wilde, Georg ; Meyer, Carsten: Doppelgänger gesucht - Ein Programm fur kontext-sensitive phonetische Textumwandlung. In: ct Magazin fur Computer & Technik 25 (1988)](http://web.archive.org/web/20070209153423/http://uni-koeln.de/phil-fak/phonetik/Lehre/MA-Arbeiten/magister_wilz.pdf)\n\nThis encoding needs to be hashed (similar to the salted hashing procedure in the exact matching part), to ensure the same level of security as in the exact matching case.\n\n### Locality-sensitive hashing\nTo use locality-sensitive hashing, one needs to define a mapping from input to hash in such a way that close inputs remain close in the hash. This requires context-specific reasoning about the term \"close\" and what close means in terms of our input type(s).\n\nFor encoding a date-of-birth we consider its elements (day, month, year) separately. Specifically, we **chose/decided** to go for a simple mapping to a modular space per element. In the future, we could consider constructing a more advanced mapping, by e.g. taking into account the days that are actually possible within a month, (e.g. only 1-28 for February).\n\nWe map date of birth (dd-mm-yy) as follows:\n- Month (mm) is mapped to modular space (mod 12)\n- Day (dd) is mapped to modular space (mod 31)\n- Year (yy) is mapped to modular space (mod 100)\n\n![Mapping month and day [torus]](https://raw.githubusercontent.com/TNO-MPC/protocols.secure_inner_join/main/assets/month_day_torus.svg)\n![Mapping year](https://raw.githubusercontent.com/TNO-MPC/protocols.secure_inner_join/main/assets/year.svg)\n\nFor 2-zip regional codes (i.e., all postal codes with the same first two digits) we made the assumption that people often move within the same (or neighbouring/close) regions. Based on the distribution of 2-zip regions in the Netherlands we **chose/decided** to go for a simple mapping to a line [10-99]. Again, note that more accurate, complicated, mappings could improve the performance of the matching. One could even consider using statistics to base a mapping on (e.g. the likelihood of moving between regions?).\n\nTo conclude, for Dutch zipcode/postal code (1234 AB):\n- 2-zip code (12) is mapped to a line $`[10-99]`$\n\n![2-zip code](https://raw.githubusercontent.com/TNO-MPC/protocols.secure_inner_join/main/assets/zip2.svg)\n\nTo make sure that the produced LSH hashes are secure, we need to mask these with a random (collaboratively determined) bit vector, which is unknown to the helper party. If we would not do this, one (the helper) could learn/guess plaintext values based on the distributions within the hashes.\n\n## Configurable parameters + defaults\n\nFor approximate matching we introduced some configurable parameters. More specifically one can set the thresholds for \"closeness\" of LSH hashes on various levels. There is an option to set an overall threshold function on the weighted distance scores. The intuition behind those scores is that if two input values of the LSH hashing algorithm are one-off (in one of its attributes), the weighted overall distance will be approximately $`1`$ (converges to $`1`$ if the number of hyperplanes goes to infinity). Depending on the (number of and the) randomly picked hyperplanes the distance might deviate a bit from $`1`$. If you wish to support one-offs it makes sense to set the threshold to $`1.5`$, if you are happy to allow two one-off, or one two-off, set it to $`2.5`$, etc. The default threshold function validates that all attributes differ at most $`1.5`$ and the sum of all differences does not surpass $`4.5`$.\n\nOne can also configure the number of slices/hyperplanes to construct for LSH, trivially this number should be equal for all data owners. A default value of $`2000`$ seems to result in sufficient accuracy.\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://pypi.org/project/tno.mpc.protocols.secure_inner_join/#files",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://mpc.tno.nl/",
    "keywords": "TNO,MPC,multi-party computation,protocols,secure inner join,matching,fuzzy,approximate matching",
    "license": "Apache License, Version 2.0",
    "maintainer": "TNO MPC Lab",
    "maintainer_email": "mpclab@tno.nl",
    "name": "tno.mpc.protocols.secure-inner-join",
    "package_url": "https://pypi.org/project/tno.mpc.protocols.secure-inner-join/",
    "platform": "any",
    "project_url": "https://pypi.org/project/tno.mpc.protocols.secure-inner-join/",
    "project_urls": {
      "Documentation": "https://docs.mpc.tno.nl/protocols/secure_inner_join/1.0.0",
      "Download": "https://pypi.org/project/tno.mpc.protocols.secure_inner_join/#files",
      "Homepage": "https://mpc.tno.nl/",
      "Source Code": "https://github.com/TNO-MPC/protocols.secure_inner_join"
    },
    "release_url": "https://pypi.org/project/tno.mpc.protocols.secure-inner-join/1.0.0/",
    "requires_dist": [
      "mypy-extensions",
      "numpy",
      "randomgen",
      "tno.mpc.communication[bitarray] (>=3.1.0)",
      "tno.mpc.encryption-schemes.paillier (>=0.5.0)",
      "tno.mpc.encryption-schemes.paillier[gmpy] ; extra == 'gmpy'",
      "pytest ; extra == 'tests'",
      "pytest-asyncio ; extra == 'tests'"
    ],
    "requires_python": "",
    "summary": "Secure inner join using Paillier homomorphic encryption and a helper party",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13781269,
  "releases": {
    "0.3.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0007d0dcc81d4a5dfe95925dc164bdc5f011790d712b10b69b51c8f125847177",
          "md5": "23e3b035d5be270e0163ff06e9d122ce",
          "sha256": "9bdc1a712ea33bfcadaef49270d6ad55c77867106cac25b767dc4771d6443760"
        },
        "downloads": -1,
        "filename": "tno.mpc.protocols.secure_inner_join-0.3.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "23e3b035d5be270e0163ff06e9d122ce",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 17847,
        "upload_time": "2021-09-10T12:20:30",
        "upload_time_iso_8601": "2021-09-10T12:20:30.697212Z",
        "url": "https://files.pythonhosted.org/packages/00/07/d0dcc81d4a5dfe95925dc164bdc5f011790d712b10b69b51c8f125847177/tno.mpc.protocols.secure_inner_join-0.3.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "09b750b762b24a84d926c84d3110b19d61e20721306ffe6ef4af182ab81166a6",
          "md5": "0466d3a21591375d9c2f17f4179ac0ed",
          "sha256": "04dd9827b7e8515d699fc75c44787f48747377c9025059233e0df321833521e3"
        },
        "downloads": -1,
        "filename": "tno.mpc.protocols.secure_inner_join-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0466d3a21591375d9c2f17f4179ac0ed",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 39906,
        "upload_time": "2022-05-11T11:23:17",
        "upload_time_iso_8601": "2022-05-11T11:23:17.369520Z",
        "url": "https://files.pythonhosted.org/packages/09/b7/50b762b24a84d926c84d3110b19d61e20721306ffe6ef4af182ab81166a6/tno.mpc.protocols.secure_inner_join-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "09b750b762b24a84d926c84d3110b19d61e20721306ffe6ef4af182ab81166a6",
        "md5": "0466d3a21591375d9c2f17f4179ac0ed",
        "sha256": "04dd9827b7e8515d699fc75c44787f48747377c9025059233e0df321833521e3"
      },
      "downloads": -1,
      "filename": "tno.mpc.protocols.secure_inner_join-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0466d3a21591375d9c2f17f4179ac0ed",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 39906,
      "upload_time": "2022-05-11T11:23:17",
      "upload_time_iso_8601": "2022-05-11T11:23:17.369520Z",
      "url": "https://files.pythonhosted.org/packages/09/b7/50b762b24a84d926c84d3110b19d61e20721306ffe6ef4af182ab81166a6/tno.mpc.protocols.secure_inner_join-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}