{
  "info": {
    "author": "Brennan Freeze, Paris Osuch, Aundre Barras, Soren Richenberg, Suzanne Rivoire",
    "author_email": "freezebrennan@gmail.com, osuch@sonoma.edu, barras@sonoma.edu, richenbe@sonoma.edu, rivoire@sonoma.edu",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# README.md\n\n# QCpy - A Quantum Computing Library for Python\n\nQCpy is an open source python library and collaborative project for flexible simulations and visualizations of quantum circuits. Designed by college students with students in mind, this library contains a powerful set of tools to teach computer scientists about the emerging discipline of quantum computing (QC).\n\n## Recommended Resources on Quantum Computing:\n\n- [Microsoft’s Linear Algebra for Quantum Computing](https://learn.microsoft.com/en-us/azure/quantum/overview-algebra-for-quantum-computing)\n- [IBM’s Quantum Computing: a field guide](https://quantum-computing.ibm.com/composer/docs/iqx/guide/)\n- [Wikipedia: Quantum Computing](https://en.wikipedia.org/wiki/Quantum_computing)\n\n---\n\n# Qubits\n\n> ## *class* QC.Qubit.`Qubit`(*initial_state=’z’*)\n\n*Object representation of a qubit.*\n\n### Parameters:\n\n`initial_state (chr)` - Character input for starting direction in the *x*, *y*, or *z* axis.\n\n### Attributes:\n\n`state (numpy.ndarray)` -  current state of qubit in matrix representation.\n\n---\n\n# Quantum Gates\n\n> ## *class* QC.QuantumGate.`Identity`()\n\n*Gate that does not modify the quantum state.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Identity gate.\n\n```python\nIdentity.matrix = [1+0j, 0+0j], \n\t          [0+0j, 1+0j]\n```\n\n> ## *class* QC.QuantumGate.`PauliX`()\n\n*Quantum equivalent of the NOT gate in classical computing with respect to the standard basis |0>, |1>.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Pauli-X gate.\n\n```python\nPauliX.matrix = [0+0j, 1+0j], \n\t        [1+0j, 0+0j]\n```\n\n> ## *class* QC.QuantumGate.`PauliY`()\n\n*Rotation around y-axis of the bloch sphere by π radiains, mapping |0> to i|1> and |1> to -i|0>.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Pauli-Y gate.\n\n```python\nPauliY.matrix = [0+0j, 0-1j],\n                [0+1j, 0+0j]\n```\n\n> ## *class* QC.QuantumGate.`PauliZ`()\n\n*Rotation around z-axis of the bloch sphere by π radiains, mapping |1> to -|1>; known as the phase-flip.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Pauli-Z gate.\n\n```python\nPauliY.matrix = [1+0j, 0+0j], \n                [0+0j, -1+0j]\n```\n\n> ## *class* QC.QuantumGate.`Hadamard`()\n\n*Maps the basis states |0> to |+> and |1> to |->, creating a superposition state if given a computation basis state.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Hadamard gate.\n\n```python\nHadamard.matrix = ([1,  1] \n                   [1, -1]) * (1/sqrt(2))\n```\n\n> ## *class* QC.QuantumGate.`CNot`(*inverse=False*)\n\n*Controlled gate acts on two or more qubits, performing the NOT operation of the target qubit only if the control qubits are |1>, can act as a quantum regiester and is used to entangle and disentangle Bell states.*\n\n### Parameters:\n\n`inverse (bool)` - if the gate is an inverse, with the target being above the control.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of CNOT gate.\n\n```python\n# regular\nCNot.matrix = [1+0j, 0+0j, 0+0j, 0+0j],\n              [0+0j, 1+0j, 0+0j, 0+0j],\n              [0+0j, 0+0j, 0+0j, 1+0j],\n              [0+0j, 0+0j, 1+0j, 0+0j]\n# inverse\nCNot.matrix = [1+0j, 0+0j, 0+0j, 0+0j],\n              [0+0j, 0+0j, 0+0j, 1+0j],\n              [0+0j, 0+0j, 1+0j, 0+0j],\n              [0+0j, 1+0j, 0+0j, 0+0j] \n```\n\n> ## *class* QC.QuantumGate.`Swap`()\n\n*Swaps two qubits, with respect to the basis |00>, |01>, |10>, and |11>.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of SWAP gate.\n\n```python\nSwap.matrix = [1+0j, 0+0j, 0+0j, 0+0j],\n              [0+0j, 0+0j, 1+0j, 0+0j],\n              [0+0j, 1+0j, 0+0j, 0+0j],\n              [0+0j, 0+0j, 0+0j, 1+0j]\n```\n\n> ## *class* QC.QuantumGate.`Toffoli`()\n\n*Universal reversible logic gate, known as the “controlled-controlled-NOT” gate; if the two control bits are set to 1, it will invert the target.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Toffoli gate.\n\n```python\nToffoli.matrix = [1+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j],\n                 [0+0j, 1+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j],\n                 [0+0j, 0+0j, 1+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j],\n                 [0+0j, 0+0j, 0+0j, 1+0j, 0+0j, 0+0j, 0+0j, 0+0j],\n                 [0+0j, 0+0j, 0+0j, 0+0j, 1+0j, 0+0j, 0+0j, 0+0j],\n                 [0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 1+0j, 0+0j, 0+0j],\n                 [0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 1+0j],\n                 [0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 0+0j, 1+0j, 0+0j]\n```\n\n> ## *class* QC.QuantumGate.`Phase`(*theta=numpy.pi/2*)\n\n*Applies a rotation of theta around the z-axis.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of Phase gate.\n\n```python\nPhase.matrix = [1+0j, 0+0j],\n\t       [0+0j, numpy.exp(0+1j * theta)]\n```\n\n> ## *class* QC.QuantumGate.`S`()\n\n*Equivalent to a pi/2 rotation around the z-axis.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of S gate.\n\n```python\nS.matrix = [1+0j, 0+0j],\n           [0+0j, 0+1j]\n```\n\n> ## *class* QC.QuantumGate.`Sdg`()\n\n*Inverse of S gate; a -pi/2 rotation around the z-axis.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an inverse S gate.\n\n```python\nSdg.matrix = [1+0j, 0+0j],\n             [0+0j, 0-1j]\n```\n\n> ## *class* QC.QuantumGate.`T`()\n\n*Square of S gate; where T = S^2.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of a T gate.\n\n```python\nT.matrix = [1+0j, 0+0j],\n           [0+0j, numpy.exp((0+1j * numpy.pi) / 4)]\n```\n\n> ## *class* QC.QuantumGate.`Tdg`()\n\n*Inverse of T gate.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of a inverse of T gate.\n\n```python\nTdg.matrix = [1+0j, 0+0j],\n             [0+0j, numpy.exp((0-1j * numpy.pi) / 4)]\n```\n\n> ## *class* QC.QuantumGate.`Rz`(*theta=numpy.pi/2*)\n\n*Rotation of qubit around the z-axis.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Rz gate.\n\n```python\nRz.matrix = [numpy.exp((0-1j * (theta / 2))), 0+0j],\n            [0+0j, numpy.exp(0+1j * (theta / 2))]\n```\n\n> ## *class* QC.QuantumGate.`Rx`(*theta=numpy.pi/2*)\n\n*Rotation of qubit around the x-axis.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around x-axis.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Rx gate.\n\n```python\nRx.matrix = [numpy.cos(theta / 2), 0-1j * numpy.sin(theta / 2)],\n            [0-1j * numpy.sin(theta / 2), numpy.cos(theta / 2)]\n```\n\n> ## *class* QC.QuantumGate.`Ry`(*theta=numpy.pi/2*)\n\n*Rotation of qubit around the y-axis.*\n\n### Parameters:\n\n`theta (float)`default: `numpy.pi/2` -  angle of rotation around y-axis.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Ry gate.\n\n```python\nRy.matrix = [numpy.cos(theta / 2), -1 * numpy.sin(theta / 2)],\n            [numpy.sin(theta / 2), numpy.cos(theta / 2)]\n```\n\n> ## *class* QC.QuantumGate.`Sx`()\n\n*Rotation around the x-axis by 90 degrees in the counter-clockwise direction. Also known as the “square-root X gate” due to the fact that applying the SX gate twice results in an X gate.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Sx gate.\n\n```python\nSx.matrix = [1+1j, 1-1j], \n            [1-1j, 1+1j]]) * (1 / 2)\n```\n\n> ## *class* QC.QuantumGate.`Sxdg`()\n\n*Inverse of the Sx gate.*\n\n### Parameters:\n\n`None`\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an inverse Sx gate.\n\n```python\nSxdg.matrix = [1-1j, 1+1j], \n              [1+1j, 1-1j]]) * (1 / 2)\n```\n\n> ## *class* QC.QuantumGate.`U`(*theta=numpy.pi/2, phi=numpy.pi/2, lmbda=numpy.pi/2*)\n\n*Rotation of qubit with respect to theta, phi, and lambda, in Euler angles.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around Euler angle theta.\n\n`phi (float)` default: `numpy.pi/2` -  angle of rotation around Euler angle phi.\n\n`lmbda (float)` default: `numpy.pi/2` -  angle of rotation around Eulear angle lambda.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of a U gate.\n\n```python\nU.matrix = [numpy.cos(theta / 2), -1 * numpy.exp(0+1j * lmbda) * numpy.sin(theta / 2)], \n           [numpy.exp(0+1j * phi) * numpy.sin(theta / 2), numpy.exp(0+1j * (lmbda + phi)) * numpy.cos(theta / 2)]]\n```\n\n> ## *class* QC.QuantumGate.`Rxx`(*theta=numpy.pi/2*)\n\n*Rotation about XX, maximally entangling at theta = pi/2.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around XX.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Rxx gate.\n\n```python\nRxx.matrix = [numpy.cos(theta / 2), 0+0j, 0+0j, 0-1j * numpy.sin(theta / 2)],\n             [0+0j, numpy.cos(theta / 2), 0-1j * numpy.sin(theta / 2), 0+0j],\n             [0+0j, 0-1j * numpy.sin(theta / 2), numpy.cos(theta / 2), 0+0j],\n             [0-1j * numpy.sin(theta / 2), 0+0j, 0+0j, numpy.cos(theta / 2)]\n```\n\n> ## *class* QC.QuantumGate.`Rzz`(*theta=numpy.pi/2*)\n\n*Rotation about ZZ, maximally entangling at theta = pi/2.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around ZZ.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Rzz gate.\n\n```python\nRzz.matrix = [numpy.exp(0-1j * (theta / 2)), 0+0j, 0+0j, 0+0j],\n             [0+0j, numpy.exp(0+1j * (theta / 2)), 0+0j, 0+0j],\n             [0+0j, 0+0j, numpy.exp(0+1j * (theta / 2)), 0+0j],\n             [0+0j, 0+0j, 0+0j, numpy.exp(0-1j * (theta / 2))]\n```\n\n> ## *class* QC.QuantumGate.`Cr`(*theta=numpy.pi/2*)\n\n*Controlled phase shift rotation in theta radians; generalization of Cz gate.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation in theta radians.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Cr gate.\n\n```python\nCz.matrix = [1+0j, 0+0j, 0+0j, 0+0j],\n            [0+0j, 1+0j, 0+0j, 0+0j],\n            [0+0j, 0+0j, 1+0j, 0+0j],\n            [0+0j, 0+0j, 0+0j, numpy.exp(theta * 0+1j)]\n```\n\n> ## *class* QC.QuantumGate.`Cz`(*theta=numpy.pi/2*)\n\n*Controlled phase shift rotation in theta radians.*\n\n### Parameters:\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation in theta radians.\n\n### Attributes:\n\n`matrix (np.ndarray)` - matrix representation of an Cz gate.\n\n```python\nCz.matrix = [1+0j, 0+0j, 0+0j, 0+0j],\n            [0+0j, 1+0j, 0+0j, 0+0j],\n            [0+0j, 0+0j, 1+0j, 0+0j],\n            [0+0j, 0+0j, 0+0j, -1+0j]\n```\n---\n# Quantum Circuit\n> ## *class* QC.QuantumCircuit.`QuantumCircuit`(*qubits*, *little_endian=False*, *prep='z'*)\n\n*Quantum circuit that represents the state of a quantum system and performs operations on select qubits.*\n\n### Parameters:\n\n`qubits (int)` - number of qubits in the circuit.\n\n`little_endian (bool)` default: `False` - order of qubits and tensor products.\n\n`prep (char)` options: [`z`, `y`, `x`] - initial direction of the qubits' phase angle.\n\n### Attributes:\n\n`None`\n\n> ## QuantumCircuit.`circuit`()\n\n*Dictionary representation of the circuit*\n\n### Parameters:\n\n`None`\n\n### Returns:\n\n`circuit (dict[int, list[str]])` - key: qubit; value: name of gate.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\nqc.cnot(0, 1)\nqc.hadamard(0)\n\nprint(qc.circuit())\n\n# {0: ['hadamard', 'cnot_control', 'hadamard'], \n#  1: ['cnot_target']}\n```\n\n> ## QuantumCircuit.`amplitude`(*round=3*)\n\n*Returns vector of all possible amplitudes for the quantum circuit*\n\n### Parameters:\n\n`round (int)` - rounding the amplitude to the nearest `round`\n\n### Returns:\n\n`amplitude (numpy.ndarray[float16])` - amplitude of the quantum circuit.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\nqc.cnot(0, 1)\nqc.hadamard(0)\n\nprint(qc.amplitude())\n\n# [[0.5]\n# [0.5]\n# [0.5]\n# [0.5]]\n```\n\n> ## QuantumCircuit.`phaseAngle`(*round=2*, *radian=True*)\n\n*Calculates possible phase angles for the quantum circuit*\n\n### Parameters:\n\n`round (int)` - rounding the amplitude to the nearest `round`\n\n`radian (bool)` - whether or not the values are in radians or degrees.\n\n### Returns:\n\n`phase_angle (numpy.ndarray)` - array of qubit's phase angle.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\nqc.cnot(0, 1)\nqc.hadamard(0)\n\nprint(qc.phaseAngle())\n\n# [[0.        ]\n# [0.         ]\n# [0.         ]\n# [3.14159265]]\n```\n\n> ## QuantumCircuit.`state`(*round=3*)\n\n*Returns state of the quantum circuit.*\n\n### Parameters:\n\n`round (int)` - rounding the state to the nearest `round`\n\n### Returns:\n\n`_state (numpy.ndarray)` - array of quantum circuit's state.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\nqc.cnot(0, 1)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.   +0.j]\n# [0.707+0.j]]\n```\n\n> ## QuantumCircuit.`probabilities`(*round=3*)\n\n*Returns probabilitiy of the qubits within the quantum circuit.*\n\n### Parameters:\n\n`round (int)` - rounding the probabilities to the nearest `round`\n\n### Returns:\n\n`prob_matrix (numpy.ndarray)` - array of quantum circuit's probabilities.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.cnot(0, 1)\n\nprint(qc.probabilities())\n\n# [0.5 0.  0.  0.5]\n```\n\n> ## QuantumCircuit.`measure`()\n\n*Collapses the state based on the quantum circuit's probabilities.*\n\n### Parameters:\n\n`None`\n\n### Returns:\n\n`final_state (numpy.ndarray)` - array of quantum circuit's measurement.\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\nqc.cnot(0, 1)\n\nprint(qc.measure())\n\n# ~Results may vary~\n# 00\n```\n\n> ## QuantumCircuit.`reverse`()\n\n*Reverses the quantum circuit's values.*\n\n### Parameters:\n\n`None`\n\n### Returns:\n\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nprint(qc.state())\n\nqc.reverse()\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]]\n \n# [[0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]]\n```\n> ## QuantumCircuit.`toffoli`(*control_1*, *control_2*, *target*)\n\n*A 3-qubit quantum gate that takes in two control qubits and one target qubit.*\n\n### Parameters:\n\n`control_1 (int)` - first control qubit.\n\n`control_2 (int)` - second control qubit.\n\n`target (int)` - target qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(3)\n\nqc.hadamard(0)\n\nqc.hadamard(1)\n\nqc.toffoli(0,1,2)\n\nprint(qc.state())\n\n# [[0.5+0.j]\n# [0. +0.j]\n# [0.5+0.j]\n# [0. +0.j]\n# [0.5+0.j]\n# [0. +0.j]\n# [0. +0.j]\n# [0.5+0.j]]\n```\n\n> ## QuantumCircuit.`rccx`(*control_1*, *control_2*, *target*)\n\n*A 3-qubit quantum gate that takes in two control qubits and one target qubit.*\n\n### Parameters:\n\n`control_1 (int)` - first control qubit.\n\n`control_2 (int)` - second control qubit.\n\n`target (int)` - target qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(3)\n\nqc.hadamard(0)\n\nqc.hadamard(1)\n\nqc.rccx(0,1,2)\n\nprint(qc.state())\n\n# [[ 0.5-0.j ]\n# [ 0. +0.j ]\n# [ 0.5-0.j ]\n# [ 0. +0.j ]\n# [ 0.5-0.j ]\n# [ 0. +0.j ]\n# [-0. +0.j ]\n# [ 0. +0.5j]]\n```\n\n> ## QuantumCircuit.`rc3x`(*a*, *b*, *c*, *d*)\n\n*A 4-qubit quantum gate that takes in 4 unique qubits.*\n\n### Parameters:\n\n`a (int)` - first input qubit.\n\n`b (int)` - second input qubit.\n\n`c (int)` - third input qubit.\n\n`d (int)` - fourth input qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(4)\n\nqc.hadamard(0)\n\nqc.hadamard(1)\n\nqc.hadamard(2)\n\nqc.rc3x(0,1,2)\n\nprint(qc.state())\n\n# [[ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.354-0.j   ]\n# [ 0.   +0.j   ]\n# [ 0.   +0.354j]\n# [-0.   +0.j   ]\n# [ 0.   -0.j   ]\n# [-0.354+0.j   ]]\n```\n> ## QuantumCircuit.`cnot`(*control*, *target*)\n\n*A 2-qubit quantum gate that takes in a control qubit and one target qubit.*\n\n### Parameters:\n\n`control (int)` - control qubit.\n\n`target (int)` - target qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.cnot(0,1)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.   +0.j]\n# [0.707+0.j]]\n```\n\n> ## QuantumCircuit.`cr`(*control*, *target*)\n\n*A 2-qubit quantum gate that takes in a control qubit and one target qubit.*\n\n### Parameters:\n\n`control (int)` - control qubit.\n\n`target (int)` - target qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.cr(0,1)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]]\n```\n\n\n> ## QuantumCircuit.`cz`(*control*, *target*)\n\n*A 2-qubit quantum gate that takes in a control qubit and one target qubit.*\n\n### Parameters:\n\n`control (int)` - control qubit.\n\n`target (int)` - target qubit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.cz(0,1)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]]\n```\n\n> ## QuantumCircuit.`swap`(*qubit_1*, *qubit_2*)\n\n*A 2-qubit quantum gate that takes in 2 qubits to swap there properties.*\n\n### Parameters:\n\n`qubit_1 (int)` - first qubit to swap.\n\n`qubit_2 (int)` - second qubit to swap.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.swap(0,1)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.707+0.j]\n# [0.   +0.j]\n# [0.   +0.j]]\n```\n\n> ## QuantumCircuit.`rxx`(*qubit_1*, *qubit_2*, *theta=numpy.pi/2*)\n\n*A 2-qubit quantum gate that takes in two qubits and a representation of theta to initialize in the quantum state.*\n\n### Parameters:\n\n`qubit_1 (int)` - first qubit input.\n\n`qubit_2 (int)` - second qubit input.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.rxx(0,1)\n\nprint(qc.state())\n\n# [[0.5+0.j ]\n# [0. -0.5j]\n# [0.5+0.j ]\n# [0. -0.5j]]\n```\n\n> ## QuantumCircuit.`rzz`(*qubit_1*, *qubit_2*, *theta=numpy.pi/2*)\n\n*A 2-qubit quantum gate that takes in two qubits and a representation of theta to initialize in the quantum state.*\n\n### Parameters:\n\n`qubit_1 (int)` - first qubit input.\n\n`qubit_2 (int)` - second qubit input.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.rxx(0,1)\n\nprint(qc.state())\n\n# [[0.5+0.j ]\n# [0. -0.5j]\n# [0.5+0.j ]\n# [0. -0.5j]]\n```\n\n> ## QuantumCircuit.`customControlPhase`(*control*, *target*, *custom_matrix*)\n\n*Used to insert single qubit based quantum gates to have a control qubit apart of it and committing to the quantum state.*\n\n### Parameters:\n\n`control (int)` - control qubit for given matrix.\n\n`target (int)` - target qubit for given matrix.\n\n`custom_matrix (np.array)` -  matrix to be applied to the quantum circuit.\n\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nfrom QCpy.QuantumGate import PauliX\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.customControlPhase(0,1, PauliX().matrix)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.   +0.j]\n# [0.707+0.j]]\n```\n\n> ## QuantumCircuit.`identity`(*qubit*)\n\n*Used to confirm value that a qubit is representing and does nothing to manipulate the value of such qubit.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the identity gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.identity(0)\n\nprint(qc.state())\n\n# [[1.+0.j]\n# [0.+0.j]\n# [0.+0.j]\n# [0.+0.j]]\n```\n\n> ## QuantumCircuit.`x`(*qubit*)\n\n*Used to invert the value of what a qubit is representing.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Pauli-X gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.x(0)\n\nprint(qc.state())\n\n# [[0.+0.j]\n# [0.+0.j]\n# [1.+0.j]\n# [0.+0.j]]\n```\n\n\n> ## QuantumCircuit.`hadmard`(*qubit*)\n\n*Used to put a given qubit into superposition.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Hadamard gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]]\n```\n\n> ## QuantumCircuit.`y`(*qubit*)\n\n*Changes the state of a qubit by pi around the y-axis of a Bloch Sphere.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Pauli-Y gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.y(0)\n\nprint(qc.state())\n\n# [[0.+0.j]\n# [0.+0.j]\n# [0.+1.j]\n# [0.+0.j]]\n```\n\n\n> ## QuantumCircuit.`z`(*qubit*)\n\n*Changes the state of a qubit by pi around the z-axis of a Bloch Sphere.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Pauli-Z gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.z(0)\n\nprint(qc.state())\n\n# [[ 0.707+0.j]\n# [ 0.   +0.j]\n# [-0.707+0.j]\n# [ 0.   +0.j]]\n```\n\n> ## QuantumCircuit.`phase`(*qubit*, *theta=numpy.pi/2*)\n\n*Commits to a rotation around the z-axis based off of the inputted theta value.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Phase gate be applied to the quantum wire.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.phase(0)\n\nprint(qc.state())\n\n# [[0.707+0.j   ]\n# [0.   +0.j   ]\n# [0.   +0.707j]\n# [0.   +0.j   ]]\n```\n\n> ## QuantumCircuit.`s`(*qubit*)\n\n*Is a Phase gate where the inputted theta value is given as a constant of theta = pi / 2.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Pauli-Z gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.s(0)\n\nprint(qc.state())\n\n# [[0.707+0.j   ]\n# [0.   +0.j   ]\n# [0.   +0.707j]\n# [0.   +0.j   ]]\n```\n\n> ## QuantumCircuit.`sdg`(*qubit*)\n\n*Is a Phase gate and inverse of the S gate where the inputted theta value is given as a constant of theta = -pi / 2.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Sdg gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.sdg(0)\n\nprint(qc.state())\n\n# [[0.707+0.j   ]\n# [0.   +0.j   ]\n# [0.   -0.707j]\n# [0.   +0.j   ]]\n```\n\n> ## QuantumCircuit.`t`(*qubit*)\n\n*T gate is a special use case gate that in implemented from the P Gate.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the T gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.t(0)\n\nprint(qc.state())\n\n# [[0.707+0.j ]\n# [0.   +0.j ]\n# [0.5  +0.5j]\n# [0.   +0.j ]]\n```\n\n> ## QuantumCircuit.`tdg`(*qubit*)\n\n*Tdg gate is a special use case gate that in implemented from the P Gate and is the inverse of the T gate.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Tdg gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.tdg(0)\n\nprint(qc.state())\n\n# [[0.707+0.j ]\n# [0.   +0.j ]\n# [0.5  -0.5j]\n# [0.   +0.j ]]\n```\n\n> ## QuantumCircuit.`rz`(*qubit*, *theta=numpy.pi/2*)\n\n*RZ gate commits a rotation around the z-axis for a qubit.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Rz gate be applied to the quantum wire.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around z-axis.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.hadamard(0)\n\nqc.rz(0)\n\nprint(qc.state())\n\n# [[0.5-0.5j]\n# [0. +0.j ]\n# [0.5+0.5j]\n# [0. +0.j ]]\n```\n\n> ## QuantumCircuit.`ry`(*qubit*, *theta=numpy.pi/2*)\n\n*RY gate commits a rotation around the y-axis for a qubit.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Ry gate be applied to the quantum wire.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around y-axis.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.ry(0)\n\nprint(qc.state())\n\n# [[0.707+0.j]\n# [0.   +0.j]\n# [0.707+0.j]\n# [0.   +0.j]]\n```\n\n> ## QuantumCircuit.`rx`(*qubit*, *theta=numpy.pi/2*)\n\n*RX gate commits a rotation around the x-axis for a qubit.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Ry gate be applied to the quantum wire.\n\n`theta (float)` default: `numpy.pi/2` -  angle of rotation around x-axis.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.rx(0)\n\nprint(qc.state())\n\n# [[0.707+0.j   ]\n# [0.   +0.j   ]\n# [0.   -0.707j]\n# [0.   +0.j   ]]\n```\n\n> ## QuantumCircuit.`sx`(*qubit*)\n\n*SX gate is the square root of the Inverse gate (X, PauliX Gate).*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the Sx gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.sx(0)\n\nprint(qc.state())\n\n# [[0.5+0.5j]\n# [0. +0.j ]\n# [0.5-0.5j]\n# [0. +0.j ]]\n```\n\n> ## QuantumCircuit.`sxdg`(*qubit*)\n\n*SXDG gate is the negative square root of the Inverse gate (X, PauliX Gate) and inverse of the SX gate.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the SXdg gate be applied to the quantum wire.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.sxdg(0)\n\nprint(qc.state())\n\n# [[0.5-0.5j]\n# [0. +0.j ]\n# [0.5+0.5j]\n# [0. +0.j ]]\n```\n\n> ## QuantumCircuit.`u`(*qubit*, *theta=numpy.pi/2*, *phi=numpy.pi/2*, *lmbda=numpy.pi/2*)\n\n*U gate is given three inputs (theta, phi, and lambda) that allow the inputs to manipulate the base matrix to allow for the position of the enacted qubit around the bloch sphere representation.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the U gate be applied to the quantum wire.\n\n`theta (float)` default: `numpy.pi/2` - angle representation to rotate the qubit's representation.\n\n`phi (float)` default: `numpy.pi/2` -  angle representation to rotate the qubit's representation.\n\n`lmbda (float)` default: `numpy.pi/2` -  angle representation to rotate the qubit's representation.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nqc = QuantumCircuit(2)\n\nqc.u(0)\n\nprint(qc.state())\n\n# [[0.5-0.5j]\n# [0. +0.j ]\n# [0.5+0.5j]\n# [0. +0.j ]]\n```\n\n> ## QuantumCircuit.`custom`(*qubit*, *custom_matrix*)\n\n*Will take in a custom single qubit quantum gate and implement it on a qubit.*\n\n### Parameters:\n\n`qubit (int)` - the qubit to have the U gate be applied to the quantum wire.\n\n`custom_matrix (np.array)` -  matrix to be applied to the quantum circuit.\n\n### Returns:\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\n\nfrom QCpy.QuantumGate import PauliX\n\nqc = QuantumCircuit(2)\n\nqc.custom(0, PauliX().matrix)\n\nprint(qc.state())\n\n# [[0.+0.j]\n# [0.+0.j]\n# [1.+0.j]\n# [0.+0.j]]\n```\n\n# Visualizer\n\n*A collection of classes to visualize the quantum circuit*\n\n> ## *class* QC.Visualizer.QSphere(*circuit*)\n\n*Visualizes the quantum circuit as a q-sphere*\n\n### Parameters:\n\n`circuit` - the quantum circuit\n\n### Attributes:\n\n`None`\n\n> ## QSphere.`makeSphere`(*path=\"qsphere.png\"*, *save=True*, *show=True*, *darkmode=True*)\n\n*Returns a Q-Sphere that plots a global visualization of the quantum states in a 3D global view*\n\n### Parameters:\n\n`path (str)` - name of the image to be saved\n\n`save (bool)` - pass True for the graph to be saved\n\n`show (bool)` - pass True for the sphere to be shown instead of saved\n\n`darkmode (bool)` - pass True for darkmode, false for lightmode\n\n### Returns:\n\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nfrom QCpy.Visualizer import *\n\nqc = QuantumCircuit(3)\n\nqc.hadamard(0)\nqc.hadamard(1)\nqc.hadamard(2)\n\nsphere_ex = QSphere(qc)\nsphere_ex.makeSphere(save=False, show=True)\n```\n> ## *class* QC.Visualizer.StateVector(*circuit*)\n\n*Visualizes the quantum circuit's quantum amplitutes using a bar graph*\n\n### Parameters:\n\n`circuit` - the quantum circuit\n\n### Attributes:\n\n`None`\n\n> ## StateVector.`makeGraph`(*path=\"statevector.png\"*, *save=True*, *show=True*, *darkmode=True*)\n\n*Returns a graph that plots all the amplitudes of the qubits being measured*\n\n### Parameters:\n\n`path (str)` - name of the image to be saved\n\n`save (bool)` - pass True for the graph to be saved\n\n`show (bool)` - pass True for the graph to be shown instead of saved\n\n`darkmode (bool)` - pass True for darkmode and false for lightmode\n\n### Returns:\n\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nfrom QCpy.Visualizer import *\n\nqc = QuantumCircuit(3)\n\nqc.hadamard(0)\nqc.hadamard(1)\nqc.hadamard(2)\n\nstateVector_ex = StateVector(qc)\nstateVector_ex.makeGraph(save=False, show=True)\n```\n\n> ## *class* QC.Visualizer.Probabilities(*circuit*)\n\n*Visualizes the quantum circuit's qubits probability of being measured using a bar graph*\n\n### Parameters:\n\n`circuit` - the quantum circuit\n\n### Attributes:\n\n`None`\n\n> ## Probabilities.`makeGraph`(*path=\"probabilities.png\"*, *save=True*, *show=True*, *darkmode=True*)\n\n*Returns a graph that plots all the probabilities of the qubits being measured*\n\n### Parameters:\n\n`path (str)` - name of the image to be saved\n\n`save (bool)` - pass True for the graph to be saved\n\n`show (bool)` - pass True for the graph to be shown instead of saved\n\n`darkmode (bool)` - pass True for darkmode and false for lightmode\n\n### Returns:\n\n`None`\n\n### Example:\n\n```python\nfrom QCpy import QuantumCircuit\nfrom QCpy.Visualizer import *\n\nqc = QuantumCircuit(3)\n\nqc.hadamard(0)\nqc.hadamard(1)\nqc.hadamard(2)\n\nprobabilities_ex = Probabilities(qc)\nprobabilities_ex.makeGraph(save=False, show=True)\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/QCpython/QCpy",
    "keywords": "quantum computing,physics,visualization,quantum circuit",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "QCpython",
    "package_url": "https://pypi.org/project/QCpython/",
    "platform": null,
    "project_url": "https://pypi.org/project/QCpython/",
    "project_urls": {
      "Homepage": "https://github.com/QCpython/QCpy"
    },
    "release_url": "https://pypi.org/project/QCpython/1.0.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "QCpy is a lightweight quantum circuit simulator and visualization of quantum computing.",
    "version": "1.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16572348,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f349b57eab3564e019f169ea2392bc7358ceccb73b872c7501853e75fa42c72a",
          "md5": "cc27129e5dc0b40f72dad211cf7ac830",
          "sha256": "0113e1b0a74977120d2b28d0c58ab5b1f02d57550ce820f57c05aaa2a1b16068"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "cc27129e5dc0b40f72dad211cf7ac830",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21156,
        "upload_time": "2023-01-26T06:11:34",
        "upload_time_iso_8601": "2023-01-26T06:11:34.228027Z",
        "url": "https://files.pythonhosted.org/packages/f3/49/b57eab3564e019f169ea2392bc7358ceccb73b872c7501853e75fa42c72a/QCpython-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "49956e459b5edb4909536b642af73b20171a63e8da555bf773d72f86d3b44c5e",
          "md5": "d1705260bf1ead742ef0c982220c5d6f",
          "sha256": "cb24ced0de6c4b2ba29ab7231b7a20294ea1fb1ad0ced55eec0a9d3118e2c31f"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d1705260bf1ead742ef0c982220c5d6f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28186,
        "upload_time": "2023-01-08T22:56:34",
        "upload_time_iso_8601": "2023-01-08T22:56:34.922178Z",
        "url": "https://files.pythonhosted.org/packages/49/95/6e459b5edb4909536b642af73b20171a63e8da555bf773d72f86d3b44c5e/QCpython-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4abf422f46a9375f4a254e0fc254a969f5b0a807b489be9c84075107deff8fd7",
          "md5": "0acbb38f7d5c8c5d1368ec00e20eee84",
          "sha256": "304075a62856934d04ec0d9ff7e3d5c3fa0002405ec0b34ed8c2c282e724a061"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0acbb38f7d5c8c5d1368ec00e20eee84",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21154,
        "upload_time": "2023-01-26T06:18:40",
        "upload_time_iso_8601": "2023-01-26T06:18:40.611498Z",
        "url": "https://files.pythonhosted.org/packages/4a/bf/422f46a9375f4a254e0fc254a969f5b0a807b489be9c84075107deff8fd7/QCpython-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5d7c9e7e01f2713045993204358331d59bfe1ffbb7ce7bbf8d1129fcabd8a98b",
          "md5": "61e9ccbb3ea688b352042e6a2e1fc100",
          "sha256": "eb23dba41b20be781bf434f3831c761c7771e99947c6d808cd3d770737084363"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "61e9ccbb3ea688b352042e6a2e1fc100",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 30879,
        "upload_time": "2023-01-26T06:18:43",
        "upload_time_iso_8601": "2023-01-26T06:18:43.075319Z",
        "url": "https://files.pythonhosted.org/packages/5d/7c/9e7e01f2713045993204358331d59bfe1ffbb7ce7bbf8d1129fcabd8a98b/QCpython-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b3e6a79a11bc6eb47a877c451c006ce4527bebb69f1f0c47cfd1479a711795c0",
          "md5": "5684d6cd718096cf6ee1a909d9205db3",
          "sha256": "a8d7567e7f3bbeb51134dfd2148aff1184f8b904da51e7b7ff5dfc7cf298a806"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5684d6cd718096cf6ee1a909d9205db3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21146,
        "upload_time": "2023-01-26T06:23:44",
        "upload_time_iso_8601": "2023-01-26T06:23:44.763844Z",
        "url": "https://files.pythonhosted.org/packages/b3/e6/a79a11bc6eb47a877c451c006ce4527bebb69f1f0c47cfd1479a711795c0/QCpython-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e6a2a56533c130609926b0fa6cdd09e9c6113da6ef3a1d20aaa76b8e474b0411",
          "md5": "4b182ff4d58ef3ad306135005877f50f",
          "sha256": "4da69036855a45cf80167c8f41d813a0051f5512b7a7a51b954d3bf85bcaec85"
        },
        "downloads": -1,
        "filename": "QCpython-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "4b182ff4d58ef3ad306135005877f50f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 30749,
        "upload_time": "2023-01-26T06:23:47",
        "upload_time_iso_8601": "2023-01-26T06:23:47.488645Z",
        "url": "https://files.pythonhosted.org/packages/e6/a2/a56533c130609926b0fa6cdd09e9c6113da6ef3a1d20aaa76b8e474b0411/QCpython-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b3e6a79a11bc6eb47a877c451c006ce4527bebb69f1f0c47cfd1479a711795c0",
        "md5": "5684d6cd718096cf6ee1a909d9205db3",
        "sha256": "a8d7567e7f3bbeb51134dfd2148aff1184f8b904da51e7b7ff5dfc7cf298a806"
      },
      "downloads": -1,
      "filename": "QCpython-1.0.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "5684d6cd718096cf6ee1a909d9205db3",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 21146,
      "upload_time": "2023-01-26T06:23:44",
      "upload_time_iso_8601": "2023-01-26T06:23:44.763844Z",
      "url": "https://files.pythonhosted.org/packages/b3/e6/a79a11bc6eb47a877c451c006ce4527bebb69f1f0c47cfd1479a711795c0/QCpython-1.0.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e6a2a56533c130609926b0fa6cdd09e9c6113da6ef3a1d20aaa76b8e474b0411",
        "md5": "4b182ff4d58ef3ad306135005877f50f",
        "sha256": "4da69036855a45cf80167c8f41d813a0051f5512b7a7a51b954d3bf85bcaec85"
      },
      "downloads": -1,
      "filename": "QCpython-1.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "4b182ff4d58ef3ad306135005877f50f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 30749,
      "upload_time": "2023-01-26T06:23:47",
      "upload_time_iso_8601": "2023-01-26T06:23:47.488645Z",
      "url": "https://files.pythonhosted.org/packages/e6/a2/a56533c130609926b0fa6cdd09e9c6113da6ef3a1d20aaa76b8e474b0411/QCpython-1.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}