{
  "info": {
    "author": "Shoval Fridman",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# OGRE - Online Two-Stages Embedding Method For Large Graphs\n## Overview\nOGRE and its variants are fast online two-stages graph embedding algorithms for large graphs. The accuracy of existing embedding, as defined by auxiliary tests, is maximal for a core of high degree vertices. We propose to embed only this core using existing methods (such as node2vec, HOPE, GF, GCN), and then update online the remaining vertices, based on the position of their already embedded neighbors. The position of each new vertex is a combination of its first and second neighborsâ€™ positions. We present three versions of this heuristic:\n\n1. OGRE - a weighted combination approach which assumes an undirected graph, or the undirected graph underlying a directed graph. The position of a new vertex that is inserted to the embedding is calculated by the average embedding of its first and second order neighbours, with epsilon as a hyperparamter representing the importance of the second order neighbours.\n2. DOGRE - a directed regression which assumes a directed graph. The position of a new vertex that is inserted to the embedding is calculated by the average embedding of its first and second order neighbours, where now they have directions - in, out, in-in, in-out, out-in, out-out, and the importance of each of them is determined by the regression weights.\n3. WOGRE - a directed weighted regression, very similar to DOGRE. The difference is by the calculation of the parameters, where here we use a little different combination, therefore different regression results. \n\n## Dependencies:\n\n- python >=3.6.8\n- numpy >= 1.18.0\n- scikit-learn >= 0.22.1\n- heapq \n- node2vec==0.3.2\n- networkx==1.11\n- scipy >= 1.41\n- pytorch==1.7.0\n- matplotlib==3.1.3\n- pandas >= 1.0.5\n\n## Notes:\n`datasets` directory consists of several small datasets. You can find the larger ones in [This Google Drive link](https://drive.google.com/drive/folders/1zycmmDES39zVlbVCYs88JTJ1Wm5FbfLz), taken from [GraphSaint public github repository](https://github.com/GraphSAINT/GraphSAINT) and from [NRL Benchmark public github repository](https://github.com/PriyeshV/NRL_Benchmark)\n(go to `link prediction` or `node classification` directories, there you will find links to datasets in .mat format). Once you have your datasets, place them in the `datasets` direcotiry.\n\nNotice you will have to adjust them to our files format (will be further explained) or provide a data loader function in order to produce the networkx graph. For .mat files, see how Youtube and Flickr datasets are loaded. You can add the appropriate condition to the function \"load_data\" in `evaluation_tasks` -> `eval_utils.py`. Note that when having .mat file, it has both the edges and labels. To see an example for a use go to \"load_data\" in `evaluation_tasks` -> `eval_utils.py` and to `evaluation_tasks` -> `calculate_static_embeddings.py`.\n\n### What files should you have in order to embed your graph?\n- In order to calculate the embedding, you first must have an edge list file:\nIf the graph is unweighted it consists of 2 columns: source, target (with no title, source and target share an edge).<br>\nExample for unweighted graph: <br>\n1 2 <br>\n2 3 <br>\n1 4 <br>\n1 3 <br>\nIf the graph is weighted, it consists of 3 columns: source target weight.<br> \nExample for weighted graph: <br>\n1 2 3 <br>\n1 3 0.3 <br>\n1 4 4.5 <br>\n2 4 0.98 <br>\nYou can see examples for this format in `datasets` directory.\n\nNote that in the end one must have a networkx graph, so you can change the data loader function as you want (adjusting to your file format), but remember a networkx graph is required in the end.\n\nAnother format is `.mat`, as explained above. For example you can see `datasets\\Flickr.mat` and see how it is loaded in `evaluation_tasks`->`eval_utils.py`->`load_data`.\n- If you want to perform vertex classification task or GCN initial embedding is used, you must provide labels file: <br>\nA txt file which consists of 2 columns: node, label (no title). Notice all nodes must have labels! <br>\nExample: <br>\n1 0 <br>\n2 0 <br>\n3 1 <br>\n4 2 <br>\nYou can see examples for this format in `labels` directory.\n\nIf your file is in `.mat` format, you do not need labels file (because it already has labels).\n- If you want to perform link prediction task, you must provide non edges file: <br>\nA csv file which consists of two columns: node1, node2 ; where there is no edge between them (again no title). <br>\nIn order to produce such file, you can use `calculate_non_edges()` function, using `from OGRE import calculate_non_edges`.\nIf such file does not exist, it will be created automaticly by running the function `link prediction()` on your `CalculateStaticEmbeddings` object.\n\n## How to run?\n\n1. First install the packages using pip.\n\n```commandline\npip install OGRE-embed\n```\n\n2. Import OGRE and create a `CalculateStaticEmbeddings` object.\n```python\nfrom OGRE import CalculateStaticEmbeddings\n# CalculateStaticEmbeddings is the main class of the package.\n# Use it to embed your graph. Then you can perform link prediction or vertex classification tasks.\n\n# create an instance of the class\nembedding = CalculateStaticEmbeddings(name=\"example_dataset\", dataset_path=\".\", \n                                      initial_size=[100, 1000], dim=128, is_weighted=False,\n                                      choose=\"degree\", s_a=True, epsilon=0.1,\n                                      regu_val=0.1, weighted_reg=False)\n```\n\n#### CalculateStaticEmbeddings Parameters:\n- **name**: Name of dataset (as the name of the edge list txt file) (string)\n- **dataset_path**: Path to the dataset (string)\n- **initial_size**: List of initial core sizes. (list of int)\n- **dim**: Embedding dimension (int). Default is 128.\n- **is_weighted**: True if the graph is weighted, else False (bool). Default is False.\n- **choose**: \"degrees\" if the vertices of the initial core are the ones with the highest degree\n(as done in our experiments), else \"k_core\" if the vertices of the initial core are\nthe ones with highest k-core score (string). Default is \"degrees\".\n- **s_a**: True if you also want to calculate state-of-the-art embeddings (node2vec/GF/HOPE/GCN), \nelse False. Default is True.\n\nParams for OGRE:\n- **epsilon**: Weight to the second order neighbours embedding. Default is 0.1.<br>\nFor more details you can go to the implementation - `our_embedding_methods -> OGRE.py` (float).\n\nParams for DOGRE/WOGRE:\n- **regu_val**: Regularization value for regression, only for DOGRE/WOGRE. Default is 0.<br>\nFor more details you can go to the implementation- `our_embedding_methods -> D_W_OGRE.py` (float).\n- **weighted_reg**: True for weighted regression, else False. Default is False.\n\n3. Calculate the embedding.\n```python\nembedding.calculate_static_embeddings(method=[\"OGRE\"], initial_methods=[\"node2vec\"])\n```\n#### Output:\nFirst, If the directories `embeddings_degrees`/`embedding_k_core` do not exist,\nthey will be created depends on the input of `choose`(parameter of CalculateStaticEmbeddings).\nIf the directory `embeddings_state_of_the_art` does not exist, it will be created as well.<br>\n\nOur embeddings will be saved in the directory `embeddings_degrees`/`embedding_k_core` under the name:<br> \n`{name_of_dataset} + {state_of_the_art} + {our_embedding} + {initial_core_size} + {epsilon}.npy`<br> \nand state-of-the-art embeddings are saved in the directory `embeddings_state_of_the_art` under the name:<br>\n`{name_of_dataset} + {state_of_the_art}.npy`<br>\n\n#### calculate_static_embeddings Parameters:\n - methods: List of our suggested embedding methods (OGRE/DOGRE/WOGRE) with whom you want to embed the given graph. Default is `[\"OGRE\"]`.\n - initial_methods : List of state-of-the-art embedding methods (node2vec/GF/HOPE/GCN) with whom the initial core will be embed. Default is `[\"node2vec\"]`.\n\n4. Evaluate run time.\n\nEvaluate running times of each method according to the initial core size\nIf one wishes to evaluate the run time, one can use the function `run_time()` on the `CalculateStaticEmbeddings` object.<br>\nThe function will create a csv file with the run time and save it in the directory `files_degrees`/`files_k_core`<br>\n(depends on `choose` parameter value) under the name:<br>\n`{name_of_dataset} times_1.csv`<br>\nIf `plot=True` a plot of the run time will be saved in the directory `plots` (directory is created if it does not exist) under the name:<br>\n`{dataset_name} {initial_method} running time vs initial.png`<br>\n\n```python\nembedding.run_time(plot=True)\n```\n\n**NOTE**: If you want to evaluate the run time, you must run the function `calculate_static_embeddings()` first.\n\n5. Perform link prediction task.\n\nIf one wishes to perform link prediction task, one can use the function `link_prediction()` on the `CalculateStaticEmbeddings` object.<br>\nThe function will create a csv file with the link prediction and save it in the directory `files_degrees`/`files_k_core`<br>\n(depends on `choose` parameter value) under the name:<br>\n`{name_of_dataset} Link Prediction.csv`<br>\nPlots of the link prediction will be saved in the directory `plots` (directory is created if it does not exist) under the name:<br>\n`{dataset_name} Link Prediction {...}.png`<br>\n\n```python\nembedding.link_prediction(plot=True)\n```\n\n##### link_prediction Parameters:\n- **number_true_false**:\n- **rounds**:\n- **test_ratio**:\n- **number_choose**:\n- **path_non_edges**: Path to the non edges file without the file name itself. Default is `\".\"`.\n- **non_edges_percentage**: Percentage of non edges to take.<br>\n(non-edge might be too big for all nodes, choose the biggest portion your device\n    can handle with). Default is 1.\n- **plot**: True if you want to plot the link prediction, else False. Default is False.\n\n**NOTE**: If you want to calculate link prediction, you must run the function `calculate_static_embeddings()` first.\n\n6. Perform node classification tasks.\n\nIf one wishes to perform node classification task, one can use the function `node_classification()` on the `CalculateStaticEmbeddings` object.<br>\nThe function will create a csv file with the node classification and save it in the directory `files_degrees`/`files_k_core`\n(depends on `choose` parameter value) \n\n[//]: # (under the name:<br>)\n\n[//]: # (`{name_of_dataset} Link Prediction.csv`<br>)\nPlots of the link prediction will be saved in the directory `plots` (directory is created if it does not exist) \n\n[//]: # (under the name:<br>)\n\n[//]: # (`{dataset_name} Link Prediction {...}.png`<br>)\n\n```python\nembedding.node_classification(plot=True)\n```\n\n##### node_classification Parameters:\n- **label_files**:\n- **multi_label**: True if you want to perform a multi-label node classification task, else False. Default is False.\n- **rounds**:\n- **test_ratio**:\n- **plot**: True if you want to plot the link prediction, else False. Default is False.\n\n**NOTE**: If you want to calculate node classification, you must run the function `calculate_static_embeddings()` first.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/AmitKabya/OGRE",
    "keywords": "graphs networks graph-embeddings",
    "license": "MIT",
    "maintainer": "Amit Kabya",
    "maintainer_email": "kabya.amit@gmail.com",
    "name": "OGRE-embed",
    "package_url": "https://pypi.org/project/OGRE-embed/",
    "platform": null,
    "project_url": "https://pypi.org/project/OGRE-embed/",
    "project_urls": {
      "Homepage": "https://github.com/AmitKabya/OGRE"
    },
    "release_url": "https://pypi.org/project/OGRE-embed/0.0.3/",
    "requires_dist": [
      "setuptools (>=61.3.1)"
    ],
    "requires_python": ">=3.6.8",
    "summary": "Online Two-Stages Embedding Method For Large Graphs",
    "version": "0.0.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14071243,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "32a38871d2fd6b4585e3625cb54a527ef5d1de53190a2022b81e182bf5ca2a53",
          "md5": "0fb1a3c3704007c073d8da4930d08ec7",
          "sha256": "5f2415dbd9970697337308cd37e7be38aa15b621c41bbc5f4581784a376f9b79"
        },
        "downloads": -1,
        "filename": "OGRE_embed-0.0.1-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0fb1a3c3704007c073d8da4930d08ec7",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": ">=3.6.8",
        "size": 52467022,
        "upload_time": "2022-06-06T07:31:08",
        "upload_time_iso_8601": "2022-06-06T07:31:08.282764Z",
        "url": "https://files.pythonhosted.org/packages/32/a3/8871d2fd6b4585e3625cb54a527ef5d1de53190a2022b81e182bf5ca2a53/OGRE_embed-0.0.1-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "72d46aa289a15c08ee2a396d48acb415d4684d6965f175d9c7ceca2398fd2a53",
          "md5": "d3fc3f2a9dd33653c2e3b8ec9e171c0a",
          "sha256": "3bd4e8c59b4eb756a9f2bb0263a0e4111bf81897bc453f1a2f19dc6a29d06dc3"
        },
        "downloads": -1,
        "filename": "OGRE-embed-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d3fc3f2a9dd33653c2e3b8ec9e171c0a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.8",
        "size": 52469022,
        "upload_time": "2022-06-06T07:31:14",
        "upload_time_iso_8601": "2022-06-06T07:31:14.326798Z",
        "url": "https://files.pythonhosted.org/packages/72/d4/6aa289a15c08ee2a396d48acb415d4684d6965f175d9c7ceca2398fd2a53/OGRE-embed-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "344d537a4833a9a303a888c8e36d803dbb19cd1d53ffcf2b2130a4724decbda8",
          "md5": "80d922548cd45b4205a87ffb65c1e451",
          "sha256": "259c600fcf8933c9a781d53702e5bf808af909ff0d1a7c083cd6a644a75e89fe"
        },
        "downloads": -1,
        "filename": "OGRE_embed-0.0.2-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "80d922548cd45b4205a87ffb65c1e451",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": ">=3.6.8",
        "size": 52467044,
        "upload_time": "2022-06-08T15:31:22",
        "upload_time_iso_8601": "2022-06-08T15:31:22.094720Z",
        "url": "https://files.pythonhosted.org/packages/34/4d/537a4833a9a303a888c8e36d803dbb19cd1d53ffcf2b2130a4724decbda8/OGRE_embed-0.0.2-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3723d792ae048011f65ea7cccba9e68e7cb554350547320dd592f8123319b039",
          "md5": "3adfb556ee0098c4668c473c2bd85978",
          "sha256": "ef22ad9099c61208671165e0f00ef44555c9e40a481c1d67fc8958f967e8c6b1"
        },
        "downloads": -1,
        "filename": "OGRE-embed-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "3adfb556ee0098c4668c473c2bd85978",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.8",
        "size": 52469428,
        "upload_time": "2022-06-08T15:31:30",
        "upload_time_iso_8601": "2022-06-08T15:31:30.436636Z",
        "url": "https://files.pythonhosted.org/packages/37/23/d792ae048011f65ea7cccba9e68e7cb554350547320dd592f8123319b039/OGRE-embed-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eb2386540144dbd378844e63d46fb460f9ab9f04eeb26f68a95d3006a9f02dbd",
          "md5": "cd3e5802bfc2739545a6c4348a520f5f",
          "sha256": "bdd41904d09d366d0ec9038119a262aa9ec696b6609288455e12961190eaaa83"
        },
        "downloads": -1,
        "filename": "OGRE_embed-0.0.3-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "cd3e5802bfc2739545a6c4348a520f5f",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": ">=3.6.8",
        "size": 52467027,
        "upload_time": "2022-06-08T15:42:15",
        "upload_time_iso_8601": "2022-06-08T15:42:15.134224Z",
        "url": "https://files.pythonhosted.org/packages/eb/23/86540144dbd378844e63d46fb460f9ab9f04eeb26f68a95d3006a9f02dbd/OGRE_embed-0.0.3-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "65103de1386042dea8d63fc6a0c3e51d1964f1744f6c4e7497e0f8a9ca758116",
          "md5": "5783523b9d2e2d682946be215966e371",
          "sha256": "36bf53d5b51caad389d08a5007a109f72074a1e0a6900b9ba4296eeeb1e5fadc"
        },
        "downloads": -1,
        "filename": "OGRE-embed-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "5783523b9d2e2d682946be215966e371",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.8",
        "size": 52469377,
        "upload_time": "2022-06-08T15:42:21",
        "upload_time_iso_8601": "2022-06-08T15:42:21.483514Z",
        "url": "https://files.pythonhosted.org/packages/65/10/3de1386042dea8d63fc6a0c3e51d1964f1744f6c4e7497e0f8a9ca758116/OGRE-embed-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "eb2386540144dbd378844e63d46fb460f9ab9f04eeb26f68a95d3006a9f02dbd",
        "md5": "cd3e5802bfc2739545a6c4348a520f5f",
        "sha256": "bdd41904d09d366d0ec9038119a262aa9ec696b6609288455e12961190eaaa83"
      },
      "downloads": -1,
      "filename": "OGRE_embed-0.0.3-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "cd3e5802bfc2739545a6c4348a520f5f",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": ">=3.6.8",
      "size": 52467027,
      "upload_time": "2022-06-08T15:42:15",
      "upload_time_iso_8601": "2022-06-08T15:42:15.134224Z",
      "url": "https://files.pythonhosted.org/packages/eb/23/86540144dbd378844e63d46fb460f9ab9f04eeb26f68a95d3006a9f02dbd/OGRE_embed-0.0.3-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "65103de1386042dea8d63fc6a0c3e51d1964f1744f6c4e7497e0f8a9ca758116",
        "md5": "5783523b9d2e2d682946be215966e371",
        "sha256": "36bf53d5b51caad389d08a5007a109f72074a1e0a6900b9ba4296eeeb1e5fadc"
      },
      "downloads": -1,
      "filename": "OGRE-embed-0.0.3.tar.gz",
      "has_sig": false,
      "md5_digest": "5783523b9d2e2d682946be215966e371",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6.8",
      "size": 52469377,
      "upload_time": "2022-06-08T15:42:21",
      "upload_time_iso_8601": "2022-06-08T15:42:21.483514Z",
      "url": "https://files.pythonhosted.org/packages/65/10/3de1386042dea8d63fc6a0c3e51d1964f1744f6c4e7497e0f8a9ca758116/OGRE-embed-0.0.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}