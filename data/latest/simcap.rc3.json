{
  "info": {
    "author": "Jeremy Doyle",
    "author_email": "hello@jeremy-doyle.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Financial and Insurance Industry",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Office/Business :: Financial",
      "Topic :: Office/Business :: Financial :: Investment",
      "Topic :: Scientific/Engineering :: Information Analysis"
    ],
    "description": "<p align=\"center\" style=\"border: 1px solid black;\">\r\n  <img src=\"img/SimCAP.png\" alt=\"SimCAP\" style=\"width: 150px;\">\r\n</p>\r\n\r\n# SimCAP: Simulation of Correlated Asset Prices\r\n<img src=\"img/intro.png\" alt=\"SimCAP\" style=\"max-width: 100%;\">\r\n\r\nSimCAP was created with the intent to make it simple to generate useful simulations of correlated multivariate financial time series. SimCAP is written in Python3 and leans heavily on the excellent <a href=\"https://hmmlearn.readthedocs.io/en/latest/\" target=\"_blank\">hmmlearn</a> package to train the Hidden Markov Models at the core of SimCAP simulations. \r\n\r\nWith SimCAP, just provide a pandas DataFrame of historical stock prices (or any other financial instrument) and you can easily generate thousands of simulations in minutes. Simulations resemble the original time series in both the correlations between assets and the statistical properties of the returns distributions.\r\n\r\nPossible uses for SimCAP could be trading strategy development, portfolio optimization, portfolio risk management, financial planning, augementation of data sets for machine learning, etc.\r\n<br><br>\r\n\r\n## Contents\r\n- [Installation](#installation)  \r\n- [Quick Start](#quick-start)  \r\n  - [Importing SimCAP and Example Data](#importing)  \r\n  - [Generating Simulations](#generating-simulations)  \r\n  - [Comparing Observation to Simulations](#comparison)\r\n  - [Additional Examples](#additional-examples)\r\n- [Stylized Facts of Financial Time Series](#stylized-facts)\r\n  - [Returns do not follow a normal distribution and are leptokurtic.](#not-normal)  \r\n  - [The autocorrelation of returns is insignificant.](#no-autocorrelation)  \r\n  - [Returns are subject to volatility clustering.](#volatility-clustering)  \r\n  - [Returns are negatively correlated with volatility.](#returns-volatility-correlation)\r\n- [API](#api)  \r\n- [About the Developer](#about-the-developer)\r\n\r\n# Installation <a name=\"installation\"></a>\r\nSimCAP requires:\r\n- Python >= 3.7\r\n- NumPy >= 1.17\r\n- SciPy >= 1.3\r\n- scikit-learn >= 0.18\r\n- statsmodels >= 0.13\r\n- hmmlearn >= 0.2.7\r\n- pandas >= 1.0\r\n\r\nYou can install SimCAP directly with pip:  \r\n```python \r\npip install simcap\r\n```\r\nAlternatively, you can install SimCAP directly from source:  \r\n```python\r\npip install git+https://github.com/jeremy-doyle/SimCAP.git\r\n```\r\n\r\n# Quick Start <a name=\"quick-start\"></a>\r\nDaily closing prices (adjusted for dividends and splits) for the following Exchange Traded Funds (ETFs) over a 10-year period are included with the package:\r\n<br><br>\r\n\r\nTicker | Description\r\n-------|------------\r\nSPY|SPDR S&P 500 ETF Trust\r\nVO|Vanguard Mid-Cap Index Fund ETF\r\nIWM|iShares Russell 2000 ETF\r\nEFA|iShares MSCI EAFE ETF\r\nVWO|Vanguard Emerging Markets Stock Index Fund ETF\r\nAGG|iShares Core US Aggregate Bond ETF\r\nIBND|SPDR Bloomberg International Corporate Bond ETF\r\nVNQ|Vanguard Real Estate Index Fund ETF\r\n\r\n<br> \r\n\r\n## Importing SimCAP and Example Data <a name=\"importing\"></a>\r\n\r\n```python\r\n>>> from simcap import SimCAP\r\n>>> from simcap.datasets import load_example_asset_price_history\r\n\r\n>>> obs = load_example_asset_price_history()\r\n\r\n>>> obs.head().round(2)\r\n      SPY     VO    IWM    EFA    VWO    AGG   IBND    VNQ\r\n0  106.80  64.47  66.44  37.22  30.88  86.69  29.32  39.60\r\n1  107.98  65.52  67.62  37.85  31.64  86.58  29.56  39.88\r\n2  108.55  66.00  68.04  38.31  31.94  86.44  29.68  40.04\r\n3  108.95  65.80  68.08  38.51  31.97  86.22  29.68  40.28\r\n4  108.67  65.91  68.00  38.66  32.14  86.15  29.95  40.48\r\n```\r\n\r\n\r\n## Generating Simulations <a name=\"generating-simulations\"></a>\r\n\r\n1. Initialize a `SimCAP`instance with the observed data\r\n2. Call the `generate_simulations` method\r\n\r\nFor this example, parameters were chosen to:\r\n\r\n* generate five simulations\r\n* set the beginning values of each asset in each simulation to 1 (`begin_values=\"norm\"`)\r\n* output the simulations as a list of pandas dataframes\r\n* speed things up by setting the number of parallel jobs to 3\r\n\r\n```python\r\n>>> model = SimCAP(obs)\r\n>>> sims = model.generate_simulations(\r\n>>>     n_sims=5, \r\n>>>     begin_values=\"norm\",\r\n>>>     output_as_dfs=True,\r\n>>>     n_jobs=3,\r\n>>> )\r\nmarkov model search (n_jobs=3): 100%|██████████| 60/60 [01:27<00:00,  1.45s/it]\r\ngenerating sims (n_jobs=3): 100%|██████████| 5/5 [00:00<00:00, 2465.79it/s]\r\n\r\n>>> sims[0].head().round(4)\r\n      SPY      VO     IWM     EFA     VWO     AGG    IBND     VNQ\r\n0  1.0000  1.0000  1.0000  1.0000  1.0000  1.0000  1.0000  1.0000\r\n1  1.0107  1.0123  1.0194  1.0124  1.0192  1.0002  0.9966  1.0159\r\n2  1.0138  1.0203  1.0254  1.0160  1.0379  0.9961  0.9931  1.0049\r\n3  1.0049  1.0080  1.0082  1.0029  1.0260  0.9958  0.9879  0.9918\r\n4  1.0061  1.0106  1.0091  1.0002  1.0166  0.9966  0.9921  0.9933\r\n```\r\n\r\n## Comparing Observation to Simulations <a name=\"comparison\"></a>\r\n```python\r\n>>> import matplotlib.pyplot as plt\r\n>>> import seaborn as sns\r\n\r\n>>> sns.set_theme(style=\"whitegrid\", palette=\"bright\")\r\n\r\n>>> fig, axes = plt.subplots(\r\n>>>     ncols=2, \r\n>>>     nrows=3, \r\n>>>     sharex=True,\r\n>>>     sharey=True, \r\n>>>     figsize=(8, 12),\r\n>>> )\r\n\r\n>>> norm_obs = obs / obs.iloc[0, :]\r\n>>> sns.lineplot(data=norm_obs, dashes=False, ax=axes[0][0])\r\n>>> axes[0][0].set_title(\"Normalized Observation\", fontsize=14)\r\n\r\n>>> for i, ax in enumerate(axes.reshape(-1)[1:]):\r\n>>>     sns.lineplot(data=sims[i], dashes=False, ax=ax, legend=False)\r\n>>>     ax.set_title(f\"Simulation {i+1}\", fontsize=14)\r\n    \r\n>>> plt.tight_layout()\r\n>>> plt.show();\r\n```\r\n<img src=\"img/quick-start-sims.png\" alt=\"Plot of five SimCAP simulations against the normalized observation\" style=\"max-width: 100%;\">\r\n\r\n```python\r\n>>> import numpy as np\r\n\r\n>>> sim = sims[0]\r\n\r\n>>> obs_log_return = norm_obs.pct_change().dropna().apply(np.log1p)\r\n>>> sim_log_return = sim.pct_change().dropna().apply(np.log1p)\r\n\r\n>>> obs_corr = obs_log_return.corr()\r\n>>> sim_corr = sim_log_return.corr()\r\n\r\n>>> corr_ax_labels = [[\"obs\"],[ \"sim\"]]\r\n>>> fig, axes = plt.subplot_mosaic(corr_ax_labels, figsize=(8, 6))\r\n>>> sns.heatmap(obs_corr, annot=True, ax=axes[\"obs\"], cbar=False)\r\n>>> sns.heatmap(sim_corr, annot=True, ax=axes[\"sim\"], cbar=False)\r\n>>> axes[\"obs\"].set_title(\"Observation\", fontsize=14)\r\n>>> axes[\"sim\"].set_title(\"Simulation 1\", fontsize=14)\r\n>>> plt.tight_layout(rect=[0, 0, 1, 0.95])\r\n>>> fig.suptitle(\"Correlation Coefficients of 1-Day Returns\", fontsize=16)\r\n>>> plt.show();\r\n```\r\n<img src=\"img/stylized-facts-correlation.png\" alt=\"Inter-asset correlation coefficients for both the SimCAP simulation and the observed asset returns.\" style=\"max-width: 100%;\">\r\n\r\n## Additional Examples <a name=\"additional-examples\"></a>\r\n\r\nFor additional examples, please see the Jupyter notebooks located in the [examples](examples/) directory of this repository.\r\n<br><br>\r\n\r\n# Stylized Facts of Financial Time Series <a name=\"stylized-facts\"></a>\r\n\r\nThe mechanisms by which financial time series are generated are not fully understood. There are some statistical properties, however, that are common to financial time series. These properties are called **stylized facts**.\r\n\r\nStylized facts are observations that have been made in so many studies on the statistical properties of financial markets that they are widely understood to be empirical truths, to which theories and models must fit. \r\n\r\nWe'll walk through some of the most commonly documented stylized facts and see how a SimCAP simulation conforms.\r\n\r\n## Returns do not follow a normal distribution and are leptokurtic. <a name=\"not-normal\"></a>\r\n\r\nAsset returns are not normally distributed and are leptokurtic (fat tails). The degree of leptokurtosis tends to increase as the frequency of price measurement increases. In other words, there is more leptokurtosis in the distribution of 5 minute returns than there is in the distribution of weekly returns.\r\n\r\nThere is no consensus for the right distribution to model financial time series, though the following distributions are commonly used in practice:\r\n\r\n* Normal\r\n* Laplace\r\n* Student's T \r\n* Cauchy\r\n* Lévy\r\n\r\nNone of these distributions, however, are great representations for every asset being modeled so SimCAP simulations aren't modeled on theortical distributions *at all*; rather, they are modeled using kernel density estimates for each of the modeled instruments' empirical distributions. Therefore, simulated distributions of returns closely resemble distributions seen in the \"wild\".\r\n\r\n```python\r\n>>> import pandas as pd\r\n\r\n>>> cols = sim.columns\r\n\r\n>>> ax_labels = np.reshape(cols, (4, 2)).tolist()\r\n>>> fig, axes = plt.subplot_mosaic(ax_labels, figsize=(8, 12))\r\n\r\n>>> for col in cols:\r\n>>>     data = pd.DataFrame({\"obs\": obs_log_return[col], \"sim\": sim_log_return[col]})\r\n>>>     sns.kdeplot(data=data+1e-8, ax=axes[col], fill=True, alpha=0.25, log_scale=True)\r\n>>>     axes[col].set_title(col, fontsize=12)\r\n>>>     axes[col].set(xticklabels=[])\r\n>>>     sns.move_legend(axes[col], \"upper left\")\r\n\r\n>>> plt.tight_layout(rect=[0, 0, 1, 0.95])\r\n>>> fig.suptitle(\"Distribution of 1-Day Returns (x-axis log scale)\", fontsize=16)\r\n>>> plt.show();\r\n```\r\n\r\n<img src=\"img/stylized-facts-distributions.png\" alt=\"Plot of SimCAP simulated returns distributions against observed returns distributions.\" style=\"max-width: 100%;\">\r\n\r\n## The autocorrelation of returns is insignificant. <a name=\"no-autocorrelation\"></a>\r\n\r\nThe autocorrelation (also known as serial correlation) of log returns in financial time series is insignificant. Considering the efficient markets hypothesis &mdash; the theory that asset prices reflect all information currently available thereby making future returns unpredictable &mdash; this lack of autocorrelation is not surprising.\r\n\r\nAutocorrelation of returns is not present in SimCAP simulations. \r\n\r\n```python \r\n>>> from statsmodels.graphics.tsaplots import plot_acf\r\n\r\n>>> def acf_of_returns(squared=False):\r\n>>>     fig, axes = plt.subplot_mosaic(ax_labels, figsize=(8, 12))\r\n\r\n>>>     power = 2 if squared else 1\r\n\r\n>>>     for col in cols:\r\n>>>         data = pd.DataFrame({\"obs\": obs_log_return[col], \"sim\": sim_log_return[col]})\r\n>>>         plot_acf(x=data[\"obs\"] ** power, ax=axes[col], lags=50, zero=False, label=\"obs\")\r\n>>>         plot_acf(x=data[\"sim\"] ** power, ax=axes[col], lags=50, zero=False, label=\"sim\")\r\n>>>         axes[col].set_title(col, fontsize=12)\r\n>>>         axes[col].set_xlabel(\"Days Lag\")\r\n\r\n>>>         handles, labels= axes[col].get_legend_handles_labels()\r\n>>>         handles = [handles[1], handles[3]]\r\n>>>         labels = [labels[1], labels[3]]\r\n>>>         axes[col].legend(handles=handles, labels=labels, loc=\"best\", numpoints=1)\r\n\r\n>>>     plt.tight_layout(rect=[0, 0, 1, 0.95])\r\n\r\n>>>     title_mod = \"squared \" if squared else \"\"\r\n>>>     fig.suptitle(f\"Autocorrelation of {title_mod.title()}Returns\", fontsize=16)\r\n>>>     plt.savefig(f\"../img/stylized-facts-autocorrelation{title_mod.strip()}.png\")\r\n  \r\n>>> acf_of_returns()\r\n```\r\n\r\n<img src=\"img/stylized-facts-autocorrelation.png\" alt=\"Plot of SimCAP simulated returns autocorrelations against observed returns autocorrelations.\" style=\"max-width: 100%;\">\r\n\r\n\r\n## Returns are subject to volatility clustering. <a name=\"volatility-clustering\"></a>\r\n\r\nIn contrast to the lack of serial dependence in returns, the autocorrelation of *squared* returns is always positive, significant, and decays slowly. This is explained by the phenomenon known as **volatility clustering**. \r\n\r\nThe volatility of returns changes over time but its magnitude &mdash; measured by squared returns &mdash; tends to persist or \"cluster\". In other words, there are periods where volatility is low &mdash; and stays low &mdash; while there are other periods where volatility is high &mdash; and stays high. \r\n\r\nVolatility clustering is difficult to model. SimCAP simulations can exhibit volatility clustering though usually not to the degree observed in the market.\r\n\r\n```python\r\n>>> acf_of_returns(squared=True)\r\n```\r\n\r\n<img src=\"img/stylized-facts-autocorrelationsquared.png\" alt=\"Plot of SimCAP autocorrelation of simulated squared returns against observed autocorrelation of squared returns.\" style=\"max-width: 100%;\">\r\n\r\n## Returns are negatively correlated with volatility. <a name=\"returns-volatility-correlation\"></a>\r\n\r\nMost measures of volatility of an asset are negatively correlated with the returns of that asset. Therefore, falling asset prices are typically accompanied by increased volatility and vice versa. \r\n\r\nHere, like we did when examining the phenomenon of volatility clustering, we are measuring volatility by squaring returns. We can see that returns and volatility are negatively correlated in the SimCAP simulation at a similar degree to what we observed in the market.\r\n\r\n```python\r\n>>> from sklearn.preprocessing import minmax_scale\r\n\r\n>>> obs_coefs = list()\r\n>>> sim_coefs = list()\r\n\r\n>>> cols = obs.columns\r\n\r\n>>> for col in cols:\r\n>>>     obs_coef = np.corrcoef(obs_log_return[col], obs_log_return[col]**2, rowvar=False)\r\n>>>     sim_coef = np.corrcoef(sim_log_return[col], sim_log_return[col]**2, rowvar=False)\r\n>>>     obs_coefs.append(obs_coef[0,1])\r\n>>>     sim_coefs.append(sim_coef[0,1])\r\n \r\n>>> data = pd.DataFrame({\"obs\": obs_coefs, \"sim\": sim_coefs}, index=cols)\r\n\r\n>>> fig, ax = plt.subplots(figsize=(8, 2))\r\n\r\n>>> sns.heatmap(\r\n>>>     minmax_scale(data).T, \r\n>>>     annot=data.T, \r\n>>>     xticklabels=data.index,\r\n>>>     yticklabels=data.columns,\r\n>>>     ax=ax, \r\n>>>     linewidths=0.5,\r\n>>>     cbar=False,\r\n>>> )\r\n\r\n>>> plt.tight_layout(rect=[0, 0, 1, 0.925])\r\n>>> fig.suptitle(\"Correlation Between Returns and Volatility\", fontsize=16)\r\n>>> plt.show();\r\n```\r\n\r\n<img src=\"img/stylized-facts-correlation-returns-volatility.png\" alt=\"Correlation between returns and volatilty for both a SimCAP simulation and observed asset prices.\" style=\"max-width: 100%;\">\r\n\r\n# API <a name=\"api\"></a>\r\n\r\n## simcap.SimCAP \r\n\r\n<p style=\"background-color:#eaecef; padding:1em;\">\r\n  <em>class</em> simcap.<strong>SimCAP</strong>(<em>asset_price_history, prototypes=None, asset_proto_rel=None, external_factors=None, suppress_warnings=False</em>)\r\n</p>\r\n\r\nSimulation of Correlated Asset Prices\r\n\r\n### Parameters\r\n\r\n<dl>\r\n  <dt>asset_price_history : pandas DataFrame of shape (n_periods, n_assets)</dt>\r\n  <dd>\r\n    DataFrame of asset price history. Assets should be in columns with periods in \r\n    rows. Ticker symbol or some other unique label for the asset should be in the \r\n    first row. It is assumed the passed DataFrame is already sorted chronologically \r\n    with the most recent price observation in the last row. Each of the assets in  \r\n    this DataFrame will be modeled by the simulation.\r\n  </dd>\r\n  <dt>prototypes : list of ndarrays or pandas Series of shape (n_periods, ), optional</dt>\r\n  <dd>\r\n    A list of univariate time series of shape (n_periods, ). It is assumed each of \r\n    the prototypes are already sorted chronologically with the most recent  \r\n    observation in the last element of the array/Series. Prototypical time series \r\n    can be used to model distributions of assets. For example, if attempting to \r\n    model the price of a mutual fund with only two years of bull market price \r\n    history, one might decide to use a stock index like the S&P 500 as a prototype \r\n    for the mutual fund since the stock index has a longer history with examples \r\n    across all market regimes.\r\n  </dd>\r\n  <dt>asset_proto_rel : dict, optional</dt>\r\n  <dd>\r\n    Required if prototypes are used. A dictionary mapping assets to prototypes. For \r\n    example, if the asset with ticker of \"SPD\" maps to the first prototype, \"GSUS\" \r\n    does not have a prototype, and \"XVV\" maps to the second prototype, pass the \r\n    dictionary: {\"SPD\": 0, \"GSUS\": None, \"XVV\": 1}\r\n  </dd>\r\n  <dt>external_factors : pandas DataFrame of shape (n_periods, n_assets), optional</dt>\r\n  <dd>\r\n    DataFrame of factors that are used to influence the simulation of asset prices \r\n    but are not simulated themselves. The DataFrame should have the same number of \r\n    rows as the asset_price_history DataFrame. external_factor observations for a \r\n    particular period should be in the same row as the asset_price_history \r\n    observations for the same period. For example, if row 4 of the \r\n    asset_price_history DataFrame are prices recorded on 2021-11-15, row 4 of the \r\n    external_factors DataFrame should also be values that were recorded on \r\n    2021-11-15.\r\n  </dd>\r\n  <dt>suppress_warnings : bool, default=False</dt>\r\n  <dd>\r\n    If True, StationaryWarning and CorrelatedExogWarning warnings are suppressed.\r\n  </dd>\r\n</dl>\r\n\r\n### Examples\r\n```python\r\n>>> from simcap.datasets import load_example_asset_price_history\r\n>>> from simcap import SimCAP\r\n\r\n>>> asset_prices = load_example_asset_price_history()\r\n>>> print(asset_prices.shape)\r\n(2517, 8)\r\n\r\n>>> model = SimCAP(asset_prices)\r\n>>> sims = model.generate_simulations(\r\n>>>     n_sims=10, \r\n>>>     periods_per_sim=500,\r\n>>>     output_as_dfs=False,\r\n>>> )\r\n>>> print(sims.shape)\r\n(10, 500, 8)\r\n```\r\n\r\n### Methods\r\n\r\n<p style=\"background-color:#eaecef; padding:1em;\">\r\n  <strong>generate_simulations</strong>(<em>n_sims=100, periods_per_sim=None, begin_values=\"norm\", hmm_search_n_iter=60, hmm_search_n_fits_per_iter=10, hmm_search_params=None, output_as_dfs=True, output_as_float32=False, n_jobs=None, verbose=True</em>)\r\n</p>\r\n\r\nGenerate simulations using the data set at object initiation.\r\n\r\n### Parameters\r\n<dl>\r\n  <dt>n_sims : int, default=100</dt>\r\n  <dd>\r\n    The number of simulations to generate.\r\n  </dd>\r\n  <dt>periods_per_sim : int, optional</dt>\r\n  <dd>\r\n    The number of periods, or rows, to generate in each simulation. If None \r\n    (default), the periods per simulation will match the number of rows in the \r\n    asset_price_history DataFrame.\r\n  </dd>\r\n  <dt>begin_values : {\"start\", \"end\", \"norm\"}, default=\"norm\"</dt>\r\n  <dd>\r\n    The values to set for the first row of each simulation. \"start\" will set the \r\n    first row of each simulation to match the first row of asset prices in the \r\n    asset_price_history DataFrame. \"end\" will set the first row of each \r\n    simulation to match the last row of the asset_price_history DataFrame. \r\n    \"norm\" will set the first row of each simulation to 1 for all assets.\r\n  </dd>\r\n  <dt>hmm_search_n_iter: int, default=60</dt>\r\n  <dd>\r\n    For Hidden Markov Model search, the number of parameter settings that are \r\n    sampled. <code>n_iter</code> trades off runtime vs quality of the solution. If \r\n    exhausitive search of the parameter grid would result in fewer iterations, \r\n    search stops when all parameter combinations have been searched.\r\n  </dd>\r\n  <dt>hmm_search_n_fits_per_iter: int, default=10</dt>\r\n  <dd>\r\n    The number of Hidden Markov Models to be randomly initialized and evaluated \r\n    for each combination of parameter settings.\r\n  </dd>\r\n  <dt>hmm_search_params: dict, default=None</dt>\r\n  <dd>\r\n    For Hidden Markov Model search, dictionary with parameter names (str) as \r\n    keys and lists of parameters to try as dictionary values. Parameter lists \r\n    are sampled uniformly. All of the parameters are required:\r\n    \r\n    * n_states: list of ints\r\n    * cov_window_size: list of ints\r\n    * pca_n_components: list of floats, ints, or None\r\n    * scale_before_pca: list of bool\r\n    * scale_after_pca: list of bool\r\n    \r\n    If fit_pipeline_params is None, default is:\r\n\r\n        dict = (\r\n            n_states = [3, 4, 5, 6, 7, 8, 9],\r\n            cov_window_size = [13, 21, 34, 55, 89, 144],\r\n            pca_n_components = [0.8, 0.85, 0.9, 0.95, None],\r\n            scale_before_pca = [True, False],\r\n            scale_after_pca = [True, False],\r\n        )\r\n  </dd>\r\n  <dt>output_as_dfs : bool, default=True</dt>\r\n  <dd>\r\n    If True, simulations are output as an n_sims element list of DataFrames of \r\n    shape (periods_per_sim, n_assets). If False, simulations are ouput as an \r\n    ndarray of shape (n_sims, periods_per_sim, n_assets).\r\n  </dd>\r\n  <dt>output_as_float32 : bool, default=False</dt>\r\n  <dd>\r\n    If True, convert simulation array to float32. If False, simulation will be \r\n    output as float64.\r\n  </dd>\r\n  <dt>n_jobs : int, default=None</dt>\r\n  <dd>\r\n    Number of jobs to run in parallel when performing Hidden Markov Model search \r\n    as well as when generating simulations. None means 1. -1 means using all \r\n    processors.\r\n  </dd>\r\n  <dt>verbose : bool, default=True</dt>\r\n  <dd>\r\n    If True, progress bar written to stdout as simulations are generated.\r\n  </dd>\r\n</dl>\r\n\r\n### Returns\r\n<dl>\r\n  <dt>\r\n    simulations : list (of length n_sims) of pandas DataFrames of \r\n    shape (n_periods, n_variables) or ndarray of shape (n_simulations, \r\n    n_periods, n_variables)\r\n  </dt>\r\n  <dd>\r\n    If <code>output_as_dfs</code> is True, simulations are output as an n_sims element \r\n    list of DataFrames of shape (periods_per_sim, n_assets). If False, \r\n    simulations are ouput as an ndarray of shape (n_sims, \r\n    periods_per_sim, n_assets).\r\n  </dd>\r\n</dl>\r\n\r\n# About the Developer <a name=\"about-the-developer\"></a>\r\nSimCAP is developed by me, [Jeremy Doyle](http://www.jeremy-doyle.com). I have a degree in finance and extensive securities industry experience. My never-ending pursuit for better analysis tools led me to data science and I fell in love with it. My passion therefore lies at the intersection of financial services and data science. \r\n\r\nWhen optimizing the allocation of my own investment portfolio I wanted to stress-test allocations against multiple alternate realities &mdash; Monte Carlo simulation &mdash; but I struggled to find a package that could generate *realistic* simulations of correlated stock prices. Try doing a Google search for \"simulating correlated stock prices\" and you'll find a lot of talk about Geometric Brownian Motion (doesn't easily model multiple correlated assets) or simulations based on the Cholesky decomposition (can easily generate correlated simulations but the resulting return distributions are Gaussian and do not exhibit any of the volatility clustering we see in the \"wild\"). Since I couldn't find a suitable tool, I decided to build my own &mdash; the result was SimCAP. \r\n\r\nIf you have any questions, requests, or suggestions, please reach out to me at <a href=\"mailto:hello@jeremy-doyle.com\">hello@jeremy-doyle.com</a>. I hope you find SimCAP useful.\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/jeremy-doyle/simcap",
    "keywords": "finance,investment,analysis,securities,simulation,markov,time,series,monte,carlo,risk",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "simcap",
    "package_url": "https://pypi.org/project/simcap/",
    "platform": null,
    "project_url": "https://pypi.org/project/simcap/",
    "project_urls": {
      "Homepage": "https://github.com/jeremy-doyle/simcap"
    },
    "release_url": "https://pypi.org/project/simcap/0.2.0/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Simulation of Correlated Asset Prices",
    "version": "0.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13938168,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "567f72acce9704e45b2181ed3749eae2b85a27bcd677cccc0ab37989973050a6",
          "md5": "028bab6aaceabf8465593860dac42bd1",
          "sha256": "4aaa646d4da33b13b51bac1089b9813cc11305447024c98b9a61879827be4a9b"
        },
        "downloads": -1,
        "filename": "simcap-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "028bab6aaceabf8465593860dac42bd1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 29577,
        "upload_time": "2022-04-29T22:53:29",
        "upload_time_iso_8601": "2022-04-29T22:53:29.297271Z",
        "url": "https://files.pythonhosted.org/packages/56/7f/72acce9704e45b2181ed3749eae2b85a27bcd677cccc0ab37989973050a6/simcap-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bb2e09349906111f269b048b312e5ebddb7291325fe23891d6f9f72c59cfc3b8",
          "md5": "6413f78e425e9f51082dddb6dd77c602",
          "sha256": "2eeba486924d5ddc652e9ed90d7cdf5f6f0b7fb06554412029b169d3092cb7df"
        },
        "downloads": -1,
        "filename": "simcap-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "6413f78e425e9f51082dddb6dd77c602",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 589955,
        "upload_time": "2022-04-29T23:18:12",
        "upload_time_iso_8601": "2022-04-29T23:18:12.470677Z",
        "url": "https://files.pythonhosted.org/packages/bb/2e/09349906111f269b048b312e5ebddb7291325fe23891d6f9f72c59cfc3b8/simcap-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ef388af27ea14c6b350519cf1e7e964971c9ea110c35c7d5ba478a8f7364fe9e",
          "md5": "945964777aba8c0e4f94621afdd5ee5a",
          "sha256": "d4fe6a273b48fc833f5668da13479fbecbca50afee80819ed813370a4dd91296"
        },
        "downloads": -1,
        "filename": "simcap-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "945964777aba8c0e4f94621afdd5ee5a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 590523,
        "upload_time": "2022-05-25T21:38:31",
        "upload_time_iso_8601": "2022-05-25T21:38:31.987692Z",
        "url": "https://files.pythonhosted.org/packages/ef/38/8af27ea14c6b350519cf1e7e964971c9ea110c35c7d5ba478a8f7364fe9e/simcap-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ef388af27ea14c6b350519cf1e7e964971c9ea110c35c7d5ba478a8f7364fe9e",
        "md5": "945964777aba8c0e4f94621afdd5ee5a",
        "sha256": "d4fe6a273b48fc833f5668da13479fbecbca50afee80819ed813370a4dd91296"
      },
      "downloads": -1,
      "filename": "simcap-0.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "945964777aba8c0e4f94621afdd5ee5a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 590523,
      "upload_time": "2022-05-25T21:38:31",
      "upload_time_iso_8601": "2022-05-25T21:38:31.987692Z",
      "url": "https://files.pythonhosted.org/packages/ef/38/8af27ea14c6b350519cf1e7e964971c9ea110c35c7d5ba478a8f7364fe9e/simcap-0.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}