{
  "info": {
    "author": "Markus Weber",
    "author_email": "markus.weber@wacom.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "\n# Universal Ink Library\n\n[![PyPI](https://img.shields.io/pypi/v/universal-ink-library.svg)](https://pypi.python.org/pypi/universal-ink-library)\n[![PyPI](https://img.shields.io/pypi/pyversions/universal-ink-library.svg)](https://pypi.python.org/pypi/universal-ink-library)\n[![Documentation](https://img.shields.io/badge/api-reference-blue.svg)](https://developer-docs.wacom.com/sdk-for-ink/docs/model) \n\nUniversal Ink Library is a pure Python package for working with Universal Ink Models ([UIM](https://developer.wacom.com/products/universal-ink-model)).\nThe UIM defines a language-neutral and platform-neutral data model for representing and manipulating digital ink data captured using an electronic pen or stylus, or using touch input.\n\nThe main aspects of the UIM are:\n\n- Interoperability of ink-based data models by defining a standardized interface with other systems\n- Biometric data storage mechanism\n- Spline data storage mechanism\n- Rendering configurations storage mechanism\n- Ability to compose spline/raw-input based logical trees, which are contained within the ink model\n- Portability, by enabling conversion to common industry standards\n- Extensibility, by enabling the description of ink data related semantic meta-data\n- Standardized serialization mechanism\n\nThis reference document defines a RIFF container and Protocol Buffers schema for serialization of ink models as well as \na standard mechanism to describe relationships between different parts of the ink model, and/or between parts of the ink \nmodel and external entities.\n\nThe specified serialization schema is based on the following standards:\n\n- **Resource Interchange File Format (RIFF)** - A generic file container format for storing data in tagged chunks\n- **Protocol Buffers v3** - A language-neutral, platform-neutral extensible mechanism for serializing structured data\n- **Resource Description Framework (RDF)** - A standard model for data interchange on the Web\n- **OWL 2 Web Ontology Language (OWL2)** - An ontology language for the Semantic Web with formally defined meaning\n\n## Data Model\nThe *Universal Ink Model* has five fundamental categories:\n\n- **Input data**: A collection of data repositories, holding raw sensor input, input device/provider configurations, sensor channel configurations, etc. Each data repository keeps certain data-sets isolated and is responsible for specific type(s) of data\n- **Ink data**: The visual appearance of the digital ink, presented as ink geometry with rendering configurations\n- **Meta-data**: Related meta-data about the environment, input devices, etc.\n- **Ink Trees / Views**: A collection of logical trees, representing structures of hierarchically organized paths or raw input data-frames\n- **Semantic triple store**: An RDF compliant triple store, holding semantic information, such as text structure, handwriting recognition results, and semantic entities\n\nThe diagram below illustrates the different logical parts of the ink model.\n![Logical Parts of Ink Model.](https://github.com/Wacom-Developer/universal-ink-library/raw/main/assets/uim-v1.png)\n\nThis UML diagram illustrates the complete Ink Model in terms of logical models and class dependencies.\n![UML Diagram](https://github.com/Wacom-Developer/universal-ink-library/raw/main/assets/uim-uml-all-v9.png)\n\nThe *Universal Ink Model* provides the flexibility required for a variety of applications, since the display of pen data is only one aspect.\nFor example, the same data can be used for data mining or even signature comparison, while the ink display can be on a range of platforms potentially requiring different scaling and presentation.\n\n## Input data\n\nIn reality, pen data is captured from a pen device as a set of positional points:\n\n![Digital-ink-w](https://github.com/Wacom-Developer/universal-ink-library/raw/main/assets/overview_ink_device_sensor_channels.png)\n\nDepending on the type of hardware, in addition to the x/y positional coordinates, the points can contain further information such as pen tip force and angle.\nCollectively, this information is referred to as sensor data and the *Universal Ink Model* provides a means of storing all the available data.\nFor example, with some types of hardware, pen hover coordinates can be captured while the pen is not in contact with the surface.\nThe information is saved in the *Universal Ink Model* and can be used when required.\n\n## Ink data\n\nInk data is the result of the [ink geometry pipeline](https://developer-docs.wacom.com/sdk-for-ink/docs/pipeline) of the [WILL SDK for ink](https://developer.wacom.com/products/will-sdk-for-ink).\nPen strokes are identified as continuous sets of pen coordinates captured while the pen is in contact with the surface. \nFor example, writing the letter â€˜w', as illustrated below.\nThe process converts each pen stroke into a matmeta-datahematical representation, which can then be used to render the shape on a display.\nSteps in the so-called Ink Geometry pipeline are illustrated below where each step is configured by an application to generate the desired output:\n\n![Digital-ink-rendering](https://github.com/Wacom-Developer/universal-ink-library/raw/main/assets/pen-data-w-rendering.png)\n\nAs a result, the data points are smoothed and shaped to produce the desired representation. \nFor example, simulating the appearance of a felt-tip ink pen.\nRaster and vector rendering is supported with a selection of rendering brush types.\n\nThe results are saved as Ink data, containing ink geometry and rendering information.\n\n## Meta-data\n\nMeta-data is added as data about the pen data.\nThe *Universal Ink Model* allows for administrative information such as author name, location, pen data source, etc.\nFurther meta-data is computed by analysis of the pen data.\nAn example of digital ink is annotated below:\n\n![Digital-ink-annotated](https://github.com/Wacom-Developer/universal-ink-library/raw/main/assets/pen-data-annotated.png)\n\nThe labels identify pen strokes *s1, s2, s3*, etc.\nIn addition, groups of strokes are identified as *g1, g2, g3*, etc.\nPen strokes are passed to a handwriting recognition engine, and the results are stored as additional meta-data, generally referred to as semantic data.\nThe semantic data is stored with reference to the groups, categorized as single characters, individual words, lines of text, and so on.\n\n\n# Installation\n\nOur Universal Ink Library can be installed using pip.\n\n``\n    $ pip install universal-ink-library\n``\n\n\n# Quick Start\n\n## File handling\n###  Loading UIM\n\nThe `UIMParser` is be used to load a serialized Universal Ink Model in version 3.0.0 or 3.1.0 and you receive the memory model `InkModel` which can be used for extracting the relevant data.\n\n```python\nfrom uim.codec.parser.uim import UIMParser\nfrom uim.model.ink import InkModel\n\nparser: UIMParser = UIMParser()\n# ---------------------------------------------------------------------------------\n# Parse a UIM file version 3.0.0\n# ---------------------------------------------------------------------------------\nink_model_1: InkModel = UIMParser().parse('../ink/uim_3.0.0/1) Value of Ink 1.uim')\n# ---------------------------------------------------------------------------------\n# Parse a UIM file version 3.1.0\n# ---------------------------------------------------------------------------------\nink_model_2: InkModel = UIMParser().parse('../ink/uim_3.1.0/1) Value of Ink 1.uim')\n\n```\n###  Loading WILL 2.0 file\n\nThe `WILL2Parser` is be used to load a serialized Wacom Ink Layer Language (WILL), e.g., from [Wacom's Inkspace](https://inkspace.wacom.com/).\n\n```python\nfrom uim.codec.parser.will import WILL2Parser\nfrom uim.model.ink import InkModel\n\nparser: WILL2Parser = WILL2Parser()\nink_model: InkModel = parser.parse('../ink/will/elephant.will')\n```\n\n### Saving of UIM\n\nSaving the `InkModel` as a Universal Ink Model file.\n\n```python\nfrom uim.codec.writer.encoder.encoder_3_1_0 import UIMEncoder310\nfrom uim.model.ink import InkModel\n\nink_model: InkModel = InkModel()\n... \n\n# Save the model, this will overwrite an existing file\nwith io.open('3_1_0.uim', 'wb') as uim:\n    # unicode(data) auto-decodes data to unicode if str\n    uim.write(UIMEncoder310().encode(ink_model))\n```\n\nFind the sample, [here](https://github.com/Wacom-Developer/universal-ink-library/blob/main/samples/sample_file_handling.py)\n\n## InkModel\n\n### Iterate over semantics\n\nIf the `InkModel` is enriched with semantics from handwriting recognition and named entity recognition, or named entity linking.\nThe semantics an be access with a helper function `uim_extract_text_and_semantics_from` or by iterating the views, like shown in `uim_extract_text_and_semantics_from` function:\n\n```python\n    if ink_model.has_knowledge_graph() \\\n            and ink_model.has_tree(CommonViews.HWR_VIEW.value) \\\n            and ink_model.has_tree(CommonViews.NER_VIEW.value):\n        # The sample\n        text_lines, entities = uim_extract_text_and_semantics_from(ink_model, \n                                                                   hwr_view=CommonViews.HWR_VIEW.value,\n                                                                   ner_view=CommonViews.NER_VIEW.value)\n        line_number: int = 1\n        print('-------------------------------------------------------------------------')\n        print(' Text lines:')\n        print('-------------------------------------------------------------------------')\n        for line in text_lines:\n            print(f'{line_number}. Text line: {line[\"line\"]} | {line[\"box\"]}')\n            word_num: int = 1\n            for word in line['words']:\n                print(f' {word_num}. Word: {word[\"word\"]} | {word[\"box\"]}')\n                print(f'  -> Stroke UUIDs: {[str(w) for w in word[\"strokes\"]]}')\n                word_num += 1\n            line_number += 1\n        print()\n        entity_number: int = 1\n        print('-------------------------------------------------------------------------')\n        print(' Entities:')\n        print('-------------------------------------------------------------------------')\n        for entity in entities:\n            print(f'{entity_number}. URI: {entity[\"statements\"][SEMANTIC_HAS_URI]} - '\n                  f'{entity[\"statements\"][SEMANTIC_HAS_LABEL]} '\n                  f'({entity[\"statements\"][SEMANTIC_HAS_TYPE]})')\n            entity_number += 1\n```\n\n### Accessing input and ink data\nIn order to access ink input configuration data, sensor data, or stroke data from `InkModel`, you can use the following functions:\n\n```python\nfrom typing import Dict\nfrom uuid import UUID\n\nfrom uim.codec.parser.uim import UIMParser\nfrom uim.model.ink import InkModel\nfrom uim.model.inkinput.inputdata import InkInputType, InputContext, SensorContext, InputDevice\nfrom uim.model.inkinput.sensordata import SensorData\n\nif __name__ == '__main__':\n    parser: UIMParser = UIMParser()\n    # This file contains ink from different providers: PEN, TOUCH, MOUSE\n    ink_model: InkModel = parser.parse('../ink/uim_3.1.0/6) Different Input Providers.uim')\n\n    mapping_type: Dict[UUID, InkInputType] = {}\n    if ink_model.has_ink_structure():\n        print('InkInputProviders:')\n        print('-------------------')\n        # Iterate Ink input providers\n        for ink_input_provider in ink_model.input_configuration.ink_input_providers:\n            print(f' InkInputProvider. ID: {ink_input_provider.id} | type: {ink_input_provider.type}')\n            mapping_type[ink_input_provider.id] = ink_input_provider.type\n        print()\n        print('Strokes:')\n        print('--------')\n        # Iterate over strokes\n        for stroke in ink_model.strokes:\n            print(f'|- Stroke (id:={stroke.id} | points count: {stroke.points_count})')\n            if stroke.style and stroke.style.path_point_properties:\n                print(f'|   |- Style (render mode:={stroke.style.render_mode_uri} | color:=('\n                      f'red: {stroke.style.path_point_properties.red}, '\n                      f'green: {stroke.style.path_point_properties.green}, '\n                      f'blue: {stroke.style.path_point_properties.green}, '\n                      f'alpha: {stroke.style.path_point_properties.alpha}))')\n            # Stroke is produced by sensor data being processed by the ink geometry pipeline\n            sd: SensorData = ink_model.sensor_data.sensor_data_by_id(stroke.sensor_data_id)\n            # Get InputContext for the sensor data\n            input_context: InputContext = ink_model.input_configuration.get_input_context(sd.input_context_id)\n            # Retrieve SensorContext\n            sensor_context: SensorContext = ink_model.input_configuration\\\n                .get_sensor_context(input_context.sensor_context_id)\n            for scc in sensor_context.sensor_channels_contexts:\n                # Sensor channel context is referencing input device\n                input_device: InputDevice = ink_model.input_configuration.get_input_device(scc.input_device_id)\n                print(f'|   |- Input device (id:={input_device.id} | type:=({mapping_type[scc.input_provider_id]})')\n                # Iterate over sensor channels\n                for c in scc.channels:\n                    print(f'|   |     |- Sensor channel (iid:={c.id} | name: {c.type.name} '\n                          f'| values: {sd.get_data_by_id(c.id).values}')\n            print('|')\n```\n\nFind the sample, [here](https://github.com/Wacom-Developer/universal-ink-library/blob/main/samples/sample_input_and_ink.py)\n\n## Creating an Ink Model \nCreating an `InkModel` from the scratch:\n\n```python\nfrom uim.model.base import UUIDIdentifier\nfrom uim.model.ink import InkModel, InkTree\nfrom uim.model.inkdata.brush import VectorBrush, BrushPolygon, BrushPolygonUri, RasterBrush, RotationMode, BlendMode\nfrom uim.model.inkdata.strokes import Spline, Style, Stroke, LayoutMask\nfrom uim.model.inkinput.inputdata import Environment, InkInputProvider, InkInputType, InputDevice, SensorChannel, \\\n    InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext, InputContext\nfrom uim.model.inkinput.sensordata import SensorData, InkState\nfrom uim.model.semantics import syntax\nfrom uim.model.semantics.node import StrokeGroupNode, StrokeNode, StrokeFragment, URIBuilder\nfrom uim.model.semantics.syntax import SemanticTriple, CommonViews\nfrom uim.utils.matrix import Matrix4x4\n\nif __name__ == '__main__':\n    \"\"\"Creates an ink model from the scratch.\"\"\"\n    # Create the model\n    ink_model: InkModel = InkModel()\n    # Setting a unit scale factor\n    ink_model.unit_scale_factor = 1.5\n    # Using a 4x4 matrix for scaling\n    ink_model.transform = Matrix4x4.create_scale(1.5)\n\n    # Properties are added as key-value pairs\n    ink_model.properties.append((\"Author\", \"John\"))\n    ink_model.properties.append((\"PrimaryLanguage\", \"en_US\"))\n    ink_model.properties.append((\"OtherStuff\", \"Yes\"))\n\n    # Create an environment\n    env: Environment = Environment()\n    env.properties.append((\"env.name\", \"My Environment\"))\n    env.properties.append((\"os.id\", \"98765\"))\n    env.properties.append((\"os.name\", \"Windows\"))\n    env.properties.append((\"os.version\", \"10.0.18362.239\"))\n    env.properties.append((\"os.build\", \"239\"))\n    env.properties.append((\"os.platform\", \"whatever\"))\n    ink_model.input_configuration.environments.append(env)\n\n    # Ink input provider can be pen, mouse or touch.\n    provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)\n    provider.properties.append((\"pen.id\", \"1234567\"))\n    ink_model.input_configuration.ink_input_providers.append(provider)\n\n    # Input device is the sensor (pen tablet, screen, etc.)\n    input_device: InputDevice = InputDevice()\n    input_device.properties.append((\"dev.id\", \"123454321\"))\n    input_device.properties.append((\"dev.manufacturer\", \"Wacom\"))\n    input_device.properties.append((\"dev.model\", \"Mobile Studio Pro\"))\n    input_device.properties.append((\"dev.cpu\", \"Intel\"))\n    input_device.properties.append((\"dev.graphics.display\", \"Dell 1920x1080 32bit\"))\n    input_device.properties.append((\"dev.graphics.adapter\", \"NVidia\"))\n    ink_model.input_configuration.devices.append(input_device)\n\n    # Create a group of sensor channels\n    sensor_channels_tablet: list = [\n        SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),\n        SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),\n        SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)\n    ]\n\n    scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,\n                                                              ink_input_provider_id=provider.id,\n                                                              input_device_id=input_device.id)\n\n    # We can create an additional input device, for example one providing pressure via Bluetooth\n    input_device_bluetooth: InputDevice = InputDevice()\n    input_device_bluetooth.properties.append((\"dev.id\", \"345456567\"))\n    input_device_bluetooth.properties.append((\"dev.manufacturer\", \"Apple\"))\n    ink_model.input_configuration.devices.append(input_device_bluetooth)\n\n    sensor_channels_bluetooth: list = [\n        SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),\n        SensorChannel(channel_type=InkSensorType.PRESSURE, metric=InkSensorMetricType.FORCE, resolution=1.0),\n    ]\n\n    scc_bluetooth: SensorChannelsContext = SensorChannelsContext(input_device_id=input_device_bluetooth.id,\n                                                                 channels=sensor_channels_bluetooth)\n\n    # Add all sensor channel contexts\n    sensor_context: SensorContext = SensorContext()\n    sensor_context.add_sensor_channels_context(scc_tablet)\n    sensor_context.add_sensor_channels_context(scc_bluetooth)\n    ink_model.input_configuration.sensor_contexts.append(sensor_context)\n\n    # Create the input context using the Environment and the Sensor Context\n    input_context: InputContext = InputContext(environment_id=env.id, sensor_context_id=sensor_context.id)\n    ink_model.input_configuration.input_contexts.append(input_context)\n\n    # Create sensor data\n    sensor_data_0: SensorData = SensorData(UUIDIdentifier.id_generator(), input_context_id=input_context.id,\n                                           state=InkState.PLANE)\n\n    sensor_data_0.add_timestamp_data(sensor_channels_tablet[0], [0, 1, 2, 4, 5])\n    sensor_data_0.add_data(sensor_channels_tablet[1],  [100.4, 103.7, 110.1])\n    sensor_data_0.add_data(sensor_channels_tablet[2],  [200.1, 202.0, 207.0])\n\n    sensor_data_0.add_timestamp_data(sensor_channels_bluetooth[0], [0, 1, 2])\n\n    sensor_data_0.add_data(sensor_channels_bluetooth[1], [100, 200])\n\n    # Add sensor data to the model\n    ink_model.sensor_data.add(sensor_data_0)\n\n    # We need to define a brush polygon\n    points: list = [(10, 10), (0, 10), (0, 0)]\n    brush_polygons: list = [BrushPolygon(min_scale=0., points=points)]\n\n    # Create the brush object using polygons\n    vector_brush_0: VectorBrush = VectorBrush(\n        \"app://qa-test-app/vector-brush/MyTriangleBrush\",\n        brush_polygons)\n\n    # Add it to the model\n    ink_model.brushes.add_vector_brush(vector_brush_0)\n\n    # Add a brush specified with shape Uris\n    poly_uris: list = [\n        BrushPolygonUri(\"will://brush/3.0/shape/Circle?precision=20&radius=1\", 0.),\n        BrushPolygonUri(\"will://brush/3.0/shape/Ellipse?precision=20&radiusX=1&radiusY=0.5\", 4.0)\n    ]\n\n    vector_brush_1: VectorBrush = VectorBrush(\n        \"app://qa-test-app/vector-brush/MyEllipticBrush\",\n        poly_uris)\n\n    raster_brush_0: RasterBrush = RasterBrush(\n        name=\"app://qa-test-app/raster-brush/MyRasterBrush\",\n        spacing=10., scattering=5., rotation=RotationMode.TRAJECTORY, shape_textures=[bytes([10, 20]),\n                                                                                      bytes([30, 20])],\n        fill_width=2.0, fill_height=0.3,\n        fill_texture=bytes([10, 10, 20, 15, 17, 20, 25, 16, 34, 255, 23, 0, 34, 255, 23, 255]),\n        randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)\n\n    # Add it to the model\n    ink_model.brushes.add_raster_brush(raster_brush_0)\n\n    raster_brush_1: RasterBrush = RasterBrush(\n        name=\"app://qa-test-app/raster-brush/MyRasterBrush1\",\n        spacing=10.0, scattering=5.0, rotation=RotationMode.TRAJECTORY, fill_width=2., fill_height=0.3,\n        fill_texture_uri=\"app://qa-test-app/raster-brush-fill/mixedShapesGL\",\n        shape_texture_uris=[\n            \"app://qa-test-app/raster-brush-shape/mixedShapesGL_128x128\",\n            \"app://qa-test-app/raster-brush-shape/mixedShapesGL_64x64\",\n            \"app://qa-test-app/raster-brush-shape/mixedShapesGL_32x32\",\n            \"app://qa-test-app/raster-brush-shape/mixedShapesGL_16x16\"\n        ], randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)\n\n    ink_model.brushes.add_raster_brush(raster_brush_1)\n    ink_model.brushes.add_vector_brush(vector_brush_1)\n\n    # Specify the layout of the stroke data, in this case the stroke will have variable X, Y and Size properties.\n    layout_mask: int = LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value\n\n    # Provide the stroke data - in this case 4 data points, each consisting of X, Y, Size\n    path: list = [\n        10., 10.7, 1.0,\n        21.0, 20.2, 2.0,\n        30.0, 12.4, 2.1,\n        40.0, 15.0, 1.5\n    ]\n\n    # Create a spline object from the path data\n    spline: Spline = Spline(layout_mask, path)\n\n    # Create some style\n    style: Style = Style(brush_uri=vector_brush_0.name)\n    style.path_point_properties.red = 1.0\n    style.path_point_properties.green = 0.0\n    style.path_point_properties.blue = 0.4\n    style.path_point_properties.alpha = 1.0\n\n    # Create a stroke object. Note that it just exists, but is not in the model yet.\n    stroke_0: Stroke = Stroke(sid=UUIDIdentifier.id_generator(), spline=spline, style=style)\n\n    # Create a spline object - 9 data points, each consisting of X, Y, Size, Red, Green, Blue, Alpha\n    spline_1: Spline = Spline(\n        LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value | LayoutMask.RED.value | LayoutMask.GREEN.value\n        | LayoutMask.BLUE.value | LayoutMask.ALPHA.value,\n        [10.0, 10.7, 1.0, 0.5, 0.0, 0.1, 1.0,\n         21.0, 20.2, 2.0, 0.9, 0.4, 0.2, 0.8,\n         30.0, 12.4, 2.1, 0.7, 0.1, 0.1, 0.7,\n         40.0, 15.0, 1.5, 0.3, 0.5, 0.4, 1.0,\n         50.0, 45.0, 1.0, 0.3, 0.5, 0.4, 1.0,\n         41.0, 53.0, 1.1, 0.2, 0.3, 0.5, 0.9,\n         33.0, 73.0, 1.2, 0.6, 0.7, 0.4, 0.8,\n         20.0, 84.0, 1.3, 0.7, 0.8, 0.3, 0.7,\n         10.0, 91.0, 1.1, 0.7, 0.9, 0.2, 0.6]\n    )\n\n    # Create a style\n    style_1: Style = Style(brush_uri=raster_brush_0.name)\n    style_1.path_point_properties.rotation = 0.35\n\n    # The render mode URI can also be app specific like app://blabla\n    # The URI will://rasterization/3.0/blend-mode/SourceOver is assumed and must not be set.\n    style_1.render_mode_uri = \"will://rasterization/3.0/blend-mode/DestinationOver\"\n\n    # Create a stroke object. Note that it just exists, but is not in the model yet.\n    stroke_1: Stroke = Stroke(UUIDIdentifier.id_generator(), spline=spline_1, style=style_1)\n\n    # First you need a root group to contain the strokes\n    root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())\n\n    # Assign the group as the root of the main ink tree\n    ink_model.ink_tree = InkTree()\n    ink_model.ink_tree.root = root\n\n    # Add a node for stroke 0\n    stroke_node_0: StrokeNode = StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0))\n    root.add(stroke_node_0)\n\n    # Add a node for stroke 1\n    root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))\n\n    # Adding view for handwriting recognition results\n    hwr_tree: InkTree = InkTree(CommonViews.HWR_VIEW.value)\n    # Add view right after creation, to avoid warnings that tree is not yet attached\n    ink_model.add_view(hwr_tree)\n\n    hwr_root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())\n    hwr_tree.root = hwr_root\n\n    # Here you can add the same strokes as in the main tree, but you can organize them in a different way\n    # (put them in different groups)\n    # You are not supposed to add strokes that are not already in the main tree.\n    hwr_root.add(StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0)))\n\n    # A view node can refer to a fragment of a stroke.\n    hwr_root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))\n\n    # The hwr root denotes a word\n    ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.CommonRDF.PRED_RDF_HAS_TYPE, syntax.WORD))\n    ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.Semantics.PRED_IS, \"Wacom\"))\n\n    # We need an URI builder\n    uri_builder: URIBuilder = URIBuilder()\n\n    # Create a named entity\n    named_entity_uri: str = uri_builder.build_named_entity_uri(UUIDIdentifier.id_generator())\n    ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.Semantics.PRED_HAS_NAMED_ENTITY_DEFINITION,\n                                                    named_entity_uri))\n\n    # Add knowledge for the named entity\n    ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, \"entityType\", \"Organization\"))\n    ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, \"basedIn\", \"Japan\"))\n    ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, \"hasConfidence\", \"0.85\"))\n\n    # Save the model, this will overwrite an existing file\n    with io.open('3_1_0.uim', 'wb') as uim:\n        # unicode(data) auto-decodes data to unicode if str\n        uim.write(UIMEncoder310().encode(ink_model))\n```\n\nFind the sample, [here](https://github.com/Wacom-Developer/universal-ink-library/blob/main/samples/sample_create_model.py)\n\n# Web Demos\nThe following web demos can be used to produce Universal Ink Model files: \n\n- [Universal Ink Model Viewer](https://universal-ink-model-viewer.azurewebsites.net/) - producing UIM 3.0.0 files,\n- [WILL SDK for ink - Demo](https://will3-web-ink-demo.azurewebsites.net/) - producing UIM 3.1.0 files.\n\n\n# Documentation\nYou can find more detailed technical documentation, [here](https://developer-docs.wacom.com/sdk-for-ink/docs/model).\nAPI documentation is available [here](docs/uim/index.html).\n\n# Usage\n\nThe library is used for machine learning experiments based on digital ink using the Universal Ink Model. \n\n> :warning:  Its is still under development, so **we do not recommend using it yet for production environments**. Moreover, it is not following any formal QA and release process, yet.\n\n# Contributing\nContribution guidelines are still work in progress.\n\n# License\n[Apache License 2.0](LICENSE)\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/Wacom-Developer/universal-ink-library",
    "keywords": "universal ink model;digital ink;wacom ink technologies",
    "license": "Apache 2.0 License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "universal-ink-library",
    "package_url": "https://pypi.org/project/universal-ink-library/",
    "platform": null,
    "project_url": "https://pypi.org/project/universal-ink-library/",
    "project_urls": {
      "Homepage": "https://github.com/Wacom-Developer/universal-ink-library"
    },
    "release_url": "https://pypi.org/project/universal-ink-library/1.0.6/",
    "requires_dist": [
      "numpy (>=1.16.4)",
      "bitstring (>=3.1.7)",
      "protobuf (==3.20.3)",
      "varint (>=1.0.2)",
      "python-dateutil (>=2.8.1)",
      "lxml (>=4.6.3)"
    ],
    "requires_python": "",
    "summary": "Library to parse and write Universal Ink Model data files.",
    "version": "1.0.6",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15331570,
  "releases": {
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "087df453f4cd503b4154d1f8c1b40c7ad7134a6c8b2dda300862a4e8018f32d8",
          "md5": "1f3887f4555f924bc17f28cf3a381517",
          "sha256": "b16dfba2f13c9695f7a0eff70be44af2b3f8ac804580290c097792d5b456174a"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.1-_wacom_uim_py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1f3887f4555f924bc17f28cf3a381517",
        "packagetype": "bdist_wheel",
        "python_version": "_wacom_uim_py3",
        "requires_python": null,
        "size": 134578,
        "upload_time": "2021-08-18T10:47:17",
        "upload_time_iso_8601": "2021-08-18T10:47:17.319115Z",
        "url": "https://files.pythonhosted.org/packages/08/7d/f453f4cd503b4154d1f8c1b40c7ad7134a6c8b2dda300862a4e8018f32d8/universal_ink_library-1.0.1-_wacom_uim_py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "48e79c2cf59421aaf2c2ade3fec0baaed0be1e58fd329bdc2dd62bf736c94aba",
          "md5": "e94ddaa6d5af79bf2b1bfdf2c94fb80a",
          "sha256": "feaa267d81d4b1d9f7cfb397d816c0dc4bc49a813208c09defa53b0b9fababc3"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.1_wacom_uim.tar.gz",
        "has_sig": false,
        "md5_digest": "e94ddaa6d5af79bf2b1bfdf2c94fb80a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3541552,
        "upload_time": "2021-08-18T10:47:20",
        "upload_time_iso_8601": "2021-08-18T10:47:20.675935Z",
        "url": "https://files.pythonhosted.org/packages/48/e7/9c2cf59421aaf2c2ade3fec0baaed0be1e58fd329bdc2dd62bf736c94aba/universal_ink_library-1.0.1_wacom_uim.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f59c7ce5bf2c2978079d16a0e271933ca5562b3d555fc182c4a0eeb475b5699f",
          "md5": "e6c995bcc490c6333ce977f615571a9b",
          "sha256": "9ef81e56d8981e489f8f65683e1fab54a18537799fa83288ee1e37224bf3042d"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e6c995bcc490c6333ce977f615571a9b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134577,
        "upload_time": "2021-08-18T11:18:55",
        "upload_time_iso_8601": "2021-08-18T11:18:55.006221Z",
        "url": "https://files.pythonhosted.org/packages/f5/9c/7ce5bf2c2978079d16a0e271933ca5562b3d555fc182c4a0eeb475b5699f/universal_ink_library-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3d3b50c149eb5f0821d529cb80d9afa25ede11d93cc5d726c75b6540e040dbfc",
          "md5": "9ffd41923c76ae0792242fcdae1bf6b1",
          "sha256": "2b4021a487e1dcce9f7d78d16f65ef24dc584fdd67af3085a010509210c535ea"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "9ffd41923c76ae0792242fcdae1bf6b1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3541538,
        "upload_time": "2021-08-18T11:18:58",
        "upload_time_iso_8601": "2021-08-18T11:18:58.201048Z",
        "url": "https://files.pythonhosted.org/packages/3d/3b/50c149eb5f0821d529cb80d9afa25ede11d93cc5d726c75b6540e040dbfc/universal_ink_library-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4e03dd988b75d666e94b48afd6b4a7a9afb55ec0f219fc37c7a8061190397a73",
          "md5": "fa697f736279dfeba59ba634dfecf3b8",
          "sha256": "2000daa5c4b0f4ace0d44a07b6ab8c9d9a2896987e5a8fd049833679ccf9c1f0"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fa697f736279dfeba59ba634dfecf3b8",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134597,
        "upload_time": "2021-08-20T10:15:42",
        "upload_time_iso_8601": "2021-08-20T10:15:42.190893Z",
        "url": "https://files.pythonhosted.org/packages/4e/03/dd988b75d666e94b48afd6b4a7a9afb55ec0f219fc37c7a8061190397a73/universal_ink_library-1.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0432eb449ab489bce2c362ba44d67a4175754eb4474afcc4d2cf8a9e7f31ba0e",
          "md5": "0d2c2539315af1dbd152102fc0a7d9b0",
          "sha256": "c47b26ea190fadefb44fac9092a89751b4931828e3aced4a129d0f07d59b95e9"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0d2c2539315af1dbd152102fc0a7d9b0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3541658,
        "upload_time": "2021-08-20T10:15:46",
        "upload_time_iso_8601": "2021-08-20T10:15:46.036705Z",
        "url": "https://files.pythonhosted.org/packages/04/32/eb449ab489bce2c362ba44d67a4175754eb4474afcc4d2cf8a9e7f31ba0e/universal_ink_library-1.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e094ccb11383d543ac5b75bd9c19d85c76c032553239b570f8bcdbc856e8ca1a",
          "md5": "0229821f9f1bc457bb8a123b1ac74645",
          "sha256": "472cbfda7e9d345fc78f69c05e0b2f3c2a39e25fc7c3c885faa1c9504cd6f63e"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0229821f9f1bc457bb8a123b1ac74645",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134615,
        "upload_time": "2022-01-26T17:04:09",
        "upload_time_iso_8601": "2022-01-26T17:04:09.957380Z",
        "url": "https://files.pythonhosted.org/packages/e0/94/ccb11383d543ac5b75bd9c19d85c76c032553239b570f8bcdbc856e8ca1a/universal_ink_library-1.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ed5cc433f111d283fca84b65bc9fc7d5726a9335767f4a98d8e589e3881bb943",
          "md5": "f9c98b161be1edf9ced1ef65dd3911f7",
          "sha256": "affe47a87f396575fd53c74a35939d7762511ff0ffb6fdefd1b48c2016f831de"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "f9c98b161be1edf9ced1ef65dd3911f7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3541994,
        "upload_time": "2022-01-26T17:04:13",
        "upload_time_iso_8601": "2022-01-26T17:04:13.117985Z",
        "url": "https://files.pythonhosted.org/packages/ed/5c/c433f111d283fca84b65bc9fc7d5726a9335767f4a98d8e589e3881bb943/universal_ink_library-1.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6f53e9e6952cc497b98e96cacdd5c1f2edf94812cafcaf92c7c62d38971ccd68",
          "md5": "a1788e084c9c11e2ca2fda8c232e9719",
          "sha256": "bfaedabb48c4f3a24c9dbfaf9d83168833f71e5d56fb7ba10b144677a7a941e7"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a1788e084c9c11e2ca2fda8c232e9719",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134682,
        "upload_time": "2022-04-06T19:48:24",
        "upload_time_iso_8601": "2022-04-06T19:48:24.450225Z",
        "url": "https://files.pythonhosted.org/packages/6f/53/e9e6952cc497b98e96cacdd5c1f2edf94812cafcaf92c7c62d38971ccd68/universal_ink_library-1.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1e9afdfe60587cfd2493c1e57944ddc3097fe8a0efe7d37b16d37eaaf399d939",
          "md5": "d4931e2835f59a33a59bff10cbc29392",
          "sha256": "b95a36c86e46150509e6c69c1280b9db0870a9c8a678f471b2983928396e61ef"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "d4931e2835f59a33a59bff10cbc29392",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3580488,
        "upload_time": "2022-04-06T19:48:26",
        "upload_time_iso_8601": "2022-04-06T19:48:26.733782Z",
        "url": "https://files.pythonhosted.org/packages/1e/9a/fdfe60587cfd2493c1e57944ddc3097fe8a0efe7d37b16d37eaaf399d939/universal_ink_library-1.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6f6db99c29ae696ebd3eac5557b2cbdbe78031dc6035a4fdbbc0a19189c55497",
          "md5": "f5d790e90b0938b5f281efe4bd926f36",
          "sha256": "d4b99bce5982115480e496508f62286b77769d921b32f590e9626a140a324f7d"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f5d790e90b0938b5f281efe4bd926f36",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134685,
        "upload_time": "2022-10-07T06:56:31",
        "upload_time_iso_8601": "2022-10-07T06:56:31.909058Z",
        "url": "https://files.pythonhosted.org/packages/6f/6d/b99c29ae696ebd3eac5557b2cbdbe78031dc6035a4fdbbc0a19189c55497/universal_ink_library-1.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "610abe2d9ba143d8803922bb9ddef347865eb437978373f436c465a274e14a59",
          "md5": "46d55c3b8c9aead3ea6b80f75a3548ea",
          "sha256": "d57cb88640edd8abbf9c9202a303a63a7952931371f1fc1a51503896ab62ff64"
        },
        "downloads": -1,
        "filename": "universal_ink_library-1.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "46d55c3b8c9aead3ea6b80f75a3548ea",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3580515,
        "upload_time": "2022-10-07T06:56:34",
        "upload_time_iso_8601": "2022-10-07T06:56:34.509904Z",
        "url": "https://files.pythonhosted.org/packages/61/0a/be2d9ba143d8803922bb9ddef347865eb437978373f436c465a274e14a59/universal_ink_library-1.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6f6db99c29ae696ebd3eac5557b2cbdbe78031dc6035a4fdbbc0a19189c55497",
        "md5": "f5d790e90b0938b5f281efe4bd926f36",
        "sha256": "d4b99bce5982115480e496508f62286b77769d921b32f590e9626a140a324f7d"
      },
      "downloads": -1,
      "filename": "universal_ink_library-1.0.6-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "f5d790e90b0938b5f281efe4bd926f36",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 134685,
      "upload_time": "2022-10-07T06:56:31",
      "upload_time_iso_8601": "2022-10-07T06:56:31.909058Z",
      "url": "https://files.pythonhosted.org/packages/6f/6d/b99c29ae696ebd3eac5557b2cbdbe78031dc6035a4fdbbc0a19189c55497/universal_ink_library-1.0.6-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "610abe2d9ba143d8803922bb9ddef347865eb437978373f436c465a274e14a59",
        "md5": "46d55c3b8c9aead3ea6b80f75a3548ea",
        "sha256": "d57cb88640edd8abbf9c9202a303a63a7952931371f1fc1a51503896ab62ff64"
      },
      "downloads": -1,
      "filename": "universal_ink_library-1.0.6.tar.gz",
      "has_sig": false,
      "md5_digest": "46d55c3b8c9aead3ea6b80f75a3548ea",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 3580515,
      "upload_time": "2022-10-07T06:56:34",
      "upload_time_iso_8601": "2022-10-07T06:56:34.509904Z",
      "url": "https://files.pythonhosted.org/packages/61/0a/be2d9ba143d8803922bb9ddef347865eb437978373f436c465a274e14a59/universal_ink_library-1.0.6.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}