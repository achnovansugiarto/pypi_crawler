{
  "info": {
    "author": "Hofheinz group",
    "author_email": "florian.blanchet@supoptique.org",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Scientific/Engineering :: Physics"
    ],
    "description": "## Introduction\n\nMeaVis is a python framework intended to define how **Mea**surements have to\nbe run and a programming interface to **Vis**ualise resulting datasets.\n\nSee more details at [ReadTheDocs.io](https://meavis.readthedocs.io/en/latest/).\n\n### Basic example\n\n#### General configuration of intruments\n\nLet's assume two basic drivers as follow:\n\n```python\nimport vxi11\n\n\nclass AgilentB596X(vxi11.Instrument):\n    def __init__(self, host):\n        super().__init__(host=host)\n\n        self.channel = None\n        self.mode = None\n\n    def conf():\n        if self.channel and self.mode:\n            self.write(\":SOUR{}:FUNC:MODE {}\".format(self.channel, self.mode))\n\n    def output(self, value):\n        self.conf()\n        if self.channel:\n            self.write(\n                \":OUTP{} {}\".format(self.channel, \"ON\" if value else \"OFF\")\n            )\n\n    def set_channel(self, channel):\n        self.channel = channel\n        self.write(\":SOUR{}:FUNC:SHAP DC\".format(self.channel))\n        self.conf()\n\n    def set_mode(self, mode):\n        self.mode = mode\n        self.conf()\n\n    def set_value(self, value):\n        self.write(\":SOUR{}:{} {}\".format(self.channel, self.mode, value))\n\n\nclass KeySight344XX(vxi11.Instrument):\n    def __init__(self, host):\n        super().__init__(host=host)\n\n        self.write(\"*CLS\")\n        self.write(\"*RST\")\n\n        self.write(\"TRIG:SOUR IMM\")\n\n        self.write(\"CALC:FUNC AVER\")\n        self.write(\"CALC:STAT ON\")\n\n        self.ACorDC = None\n        self.mode = None\n\n    def calc_average(self):\n        self.write(\"*CALC:AVER:AVER\")\n        return float(self.read())\n\n    def conf(self):\n        if self.ACorDC and self.mode:\n            self.write(\"CONF:{}:{}\".format(self.mode, self.ACorDC))\n\n    def conf_ACorDC(self, ACorDC):\n        self.ACorDC = ACorDC\n        self.conf()\n\n    def conf_mode(self, mode):\n        self.mode = mode\n        self.conf()\n\n    def count(self, value):\n        self.write(\"SAMP:COUN {}\".format(value))\n\n    def initiate(self):\n        self.write(\"INIT\")\n\n    def opc(self):\n        self.write(\"*OPC\")\n\n    def set_aperture(self, value):\n        self.write(\"{}:APER {}\".format(self.mode, value))\n```\n\nAs you see, this driver is very close to a one-to-one correpondance between\nthe SPCI commands and the methods. Of course, methods can be more complexe,\nhowever a simplest driver as possible allow more flexiblity.\n\nThen classes specific to MeaVis have to be written to decribe how to use this\ndriver:\n* *Drivers*: Front panel instrument.\n* *MeaVis classes*: How an experimentalist use the front panel.\n\n```python\nimport drivers\n\nimport meavis.tags\n\n\n@meavis.tags.initialiser(\"power_source.current_source\", mode=\"CURR\")\n@meavis.tags.initialiser(\"power_source.voltage_source\", mode=\"VOLT\")\nclass InitialiserB596X:\n    def __init__(self, mode):\n        self.mode = mode\n\n    def initialise(self, handler, channel):\n        handler_channel = drivers.AgilentB596X(**handler)\n\n        handler_channel.set_channel(channel)\n        handler_channel.set_mode(self.mode)\n        handler_channel.output(True)\n\n        return handler_channel\n\n\n@meavis.tags.initialiser(\"multimeter.ac_current_meter\")\n@meavis.tags.kwargs(mode=\"CURR\", ACorDC=\"AC\")\n@meavis.tags.initialiser(\"multimeter.ac_volt_meter\")\n@meavis.tags.kwargs(mode=\"VOLT\", ACorDC=\"AC\")\n@meavis.tags.initialiser(\"multimeter.dc_current_meter\")\n@meavis.tags.kwargs(mode=\"CURR\", ACorDC=\"DC\")\n@meavis.tags.initialiser(\"multimeter.dc_volt_meter\")\n@meavis.tags.kwargs(mode=\"VOLT\", ACorDC=\"DC\")\nclass Initialiser344XX:\n    def __init__(self, mode, ACorDC):\n        self.ACorDC = ACorDC\n        self.mode = mode\n\n    def initialise(self, handler, channel):\n        handler_channel = drivers.KeySight344XX(**handler)\n\n        handler_channel.conf_mode(self.mode)\n        handler_channel.conf_ACorDC(True)\n\n        return handler_channel\n\n\n@meavis.tags.parameter(\"power_source.current_source.current\")\n@meavis.tags.attributes(unit=\"A\", delay=0.1)\n@meavis.tags.parameter(\"power_source.voltage_source.voltage\")\n@meavis.tags.attributes(unit=\"V\", delay=0.1)\nclass SourceValue:\n    def __init__(self, data):\n        self.data = data\n\n    def apply(self, handler, value):\n        handler.set_value(value)\n\n\n@meavis.tags.parameter(\"multimeter.~.aperture\")\n@meavis.tags.attributes(unit=\"s\")\nclass DMMAperture:\n    def __init__(self, data):\n        self.data = data\n\n    def apply(self, handler, value):\n        handler.set_aperture(value)\n\n\n@meavis.tags.parameter(\"multimeter.~.average_count\")\nclass DMMCount:\n    def __init__(self, data):\n        self.data = data\n\n    def apply(self, handler, value):\n        handler.count(value)\n\n\n@meavis.tags.measurement(\"multimeter.ac_current_meter|dc_current_meter.current\")\n@meavis.tags.measurement(\"multimeter.ac_volt_meter|dc_volt_meter.voltage\")\nclass DMMAverage:\n    def trigger(self, handler):\n        handler.initiate()\n\n    def wait(self, handler):\n        handler.opc()\n        handler.calc_average()\n```\n\nThe elements mapped after *kwargs* will be used to initialise the\ncorresponding instrument when required. For exemple, if a source is used as a\nvoltage source, the statement \n`handler = meavis_user.InitialiserB596X(mode=\"VOLT\").intialise(/* */)` will be\nexecuted.\n\nThis file have to be loaded as follow:\n\n```python\nmeavis.instruments.inject(meavis_user._meavis_instruments)\n```\n\nNote that it cannot be loaded multiple time, otherwise name collisions will\nhappen.\n\nUp to now the configuration is independant of what we want to measure: it only\ndescribes how to use instruments, but not how they are connect or what we want\nto do.\n\n#### Experiment-specific configuration of intruments\n\nFirst we describe how instruments are wired and for which purpose with a YAML\nfile:\n\n```yaml\njunction_bias:\n  instrument: power_source\n  usage: voltage_source\n  kwargs:\n    addr: 192.168.0.0\n  attributes:\n    channel: 1\njunction_current:\n  instrument: multimeter\n  usage: dc_current_meter\n  kwargs:\n    host: 192.168.0.1\n  attributes:\n    channel: 1\njunction_voltage:\n  instrument: multimeter\n  usage: dc_volt_meter\n  kwargs:\n    host: 192.168.0.1\n  attributes:\n    channel: 2\n```\n\nThe elements mapped after *kwargs* will be used to construct the corresponding\ninstrument when required. For exemple, the multimeter to measure the junction\nvoltage is constructed with the statement:\n`handler = meavis_user.ConstructorEthernet(host=\"192.168.0.1\").create()` when\nrequired. Morevoer the attribute `channel: 2` is used for the initialisation \n`handler = meavis_user.InitialiserB596X(/* */).intialise(/* */, channel=2)`.\n\nThis file have to be loaded as follow:\n\n```python\nwith open(\"instances.yaml\") as file:\n    meavis.instruments.register(yaml.safe_load(file))\n```\n\nNote that it cannot be loaded multiple time, otherwise name collisions will\nhappen. After this step, parameters and measurements can be accessed as \nfollow:\n\n```python\nmeavis.parameters.junction_current.aperture([10e-3])\nmeavis.parameters.junction_current.average_count([100])\n\nmeavis.parameters.junction_voltage.aperture([100e-3])\nmeavis.parameters.junction_voltage.average_count([10])\n```\n\nAvaibled parameters and measurements are displayed in the log output:\n\n```\nINFO --  Register power_source constructor [90e97748d6ea9cbb434602eb177a91c685701667] {host: 192.168.0.0}.\nINFO --  Register voltage_source initialiser {mode: VOLT} for junction_bias.\nINFO --  Register voltage as parameter named junction_bias.voltage.\nINFO --  Register multimeter constructor [1ca226d3ca09e4167fbbfa3bd218a8323d76e12f] {host: 192.168.0.1}.\nINFO --  Register dc_current_meter initialiser {mode: CURR, ACorDC: DC} for junction_current.\nINFO --  Register aperture as parameter named junction_current.aperture.\nINFO --  Register average_count as parameter named junction_current.average_count.\nINFO --  Register current as measurement named junction_current.current.\nINFO --  Register dc_volt_meter initialiser {mode: VOLT, ACorDC: DC} for junction_voltage.\nINFO --  Register aperture as parameter named junction_voltage.aperture.\nINFO --  Register average_count as parameter named junction_voltage.average_count.\nINFO --  Register voltage as measurement named junction_voltage.voltage.\nINFO --  Add completer group for junction_bias : {junction_bias.voltage}.\nINFO --  Add completer group for junction_current : {junction_current.average_count, junction_current.aperture}.\nINFO --  Add completer group for junction_voltage : {junction_voltage.aperture, junction_voltage.average_count}.\n```\n\nAnd finally the measurement can be described and processed as follow:\n\n```python\nmeasurement_loop = meavis.loop.LoopEngine(\n    yaml.safe_load(\n        \"\"\"\nparameters:\n    - junction_bias.voltage\nmeasurements:\n    - junction_current.current\n    - junction_voltage.voltage\nname: iv_dc_4probes\n\"\"\"\n)).create(\n    meavis.parameters.junction_bias.voltage(numpy.linspace(-1e-3, 1e-3, 401)),\n    meavis.measurements.junction_current.current(),\n    meavis.measurements.junction_voltage.voltage(),\n)\nmeasurement_loop.trigger(None)\nmeasurement_loop.wait(None)\n```\n\nIn the log output, instruments are created and intialised when required:\n\n```\nINFO --  Complete parameters with [junction_current.average_count, junction_current.aperture]\nINFO --  Complete parameters with [junction_voltage.aperture, junction_voltage.average_count]\nINFO --  Create handler of multimeter.constructor [1ca226d3ca09e4167fbbfa3bd218a8323d76e12f] with {host: 192.168.0.1}.\nINFO --  Initialise channel 2 on handler of multimeter.dc_volt_meter.initialiser with {mode: VOLT, ACorDC: DC}.\nINFO --  Set junction_voltage.aperture to 0.1 s.\nINFO --  Set junction_voltage.average_count to 10.\nINFO --  Initialise channel 1 on handler of multimeter.dc_current_meter.initialiser with {mode: CURR, ACorDC: DC}.\nINFO --  Set junction_current.aperture to 0.01 s.\nINFO --  Set junction_current.average_count to 100.\nINFO --  Create handler of power_source.constructor [90e97748d6ea9cbb434602eb177a91c685701667] with {host: 192.168.0.0}.\nINFO --  Initialise channel 1 on handler of power_source.voltage_source.initialiser with {mode: VOLT}.\nINFO --  Set junction_bias.voltage to -0.001 V.\nINFO --  Trigger junction_current.current, waiting for data.\nINFO --  Trigger junction_voltage.voltage, waiting for data.\nINFO --  Set junction_bias.voltage to -0.000998 V.\nINFO --  Trigger junction_current.current, waiting for data.\nINFO --  Trigger junction_voltage.voltage, waiting for data.\n```",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://gitlab.com/hofheinz-group/meavis",
    "keywords": "",
    "license": "Apache Software License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "meavis",
    "package_url": "https://pypi.org/project/meavis/",
    "platform": "",
    "project_url": "https://pypi.org/project/meavis/",
    "project_urls": {
      "Bug Tracker": "https://gitlab.com/hofheinz-group/meavis/issues",
      "Documentation": "https://meavis.readthedocs.io",
      "Homepage": "https://gitlab.com/hofheinz-group/meavis"
    },
    "release_url": "https://pypi.org/project/meavis/0.2.2.dev2/",
    "requires_dist": null,
    "requires_python": "<4,>=3.5",
    "summary": "Measurement & Visualisation python framework.",
    "version": "0.2.2.dev2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8998741,
  "releases": {
    "0.2.1.dev0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bf5ecb6c2a33c94dd7bc028881dd43672e7868d9196c8ff0fd66c72d06ce6ab8",
          "md5": "58051b0e743fd1f942685e8c9d9a7e68",
          "sha256": "9f1b2198fca8b3e5c4a86dcac333b370fa0c189355c7dedde1bfd5db84546509"
        },
        "downloads": -1,
        "filename": "meavis-0.2.1.dev0.tar.gz",
        "has_sig": false,
        "md5_digest": "58051b0e743fd1f942685e8c9d9a7e68",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "<4,>=3.5",
        "size": 28098,
        "upload_time": "2020-04-10T02:21:19",
        "upload_time_iso_8601": "2020-04-10T02:21:19.116657Z",
        "url": "https://files.pythonhosted.org/packages/bf/5e/cb6c2a33c94dd7bc028881dd43672e7868d9196c8ff0fd66c72d06ce6ab8/meavis-0.2.1.dev0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2.dev0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b60d4dd11214dbf3116b1298fcc2e37ce1d88cc1aff1dec8d0111d5905296565",
          "md5": "27d9bb3c5145d11298b4c763ed26d764",
          "sha256": "1a3305da426c372201488d54b76320f5583b6fe07bd82491789ac1adc5c5e51e"
        },
        "downloads": -1,
        "filename": "meavis-0.2.2.dev0.tar.gz",
        "has_sig": false,
        "md5_digest": "27d9bb3c5145d11298b4c763ed26d764",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "<4,>=3.5",
        "size": 38825,
        "upload_time": "2020-04-28T17:39:00",
        "upload_time_iso_8601": "2020-04-28T17:39:00.878308Z",
        "url": "https://files.pythonhosted.org/packages/b6/0d/4dd11214dbf3116b1298fcc2e37ce1d88cc1aff1dec8d0111d5905296565/meavis-0.2.2.dev0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2.dev2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fab1ab4d99d887ffa505bea35b0dfbb735cfa564d32c6cd66c301b6d8762b9d2",
          "md5": "d1f24ba9fccd3b2e9615c542b6738828",
          "sha256": "4aff9e805fd176211a9459d92c71efbceb057e14b64154965fbdfc359a3321bf"
        },
        "downloads": -1,
        "filename": "meavis-0.2.2.dev2.tar.gz",
        "has_sig": false,
        "md5_digest": "d1f24ba9fccd3b2e9615c542b6738828",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "<4,>=3.5",
        "size": 37239,
        "upload_time": "2020-12-28T13:53:14",
        "upload_time_iso_8601": "2020-12-28T13:53:14.284508Z",
        "url": "https://files.pythonhosted.org/packages/fa/b1/ab4d99d887ffa505bea35b0dfbb735cfa564d32c6cd66c301b6d8762b9d2/meavis-0.2.2.dev2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fab1ab4d99d887ffa505bea35b0dfbb735cfa564d32c6cd66c301b6d8762b9d2",
        "md5": "d1f24ba9fccd3b2e9615c542b6738828",
        "sha256": "4aff9e805fd176211a9459d92c71efbceb057e14b64154965fbdfc359a3321bf"
      },
      "downloads": -1,
      "filename": "meavis-0.2.2.dev2.tar.gz",
      "has_sig": false,
      "md5_digest": "d1f24ba9fccd3b2e9615c542b6738828",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": "<4,>=3.5",
      "size": 37239,
      "upload_time": "2020-12-28T13:53:14",
      "upload_time_iso_8601": "2020-12-28T13:53:14.284508Z",
      "url": "https://files.pythonhosted.org/packages/fa/b1/ab4d99d887ffa505bea35b0dfbb735cfa564d32c6cd66c301b6d8762b9d2/meavis-0.2.2.dev2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}