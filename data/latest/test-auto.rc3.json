{
  "info": {
    "author": "卢家涛",
    "author_email": "522430860@qq.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: Chinese (Simplified)",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7",
      "Topic :: Software Development",
      "Topic :: Software Development :: Testing",
      "Topic :: Software Development :: Testing :: Unit"
    ],
    "description": "&emsp;&emsp;自动化测试框架，支持多线程和参数化测试，且自带HTML测试报告！\n\n# 主要特性\n\n* 支持IDE和命令行方式执行测试用例。\n* 支持多线程测试。\n* 支持参数化测试。\n* 自带HTML测试报告。\n* 支持设置终止策略、重试策略和超时时间。\n* 易扩展，开发者可自定义测试任务、测试记录器和测试执行器等。\n\n# 安装\n\n## 在线安装\n\n&emsp;&emsp;执行以下命令即可安装testauto的最新版本：\n\n```\npip install test-auto\n```\n\n&emsp;&emsp;如需安装指定版本，比如安装1.0.0版本，可执行以下命令：\n\n```\npip install test-auto==1.0.0\n```\n\n## 离线安装\n\n&emsp;&emsp;如果已经下载了test_auto-X.X.X-py3-none-any.whl或test-auto-X.X.X.tar.gz安装文件，那么可以使用离线安装方式安装testauto。  \n&emsp;&emsp;你可以在PyPI的以下地址找到安装文件：\n\n```\nhttps://pypi.org/project/test-auto/#files\n```\n\n&emsp;&emsp;或者GitHub的以下地址找到安装文件：\n\n```\nhttps://github.com/lujiatao2/testauto/releases\n```\n\n&emsp;&emsp;若使用test_auto-X.X.X-py3-none-any.whl安装文件，执行以下命令即可安装testauto：\n\n```\npip install path/to/test_auto-X.X.X-py3-none-any.whl\n```\n\n&emsp;&emsp;若使用test-auto-X.X.X.tar.gz安装文件，执行以下命令即可安装testauto：\n\n```\npip install path/to/test-auto-X.X.X.tar.gz\n```\n\n# 第一个测试用例\n\n&emsp;&emsp;来开始使用testauto编写第一个测试用例吧！\n\n```python\n# case_for_doc.py\nfrom testauto import main\nfrom testauto.case import TestCase\n\n\nclass TestCase01(TestCase):\n\n    def test_case(self):\n        ...\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n&emsp;&emsp;执行结果如下：\n\n```\n======================================================================================================================================================\n执行总数：1\n开始时间：2021-01-24 14:48:21    结束时间：2021-01-24 14:48:21    执行耗时：00时00分00秒\n------------------------------------------------------------------------------------------------------------------------------------------------------\n执行结果      数量        百分比（%）\n通过        1         100.0\n失败        0         0.0\n阻塞        0         0.0\n超时        0         0.0\n未执行       0         0.0\n======================================================================================================================================================\n\n```\n\n# 测试用例\n\n## 基本用法\n\n&emsp;&emsp;测试用例使用一个Python类来表示，且该类必须直接或间接继承至TestCase抽象基类才能被testauto识别为测试用例。\n\n```python\nclass TestCase02(TestCase):\n\n    def test_case(self):\n        print(self.__class__.__name__)\n\n\nclass TestCase03(TestCase02):\n\n    def test_case(self):\n        print(self.__class__.__name__)\n\n\nclass TestCase04:\n\n    def test_case(self):\n        print(self.__class__.__name__)\n\n```\n\n&emsp;&emsp;执行以上代码后，可以看到只有TestCase02和TestCase03的类名被打印了。\n\n## 初始化和清理操作\n\n&emsp;&emsp;测试用例支持添加初始化和清理操作，只需重写setup()和teardown()方法即可。\n\n```python\nclass TestCase05(TestCase):\n\n    def setup(self):\n        print('这是初始化操作')\n\n    def test_case(self):\n        print('这是测试用例')\n\n    def teardown(self):\n        print('这是清理操作')\n\n```\n\n&emsp;&emsp;执行结果如下：\n\n```\n这是初始化操作\n这是测试用例\n这是清理操作\n```\n\n## 测试用例属性\n\n* project：测试工程名称，默认为：Default Project。\n* module：测试模块名称，默认为：Default Module。\n* title：测试用例标题，默认为：Default Title。\n* description：测试用例描述，默认：无。\n* priority：测试用例优先级，默认：P0。\n* designer：测试用例设计者，默认：Anonymous。\n* version：测试用例版本号，默认：1.0.0。\n* completed：测试用例完成状态，默认：已完成。\n\n&emsp;&emsp;以上属性都可以修改，只需在测试用例中显式声明即可。\n\n```python\nclass TestCase06(TestCase):\n    title = '登录成功'\n    priority = TestCasePriority.P1\n    completed = False\n\n    def test_case(self):\n        ...\n\n```\n\n&emsp;&emsp;从以上代码可以看出：测试用例优先级使用枚举表示，而不是字符串；而测试用例完成状态是一个布尔类型。\n\n# 测试任务\n\n## 基本用法\n\n&emsp;&emsp;testauto的执行单元是测试任务，而不是测试用例，即使只有一个测试用例，testauto也会自动将该测试用例转换为测试任务。  \n&emsp;&emsp;为什么需要测试任务？比如一个测试项目有1000个测试用例，但对于不同的测试策略（冒烟测试？回归测试？），需要执行的测试用例显然是不同的，因此我们可以创建不同的测试任务。\n\n```python\n# task_for_doc.py\nfrom testauto.task import DefaultTestTask\n\nfrom testauto_test.case_for_doc import *\n\n# 冒烟测试用例对应的测试任务\ntest_task_01 = DefaultTestTask()\ntest_task_01.add_test_cases(TestCase01(), TestCase02())\n\n# 回归测试用例对应的测试任务\ntest_task_02 = DefaultTestTask()\ntest_task_02.add_test_cases(TestCase01(), TestCase03())\n\nif __name__ == '__main__':\n    main(test_task=test_task_01)  # 执行冒烟测试\n    main(test_task=test_task_02)  # 执行回归测试\n\n```\n\n&emsp;&emsp;以上代码中的测试用例是上一节case_for_doc.py中的测试用例。\n\n## 添加测试用例\n\n&emsp;&emsp;除了上一小节介绍的add_test_cases()方法外，还支持多种添加测试用例方法，以下为完整列表：\n\n* add_test_case()：添加单个测试用例。\n* add_test_cases()：添加多个测试用例。\n* add_test_cases_by_classes()：通过类名增加测试用例，格式：path.to.module.Class\n* add_test_cases_by_modules()：通过模块名增加测试用例，格式：path.to.module\n* add_test_cases_by_files()：通过文件增加测试用例，格式：  \n  Windows：E:\\\\path\\\\to\\\\dictionary\\\\module.py  \n  macOS/Linux：/path/to/dictionary/module.py\n* add_test_cases_by_paths()：通过路径增加测试用例，格式：  \n  Windows：E:\\\\path\\\\to\\\\dictionary  \n  macOS/Linux：/path/to/dictionary\n\n&emsp;&emsp;以下演示add_test_cases_by_files()方法的使用：\n\n```python\ntest_task_03 = DefaultTestTask()\ntest_task_03.add_test_cases_by_files(\n    r'E:\\Software_Testing\\Software Development\\Python\\PycharmProjects\\testauto\\testauto_test\\case_for_doc.py')\n\nif __name__ == '__main__':\n    main(test_task=test_task_03)\n\n```\n\n&emsp;&emsp;除了添加，也可以删除测试用例，对应的方法是remove_test_case()和remove_test_cases()。\n\n## 过滤器\n\n&emsp;&emsp;过滤器是一个抽象类TestCaseFilter，它的作用是过滤掉不满足要求的测试用例。testauto内置了2个过滤器：\n\n* TestCaseCompletedShouldBe：根据测试用例完成状态来过滤测试用例。\n* TestCasePriorityShouldBe：根据测试用例优先级来过滤测试用例。\n\n&emsp;&emsp;比如我们只想执行P0优先级的测试用例，可以这么做：\n\n```python\ntest_task_03 = DefaultTestTask()\ntest_task_03.add_test_cases_by_files(\n    r'E:\\Software_Testing\\Software Development\\Python\\PycharmProjects\\testauto\\testauto_test\\case_for_doc.py')\ntest_task_03.add_filter(TestCasePriorityShouldBe(OperationMethod.EQUAL, TestCasePriority.P0))\ntest_task_03.filter_test_cases()\n\nif __name__ == '__main__':\n    main(test_task=test_task_03)\n\n```\n\n&emsp;&emsp;从以上代码可以看出：在添加了过滤器后，要真正执行过滤操作，需要调用filter_test_cases()方法。  \n&emsp;&emsp;除了添加，也可以删除过滤器，对应的方法是remove_test_filter()和remove_test_filters()。  \n&emsp;&emsp;另外，DefaultTestTask默认包含TestCaseCompletedShouldBe过滤器，且过滤条件为OperationMethod.EQUAL和True，即测试用例完成状态等于True的测试用例才会被保留。当然你可以调用clear_test_task()\n方法来阻止该行为，该方法会清空测试任务中的所有测试用例和过滤器。\n\n# 命令行执行\n\n&emsp;&emsp;testauto提供了命令行执行的功能，执行以下命令获取帮助信息：\n\n```\npython -m testauto -h\n```\n\n&emsp;&emsp;执行结果如下：\n\n```\nusage: testauto [-h] [-m [TEST_MODULES [TEST_MODULES ...]]] [-t TEST_TASK]\n                [-r TEST_RECORDER] [-rn TEST_RUNNER] [-s STOP_STRATEGY]\n                [-rt RETRY_STRATEGY] [-to TIMEOUT] [-p PARALLEL]\n\noptional arguments:\n  -h, --help            显示帮助信息。\n  -m [TEST_MODULES [TEST_MODULES ...]], --test-modules [TEST_MODULES [TEST_MODULES ...]]\n                        测试模块。示例：-m E:\\path\\to\\dictionary\\module.py\n  -t TEST_TASK, --test-task TEST_TASK\n                        测试任务。示例：-t path.to.module.callable，其中callable为返回TestTask对象的可调用对象。\n  -r TEST_RECORDER, --test-recorder TEST_RECORDER\n                        测试记录器。示例：-r path.to.module.callable，其中callable为返回TestRecorder对象的可调用对象。\n  -rn TEST_RUNNER, --test-runner TEST_RUNNER\n                        测试执行器。示例：-rn path.to.module.callable，其中callable为返回TestRunner对象的可调用对象。\n  -s STOP_STRATEGY, --stop-strategy STOP_STRATEGY\n                        终止策略。参数取值：0-全部完成（默认）/1-第一个未执行成功/2-第一个P0测试用例未执行成功\n  -rt RETRY_STRATEGY, --retry-strategy RETRY_STRATEGY\n                        重试策略。参数取值：0-不重试（默认）/1-立即重新执行测试用例/2-最后重新执行测试用例\n  -to TIMEOUT, --timeout TIMEOUT\n                        超时时间（单位秒）。参数取值：正整数\n  -p PARALLEL, --parallel PARALLEL\n                        并行执行数量。参数取值：正整数\n\n```\n\n&emsp;&emsp;以上帮助信息已经把使用方法说明得很清楚了，以下演示如何使用命令行执行测试任务，新增测试任务test_task_04：\n\n```python\ndef test_task_04():\n    test_task = DefaultTestTask()\n    test_task.add_test_cases(TestCase01(), TestCase02())\n    return test_task\n\n```\n\n&emsp;&emsp;注意test_task_04要定义为可调用对象，这里定义为了一个函数。  \n&emsp;&emsp;执行以下命令可运行test_task_04中的测试用例：\n\n```\npython -m testauto -t testauto_test.test_task.test_task_04\n```\n\n&emsp;&emsp;另外，IDE和命令行均支持直接传入测试模块，但此时若同时传入了测试任务，testauto会忽略测试任务，而使用传入的测试模块自动创建测试任务。\n\n# 多线程测试\n\n&emsp;&emsp;testauto支持多线程测试，使用方法很简单，通过main()方法传入parallel参数或命令行传入-p/--parallel参数即可。  \n&emsp;&emsp;为了演示多线程测试带来的效率上优势，我们首先在case_for_doc.py中新增以下两个测试用例：\n\n```python\nclass TestCase07(TestCase):\n\n    def test_case(self):\n        sleep(5)\n\n\nclass TestCase08(TestCase):\n\n    def test_case(self):\n        sleep(5)\n\n```\n\n&emsp;&emsp;然后在task_for_doc.py中新增test_task_05：\n\n```python\ntest_task_05 = DefaultTestTask()\ntest_task_05.add_test_cases(TestCase07(), TestCase08())\n\nif __name__ == '__main__':\n    main(test_task=test_task_05)\n\n```\n\n&emsp;&emsp;如果直接执行test_task_05，那么测试耗时是10秒，这时我们加入parallel参数，并将参数值设置为2：\n\n```python\nif __name__ == '__main__':\n    main(test_task=test_task_05, parallel=2)\n\n```\n\n&emsp;&emsp;重新执行test_task_05，可以看到耗时为5秒。  \n&emsp;&emsp;需要注意的是，多线程执行测试用例时，需考虑线程安全性，如果多个测试用例同时对一个资源进行修改，会造成意想不到的结果。\n\n# 参数化测试\n\n&emsp;&emsp;testauto使用@parameterized装饰器提供对参数化的支持。  \n&emsp;&emsp;首先在case_for_doc.py中新增以下测试用例：\n\n```python\n@parameterized(\n    ('username', 'password'),\n    [\n        ('zhangsan', 'zhangsan123456'),\n        ('lisi', 'lisi123456')\n    ]\n)\nclass TestCase09(TestCase):\n\n    def test_case(self):\n        username = self.get_param_value('username')\n        password = self.get_param_value('password')\n        print(f'我的用户名是：{username}，我的密码是：{password}！')\n\n```\n\n&emsp;&emsp;@parameterized装饰器的第一个参数是一个字符串类型的元组，每个字符串代表一个参数，可传递多个参数；第二个参数是一个元组组成的列表，每个元组代表一组参数，元组中参数的个数必须与参数数量一致。然后在测试用例中通过get_param_value()\n方法来获取参数。  \n&emsp;&emsp;在test_task.py中新增test_task_06：\n\n```python\ntest_task_06 = DefaultTestTask()\ntest_task_06.add_test_cases_by_classes('testauto_test.case_for_doc.TestCase09')\n\nif __name__ == '__main__':\n    main(test_task=test_task_06)\n\n```\n\n&emsp;&emsp;注意test_task_06添加测试用例的方式不是直接传递测试用例对象，因为参数化测试时，需要根据参数的数量来动态创建测试用例对象，这个过程是testauto自动完成的。  \n&emsp;&emsp;执行结果如下：\n\n```\n我的用户名是：zhangsan，我的密码是：zhangsan123456！\n我的用户名是：lisi，我的密码是：lisi123456！\n```\n\n# 测试报告\n\n&emsp;&emsp;testauto有5种测试结果：\n\n* 通过：未引发任何异常。\n* 失败：引发AssertionError异常。\n* 超时：引发TimeoutError异常。\n* 阻塞：引发其它异常（非AssertionError和TimeoutError异常）。\n* 未执行：未执行。\n\n&emsp;&emsp;testauto内置的测试记录器DefaultTestRecorder会生成HTML测试报告。  \n&emsp;&emsp;为了查看不同测试结果在测试报告中的显示效果，在case_for_doc.py中新增以下3个测试用例：\n\n```python\nclass TestCase010(TestCase):\n    module = 'TestCase010模块'\n    title = 'TestCase010标题'\n\n    def test_case(self):\n        sleep(1)\n\n\nclass TestCase11(TestCase):\n    module = 'TestCase11模块'\n    title = 'TestCase11标题'\n\n    def test_case(self):\n        sleep(2)\n        assert False\n\n\nclass TestCase12(TestCase):\n    module = 'TestCase12模块'\n    title = 'TestCase12标题'\n\n    def test_case(self):\n        sleep(3)\n        raise RuntimeError('我是TestCase12，这是我抛的异常！')\n\n```\n\n&emsp;&emsp;然后直接执行test_task_03，执行后会生成test-report.html文件，该文件即HTML测试报告。效果如下所示：\n![HTML测试报告01](https://raw.githubusercontent.com/lujiatao2/testauto/master/testauto_test/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A01.png)\n&emsp;&emsp;未执行成功的测试用例，可点击查看详情，效果如下所示：\n![HTML测试报告02](https://raw.githubusercontent.com/lujiatao2/testauto/master/testauto_test/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A02.png)\n&emsp;&emsp;不同的测试结果在HTML测试报告中显示是不同的：\n\n* 通过：显示为绿色，不能点击详情查看。\n* 失败：显示为红色，能点击详情查看。\n* 阻塞：显示为黄色，能点击详情查看。\n* 超时：显示为灰色，能点击详情查看。\n* 未执行：显示为白色，不能点击详情查看。\n\n# 其它\n\n## 终止策略\n\n&emsp;&emsp;testauto支持3种终止策略：\n\n* ALL_COMPLETED：全部完成，默认。\n* FIRST_NOT_PASS：第一个未执行成功。\n* FIRST_P0_NOT_PASS：第一个P0测试用例未执行成功。\n\n&emsp;&emsp;终止策略使用StopStrategy枚举来设置：\n\n```python\nif __name__ == '__main__':\n    main(stop_strategy=StopStrategy.FIRST_NOT_PASS)\n\n```\n\n## 重试策略\n\n&emsp;&emsp;testauto支持3种重试策略：\n\n* NOT_RERUN：不重试，默认。\n* RERUN_NOW：立即重新执行测试用例，即：对当前未执行成功的测试用例，立即重新执行一次。\n* RERUN_LAST：最后重新执行测试用例，即：对全部未执行成功的测试用例，最后批量重新执行一次。\n\n&emsp;&emsp;重试策略使用RetryStrategy枚举来设置：\n\n```python\nif __name__ == '__main__':\n    main(retry_strategy=RetryStrategy.RERUN_NOW)\n\n```\n\n&emsp;&emsp;注意终止策略的优先级是大于重试策略的，比如同时设置了FIRST_NOT_PASS和RERUN_NOW，当测试用例执行失败时，testauto会立即终止后续测试用例的执行，而不会对当前测试用例进行重新执行。\n\n## 超时时间\n\n&emsp;&emsp;使用timeout参数可对单个测试用例设置超时时间：\n\n```python\nif __name__ == '__main__':\n    main(timeout=60)\n\n```\n\n&emsp;&emsp;以上代码将单个测试用例的执行超时时间设置为了60秒，默认为1小时（3600秒）。\n\n## 断言\n\n&emsp;&emsp;作为自动化测试框架，断言功能当然是不能少的，但testauto没有重复造轮子，而是直接使用Python自带的assert关键字来实现断言。比如TestCase11测试用例中断言的写法如下：\n\n```python\nclass TestCase11(TestCase):\n    module = 'TestCase11模块'\n    title = 'TestCase11标题'\n\n    def test_case(self):\n        sleep(2)\n        assert False\n\n```\n\n&emsp;&emsp;以上代码直接使用了assert关键字来断言。  \n&emsp;&emsp;但testauto也新增了2个断言函数作为补充：\n\n* assert_raise()：断言抛出指定异常。\n* assert_not_raise()：断言不抛出指定异常。\n\n&emsp;&emsp;以下为演示代码，可参考这几个测试用例的写法来使用以上断言函数：\n\n```python\nclass TestCase13(TestCase):\n    title = '抛出异常成功'\n\n    def test_case(self):\n        assert_raise(self._callable_target, RuntimeError)\n\n    def _callable_target(self):\n        raise RuntimeError('TestCase13的异常')\n\n\nclass TestCase14(TestCase):\n    title = '不抛出异常成功'\n\n    def test_case(self):\n        assert_not_raise(self._callable_target, ValueError)\n\n    def _callable_target(self):\n        raise RuntimeError('TestCase14的异常')\n\n\nclass TestCase15(TestCase):\n    title = '抛出异常失败'\n\n    def test_case(self):\n        assert_raise(self._callable_target, ValueError)\n\n    def _callable_target(self):\n        raise RuntimeError('TestCase15的异常')\n\n\nclass TestCase16(TestCase):\n    title = '不抛出异常失败'\n\n    def test_case(self):\n        assert_not_raise(self._callable_target, RuntimeError)\n\n    def _callable_target(self):\n        raise RuntimeError('TestCase16的异常')\n\n```\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/lujiatao2",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "test-auto",
    "package_url": "https://pypi.org/project/test-auto/",
    "platform": "",
    "project_url": "https://pypi.org/project/test-auto/",
    "project_urls": {
      "Changelog": "https://github.com/lujiatao2/testauto/blob/master/CHANGELOG.md",
      "Homepage": "https://github.com/lujiatao2",
      "Source": "https://github.com/lujiatao2/testauto"
    },
    "release_url": "https://pypi.org/project/test-auto/1.0.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "自动化测试框架，支持多线程和参数化测试，且自带HTML测试报告！",
    "version": "1.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10850721,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dde164c9ec3c614417479469012d1c47318697cee034987a494d265c99854945",
          "md5": "e8378ac8a7aaead37502a96f01f26804",
          "sha256": "0c04b8d44e5a39366cdd6f9fb5b2ad9e14b31e5dcaa4d1c6f65d58c1bfb4e977"
        },
        "downloads": -1,
        "filename": "test_auto-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e8378ac8a7aaead37502a96f01f26804",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21975,
        "upload_time": "2021-01-24T14:34:07",
        "upload_time_iso_8601": "2021-01-24T14:34:07.976499Z",
        "url": "https://files.pythonhosted.org/packages/dd/e1/64c9ec3c614417479469012d1c47318697cee034987a494d265c99854945/test_auto-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a4c13086ebf47d96b85a3319dc4c8895375b7a13f59973dcfc019ee76eed5cfa",
          "md5": "27b1979a4a775edbe580a7035188855a",
          "sha256": "b4a88eeee4a30683ea69bdbc8c7f9158f79ba3a3f3aa61e3c51c25a9b7702316"
        },
        "downloads": -1,
        "filename": "test-auto-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "27b1979a4a775edbe580a7035188855a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 213101,
        "upload_time": "2021-01-24T14:34:12",
        "upload_time_iso_8601": "2021-01-24T14:34:12.888337Z",
        "url": "https://files.pythonhosted.org/packages/a4/c1/3086ebf47d96b85a3319dc4c8895375b7a13f59973dcfc019ee76eed5cfa/test-auto-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "785e680b9423e364e25acaff2cb114fcb18cdcdbabe09b838544059b3172ae42",
          "md5": "3a54186ce62abe522e1a742ef2628f2c",
          "sha256": "9d39509be0f891cba1492c91593086048549b16cf595363a7c3436a7ffa5188b"
        },
        "downloads": -1,
        "filename": "test_auto-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3a54186ce62abe522e1a742ef2628f2c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 22101,
        "upload_time": "2021-01-26T15:47:56",
        "upload_time_iso_8601": "2021-01-26T15:47:56.906166Z",
        "url": "https://files.pythonhosted.org/packages/78/5e/680b9423e364e25acaff2cb114fcb18cdcdbabe09b838544059b3172ae42/test_auto-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6e8abafb1b0c264cbc8bbb103aa1525608b83f0ffa93edd7f62d8f566848798a",
          "md5": "e87af5f328c4deccbaba3a8da4ca3653",
          "sha256": "efdc74f5d8fddb57a76e35f9e4b8cd619ab7d36bcb93b121e2143d194a5977b5"
        },
        "downloads": -1,
        "filename": "test-auto-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e87af5f328c4deccbaba3a8da4ca3653",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 213516,
        "upload_time": "2021-01-26T15:48:00",
        "upload_time_iso_8601": "2021-01-26T15:48:00.539854Z",
        "url": "https://files.pythonhosted.org/packages/6e/8a/bafb1b0c264cbc8bbb103aa1525608b83f0ffa93edd7f62d8f566848798a/test-auto-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ae84d2e0897afb0410232f0d6718979f33c7030d1d6a1d037a83cbeadb6da13e",
          "md5": "e0c93c9606b120018345287dc3abb922",
          "sha256": "e2f87c7e5937f3adf6c9ffbbb05fa095ae01fae28b41f0b5a40dc9bc7306af8c"
        },
        "downloads": -1,
        "filename": "test_auto-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e0c93c9606b120018345287dc3abb922",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 25865,
        "upload_time": "2021-07-08T00:00:56",
        "upload_time_iso_8601": "2021-07-08T00:00:56.074859Z",
        "url": "https://files.pythonhosted.org/packages/ae/84/d2e0897afb0410232f0d6718979f33c7030d1d6a1d037a83cbeadb6da13e/test_auto-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "33d84a57c90386b296bdcb251ae6e3280e80c6c13086f1fa0be4cf3268caef74",
          "md5": "92648b9ec71a944d272bd52ad29b05c1",
          "sha256": "af09d6e556f2d6c0c0162b76cee6491465cafe9397fd071b0cf9602185133e7d"
        },
        "downloads": -1,
        "filename": "test-auto-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "92648b9ec71a944d272bd52ad29b05c1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 216122,
        "upload_time": "2021-07-08T00:00:58",
        "upload_time_iso_8601": "2021-07-08T00:00:58.012292Z",
        "url": "https://files.pythonhosted.org/packages/33/d8/4a57c90386b296bdcb251ae6e3280e80c6c13086f1fa0be4cf3268caef74/test-auto-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ae84d2e0897afb0410232f0d6718979f33c7030d1d6a1d037a83cbeadb6da13e",
        "md5": "e0c93c9606b120018345287dc3abb922",
        "sha256": "e2f87c7e5937f3adf6c9ffbbb05fa095ae01fae28b41f0b5a40dc9bc7306af8c"
      },
      "downloads": -1,
      "filename": "test_auto-1.0.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "e0c93c9606b120018345287dc3abb922",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 25865,
      "upload_time": "2021-07-08T00:00:56",
      "upload_time_iso_8601": "2021-07-08T00:00:56.074859Z",
      "url": "https://files.pythonhosted.org/packages/ae/84/d2e0897afb0410232f0d6718979f33c7030d1d6a1d037a83cbeadb6da13e/test_auto-1.0.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "33d84a57c90386b296bdcb251ae6e3280e80c6c13086f1fa0be4cf3268caef74",
        "md5": "92648b9ec71a944d272bd52ad29b05c1",
        "sha256": "af09d6e556f2d6c0c0162b76cee6491465cafe9397fd071b0cf9602185133e7d"
      },
      "downloads": -1,
      "filename": "test-auto-1.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "92648b9ec71a944d272bd52ad29b05c1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 216122,
      "upload_time": "2021-07-08T00:00:58",
      "upload_time_iso_8601": "2021-07-08T00:00:58.012292Z",
      "url": "https://files.pythonhosted.org/packages/33/d8/4a57c90386b296bdcb251ae6e3280e80c6c13086f1fa0be4cf3268caef74/test-auto-1.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}