{
  "info": {
    "author": "Justin Blaber",
    "author_email": "justin.akira.blaber@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Natural Language :: English",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "```python\n# default_exp disparity\n```\n\n# Disparity\n\n\n```python\n# export\nimport numba\nimport numpy as np\n\nfrom camera_calib.utils import *\n```\n\n\n```python\nimport re\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\nimport torch\n```\n\n# Utilities\n\n\n```python\ndef _parse_name(name_img):\n    match = re.match(r'''SERIAL_(?P<serial>.*)_\n                         DATETIME_(?P<date>.*)_\n                         CAM_(?P<cam>.*)_\n                         FRAMEID_(?P<frameid>.*)_\n                         COUNTER_(?P<counter>.*).png''', \n                     name_img, \n                     re.VERBOSE)\n    return match.groupdict()\n```\n\n\n```python\ndef _get_imgs(dir_imgs):\n    imgs = []\n    for file_img in dir_imgs.glob('*.png'):\n        dict_group = _parse_name(file_img.name)\n        img = api.File16bitImg(file_img)\n        img.idx_cam = int(dict_group['cam'])-1\n        img.idx_cb  = int(dict_group['counter'])-1\n        imgs.append(img)\n    return imgs\n```\n\n\n```python\ndef _print_imgs(imgs): \n    for img in imgs: print(f'{img.name} - cam: {img.idx_cam} - cb: {img.idx_cb}')\n```\n\n# Compute disparity map\n\nFirst, we need to calibrate, then rectify, and then we can compute disparity maps.\n\n## Calibrate\n\n\n```python\nimport camera_calib.api as api\n```\n\n\n```python\nimgs = _get_imgs(Path('data/calib'))\n_print_imgs(imgs)\n```\n\n    SERIAL_19061245_DATETIME_2020-08-16-16:58:39-927381_CAM_1_FRAMEID_0_COUNTER_1 - cam: 0 - cb: 0\n    SERIAL_16276941_DATETIME_2020-08-16-16:58:53-756240_CAM_2_FRAMEID_0_COUNTER_2 - cam: 1 - cb: 1\n    SERIAL_16276941_DATETIME_2020-08-16-16:58:39-927424_CAM_2_FRAMEID_0_COUNTER_1 - cam: 1 - cb: 0\n    SERIAL_16276941_DATETIME_2020-08-16-16:59:05-367688_CAM_2_FRAMEID_0_COUNTER_3 - cam: 1 - cb: 2\n    SERIAL_19061245_DATETIME_2020-08-16-16:59:59-403047_CAM_1_FRAMEID_0_COUNTER_4 - cam: 0 - cb: 3\n    SERIAL_16276941_DATETIME_2020-08-16-17:00:14-283298_CAM_2_FRAMEID_0_COUNTER_5 - cam: 1 - cb: 4\n    SERIAL_19061245_DATETIME_2020-08-16-16:58:53-756222_CAM_1_FRAMEID_0_COUNTER_2 - cam: 0 - cb: 1\n    SERIAL_16276941_DATETIME_2020-08-16-16:59:59-403092_CAM_2_FRAMEID_0_COUNTER_4 - cam: 1 - cb: 3\n    SERIAL_19061245_DATETIME_2020-08-16-16:59:05-367645_CAM_1_FRAMEID_0_COUNTER_3 - cam: 0 - cb: 2\n    SERIAL_19061245_DATETIME_2020-08-16-17:00:14-283252_CAM_1_FRAMEID_0_COUNTER_5 - cam: 0 - cb: 4\n\n\n\n```python\nh_cb = 50.8\nw_cb = 50.8\nh_f = 42.672\nw_f = 42.672\nnum_c_h = 16\nnum_c_w = 16\nspacing_c = 2.032\ncb_geom = api.CbGeom(h_cb, w_cb,\n                     api.CpCSRGrid(num_c_h, num_c_w, spacing_c),\n                     api.FmCFPGrid(h_f, w_f))\n```\n\n\n```python\nfile_model = Path('models/dot_vision_checker.pth')\ndetector = api.DotVisionCheckerDLDetector(file_model)\n```\n\n\n```python\nrefiner = api.OpenCVCheckerRefiner(hw_min=5, hw_max=15, cutoff_it=20, cutoff_norm=1e-3)\n```\n\n\n```python\ncalib = api.multi_calib(imgs, cb_geom, detector, refiner)\n```\n\n    Refining control points for: SERIAL_19061245_DATETIME_2020-08-16-16:58:39-927381_CAM_1_FRAMEID_0_COUNTER_1...\n    Refining control points for: SERIAL_19061245_DATETIME_2020-08-16-16:59:59-403047_CAM_1_FRAMEID_0_COUNTER_4...\n    Refining control points for: SERIAL_19061245_DATETIME_2020-08-16-16:58:53-756222_CAM_1_FRAMEID_0_COUNTER_2...\n    Refining control points for: SERIAL_19061245_DATETIME_2020-08-16-16:59:05-367645_CAM_1_FRAMEID_0_COUNTER_3...\n    Refining control points for: SERIAL_19061245_DATETIME_2020-08-16-17:00:14-283252_CAM_1_FRAMEID_0_COUNTER_5...\n    Refining single parameters...\n     - Iteration: 000 - Norm:    0.05166 - Loss:   40.43536\n     - Iteration: 001 - Norm:    0.05871 - Loss:   27.05900\n     - Iteration: 002 - Norm:    0.10641 - Loss:   16.14479\n     - Iteration: 003 - Norm:    0.52404 - Loss:    9.86104\n     - Iteration: 004 - Norm:    0.70472 - Loss:    5.50705\n     - Iteration: 005 - Norm:    0.15078 - Loss:    5.39712\n     - Iteration: 006 - Norm:    0.02470 - Loss:    5.38315\n     - Iteration: 007 - Norm:    0.01638 - Loss:    5.37218\n     - Iteration: 008 - Norm:    0.00468 - Loss:    5.37189\n     - Iteration: 009 - Norm:    0.13333 - Loss:    5.36454\n     - Iteration: 010 - Norm:    0.00423 - Loss:    5.36439\n     - Iteration: 011 - Norm:   28.76676 - Loss:    3.86312\n     - Iteration: 012 - Norm:   17.23997 - Loss:    3.17776\n     - Iteration: 013 - Norm:    0.00853 - Loss:    3.17776\n     - Iteration: 014 - Norm:    0.00000 - Loss:    3.17776\n    Refining control points for: SERIAL_16276941_DATETIME_2020-08-16-16:58:53-756240_CAM_2_FRAMEID_0_COUNTER_2...\n    Refining control points for: SERIAL_16276941_DATETIME_2020-08-16-16:58:39-927424_CAM_2_FRAMEID_0_COUNTER_1...\n    Refining control points for: SERIAL_16276941_DATETIME_2020-08-16-16:59:05-367688_CAM_2_FRAMEID_0_COUNTER_3...\n    Refining control points for: SERIAL_16276941_DATETIME_2020-08-16-17:00:14-283298_CAM_2_FRAMEID_0_COUNTER_5...\n    Refining control points for: SERIAL_16276941_DATETIME_2020-08-16-16:59:59-403092_CAM_2_FRAMEID_0_COUNTER_4...\n    Refining single parameters...\n     - Iteration: 000 - Norm:    0.04648 - Loss:   33.60078\n     - Iteration: 001 - Norm:    0.03970 - Loss:   26.93946\n     - Iteration: 002 - Norm:    0.04580 - Loss:   24.62314\n     - Iteration: 003 - Norm:    0.14923 - Loss:   21.53392\n     - Iteration: 004 - Norm:    0.48321 - Loss:   13.00884\n     - Iteration: 005 - Norm:    0.00873 - Loss:   12.83886\n     - Iteration: 006 - Norm:    0.65804 - Loss:    8.40447\n     - Iteration: 007 - Norm:    0.10469 - Loss:    8.11526\n     - Iteration: 008 - Norm:    0.09923 - Loss:    8.02833\n     - Iteration: 009 - Norm:    0.09764 - Loss:    7.97387\n     - Iteration: 010 - Norm:    0.18271 - Loss:    7.92175\n     - Iteration: 011 - Norm:    9.62275 - Loss:    7.45953\n     - Iteration: 012 - Norm:   37.67393 - Loss:    5.66647\n     - Iteration: 013 - Norm:    1.13521 - Loss:    5.66112\n     - Iteration: 014 - Norm:    0.01024 - Loss:    5.66107\n     - Iteration: 015 - Norm:  142.51304 - Loss:    3.52503\n     - Iteration: 016 - Norm:    0.29318 - Loss:    3.52483\n     - Iteration: 017 - Norm:    0.00000 - Loss:    3.52483\n    Refining multi parameters...\n     - Iteration: 000 - Norm:    0.00633 - Loss:  365.50887\n     - Iteration: 001 - Norm:    0.03670 - Loss:  251.90410\n     - Iteration: 002 - Norm:    0.03891 - Loss:  191.50267\n     - Iteration: 003 - Norm:    0.03330 - Loss:  169.51325\n     - Iteration: 004 - Norm:    0.14800 - Loss:  115.86002\n     - Iteration: 005 - Norm:    0.03182 - Loss:   99.71262\n     - Iteration: 006 - Norm:    0.09812 - Loss:   78.23173\n     - Iteration: 007 - Norm:    0.12045 - Loss:   50.32390\n     - Iteration: 008 - Norm:    0.02356 - Loss:   45.52809\n     - Iteration: 009 - Norm:    0.00880 - Loss:   44.19760\n     - Iteration: 010 - Norm:    0.03753 - Loss:   40.63650\n     - Iteration: 011 - Norm:    0.03345 - Loss:   37.87511\n     - Iteration: 012 - Norm:    0.01658 - Loss:   36.71647\n     - Iteration: 013 - Norm:    0.02828 - Loss:   34.62113\n     - Iteration: 014 - Norm:    0.05827 - Loss:   30.72548\n     - Iteration: 015 - Norm:    0.00558 - Loss:   30.46024\n     - Iteration: 016 - Norm:    0.00377 - Loss:   30.32508\n     - Iteration: 017 - Norm:    0.01700 - Loss:   29.78092\n     - Iteration: 018 - Norm:    0.00733 - Loss:   29.58850\n     - Iteration: 019 - Norm:    0.16740 - Loss:   25.31908\n     - Iteration: 020 - Norm:    0.02405 - Loss:   24.72751\n     - Iteration: 021 - Norm:    0.00133 - Loss:   24.69757\n     - Iteration: 022 - Norm:    0.00339 - Loss:   24.62627\n     - Iteration: 023 - Norm:    0.00355 - Loss:   24.59673\n     - Iteration: 024 - Norm:    0.04353 - Loss:   24.94890\n     - Iteration: 025 - Norm:    0.04560 - Loss:   24.23809\n     - Iteration: 026 - Norm:    0.04802 - Loss:   24.02517\n     - Iteration: 027 - Norm:    0.00035 - Loss:   24.02463\n     - Iteration: 028 - Norm:    0.00095 - Loss:   24.02313\n     - Iteration: 029 - Norm:    0.07848 - Loss:   23.82852\n     - Iteration: 030 - Norm:    0.06296 - Loss:   23.67669\n     - Iteration: 031 - Norm:    0.00122 - Loss:   23.67818\n     - Iteration: 032 - Norm:    0.01764 - Loss:   23.65771\n     - Iteration: 033 - Norm:    0.53306 - Loss:   23.11532\n     - Iteration: 034 - Norm:    0.00389 - Loss:   23.11467\n     - Iteration: 035 - Norm:    0.00026 - Loss:   23.11465\n     - Iteration: 036 - Norm:    0.00855 - Loss:   23.11144\n     - Iteration: 037 - Norm:    0.04346 - Loss:   23.09543\n     - Iteration: 038 - Norm:    0.00329 - Loss:   23.09395\n     - Iteration: 039 - Norm:    0.00014 - Loss:   23.09395\n     - Iteration: 040 - Norm:    0.00550 - Loss:   23.09309\n     - Iteration: 041 - Norm:    0.11960 - Loss:   23.05538\n     - Iteration: 042 - Norm:    0.21922 - Loss:   22.99648\n     - Iteration: 043 - Norm:    0.00130 - Loss:   22.99645\n     - Iteration: 044 - Norm:    0.00077 - Loss:   22.99642\n     - Iteration: 045 - Norm:    0.04483 - Loss:   22.98557\n     - Iteration: 046 - Norm:    7.57304 - Loss:   21.17649\n     - Iteration: 047 - Norm:   10.45625 - Loss:   18.59859\n     - Iteration: 048 - Norm:    0.76570 - Loss:   18.39438\n     - Iteration: 049 - Norm:    0.01591 - Loss:   18.39388\n     - Iteration: 050 - Norm:    0.01743 - Loss:   18.39040\n     - Iteration: 051 - Norm:    4.64610 - Loss:   17.20502\n     - Iteration: 052 - Norm:    2.02334 - Loss:   16.86937\n     - Iteration: 053 - Norm:    0.00002 - Loss:   16.86937\n     - Iteration: 054 - Norm:    0.02372 - Loss:   16.86879\n     - Iteration: 055 - Norm:    2.26827 - Loss:   16.59826\n     - Iteration: 056 - Norm:   29.46264 - Loss:   13.48704\n     - Iteration: 057 - Norm:    2.88659 - Loss:   13.25918\n     - Iteration: 058 - Norm:    0.04408 - Loss:   13.25897\n     - Iteration: 059 - Norm:    0.00140 - Loss:   13.25896\n     - Iteration: 060 - Norm:    0.00002 - Loss:   13.25896\n     - Iteration: 061 - Norm:    0.00000 - Loss:   13.25896\n\n\n\n```python\napi.plot_residuals(calib);\n```\n\n\n![png](README_files/README_17_0.png)\n\n\n\n```python\napi.plot_extrinsics(calib);\n```\n\n\n![png](README_files/README_18_0.png)\n\n\n\n```python\napi.save(calib, 'data/calib/calib.pth')\n```\n\nFreeze above and just load\n\n\n```python\ncalib = api.load('data/calib/calib.pth')\n```\n\n## Rectify\n\n\n```python\nfrom image_rect import image_rect\n```\n\n\n```python\nimgs = _get_imgs(Path('data/scene1'))\n_print_imgs(imgs)\n```\n\n    SERIAL_19061245_DATETIME_2020-08-16-17:05:28-278345_CAM_1_FRAMEID_0_COUNTER_1 - cam: 0 - cb: 0\n    SERIAL_16276941_DATETIME_2020-08-16-17:05:28-278389_CAM_2_FRAMEID_0_COUNTER_1 - cam: 1 - cb: 0\n\n\n\n```python\n[img1] = [img for img in imgs if img.idx_cam == 0]\n[img2] = [img for img in imgs if img.idx_cam == 1]\nimg1.name, img2.name\n```\n\n\n\n\n    ('SERIAL_19061245_DATETIME_2020-08-16-17:05:28-278345_CAM_1_FRAMEID_0_COUNTER_1',\n     'SERIAL_16276941_DATETIME_2020-08-16-17:05:28-278389_CAM_2_FRAMEID_0_COUNTER_1')\n\n\n\n\n```python\nrect = image_rect.rectify(calib)\n```\n\n\n```python\nwith torch.no_grad():\n    arr1_r = image_rect.rect_img(img1, rect)\n    arr2_r = image_rect.rect_img(img2, rect)\n```\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(20,15))\naxs[0].imshow(arr1_r, cmap='gray')\naxs[1].imshow(arr2_r, cmap='gray')\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c7f91ad10>\n\n\n\n\n![png](README_files/README_28_1.png)\n\n\n## Disparity\n\nDo initial resize to make processing faster; also note that I'm doing the rest in numba/numpy since a lot of nested for loops are involved.\n\nNOTE: numba does not yet support classes with inheritance yet\n\n\n```python\narr1, arr2 = [imresize(torch2np(arr), shape(arr)/4) for arr in [arr1_r, arr2_r]]\n```\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(10,10))\nfor arr, ax in zip([arr1, arr2], axs): ax.imshow(arr)\n```\n\n\n![png](README_files/README_32_0.png)\n\n\n### Basic block matching\n\nsum of absolute difference is a common loss function for disparity maps\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef SAD(arr1, arr2):\n    l = 0\n    for i in range(arr1.shape[0]):\n        for j in range(arr2.shape[1]):\n            l += abs(arr1[i,j] - arr2[i,j])\n    return l\n```\n\n`rect_loss_p` will compute the loss for a single point and store the losses in a buffer\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef rect_loss_p(arr1, arr2, x, y, min_disp, max_disp, hw, loss, buf_loss):\n    h_arr, w_arr = arr1.shape\n\n    l_t, t_t, r_t, b_t = max(x-hw, 0), max(y-hw, 0), min(x+hw, w_arr-1), min(y+hw, h_arr-1)\n    h_t, w_t = b_t-t_t+1, r_t-l_t+1\n    for j in range(min_disp, max_disp+1):\n        if (j+l_t >= 0) and (j+r_t < w_arr): # Template in bounds\n            buf_loss[j-min_disp] = loss(arr1[t_t:t_t+h_t, l_t:l_t+w_t], arr2[t_t:t_t+h_t, j+l_t:j+l_t+w_t])\n        else:                                # Template out of bound \n            buf_loss[j-min_disp] = np.inf        \n```\n\n`argmin_int` is the integer argument minimum; `int` suffix is only used to distinguish between subpixel minimum, which is used later.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef argmin_int(arr): return np.argmin(arr)\n```\n\nTest out getting the loss for an example point\n\n\n```python\ndef _debug_rect_loss_p(x, y):\n    buf_loss = np.empty(max_disp-min_disp+1)\n    rect_loss_p(arr1, arr2, x, y, min_disp, max_disp, hw, loss, buf_loss)\n    disp = argmin(buf_loss) + min_disp\n    _, axs = plt.subplots(1, 2, figsize=(10,10))\n    axs[0].imshow(arr1)\n    axs[0].plot(x, y, 'rs')\n    axs[1].imshow(arr2)\n    axs[1].plot(x+disp, y, 'rs')\n```\n\n\n```python\nhw = 15\nmin_disp = -15\nmax_disp =  15\nloss = SAD\nargmin = argmin_int\n_debug_rect_loss_p(x=60, y=75)\n```\n\n\n![png](README_files/README_42_0.png)\n\n\n`rect_loss_l` will compute the loss for an entire line. Note that an initial disparity map guess can also be input; if this is the case, then the disparity range will be centered around this disparity value instead of zero.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef rect_loss_l(arr1, arr2, y, r_disp, hw, loss, buf_loss, arr_disp_init=None):\n    h_arr, w_arr = arr1.shape\n\n    for i in range(w_arr):\n        disp_init = 0 if arr_disp_init is None else arr_disp_init[y, i]\n        min_disp, max_disp = [disp + disp_init for disp in r_disp]\n        rect_loss_p(arr1, arr2, i, y, min_disp, max_disp, hw, loss, buf_loss[i])\n```\n\n\n```python\ndef _debug_rect_loss_l(y):\n    buf_loss = np.empty((arr1.shape[1], r_disp[1]-r_disp[0]+1))\n    rect_loss_l(arr1, arr2, y, r_disp, hw, loss, buf_loss)\n    _, ax = plt.subplots(1, 1, figsize=(10,10))\n    ax.imshow(buf_loss.T)\n    return buf_loss\n```\n\n\n```python\nr_disp = (-15, 15)\n```\n\n\n```python\n_debug_rect_loss_l(60);\n```\n\n\n![png](README_files/README_47_0.png)\n\n\n`min_path_int` will compute the path from left to right of transposed loss buffer using the minimum value in each column.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef min_path_int(arr_loss, buf_path):\n    for i in range(len(arr_loss)):\n        buf_path[i] = argmin_int(arr_loss[i])\n```\n\n`rect_match_arr_min_path` will compute a disparity map. It takes an input `min_path` function which, when given a loss buffer, will compute the best path across it; this will make more sense when we use dynamic programming. `arr_disp_init` is an initial guess for the disparity map; this will make more sense when we do the image pyramids. \n\nNote that this seems to be the level where multi-threading makes sense; it's not too fine grained where overhead will slow things down and it's not too grainular such that a single thread can cause a long delay.\n\n\n```python\n# export\n@numba.jit(nopython=True, parallel=True)\ndef rect_match_arr_min_path(arr1, arr2, r_disp, hw, loss, min_path, arr_disp_init=None):\n    h_arr, w_arr = arr1.shape[0], arr1.shape[1]\n\n    arr_disp = np.empty((h_arr, w_arr))\n    for i in numba.prange(h_arr):\n        buf_loss = np.empty((arr1.shape[1], r_disp[1]-r_disp[0]+1))\n        rect_loss_l(arr1, arr2, i, r_disp, hw, loss, buf_loss, arr_disp_init)\n        min_path(buf_loss, arr_disp[i]) # range offset and initial disparity need to be applied after\n        arr_disp[i] += r_disp[0]                                       \n        if arr_disp_init is not None: arr_disp[i] += arr_disp_init[i]\n    return arr_disp\n```\n\n\n```python\n# export\ndef make_rect_match_arr_min_path(r_disp, hw, loss, min_path):\n    @numba.jit(nopython=True)\n    def rect_match_arr(arr1, arr2, arr_disp_init=None):\n        return rect_match_arr_min_path(arr1, arr2, r_disp, hw, loss, min_path, arr_disp_init)\n    return rect_match_arr\n```\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_int)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\nDo it again so numba will compile and run faster.\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\n~200 ms is not bad. This could be realtime-ish performance for this image resolution.\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=min_disp, vmax=max_disp)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=min_disp, vmax=max_disp, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c66f9a390>\n\n\n\n\n![png](README_files/README_58_1.png)\n\n\nAs to be expected this doesn't look great; lets debug some problem areas\n\n\n```python\n_debug_rect_loss_p(125, 60)\n```\n\n\n![png](README_files/README_60_0.png)\n\n\nThere is confusion with similar patterns. Note the found point on the right image is 3 stripes other rather than 2 on the left image.\n\n\n```python\n_debug_rect_loss_p(125, 25)\n```\n\n\n![png](README_files/README_62_0.png)\n\n\nGlare causes an issue; note the point on the right image is aligned to the glare instead of where it should be\n\n\n```python\n_debug_rect_loss_p(45, 100)\n```\n\n\n![png](README_files/README_64_0.png)\n\n\nThis is actually wrong since the left part of the object is not visible to the right camera. It's more aligned to the side of the object rather than its actual location.\n\n\n```python\n_debug_rect_loss_p(60, 125)\n```\n\n\n![png](README_files/README_66_0.png)\n\n\nThis might be due to the fact that sub images are not normalized (mean subtracted and divided by std-dev) before being compared.\n\n### Subpixel block matching\n\n`argmin_sub` uses a single newton's iteration to find the root of the derivate (i.e. the minima). The update is the first derivative divided by the second derivative at the integer minimum location.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef argmin_sub(arr):\n    idx_min = argmin_int(arr)\n    if 1 <= idx_min <= len(arr)-2:\n        delta_idx = ((arr[idx_min+1]-arr[idx_min-1])/2)/(arr[idx_min+1]-2*arr[idx_min]+arr[idx_min-1])\n        if np.isnan(delta_idx): delta_idx =  0\n        if delta_idx < -1:      delta_idx = -1\n        if delta_idx >  1:      delta_idx =  1\n        idx_min = idx_min - delta_idx\n    return idx_min\n```\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef min_path_sub(arr_loss, buf_path):\n    for i in range(len(arr_loss)):\n        buf_path[i] = argmin_sub(arr_loss[i])\n```\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_sub)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\nAgain, around ~200 ms, the subpixel stuff doesn't add much overhead\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c666fc910>\n\n\n\n\n![png](README_files/README_76_1.png)\n\n\nLooks smoother near the center of the object.\n\n### Dynamic programming\n\nThe goal of dynamic programming is to find the shortest path from left to right in the following array:\n\n\n```python\narr_loss = _debug_rect_loss_l(75)\n```\n\n\n![png](README_files/README_80_0.png)\n\n\nBut with an added smoothness contraint. This will be in the form of a penalty for going \"up\" and \"down\" and also a max change between neighboring columns. The hope is that, in the above, the path taken will not skip down near the ~125 column, but will instead continue smoothly above it, because doing so would incur a pentalty.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef _min_path_int_dp(arr_loss, buf_path, r_disp, max_change, penalty_disp):\n    buf_route     = np.zeros(arr_loss.shape)\n    buf_move      = np.empty((2*max_change+1, r_disp[1]-r_disp[0]+1))\n    buf_loss_prev = arr_loss[-1].copy() # Going backwards, this is initial optimal loss\n    for i in range(len(arr_loss)-2, -1, -1):\n        # Get loss of each move\n        buf_move[:] = np.inf\n        for j in range(-max_change, max_change+1):\n            idx_minl, idx_maxl = max( j,0), min(arr_loss.shape[1]+j,arr_loss.shape[1])\n            idx_minm, idx_maxm = max(-j,0), min(arr_loss.shape[1]-j,arr_loss.shape[1])\n            buf_move[j+max_change, idx_minm:idx_maxm] = buf_loss_prev[idx_minl:idx_maxl] + abs(j)*penalty_disp\n        # Get optimal move and store it\n        for j in range(buf_move.shape[1]):\n            idx_min = np.argmin(buf_move[:,j])\n            buf_route[i,j] = idx_min - max_change\n            buf_loss_prev[j] = arr_loss[i,j] + buf_move[idx_min, j] # total loss = loss + optimal move\n    # Gather path\n    buf_path[0] = np.argmin(buf_loss_prev)\n    for i in range(1, len(buf_route)):\n        buf_path[i] = buf_path[i-1] + buf_route[i-1, int(buf_path[i-1])]\n```\n\n\n```python\n# export\ndef make_min_path_int_dp(r_disp, max_change, penalty_disp):\n    @numba.jit(nopython=True)\n    def min_path(arr_loss, buf_path):\n        return _min_path_int_dp(arr_loss, buf_path, r_disp, max_change, penalty_disp)\n    return min_path\n```\n\n\n```python\nmax_change = 3\npenalty_disp = 2\n```\n\n\n```python\nmin_path_int_dp = make_min_path_int_dp(r_disp, max_change, penalty_disp)\n```\n\n\n```python\ndef _debug_min_path(min_path):\n    buf_path = np.empty(arr_loss.shape[0])\n    min_path(arr_loss, buf_path)\n    _, ax = plt.subplots(1, 1, figsize=(10,10))\n    ax.imshow(arr_loss.T)\n    plt.plot(buf_path, '-r')\n```\n\n\n```python\n_debug_min_path(min_path_int)\n```\n\n\n![png](README_files/README_87_0.png)\n\n\n\n```python\n_debug_min_path(min_path_int_dp)\n```\n\n\n![png](README_files/README_88_0.png)\n\n\nDynamic programming punishes the jump near 125 and prevents it from happening... cool\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_int_dp)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\nAgain, ~200 ms, not bad.\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c66d5aa50>\n\n\n\n\n![png](README_files/README_94_1.png)\n\n\nDefinitely much smoother. The glare still causes problems though.\n\n### Sub pixel dynamic programming\n\nI just basically replaced all `argmin`s with `argmin_sub` and also replaced indexing with `interp`. This assumes smoothness between adjacent optimal paths and im not sure if its strictly correct, but it seems to work.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef interp(arr, idx):\n    if idx < 0 or idx > len(arr)-1: val = np.nan\n    else:\n        idx_f = np.floor(idx)\n        if idx == idx_f: val = arr[int(idx_f)]\n        else:            val = (idx_f+1-idx)*arr[int(idx_f)] + (idx-idx_f)*arr[int(idx_f)+1]\n    return val\n```\n\n\n```python\narr = np.array([1,2,3])\nassert_allclose(np.isnan(interp(arr, -0.5)), True)\nassert_allclose(         interp(arr,  0.0),  1.0)\nassert_allclose(         interp(arr,  0.5),  1.5)\nassert_allclose(         interp(arr,  1.0),  2.0)\nassert_allclose(         interp(arr,  1.5),  2.5)\nassert_allclose(         interp(arr,  2.0),  3.0)\nassert_allclose(np.isnan(interp(arr,  2.5)), True)\n```\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef _min_path_sub_dp(arr_loss, buf_path, r_disp, max_change, penalty_disp):\n    buf_route     = np.zeros(arr_loss.shape)\n    buf_move      = np.empty((2*max_change+1, r_disp[1]-r_disp[0]+1))\n    buf_loss_prev = arr_loss[-1].copy() # Going backwards, this is initial optimal loss\n    for i in range(len(arr_loss)-2, -1, -1):\n        # Get loss of each move\n        buf_move[:] = np.inf\n        for j in range(-max_change, max_change+1):\n            idx_minl, idx_maxl = max( j,0), min(arr_loss.shape[1]+j,arr_loss.shape[1])\n            idx_minm, idx_maxm = max(-j,0), min(arr_loss.shape[1]-j,arr_loss.shape[1])\n            buf_move[j+max_change, idx_minm:idx_maxm] = buf_loss_prev[idx_minl:idx_maxl] + abs(j)*penalty_disp\n        # Get optimal move and store it\n        for j in range(buf_move.shape[1]):\n            idx_min = argmin_sub(buf_move[:,j])\n            buf_route[i,j] = idx_min - max_change\n            buf_loss_prev[j] = arr_loss[i,j] + interp(buf_move[:, j], idx_min)\n    # Gather path\n    buf_path[0] = argmin_sub(buf_loss_prev)\n    for i in range(1, len(buf_route)):\n        buf_path[i] = buf_path[i-1] + interp(buf_route[i-1], buf_path[i-1])\n```\n\n\n```python\n# export\ndef make_min_path_sub_dp(r_disp, max_change, penalty_disp):\n    @numba.jit(nopython=True)\n    def min_path(arr_loss, buf_path):\n        return _min_path_sub_dp(arr_loss, buf_path, r_disp, max_change, penalty_disp)\n    return min_path\n```\n\n\n```python\nmin_path_sub_dp = make_min_path_sub_dp(r_disp, max_change, penalty_disp)\n```\n\n\n```python\n_debug_min_path(min_path_sub_dp)\n```\n\n\n![png](README_files/README_103_0.png)\n\n\nIt's smooth now\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_sub_dp)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\nStill ~200 ms\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c6651cb10>\n\n\n\n\n![png](README_files/README_109_1.png)\n\n\nIt's a little bit different from the integer version, but overall it looks similar and is smoother\n\n### Image pyramid\n\nTry using an image pyramid with \"telescoping\" search. Note that I've kept the window size the same for each level. In the most reduced image, it will use a proportionally larger window to get the overall translation correct, then in larger images, the proportionally smaller window will localize better (in theory at least).\n\n\n```python\n# export\ndef rect_match_pyr(arr1, arr2, rect_match_arr, steps=3):\n    if not np.all(shape(arr1) % 2**steps == 0): raise RuntimeError('Shape must be divisible by 2^steps')\n\n    def _get_pyr(arr):\n        arr_pyr = [arr]\n        for idx in range(steps-1): \n            arr_pyr.append(imresize(arr_pyr[-1], shape(arr_pyr[-1])/2))\n        return arr_pyr\n    arr1_pyr, arr2_pyr = [_get_pyr(arr) for arr in [arr1, arr2]]\n\n    arr_disp = None\n    for idx in range(steps-1,-1,-1):\n        arr1, arr2 = arr1_pyr[idx], arr2_pyr[idx]\n        if arr_disp is not None:\n            arr_disp = imresize(2*arr_disp, 2*shape(arr_disp)) # Remember to multiply disparities by 2\n            arr_disp = np.round(arr_disp).astype(np.long)      # Must be integer\n        arr_disp = rect_match_arr(arr1, arr2, arr_disp)\n    return arr_disp\n```\n\n\n```python\nr_disp = (-5,5)\n```\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_sub)\n```\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n~100 ms, could probably optimize more but its fast\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c640bbd50>\n\n\n\n\n![png](README_files/README_119_1.png)\n\n\n\n```python\nmin_path_sub_dp = make_min_path_sub_dp(r_disp, max_change, penalty_disp)\n```\n\n\n```python\nrect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path_sub_dp)\n```\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n~150 ms, a little slower but still pretty fast\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c523c3d10>\n\n\n\n\n![png](README_files/README_125_1.png)\n\n\n# SGM\n\nSemi global matching is another popular method thats fast but has more smoothness constraints than dynamic programming (which is restricted to rows). A lot of SGM implementations I've seen usually have a fixed number of directions (like 8 cardinal directions) which are hard coded. I want to be able to input any direction and see what the output disparity map looks like. I've attempted to do this by implementing a `line_loop` which will iterate over an array in non-overlapping lines.\n\n### Line loop\n\n`np.isclose` hasnt been implemented yet\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef isclose(x, y, atol=1e-8): return abs(x-y) < atol\n```\n\n`np.clip` hasnt been implemented yet\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef clip(x, min_x, max_x): return max(min(x, max_x), min_x)\n```\n\n`line_loop` will iterate over an `arr` line by line in a non-overlapping and full/unique manner given an input `theta`.\n\n\n```python\n# export\n@numba.jit(nopython=True)\ndef line_loop(arr, theta, callback):\n    h, w = arr.shape[0:2]\n\n    # Get dx, dy\n    dx, dy = np.cos(theta), np.sin(theta)\n    if    isclose(dx, 0): dx, dy = 0, np.sign(dy)*h\n    elif  isclose(dy, 0): dx, dy = np.sign(dx)*w, 0\n    else:\n        sf = min(abs(dx), abs(dy))\n        dx, dy = np.round(dx/sf), np.round(dy/sf)\n        dx, dy = clip(dx, 1-w, w-1), clip(dy, 1-h, h-1)\n    dx, dy = int(dx), int(dy)\n\n    # Get increments\n    if abs(dx) > abs(dy): l, dx_l, dy_l, dx_c, dy_c = abs(dx), np.sign(dx), 0, 0, np.sign(dy)\n    else:                 l, dx_l, dy_l, dx_c, dy_c = abs(dy), 0, np.sign(dy), np.sign(dx), 0\n\n    # Get initial p0\n    if   0 <= dx <   w and 0 <  dy <=  h: x0, y0 = w-1,   0\n    elif 0 <  dx <=  w and 0 >= dy >  -h: x0, y0 =   0,   0\n    elif 0 >= dx >  -w and 0 >  dy >= -h: x0, y0 =   0, h-1\n    elif 0 >  dx >= -w and 0 <= dy <   h: x0, y0 = w-1, h-1\n    else: raise RuntimeError('Invalid dx, dy')\n\n    # Do line iterations\n    it_p, num_p = 0, h*w              # Iterate until it_p == num_p\n    while it_p < num_p:\n        x, y, started = x0, y0, False # Start tracing line at p0\n        while True:\n            for i in range(l):\n                if (0 <= x < w) and (0 <= y < h):\n                    if not started: callback.start_line(arr, x, y); started=True\n                    else:           callback.in_line(arr, x, y)\n                    it_p += 1         # Point increment\n                x += dx_l; y += dy_l  # Line increment\n            x += dx_c; y += dy_c      # Change increment\n            if not ((0 <= x < w) and (0 <= y < h)): break # Lines goes out of array, so end this line\n        # Shift start of line based on current p0\n        if   x0 >= w-1 and y0 >=   1: y0 -= max(abs(dy), 1)\n        elif x0 >=   1 and y0 <=   0: x0 -= max(abs(dx), 1)\n        elif x0 <=   0 and y0 <= h-2: y0 += max(abs(dy), 1)\n        elif x0 <= w-2 and y0 >= h-1: x0 += max(abs(dx), 1)\n        else: raise RuntimeError('Invalid x0, y0')\n```\n\n### Line loop tests\n\nUse callbacks to test\n\n\n```python\n@numba.experimental.jitclass([('it', numba.int32)])\nclass callback_itfill(object):\n    def __init__(self):              self.it = -1\n    def start_line(self, arr, x, y): self.it += 1; arr[y, x] = self.it\n    def in_line(self, arr, x, y):    self.it += 1; arr[y, x] = self.it\n```\n\n\n```python\n@numba.experimental.jitclass([('line', numba.int32)])\nclass callback_linefill(object):\n    def __init__(self):              self.line = -1\n    def start_line(self, arr, x, y): self.line += 1; arr[y, x] = self.line\n    def in_line(self, arr, x, y):    arr[y, x] = self.line\n```\n\n\n```python\n@numba.experimental.jitclass([('line', numba.int32)])\nclass callback_startfill(object):\n    def __init__(self):              self.line = -1\n    def start_line(self, arr, x, y): self.line += 1; arr[y, x] = self.line\n    def in_line(self, arr, x, y):    pass\n```\n\nDo 16 cardinal directions\n\n\n```python\narr = np.full((3, 4), -1)\n```\n\n\n```python\ntheta = (0/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 0,  1,  2,  3],\n                               [ 4,  5,  6,  7],\n                               [ 8,  9, 10, 11]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[0, 0, 0, 0],\n                               [1, 1, 1, 1],\n                               [2, 2, 2, 2]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 0, -1, -1, -1],\n                               [ 1, -1, -1, -1],\n                               [ 2, -1, -1, -1]]))\n```\n\n\n```python\ntheta = (1/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 4,  1,  2,  0],\n                               [ 8,  5,  6,  3],\n                               [11,  9, 10,  7]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[2, 1, 1, 0],\n                               [3, 2, 2, 1],\n                               [4, 3, 3, 2]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 2,  1, -1,  0],\n                               [ 3, -1, -1, -1],\n                               [ 4, -1, -1, -1]]))\n```\n\n\n```python\ntheta = (2/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 6,  3,  1,  0],\n                               [ 9,  7,  4,  2],\n                               [11, 10,  8,  5]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[3, 2, 1, 0],\n                               [4, 3, 2, 1],\n                               [5, 4, 3, 2]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 3,  2,  1,  0],\n                               [ 4, -1, -1, -1],\n                               [ 5, -1, -1, -1]]))\n```\n\n\n```python\ntheta = (3/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 8,  5,  2,  0],\n                               [ 9,  6,  3,  1],\n                               [11, 10,  7,  4]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[3, 2, 1, 0],\n                               [3, 2, 1, 0],\n                               [4, 3, 2, 1]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 3,  2,  1,  0],\n                               [-1, -1, -1, -1],\n                               [ 4, -1, -1, -1]]))\n```\n\n\n```python\ntheta = (4/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 9,  6,  3,  0],\n                               [10,  7,  4,  1],\n                               [11,  8,  5,  2]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[3, 2, 1, 0],\n                               [3, 2, 1, 0],\n                               [3, 2, 1, 0]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 3,  2,  1,  0],\n                               [-1, -1, -1, -1],\n                               [-1, -1, -1, -1]]))\n```\n\n\n```python\ntheta = (5/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[10,  7,  4,  1],\n                               [11,  8,  5,  2],\n                               [ 9,  6,  3,  0]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[4, 3, 2, 1],\n                               [4, 3, 2, 1],\n                               [3, 2, 1, 0]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 4,  3,  2,  1],\n                               [-1, -1, -1, -1],\n                               [-1, -1, -1,  0]]))\n```\n\n\n```python\ntheta = (6/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[11,  9,  6,  3],\n                               [10,  7,  4,  1],\n                               [ 8,  5,  2,  0]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[5, 4, 3, 2],\n                               [4, 3, 2, 1],\n                               [3, 2, 1, 0]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 5,  4,  3,  2],\n                               [-1, -1, -1,  1],\n                               [-1, -1, -1,  0]]))\n```\n\n\n```python\ntheta = (7/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[11, 10,  7,  6],\n                               [ 9,  8,  3,  2],\n                               [ 5,  4,  1,  0]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[3, 3, 2, 2],\n                               [2, 2, 1, 1],\n                               [1, 1, 0, 0]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1,  3, -1,  2],\n                               [-1, -1, -1,  1],\n                               [-1, -1, -1,  0]]))\n```\n\n\n```python\ntheta = (8/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[11, 10,  9,  8],\n                               [ 7,  6,  5,  4],\n                               [ 3,  2,  1,  0]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[2, 2, 2, 2],\n                               [1, 1, 1, 1],\n                               [0, 0, 0, 0]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1, -1, -1,  2],\n                               [-1, -1, -1,  1],\n                               [-1, -1, -1,  0]]))\n```\n\n\n```python\ntheta = (9/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 7, 10,  9, 11],\n                               [ 3,  6,  5,  8],\n                               [ 0,  2,  1,  4]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[2, 3, 3, 4],\n                               [1, 2, 2, 3],\n                               [0, 1, 1, 2]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1, -1, -1,  4],\n                               [-1, -1, -1,  3],\n                               [ 0, -1,  1,  2]]))\n```\n\n\n```python\ntheta = (10/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 5,  8, 10, 11],\n                               [ 2,  4,  7,  9],\n                               [ 0,  1,  3,  6]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[2, 3, 4, 5],\n                               [1, 2, 3, 4],\n                               [0, 1, 2, 3]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1, -1, -1,  5],\n                               [-1, -1, -1,  4],\n                               [ 0,  1,  2,  3]]))\n```\n\n\n```python\ntheta = (11/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 4,  7, 10, 11],\n                               [ 1,  3,  6,  9],\n                               [ 0,  2,  5,  8]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[1, 2, 3, 4],\n                               [0, 1, 2, 3],\n                               [0, 1, 2, 3]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1, -1, -1,  4],\n                               [-1, -1, -1, -1],\n                               [ 0,  1,  2,  3]]))\n```\n\n\n```python\ntheta = (12/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 2,  5,  8, 11],\n                               [ 1,  4,  7, 10],\n                               [ 0,  3,  6,  9]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[0, 1, 2, 3],\n                               [0, 1, 2, 3],\n                               [0, 1, 2, 3]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[-1, -1, -1, -1],\n                               [-1, -1, -1, -1],\n                               [ 0,  1,  2,  3]]))\n```\n\n\n```python\ntheta = (13/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 0,  3,  6,  9],\n                               [ 2,  5,  8, 11],\n                               [ 1,  4,  7, 10]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[0, 1, 2, 3],\n                               [1, 2, 3, 4],\n                               [1, 2, 3, 4]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 0, -1, -1, -1],\n                               [-1, -1, -1, -1],\n                               [ 1,  2,  3,  4]]))\n```\n\n\n```python\ntheta = (14/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 0,  2,  5,  8],\n                               [ 1,  4,  7, 10],\n                               [ 3,  6,  9, 11]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[0, 1, 2, 3],\n                               [1, 2, 3, 4],\n                               [2, 3, 4, 5]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 0, -1, -1, -1],\n                               [ 1, -1, -1, -1],\n                               [ 2,  3,  4,  5]]))\n```\n\n\n```python\ntheta = (15/8)*np.pi\narr[:] = -1; line_loop(arr, theta, callback_itfill())\nassert_allclose(arr, np.array([[ 0,  1,  4,  5],\n                               [ 2,  3,  8,  9],\n                               [ 6,  7, 10, 11]]))\narr[:] = -1; line_loop(arr, theta, callback_linefill())\nassert_allclose(arr, np.array([[0, 0, 1, 1],\n                               [1, 1, 2, 2],\n                               [2, 2, 3, 3]]))\narr[:] = -1; line_loop(arr, theta, callback_startfill())\nassert_allclose(arr, np.array([[ 0, -1, -1, -1],\n                               [ 1, -1, -1, -1],\n                               [ 2, -1,  3, -1]]))\n```\n\n### SGM implementation\n\nFirst, we need to precompute the disparity losses for the entire array; this buffer can be quite large for large images\n\n\n```python\n# export\n@numba.jit(nopython=True, parallel=True)\ndef rect_loss_arr(arr1, arr2, r_disp, hw, loss, buf_loss, arr_disp_init=None):\n    h_arr, w_arr = arr1.shape\n    for i in numba.prange(h_arr):\n        rect_loss_l(arr1, arr2, i, r_disp, hw, loss, buf_loss[i], arr_disp_init)\n```\n\n\n```python\n# export\n@numba.experimental.jitclass([('buf_accum', numba.float64[:,:,:]), \n                              ('buf_move', numba.float64[:,:]),\n                              ('x_prev', numba.int32), \n                              ('y_prev', numba.int32),\n                              ('max_change', numba.int32),\n                              ('penalty_disp', numba.int32)])\nclass callback_sgm(object):\n    def __init__(self, sz, r_disp, max_change, penalty_disp):\n        self.buf_accum = np.empty((sz[0], sz[1], r_disp[1]-r_disp[0]+1))\n        self.buf_move = np.empty((2*max_change+1, r_disp[1]-r_disp[0]+1))\n        self.x_prev, self.y_prev = -1, -1\n        self.max_change, self.penalty_disp = max_change, penalty_disp\n\n    def start_line(self, arr, x, y):\n        self.buf_accum[y, x] = arr[y, x] # Initialize\n        self.x_prev, self.y_prev = x, y\n\n    def in_line(self, arr, x, y):\n        # Get loss of each move\n        self.buf_move[:] = np.inf\n        for j in range(-self.max_change, self.max_change+1):\n            idx_minl, idx_maxl = max( j,0), min(self.buf_move.shape[1]+j,self.buf_move.shape[1])\n            idx_minm, idx_maxm = max(-j,0), min(self.buf_move.shape[1]-j,self.buf_move.shape[1])\n            self.buf_move[j+max_change, idx_minm:idx_maxm] = \\\n                self.buf_accum[self.y_prev, self.x_prev, idx_minl:idx_maxl] + abs(j)*self.penalty_disp\n\n        # Get optimal cost and store it\n        for j in range(self.buf_move.shape[1]):\n            self.buf_accum[y, x, j] = arr[y, x, j] + np.min(self.buf_move[:, j])\n\n        self.x_prev, self.y_prev = x, y\n```\n\nPrecompute loss array\n\n\n```python\nr_disp = (-15, 15)\n```\n\n\n```python\nbuf_loss = np.empty((arr1.shape[0], arr1.shape[1], r_disp[1]-r_disp[0]+1))\nrect_loss_arr(arr1, arr2, r_disp, hw, loss, buf_loss)\n```\n\nGet SGM callback\n\n\n```python\ncallback = callback_sgm(arr1.shape, r_disp, max_change, penalty_disp)\n```\n\nPlot each direction\n\n\n```python\nfig, axs = plt.subplots(4, 4, figsize=(20, 20))\nfor idx, ax in enumerate(axs.flatten()):\n    theta = (idx/8)*np.pi\n    line_loop(buf_loss, theta, callback)\n    ax.imshow(np.argmin(callback.buf_accum, axis=2))\n    ax.set_title(f'Theta: {theta}')\n```\n\n\n![png](README_files/README_168_0.png)\n\n\nMake api for sgm\n\n\n```python\n# export\n@numba.jit(nopython=True, parallel=True)\ndef rect_match_arr_sgm(arr1, arr2, r_disp, hw, loss, max_change, penalty_disp, thetas, arr_disp_init=None):\n    h_arr, w_arr = arr1.shape[0], arr1.shape[1]\n\n    # Precompute losses\n    buf_loss = np.empty((h_arr, w_arr, r_disp[1]-r_disp[0]+1))\n    rect_loss_arr(arr1, arr2, r_disp, hw, loss, buf_loss, arr_disp_init)\n\n    # Do SGM accumulation\n    callback = callback_sgm(arr1.shape, r_disp, max_change, penalty_disp)\n    buf_accum = np.zeros((h_arr, w_arr, r_disp[1]-r_disp[0]+1))\n    for theta in thetas:\n        line_loop(buf_loss, theta, callback)\n        buf_accum += callback.buf_accum\n\n    # Get disparity map\n    arr_disp = np.empty((h_arr, w_arr))\n    for i in range(arr1.shape[0]):\n        for j in range(arr2.shape[1]):\n            arr_disp[i, j] = np.argmin(buf_accum[i, j]) + r_disp[0]\n    if arr_disp_init is not None: arr_disp += arr_disp_init\n    return arr_disp\n```\n\n\n```python\n# export\ndef make_rect_match_arr_sgm(r_disp, hw, loss, max_change, penalty_disp, thetas):\n    @numba.jit(nopython=True)\n    def rect_match_arr(arr1, arr2, arr_disp_init=None):\n        return rect_match_arr_sgm(arr1, arr2, r_disp, hw, loss, max_change, penalty_disp, thetas, arr_disp_init)\n    return rect_match_arr\n```\n\n\n```python\nhw = 15\nnum_directions = 16\nthetas = np.linspace(0, 2*np.pi, num_directions+1)[:-1]\n```\n\n\n```python\nrect_match_arr = make_rect_match_arr_sgm(r_disp, hw, loss, max_change, penalty_disp, thetas)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\n\n```python\narr_disp = rect_match_arr(arr1, arr2)\n```\n\nI think this is slower primarily because input to the line looper is a class, so I think the callback isn't getting inlined which incurs more overhead, but not sure.\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c51ddc4d0>\n\n\n\n\n![png](README_files/README_177_1.png)\n\n\nTry pyramid\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n\n```python\narr_disp = rect_match_pyr(arr1, arr2, rect_match_arr)\n```\n\n\n```python\n_, axs = plt.subplots(1, 2, figsize=(15,10))\naxs[0].imshow(arr_disp, vmin=-15, vmax=15)\naxs[1].imshow(arr1)\naxs[1].imshow(arr_disp, vmin=-15, vmax=15, alpha=0.5)\n```\n\n\n\n\n    <matplotlib.image.AxesImage at 0x7f3c518bda10>\n\n\n\n\n![png](README_files/README_181_1.png)\n\n\nIt's slower... probably because overhead within the sgm call, so pyramiding doesn't help, and might look worse because smoothness contraints are only applied for new disparities added at the every level, so it won't be as smooth.\n\n# API\n\n\n```python\n# export\nclass RectMatch:\n    def __init__(self, type_rect_match, hw=15, r_disp=(-15,15), loss=SAD, max_change=3, penalty_disp=2, steps=1):\n        if type_rect_match in ['int', 'sub', 'int_dp', 'sub_dp']:\n            if   type_rect_match == 'int':\n                min_path = min_path_int\n            elif type_rect_match == 'sub':\n                min_path = min_path_sub\n            elif type_rect_match == 'int_dp': \n                min_path = make_min_path_int_dp(r_disp, max_change, penalty_disp)\n            elif type_rect_match == 'sub_dp':\n                min_path = make_min_path_sub_dp(r_disp, max_change, penalty_disp)\n            rect_match_arr = make_rect_match_arr_min_path(r_disp, hw, loss, min_path)\n        elif type_rect_match == 'sgm':    \n            rect_match_arr = make_rect_match_arr_sgm(r_disp, hw, loss, max_change, penalty_disp, thetas)\n        else: \n            raise RuntimeError(f'Unrecognized min path type: {type_rect_match}')\n        self.rect_match_arr, self.steps = rect_match_arr, steps\n\n    def __call__(self, arr1, arr2): \n        return rect_match_pyr(arr1, arr2, self.rect_match_arr, self.steps)\n```\n\n\n```python\ntypes_rect_match = ['int', 'sub', 'int_dp', 'sub_dp', 'sgm']\nrect_matchs = [RectMatch(type_rect_match) for type_rect_match in types_rect_match]\n```\n\n\n```python\n_, axs = plt.subplots(3, 2, figsize=(15,20))\nfor ax, rect_match, type_rect_match in zip(axs.ravel(), rect_matchs, types_rect_match): \n    ax.imshow(rect_match(arr1, arr2), vmin=-15, vmax=15)\n    ax.set_title(type_rect_match)\naxs[2,1].set_visible(False)\n```\n\n\n![png](README_files/README_186_0.png)\n\n\n# Build\n\n\n```python\nbuild_notebook()\n```\n\n\n    <IPython.core.display.Javascript object>\n\n\n    Converted README.ipynb.\n\n\n\n```python\nconvert_notebook()\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/justinblaber/disparity/tree/master/",
    "keywords": "disparity",
    "license": "Apache Software License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "disparity",
    "package_url": "https://pypi.org/project/disparity/",
    "platform": "",
    "project_url": "https://pypi.org/project/disparity/",
    "project_urls": {
      "Homepage": "https://github.com/justinblaber/disparity/tree/master/"
    },
    "release_url": "https://pypi.org/project/disparity/0.0.5/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Computing disparity maps",
    "version": "0.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8221626,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "116187d969b88b9d3cadf5b7679cab4ed9c45ca5962fdaff0502264c30b20a00",
          "md5": "d1d2bb57bb30349aec241c6162e420e2",
          "sha256": "116bf42b1b16342eca7a2c93853b50dbc039177eda3fa9ae61b6406f4f98ec9b"
        },
        "downloads": -1,
        "filename": "disparity-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d1d2bb57bb30349aec241c6162e420e2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 15807,
        "upload_time": "2020-08-30T23:20:04",
        "upload_time_iso_8601": "2020-08-30T23:20:04.728438Z",
        "url": "https://files.pythonhosted.org/packages/11/61/87d969b88b9d3cadf5b7679cab4ed9c45ca5962fdaff0502264c30b20a00/disparity-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e657108096da00eae6321d7349511845edfc9a576970b2e567bde29737fc4e58",
          "md5": "b51340d1ab5969a115cb788d36c7ab7a",
          "sha256": "12f809fa1d5dbfc518437fe33bd709cdbe1adff2eedf324d0ec82290ff9676cf"
        },
        "downloads": -1,
        "filename": "disparity-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b51340d1ab5969a115cb788d36c7ab7a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29037,
        "upload_time": "2020-08-30T23:20:08",
        "upload_time_iso_8601": "2020-08-30T23:20:08.318722Z",
        "url": "https://files.pythonhosted.org/packages/e6/57/108096da00eae6321d7349511845edfc9a576970b2e567bde29737fc4e58/disparity-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "15dd0e2d5a6b83086fafc32e973eb1096129860c1d67846c20b7afdbcaef6e9c",
          "md5": "609503d2f6fc34f6ef14989a3e39f123",
          "sha256": "9d103dff3f94e5298c99981a41d386b2241c380e704430f472c36a8e70b7605f"
        },
        "downloads": -1,
        "filename": "disparity-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "609503d2f6fc34f6ef14989a3e39f123",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 15849,
        "upload_time": "2020-09-02T12:04:40",
        "upload_time_iso_8601": "2020-09-02T12:04:40.827756Z",
        "url": "https://files.pythonhosted.org/packages/15/dd/0e2d5a6b83086fafc32e973eb1096129860c1d67846c20b7afdbcaef6e9c/disparity-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2837755dea015d7ec083a8f8a97956e5838e4c0368f81ec8cdadf3e068d7452d",
          "md5": "90cd9c88f40ff4f1b2930e060fd8609c",
          "sha256": "4891af3b1f5abdab7c0b42acec08e7b999727986f680f14e17780141aab41739"
        },
        "downloads": -1,
        "filename": "disparity-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "90cd9c88f40ff4f1b2930e060fd8609c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29117,
        "upload_time": "2020-09-02T12:04:42",
        "upload_time_iso_8601": "2020-09-02T12:04:42.722002Z",
        "url": "https://files.pythonhosted.org/packages/28/37/755dea015d7ec083a8f8a97956e5838e4c0368f81ec8cdadf3e068d7452d/disparity-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bae5e427d974c2644156cbfe8b1745c5376cb8dec21def73098c4fa115e9a0cb",
          "md5": "ca5d5ebdab1e617d9cbef4804e6935c4",
          "sha256": "df3118ba686f2bc8c5e08dd6ffb0875b602f63e0bf369ce98bc973aafbcd6734"
        },
        "downloads": -1,
        "filename": "disparity-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ca5d5ebdab1e617d9cbef4804e6935c4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 20073,
        "upload_time": "2020-09-18T01:06:22",
        "upload_time_iso_8601": "2020-09-18T01:06:22.848342Z",
        "url": "https://files.pythonhosted.org/packages/ba/e5/e427d974c2644156cbfe8b1745c5376cb8dec21def73098c4fa115e9a0cb/disparity-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7711c6c8dbabe058c7fca61e65f37158ae77c51124e5b1c01ba51b104bf2c97f",
          "md5": "3849e62e3101884909d77f9fd33efa4b",
          "sha256": "493df204ea2ee7cb642b4e994231442d6d98f9f6259e2308c980f6586de17f82"
        },
        "downloads": -1,
        "filename": "disparity-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "3849e62e3101884909d77f9fd33efa4b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 40778,
        "upload_time": "2020-09-18T01:06:25",
        "upload_time_iso_8601": "2020-09-18T01:06:25.956914Z",
        "url": "https://files.pythonhosted.org/packages/77/11/c6c8dbabe058c7fca61e65f37158ae77c51124e5b1c01ba51b104bf2c97f/disparity-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0a4dc1ad49bc59d0d78997e33db254f21b6faff94d5f7a9b9eb3c1b84ba8dd59",
          "md5": "ea648826c575b0fb9972060c6137b4b4",
          "sha256": "6c97e87ed70e42cafe27105c16a4ac8b0a38138b847178546b32ad6b958687b5"
        },
        "downloads": -1,
        "filename": "disparity-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ea648826c575b0fb9972060c6137b4b4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 20061,
        "upload_time": "2020-09-18T23:50:00",
        "upload_time_iso_8601": "2020-09-18T23:50:00.507386Z",
        "url": "https://files.pythonhosted.org/packages/0a/4d/c1ad49bc59d0d78997e33db254f21b6faff94d5f7a9b9eb3c1b84ba8dd59/disparity-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dff2acfd46d97019ae2a032df3b26ed003acdf4e6ed1ca24f5b4925b44e4bb9d",
          "md5": "ceda940bb8e94d2657462919e8fcaa20",
          "sha256": "094df2c64070096da0e858f26efd50cdd1e2edd7be358d5d1e9b6317e90b297c"
        },
        "downloads": -1,
        "filename": "disparity-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "ceda940bb8e94d2657462919e8fcaa20",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 40765,
        "upload_time": "2020-09-18T23:50:03",
        "upload_time_iso_8601": "2020-09-18T23:50:03.622229Z",
        "url": "https://files.pythonhosted.org/packages/df/f2/acfd46d97019ae2a032df3b26ed003acdf4e6ed1ca24f5b4925b44e4bb9d/disparity-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0a4dc1ad49bc59d0d78997e33db254f21b6faff94d5f7a9b9eb3c1b84ba8dd59",
        "md5": "ea648826c575b0fb9972060c6137b4b4",
        "sha256": "6c97e87ed70e42cafe27105c16a4ac8b0a38138b847178546b32ad6b958687b5"
      },
      "downloads": -1,
      "filename": "disparity-0.0.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "ea648826c575b0fb9972060c6137b4b4",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 20061,
      "upload_time": "2020-09-18T23:50:00",
      "upload_time_iso_8601": "2020-09-18T23:50:00.507386Z",
      "url": "https://files.pythonhosted.org/packages/0a/4d/c1ad49bc59d0d78997e33db254f21b6faff94d5f7a9b9eb3c1b84ba8dd59/disparity-0.0.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "dff2acfd46d97019ae2a032df3b26ed003acdf4e6ed1ca24f5b4925b44e4bb9d",
        "md5": "ceda940bb8e94d2657462919e8fcaa20",
        "sha256": "094df2c64070096da0e858f26efd50cdd1e2edd7be358d5d1e9b6317e90b297c"
      },
      "downloads": -1,
      "filename": "disparity-0.0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "ceda940bb8e94d2657462919e8fcaa20",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 40765,
      "upload_time": "2020-09-18T23:50:03",
      "upload_time_iso_8601": "2020-09-18T23:50:03.622229Z",
      "url": "https://files.pythonhosted.org/packages/df/f2/acfd46d97019ae2a032df3b26ed003acdf4e6ed1ca24f5b4925b44e4bb9d/disparity-0.0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}