{
  "info": {
    "author": "Agendaless Consulting",
    "author_email": "pylons-discuss@googlegroups.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.2",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy"
    ],
    "description": "Colander\n========\n\nAn extensible package which can be used to:\n\n- deserialize and validate a data structure composed of strings,\n  mappings, and lists.\n\n- serialize an arbitrary data structure to a data structure composed\n  of strings, mappings, and lists.\n\nIt runs on Python 2.6, 2.7, 3.2, and 3.3.\n\nPlease see http://docs.pylonsproject.org/projects/colander/en/latest/\nfor further documentation.\n\nSee https://github.com/Pylons/colander for in-development version.\n\n\nUnreleased\n----------\n\nBug Fixes\n~~~~~~~~~\n\n- Removed forked iso8601 and change to dependency on pypi iso8601\n  (due to float rounding bug on microsecond portion when parsing\n  iso8601 datetime string).  Left an iso8601.py stub for backwards\n  compatibility.\n\n- Time of \"00:00\" no longer gives ``colander.Invalid``.\n\n- Un-break wrapping of callable instances as ``colander.deferred``.\n  See https://github.com/Pylons/colander/issues/141.\n\n- Set the max length TLD to 22 in ``Email`` validator based on the\n  current list of valid TLDs.\n  See https://github.com/Pylons/colander/issues/159\n\n- Fix an issue where ``drop`` was not recognized as a default and was\n  returning the ``drop`` instance instead of omitting the value.\n  https://github.com/Pylons/colander/issues/139\n\n- Fix an issue where the ``SchemaNode.title`` was clobbered by the ``name``\n  when defined as a class attribute.\n  See https://github.com/Pylons/colander/pull/183 and\n  https://github.com/Pylons/colander/pull/185\n\nFeatures\n~~~~~~~~\n\n- Add `Any` validator which succeeds if at least one of its subvalidators\n  succeeded.\n\n- Allow localization of error messages returned by ``colander.Invalid.asdict``\n  by adding an optional ``translate`` callable argument.\n\n1.0b1 (2013-09-01)\n------------------\n\nBug Fixes\n~~~~~~~~~\n\n- In 1.0a1, there was a change merged from\n  https://github.com/Pylons/colander/pull/73 which made it possible to supply\n  ``None`` as the ``default`` value for a String type, and upon serialization,\n  the value would be rendered as ``colander.null`` if the default were used.\n  This confused people who were actually supplying the value ``None`` as a\n  default when the associated appstruct had no value, so the change has been\n  reverted.  When you supply ``None`` as the ``default`` argument to a String,\n  the rendered serialize() value will again be ``'None'``.  Sorry.\n\n- Normalize ``colander.Function`` argument ``message`` to be ``msg``. This now\n  matches other APIs within Colander. The ``message`` argument is now\n  deprecated and a warning will be emitted.\n  https://github.com/Pylons/colander/issues/31\n  https://github.com/Pylons/colander/issues/64\n\n- ``iso8601.py``:  Convert ``ValueError`` (raised by ``datetime``) into\n  ``ParseErrorr`` in ``parse_date``, so that the validation machinery\n  upstream handles it properly.\n\n- ``iso8601.py``:  Correctly parse datetimes with a timezone of Z even\n  when the default_timezone is set. These previously had the default\n  timezone.\n\n- ``colander.String`` schema type now raises ``colander.Invalid`` when trying\n  to deserialize a non-string item.\n  See https://github.com/Pylons/colander/issues/100\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.List`` type, modeled on ``deform.List``:  this type\n  preserves ordering, and allows duplicates.\n\n- It is now possible to use the value ``colander.drop`` as the ``default``\n  value for items that are subitems of a mapping.  If ``colander.drop`` is used\n  as the ``default`` for a subnode of a mapping schema, and the mapping\n  appstruct being serialized does not have a value for that schema node, the\n  value will be omitted from the serialized mapping.  For instance, the\n  following script, when run would not raise an assertion error::\n\n      class What(colander.MappingSchema):\n        thing = colander.SchemaNode(colander.String(), default=colander.drop)\n\n      result = What().serialize({}) # no \"thing\" in mapping\n      assert result == {}\n\n- The ``typ`` of a ``SchemaNode`` can optionally be pased in as a keyword\n  argument. See https://github.com/Pylons/colander/issues/90\n\n- Add a ``missing_msg`` argument to ``SchemaNode`` that specifies the error\n  message to be used when the node is required and missing\n\n1.0a5 (2013-05-31)\n------------------\n\n- Fix bug introduced by supporting spec-mandated truncations of ISO-8601\n  timezones.  A TypeError would be raised instead of Invalid.  See\n  https://github.com/Pylons/colander/issues/111.\n\n1.0a4 (2013-05-21)\n------------------\n\n- Loosen Email validator regex (permit apostrophes, bang, etc in localpart).\n\n- Allow for timezone info objects to be pickled and unpickled \"more correctly\"\n  (Use '__getinitargs__' to provide unpickling-only defaults).  See\n  https://github.com/Pylons/colander/pull/108.\n\n1.0a3 (2013-05-16)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Support spec-mandated truncations of ISO-8601 timezones.\n\n- Support spec-mandated truncations of ISO-8601 datetimes.\n\n- Allow specifying custom representations of values for boolean fields.\n\nBug Fixes\n~~~~~~~~~\n\n- Ensure that ``colander.iso8601.FixedOffset`` instances can be unpickled.\n\n- Avoid validating strings as sequences under Py3k.\n\n- Sync documentation with 0.9.9 change to use ``insert_before`` rather than\n  ``schema_order``.  See https://github.com/Pylons/colander/issues/104\n\n\n1.0a2 (2013-01-30)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.ContainsOnly`` and ``colander.url`` validators.\n\n- Add ``colander.instantiate`` to help define schemas containing\n  mappings and sequences more succinctly.\n\n1.0a1 (2013-01-10)\n------------------\n\nBug Fixes\n~~~~~~~~~\n\n- Work around a regression in Python 3.3 for ``colander.Decimal`` when it's\n  used with a ``quant`` argument but without a ``rounding`` argument.\n  See https://github.com/Pylons/colander/issues/66\n\n- Using ``SchemaNode(String, default='', ..)`` now works properly, or at least\n  more intuitively.  Previously if an empty-string ``default`` was supplied,\n  serialization would return a defaulted value as ``colander.null``.  See\n  https://github.com/Pylons/colander/pull/73.\n\n- Stricter checking in colander.Mapping to prevent items which are logically\n  not mappings from being accepted during validation (see\n  https://github.com/Pylons/colander/pull/96).\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.Set`` type, ported from ``deform.Set``\n\n- Add Python 3.3 to tox configuration and use newer tox testing regime\n  (setup.py dev).\n\n- Add Python 3.3 Trove classifier.\n\n- Calling ``bind`` on a schema node e.g. ``cloned_node = somenode.bind(a=1,\n  b=2)`` on a schema node now results in the cloned node having a\n  ``bindings`` attribute of the value ``{'a':1, 'b':2}``.\n\n- It is no longer necessary to pass a ``typ`` argument to a SchemaNode\n  constructor if the node class has a ``schema_type`` callable as a class\n  attribute which, when called with no arguments, returns a schema type.\n  This callable will be called to obtain the schema type if a ``typ`` is not\n  supplied to the constructor.  The default ``SchemaNode`` object's\n  ``schema_type`` callable raises a ``NotImplementedError`` when it is\n  called.\n\n- SchemaNode now has a ``raise_invalid`` method which accepts a message and\n  raises a colander.Invalid exception using ``self`` as the node and the\n  message as its message.\n\n- It is now possible and advisable to subclass ``SchemaNode`` in order to\n  create a bundle of default node behavior.  The subclass can define the\n  following methods and attributes: ``preparer``, ``validator``, ``default``,\n  ``missing``, ``name``, ``title``, ``description``, ``widget``, and\n  ``after_bind``.\n\n  For example, the older, more imperative style that looked like this still\n  works, of course::\n\n     from colander import SchemaNode\n\n     ranged_int = colander.SchemaNode(\n         validator=colander.Range(0, 10),\n         default = 10,\n         title='Ranged Int'\n         )\n\n  But you can alternately now do something like this::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         validator = colander.Range(0, 10)\n         default = 10\n         title = 'Ranged Int'\n\n     ranged_int = RangedInt()\n\n  Values that are expected to be callables can now alternately be methods of\n  the schemanode subclass instead of plain attributes::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         def validator(self, node, cstruct):\n            if not 0 < cstruct < 10:\n                raise colander.Invalid(node, 'Must be between 0 and 10')\n\n     ranged_int = RangedInt()\n\n  Note that when implementing a method value such as ``validator`` that\n  expects to receive a ``node`` argument, ``node`` must be provided in the\n  call signature, even though ``node`` will almost always be the same as\n  ``self``.  This is because Colander simply treats the method as another\n  kind of callable, be it a method, or a function, or an instance that has a\n  ``__call__`` method.  It doesn't care that it happens to be a method of\n  ``self``, and it needs to support callables that are not methods, so it\n  sends ``node`` in regardless.\n\n  You can't currently use *method* definitions as ``colander.deferred``\n  callables.  For example this will *not* work::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         @colander.deferred\n         def validator(self, node, kw):\n            request = kw['request']\n            def avalidator(node, cstruct):\n                if not 0 < cstruct < 10:\n                    if request.user != 'admin':\n                        raise colander.Invalid(node, 'Must be between 0 and 10')\n            return avalidator\n\n     ranged_int = RangedInt()\n     bound_ranged_int = ranged_int.bind(request=request)\n\n  This will result in::\n\n        TypeError: avalidator() takes exactly 3 arguments (2 given)\n\n  However, if you treat the thing being decorated as a function instead of a\n  method (remove the ``self`` argument from the argument list), it will\n  indeed work)::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         @colander.deferred\n         def validator(node, kw):\n            request = kw['request']\n            def avalidator(node, cstruct):\n                if not 0 < cstruct < 10:\n                    if request.user != 'admin':\n                        raise colander.Invalid(node, 'Must be between 0 and 10')\n            return avalidator\n\n     ranged_int = RangedInt()\n     bound_ranged_int = ranged_int.bind(request=request)\n\n  In previous releases of Colander, the only way to defer the computation of\n  values was via the ``colander.deferred`` decorator.  In this release,\n  however, you can instead use the ``bindings`` attribute of ``self`` to\n  obtain access to the bind parameters within values that are plain old\n  methods::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         def validator(self, node, cstruct):\n            request = self.bindings['request']\n            if not 0 < cstruct < 10:\n                if request.user != 'admin':\n                    raise colander.Invalid(node, 'Must be between 0 and 10')\n\n     ranged_int = RangedInt()\n     bound_range_int = ranged_int.bind(request=request)\n\n  If the things you're trying to defer aren't callables like ``validator``,\n  but they're instead just plain attributes like ``missing`` or ``default``,\n  instead of using a ``colander.deferred``, you can use ``after_bind`` to set\n  attributes of the schemanode that rely on binding variables::\n\n     from colander import SchemaNode\n\n     class UserIdSchemaNode(SchemaNode):\n         title = 'User Id'\n\n         def after_bind(self, node, kw):\n             self.default = kw['request'].user.id\n\n  You can override the default values of a schemanode subclass in its\n  constructor::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n         validator = colander.Range(0, 10)\n\n     ranged_int = RangedInt(validator=colander.Range(0, 20))\n\n  In the above example, the validation will be done on 0-20, not 0-10.\n\n  If a schema node name conflicts with a schema value attribute name on the\n  same class, you can work around it by giving the schema node a bogus name\n  in the class definition but providing a correct ``name`` argument to the\n  schema node constructor::\n\n     from colander import SchemaNode, Schema\n\n     class SomeSchema(Schema):\n         title = 'Some Schema'\n         thisnamewillbeignored = colander.SchemaNode(\n                                             colander.String(),\n                                             name='title'\n                                             )\n\n  Note that such a workaround is only required if the conflicting names are\n  attached to the *exact same* class definition.  Colander scrapes off schema\n  node definitions at each class' construction time, so it's not an issue for\n  inherited values.  For example::\n\n     from colander import SchemaNode, Schema\n\n     class SomeSchema(Schema):\n         title = colander.SchemaNode(colander.String())\n\n     class AnotherSchema(SomeSchema):\n         title = 'Some Schema'\n\n     schema = AnotherSchema()\n\n  In the above example, even though the ``title = 'Some Schema'`` appears to\n  override the superclass' ``title`` SchemaNode, a ``title`` SchemaNode will\n  indeed be present in the child list of the ``schema`` instance\n  (``schema['title']`` will return the ``title`` SchemaNode) and the schema's\n  ``title`` attribute will be ``Some Schema`` (``schema.title`` will return\n  ``Some Schema``).\n\n  Normal inheritance rules apply to class attributes and methods defined in\n  a schemanode subclass.  If your schemanode subclass inherits from another\n  schemanode class, your schemanode subclass' methods and class attributes\n  will override the superclass' methods and class attributes.\n\n  Ordering of child schema nodes when inheritance is used works like this:\n  the \"deepest\" SchemaNode class in the MRO of the inheritance chain is\n  consulted first for nodes, then the next deepest, then the next, and so on.\n  So the deepest class' nodes come first in the relative ordering of schema\n  nodes, then the next deepest, and so on.  For example::\n\n      class One(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a1',\n              )\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b1',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d1',\n              )\n\n      class Two(One):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a2',\n              )\n          c = colander.SchemaNode(\n              colander.String(), \n              id='c2',\n              )\n          e = colander.SchemaNode(\n              colander.String(),\n              id='e2',\n              )\n\n      class Three(Two):\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b3',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d3',\n              )\n          f = colander.SchemaNode(\n              colander.String(),\n              id='f3',\n              )\n\n      three = Three()\n\n  The ordering of child nodes computed in the schema node ``three`` will be\n  ``['a2', 'b3', 'd3', 'c2', 'e2', 'f3']``.  The ordering starts ``a1``,\n  ``b1``, ``d1`` because that's the ordering of nodes in ``One``, and\n  ``One`` is the deepest SchemaNode in the inheritance hierarchy.  Then it\n  processes the nodes attached to ``Two``, the next deepest, which causes\n  ``a1`` to be replaced by ``a2``, and ``c2`` and ``e2`` to be appended to\n  the node list.  Then finally it processes the nodes attached to ``Three``,\n  which causes ``b1`` to be replaced by ``b3``, and ``d1`` to be replaced by\n  ``d3``, then finally ``f`` is appended.\n\n  Multiple inheritance works the same way::\n\n      class One(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a1',\n              )\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b1',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d1',\n              )\n\n      class Two(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a2',\n              )\n          c = colander.SchemaNode(\n              colander.String(), \n              id='c2',\n              )\n          e = colander.SchemaNode(\n              colander.String(),\n              id='e2',\n              )\n\n      class Three(Two, One):\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b3',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d3',\n              )\n          f = colander.SchemaNode(\n              colander.String(),\n              id='f3',\n              )\n\n      three = Three()\n\n  The resulting node ordering of ``three`` is the same as the single\n  inheritance example: ``['a2', 'b3', 'd3', 'c2', 'e2', 'f3']`` due to the\n  MRO deepest-first ordering (``One``, then ``Two``, then ``Three``).\n\nBackwards Incompatibilities\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Passing non-SchemaNode derivative instances as ``*children`` into a\n  SchemaNode constructor is no longer supported.  Symptom: ``AttributeError:\n  name`` when constructing a SchemaNode.\n\n0.9.9 (2012-09-24)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Allow the use of ``missing=None`` for Number.  See\n  https://github.com/Pylons/colander/pull/59 .\n\n- Create a ``colander.Money`` type that is a Decimal type with\n  two-decimal-point precision rounded-up.\n\n- Allow ``quant`` and ``rounding`` args to ``colander.Decimal`` constructor.\n\n- ``luhnok`` validator added (credit card luhn mod10 validator).\n\n- Add an ``insert`` method to SchemaNode objects.\n\n- Add an ``insert_before`` method to SchemaNode objects.\n\n- Better class-based mapping schema inheritance model.\n\n  * A node declared in a subclass of a mapping schema superclass now\n    overrides any node with the same name inherited from any superclass.\n    Previously, it just repeated and didn't override.\n\n  * An ``insert_before`` keyword argument may be passed to a SchemaNode\n    constructor.  This is a string naming a node in a superclass.  A node\n    with an ``insert_before`` will be placed before the named node in a\n    parent mapping schema.\n\n- The ``preparer=`` argument to SchemaNodes may now be a sequence of\n  preparers.\n\n- Added a ``cstruct_children`` method to SchemaNode.\n\n- A new ``cstruct_children`` API should exist on schema types.  If\n  ``SchemaNode.cstruct_children`` is called on a node with a type that does\n  not have a ``cstruct_children`` method, a deprecation warning is emitted\n  and ``[]`` is returned (this may or may not be the correct value for your\n  custom type).\n\nBackwards Incompatibilities\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- The inheritance changes required a minor backwards incompatibility: calling\n  ``__setitem__`` on a SchemaNode will no longer raise ``KeyError`` when\n  attempting to set a subnode into a node that doesn't already have an\n  existing subnode by that name.  Instead, the subnode will be appended to\n  the child list.\n\nDocumentation\n~~~~~~~~~~~~~\n\n- A \"Schema Inheritance\" section was added to the Basics chapter\n  documentation.\n\n0.9.8 (2012-04-27)\n------------------\n\n- False evaluating values are now serialized to colander.null for\n  String, Date, and Time.  This resolves the issue where a None value\n  would be rendered as 'None' for String, and missing='None' was not\n  possible for Date, Datetime, and Time.\n  See https://github.com/Pylons/colander/pull/1 .\n\n- Updated Brazilian Portugese translations.\n\n- Updated Japanese translations.\n\n- Updated Russian translations.\n\n- Fix documentation: 0.9.3 allowed explicitly passing None to DateTime\n  to have no default timezone applied.\n\n- Add ``dev`` and ``docs`` setup.py aliases (e.g. ``python setup.py dev``).\n\n0.9.7 (2012-03-20)\n------------------\n\n- Using ``schema.flatten(...)`` against a mapping schema node without a name\n  produced incorrectly dot-prefixed keys.  See\n  https://github.com/Pylons/colander/issues/37\n\n- Fix invalid.asdict for multiple error messages.  See\n  https://github.com/Pylons/colander/pull/22 ,\n  https://github.com/Pylons/colander/pull/27 ,\n  https://github.com/Pylons/colander/pull/12 , and\n  https://github.com/Pylons/colander/issues/2 .\n\n- Invalid.messages() now returns an empty list if there are no messages.\n  See https://github.com/Pylons/colander/pull/21 .\n\n- ``name`` passed to a SchemaNode constructor was not respected in\n  declaratively constructed schemas.  Now if you pass ``name`` to the\n  SchemaNode constructor within the body of a schema class, it will take\n  precedence over the name it's been assigned to in the schema class.\n  See https://github.com/Pylons/colander/issues/39 .\n\n- Japanese translation thanks to OCHIAI, Gouji.\n\n- Replaced incorrect ``%{err}`` with correct ``${err}`` in String.deserialize\n  error message.  See https://github.com/Pylons/colander/pull/41\n\n0.9.6 (2012-02-14)\n------------------\n\n- No longer runs on Python 2.4 or 2.5.  Python 2.6+ is now required.\n\n- Python 3.2 compatibility.\n\n- Removed a dependency on the iso8601 package (code from the package is now\n  inlined in Colander itself).\n\n- Added copyright and licensing information for iso8601-derived code to\n  LICENSE.txt.\n\n0.9.5 (2012-01-13)\n------------------\n\n- Added Czech translation.\n\n- Compile pt_BR translation (it was previously uncompiled).\n\n- Minor docs fixes.\n\n- Documentation added about flatten and unflatten.\n\n0.9.4 (2011-10-14)\n------------------\n\n- ``flatten`` now only includes leaf nodes in the flattened dict.\n\n- ``flatten`` does not include a path element for the name of the type node\n  for sequences.\n\n- ``unflatten`` is implemented.\n\n- Added ``__setitem__`` to ``SchemaNode``, allowing replacement of nodes by\n  name.\n\n- Added ``get_value`` and ``set_value`` methods to ``Schema`` which allow\n  access and mutation of appstructs using dotted name paths.\n\n- Add Swedish, French, Chinese translations.\n\n0.9.3 (2011-06-23)\n------------------\n\n- Add ``Time`` type.\n\n- Add Dutch translation.\n\n- Fix documentation: 0.9.2 requires ``deserialize`` of types to explicitly\n  deal with the potential to receive ``colander.null``.\n\n- Use ``default_tzinfo`` when deserializing naive datetimes.  See\n  https://github.com/Pylons/colander/issues#issue/5.\n\n- Allow ``default_tzinfo`` to be ``None`` when creating a\n  ``colander.DateTime``.  See\n  https://github.com/Pylons/colander/issues#issue/6.\n\n- Add the ability to insert a ``colander.interfaces.Preparer`` between\n  deserialization and validation. See the Preparing section in the\n  documentation.\n\n0.9.2 (2011-03-28)\n------------------\n\n- Added Polish translation, thanks to Jedrzej Nowak.\n\n- Moved to Pylons Project GitHub (https://github.com/Pylons/colander).\n\n- Add tox.ini for testing purposes.\n\n- New API: ``colander.required``.  Used as the marker value when a\n  ``missing`` argument is left unspecified.\n\n- Bug fix: if a ``title`` argument which is the empty string or ``None`` is\n  passed explicitly to a SchemaNode, it is no longer replaced by a title\n  computed from the name.\n\n- Add SchemaNode.__contains__ to support \"name in schema\".\n\n- SchemaNode deserialization now unconditionally calls the schema type's\n  ``deserialize`` method to obtain an appstruct before attempting to\n  validate.  Third party schema types should now return ``colander.null`` if\n  passed a ``colander.null`` value or another logically \"empty\" value as a\n  cstruct during ``deserialize``.\n\n0.9.1 (2010-12-02)\n------------------\n\n- When ``colander.null`` was unpickled, the reference created during\n  unpickling was *not* a reference to the singleton but rather a new instance\n  of the ``colander._null`` class.  This was unintentional, because lots of\n  code checks for ``if x is colander.null``, which will fail across pickling\n  and unpickling.  Now the reference created when ``colander.null`` is\n  pickled is unpickled as the singleton itself.\n\n0.9  (2010-11-28)\n-----------------\n\n- SchemaNode constructor now accepts arbitrary keyword arguments.  It\n  sets any unknown values within the ``**kw`` sequence as attributes\n  of the node object.\n\n- Added Spanish locale:  thanks to Douglas Cerna for the translations!\n\n- If you use a schema with deferred ``validator``, ``missing`` or\n  ``default`` attributes, but you use it to perform serialization and\n  deserialization without calling its ``bind`` method:\n\n  - If ``validator`` is deferred, no validation will be performed.\n\n  - If ``missing`` is deferred, the field will be considered *required*.\n\n  - If ``default`` is deferred, the serialization default will be\n    assumed to be ``colander.null``.\n\n- Undocumented internal API for all type objects: ``flatten``.\n  External type objects should now inherit from\n  ``colander.SchemaType`` to get a default implementation.\n\n0.8  (2010/09/08)\n-----------------\n\n- Docstring fixes to ``colander.SchemaNode`` (``missing`` is not the\n  ``null`` value when required, it's a special marker value).\n\n- The concept of \"schema binding\" was added, which allows for a more\n  declarative-looking spelling of schemas and schema nodes which have\n  dependencies on values available after the schema has already been\n  fully constructed.  See the new narrative chapter in the\n  documentation entitled \"Schema Binding\".\n\n- The interface of ``colander.SchemaNode`` has grown a ``__delitem__``\n  method.  The ``__iter__``, and ``__getitem__`` methods have now also\n  been properly documented.\n\n0.7.3 (2010/09/02)\n------------------\n\n- The title of a schema node now defaults to a titleization of the\n  ``name``.  Underscores in the ``name`` are replaced with empty\n  strings and the first letter of every resulting word is capitalized.\n  Previously the ``name`` was not split on underscores, and the\n  entirety of the ``name`` was capitalized.\n\n- A method of the ``colander.Invalid`` exception named ``messages``\n  was added.  It returns an iterable of error messages using the\n  ``msg`` attribute of its related exception node.  If the ``msg``\n  attribute is iterable, it is returned.  If it is not iterable, a\n  single-element list containing the ``msg`` value is returned.\n\n0.7.2 (2010/08/30)\n------------------\n\n- Add an ``colander.SchemaNode.__iter__`` method, which iterates over\n  the children nodes of a schema node.\n\n- The constructor of a ``colander.SchemaNode`` now accepts a\n  ``widget`` keyword argument, for use by Deform (it is not used\n  internally).\n\n0.7.1 (2010/06/12)\n------------------\n\n- Make it possible to use ``colander.null`` as a ``missing`` argument\n  to ``colander.SchemaNode`` for roundtripping purposes.\n\n- Make it possible to pickle ``colander.null``.\n\n0.7.0\n-----\n\nA release centered around normalizing the treatment of default and\nmissing values.\n\nBug Fixes\n~~~~~~~~~\n\n- Allow ``colander.Regex`` validator to accept a pattern object\n  instead of just a string.\n\n- Get rid of circular reference in Invalid exceptions: Invalid\n  exceptions now no longer have a ``parent`` attribute.  Instead, they\n  have a ``positional`` attribute, which signifies that the parent\n  node type of the schema node to which they relate inherits from\n  Positional.  This attribute isn't an API; it's used only internally\n  for reporting.\n\n- Raise a ``TypeError`` when bogus keyword arguments are passed to\n  ``colander.SchemaNode``.\n\nBackwards Incompatiblities / New Features\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``missing`` constructor arg to SchemaNode: signifies\n  *deserialization* default, disambiguated from ``default`` which acted\n  as both serialization and deserialization default previously.\n\n  Changes necessitated / made possible by SchemaNode ``missing``\n  addition:\n\n  - The ``allow_empty`` argument of the ``colander.String`` type was\n    removed (use ``missing=''`` as a wrapper SchemaNode argument\n    instead).\n\n- New concept: ``colander.null`` input to serialization and\n  deserialization.  Use of ``colander.null`` normalizes serialization\n  and deserialization default handling.\n\n  Changes necessitated / made possible by ``colander.null`` addition:\n\n  - ``partial`` argument and attribute of colander.MappingSchema has\n     been removed; all serializations are partial, and partial\n     deserializations are not necessary.\n\n  - ``colander.null`` values are added to the cstruct for partial\n     serializations instead of omitting missing node values from\n     the cstruct.\n\n  - ``colander.null`` may now be present in serialized and\n     deserialized data structures.\n\n  - ``sdefault`` attribute of SchemaNode has been removed; we never need\n    to serialize a default anymore.\n\n  - The value ``colander.null`` will be passed as ``appstruct`` to\n    each type's ``serialize`` method when a mapping appstruct doesn't\n    have a corresponding key instead of ``None``, as was the practice\n    previously.\n\n  - The value ``colander.null`` will be passed as ``cstruct`` to\n    each type's ``deserialize`` method when a mapping cstruct\n    doesn't have a corresponding key instead of ``None``, as was the\n    practice previously.\n\n  - Types now must handle ``colander.null`` explicitly during\n    serialization.\n\n- Updated and expanded documentation, particularly with respect to new\n  ``colander.null`` handling.\n\n- The ``value`` argument`` to the ``serialize`` method of a SchemaNode\n  is now named ``appstruct``.  It is no longer a required argument; it\n  defaults to ``colander.null`` now.\n\n  The ``value`` argument to the ``deserialize`` method of a SchemaNode\n  is now named ``cstruct``.  It is no longer a required argument; it\n  defaults to ``colander.null`` now.\n\n- The ``value`` argument to the ``serialize`` method of each built-in\n  type is now named ``appstruct``, and is now required: it is no\n  longer a keyword argument that has a default.\n\n  The ``value`` argument to the ``deserialize`` method of each\n  built-in type is now named ``cstruct``, and is now required: it is\n  no longer a keyword argument that has a default.\n\n0.6.2 (2010-05-08)\n------------------\n\n- The default ``encoding`` parameter value to the ``colander.String``\n  type is still ``None``, however its meaning has changed.  An\n  encoding of ``None`` now means that no special encoding and decoding\n  of Unicode values is done by the String type.  This differs from the\n  previous behavior, where ``None`` implied that the encoding was\n  ``utf-8``.  Pass the encoding as ``utf-8`` specifically to get the\n  older behavior back.  This is in support of Deform.\n\n- The default ``err_template`` value attached to the ``colander.Date``\n  and ``colander.Datetime`` types was changed.  It is now simply\n  ``Invalid date`` instead of ``_('${val} cannot be parsed as an\n  iso8601 date: ${err}')``.  This is in support of Deform.\n\n- Fix bug in ``colander.Boolean`` that attempted to call ``.lower`` on\n  a bool value when a default value was found for the schema node.\n\n0.6.1 (2010-05-04)\n------------------\n\n- Add a Decimal type (number type which uses ``decimal.Decimal`` as a\n  deserialization target).\n\n0.6.0 (2010-05-02)\n------------------\n\n- (Hopefully) fix intermittent datetime-granularity-related test\n  failures.\n\n- Internationalized error messages.  This required some changes to\n  error message formatting, which may impact you if you were feeding\n  colander an error message template.\n\n- New project dependency: ``translationstring`` package for\n  internationalization.\n\n- New argument to ``colander.String`` constructor: ``allow_empty``.\n  This is a boolean representing whether an empty string is a valid\n  value during deserialization, defaulting to ``False``.\n\n- Add minimal documentation about the composition of a\n  colander.Invalid exception to the narrative docs.\n\n- Add (existing, but previously non-API) colander.Invalid attributes\n  to its interface within the API documentation.\n\n0.5.2 (2010-04-09)\n------------------\n\n- Add Email and Regex validators (courtesy Steve Howe).\n\n- Raise a ``colander.Invalid`` error if a ``colander.SequenceSchema``\n  is created with more than one member.\n\n- Add ``Function`` validator.\n\n- Fix bug in serialization of non-Unicode values in the ``String`` class.\n\n- Get rid of ``pserialize`` in favor of making ``serialize`` always\n  partially serialize.\n\n- Get rid of ``pdeserialize``: it existed only for symmetry.  We'll\n  add something like it back later if we need it.\n\n0.5.1 (2010-04-02)\n------------------\n\n- The constructor arguments to a the ``colander.Schema`` class are now\n  sent to the constructed SchemaNode rather than to the type it represents.\n\n- Allow ``colander.Date`` and ``colander.DateTime`` invalid error\n  messages to be customized.\n\n- Add a ``pos`` argument to the ``colander.Invalid.add`` method.\n\n- Add a ``__setitem__`` method to the ``colander.Invalid`` class.\n\n- The ``colander.Mapping`` constructor keyword argument\n  ``unknown_keys`` has been renamed to ``unknown``.\n\n- Allow ``colander.Mapping`` type to accept a new constructor\n  argument: ``partial``.\n\n- New interface methods required by types and schema nodes:\n  ``pserialize`` and ``pdeserialize``.  These partially serialize or\n  partially deserialize a value (the definition of \"partial\" is up to\n  the type).\n\n0.5 (2010-03-31)\n----------------\n\n- 0.4 was mispackaged (CHANGES.txt missing); no code changes from 0.4\n  however.\n\n0.4 (2010-03-30)\n----------------\n\n- Add ``colander.DateTime`` and ``colander.Date`` data types.\n\n- Depend on the ``iso8601`` package for date support.\n\n0.3 (2010-03-29)\n----------------\n\n- Subnodes of a schema node are now kept in the ``children`` attribute\n  rather than the ``nodes`` attribute.\n\n- Add an ``sdefault`` property to ``colander.SchemaNode`` objects.\n\n- Add a ``clone`` method to ``colander.SchemaNode`` objects.\n\n- Add a ``__str__`` method to the ``colander.Invalid`` exception that\n  prints an error summary.\n\n- Various error message improvements.\n\n- Add ``colander.Length`` validator class.\n\n0.2 (2010-03-23)\n----------------\n\n- Make nodetype overrideable.\n\n- Add __getitem__ to SchemaNode.\n\n- Fix OneOf message.\n\n- Capitalize node titles.\n\n- Deal with empty strings in String, Boolean, and Float types.\n\n- Introduce description; make title the same as name.\n\n- Remove copy method from schemanode.\n\n- Allow schema nodes to have titles.\n\n- The term \"structure\" is too overloaded to use for schema purposes:\n  structure -> schema node.\n\n- Make Sequence more like Tuple and Mapping (it uses a substructure\n  rather than a structure parameter to denote its type).\n\n- Add __repr__ and copy methods to structure.\n\n- Add accept_scalar flag to Sequence.\n\n\n0.1 (2010-03-14)\n----------------\n\n- Initial release.",
    "description_content_type": null,
    "docs_url": null,
    "download_url": "UNKNOWN",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://docs.pylonsproject.org/projects/colander/en/latest/",
    "keywords": "serialize deserialize validate schema validation",
    "license": "BSD-derived (http://www.repoze.org/LICENSE.txt)",
    "maintainer": null,
    "maintainer_email": null,
    "name": "ba-colander",
    "package_url": "https://pypi.org/project/ba-colander/",
    "platform": "UNKNOWN",
    "project_url": "https://pypi.org/project/ba-colander/",
    "project_urls": {
      "Download": "UNKNOWN",
      "Homepage": "http://docs.pylonsproject.org/projects/colander/en/latest/"
    },
    "release_url": "https://pypi.org/project/ba-colander/1.0b1/",
    "requires_dist": null,
    "requires_python": null,
    "summary": "A simple schema-based serialization and deserialization library",
    "version": "1.0b1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 1228300,
  "releases": {
    "1.0b1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f07cde8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f",
          "md5": "797c7c42b1c4f02cf0935446f367d85b",
          "sha256": "555109ba7fe43432b18db203d2df403ba6bced1916cab6481fb4916e7aa99aaf"
        },
        "downloads": -1,
        "filename": "ba-colander-1.0b1.tar.gz",
        "has_sig": false,
        "md5_digest": "797c7c42b1c4f02cf0935446f367d85b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 58055,
        "upload_time": "2014-09-17T18:41:33",
        "upload_time_iso_8601": "2014-09-17T18:41:33.627348Z",
        "url": "https://files.pythonhosted.org/packages/f0/7c/de8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f/ba-colander-1.0b1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f07cde8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f",
        "md5": "797c7c42b1c4f02cf0935446f367d85b",
        "sha256": "555109ba7fe43432b18db203d2df403ba6bced1916cab6481fb4916e7aa99aaf"
      },
      "downloads": -1,
      "filename": "ba-colander-1.0b1.tar.gz",
      "has_sig": false,
      "md5_digest": "797c7c42b1c4f02cf0935446f367d85b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 58055,
      "upload_time": "2014-09-17T18:41:33",
      "upload_time_iso_8601": "2014-09-17T18:41:33.627348Z",
      "url": "https://files.pythonhosted.org/packages/f0/7c/de8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f/ba-colander-1.0b1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}