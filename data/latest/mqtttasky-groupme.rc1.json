{
  "info": {
    "author": "Ryan Haas",
    "author_email": "haasrr@etsu.edu",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Other Audience",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3 :: Only"
    ],
    "description": "*****************\nmqtttasky_groupme\n*****************\n\nTurn your Raspberry Pi into a Task notification system.\n*******************************************************\n| |task-notification|\n\n.. |task-notification| image:: images/task-notification.png\n\n.. contents:: Contents\n\n\nWhat is MQTTTasky?\n##################\n| I once created a desktop application called Tasky which would allow\n| me to create tasks in sticky-note-like windows. I could set\n| notifications for each task and have notifications sent to my phone.\n| The UI was nice and but that was about it; Tasky was clunky and buggy\n| and I couldn't conventiently schedule tasks from my smart phone.\n\n| MQTTTasky is much less terrible, despite its name. The basic idea is,\n| using GroupMe on my phone, I can schedule a task, then A GroupMe bot\n| I have configured will interact with me and schedule the tasks. When\n| a task notification occurs, the Raspberry Pi running MQTTTasky will\n| display a notification window about the task and read the task aloud\n| using a separate GitHub project called simple_google_tts. Additionally,\n| when LEDs are connected to the Raspberry Pi's BCM pins 18, 23, and 24,\n| they serve as status lights. Of course, it wouldn't be MQTTTasky\n| without some MQTT action now would it? MQTTTasky connects to a Mosquito\n| broker and when a task notification occurs, the notification is also\n| published to pub/tasks. Payloads are encrypted with Fernet and a\n| base-64 32-byte key can be used by any MQTT client to decrypt the\n| message payloads using a Fernet decryption.\n|\n\nSystem Design\n#############\n| |system-design|\n\n.. |system-design| image:: images/system-design.png\n    :height: 300\n    :width: 750\n\n| In case my artistic endeavors are lost on you, I will try to explain\n| my system design. We can think of it in terms of the HTTP(S) side of\n| the architecture, what happens locally on Pi (Pi side?), and the MQTT\n| side.\n|\n| Sitting on the Raspberry Pi, we have the mqtttasky_groupme\n| package running. This package includes the GroupMe bot which communicates\n| with users over HTTP. The the bot code processes requests in the group\n| to act on the scheduling component of mqtttasky_groupme which schedules\n| tasks. So on the 'Pi side', the bot and the scheduler will blink the LEDs\n| to indicate the status of messages and task notifications. The scheduler\n| will display graphical task notifications at the notification time of\n| each task and it will also cause the task information to be read aloud\n| through a connected speaker using a system call to simple_google_tts.\n|\n| Lastly, mqtttasky_groupme also includes an MQTT client. When it is time\n| for a notification to be sent, the scheduler also calls on the MQTT client\n| to publish the data to the topic, 'pub/tasks'. The client publishes\n| payloads which are encrypted using Fernet encryption for which the client\n| provides the symmetric key during initial configuration so that another\n| MQTT client (such as the one contained in this repo in\n| ./node_mqtttasky_pi_client) can use the key to create Fernet tokens and\n| decrypt the payloads.\n|\n| The Node.js client pictured in the above design is an example of another\n| client which subscribes to 'pub/tasks' on the same broker as MQTTasky is\n| publishing to. For instructions on setting up a broker for which to connect\n| your clients, see the section, 'Setting up a Mosquitto broker'.\n|\n| For me, this design is nifty because it is fully functional with just one\n| Pi but the MQTT architecture allows me to implement multiple displays and/or\n| speakers for task notifications such as on my monitor, my Raspberry\n| Pi touch display, or even a television.\n\nEquipment/Requirements\n######################\n- A Raspberry Pi 3B/3B+ or 4B/4B+ running Raspberry Pi OS w/ desktop\n- A display connected to the Raspberry Pi\n- A speaker connected to the Raspberry Pi\n- A stable Internet connection on the Pi\n- Three LED lights (preferably a red, yellow, and green)\n- Four female to male jumper wires\n- One ~100-220 Ohm resistor\n- One breadboard\n\n\nSetup\n#####\n\nConnecting the LEDs\n-------------------\n| Please refer to the following diagram (I tried):\n| |gpio-diagram|\n|\n| 1) Connect one jumper wire to physical pin 1 (3.3V); connect the other\n|    end to the positive side of the breadboard to share its voltage.\n|\n| 2) Connect the resistor to the positive side of the breadboard after\n|    the jumper wire.\n|\n| 3) Connect the longer end (anode) of the first (red) LED to the positive\n|    side of the breadboard after the resistor.\n|\n| 4) Connect the next wire to physical pin 12 (BCM 18); connect the other\n|    end to the shorter end (cathode) of the first (red) LED.\n|\n| 5) Connect the longer end (anode) of the second (yellow) LED to the\n|    positive side of the breadboard after the first LED.\n|\n| 6) Connect the next wire to physical pin 16 (BCM 23); connect the other\n|    end to the shorter end (cathode) of the second (yellow) LED.\n|\n| 7) Connect the longer end (anode) of the third (green) LED to the\n|    positive side of the breadboard after the second LED.\n|\n| 8) Connect the next and final wire to physical pin 18 (BCM 24); connect\n|    the other end to the shorter end (cathode) of the third (green) LED.\n|\n\n.. |gpio-diagram| image:: images/gpio-diagram.png\n\nSetting up simple_google_tts\n----------------------------\n| 1) As per the instructions from `this link <https://github.com/alexylem/jarvis/issues/129#issuecomment-248072872>`_, download each of the following\n| files on your Raspberry Pi:\n|   - `libttspico-data <http://ftp.fr.debian.org/debian/pool/non-free/s/svox/libttspico-data_1.0+git20130326-3_all.deb>`_\n|   - `libttspico0_1.0 <http://ftp.fr.debian.org/debian/pool/non-free/s/svox/libttspico0_1.0+git20130326-3_armhf.deb>`_\n|   - `libttspico-utils <http://ftp.fr.debian.org/debian/pool/non-free/s/svox/libttspico-utils_1.0+git20130326-3_armhf.deb>`_\n|\n| 2) And following the same instructions, install each of the packages onto your Pi:\n\n.. code:: bash\n\n    sudo dpkg -i libttspico-data_1.0+git20130326-3_all.deb\n    sudo dpkg -i libttspico0_1.0+git20130326-3_armhf.deb\n    sudo dpkg -i libttspico-utils_1.0+git20130326-3_armhf.deb\n\n| 3) If git is not installed, you will need to install it:\n\n.. code:: bash\n\n    sudo apt install git\n\n| 4) As instrcuted in the `simple_google_tts readme <https://github.com/glutanimate/simple-google-tts>`_, run the following command:\n|\n\n.. code:: bash\n\n    sudo apt-get install xsel libnotify-bin libttspico0 libttspico-utils libttspico-data libwww-perl libwww-mechanize-perl libhtml-tree-perl sox libsox-fmt-mp3\n\n| 5) Clone the repo into the home directory and then open ~/.bashrc:\n\n.. code:: bash\n\n    cd /home/pi; git clone https://github.com/Glutanimate/simple-google-tts.git\n    nano .bashrc\n\n| 6) On a new line, at the end of .bashrc, add the following:\n\n.. code:: bash\n\n    export PATH=\"$PATH:`pwd`/simple-google-tts\"\n\n|\n\nInstalling the Python packages\n------------------------------\n| 1) First, ensure python3-pip is installed on your Raspberry Pi:\n\n.. code:: bash\n\n    sudo apt install python3-pip\n\n| 2) Now install mqtttasky_groupme from the package index:\n\n.. code:: bash\n\n    pip3 install mqtttasky-groupme==0.1.4\n\n|\n\nRegistering for GroupMe, Creating a Group\n-----------------------------------------\n| 1) If you do not already, you will need to create a GroupMe account\n|    since this is what MQTTTasky will use to allow you to schedule\n|    tasks. You may sign up for groupme `here <https://web.groupme.com/signup>`_.\n|\n| 2) Afer registering, login. You will need to create at least one group\n|    to which you will add your GroupMe bot after having created it. For\n|    help with creating a group, see `this page <https://support.microsoft.com/en-us/office/how-do-i-start-a-group-in-groupme-d7488e15-4429-43ff-85fa-a5c7775305e2>`_.\n|\n\nCreating your GroupMe bot\n-------------------------\n| 1) First, register a developer account after logging in at\n|    (https://dev.groupme.com/).\n|\n| 2) After your are logged in, click the 'Bots' link in the main site\n|    navigation or visit (https://dev.groupme.com/bots).\n|\n| 3) Click \"Create Bot\", and select thr group to which it\n|    will belong and name it. You will not need to enter\n|    a callback URL and you may give the bot an avatar\n|    by entering a public image URL.\n|\n| 4) After having created your bot, it will be visible on the page at\n|    (https://dev.groupme.com/bots).\n|\n| 5) Copy your bot's ID, as well as the Group ID to which it belongs.\n|    Finally, find the 'Access Token' link in the main site navigation\n|    and copy it as well. You will need all of this information shortly.\n|\n\nSetting up a Mosquitto broker\n------------------------------\n| MQTTTasky requires to be connected to an MQTT broker which uses\n| authentication. The broker can be hosted on another computer or\n| Raspberry Pi. It is not recommended to host the broker on the same Pi\n| as MQTTTasky will be running on. To set up a Mosquitto broker on a\n| Raspberry Pi, please refer to `these instructions <https://medium.com/@eranda/setting-up-authentication-on-mosquitto-mqtt-broker-de5df2e29afc>`_.\n|\n| Please note while following along with the instructions above, that\n| there are a couple of descrepancies. In the first step, you will have\n| to change the line\n\n.. code:: bash\n\n    sudo wget http://repo.mosquitto.org/debian/mosquitto-wheezy.list\n\n| to the following:\n\n.. code:: bash\n\n    sudo wget http://repo.mosquitto.org/debian/mosquitto-buster.list\n\n| Furthermore, the line that says\n\n.. code:: bash\n\n    sudo stop mosquitto\n\n| in step 2 should instead read:\n\n.. code:: bash\n\n    sudo systemctl stop mosquitto\n\n| Finally, please record the username and password you used in this\n| configuration as you will need it when configuring MQTTTasky.\n\nConfigure MQTTTasky\n-------------------\n| After having completed the above setup, you are ready to start the\n| mqtttasky_groupme program. This may be done simply by entering:\n\n.. code:: bash\n\n    mqtttasky_groupme\n\n| On first launch, you will be prompted to enter your GroupMe information\n| as well as your MQTT broker and authentication information. You should\n| have already recorded these. If you are unsure of your broker's port\n| number, it is likely 1883 and if it is hosted on a Linux machine, the\n| IP address can be found using the 'ifconfig' command (or 'ipconfig' on \n| Windows). If the configuration is successful, you will see similar\n| output to that below:\n\n.. code:: bash\n\n    [ MQTT Client ] Connected to broker.\n\n\n    #######################\n    # Bot: Tarnoff Bot\n    # Group: IoT Dev Server\n    # Status: Listening\n    #######################\n\n| Note that you can break out of the program using Ctrl-C. Any time you\n| need to re-run the configuration, you may enter the command:\n\n.. code:: bash\n\n    mqtttasky_groupme_config\n\n\nMQTTTasky: Status lights, notifications, and usage\n##################################################\n\nStatus lights and notifications\n-------------------------------\n| First you will notice that MQTTTasky's MQTT client has connected to\n| the broker. Once the broker is connected, MQTTTasky will start\n| listening for messages every 4 seconds.\n|\n| Each time the program successfully retrieves the messages, the second \n| (yellow) LED will blink on and off.\n|\n| Each time a message retrieval fails, the first (red) LED will blink on\n| and off.\n|\n| Each time a new message is discovered, the third (green) LED will blink\n| on and off several times.\n|\n| Each time a new response is sent back from the bot, the second (yellow)\n| LED will blink on and off several times.\n|\n| Finally, when a notification is being shown and the MQTT client is\n| publishing data, all three lights will blink several times in a sequence.\n| Additionally, MQTTTasky will display the task notification in a graphical\n| window and read the task information aloud using simple_google_tts. Every\n| time a task notification is published, the payload is encrypted using\n| Fernet encryption and the key provided during the configuration of\n| mqtttasky_groupme. This key can be used to create a Fernet cipher in other\n| MQTT clients on the network so that they may decrypt the payload. Included\n| in the 'node_mqtttasky_pi_client' directory is an example of such a client\n| in Node.js. It's instructions can be found in a separate readme file within\n| that directory.\n\nUsage\n------\n| The MQTTTasky bot will make it fairly clear what you need to do to create\n| a task, however, other options, such as resetting task data or deleting\n| all scheduled tasks are available. The usage for communicating with the\n| bot is as follows:\n|\n| MQTTasky Usage\n| ===============================\n| - Initiate a new task:\n| 'Schedule task'\n| 'Schedule task <title> with description <description>'\n| \n| - Date and time:\n| MQTTTasky will let you know how\n| to enter date or time when prompted.\n| If the year is not provided in a date\n| string, the current year is assumed.\n|\n| Time strings ending in AM or PM are\n| automatically converted into 24-hr\n| format.\n|\n| - Notifications:\n| Notifications are specified by a unit\n| of time before the time of the task.\n| You may use the following units of\n| time:\n|\n| Minutes:\n| E.g. '15 minutes before'\n| Hours:\n| E.g. '15 hours before'\n| Days:\n| E.g. '15 days before'\n| Weeks:\n| E.g. '15 weeks before'\n|\n| - Reset:\n| If you want to cancel or restart the\n| creation of a task, use the command:\n| '/reset'\n| \n| - Delete:\n| To delete all active tasks:\n| '/deleteall'\n| \n| - Bonus:\n| Ask bot to tell a joke or proverb.\n\nMQTT Topic Details\n##################\n| The MQTT topic to which MQTTasky publishes its encrypted payloads\n| is pub/tasks. The first topic level denotes published data. The\n| second topic level denotes that task data is being published.\n| The task data published is a message designed to be read over a\n| speaker using TTS. Since a payload is published by the scheduler\n| when a notification is set to occur, this allows subscribed MQTT\n| clients to display and/or speak the notification when it is\n| received.\n|\n| Since payloads are encrypted using Fernet encryption, the symmetric\n| key provided during the initial mqtttasky_groupme configuration can\n| be used by clients to implement Fernet decryption tokens to decrypt\n| the payloads which can then be decoded to UTF-8 strings.\n\nMQTT Encryption\n###############\n\nFernet (symmetric encryption)\n-----------------------------\n| MQTTTasky uses the Python Fernet class from cryptography.fernet.\n| This class is popular because of its ease of use, and the security\n| it offers for the lightweight encryption/decryption that is needed\n| in IoT.\n|\n| The algorithm used in Fernet is AES using CBC mode with signing\n| using HMAC and SHA256. Thus Fernet not only encrypts/decrypts but\n| allows for the authentication of messages to ensure integrity\n| (`McBride, 2020 <https://www.pythoninformer.com/python-libraries/cryptography/fernet/>`_).\n|\n\nCBC\n===\n| In cipher block chaining (CBC), plaintext blocks get XORed with\n| previous ciphertext blocks prior to the encryption process. That\n| is why it is referred to as block chaining, because each ciphertext\n| block depends on ever processed plaintext block at each that moment.\n| This preserves the integrity of the data\n| (`Block cipher mode of operation, 2020 <https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)>`_).\n|\n\nHMAC\n====\n| Hashing for Message authentication (HMAC) applies a hash function\n| over the data and the symmetric key. HMAC using SHA256 is the part\n| of Fernet that ensures the authenticity and integrity of the message\n| (`John C. Villanueva, 2016 <https://www.jscape.com/blog/what-is-hmac-and-how-does-it-secure-file-transfers>`_).\n|\n| As Villanueva (`2016 <https://www.jscape.com/blog/what-is-hmac-and-how-does-it-secure-file-transfers>`_) points out, one advantage of using HMAC for data\n| transfer is that hash functions create a fixed-length digest\n| regardless of the arbitrary length of the message hashed; this\n| results in mitigating the amount of bandwidth needed to transfer\n| data over a network.\n\nFernet Key Format\n=================\n| Key generation using the cryptography.fernet library's Fernet class\n| renders a 32-byte key which is actually a composite of two 16-byte\n| keys. The first 16 bytes being a signing key used to sign the HMAC\n| and the second 16 bytes being a private key used by the encryption\n| (`McBride, 2020 <https://www.pythoninformer.com/python-libraries/cryptography/fernet/>`_).\n| \n\nFernet Token Format\n====================\n| The Fernet token used in the Fernet class consists of:\n|    • Version, 1 byte - the only valid value currently is 128.\n|    • Timestamp 8 bytes - a 64 bit, unsigned, big-endian integer\n|    that indicates when the ciphertext was created. Time is\n|    represented as the number of seconds since the start of Jan 1,\n|    1970, UTC.\n|    • IV 32 bytes - the 128 bit Initialization Vector used in AES\n|    encryption and decryption.\n|    • Ciphertext - the encrypted version of the plaintext message. This is\n|    encrypted using AES, in CBC mode, using the encryption key section\n|    of the Fernet key. The ciphertext is padded to be a multiple of 128\n|    bits, which is the AES block size, using the PKCS7 padding algorithm.\n|    This menas that the ciphertest will always be a multiple of 16 bytes\n|    in length, but the padding will be automatically removed when the\n|    data is decrypted.\n|    • HMAC - a 256-bit HMAC of the concatenated Version, Timestamp, IV,\n|    and Ciphertext fields. The HMAC is signed using the signing key\n|    section [of the] Fernet key.\n|    (`McBride, 2020 <https://www.pythoninformer.com/python-libraries/cryptography/fernet/>`_).   \n|\n| Once the HMAC has been calculated using the binary data from the Version,\n| Timestamp, IV, and Ciphertext, the entire token is encoded in Base64\n| encoding (`McBride, 2020 <https://www.pythoninformer.com/python-libraries/cryptography/fernet/>`_). According to Base64 (`2020 <https://developer.mozilla.org/en-US/docs/Glossary/Base64>`_), this encoding\n| method is used to encode binary data which may need to be transferred to\n| and stored on media designed to handle ASCII. This is a convenient format\n| for the Web since it would allow binary data to be represented within a\n| URL as ASCII text. This encoding does come at a price -- increased size.\n| Every Base64 digit represents exactly 6 bits of data. Base64 can increase\n| the size of a string by as much as ~33 percent (`Base64, 2020 <https://developer.mozilla.org/en-US/docs/Glossary/Base64>`_).\n\n\nNode.js MQTT client for reading task notifications\n##################################################\n\n| In the `node_mqtttasky_pi_client <https://github.com/haasr/mqtttasky_groupme/tree/master/node_mqtttasky_pi_client>`_,\n| directory of this repository is a Node.js client which can be configured\n| to use the mqtttasky_groupme client's Fernet key to decrypt the message\n| payloads published by MQTTasky and read them aloud using\n| simple_google_tts. See the separate README file `on this page <https://github.com/haasr/mqtttasky_groupme/tree/master/node_mqtttasky_pi_client>`_ for details\n| about pacakges used, setup, and usage.",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/haasr/mqtttttttasky_groupme",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "mqtttasky-groupme",
    "package_url": "https://pypi.org/project/mqtttasky-groupme/",
    "platform": "",
    "project_url": "https://pypi.org/project/mqtttasky-groupme/",
    "project_urls": {
      "Homepage": "https://github.com/haasr/mqtttttttasky_groupme"
    },
    "release_url": "https://pypi.org/project/mqtttasky-groupme/0.1.4/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "GroupMe bot to schedule tasks, display and speak notifications, and publish them over MQTT.",
    "version": "0.1.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8945966,
  "releases": {
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bbe43c5c321ba767fb85276ffe777689ada34665059b78f83155b7d827916085",
          "md5": "96c2316dcc8744db4a529586b1f660e0",
          "sha256": "8ee2bae3feaa9205f151cc2eabf44c61de87e88916ac9fb41bfd6d90eb63d1a9"
        },
        "downloads": -1,
        "filename": "mqtttasky_groupme-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "96c2316dcc8744db4a529586b1f660e0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 28905,
        "upload_time": "2020-12-02T22:53:39",
        "upload_time_iso_8601": "2020-12-02T22:53:39.094835Z",
        "url": "https://files.pythonhosted.org/packages/bb/e4/3c5c321ba767fb85276ffe777689ada34665059b78f83155b7d827916085/mqtttasky_groupme-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bbe43c5c321ba767fb85276ffe777689ada34665059b78f83155b7d827916085",
        "md5": "96c2316dcc8744db4a529586b1f660e0",
        "sha256": "8ee2bae3feaa9205f151cc2eabf44c61de87e88916ac9fb41bfd6d90eb63d1a9"
      },
      "downloads": -1,
      "filename": "mqtttasky_groupme-0.1.4.tar.gz",
      "has_sig": false,
      "md5_digest": "96c2316dcc8744db4a529586b1f660e0",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 28905,
      "upload_time": "2020-12-02T22:53:39",
      "upload_time_iso_8601": "2020-12-02T22:53:39.094835Z",
      "url": "https://files.pythonhosted.org/packages/bb/e4/3c5c321ba767fb85276ffe777689ada34665059b78f83155b7d827916085/mqtttasky_groupme-0.1.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}