{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": ".. image:: https://github.com/knowikow/ya.resourcepool.py/workflows/tests/badge.svg\n   :target: https://github.com/knowikow/ya.resourcepool.py/workflows/tests/badge.svg\n\n=========================\nYet Another Resource Pool\n=========================\n\nA configurable resource pool. The ``ResourcePool`` class can allocate resources using a configurable function,\nstore them for later use, and also free them if the pool gets too large.\n\nAll the code examples assume::\n\n   >>> from ya.resourcepool import *\n   >>> import threading\n   >>>\n   >>> class R(int):\n   ...     lock = threading.Lock()\n   ...     current = 0  # last generated number\n   ...     deallocated = []\n   ...\n   ...     def __new__(cls, *args, **kwds):\n   ...         with R.lock:\n   ...             R.current += 1\n   ...             instance = super().__new__(cls, R.current)\n   ...         return instance\n   ...\n   ...     def __init__(self):\n   ...         self.alive = True\n   ...\n   ...     def close(self):\n   ...         self.alive = False\n   ...         R.deallocated.append(self)\n   ...         return self\n   ...\n   ...     def use(self):\n   ...         print(f'Using resource {self}')\n   ...         return self\n\n\nUsage examples\n==============\n\nThe most basic example only configures the method of allocation of the resource and uses\n``ResourcePool.__call__()`` to get a resource from the pool::\n\n   >>> pool = ResourcePool(alloc=R)\n   >>> with pool() as obj:\n   ...     obj.use()\n   Using resource ...\n\nThis assumes that the resource can be simply garbage collected, and that an unlimited\namount can be allocated.\n\nNote that ``ResourcePool.__call__()`` is supposed to be used as a context manager. If that is not needed,\nthe methods ``ResourcePool.pop()`` and ``ResourcePool.push()`` can be used::\n\n   >>> pool = ResourcePool(alloc=R)\n   >>> obj = pool.pop()\n   >>> obj.use()\n   Using resource ...\n   >>> pool.push(obj)\n\nNote that ``ResourcePool.pop()`` transfers ownership of the resource to the client code, and it is the client's\nresponsibility to either clean up the resource or to return it to the pool using ``ResourcePool.push()``.\n\nThe ``ResourcePool.push()`` method can also be used to add new resource to the pool::\n\n   >>> pool = ResourcePool()  # no alloc argument\n   >>> obj = R()              # create/allocate a resource\n   >>> pool.push(obj)         # push without preceding pop\n\nThe ``ResourcePool.__call__()`` method is actually implemented in terms of ``pop`` and ``push``.\n\n\nLimited resource sets\n---------------------\n\nIf there is only a limited amount of resource instances available, a set can be provided with the ``init`` argument::\n\n   >>> resources = [R()]\n   >>> pool = ResourcePool(init=resources)\n   >>> with pool() as obj:\n   ...     obj.use()\n   Using resource ...\n\nIn that case, no new resources will be allocated, and only the ones given in the initializer will be used.\n\nBy default, trying to get a resource from a limited pool will raise an exception of type ``ResourcePoolEmpty``\nif there is no free resource available at the moment::\n\n   >>> pool = ResourcePool(init=[])  # note the empty list\n   >>> with pool() as obj:\n   ...     obj.use()\n   Traceback (most recent call last):\n      ...\n   ya.resourcepool.ResourcePoolEmpty\n\nAlternatively, a timeout in seconds can be given::\n\n   >>> pool = ResourcePool()  # an empty list is actually the default for init\n   >>> with pool(timeout=5) as obj:\n   ...     obj.use()\n   Traceback (most recent call last):\n      ...\n   ya.resourcepool.ResourcePoolEmpty\n\nThis will raise the exception only after the given timeout of five seconds. Note that the timeout is a\nfloating point number, so fractions of seconds are possible. A timeout of zero or less will block forever\nor until a resource becomes available.\n\nThe ``init`` argument can be combined with the ``alloc`` argument::\n\n   >>> resources = [R()]\n   >>> pool = ResourcePool(init=resources, alloc=R)\n   >>> with pool() as obj:\n   ...     obj.use()\n   Using resource ...\n\nThis will use the initial resource list and only allocate new ones if the initial resources are exhausted.\n\n\nResource deallocation\n---------------------\n\nResources will usually have to be deallocated at some point. The function to do this can be\ngiven with the ``dealloc`` initializer argument::\n\n   >>> pool = ResourcePool(alloc=R, dealloc=R.close)\n   >>> with pool() as obj:\n   ...     obj.use()\n   Using resource ...\n\nThis will call ``R.close()`` when the pool gets garbage collected for all resources currently managed by the pool.\n\n\nResource retention policy\n-------------------------\n\nSurplus resources can be deallocated by giveng the ``maxsize`` argument to the pool initializer::\n\n   >>> pool = ResourcePool(alloc=R, maxsize=100)\n\nWhen a ``maxsize`` argument was given, and the pool size exceeds that number after returning a\nresource to the pool, all the surplus will be deallocated. This process will also use the optional ``dealloc``\nargument, or will just remove it from the pool and have it garbage collected.\n\nThere is an additional argument ``minsize`` to control the amount of resources that will be deallocated\nin the overflow case::\n\n   >>> pool = ResourcePool(alloc=R, maxsize=100, minsize=50)\n\nThis will reduce the pool size to 50 by deallocating surplus resources when the size exceeds 100 after\na ``push`` operation.\n\nAn additional argument ``maxage`` can be used to set the maximum time a resource shall be kept in the\npool. The ``minsize`` argument can be used to guarantee a minimal set of pooled resources,\nregardless of age.\n\n\nResource alive check\n--------------------\n\nIt is possible to check the status of any pooled resources before returning them from ``pop``. This\ncan be configured using the ``check`` argument::\n\n   >>> pool = ResourcePool(alloc=R, check=lambda resource: resource.alive)\n   >>> with pool() as obj:\n   ...     obj.use()\n   Using resource ...\n\nThe object given in ``check`` must be a callable that takes a resource instance and returns a truthy\nvalue. It will be called for a result value candidate of ``pop`` before it is returned, and if the\nresult is convertible to ``False``, then the resource is considered dead and will be discarded\nwithout calling any ``dealloc`` procedure. ``pop`` will then continue trying to get a valid resource.\n\n\nShooting yourself in the foot\n=============================\n\nIt is possible to block a thread indefinitely by having an empty fixed-size pool and using a timeout of 0::\n\n   >>> pool = ResourcePool()\n   >>>\n   >>> def allocate(pool):\n   ...     pool.push(R())\n   >>>\n   >>> threading.Timer(5, allocate, (pool,)).start()\n   >>>\n   >>> with pool(timeout=0) as obj:\n   ...     obj.use()\n   Using resource ...\n\nThis code would block forever without the ``Timer`` thread that adds a new object to the pool after 5 seconds.\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/knowikow/ya.resourcepool.py",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ya.resourcepool",
    "package_url": "https://pypi.org/project/ya.resourcepool/",
    "platform": "",
    "project_url": "https://pypi.org/project/ya.resourcepool/",
    "project_urls": {
      "Homepage": "https://github.com/knowikow/ya.resourcepool.py"
    },
    "release_url": "https://pypi.org/project/ya.resourcepool/0.1.1/",
    "requires_dist": [
      "mutmut ; extra == 'dev'",
      "pytest ; extra == 'testing'",
      "pytest-cov ; extra == 'testing'",
      "flake8 ; extra == 'testing'",
      "flake8-annotations ; extra == 'testing'",
      "flake8-comprehensions ; extra == 'testing'",
      "flake8-docstrings ; extra == 'testing'",
      "flake8-isort ; extra == 'testing'",
      "flake8-raise ; extra == 'testing'",
      "flake8-typing-imports ; extra == 'testing'"
    ],
    "requires_python": ">=3.7",
    "summary": "Resource management for Python objects",
    "version": "0.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7924549,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "78ee2d1d2396280b5aa383d97d196d7a8f7df5b6a0bf0028aa71536cc19e7f49",
          "md5": "4314c1809e046467d0c3b5c510460c60",
          "sha256": "dda5db14fc46982773aa87e77a18942b56aaf9637afb509094f8fcd44c74829c"
        },
        "downloads": -1,
        "filename": "ya.resourcepool-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4314c1809e046467d0c3b5c510460c60",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 6374,
        "upload_time": "2020-08-09T14:18:46",
        "upload_time_iso_8601": "2020-08-09T14:18:46.143359Z",
        "url": "https://files.pythonhosted.org/packages/78/ee/2d1d2396280b5aa383d97d196d7a8f7df5b6a0bf0028aa71536cc19e7f49/ya.resourcepool-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7e36b76cf782d7393f67a706f8e310b98f7f9fb2e3c975cccbafa358eb76708f",
          "md5": "bde9b55052b12b7dcbde24e2f1118f16",
          "sha256": "caf87d4d394b60e3a7eef1007145a2f5cb147f0bc43eb58c6d4532c2bebf68ce"
        },
        "downloads": -1,
        "filename": "ya.resourcepool-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "bde9b55052b12b7dcbde24e2f1118f16",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 9551,
        "upload_time": "2020-08-09T14:18:48",
        "upload_time_iso_8601": "2020-08-09T14:18:48.926489Z",
        "url": "https://files.pythonhosted.org/packages/7e/36/b76cf782d7393f67a706f8e310b98f7f9fb2e3c975cccbafa358eb76708f/ya.resourcepool-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ab785c24ca80109bbaa1dc62575fc8dc04e43450e0ad7d2c24601d1de4a5c7e1",
          "md5": "fc7484dbd1ccbb665758f263dfc4a6ca",
          "sha256": "4ac4896ea388349e3c2b32ac27fa860a8f1e4ac0d02af0d6224785987775dbd5"
        },
        "downloads": -1,
        "filename": "ya.resourcepool-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fc7484dbd1ccbb665758f263dfc4a6ca",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 6385,
        "upload_time": "2020-08-10T10:55:21",
        "upload_time_iso_8601": "2020-08-10T10:55:21.816942Z",
        "url": "https://files.pythonhosted.org/packages/ab/78/5c24ca80109bbaa1dc62575fc8dc04e43450e0ad7d2c24601d1de4a5c7e1/ya.resourcepool-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "319591c391fd35707701cfe4ede6ba5e37cd90bdcb6f4219663d40b0d1227094",
          "md5": "70b0c999d2130943c067f4d84c2031a6",
          "sha256": "86ccea2d2e4cde6e2e07bf4c3103d981c6e224bbd5c4c1396b81713c1cce628c"
        },
        "downloads": -1,
        "filename": "ya.resourcepool-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "70b0c999d2130943c067f4d84c2031a6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 9535,
        "upload_time": "2020-08-10T10:55:23",
        "upload_time_iso_8601": "2020-08-10T10:55:23.086785Z",
        "url": "https://files.pythonhosted.org/packages/31/95/91c391fd35707701cfe4ede6ba5e37cd90bdcb6f4219663d40b0d1227094/ya.resourcepool-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ab785c24ca80109bbaa1dc62575fc8dc04e43450e0ad7d2c24601d1de4a5c7e1",
        "md5": "fc7484dbd1ccbb665758f263dfc4a6ca",
        "sha256": "4ac4896ea388349e3c2b32ac27fa860a8f1e4ac0d02af0d6224785987775dbd5"
      },
      "downloads": -1,
      "filename": "ya.resourcepool-0.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "fc7484dbd1ccbb665758f263dfc4a6ca",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 6385,
      "upload_time": "2020-08-10T10:55:21",
      "upload_time_iso_8601": "2020-08-10T10:55:21.816942Z",
      "url": "https://files.pythonhosted.org/packages/ab/78/5c24ca80109bbaa1dc62575fc8dc04e43450e0ad7d2c24601d1de4a5c7e1/ya.resourcepool-0.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "319591c391fd35707701cfe4ede6ba5e37cd90bdcb6f4219663d40b0d1227094",
        "md5": "70b0c999d2130943c067f4d84c2031a6",
        "sha256": "86ccea2d2e4cde6e2e07bf4c3103d981c6e224bbd5c4c1396b81713c1cce628c"
      },
      "downloads": -1,
      "filename": "ya.resourcepool-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "70b0c999d2130943c067f4d84c2031a6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 9535,
      "upload_time": "2020-08-10T10:55:23",
      "upload_time_iso_8601": "2020-08-10T10:55:23.086785Z",
      "url": "https://files.pythonhosted.org/packages/31/95/91c391fd35707701cfe4ede6ba5e37cd90bdcb6f4219663d40b0d1227094/ya.resourcepool-0.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}