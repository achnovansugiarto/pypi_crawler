{
  "info": {
    "author": "Vincent Texier",
    "author_email": "vit@free.fr",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "This is a fork of Adhesive to handle Zeebe Modeler BPMN workflows.\n\nChanges are:\n\n1. Support for Zeebe Modeler BPMN xml files.\n2. Can be used in a thread.\n3. Should be used as a library from another app.\n\n*The following documentation is the original documentation and might not work as excepted when adhesive is used as a cli command.*\n\n----\n\nAdhesive is a micro BPMN runner written in Python.\n\nYou can easily model complex logic in BPMN, and Adhesive will execute it\nfor you taking care of parallelism, joining, etc. using the standard\nBPMN notation.\n\nSince it’s small, it can easily be embedded in containers, or replace\ncomplex scripts.\n\nInstallation\n============\n\n.. code:: sh\n\n    pip install adhesive\n\nGetting Started\n===============\n\nSimple Builds\n-------------\n\nTo create a basic build you just create a file in your project named\n``_adhesive.py``. In it you then declare some tasks. For example:\n\n.. code:: python\n\n    import adhesive\n\n    @adhesive.task(\"Checkout Code\")\n    def checkout_code(context):\n        adhesive.scm.checkout(context.workspace)\n\n    @adhesive.task(\"Run Build\")\n    def run_build(context):\n        context.workspace.run(\"mvn clean install\")\n\n    adhesive.build()\n\nSince no process was defined, adhesive takes the defined tasks, stitches\nthem in order, and has a process defined as ``<start>`` →\n``Checkout Code`` → ``Run\nBuild`` → ``<end>``.\n\nTo run it simply call ``adhesive`` in the terminal:\n\n.. code:: sh\n\n    adhesive\n\nThis is the equivalent of Jenkins stages. But we can do better:\n\nProgrammatic Builds\n-------------------\n\nIn order to use the full programmatic functionalities that adhesive\noffers, you are able to stitch your BPM process manually. You have sub\nprocesses, branching and looping available:\n\n.. code:: python\n\n    import adhesive\n    import uuid\n\n    @adhesive.task(\"Run in parallel item {loop.value}\")\n    def context_to_run(context):\n        if not context.data.executions:\n            context.data.executions = set()\n\n        context.data.executions.add(str(uuid.uuid4()))\n\n    data = adhesive.process_start()\\\n        .branch_start()\\\n            .sub_process_start() \\\n                .task(\"Run in parallel\",\n                      loop=\"items\") \\\n            .sub_process_end()\\\n        .branch_end() \\\n        .branch_start() \\\n            .sub_process_start() \\\n                .task(\"Run in parallel item {loop.value}\",\n                      loop=\"items\") \\\n            .sub_process_end() \\\n        .branch_end() \\\n        .process_end()\\\n        .build(initial_data={\"items\": [1, 2, 3, 4, 5]})\n\n    assert len(data.executions) == 10\n\nHere you see the full BPMN power starting to unfold. We create a process\nthat branches out, creates sub processes (sub processes can be looped as\na single unit). Loops are creating execution tokens that also run in\nparallel in the same pool.\n\nNote that you can pass ``initial_data`` into the process, and you can\nalso get the ``context.data`` from the last execution token.\n\nBPMN Process\n------------\n\nLast but not least, adhesive reads BPMN files, and builds the process\ngraph from them. This is particularly good if the process is complex and\nhas a lot of dependencies:\n\n|BPMN Editor|\n\nThe `build of adhesive`_ is modeled as a `BPMN process`_ itself, so we\nload it from the file directly using:\n``adhesive.build_bpmn(\"adhesive-self.bpmn\")``\n\n.. code:: python\n\n    import adhesive\n\n    @adhesive.task(\"Read Parameters\")\n    def read_parameters(context) -> None:\n        context.data.run_mypy = False\n        context.data.test_integration = True\n\n    @adhesive.task(re=r\"^Ensure Tooling:\\s+(.+)$\")\n    def gbs_ensure_tooling(context, tool_name) -> None:\n        ge_tooling.ensure_tooling(context, tool_name)\n\n    # ...\n\n    adhesive.build_bpmn(\"adhesive-self.bpmn\")\n\nAs you see steps are parametrizable, and use the data from the task name\ninto the step definition.\n\nDefining BPMN Tasks\n===================\n\nFor example here, we define an implementation of tasks using regex\nmatching, and extracting values:\n\n.. code:: python\n\n    @adhesive.task(re=r\"^Ensure Tooling:\\s+(.+)$\")\n    def gbs_ensure_tooling(context, tool_name) -> None:\n        # ...\n\nOr a user task (interactive form):\n\n.. code:: python\n\n    @adhesive.usertask('Publish to PyPI?')\n    def publish_to_pypi_confirm(context, ui):\n        ui.add_checkbox_group(\n            \"publish\",\n            title=\"Publish\",\n            values=(\n                (\"nexus\", \"Publish to Nexus\"),\n                (\"pypitest\", \"Publish to PyPI Test\"),\n                (\"pypi\", \"Publish to PyPI\"),\n            ),\n            value=(\"pypitest\", \"pypi\")\n        )\n\nDon’t forget, the ``@adhesive.task`` and ``@adhesive.usertask`` are just\ndefining mappings for implementations of the task names available in the\nprocess. Only the ``adhesive.build()`` creates a linear process out of\nthe declaration of the tasks.\n\nAs you notice, there’s always a first parameter named ``context``. The\n``context`` parameter contains the following information:\n\n1. ``task`` - the Task in the graph that’s currently matched against\n   this execution.\n\n2. ``task_name`` - The resolved name, with the variables interpolated.\n   Matching is attempted *after* the name is resolved.\n\n3. ``data`` - Data that the current execution token contains. This data\n   is always cloned across executions, and \\`set\\`s and \\`dict\\`s are\n   automatically merged if multiple execution tokens are merged. So you\n   have a modifiable copy of the data that you’re allowed to change, and\n   is propagated into the following execution tokens.\n\n4. ``loop`` - if the current task is in a loop, the entry contains its\n   ``index``, the ``key`` and ``value`` of the items that are iterating,\n   and the ``expression`` that was evaluated. Note that loop execution\n   happens in parallel since these are simple execution tokens.\n\n5. ``lane`` - the current lane where the tasks belongs. Implicitly it’s\n   ``default``.\n\n6. ``workspace`` - a way to interact with a system, and execute\n   commands, create files, etc.\n\n``adhesive`` runs all the tasks on a parallel process pool for better\nperformance. This happens automatically.\n\nThe tasks perform the actual work for the build. But in order to have\nthat, we need to be able to execute commands, and create files. For that\nwe have the ``workspace``.\n\nStart Event Messages\n====================\n\nAdhesive supports also start events with messages in the process. Each\nmessage start event, is being processed in its own thread and ``yield``\nresults:\n\n.. code:: python\n\n    @adhesive.message('Generate Event')\n    def message_generate_event(context):\n        for i in range(10):\n            yield i\n\n    @adhesive.task('Process Event')\n    def process_event(context):\n        print(f\"event data: {context.data.event}\")\n\nEach yield generates a new event that fires up the connected tasks. The\ndata yielded is present in the ``event`` attribute in the token, for the\nfollowing tasks.\n\nCallback Messages\n-----------------\n\nThe other option to push messages into a process is to use callback\nmessages:\n\n.. code:: python\n\n    @adhesive.message_callback('REST: /rest/process-resource')\n    def message_rest_rest_process_resource(context, callback):\n        @app.route(\"/rest/resource/create\")\n        def create_resource():\n            callback(Dict({\n                \"type\": \"CREATE\"\n            }))\n\n            return \"Create event fired\"\n\nUsing this we’re able to hook into other systems that have their own\nloop, such as in this case the Flask server, and push messages using the\n``callback``. This approach has also the advantage of not creating new\nthreads for each message endpoint.\n\nConnections\n===========\n\nTasks are linked using connections. In some cases, connections can have\nconditions. Conditions are expressions that when evaluated to ``True``\nwill allow the token to pass the connection. In the connection there is\naccess to the ``task``, ``task_name``, ``data``, ``loop``, ``lane`` and\n``context``, as well as the variables defined in the ``context.data``.\n\nSo if in a task there is defined a data field such as:\n\n.. code:: py\n\n    @adhesive.task('prepare data')\n    def prepare_data(context):\n        context.data.navigation_direction = \"forward\"\n\nThe ``navigation_direction`` can be validated in the condition with any\nof the following:\n\n-  ``context.data.navigation_direction == \"forward\"``\n\n-  ``data.navigation_direction == \"forward\"``\n\n-  ``navigation_direction == \"forward\"``\n\nWorkspace\n=========\n\nWorkspaces are just a way of interacting with a system, running\ncommands, and writing/reading files. Currently there’s support for:\n\n-  the local system\n\n-  docker containers\n\n-  kubernetes\n\n-  remote SSH connections\n\nWhen starting ``adhesive`` allocates a default workspace folder in the\nconfigured temp location (implicitly ``/tmp/adhesive``). The\n``Workspace`` API is an API that allows you to run commands, and create\nfiles, taking care of redirecting outputs, and even escaping the\ncommands to be able to easily run them inside docker containers.\n\nThe workspace is available from the cotext directly from the\n``context``, by calling ``context.workspace``.\n\nFor example calling ``context.workspace.run(…​)`` will run the command\non the host where adhesive is running:\n\n.. code:: python\n\n    @adhesive.task(\"Run Maven\")\n    def build_project(context) -> None:\n        context.workspace.run(\"mvn clean install\")\n\nIf we’re interested in the program output we simply do a ``run`` with a\n``capture_stdout`` that returns the output as a string:\n\n.. code:: python\n\n    @adhesive.task(\"Test\")\n    def gbs_test_linux(context) -> None:\n        content = context.workspace.run(\"echo yay\", capture_stdout=True)\n        assert content == \"yay\"\n\nor we can use the simplified call with ``run_output`` that guarantees a\n``str`` as result, unlike the ``Optional[str]`` for ``run``:\n\n.. code:: python\n\n    @adhesive.task(\"Test\")\n    def gbs_test_linux(context) -> None:\n        content = context.workspace.run_output(\"echo yay\")\n        assert content == \"yay\"\n\nThe ``run`` commands implicitly use ``/bin/sh``, but a custom shell can\nbe specified by passing the ``shell`` argument:\n\n.. code:: python\n\n    content = context.workspace.run_output(\"echo yay\", shell=\"/bin/bash\")\n\nDocker Workspace\n----------------\n\nTo create a docker workspace that runs inside a container with the\ntooling you just need to:\n\n.. code:: python\n\n    from adhesive.workspace import docker\n\nThen to spin up a container that has the current folder mounted in,\nwhere you’re able to execute commands *inside* the container. You just\nneed to:\n\n.. code:: python\n\n    @adhesive.task(\"Test\")\n    def gbs_test_linux(context) -> None:\n        image_name = 'some-custom-python'\n\n        with docker.inside(context.workspace, image_name) as w:\n            w.run(\"python -m pytest -n 4\")\n\nThis creates a container using our current context workspace, where we\nsimply execute what we want, using the ``run()`` method. After the\n``with`` statement the container will be teared down automatically.\n\nSSH Workspace\n-------------\n\nIn order to have ssh, make sure you installed ``adhesive`` with SSH\nsupport:\n\n.. code:: sh\n\n    pip install -U adhesive[ssh]\n\nTo have a SSH Workspace, it’s again the same approach:\n\n.. code:: python\n\n    from adhesive.workspace import ssh\n\nThen to connect to a host, you can just use the ``ssh.inside`` the same\nway like in the docker sample:\n\n.. code:: python\n\n    @adhesive.task(\"Run over SSH\")\n    def run_over_ssh(context) -> None:\n        with ssh.inside(context.workspace,\n                        \"192.168.0.51\",\n                        username=\"raptor\",\n                        key_fileaname=\"/home/raptor/.ssh/id_rsa\") as s:\n            s.run(\"python -m pytest -n 4\")\n\nThe parameters are being passed to paramiko, that’s the implementation\nbeneath the ``SshWorkspace``.\n\nKubernetes Workspace\n--------------------\n\nTo run things in pods, it’s the same approach:\n\n.. code:: python\n\n    from adhesive.workspace import kube\n\nThen we can create a workspace to run things in kubernetes pods. The\nworkspace, as well as the API, will use the ``kubectl`` command\ninternally.\n\n.. code:: python\n\n    @adhesive.task(\"Run things in the pod\")\n    def run_in_the_pod(context) -> None:\n        with kube.inside(context.workspace,\n                         pod_name=\"nginx-container\") as pod:\n            pod.run(\"ps x\")  # This runs in the pod\n\nKubernetes API\n--------------\n\nAdhesive also packs a kubernetes api, that’s available on the\n``adhesive.kubeapi``:\n\n.. code:: python\n\n    from adhesive.kubeapi import KubeApi\n\nTo use it, we need to create an instance against a workspace.\n\n.. code:: python\n\n    @adhesive.gateway('Determine action')\n    def determine_action(context):\n        kubeapi = KubeApi(context.workspace,\n                          namespace=context.data.target_namespace)\n\nLet’s create a namespace:\n\n.. code:: python\n\n    kubeapi.create(kind=\"ns\", name=context.data.target_namespace)\n\nOr let’s create a service using the ``kubectl apply`` approach:\n\n.. code:: python\n\n        kubeapi.apply(f\"\"\"\n            apiVersion: v1\n            kind: Service\n            metadata:\n                name: nginx-http\n                labels:\n                    app: {context.data.target_namespace}\n            spec:\n                type: ClusterIP\n                ports:\n                - port: 80\n                  protocol: TCP\n                  name: http\n                selector:\n                  app: {context.data.target_namespace}\n        \"\"\")\n\nOr let’s get some pods:\n\n.. code:: python\n\n        pod_definitions = kubeapi.getall(\n            kind=\"pod\",\n            filter=f\"execution_id={context.execution_id}\",\n            namespace=context.data.target_namespace)\n\nThese returns objects that allow navigating properties as regular python\nattributes:\n\n.. code:: python\n\n        new_pods = dict()\n        for pod in pod_definitions:\n            if not pod.metadata.name:\n                raise Exception(f\"Wrong definition {pod}\")\n\n            new_pods[pod.metadata.name] = pod.status.phase\n\nYou can also navigate properties that are not existing yet, for example\nto wait for the status of a pod to appear:\n\n.. code:: python\n\n    @adhesive.task('Wait For Pod Creation {loop.key}')\n    def wait_for_pod_creation_loop_value_(context):\n        kubeapi = KubeApi(context.workspace,\n                          namespace=context.data.target_namespace)\n        pod_name = context.loop.key\n        pod_status = context.loop.value\n\n        while pod_status != 'Running':\n            time.sleep(5)\n            pod = kubeapi.get(kind=\"pod\", name=pod_name)\n\n            pod_status = pod.status.phase\n\nTo get the actual data from the wrappers that the adhesive API creates,\nyou can simply call the ``_raw`` property.\n\nWorkspace API\n-------------\n\nHere’s the full API for it:\n\n.. code:: python\n\n    class Workspace(ABC):\n        \"\"\"\n        A workspace is a place where work can be done. That means a writable\n        folder is being allocated, that might be cleaned up at the end of the\n        execution.\n        \"\"\"\n\n        @abstractmethod\n        def write_file(\n                self,\n                file_name: str,\n                content: str) -> None:\n            pass\n\n        @abstractmethod\n        def run(self,\n                command: str,\n                capture_stdout: bool = False) -> Union[str, None]:\n            \"\"\"\n            Run a new command in the current workspace.\n\n            :param capture_stdout:\n            :param command:\n            :return:\n            \"\"\"\n            pass\n\n        @abstractmethod\n        def rm(self, path: Optional[str]=None) -> None:\n            \"\"\"\n            Recursively remove the file or folder given as path. If no path is sent,\n            the whole workspace will be cleared.\n\n            :param path:\n            :return:\n            \"\"\"\n            pass\n\n        @abstractmethod\n        def mkdir(self, path: str=None) -> None:\n            \"\"\"\n            Create a folder, including all its needed parents.\n\n            :param path:\n            :return:\n            \"\"\"\n            pass\n\n        @abstractmethod\n        def copy_to_agent(self,\n                          from_path: str,\n                          to_path: str) -> None:\n            \"\"\"\n            Copy the files to the agent from the current disk.\n            :param from_path:\n            :param to_path:\n            :return:\n            \"\"\"\n            pass\n\n        @abstractmethod\n        def copy_from_agent(self,\n                            from_path: str,\n                            to_path: str) -> None:\n            \"\"\"\n            Copy the files from the agent to the current disk.\n            :param from_path:\n            :param to_path:\n            :return:\n            \"\"\"\n            pass\n\n        @contextmanager\n        def temp_folder(self):\n            \"\"\"\n            Create a temporary folder in the current `pwd` that will be deleted\n            when the `with` block ends.\n\n            :return:\n            \"\"\"\n            pass\n\n        @contextmanager\n        def chdir(self, target_folder: str):\n            \"\"\"\n            Temporarily change a folder, that will go back to the original `pwd`\n            when the `with` block ends. To change the folder for the workspace\n            permanently, simply assing the `pwd`.\n            :param target_folder:\n            :return:\n            \"\"\"\n            pass\n\nUser Tasks\n==========\n\nIn order to create user interactions, you have user tasks. These define\nform elements that are populated in the ``context.data``, and available\nin subsequent tasks.\n\nWhen a user task is encountered in the process flow, the user is\nprompted to fill in the parameters. Note that the other started tasks\ncontinue running, proceeding forward with the build.\n\nThe ``name`` used in the method call defines the name of the variable\nthat’s in the ``context.data``.\n\nFor example in here we define a checkbox group that allows us to pick\nwhere to publish the package:\n\n.. code:: python\n\n    @adhesive.usertask(\"Read User Data\")\n    def read_user_data(context, ui) -> None:\n        ui.add_input_text(\"user\",\n                title=\"Login\",\n                value=\"root\")\n        ui.add_input_password(\"password\",\n                title=\"Password\")\n        ui.add_checkbox_group(\"roles\",\n                title=\"Roles\",\n                value=[\"cyborg\"],\n                values=[\"admin\", \"cyborg\", \"anonymous\"])\n        ui.add_radio_group(\"disabled\",  # title is optional\n                values=[\"yes\", \"no\"],\n                value=\"no\")\n        ui.add_combobox(\"machine\",\n                title=\"Machine\",\n                values=((\"any\", \"<any>\"),\n                        (\"win\", \"Windows\"),\n                        (\"lin\", \"Linux\")))\n\nThis will prompt the user with this form:\n\n|form|\n\nThis data is also available for edge conditions, so in the BPMN modeler\nwe can define a condition such as ``\"pypi\" in context.data.roles``, or\nsince ``data`` is also available in the edge scope:\n``\"pypi\" in data.roles``.\n\nThe other option is simply reading what the user has selected in a\nfollowing task:\n\n.. code:: python\n\n    @adhesive.task(\"Register User\")\n    def publish_items(context):\n        for role in context.data.roles:\n            # ...\n\nUser tasks support the following API, available on the ``ui`` parameter,\nthe parameter after the context:\n\n.. code:: python\n\n    class UiBuilderApi(ABC):\n        def add_input_text(self,\n                           name: str,\n                           title: Optional[str] = None,\n                           value: str = '') -> None:\n\n        def add_input_password(self,\n                               name: str,\n                               title: Optional[str] = None,\n                               value: str = '') -> None:\n\n        def add_combobox(self,\n                         name: str,\n                         title: Optional[str] = None,\n                         value: Optional[str]=None,\n                         values: Optional[Iterable[Union[Tuple[str, str], str]]]=None) -> None:\n\n        def add_checkbox_group(\n                self,\n                name: str,\n                title: Optional[str]=None,\n                value: Optional[Iterable[str]]=None,\n                values: Optional[Iterable[Union[Tuple[str, str], str]]]=None) -> None:\n\n        def add_radio_group(self,\n                            name: str,\n                            title: Optional[str]=None,\n                            value: Optional[str]=None,\n                            values: Optional[List[Any]]=None) -> None:\n\n        def add_default_button(self,\n                               name: str,\n                               title: Optional[str] = None,\n                               value: Optional[Any] = True) -> None:\n\nCustom Buttons\n--------------\n\nIn order to allow navigation inside the process, the\n``add_default_button`` API exists to permit creation of buttons.\nImplicitly a single button with an ``OK`` label is added to the User\nTask, that when pressed fills the ``context.data`` in the outgoing\nexecution token.\n\nWith ``add_default_button`` we create custom buttons such as ``Back``\nand ``Forward``, or whatever we need in our process. Unlike the default\n``OK`` button, when these are called, they also set in the\n``context.data`` the ``value`` that’s assigned to them. This value we\nuse then further in a ``Gateway``, or simple as a condition on the\noutgoing edges.\n\nThe title is optional, and only if missing it’s build either from the\n``name`` if all the buttons in the form have unique names, since they\nassign a different variable in the ``context.data``, or from the\n``value`` if they have overlapping names.\n\nSecrets\n=======\n\nSecrets are files that contain sensitive information are not checked in\nthe project. In order to make them available to the build, we need to\ndefine them in either ``~/.adhesive/secrets/SECRET_NAME`` or in the\ncurrent folder as ``.adhesive/secrets/SECRET_NAME``.\n\nIn order to make them available, we just use the ``secret`` function\nthat creates the file in the current workspace and deletes it when\nexiting. For example here’s how we’re doing the actual publish, creating\nthe secret inside a docker container:\n\n.. code:: python\n\n    @adhesive.task('^PyPI publish to (.+?)$')\n    def publish_to_pypi(context, registry):\n        with docker.inside(context.workspace, context.data.gbs_build_image_name) as w:\n            with secret(w, \"PYPIRC_RELEASE_FILE\", \"/germanium/.pypirc\"):\n                w.run(f\"python setup.py bdist_wheel upload -r {registry}\")\n\nNote the ``docker.inside`` that creates a different workspace.\n\nConfiguration\n=============\n\nAdhesive supports configuration via its config files, or environment\nvariables. The values are read in the following order:\n\n1. environment variables: ``ADHESIVE_XYZ``, then\n\n2. values that are in the project config yml file:\n   ``.adhesive/config.yml``, then\n\n3. values configured in the global config yml file:\n   ``$HOME/.adhesive/config.yml``.\n\nCurrently the following values are defined for configuration:\n\ntemp\\_folder\n------------\n\ndefault value ``/tmp/adhesive``, environment var:\n``ADHESIVE_TEMP_FOLDER``.\n\nIs where all the build files will be stored.\n\nplugins\n-------\n\ndefault value ``[]``, environment var: ``ADHESIVE_PLUGINS_LIST``.\n\nThis contains a list of folders, that will be added to the ``sys.path``.\nSo to create a reusable plugin that will be reused by multiple builds,\nyou need to simply create a folder with python files, then point to it\nin the ``~/.adhesive/config.yml``:\n\n.. code:: yaml\n\n    plugins:\n    - /path/to/folder\n\nThen in the python path you can simply do regular imports.\n\ncolor\n-----\n\ndefault value ``True``, environment var: ``ADHESIVE_COLOR``.\n\nMarks if the logging should use ANSI colors in the terminal. Implicitly\nthis is ``true``, but if log parsing is needed, it can make sense to\nhave it false.\n\nlog\\_level\n----------\n\ndefault\\_value ``info``, environment var: ``ADHESIVE_LOG_LEVEL``.\n\nHow verbose should the logging be on the terminal. Possible values are\n``trace``, ``debug``, ``info``, ``warning``, ``error`` and ``critical``.\n\npool\\_size\n----------\n\ndefault value is empty, environment var: ``ADHESIVE_POOL_SIZE``.\n\nSets the number of workers that adhesive will use. Defaults to the\nnumber of CPUs if unset.\n\nstdout\n------\n\ndefault value is empty, environment var: ``ADHESIVE_STDOUT``.\n\nImplicitly for each task, the log is redirected in a different file, and\nonly shown if the task failed. The redirection can be disabled.\n\nparallel\\_processing\n--------------------\n\ndefault value is ``thread``, environment var:\n``ADHESIVE_PARALLEL_PROCESSING``.\n\nImplicitly tasks are scaled using multiple threads in order to alleviate\nwaits for I/O. This is useful for times when remote ssh workspaces are\ndefined in the lanes, so the same connection can be reused for multiple\ntasks.\n\nThis value can be set to ``process``, in case the tasks are CPU\nintensive. This has the drawback of recreating the connections on\nworkspaces' each task execution.\n\nHacking Adhesive\n================\n\nAdhesive builds with itself. In order to do that, you need to checkout\nthe `adhesive-lib`_ shared plugin, and configure your local config to\nuse it:\n\n.. code:: yaml\n\n    plugins:\n    - /path/to/adhesive-lib\n\nThen simply run the build using adhesive itself:\n\n.. code:: sh\n\n    adhesive\n\n.. _build of adhesive: _adhesive.py\n.. _BPMN process: adhesive-self.bpmn\n.. _adhesive-lib: https://github.com/germaniumhq/adhesive-lib\n\n.. |BPMN Editor| image:: ./doc/yaoqiang-screenshot.png\n.. |form| image:: ./doc/console_usertask.png\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "AGPL3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "adhesive-zeebe",
    "package_url": "https://pypi.org/project/adhesive-zeebe/",
    "platform": "",
    "project_url": "https://pypi.org/project/adhesive-zeebe/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/adhesive-zeebe/2021.4.3/",
    "requires_dist": [
      "addict",
      "networkx (==2.3)",
      "npyscreen (==4.10.5)",
      "colorama (>=0.4.3)",
      "termcolor-util (<2.0,>=1.2.0)",
      "PyYAML (==5.1.2)",
      "click (<8.0,>=7.0)",
      "schedule (==0.6.0)",
      "python-dateutil (==2.8.1)",
      "yamldict (<2.0,>=1.2.0)",
      "Pebble (==4.6.1)",
      "cached-task (==2021.4.3)",
      "paramiko (==2.6.0) ; extra == 'ssh'"
    ],
    "requires_python": "",
    "summary": "adhesive fork with support for Zeebe XML extension",
    "version": "2021.4.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11958422,
  "releases": {
    "2021.4.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9f4bdb4a52fe0fe2b9c0235c9abec79d5a8e6967571e3ead70a10ee931bb0f95",
          "md5": "17d433000ef39d3da02f429446ee1af9",
          "sha256": "0da426eabdd068c85e5f3533d6418f55c6127d93ebd2fb46ee8960926b5eecd8"
        },
        "downloads": -1,
        "filename": "adhesive_zeebe-2021.4.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "17d433000ef39d3da02f429446ee1af9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 134618,
        "upload_time": "2021-11-08T09:30:12",
        "upload_time_iso_8601": "2021-11-08T09:30:12.497784Z",
        "url": "https://files.pythonhosted.org/packages/9f/4b/db4a52fe0fe2b9c0235c9abec79d5a8e6967571e3ead70a10ee931bb0f95/adhesive_zeebe-2021.4.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eeaddd7eb9fb793f4846e3456f10e262896da091139c39f7560fdbd8af6c18a8",
          "md5": "ee540b87216afc536980a1df4e647c27",
          "sha256": "a72edf6501e8de5a9f30ef452ae789158f59ab43d1871b4dabe53a5ba0daeda9"
        },
        "downloads": -1,
        "filename": "adhesive-zeebe-2021.4.3.tar.gz",
        "has_sig": false,
        "md5_digest": "ee540b87216afc536980a1df4e647c27",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 86334,
        "upload_time": "2021-11-08T09:30:15",
        "upload_time_iso_8601": "2021-11-08T09:30:15.985894Z",
        "url": "https://files.pythonhosted.org/packages/ee/ad/dd7eb9fb793f4846e3456f10e262896da091139c39f7560fdbd8af6c18a8/adhesive-zeebe-2021.4.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9f4bdb4a52fe0fe2b9c0235c9abec79d5a8e6967571e3ead70a10ee931bb0f95",
        "md5": "17d433000ef39d3da02f429446ee1af9",
        "sha256": "0da426eabdd068c85e5f3533d6418f55c6127d93ebd2fb46ee8960926b5eecd8"
      },
      "downloads": -1,
      "filename": "adhesive_zeebe-2021.4.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "17d433000ef39d3da02f429446ee1af9",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 134618,
      "upload_time": "2021-11-08T09:30:12",
      "upload_time_iso_8601": "2021-11-08T09:30:12.497784Z",
      "url": "https://files.pythonhosted.org/packages/9f/4b/db4a52fe0fe2b9c0235c9abec79d5a8e6967571e3ead70a10ee931bb0f95/adhesive_zeebe-2021.4.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "eeaddd7eb9fb793f4846e3456f10e262896da091139c39f7560fdbd8af6c18a8",
        "md5": "ee540b87216afc536980a1df4e647c27",
        "sha256": "a72edf6501e8de5a9f30ef452ae789158f59ab43d1871b4dabe53a5ba0daeda9"
      },
      "downloads": -1,
      "filename": "adhesive-zeebe-2021.4.3.tar.gz",
      "has_sig": false,
      "md5_digest": "ee540b87216afc536980a1df4e647c27",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 86334,
      "upload_time": "2021-11-08T09:30:15",
      "upload_time_iso_8601": "2021-11-08T09:30:15.985894Z",
      "url": "https://files.pythonhosted.org/packages/ee/ad/dd7eb9fb793f4846e3456f10e262896da091139c39f7560fdbd8af6c18a8/adhesive-zeebe-2021.4.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}