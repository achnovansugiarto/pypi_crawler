{
  "info": {
    "author": "",
    "author_email": "Wennströms byrå för datateknik AB <adrian@webyda.se>",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Intended Audience :: Developers",
      "Intended Audience :: Information Technology",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Internet",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
      "Topic :: Software Development :: Libraries",
      "Topic :: Software Development :: Libraries :: Application Frameworks"
    ],
    "description": "# Skick\nSkick is a library for building actor based back ends for web applications. It\nallows clients to connect over a websocket and interact with *actors*\nusing JSON encoded messages.\n\nA simple hello world program would look something like:\n\n```python\nfrom skick import Skick\n\nskick = Skick()\n\n@skick.session(\"hello\")\ndef hello_world(inst, message):\n    \"\"\" A hello world type user session \"\"\"\n    @inst.on_start\n    async def on_start():\n        await inst.socksend({\"greeting\": \"Hello, use the action 'greet' to receive a greeting\"})\n    \n    @inst.socket(\"greet\", {\"action\": \"greet\"})\n    async def greet(msg):\n        await inst.socksend({\"greeting\": \"Hello good sir\"})\n\nskick.start()\n```\n\nIn the example above, a single core instance of Skick is instantiated and a websocket server is opened on\nport 8000. A so called \"session\" is declared and registered with the system.\nThis allows users to connect over a websocket and request a \"hello\" session\nusing the command `{\"session_type\": \"hello\"}`. If they do, a pair of actors,\na *receptionist* and a *session actor* will be instantiated on the server and\nassociated with the connection. The receptionist receives and sends messages\nover the websocket and filters them to ensure they conform to predefined\nschemas. The session actor receives the accepted messages and processes them\nwithin the actor model.\n\nIn this particular case, the session actor will begin by sending the message\n```\n{\"greeting\": \"Hello, use the action 'greet' to receive a greeting\"}\n```\nto the client, and will then proceed to await further communications from the\nclient. This particular session type has only one registered schema, namely\nthe one associated with the \"greet\" action. If the client sends a conforming\nmessage, the method greet will be scheduled and run resulting in the following\ninteraction\n\n```\nClient: {\"session_type\": \"hello\"}\nServer: {\"greeting\": \"Hello, use the action 'greet' to receive a greeting\"}\nClient: {\"action\": \"greet\"}\nServer: {\"greeting\": \"Hello good sir\"}\n```\n\nThis demonstrates some of the fundamental ideas behind Skick. Actors should\nbe defined in much the same way as endpoints in the most popular HTTP\nframeworks like Flask and Sanic. There should be minimal boilerplate\nrequirements, and the library should interface seamlessly with a JavaScript\nclient in a browser. In order to see the full picture, we will need to\ntake a deeper dive into the features and general architecture of the system.\n## The Current State of the Project\nSkick is in an experimental state. It is essentially a proof of concept. It has\nnot been battle tested on the internet, and has not been extensively analyzed\nfor vulnerabilities. There are certain weak points.\n\n## The Actor\nAt the heart of the Skick system lies the lone actor. Actors are program units\nwhich have a mailbox attached. They receive messages in this mailbox and\nin response to these messages, they can do any combination of the following:\n\n1. Send messages to other actors.\n2. Spawn new actors.\n3. Replace their current set of responses with a different set of responses.\n\nWhile this leads to a nice and tidy theoretical model, such as the one\nexhibited in Gul Agha's *Actors, A Model of Concurrent Computation in\nDistributed Systems* from 1986, it does so at the expense of certain practical\nrealities of software development. For this reason, additional capabilities have\nbeen added to Skick. In particular, Skick actors also have abilities like:\n\n4. Maintaining state.\n5. Running daemons.\n6. Running functions on startup and on stopping.\n7. Maintaining stateful conversations with other actors.\n8. Receiving notices when actors cease to run.\n\n### Defining Actors\nActors in Skick are defined in *synchronous* declarative functions which are\nregistered by a special *shard* actor (conveniently hidden away in the Skick\nobject). The actor is instantiated by this shard actor when it is needed. The\ncreation process proceeds in the following steps:\n\n1. The shard actor creates an Actor object.\n2. The shard actor runs the actor's declarative function on the actor object.\n3. The function stores the actor's state in the closures of the functions defined within, and registers message\n   handlers (behaviors in actor terminology), daemons and other necessary\n   methods.\n4. The actor runs the on_start method if one has been registered.\n5. The actor starts separate tasks for the daemons (be careful of race\n   conditions).\n6. The actor starts the message processing loop in the main task.\n\nIn practice, defining actors is done through the `actor` method in some Skick instance\n```python\n@skick.actor(actor_name)\ndef function_name(actor_instance, init_message):\n    ...\n```\nHere, `actor_name` is a string used to refer to the actor type when requesting\nit from the shard. The `actor_instance` is the instance of the Actor class that\nthe shard has prepared for us, and the `init_message` is some *message*\n(messages in skick are always dictionaries) that helps us set up the initial\nstate of the actor.\n\nWithin the function, the `actor_instance` contains methods which decorate\nasynchronous functions in various ways. These are\n\n1. `@inst.action(action_name, [optional schema])` which defines a response to\n   a particular message type\n2. `@inst.on_start` which registers an asynchronous method to run on startup.\n   N.B: It is very important to run time consuming initiation steps such as\n   fetching information from an API asynchronously in this `on_start` function.\n   If you do not do this, then you will hold up the shard actor,\n   freezing the entire shard.\n3. `@inst.on_stop` which acts as the inverse of `on_start`, being run during\n   the ordinary shutdown procedure.\n4. `@inst.daemon(name)` which registers an asynchronous function that will run in\n   a separate task under the name `name`.\n5. `@inst.conversation(name)` which will be discussed later, but which formerly\n   decorated asynchronous generator functions to produce the stateful\n   conversation mechanism. More on this later.\n\nTo illustrate how these parts function together, an example is in order.\n\n```python\n@skick.actor(\"accumulator\")\ndef accumulator(inst, message):\n    \"\"\" An actor that adds numbers to an internal tally. \"\"\"\n    tally = message.get(\"initial_tally\", 0)\n\n    @inst.daemon(\"tally_reporter\")\n    async def report():\n        \"\"\" Reports the current tally with regular intervals if asked to \"\"\"\n        while \"report_to\" in message:\n            await asyncio.sleep(1)\n            await inst.send(message[\"report_to\"],\n                            {\"action\": \"report_tally\", \"tally\": tally})\n\n    @inst.action(\"add\", schema={\"action\": \"add\", \"number\": int})\n    async def adder(msg):\n        \"\"\" Adds msg[\"number\"] to the tally found in the closure \"\"\"\n        nonlocal tally # Necessary nonlocal declaration for immutable objects\n        tally += msg[\"number\"]\n    \n    @inst.action(\"get_tally\", schema={\"action\": \"get_tally\", \"sender\": str})\n    async def get_tally(msg):\n        \"\"\"\n        Asks the actor to send the current tally to *sender*. This could\n        have used the conversation mechanism which we will introduce later.\n        \"\"\"\n        await inst.send(msg[\"sender\"], {\"action\": \"report_tally\", \"tally\": tally})\n```\n### Helper Methods\nThere are a number of helpful methods in the actor instance.\n\n1. `async inst.send(address, message)` which sends the message (a dictionary) to\n   to the actor that has the address *address*. In general, this address must be\n   known in advance.\n2. `async inst.replace(new_type, message)` which replaces the current actor's\n   behaviors with a new set of behaviors defined in some actor definition.\n   This function strips the actor of all but its address, purging\n   all daemons, all message handlers, conversations, all its closures etc.\n3. `async inst.converse(partner, initial_message, prorotype)` which initiates a\n   conversation with the `partner` actor. More on this later.\n4. `async inst.spawn(actor_type, message, ...)` which asks the shard object to\n   spawn a new actor of the type `actor_type` and send it the initial message\n   `message`. By default, this is spawned on the same shard in clusters, and\n   the requesting actor is added as a monitor so that it will be notified when\n   the new actor dies. \n5. `register_service(name)` which registers the actor in the service registry\n   as probiding the service `name`\n6. `unregister_service()` which removes all mentions of the actor from the service\n   registry\n7. `get_service(name, local=\"mixed\")`, which retrieves a random service provider\n   for the service, either from\n   1. `local=\"local\"` only shard local providers;\n   2. `local=\"mixed\"` local or remote shards, preferring local shards if available; or\n   3. `local=\"remote\"` only remote providers.\n\n### How to Run Actors\nActors that have been defined in the manner described above are not\nautomatically instantiated. They have to be requested somewhere in the program.\nApart from being spawned as a response to user connections in the session system,\nshards may be spawned by any actor using the `spawn` method. In order to spawn\nactors when the shard starts up, the user can define an `on_start` method. \n\nThis method is scheduled to run when the shard starts up and is supplied with a\ndirect reference to the shard actor, so that we may use it to spawn more actors\nas shown in the example below:\n\n```python\nfrom skick import Skick\n\nasync def on_start(shard):\n    await shard.spawn(\"accumulator\", {\"initial_tally\": 420})\n\nskick = Skick(on_start=on_start)\n\n...\n\nskick.start()\n```\n\n### Conversations\nOften, actors have to communicate back and forth in specific sequences. This may\nbe as simple as actor A asking actor B what the value of some variable is.\nWith the basic messaging functionality we have to solve this problem through a\ncombination of complicated state management, replacement and defining receiving\nand sending actions in separate methods.\n\nThis is *too* inconvenient in many situations. For this reason, Skick provides\nan alternative out of the box called a *conversation*. A conversation takes\nplace between two actors, one caller and one responder. These take turns in passing\nmessages to eachother in a call and response fashion.\n\nIn a conversation in Skick, the actions involved are not normal asynchronous\nfunctions, but asynchronous generator functions. Messages are sent and received \nthrough the use of the `yield` keyword. Conversations are set up by yielding\nspecial `Conversation` objects, subclassed in one `Call` and one `Respond` variety\nfor convenience, and are managed by the actor objects out of the view\nof the programmer. Suppose the Accumulator actor from before were to return the\nnew tally whenever it received an \"add\" request. We could rewrite the action as\na conversation in the following manner.\n\n```python\n\n...\n\nfrom skick import Skick, Respond\n\n...\n\n@skick.actor(\"accumulator\")\ndef accumulator(inst, message):\n    \"\"\" An actor that adds numbers to an internal tally. \"\"\"\n    tally = message.get(\"initial_tally\", 0)\n\n    ...\n\n    @inst.action(\"add\")\n    async def adder(msg):\n        \"\"\"\n        Here, because adder is responding in a conversation, the msg parameter\n        is generated by the calling actor, and is not manually constructed by\n        the programmer. It contains the necessary parameters to respond to the\n        call.\n        \"\"\"\n        nonlocal tally # Necessary nonlocal declaration for immutable objects\n        yield Respond(msg) # We first \"pick up the phone\" as it were\n        \n        tally += msg[\"number\"]\n        yield {\"tally\": tally} # Then we yield a response\n```\nIn the corresponding caller, another asynchronous generator is found:\n\n```python\n...\n\nfrom skick import Skick, Call\n\n...\n\n@skick.actor(\"caller\")\ndef caller(inst, message):\n\n    ...\n\n    @inst.action(\"call_adder\")\n    async def call_adder(msg):\n        new_tally = yield Call(adder_address, {\"number\": 10})\n\n    ...\n```\nThese conversations can go on for many exchanges, each (with the exception of the `yield Respond(...)`\ncall) taking the form:\n```python\n    ...\n    response_to_our_message = yield our_message\n    ...\n```\n\nIn the caller actor above, the conversation was initiated because we received\na message the handler of which was a *conversation prototype*. This is not always\nappropriate. For example, we may wish to start conversations in the `on_start` method\nor in some daemon. If we wish to do this, we can create a conversation using the\n`inst.converse` method. `inst.converse` can be called in two ways. Either,\nit can be used to invoke a registered prototype by passing its string identifier,\nor we can pass some asynchronous generator function. In other words, we could\nimagine a scenario like the following.\n\n```python\n@skick.actor(\"caller\")\ndef caller(inst, message):\n\n    ...\n\n    @inst.on_start\n    async def init():\n\n        ...\n\n        async def send_number(msg):\n            response = yield Call(adder_address, {\"number\": 720})\n            await do_something(response)\n\n        await inst.converse({}, send_number)\n\n    ...\n```\n\n## The Special Actors\nThere are two special actors in Skick. The *shard* actor and the *WebSocket*\nactor. Both are automatically instantiated by the Skick object, but the latter\ncan be disabled if you do not wish to enable websocket functionality.\n\nThese actors help the other actors in various ways.\n\n### The Shard Actor\nSkick instances may run in clusters, but even if they are run in a single core,\nthere is a special *shard* actor in the background. This actor performs a few\nhelpful jobs for the actors.\n\n1. It maintains a record of which actors are alive so they don't get garbage\n   collected.\n2. It maintains a registry of *services* which works like an internal DNS to which\n   actors can add themselves if they provide a service to other actors and from\n   which actors can request addresses to service providers.\n3. If there are several shards in the cluster, it will communicate with the other\n   shards to ensure it has up to date information about which services and actor types are available\n   on the other shards, as well as telling the other shards which services and actor types it provides.\n4. It helps spawn actors\n\nMost of these functions are not exposed to the user through the actual shard actor object.\nInstead, the shard injects helpers into all actors so that they can be accessed through any Actor instance.\nActors can also be spawned by sending a message to the shard, but this is\nprimarily meant for spawning shards remotely.\n\n### The WebsocketActor\nIf a websocket server has been requested, a special `WebsocketActor` will be instantiated. It maintains its own\ncollection of websocket handlers called *sessions* and *subsessions* as well as so called *handshake sequences*.\nThese are abstractions of lower level actors, to which websocket connections have been affixed.\nThe exact details are complicated enough to warrant their own chapter, but these special actors live in their own\nuniverse, which is managed by the `WebsocketActor`. The `WebsocketActor` also ensures\nthat the actors associated with the connection live and die together, and that they are both stopped when the connection terminates.\n\n## The Session and the Subsession\nIn the previous sections, we discussed features that live, so to speak,\ninside the clean room that your backend should be. However, for our backend to\nbe useful for anything, it has to be able to communicate with the outside world.\nMost importantly, it has to be able to communicate with clients over the internet.\nSkick's main method for this is to use *websockets*. Websockets allow bidirectional\ncommunication over persistent TCP connections with clients like web browsers\nand phone apps.\n\nThe way Skick handles these connections is to create a pair of actors for each incoming connection.\nThis syzygy of actors is called a *subsession*. If the client is able to directly request\nthe subsession type over the websocket, then it is called a *session*. All the other subsession types\nare created through subsession replacement.\n\nLet us recall the Hello World program from earlier:\n\n```python\n\n...\n\n@skick.session(\"hello\")\ndef hello_world(inst, message):\n    \"\"\" A hello world type user session \"\"\"\n    @inst.on_start\n    async def on_start():\n        await inst.socksend({\"greeting\": \"Hello, use the action 'greet' to receive a greeting\"})\n    \n    @inst.socket(\"greet\", {\"action\": \"greet\"})\n    async def greet(msg):\n        await inst.socksend({\"greeting\": \"Hello good sir\"})\n\n...\n```\n\nWe note that the `skick.session` function is very similar to an actor declaration.\nIt uses similar methods, like `@inst.on_start`. On top of this there are new methods,\nsuch as `@inst.socket` and `inst.socksend`. These serve to give us the illusion\nthat the session is a special type of actor. In reality, there are two different\nsubclasses for these special websocket actors, one `FrontActor` and one `BackActor`.\nThey both provide the same sets of decorators and methods, but the methods and\ndecorators do not have the same effects on them.\n\nWhen the `hello_world` function is run on a `FrontActor`, the `@inst.on_start`\ndecorator simply does nothing (there is a separate `@inst.front_on_start` method\nfor the exceptional case where you would want to run code on startup in the\n`FrontActor`). When the `@inst.socket` decorator is used, the `FrontActor` merely\nrecords the name of the method and the provided schema, but completely ignores\nthe function body. Likewise, the old `@inst.action` decorator has been\noverridden and does nothing on the `FrontActor`.\n\nWhen the `hello_world` function is run on a `BackActor`, the `@inst.on_start`\nand other standard decorators work as we would expect from a normal `Actor`.\nThey *target* the `BackActor` since it is the actual main actor of the session.\nAs for the `@inst.socket` decorator, it reverts to an `@inst.action` decorator\nignoring the schema entirely.\n\nMany methods have these dual interpretations. The `inst.socksend` method,\nwhich only exists on these special websocket actors, sends a message to the\nwebsocket client when it is called on the `FrontActor`, but if it is called in\nthe `BackActor`, it encapsulates the message in an action that asks the `FrontActor` to\nsend the encapsulated message over the websocket.\n\n### How Websocket Connections are Processed\nWhen a client requests a new websocket connection, the following steps are followed\n\n1. The underlying websocket library (currently only Websockets is available) creates a new task.\n   The task awaits an initial handshake message from the client, which must be\n   a dictionary and which must contain the field `\"session_type\"`.\n2. If the session type has been registered with the WebsocketActor, then it creates\n   two new actors. One using the `FrontActor` class and one using the `BackActor`\n   class.\n3. The same `session` definition function is run twice. Once on the FrontActor\n   and once on the BackActor function.\n4. The websocket actor coordinates these two actors by directly injecting references\n   to things like the websocket connection and the other actor in the pair into\n   the actor objects.\n5. The actors are both started in their own separate tasks.\n\nOnce this process has completed, the client can send messages to the server.\nIf it does, they will be processed in the following order:\n\n1. The request arrives over the websocket connection.\n2. It is received by a separate task in the `FrontActor`, where it is deserialized\n   and compared with locally available schemas.\n3. If there is a corresponding schema, and the deserialized message conforms to it,\n   the message is sent over the messaging system to the `BackActor`, where\n   the schema has a corresponding `action` which treats the message as any other\n   that has been sent over the messaging system.\n\nIf the `BackActor` chooses to send a message back to the client the following\ntakes place:\n\n1. The message is encapsulated into a message which is sent to the `FrontActor`\n2. The encapsulated message is received in the `FrontActor` and is processed as\n   any other action. The specific action, `\"socksend\"`, merely extracts the message and sends it\n   through a method in the `FrontActor`'s self._websocket field.\n\n### Why\nThis dual actor setup may seem like an unnecessarily complicated procedure. Surely, it must\nintroduce a plethora of bugs and cause all manner of performance penalties.\nThere is a reason why we want this type of division. Originally, it was\nconceived that we should separate the actors so that they could live on different shards.\nThis would separate the shards into those that only dealt with the outside world\nand those that dealt only with the innards of the actor system. In such a scenario,\nwe could scale the these systems independently, and we might be able to prevent\nexcess user requests from halting the entire system. Additionally, this type of clean\nseparation does not preclude associating *several* connections to the same session.\nThat is, a user who is connected on both his smartphone and his laptop could\ninteract with the system through the same `BackActor` even if he maintains\nseveral `FrontActor`s. These features are not\npresent in the system for the time being, and we may ultimately shift towards a\nsingle actor setup, where one actor performs all tasks required to maintain websocket\nconnections. Indeed, we may even settle for a solution where these mechanisms\ncoexist and can be used interchangeably depending on the context.\n\n### Specifics About the FrontActor's Methods\nThe FrontActor inherits all methods and decorators from the Actor class, but\nin order to access them we need to use different names, namely\n\n* The `@inst.front_action` decorator creates an action on the front actor\n* The `@inst.front_daemon` decorator creates a daemon on the front actor\n* The `@inst.front_on_start` decorator registers a startup method on the front actor\n* The `@inst.front_on_stop` decorator registers a shutdown method on the front actor\n* The `async inst.socksend` method sends a message to the websocket client\n\nApart from these special methods, a number of ordinary methods are either irrelevant\nor have had their functionalities altered\n\n1. The `@inst.action` decorator ignores the function it was fed.\n2. The `@inst.daemon` decorator ignores the function it was fed.\n3. The `@inst.on_start` decorator ignores the function it was fed.\n4. The `@inst.on_stop` decorator ignores the function it was fed.\n5. The `async inst.replace` method works as usual, but performs additional steps to accommodate for the websocket.\n   It is not invoked directly by the user, but is invoked in response to a message sent by the `BackActor`\n6. The conversation mechanisms function as usual, but are largely irrelevant.\n7. The service registry functions are not disabled, but only `get_service` should be used in practice.\n\n### Specifics About the BackActor's Methods\nLike in the case of the `FrontActor`, the `BackActor` inherits all decorators and\nmethods from the `Actor` class. Some of them function as usual, and some have\nhad their behaviors altered. In addition to this, all the methods defined on the \n`FrontActor` also exist on the `BackActor` but many of them do nothing. \n\n1. The `@inst.front_...` decorators all do nothing on the `BackActor`.\n2. The `@inst.daemon` and `@inst.action` decorators functions as they do on the\n   `Actor` class.\n3. The `async inst.socksend` method sends a message to the `FrontActor` instructing it to send a message to the client.\n4. The `async inst.replace` method replaces the `BackActor`, but also performs the additional step\n   of ordering the `FrontActor` to perform a corresponding replacement action on its end.\n   N.B: This operates over the messaging system, and may therefore be somewhat brittle in some situations.\n5. The conversation mechanisms function as usual, with the exception of the addition of a\n   special method to query the client for input. More on this later.\n6. The service registry functions are not disabled but only `get_service` should be used in practice.\n\n### Session Conversations\nWhen conversing with a handler defined through an `@inst.socket` decorator,\nthe conversation will be with the `BackActor`. The `BackActor` has the ability\nto use its turn to interject a user query into the conversation. This is done\nby yielding a `skick.SocketQuery` object. When this is done, the `BackActor` will\nset up a query in the `FrontActor`. They work by siphoning off client requests where the action field is `\"query_reply\"`, and comparing the message to registered queries. For this command there is a two tiered schema verification procedure:\n\n1. The message as a whole is evaluated against the schema\n   `{\"action\": \"query_reply\", \"query_id\":str, \"message\": object}`.\n2. It is verified that such a query has been registered.\n2. The \"message\" field in the dictionary is then evaluated against the\n   *subschema* that was specified by the `BackActor` when the query was made.\n\nThe conversation in the `BackActor` will resume once the websocket client has sent its response.\n\nBecause the `FrontActor` is unable to read function bodies, the subschemas\ncan not be specified within the handler requesting the conversation.\nInstead, subschemas must created in the session declaration's direct scope\nusing the function `inst.query_schema`. This is highly inconvenient, so\na number of simple schemas have been predefined for the programmers's convenience, namely:\n\n1. `\"default\"` which accepts an `int`, `float`, `str` or `bool`\n2. `\"int\"` which accepts an `int`,\n3. `\"float\"` which accepts a `float`,\n4. `\"str\"` which accepts a `str`,\n5. `\"bool\"` which accepts a `bool`,\n6. `\"list\"` which accepts a list consisting of only those types included in the `\"default\"` subschema.\n\nFor this reason, many simple queries require no extra `query_schema` declarations.\n\nIn principle, this means we can see constructs like the one below:\n\n```python\n\n...\n\n@skick.session(\"curious\")\ndef curiosity(inst, message):\n   \n   ...\n\n   @inst.socket(\"get_information\")\n   async def info(msg):\n      response = yield Call(info_actor, {\"action\": \"info\", \"credentials\": cred})\n      \n      if response[\"ask_gdpr\"]:\n         consent = yield SocketQuery({\"gdpr_query\": GDPR_STRING}, \"bool\")\n      \n         if consent:\n            await inst.socksend(response[\"info\"])\n         else:\n            await inst.socksend({\"error\": \"terms not accepted\"})\n      else:\n         await inst.socksend(response[\"info\"])\n   \n   ...\n\n...\n\n```\nIn the example above, the `BackActor` asks a different actor for some piece of\ninformation. The other actor discovers that the user with the supplied credentials\nhas not accepted certain important GDPR related terms and conditions. It informs\nthe `BackActor`, which sends a query to the client. If the client responds approvingly, the information is sent to the client, otherwise an error message\nis sent.\n\n### Handshake Sequences\nImagine for a moment that your Skick application has several classes of user sessions. Maybe they represent different user tiers or perhaps one skick instance\nruns several different services. In many such situations there are substantial benefits to be gained from allowing us to reuse sequences of sessions and subsessions that the system proceeds through before a fully authenticated and initiated user session is in place. Skick has a mechanism for this called a\n*handshake sequence*.\n\nWe may declare that a function is a `handshake` by using the `@skick.handshake`\ndecorator. We begin with an example:\n```python\n...\n\n@skick.handshake(\"random_number\")\ndef random_session(inst, message)\n   num = random()\n   @inst.on_start\n   async def on_start():\n      await inst.replace(\"double_number\", {**message, \"number\": num})\n\n@skick.subsession(\"double_number\")\ndef doubler(inst, message):\n   num = 2*message[\"number\"]\n   @inst.on_start()\n   async def on_start():\n      await inst.replace(f\"{message['session_type']}:final\", {\"number\": num})\n\n@random_session(\"logarithm\")\ndef logarithm(inst, message):\n   base = message[\"number\"]\n   @inst.socket(\"log\", {\"action\": \"log\", \"x\": float})\n   async def log(msg):\n      await inst.socksend({\"log_base(x)\": math.log(msg[x], base=base),\n                           \"x\": msg[\"x\"]})\n```\nHere, the `random_number` and `double_number` subsessions are part of a handshake sequence. `@skick.handshake` does not actually create a session. Instead, it\nreplaces the function it decorates with a new decorator. This new decorator can be used to create subsessions which are preceded by some standardized succession of\nsubsessions.\n\nLet us take a closer look at the last decorated function.\n```python\n@random_session(\"logarithm\")\ndef logarithm(inst, message):\n   ...\n```\nHere, one session and one subsession are created and registered. One called\n`logarithm` and the other called `logarithm:final`. The former is merely a copy of\n`random_session`, and the latter is the one actually described in `logarithm`. Skick expects\na subsession that is part of a handshake sequence to forward the `\"session_type\"`\nfield of the original message throughout the sequence. Ultimately, the final actor\nin the sequence should replace itself with the `f\"{message['session_type']}:final\"`\nactor, handing control over to the subsession in question.\n\n### Session termination\nSince sessions are not normal actors, they are terminated in a slightly different fashion than normal actors. If you invoke the `inst.stop` method on the `BackActor`,\nthe `WebsocketActor` will make sure to close the connection and stop the `FrontActor`.\n\nThis works because the `FrontActor`, `BackActor` and the consumer task in the `FrontActor` are collated in a special `Syzygy` object by the `WebsocketActor`.\nIf any of the three fail, the `Syzygy` provides methods for also shutting down the other two.\n\nA word of caution is appropriate when it comes to these syzygies. While the\nconsumer task is directly monitored by the `WebsocketActor`, and while the stop\nmethods are invoked directly without involving messaging, the `WebsocketActor` is informed of the demise of the actors in the `Syzygy` through the sentinel message it\n*should* emit. This may prove unreliable on some occasions, and we *might* see situations where only one of the actors is actually alive. We may also experience ill defined states when the sentinel messages are in transition.\n\n## Clustering\nSkick has the ability to run on many shards in a cluster. If this is required in your application, then you must provide some supported messaging system in your backend, since Skick does not supply its own distributed messaging system.\n\nAt present, Skick relies on RabbitMQ for its inter-shard communication. If you have\nan unencrypted RabbitMQ service hidden behind a firewall, you may swap\nSkick's default messaging system (which relies on a dictionary of active mail queues)\nfor a RabbitMQ based system by adding a parameter when instantiating your Skick class.\n\n```python\n\n...\n\nskick = Skick(on_start = on_start,\n              message_system = \"amqp://user:pwd@rabbit_url:rabbitport\")\n\n...\n\n```\nIf you choose to run skick in a clustered configuration, there is no requirement that the shards be homogeneous. You may opt to have some that do not support websockets, some that use different websocket drivers, some that provide interactions with some external service local to its docker container or whichever\narchitecture you think is best for your application. No matter how you organize\nthe system, it will work as long as the shards all use the same messaging system.\n\n## The Skick Object\nIn the examples above, we interact with the library through an imported class\ncalled Skick. The skick class is responsible for setting up the special actors,\nlaunching all needed tasks and connections, as well as coordinating all the disparate components for the user.\n\n### Options\nThe Skick object natively supports the following options:\n\n1. `on_start` which allows you to specify a startup function. This would typically be used to spawn actors on startup.\n2. `message_system` which, if you supply it, presumes that you have given it an AMQP url to a RabbitMQ instance.\n3. `websocket_host` which, if you supply it, is the address the websocket library will listen on\n4. `websocket_port` which, if you supply it, is the port the websocket library will listen on\n5. `websocket_server` which, if you set it to any value, will disable the websocket server\n6. `ssl` which tells the websocket library to use TLS. It can be\n   1. A string, in which case skick will assume it is a PEM file and will use it to generate an SSLContext object for you using python's `create_default_context` method.\n   2. A tuple, in which case it will act as above, but it will presume the first element is the PEM file and the second is the password.\n   3. An SSLContext instance, in which case it will be used by the websocket server.\n7. `websocket_options` which should be a dictionary of options that will be passed directly to the websocket library.\n8. `dict_type` which, if you provide a string, will be presumed to be a redis url to a redis server that will manage your `hash` objects.\n\n### Methods\nThe `Skick` instance also supplies a number of methods. Some of these are\nactual methods from the class defintion and some are merely proxies for methods\nin the underlying `Shard` object.\n\n1. `skick.start()`, which starts the event loop and the rest of the system.\n2. `skick.stop()`, which initiates the shutdown procedure.\n3. `skick.add_directory(directory)` which adds the actors, subsessions and handshakes in the directory to the skick instance.\n4. `@skick.actor(name)` which directly registers an actor type with the shard.\n5. `@skick.subsession(name)` which directly registers a subsession type with the websocket actor.\n6. `@skick.session(name)` which directly registers a session type with the websocket actor.\n7. `@skick.handshake(name)` which directly registers a handshake with the websocket actor.\n8. `skick.hash(name)` which provides a hash table as described below using the requested backend.\n\n## Sentinels\nIn an actor model, we frequently end up having a large number, perhaps tens of thousands of concurrent actors. In the absence of some tool to keep track of these,\nit is very easy to see how actors could be lost and forgotten, leading to memory leaks, or how errors from crashing actors might go unknown, or how any number of other things might go wrong.\n\nMost actor systems use some sort of system for supervising actors for this reason. In Skick, the supervision is carried out by *sentinels*, tasks that monitor other tasks. If they detect a cancellation, exception or a task being marked as done, they will report this to the actor's *monitors*. Monitors are other actors that have told the supervised actor that they wish to be notified.\n\n### Registering as a Monitor\nWhen an actor is spawned, we may supply the `inst.spawn` function with a list of addresses under the optional `add_monitors` keyword argument. By default, the actor that spawns a subactor will be added as a monitor together with the `Shard` special actor. If you do not wish to only add the `Shard` actor, you may set `add_monitors` to `False`. If you opt to add extra monitors via the `add_monitors` argument, you will have to also include the spawning actor manually.\n\nIf we supply a list of monitors, then the shard will automatically assign the listed actors as monitors and have the sentinel task report to them. We may also\nrequest to monitor a running actor by sending it a request over the message system. The message must follow the format\n```python\n{\"action\": \"monitor\", \"address\": address_to_report_to}\n```\nand will receive updates just the same as if it had been added when the actor was spawned.\n\n### Receiving Notifications\nWhen an actor ceases to operate (stops processing messages), the sentinel task will produce a message the contents of which depends on\nhow this came to be. The message will follow the schema\n```python\n{\n   \"action\": \"sentinel\",\n   \"address\": str, # The address of the actor that stopped\n   \"type\": Or(Const(\"done\"), Const(\"cancellation\"), Const(\"exception\")), # The reason for the update\n   Optional(\"exception\"): str, # The name of the exception if one occurred\n   \"tag\": str, # A callsign of the sentinel that was triggered. Usually \"main_task\".\n}\n```\n\nThe user can catch these in a few different ways, but the easiest is to register sentinel handlers.\nThe actor instance provides two functions for this:\n\n1. `inst.sentinel_handler(name, awt)` which is receives the sentinel message when the address field matches the `name` argument.\n2. `@inst.default_sentinel` which receives sentinel messages for which no specific sentinel handler has been registerd.\n\nAlternatively, you can override the default behavior by defining an `@inst.action` for the `\"sentinel\"` messages.\n\n### Out of the Box Sentinels\nThe shard actor will always keep a lookout for any actor it has spawned so that it can remove the instance from its internal registries and have it be garbage collected.\nThe websocket actor will always supervise all `FrontActor`s and `BackActors` to ensure they get removed in a similar fashion.\n\n### What Triggers the Sentinel\nThere are a few ways to trigger the sentinel. Under the hood, it awaits the message processing task. This means:\n1. Any action that cancels the actor, such as invoking the `inst.stop` method, will produce a `\"cancellation\"` message.\n2. Any exception arising inside a message handler will cause an `\"exception\"` message.\n3. Any daemon marked as a `dead_mans_hand` daemon, will cancel the message processing task if it terminates, leading to a `\"cancellation\"` message\n   *even if it was stopped by an exception*.\n4. If the websocket consumer task in a `FrontActor` dies, the `WebsocketActor`\n   will sense that this has happened. It will directly invoke the stop methods of\n   both the actors associated with the connection, and both of them will send\n   cancellation messages.\n\n## Miscellaneous Features\n### Hashes\nIn many applications we need some method of keeping track of information like\nactive session keys across shards. While it is possible to directly use your\nfavorite in memory database for this purpose, or to implement your own\ndistributed hash table, the simplest use cases may benefit from Skick's `hash`\nsystem.\n\nIn order to create a dictionary which will be eventually consistent across all\nactors and shards, simply write\n\n```python\n@skick.actor(\"some_actor\")\ndef the_actor(inst, msg):\n   dictionary = skick.hash(\"table_name\")\n\n   ...\n\n   @inst.action(\"the_action\")\n   async def the_action(msg):\n\n      ...\n\n      value = await dictionary[\"our_key\"]\n\n      ...\n   \n   ...\n```\nThese hash objects emulate dictionaries to some extent, but are asynchronous.\nThey support getting, setting, deleting and checking whether certain keys are\nin the table. The supported operations are:\n\n1. Getting, which can be done either with `await hash.get(key)` or `await hash[key]`,\n2. Setting, which can be done with `await hash.set(key, value)` or `hash[key] = value`. N.B: Here the former allows you to await completion before proceeding, but the latter simply creates a task that will complete at some unknown time in the future.\n3. Deletion, which can be done with `await hash.delete(key)` or `del hash[key]`. As in the setting operation, the former method guarantees not proceeding before the key has been deleted, while the latter only promises to delete the key some time in the future.\n4. Checking for membership. Here there is no convenient asynchronous equivalent to the `in` operator, as the `in` operator will convert any future we try to return from the dunder method into a boolean. Therefore only the method `await hash.contains(key)` is available.\n\nThese as objects are, as is evident from this description, rather basic. Among\nother things, they do not support iteration, can not be copied and can not be\ncompared with one another. What they do support is both a single core\ndictionary based implementation and a clustered Redis based implementation.\n\nIn order to use the Redis version, ensure you have a Redis instance running,\nand then add the keyword parameter `dict_type` when you instantiate the Skick\ninstance, setting it to a redis url such as in the following example.\n\n```python\n...\n\nskick = Skick(dict_type=\"redis://user:pwd@localhost:port\")\n\n...\n```\n\nThis may seem like an odd choice of a feature. But it is perfectly in line with\nthe underlying philosophy of Skick. We do not want the Java experience. We want\nminimal boilerplate requirements and we want simple use cases to be available\nat the developer's fingertips. If there were no facilities such as the hash\nobject in Skick, then the developer would have to make his own version of it for\nnearly every project. While this would not be altogether difficult, and while it\nwould allow him to expand its capabilities to encompass more of Redis' (if he\nchoses Redis) feature set, it would be a major annoyance.\n\nFor those applications that require more sophisticated interactions with Redis,\nother in memory databases or fully featured SQL databases, the\ndeveloper will have to bring his own libraries and implementations.\n\n### Directories\nIn frameworks like Flask and Sanic, endpoints do not have to be attached directly\nto the main application object. This is convenient, because in nontrivial\napplications, we want to distribute the code over multiple semi independent modules.\n\nIn Skick, there is a similar mechanism called a `Directory`. They act as proxy objects for the main `Skick` object. We can attach actors, sessions and handshakes to a `Directory`, import the `Directory` in the main module, and then\nattach them to the main `Skick` object using the `skick.add_directory(directory)` method.\n\nFor example, suppose there is a submodule `a.py`. We define an actor there and\nuse the Directory class to transfer it to the `main.py` file.\n\n```python\n#a.py\nfrom skick import Directory\n\nA = Directory()\n\n@A.actor(\"a_actor\")\ndef a_actor(inst, messages):\n   ...\n```\n\nWe can then use the directory in the file main.py as follows.\n```python\n#main.py\nfrom skick import Skick\nfrom a import A\n...\n\nskick = Skick()\nskick.add_directory(A)\n\n...\n```\nThe actor defined in `a.py` is then transferred to the `skick` object in `main.py` and the resulting actor can be used just as if it had been defined directly in `main.py` with the decorator `@skick.actor`.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "actor,actor model,asyncio,rabbitmq,websockets",
    "license": "",
    "maintainer": "",
    "maintainer_email": "Adrian Wennström <adrian@webyda.se>",
    "name": "skick",
    "package_url": "https://pypi.org/project/skick/",
    "platform": null,
    "project_url": "https://pypi.org/project/skick/",
    "project_urls": {
      "Documentation": "https://github.com/webyda/skick#readme",
      "Issues": "https://github.com/webyda/skick/issues",
      "Source": "https://github.com/webyda/skick"
    },
    "release_url": "https://pypi.org/project/skick/0.0.1a0.dev1/",
    "requires_dist": [
      "aio-pika>=8",
      "orjson>=3",
      "redis>=4",
      "schema>=0.7",
      "uvloop>=0.16; platform_system != 'Windows'",
      "websockets>=10"
    ],
    "requires_python": ">=3.10",
    "summary": "Skick is a library for building actor based web application backends that communicate with javascript clients over websockets. It is in an early state of development.",
    "version": "0.0.1a0.dev1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15915490,
  "releases": {
    "0.0.1a0.dev0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "231424418591749fda1f1dde67beab3e8df65c4bf15053f75ffd82d7d43d4924",
          "md5": "3b1f97ac145208404c5d74976e95ba95",
          "sha256": "f02e8a7fdc51cdf1c56357b6b429e1389c67078f43952d59c6b8ded875a4e64f"
        },
        "downloads": -1,
        "filename": "skick-0.0.1a0.dev0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3b1f97ac145208404c5d74976e95ba95",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 77518,
        "upload_time": "2022-11-24T12:49:04",
        "upload_time_iso_8601": "2022-11-24T12:49:04.058247Z",
        "url": "https://files.pythonhosted.org/packages/23/14/24418591749fda1f1dde67beab3e8df65c4bf15053f75ffd82d7d43d4924/skick-0.0.1a0.dev0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "02173a4c7e3eebe617bc0c9a98cf460f527ea1ebf1e5244a330aaf7ea667210e",
          "md5": "45d958494e4763f71f5597bbc9f28a87",
          "sha256": "4155ff9646ff2d794832abf6f612a52860e2297d79fa4a241df5bd409163b2c7"
        },
        "downloads": -1,
        "filename": "skick-0.0.1a0.dev0.tar.gz",
        "has_sig": false,
        "md5_digest": "45d958494e4763f71f5597bbc9f28a87",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 63364,
        "upload_time": "2022-11-24T12:49:05",
        "upload_time_iso_8601": "2022-11-24T12:49:05.917597Z",
        "url": "https://files.pythonhosted.org/packages/02/17/3a4c7e3eebe617bc0c9a98cf460f527ea1ebf1e5244a330aaf7ea667210e/skick-0.0.1a0.dev0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.1a0.dev1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "98308b6c5e6aa6ade775beac5afd5956752216135a818baee9b2e66dfa43789c",
          "md5": "d291feff6b2a90cffca7b13cc66bcd91",
          "sha256": "04efa4ba76bfb8b5d32691c4b60834c918bfb7f9eb4748a1ac84b80250c6d959"
        },
        "downloads": -1,
        "filename": "skick-0.0.1a0.dev1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d291feff6b2a90cffca7b13cc66bcd91",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 77782,
        "upload_time": "2022-11-28T15:10:51",
        "upload_time_iso_8601": "2022-11-28T15:10:51.661560Z",
        "url": "https://files.pythonhosted.org/packages/98/30/8b6c5e6aa6ade775beac5afd5956752216135a818baee9b2e66dfa43789c/skick-0.0.1a0.dev1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d90f38ccd97721c2d6cdfbe4c1ea1ade96272f3f0dcac60ea770772ad087014b",
          "md5": "003c36b1ea4221c7dbd8a52d210d6115",
          "sha256": "d996ad23657401b187203dfb8f966e46d8139514deef2132276d0b693a076d3a"
        },
        "downloads": -1,
        "filename": "skick-0.0.1a0.dev1.tar.gz",
        "has_sig": false,
        "md5_digest": "003c36b1ea4221c7dbd8a52d210d6115",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 63640,
        "upload_time": "2022-11-28T15:10:54",
        "upload_time_iso_8601": "2022-11-28T15:10:54.839144Z",
        "url": "https://files.pythonhosted.org/packages/d9/0f/38ccd97721c2d6cdfbe4c1ea1ade96272f3f0dcac60ea770772ad087014b/skick-0.0.1a0.dev1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "98308b6c5e6aa6ade775beac5afd5956752216135a818baee9b2e66dfa43789c",
        "md5": "d291feff6b2a90cffca7b13cc66bcd91",
        "sha256": "04efa4ba76bfb8b5d32691c4b60834c918bfb7f9eb4748a1ac84b80250c6d959"
      },
      "downloads": -1,
      "filename": "skick-0.0.1a0.dev1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "d291feff6b2a90cffca7b13cc66bcd91",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.10",
      "size": 77782,
      "upload_time": "2022-11-28T15:10:51",
      "upload_time_iso_8601": "2022-11-28T15:10:51.661560Z",
      "url": "https://files.pythonhosted.org/packages/98/30/8b6c5e6aa6ade775beac5afd5956752216135a818baee9b2e66dfa43789c/skick-0.0.1a0.dev1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d90f38ccd97721c2d6cdfbe4c1ea1ade96272f3f0dcac60ea770772ad087014b",
        "md5": "003c36b1ea4221c7dbd8a52d210d6115",
        "sha256": "d996ad23657401b187203dfb8f966e46d8139514deef2132276d0b693a076d3a"
      },
      "downloads": -1,
      "filename": "skick-0.0.1a0.dev1.tar.gz",
      "has_sig": false,
      "md5_digest": "003c36b1ea4221c7dbd8a52d210d6115",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.10",
      "size": 63640,
      "upload_time": "2022-11-28T15:10:54",
      "upload_time_iso_8601": "2022-11-28T15:10:54.839144Z",
      "url": "https://files.pythonhosted.org/packages/d9/0f/38ccd97721c2d6cdfbe4c1ea1ade96272f3f0dcac60ea770772ad087014b/skick-0.0.1a0.dev1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}