{
  "info": {
    "author": "David J. Bianco",
    "author_email": "david.bianco@target.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "# HuntLib\nA Python library to help with some common threat hunting data analysis operations\n\n[![Targetâ€™s CFC-Open-Source Slack](https://cfc-slack-inv.herokuapp.com/badge.svg?colorA=155799&colorB=159953)](https://cfc-slack-inv.herokuapp.com/)\n\n## What's Here?\nThe `huntlib` module provides three major object classes as well as a few convenience functions.  \n\n* **ElasticDF**: Search Elastic and return results as a Pandas DataFrame\n* **SplunkDF**: Search Splunk and return results as a Pandas DataFrame\n* **DomainTools**: Convenience functions for accessing the DomainTools API, primarily focused around data enrichment (requires a DomainTools API subscription)\n* **data.read_json()**: Read one or more JSON files and return a single Pandas DataFrame\n* **data.read_csv()**: Read one or more CSV files and return a single Pandas DataFrame\n* **data.flatten()**: Recursively flatten dicts/lists into a single level dict. Useful for data normalization and creating DataFrames.\n* **data.chunk()**: Break up a large list into smaller chunks for processing.\n* **util.entropy()** / **util.entropy_per_byte()**: Calculate Shannon entropy\n* **util.promptCreds()**: Prompt for login credentials in the terminal or from within a Jupyter notebook.\n* **util.edit_distance()**: Calculate how \"different\" two strings are from each other.\n* **util.benfords()**: Determine whether a given collection of numbers obeys Benford's Law.\n* **util.punctuation_pattern()**: Return only the non-alphanumeric characters from a given string or collection of strings.\n\n## Library-Wide Configuration\nBeginning with `v0.5.0`, `huntlib` now provides a library-wide configuration file, `~/.huntlibrc` allowing you to set certain runtime defaults.  Consult the file `huntlibrc-sample` in this repo for more information.\n\n## huntlib.elastic.ElasticDF\nThe `ElasticDF()` class searches Elastic and returns results as a Pandas DataFrame.  This makes it easier to work with the search results using standard data analysis techniques.\n\n### Example usage:\n\nCreate a plaintext connection to the Elastic server, no authentication\n\n```python\ne = ElasticDF(\n                url=\"http://localhost:9200\"\n)\n```\n\nThe same, but with SSL and authentication\n\n```python\ne = ElasticDF(\n                url=\"https://localhost:9200\",\n                ssl=True,\n                username=\"myuser\",\n                password=\"mypass\"\n)\n```\nFetch search results from an index or index pattern for the previous day\n\n```python\ndf = e.search_df(\n                  lucene=\"item:5282 AND color:red\",\n                  index=\"myindex-*\",\n                  days=1\n)\n```\n\nThe same, but do not flatten structures into individual columns. This will result in each structure having a single column with a JSON string describing the structure.\n\n```python\ndf = e.search_df(\n                  lucene=\"item:5282 AND color:red\",\n                  index=\"myindex-*\",\n                  days=1,\n                  normalize=False\n)\n```\n\nA more complex example, showing how to set the Elastic document type, use Python-style datetime objects to constrain the search to a certain time period, and a user-defined field against which to do the time comparisons. The result size will be limited to no more than 1500 entries.\n\n```python\ndf = e.search_df(\n                  lucene=\"item:5285 AND color:red\",\n                  index=\"myindex-*\",\n                  doctype=\"doc\", date_field=\"mydate\",\n                  start_time=datetime.now() - timedelta(days=8),\n                  end_time=datetime.now() - timedelta(days=6),\n                  limit=1500\n)\n```\n\nThe `search` and `search_df` methods will raise `InvalidRequestSearchException`\nin the event that the search request is syntactically correct but is otherwise\ninvalid. For example, if you request more results be returned than the server\nis able to provide. They will raise `AuthenticationErrorSearchException` in the\nevent the server denied the credentials during login.  They can also raise an\n`UnknownSearchException` for other situations, in which case the exception\nmessage will contain the original error message returned by Elastic so you\ncan figure out what went wrong.\n\n## huntlib.splunk.SplunkDF\n\nThe `SplunkDF` class search Splunk and returns the results as a Pandas DataFrame. This makes it easier to work with the search results using standard data analysis techniques.\n\n### Example Usage\n\nEstablish an connection to the Splunk server. Whether this is SSL/TLS or not depends on the server, and you don't really get a say.\n\n```python\ns = SplunkDF(\n              host=splunk_server,\n              username=\"myuser\",\n              password=\"mypass\"\n)\n```\n\nIf you prefer, you use a Splunk session token in place of a username/password (ask your Splunk administator to create one for you):\n\n````python\ns = SplunkDF(\n    host=splunk_server,\n    token=\"<your token>\"\n)\n````\n\n`SplunkDF` will raise `AuthenticationErrorSearchException` during initialization\nin the event the server denied the supplied credentials.  \n\nFetch all search results across all time\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\"\n)\n```\n\nFetch only specific fields, still across all time\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688 | table ComputerName _time New_Process_Name Account_Name Creator_Process_ID New_Process_ID Process_Command_Line\"\n)\n```\n\nTime bounded search, 2 days prior to now\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\",\n                  days=2\n)\n```\n\nTime bounded search using Python datetime() values\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\",\n                  start_time=datetime.now() - timedelta(days=2),\n                  end_time=datetime.now()\n)\n```\n\nTime bounded search using Splunk notation\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\",\n                  start_time=\"-2d@d\",\n                  end_time=\"@d\"\n)\n```\n\nLimit the number of results returned to no more than 1500\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\",\n                  limit=1500\n)\n```\n\n*NOTE: The value specified as the `limit` is also subject to a server-side max\nvalue. By default, this is 50000 and can be changed by editing limits.conf on\nthe Splunk server. If you use the limit parameter, the number of search results\nyou receive will be the lesser of the following values: 1) the actual number of\nresults available, 2) the number you asked for with `limit`, 3) the server-side\nmaximum result size.  If you omit limit altogether, you will get the **true**\nnumber of search results available without subject to additional limits, though\nyour search may take much longer to complete.*\n\nReturn only specified fields `NewProcessName` and `SubjectUserName`\n\n```python\ndf = s.search_df(\n                  spl=\"search index=win_events EventCode=4688\",\n                  fields=\"NewProcessName,SubjectUserName\"\n)\n```\n\n*NOTE: By default, Splunk will only return the fields you reference in the\nsearch string (i.e. you must explicitly search on \"NewProcessName\" if you want\nthat field in the results. Usually this is not what we want. When fields is not `None`, \nthe query string will be rewritten with \"| fields <fields>\" at the end (e.g., \n`search index=win_events EventCode=4688 | fields NewProcessName,SubjectUserName`). This\nworks fine for most simple cases, but if you have a more complex SPL query and it breaks, \nsimply set `fields=None` in your function call to avoid this behavior.*\n\nTry to remove Splunk's \"internal\" fields from search results:\n\n```python\ndf = s.search_df(\n    spl=\"search index=win_events EventCode=4688\",\n    internal_fields=False\n)\n``` \nThis will remove such fields as `_time` and `_sourcetype` as well as any other field who's name begins with `_`.  This behavior occurs by default (`internal_fields` defaults to `False`), but you can disable it by using `internal_fields=True`.  \n\nRemove named field(s) from the search results:\n\n```python\ndf = s.search_df(\n    spl=\"search index=win_events EventCode=4688\",   internal_fields=\"_bkt,_cd,_indextime,_raw,_serial,_si,_sourcetype,_subsecond,_time\"\n)\n```\nIn the event you need more control over which \"internal\" fields to drop, you can pass a comma-separated list of field names (NOTE: these can be any field, not just Splunk internal fields).\n\nSplunk's Python API can be quite slow, so to speed things up you may elect to spread the result retrieval among multiple cores.  The default is to use one (1) extra core, but you can use the `processes` argument to `search()` or `search_df()` to set this higher if you like.  \n\n```python\ndf = s.search_df(\n    spl=\"search index=win_events EventCode=4688\", \n    processes=4\n)\n```\n\nIf you prefer to use all your cores, try something like:\n\n```python\nfrom multiprocessing import cpu_count\n\ndf = s.search_df(\n    spl=\"search index=win_events EventCode=4688\",\n    processes=cpu_count()\n)\n```\n\n*NOTE: You may have to experiment to find the optimal number of parallel processes for your specific environment. Maxing out the number of workers doesn't always give the best performance.*\n\n## huntlib.domaintools.DomainTools\nThe `DomainTools` class allows you to easily perform some common types of calls\nto the DomainTools API.  It uses their official `domaintools_api` Python module\nto do most of the work but is not a complete replacement for that module. In\nparticular, this class concentrates on a few calls that are most relevant for\ndata analytic style threat hunting (risk & reputation scores, WHOIS info, etc).\n\nThe `DomainTools` class can make use of the global config file `~/.huntlibrc` to store the API username and secret key, if desired.  See the `huntlibrc-sample` file for more info.\n\n### Example Usage\n\nImport the `DomainTools` object:\n\n    from huntlib.domaintools import DomainTools\n\nInstantiate a new `DomainTools` object:\n\n    dt = DomainTools(\n        api_username=\"myuser,\n        api_key=\"mysecretkey\n    )\n\nInstatiate a new `DomainTools` object using default creds stored in `~/.huntlibrc`:\n\n    dt = DomainTools()\n\nLook up API call limits and usage info for the authenticated user:\n\n    dt.account_information()\n\nReturn the list of API calls to which the authenticated user has access:\n\n    dt.available_api_calls()\n\nReturn basic WHOIS info for a domain or IP address:\n\n    dt.whois('google.com')\n    dt.whois('8.8.8.8')\n\nReturn WHOIS info with additional fields parsed from the text part of the record:\n\n    dt.parsed_whois('google.com')\n    dt.parsed_whois('8.8.8.8')\n\nFind newly-activated or pending domain registrations matching all the supplied search terms:\n\n    dt.brand_monitor('myterm')\n    dt.brand_monitor('myterm1|myterm2|myterm3') # terms are ANDed together\n\nLook up basic info about a domain's DNS, WHOIS, hosting and web site in one query.\n\n    dt.domain_profile('google.com')\n\nReturn a list of risk scores for a domain, according to different risk factors:\n\n    dt.risk('google.com')\n\nReturn a single consolidated risk score for a domain:\n\n    dt.domain_reputation('google.com')\n\nSee what DomainTools' IRIS database has to say about a certain domain. This typically provides quick info from a variety of DomainTools sources:\n\n    dt.iris_enrich('google.com')\n\nEnrich a pandas DataFrame containing a mixture of domains and/or IP address in a column called 'iocs'.  It calls `DomainTools.iris_enrich()` to gather the data, and tries to be efficient by handling duplicate values and by sending multiple queries in the same batch:\n\n    df = dt.enrich(df, column='iocs')\n\nThe default is to send batches of 100 domains at a time, but you can decrease this number if necessary (usually because the query string becomes so long the DomainTools API server rejects it):\n\n    df = dt.enrich(df, column='iocs', batch_size=75)\n\nEnrichment tends to add a large number of columns, which you may not need. Use the `fields` parameter if you know exactly what you want:\n\n    df = dt.enrich(\n        df, \n        column='iocs', \n        fields=[\n            'dt_whois.registration.created',\n            'dt_reputation.risk_score'\n        ]\n    )\n\nEnrichment may take quite some time with a large dataset. If you're antsy, try turning on the progress bars:\n\n    df = dt.enrich(df, column='iocs', progress_bar=True)\n\n## Data Module\n\nThe `huntlib.data` module contains functions that make it easier to deal with data and data files.  \n\n### Reading Multiple Data Files\n\n`huntlib.data` provides two convenience functions to replace the standard Pandas `read_json()` and `read_csv()` functions.  These replacement functions work exaclty the same as their originals, and take all the same arguments.  The only difference is that they are capable of accepting a filename wildcard in addition to the name of a single file.  All files matching the wildcard expression will be read and returned as a single `DataFrame`.\n\nStart by importing the functions from the module:\n\n```python\nfrom huntlib.data import read_csv, read_json\n```\n\nHere's an example of reading a single JSON file, where each line is a separate JSON document:\n\n```python\ndf = read_json(\"data.json\", lines=True)\n```\n\nSimilarly, this will read all JSON files in the current directory:\n\n```python\ndf = read_json(\"*.json\", lines=True)\n```\n\nThe `read_csv` function works the same way:\n\n```python\ndf = read_csv(\"data.csv)\n```\n\nor \n\n```python\ndf = read_csv(\"*.csv\")\n```\n#### Post-Processing the Input Data\nBoth `read_json()` and `read_csv()` support an optional `post_function` parameter, which allows you to specify a function to post-process the data after each individual file is read in, before it is merged into the final returned DataFrame. For example, you might want to split or combine columns, or compute a new value from existing data.  \n\nStart by creating a post-processing function according to the following prototype:\n\n```python\ndef my_post_processor(df, filename):\n    # do some stuff \n\n    return df\n```\n\nWhen called, the `df` parameter will be a DataFrame containing the chunk of data just read, and the `filename` parameter will be the name of the file it came from, which will be different for each chunk. **IT IS IMPORTANT THAT YOU RETURN `df` no matter whether you modified the input DataFrame or not.**\n\nOnce you have defined the post-processor function, you can invoke it during your call to `read_json()` or `read_csv()` like so:\n\n```python\ndf = read_csv(\"*.csv\", post_function=my_post_processor)\n```\n\n#### Additional Read Options\nConsult the Pandas documentation for information on other supported options for `read_csv()` and `read_json()`.\n\n### Normalizing nesting dicts and lists\n\nMany times the data that we deal with is not well formatted for our purposes because it contains complex data structures inside itself and we need it to be more regular (e.g., when converting REST API data in JSON format to a pandas DataFrame).  The `huntlib.data.flatten()` function may be just what you need!\n\nGiven a dict or list that may itself contain other dicts or lists, `flatten()` will traverse the object recursively and bring all the data into a single dict with a single level of keys (making it 'flat').\n\nFlattening a dict with nested dicts:\n\n    >>> flatten({\"key1\": \"val1\", \"subkeys\": {\"subkey1\": \"subval1\"}})\n    {'key1': 'val1', 'subkeys.subkey1': 'subval1'}\n\nFlatten a list with nested lists.  Notice that the resulting keys are the list indices in string form:\n\n    >>> flatten([1, 2, 3])\n    {'0': 1, '1': 2, '2': 3}\n\nA more complex example:\n\n    >>> flatten([{'a': 'a', 'b': 'b'}, {'a': 'a1', 'c': 'c'}])\n    {'0.a': 'a', '0.b': 'b', '1.a': 'a1', '1.c': 'c'}\n\n### Breaking a long list-like object into smaller chunks\nGiven a list-like object, divide into chunks of `size` and return those as a generator. If the length of the sequence is not evenly divisible by the size, the final chunk will contain however many items remain.\n\n    >>> l = list(range(26))\n    >>> for i in chunk(l, size=5):\n    ...   print(i)\n    [0, 1, 2, 3, 4]\n    [5, 6, 7, 8, 9] \n    [10, 11, 12, 13, 14]\n    [15, 16, 17, 18, 19]\n    [20, 21, 22, 23, 24]\n    [25]\n\n## Util Module \n\nThe `huntlib.util` modules contains miscellaneous functions that don't fit anywhere else, but are nevertheless still useful.\n\n### Entropy\n\n`huntlib.util` provides two entropy functions, `entropy()` and `entropy_per_byte()`. Both accept a single string as a parameter.  The `entropy()` function calculates the Shannon entropy of the given string, while `entropy_per_byte()` attempts to normalize across strings of various lengths by returning the Shannon entropy divided by the length of the string.  Both return values are `float`.\n\n```python\n>>> entropy(\"The quick brown fox jumped over the lazy dog.\")\n4.425186429663008\n>>> entropy_per_byte(\"The quick brown fox jumped over the lazy dog.\")\n0.09833747621473352\n```\n\nThe higher the value, the more data potentially embedded in it.\n\n### Credential Handling\n\nSometimes you need to provide credentials for a service, but don't want to hard-code them into your scripts, especially if you're collaborating on a hunt.  `huntlib.util` provides the `promptCreds()` function to help with this. This function works well both in the terminal and when called from within a Jupyter notebook.\n\nCall it like so:\n\n```python\n(username, password) = promptCreds()\n```\n\nYou can change one or both of the username/password prompts by passing arguments:\n\n```python\n(username, password) = promptCreds(\n                            uprompt=\"LAN ID: \",\n                            pprompt=\"LAN Pass: \"\n                        )\n```\n\n### String Similarity\n\nString similarity can be expressed in terms of \"edit distance\", or the number of single-character edits necessary to turn the first string into the second string.  This is often useful when, for example, you want to find two strings that very similar but not identical (such as when hunting for [process impersonation](http://detect-respond.blogspot.com/2016/11/hunting-for-malware-critical-process.html)).\n\nThere are a number of different ways to compute similarity. `huntlib.util` provides the `edit_distance()` function for this, which supports several algorithms:\n\n* [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n* [Damerau-Levenshtein Distance](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance)\n* [Hamming Distance](https://en.wikipedia.org/wiki/Hamming_distance)\n* [Jaro Distance](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)\n* [Jaro-Winkler Distance](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)\n\nHere's an example:\n\n```python\n>>> edit_distance('svchost', 'scvhost')\n1\n```\n\nYou can specify a different algorithm using the `method` parameter. Valid methods are `levenshtein`, `damerau-levenshtein`, `hamming`, `jaro` and `jaro-winkler`. The default is `damerau-levenshtein`.\n\n```python\n>>> edit_distance('svchost', 'scvhost', method='levenshtein')\n2\n```\n\n### Benford's Law\nBenford's Law, also known as the \"first digit law\" or the \"law of anomalous numbers\" states that there is a specific distribution pattern of the first digits of certain groups of numbers.  It is often used to detect cheating or tampering in areas such as tax fraud and vote rigging.  \n\nSee https://en.wikipedia.org/wiki/Benford%27s_law for more info on Benford's Law and it's potential applications.\n\nThe `benfords()` function returns a 3-tuple of values like: `(chi2, p, counts)`.\n\n* `chi2` is a float that describes how well the observed distribution of first digits matched the predictions of Benford's Law.  Lower is better.  \n* `p` is the probability that the computed 'chi2' is significant (i.e., it tells you whether the chi2 value can be trusted).  Its range is 0..1, but in this case, higher is better.  Generally speaking, if the p-value is >= 0.95 then the chi2 value is considered significant.\n* `counts` is a Pandas series where the indices are the possible first digits 1-9 and the values are the observed distributions of those digits. If the observed distributions didn't match up with Benford's law, the counts may help you identify the anomalous values.\n\nHere's an example of calling the `benfords()` function, with a contrived set of numbers that definitely conform to the expected distribution:\n\n```python\n>>> numbers = [1, 1, 1, 1, 1, 1, 1, 1, \n               2, 2, 2, 2,\n               3, 3, 3, \n               4, 4, \n               5, 5, \n               6, 6, \n               7, 7, \n               8, \n               9]\n>>> benfords(numbers)\n(0.019868294035033682, 0.9999999995974126, 1    0.32\n2    0.16\n3    0.12\n4    0.08\n5    0.08\n6    0.08\n7    0.08\n8    0.04\n9    0.04\nName: digits, dtype: float64)\n```\n\nNotice the `chi2` value is quite low (~0.02), meaning these numbers follow Benford's Law quite well.  The `p` value is > 0.999999999 so we can have a high confidence in these results.\n\nHere the input is a set of random numbers, which do not conform to Benford's Law.  Notice the `chi2` value is much higher, but the `p` value is still > 0.9999, indicating that we can trust the fact that it doesn't conform.\n```python\n>>> numbers = np.random.randint(1, 10, 1000)\n>>> benfords(numbers)\n(0.391706824115063, 0.9999475565204166, 1    0.114\n2    0.119\n3    0.118\n4    0.099\n5    0.110\n6    0.116\n7    0.120\n8    0.083\n9    0.121\nName: digits, dtype: float64)\n```\n\n### Generate punctuation patterns from strings\n\nFor certain types of log analysis, the contents of the individual log messages is not as important as the format of the message itself. This often results in the need to examine the pattern of punctuation (non-alphanumeric characters). To facilitate this, the `punctuation_pattern()` function accepts a single string or a list-like collection of strings and returns *just* the non-alphanumeric characters.\n\n```python\n>>> >>> s = '192.168.1.1 - - [10/Oct/2020:12:32:27 +0000] \"GET /some/web/app?param=test&param2=another_test\" 200 9987'\n>>> punctuation_pattern(s)\n'..._-_-_[//:::_+]_\"_///?=&=_\"__'\n\n>>> l = [s, \"Another example. This time, of a list of strings!\"]\n>>> punctuation_pattern(l)\n0    ..._-_-_[//:::_+]_\"_///?=&=_\"__\n1                        _.__,_____!\nName: punct, dtype: object\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/target/huntlib",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "huntlib",
    "package_url": "https://pypi.org/project/huntlib/",
    "platform": "",
    "project_url": "https://pypi.org/project/huntlib/",
    "project_urls": {
      "Homepage": "https://github.com/target/huntlib"
    },
    "release_url": "https://pypi.org/project/huntlib/0.5.3/",
    "requires_dist": [
      "future",
      "splunk-sdk",
      "elasticsearch-dsl",
      "pandas",
      "numpy",
      "jellyfish (>=0.8.2)",
      "domaintools-api",
      "tqdm",
      "scipy"
    ],
    "requires_python": "",
    "summary": "A Python library to help with some common threat hunting data analysis operations",
    "version": "0.5.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9858192,
  "releases": {
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dd916c4bcf2466adfca2ae1b1981bf352cfc6ebf860c5b1056fd9c81cde083d8",
          "md5": "d34d3c628fe4c52dd73657d475e17ccf",
          "sha256": "4e08181949e2467bddb2cc80b14e22d861081deb797f2c3205133eb6bbe1ae31"
        },
        "downloads": -1,
        "filename": "huntlib-0.2.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d34d3c628fe4c52dd73657d475e17ccf",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 10108,
        "upload_time": "2018-10-04T00:56:20",
        "upload_time_iso_8601": "2018-10-04T00:56:20.976333Z",
        "url": "https://files.pythonhosted.org/packages/dd/91/6c4bcf2466adfca2ae1b1981bf352cfc6ebf860c5b1056fd9c81cde083d8/huntlib-0.2.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e14ce8d310a256ddd6d99d29c76f845726d0115799c5c479e6423e64c5683a07",
          "md5": "e23bc1980ab6fd55e9cb8730aed26dbe",
          "sha256": "4033a5abeea42308f804455122754db083a17a6029a4bdb5139f2d592b217ce7"
        },
        "downloads": -1,
        "filename": "huntlib-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e23bc1980ab6fd55e9cb8730aed26dbe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 7965,
        "upload_time": "2018-10-04T00:56:22",
        "upload_time_iso_8601": "2018-10-04T00:56:22.198588Z",
        "url": "https://files.pythonhosted.org/packages/e1/4c/e8d310a256ddd6d99d29c76f845726d0115799c5c479e6423e64c5683a07/huntlib-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b4d7037718d31f9fae3869de4e0b9b8c56f19af1036527de29ed3fd97bfcb590",
          "md5": "72cae8423a29ea61c5de2641600f5692",
          "sha256": "24e76fd34ef9d4bbcbeb2ef4bcb7267cc84609dcbacb5198d8637ca5f8ae36f6"
        },
        "downloads": -1,
        "filename": "huntlib-0.3.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "72cae8423a29ea61c5de2641600f5692",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 12200,
        "upload_time": "2018-10-23T15:55:47",
        "upload_time_iso_8601": "2018-10-23T15:55:47.555143Z",
        "url": "https://files.pythonhosted.org/packages/b4/d7/037718d31f9fae3869de4e0b9b8c56f19af1036527de29ed3fd97bfcb590/huntlib-0.3.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0537b0eede1f9bcf016766b0a3a1fd1a43c58cfcabfd264e77d9e0e2b59b07b6",
          "md5": "2b72fcb5b5647c7373d152e16117c9ae",
          "sha256": "d81fb7d4768730de425f23e0cc0eff1afa141d7630e72122ce8c466a777124c1"
        },
        "downloads": -1,
        "filename": "huntlib-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2b72fcb5b5647c7373d152e16117c9ae",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 11173,
        "upload_time": "2018-10-23T15:55:48",
        "upload_time_iso_8601": "2018-10-23T15:55:48.489507Z",
        "url": "https://files.pythonhosted.org/packages/05/37/b0eede1f9bcf016766b0a3a1fd1a43c58cfcabfd264e77d9e0e2b59b07b6/huntlib-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c0b42e626fb548d8995bab0c73eeba242f592ebdc0bb6195568b7fce53917972",
          "md5": "5429d6a7c24b31cf870871c7b9e0395f",
          "sha256": "baf49edaed5b647732714fbb5f9fdda313db62c44f312bfe8c770f8c4afc09cc"
        },
        "downloads": -1,
        "filename": "huntlib-0.4.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5429d6a7c24b31cf870871c7b9e0395f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13990,
        "upload_time": "2020-06-09T17:09:03",
        "upload_time_iso_8601": "2020-06-09T17:09:03.405513Z",
        "url": "https://files.pythonhosted.org/packages/c0/b4/2e626fb548d8995bab0c73eeba242f592ebdc0bb6195568b7fce53917972/huntlib-0.4.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "689d0e8729201f34e7f7b93bcf306b94b19197a0b1e1b465a1e18a15b3232fe3",
          "md5": "3c57c5ed38a0f81a47023d8fce48942e",
          "sha256": "8bcd7387a00a289ba21db492645bb9832cbcb983563c7820b5032e38a8d3d7be"
        },
        "downloads": -1,
        "filename": "huntlib-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3c57c5ed38a0f81a47023d8fce48942e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 14205,
        "upload_time": "2020-06-09T17:09:04",
        "upload_time_iso_8601": "2020-06-09T17:09:04.571247Z",
        "url": "https://files.pythonhosted.org/packages/68/9d/0e8729201f34e7f7b93bcf306b94b19197a0b1e1b465a1e18a15b3232fe3/huntlib-0.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "42f341a5f0a24a69e4b52264b1e02d6de861d2f04451f42fef2dc96ca40cc9b2",
          "md5": "e9470ac9c047e452b2761020e3f17ee5",
          "sha256": "d21e3b0d00a6b9d5d3dc3e0364fccdbf24f5000a88be2e98b350fb784dac70d8"
        },
        "downloads": -1,
        "filename": "huntlib-0.4.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e9470ac9c047e452b2761020e3f17ee5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 15771,
        "upload_time": "2020-06-19T13:01:20",
        "upload_time_iso_8601": "2020-06-19T13:01:20.193331Z",
        "url": "https://files.pythonhosted.org/packages/42/f3/41a5f0a24a69e4b52264b1e02d6de861d2f04451f42fef2dc96ca40cc9b2/huntlib-0.4.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5b71d17e27494a7bb5ac263c7073af18960738e779b55650795318e566bd1c74",
          "md5": "a85d82ffd33fc74bf96171cbc95880d9",
          "sha256": "0aae3b79a8e980069e9dd3e1c7701cc61109b152403c6dca0ea283fb2bec3103"
        },
        "downloads": -1,
        "filename": "huntlib-0.4.5.tar.gz",
        "has_sig": false,
        "md5_digest": "a85d82ffd33fc74bf96171cbc95880d9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 16661,
        "upload_time": "2020-06-19T13:01:22",
        "upload_time_iso_8601": "2020-06-19T13:01:22.123485Z",
        "url": "https://files.pythonhosted.org/packages/5b/71/d17e27494a7bb5ac263c7073af18960738e779b55650795318e566bd1c74/huntlib-0.4.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d36052c0106fcbe68ba816ee8a3063d4998d2cf1418c89ad3a3dda07ba46aec7",
          "md5": "1c5870b9104a73c64d1234b4daba5cd5",
          "sha256": "818040fecef4f29cae2fb009fd7a10186cf79d1c5fdfe119eaff8fdd5585f1e9"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1c5870b9104a73c64d1234b4daba5cd5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 27698,
        "upload_time": "2020-08-10T17:59:56",
        "upload_time_iso_8601": "2020-08-10T17:59:56.388191Z",
        "url": "https://files.pythonhosted.org/packages/d3/60/52c0106fcbe68ba816ee8a3063d4998d2cf1418c89ad3a3dda07ba46aec7/huntlib-0.5.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "80057b179b7dca0a246e0ea36b7ce6ce4f2c5e0d09b329ec6cf6930ecd917a10",
          "md5": "6aec6bc0f8858503ad7192f5c4e1fe05",
          "sha256": "df835a883483197c9d46adc2c30a4fe8e12063694ddf4c1ddc35663dd4c7e6c0"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6aec6bc0f8858503ad7192f5c4e1fe05",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 30970,
        "upload_time": "2020-08-10T17:59:57",
        "upload_time_iso_8601": "2020-08-10T17:59:57.797135Z",
        "url": "https://files.pythonhosted.org/packages/80/05/7b179b7dca0a246e0ea36b7ce6ce4f2c5e0d09b329ec6cf6930ecd917a10/huntlib-0.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0a1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0d3a1f029dbaae60323e28799338385bcb644449248a316e1fbd65a5ffcc0f42",
          "md5": "5137b88000391994a532a1cee8d430e4",
          "sha256": "3a644f6a51dd4cad0697fb9696b1512803951b9ab5a3635ff4a628179b0aaf6d"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5137b88000391994a532a1cee8d430e4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21973,
        "upload_time": "2020-07-13T17:32:40",
        "upload_time_iso_8601": "2020-07-13T17:32:40.779301Z",
        "url": "https://files.pythonhosted.org/packages/0d/3a/1f029dbaae60323e28799338385bcb644449248a316e1fbd65a5ffcc0f42/huntlib-0.5.0a1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5e9e21c7b23b247629d293d7db635850e944e13e07e644bd8dd05b374d206c48",
          "md5": "17c5addb085ebc0a6e9a46007eaed1e1",
          "sha256": "1f35365699ad94050a58857e0353d978762da6a60c02fea9ce8d3c07ee6280c5"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a1.tar.gz",
        "has_sig": false,
        "md5_digest": "17c5addb085ebc0a6e9a46007eaed1e1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23963,
        "upload_time": "2020-07-13T17:32:43",
        "upload_time_iso_8601": "2020-07-13T17:32:43.163357Z",
        "url": "https://files.pythonhosted.org/packages/5e/9e/21c7b23b247629d293d7db635850e944e13e07e644bd8dd05b374d206c48/huntlib-0.5.0a1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0a2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b3d3669078724e13b998bfdc13519303b6f26c472387fe10a3e38c4779a28776",
          "md5": "a11db4b817f60530b04441ed406e2a75",
          "sha256": "8cfd1cb9175426a9cebc33596bb37a676dd81ea4023b4160112e7bffe0d57fec"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a11db4b817f60530b04441ed406e2a75",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21979,
        "upload_time": "2020-07-13T20:14:44",
        "upload_time_iso_8601": "2020-07-13T20:14:44.391325Z",
        "url": "https://files.pythonhosted.org/packages/b3/d3/669078724e13b998bfdc13519303b6f26c472387fe10a3e38c4779a28776/huntlib-0.5.0a2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "472a92139e014a1749e37d1e59ed4102e9992dd479dc223a0497b946c6a9dcf9",
          "md5": "955f25a5b12a43e58ca668caa1f00e55",
          "sha256": "9569b0a5ee3cf86534a7ebf4a4a169e3df3c2ce6454a1af075f1fafad4af033e"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a2.tar.gz",
        "has_sig": false,
        "md5_digest": "955f25a5b12a43e58ca668caa1f00e55",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23961,
        "upload_time": "2020-07-13T20:14:47",
        "upload_time_iso_8601": "2020-07-13T20:14:47.616266Z",
        "url": "https://files.pythonhosted.org/packages/47/2a/92139e014a1749e37d1e59ed4102e9992dd479dc223a0497b946c6a9dcf9/huntlib-0.5.0a2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0a3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e264cdc0024c86309b0f29a5e66d4300083b9dc37d51711fcde72fbf27b42ffe",
          "md5": "8aea4c5da875b58fb9f7203c3442d833",
          "sha256": "ccad326a4197602417fa4777d7626127f2ba7b998ed435066704058c67b7f4e0"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8aea4c5da875b58fb9f7203c3442d833",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23056,
        "upload_time": "2020-07-15T17:19:56",
        "upload_time_iso_8601": "2020-07-15T17:19:56.765655Z",
        "url": "https://files.pythonhosted.org/packages/e2/64/cdc0024c86309b0f29a5e66d4300083b9dc37d51711fcde72fbf27b42ffe/huntlib-0.5.0a3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e55216302d25f935b3f08cb4252f7c88df1bffce87c118cd55d7db95170304ca",
          "md5": "82acb3da05d5ae3429c3a5a185ad5cc2",
          "sha256": "ccbacb65240dfc3dfa3d8c709c1b978a437a507b9384bcc71db7cbc35656b404"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a3.tar.gz",
        "has_sig": false,
        "md5_digest": "82acb3da05d5ae3429c3a5a185ad5cc2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24758,
        "upload_time": "2020-07-15T17:20:00",
        "upload_time_iso_8601": "2020-07-15T17:20:00.412951Z",
        "url": "https://files.pythonhosted.org/packages/e5/52/16302d25f935b3f08cb4252f7c88df1bffce87c118cd55d7db95170304ca/huntlib-0.5.0a3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0a4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "202872672ee1c73b903497e18343e2f8e38423f91e4e95556ed3a79902502555",
          "md5": "97685c9db75fc5f701adc1905ca6cd22",
          "sha256": "3402017c7d563393215e14cf4041f2a302c2040e4fcccec7f2d50ead916b77ae"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "97685c9db75fc5f701adc1905ca6cd22",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 25533,
        "upload_time": "2020-07-21T17:53:37",
        "upload_time_iso_8601": "2020-07-21T17:53:37.446780Z",
        "url": "https://files.pythonhosted.org/packages/20/28/72672ee1c73b903497e18343e2f8e38423f91e4e95556ed3a79902502555/huntlib-0.5.0a4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "67575f9645092ae972a0b9e19d494757d68da8aafef5644675ebd846d491f4d8",
          "md5": "0a0ff0af6681474c6e6caa628330465e",
          "sha256": "858a4dc829d4ee7be1541eaf576bb66c5ad7103568dcba01f8cc50fbc31e419c"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.0a4.tar.gz",
        "has_sig": false,
        "md5_digest": "0a0ff0af6681474c6e6caa628330465e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28069,
        "upload_time": "2020-07-21T17:53:43",
        "upload_time_iso_8601": "2020-07-21T17:53:43.395476Z",
        "url": "https://files.pythonhosted.org/packages/67/57/5f9645092ae972a0b9e19d494757d68da8aafef5644675ebd846d491f4d8/huntlib-0.5.0a4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5e804d81ee505d687a6b2c28567efc8fb0523a7ec9521bb16675bc0298d089ba",
          "md5": "fd34130675fa8cc1678ad350a3fe9ad0",
          "sha256": "2cde353dc568600937e2c0d0564cbd618ab34f268bbc8fc1acb5b67548cfaf7e"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fd34130675fa8cc1678ad350a3fe9ad0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28966,
        "upload_time": "2020-10-12T14:06:24",
        "upload_time_iso_8601": "2020-10-12T14:06:24.954828Z",
        "url": "https://files.pythonhosted.org/packages/5e/80/4d81ee505d687a6b2c28567efc8fb0523a7ec9521bb16675bc0298d089ba/huntlib-0.5.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a4baae35bd604ed0a0f231f460138c4ccfc962838edc31e01277682fc184f625",
          "md5": "ade90128e8b9b8419c227406efde13a7",
          "sha256": "e1ce0930780aae53eeeabe158069bc4a040bce1fee3128bff8dc274cba0f6adf"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ade90128e8b9b8419c227406efde13a7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 32880,
        "upload_time": "2020-10-12T14:06:32",
        "upload_time_iso_8601": "2020-10-12T14:06:32.466887Z",
        "url": "https://files.pythonhosted.org/packages/a4/ba/ae35bd604ed0a0f231f460138c4ccfc962838edc31e01277682fc184f625/huntlib-0.5.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "76f984fac69395354bcf8e3e1931257920e309895b20f905ac6e4cce33d0928b",
          "md5": "b6576a51d5e9d0b680f316462af957d9",
          "sha256": "6a9c9fbd2fde1549d810cf5346b6d306bf65680456a39ded50e62f76cd4c0210"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b6576a51d5e9d0b680f316462af957d9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 29523,
        "upload_time": "2021-03-23T19:14:22",
        "upload_time_iso_8601": "2021-03-23T19:14:22.542471Z",
        "url": "https://files.pythonhosted.org/packages/76/f9/84fac69395354bcf8e3e1931257920e309895b20f905ac6e4cce33d0928b/huntlib-0.5.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d16873746413626d8c7c6795eae832e98ff0cfc3d5f5ba35041c614e9eccd5ca",
          "md5": "7da443b312bc1953941dc0b878ae341d",
          "sha256": "55e5c8cff095601d7fba2ef87085c5703cd03ba27431e97a3fd6b621aa0b66fc"
        },
        "downloads": -1,
        "filename": "huntlib-0.5.3.tar.gz",
        "has_sig": false,
        "md5_digest": "7da443b312bc1953941dc0b878ae341d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 33889,
        "upload_time": "2021-03-23T19:14:28",
        "upload_time_iso_8601": "2021-03-23T19:14:28.324460Z",
        "url": "https://files.pythonhosted.org/packages/d1/68/73746413626d8c7c6795eae832e98ff0cfc3d5f5ba35041c614e9eccd5ca/huntlib-0.5.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "76f984fac69395354bcf8e3e1931257920e309895b20f905ac6e4cce33d0928b",
        "md5": "b6576a51d5e9d0b680f316462af957d9",
        "sha256": "6a9c9fbd2fde1549d810cf5346b6d306bf65680456a39ded50e62f76cd4c0210"
      },
      "downloads": -1,
      "filename": "huntlib-0.5.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "b6576a51d5e9d0b680f316462af957d9",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 29523,
      "upload_time": "2021-03-23T19:14:22",
      "upload_time_iso_8601": "2021-03-23T19:14:22.542471Z",
      "url": "https://files.pythonhosted.org/packages/76/f9/84fac69395354bcf8e3e1931257920e309895b20f905ac6e4cce33d0928b/huntlib-0.5.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d16873746413626d8c7c6795eae832e98ff0cfc3d5f5ba35041c614e9eccd5ca",
        "md5": "7da443b312bc1953941dc0b878ae341d",
        "sha256": "55e5c8cff095601d7fba2ef87085c5703cd03ba27431e97a3fd6b621aa0b66fc"
      },
      "downloads": -1,
      "filename": "huntlib-0.5.3.tar.gz",
      "has_sig": false,
      "md5_digest": "7da443b312bc1953941dc0b878ae341d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 33889,
      "upload_time": "2021-03-23T19:14:28",
      "upload_time_iso_8601": "2021-03-23T19:14:28.324460Z",
      "url": "https://files.pythonhosted.org/packages/d1/68/73746413626d8c7c6795eae832e98ff0cfc3d5f5ba35041c614e9eccd5ca/huntlib-0.5.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}