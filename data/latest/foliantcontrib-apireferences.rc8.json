{
  "info": {
    "author": "Daniil Minukhin",
    "author_email": "ddddsa@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Console",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Topic :: Documentation",
      "Topic :: Utilities"
    ],
    "description": "[![](https://img.shields.io/pypi/v/foliantcontrib.apireferences.svg)](https://pypi.org/project/foliantcontrib.apireferences/)  [![](https://img.shields.io/github/v/tag/foliant-docs/foliantcontrib.apireferences.svg?label=GitHub)](https://github.com/foliant-docs/foliantcontrib.apireferences)\n\n# APIReferences Preprocessor for Foliant\n\n> APIReferences is a successor of APILinks preprocessor with slightly changed configuration syntax and completely rewritten insides. APILinks is now deprecated, please use APIReferences instead.\n\nPreprocessor replaces API *reference*s in markdown files with links to the corresponding method description on the API documentation web-page.\n\n## What is it for?\n\nSay, you have API documentation hosted at the url http://example.com/api-docs\n\nIt may be a [Swagger UI](https://swagger.io/tools/swagger-ui/) website or just some static one-page site (like [Slate](https://github.com/slatedocs/slate)).\n\nIf you have a site with API docs, you probably reference them from time in your other documents:\n\n```\nTo authenticate user use API method `POST /user/authenticate`.\n```\n\nWe thought, how cool it'd be if this fragment: **\\`POST /user/authenticate\\`** automatically transformed into a URL of this method's description on your API docs website:\n\n```\nTo authenticate user use API method [POST user/authenticate](http://example.com/api-docs/#post-user-authenticate).\n```\n\nThat's exactly what APIReferences does.\n\n## How does it work?\n\nThe purpose of APIReferences is to convert references into links. In the example above \\``POST /user/authenticate`\\` is a reference, and `[POST user/authenticate](http://example.com/api-docs/#post-user-authenticate)` is a Markdown link, the result of APIReferences' work.\n\nThe resulting link URL (http://example.com/api-docs/#get-user-authenticate) always consists of two parts: `{url}{anchor}`. `url` is static and is set in config, but `anchor` differs for each method. Open your API documentation website and look for HTML elements with `id` attribute near method description sections. When you add this `id` to the website's URL with number sign # (we call this combination an *anchor*), your browser scrolls the page to this exact element.\n\nThe tricky part is to determine which anchor should be added to the website's URL for each method. APIReferences offers several ways to do that, we call these ways *modes* (which are supplied in the `mode` parameter). It's up to you to choose the most suitable mode for your API website.\n\nHere are available modes with their short descriptions. Detailed descriptions and examples are in the **User Guide** below.\n\n**1. Generating anchors**\n\nMode option: `generate_anchor`\n\nConvert reference into an anchor without checking the website.\n\n**2. Find anchor**\n\nMode option: `find_by_anchor`\n\nParse API website and collect all ids from specific tags. Then convert reference into an anchor and check whether the converted anchor is present among these ids.\n\n**3. Find tag content**\n\nMode option: `find_by_tag_content`\n\nThis mode searches not by tag ids but by tag content (`<tag id=\"id\">content</tag>`) Parse API website and collect all tags from the specified list, which have ids and text content. The content to search is constructed from the reference. If the tag is found, return a link to its id.\n\n**4. Find method in swagger spec for SwaggerUI**\n\nMode option: `find_for_swagger`\n\nParse the swagger spec file and find the referenced method. The anchor is then constructed by a template. This mode will work for SwaggerUI websites.\n\n**5. Find method in swagger spec for Redoc**\n\nMode option: `find_for_redoc`\n\nParse the swagger spec file and find the referenced method. The anchor is then constructed by a template. This mode will work for Redoc websites.\n\n***\n\nAPIReferences is a highly customizable preprocessor. You can tune almost anything about reference conversion.\n\nFor details look through the following sections.\n\nGlossary:\n\n- **reference** — reference to an API method in the source file. The one to be replaced with the link, e.g. `GET user/config`\n- **verb** — HTTP method, e.g. `GET`, `POST`, etc.\n- **command** — resource used to represent method on the API documentation webpage, e.g. `/service/healthcheck`.\n- **endpoint prefix** — A prefix from server root to the command. If the command is `/user/status` and full resource is `/api/v0/user/status` then the endpoint prefix should be stated `/api/v0`. In references, you can use either full resource (`{endpoint_prefix}/{command}`) or just the command. APIReferences will sort it out for you.\n- **output** — string, which will replace the *reference*.\n- **tag content** — plain text between the tags, for example `<tag>Tag content</tag>`.\n- **anchor** — web-element id with leading number sign, for example `#get-user-config`. Adding the anchor to the end of the web URL will make a browser scroll to the specified web element.\n- **mode** — the way APIReferences will determine correct anchors to add to website URLs.\n\n## Quick Recipes\n\n### Recipe 1: find by tag content\n\nWe want reference \\``GET /user/status`\\` to be pointed at this element on our API website:\n\n```html\n<h2 id=\"get-user-status\">Operation GET /user/status</h2>\n```\n\nMinimal sufficient foliant.yml:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            My-API:\n                mode: find_by_tag_content\n                url: http://example.com/api  # path to your API website\n                content_template: 'Operation {verb} {command}'\n```\n\n\\``GET /user/status`\\` -> [GET /user/status](http://example.com/api#get-user-status)\n\n### Recipe 2: find by tag id\n\nThe task is the same as in Recipe 1. We want reference \\``GET /user/status`\\` to be pointed at this element on our API website:\n\n```html\n<h2 id=\"get-user-status\">Operation GET /user/status</h2>\n```\n\nMinimal sufficient foliant.yml:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            My-API:\n                mode: find_by_anchor\n                url: http://example.com/api  # path to your API website\n                anchor_template: '{verb} {command}'\n                anchor_converter: slate\n```\n\n\\``GET /user/status`\\` -> [GET /user/status](http://example.com/api#get-user-status)\n\n### Recipe 3: generate tag id\n\nThe task is the same as in Recipes 1 and 2, but this time you don't have access to API website at the time of building foliant project. We want reference \\``GET /user/status`\\` to be pointed at this element on our API website:\n\n```html\n<h2 id=\"get-user-status\">Operation GET /user/status</h2>\n```\n\nMinimal sufficient foliant.yml:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            My-API:\n                mode: generate_anchor\n                url: http://example.com/api  # path to your API website\n                anchor_template: '{verb} {command}'\n                anchor_converter: slate\n```\n\n\\``GET /user/status`\\` -> [GET /user/status](http://example.com/api#get-user-status)\n\n### Recipe 4: find link for SwaggerUI\n\nWe have a SwaggerUI website, and we need to find the link to the method by reference \\``GET /user/status`\\``.\n\nMethod anchors on SwaggerUI consist of tag and operationId, both of which are not present in our reference. APIReferences can find them for you in the spec file. Let's assume that correct tag and operationId are `usertag` and `getStatus`.\n\nMinimal sufficient foliant.yml:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            My-API:\n                mode: generate_for_swagger\n                url: http://example.com/swagger_ui  # path to your API website\n                spec: !path swagger.json  # path or direct url to OpenAPI spec\n```\n\n\\``GET /user/status`\\` -> [GET /user/status](http://example.com/swagger_ui#/usertag/getStatus)\n\n\n## Installation\n\n```shell\n$ pip install foliantcontrib.apireferences\n```\n\n## Config\n\nTo enable the preprocessor, add `apireferences` to `preprocessors` section in the project config:\n\n```yaml\npreprocessors:\n  - apireferences\n```\n\nThe preprocessor has a lot of options. For your convenience, the required options are marked *(required)*; and those options which are used in customization are marked *(optional)*. Most likely you will need just one or two of the latter.\n\n```yaml\npreprocessors:\n- apireferences:\n    targets:  # optional. default: []\n        - site\n    trim_if_targets: # optional. default: []\n        - pdf\n    prefix_to_ignore: Ignore  # optional\n    warning_level: 2  # optional\n    reference:  # optional\n        - regex: *ref_pattern\n          only_with_prefixes: false\n          only_defined_prefixes: false\n          output_template: '[{verb} {command}]({url})'\n          trim_template: '`{verb} {command}`'\n        - regex: *another_ref_pattern  # second reference config. Unlisted options are default\n          output_template: '**{verb} {command}**'\n    API:  # below are examples for each mode\n        Client-API:  # reference prefix\n            mode: generate_anchor\n            url: http://example.com/api/client\n            anchor_template: '{verb} {command}'\n            anchor_converter: pandoc  # optional\n            endpoint_prefix: /api/v1  # optional\n            endpoint_prefix_list: [/api/v1/,/api/v2/,/api/v3/]\n        Admin-API:\n            mode: find_by_anchor\n            url: http://example.com/api/admin\n            anchor_template: '{verb} {command}'\n            anchor_converter: pandoc  # optional\n            endpoint_prefix: /api/v1  # optional\n            tags: ['h1', 'h2', 'h3', 'h4']  # optional\n            login: login  # optional\n            password: password  # optional\n        External-API:\n            mode: find_by_tag_content\n            url: http://example.com/api/external\n            content_template: '{verb} {command}'\n            endpoint_prefix: /api/v1  # optional\n            tags: ['h1', 'h2', 'h3', 'h4']  # optional\n            login: login  # optional\n            password: password  # optional\n        Inernal-API:\n            mode: find_for_swagger\n            url: http://example.com/api/swagger-ui\n            anchor_template: '/{tag}/{operation_id}'\n            anchor_converter: no-transform\n            endpoint_prefix: /api/v1  # optional\n            login: login  # optional\n            password: password  # optional\n```\n\n`targets`\n:   *(optional)* List of supported targets for `foliant make` command. If target is not listed here — preprocessor won't be applied. If the list is an empty — preprocessor will be applied for any target. Default: `[]`\n\n`trim_if_targets`\n:   *(optional)* List of targets for `foliant make` command for which the prefixes from all *references* in the text will be cut out. Default: `[]`\n\n> Only those references whose prefixes are defined in the `API` section (described below) are affected by this option. All references with unlisted prefixes will not be trimmed.\n\n`prefix_to_ignore`\n:   *(optional)* A default prefix for ignoring references. If APIReferences meets a reference with this prefix, it leaves it unchanged. Default: `Ignore`\n\n`warning_level`\n:   *(optional)* `2` — show all warnings for not found references; `1` — show only warnings for not found prefixed references; `0` — don't show warnings about not found references. Default: `2`\n\n`use_multiproject_mode`\n: *(optional)* - Use cached API registries in case of multiproject. Default: `True`\n\n`reference`\n:   *(optional)* List of dictionaries. A subsection for listing all the types of references you are going to catch in the text, and their properties. Options for this section are listed below.\n\n> All reference properties have defaults. If any of them are missing in the config, the defaults will be used. If `reference` section is omitted, APIReferences will use default values.\n\n***\n\n**Reference options**\n\n`regex`\n:   *(optional)* regular expression used to catch *references* in the source. Look for details in the **Capturing References** section.\nDefault:\n\n```\n`((?P<prefix>[\\w-]+):\\s*)?(?P<verb>OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P<command>\\S+)`\n```\n\n`only_with_prefixes`\n:   *(optional)* if this is `true`, only *references* with prefix will be transformed. Ordinary links like `GET user/info` will be ignored. Default: `false`\n\n`only_defined_prefixes`\n:   *(optional)* if this is `true` all references whose prefix is not listed in the `API` section (described below) will be ignored. References without prefixes are not affected by this option. Default: `false`.\n\n`output_template`\n:   *(optional)* A template string describing the *output* which will replace the *reference*. More info in the **Customizing Output** section. Default: `'[{verb} {command}]({url})'`\n\n`trim_template`\n:   *(optional)* Only for targets listed in `trim_if_targets` option. Tune this template if you want to customize how APIReferences cuts out prefixes. The reference will be replaced with a text based on this template. Default: ```'`{verb} {command}`'```\n\n***\n\n`API`\n:   *(required)* A subsection for listing APIs and their properties. Define a separate subsection for each API here. The section name represents the API name and, at the same time, the *prefix* used in the references. You need to add at least one API subsection for the preprocessor to work.\n\n**API properties**\n\nThe list of options and some default values differ for each mode.\n\n`mode`\n:   *(required)* API mode, which determines how references are collected. Available modes: `generate_anchor`, `find_by_anchor`, `find_by_tag_content`, `find_for_swagger`, `find_for_redoc`.\n\n\n**`generate_anchor` mode**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method.\n\n`anchor_template`\n:   *(required)* A template string describing the format of the anchors in the API documentation web-page. You can use placeholders in {curly braces}, with names of the groups from the reference regex. Example: `'user-content {verb} {command}'`.\n\n`anchor_converter`\n:   *(optional)* anchor converter from [this list](https://github.com/foliant-docs/foliantcontrib.utils.header_anchors#to_id). Determines how string `GET /user/status` is converted into `get-userstatus` or `get-user-status` etc. [List of available converters](https://github.com/foliant-docs/foliantcontrib.utils.header_anchors#to_id). Default: `pandoc`\n\n`endpoint_prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. If is stated — APIReferences can divide the command into the reference and search for it more accurately. Also, you could use it in templates. More info in the **Commands and Endpoint Prefixes** section. Default: `''`\n\n`endpoint_prefix_list`\n: *(optional)* The list of available endpoint prefixes which could be added to output. Default: `[]`\n\n`trim_query`\n: *(optional)* Cut a query part after `?` character from command while searching for an API link. Default: `True`\n\n**`find_by_anchor` mode**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method. In this mode, it is also being parsed to check whether the generated anchor is present on the page.\n\n`anchor_template`\n:   *(required)* A template string describing the format of the anchors in the API documentation web-page. You can use placeholders in {curly braces}, with names of the groups in the reference regex. Example: `'user-content {verb} {command}'`.\n\n`anchor_converter`\n:   *(optional)* anchor converter from [this list](https://github.com/foliant-docs/foliantcontrib.utils.header_anchors#to_id). Determines how string `GET /user/status` is converted into `get-userstatus` or `get-user-status` etc. Default: `pandoc`\n\n`endpoint_prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. If is stated — APIReferences can divide the command into the reference and search for it more accurately. Also, you could use it in templates. More info in the **Commands and Endpoint Prefixes** section. Default: `''`\n\n`endpoint_prefix_list`\n: *(optional)* The list of available endpoint prefixes which could be added to output. Default: `[]`\n\n`tags`\n:   *(optional)* list of HTML tags which will be parsed out from the page and searched for ids. Default: `['h1', 'h2', 'h3', 'h4']`\n\n`login`\n:    *(optional)* Login for basic authentication if present on your API site.\n\n`password`\n:    *(optional)* Password for basic authentication if present on your API site.\n\n`trim_query`\n: *(optional)* Cut a query part after `?` character from command while searching for an API link. Default: `True`\n\n**`find_by_tag_content` mode**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method. In this mode, it is also being parsed to check whether the generated anchor is present on the page.\n\n`content_template`\n:   *(required)* A template string describing the format of the tag content in the API documentation web-page. You can use placeholders in {curly braces}, with names of the groups in the reference regex. Example: `'{verb} {command}'`.\n\n`endpoint_prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. If is stated — APIReferences can divide the command into the reference and search for it more accurately. Also, you could use it in templates. More info in the **Commands and Endpoint Prefixes** section. Default: `''`\n\n`endpoint_prefix_list`\n: *(optional)* The list of available endpoint prefixes which could be added to output. Default: `[]`\n\n`tags`\n:   *(optional)* list of HTML tags which will be parsed out from the page and searched for ids. Default: `['h1', 'h2', 'h3', 'h4']`\n\n`login`\n:    *(optional)* Login for basic authentication if present on your API site.\n\n`password`\n:    *(optional)* Password for basic authentication if present on your API site.\n\n`trim_query`\n: *(optional)* Cut a query part after `?` character from command while searching for an API link. Default: `True`\n\n**`find_for_swagger` mode**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method.\n\n`spec`\n:   *(required)* URL or local path to OpenAPI specification file.\n\n`anchor_template`\n:   *(optional)* A template string describing the format of the anchors in the API documentation web-page. You can use placeholders in {curly braces}, with names of the groups in the reference regex. In this mode, you can also use two additional placeholders: `{tag}` and `{operation_id}`. Default: `'/{tag}/{operation_id}'`.\n\n`endpoint_prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. You may use it in output template. Default: `''`\n\n`endpoint_prefix_list`\n: *(optional)* The list of available endpoint prefixes which could be added to output. Default: `[]`\n\n`login`\n:    *(optional)* Login for basic authentication if present on your API site.\n\n`password`\n:    *(optional)* Password for basic authentication if present on your API site.\n\n`trim_query`\n: *(optional)* Cut a query part after `?` character from command while searching for an API link. Default: `True`\n\n**`find_for_redoc` mode**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method.\n\n`spec`\n:   *(required)* URL or local path to OpenAPI specification file.\n\n`anchor_template`\n:   *(optional)* A template string describing the format of the anchors in the API documentation web-page. You can use placeholders in {curly braces}, with names of the groups in the reference regex. In this mode, you can also use two additional placeholders: `{tag}` and `{operation_id}`. Default: `'operation/{operation_id}'`.\n\n`endpoint_prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. You may use it in output template. Default: `''`\n\n`endpoint_prefix_list`\n: *(optional)* The list of available endpoint prefixes which could be added to output. Default: `[]`\n\n`login`\n:    *(optional)* Login for basic authentication if present on your API site.\n\n`password`\n:    *(optional)* Password for basic authentication if present on your API site.\n\n`trim_query`\n: *(optional)* Cut a query part after `?` character from command while searching for an API link. Default: `True`\n\n# User guide\n\nThe purpose of APIReferences is to convert *references* into Markdown links. \n\nReference is a chunk of text in your Markdown source which will be parsed by APIReferences, separated into groups, and converted into a link. An example of a reference is \\``GET /user/authenticate`\\`. APIReferences uses Regular Expressions to find the reference and split into groups. You can supply your own regular expression in `reference -> regex` param (details in **Capturing References** section below). If you are using the default one, the reference from the example above will be split into two groups:\n\n- **verb**: `GET`,\n- **command**: `/user/authenticate`.\n\nThese groups then will be used to find the referenced method on the API website and also to construct an *output string*.\n\nFor example, with `find_by_tag_content` mode (see the detailed description of all modes below) APIReferences will use `content_template` from API configuration to construct a tag content and search for it on the API website. If the content template is `'{verb} {command}'`, then the constructed content, for the example above, will be `GET /user/authenticate`. APIReferences will search for a tag with such content on the page and get its id.\n\nThe found tag may be `<h2 id=\"get-userauthenticate\">GET /user/authenticate</h2>`. APIReferences will take the id from this tag and use it as an anchor to the link: `#get-userauthenticate`. Then it will add the API website path and here's your url: `http://example.com/api/#get-userauthenticate`.\n\nNow, when APILink has the url of the method description, it can construct an output string. The output string is formed by a template, stated in reference `output_template` param. This template contains placeholders, which correspond to the reference groups with an addition of `{url}` placeholder, which contains the url formed above.\n\nIf the output template is `'[{verb} {command}]({url})'`, then the output string, for our example, will be:\n\n`[GET /user/authenticate](http://example.com/api/#get-userauthenticate)`.\n\nThat's it, we've turned our reference into a Markdown link:\n\n\\``GET /user/authenticate`\\` -> `[GET /user/authenticate](http://example.com/api/#get-userauthenticate)`.\n\nThat's the big picture. Now let's start with exploring different *modes* by means of which APIReferences captures references on API websites and transforms them into links.\n\n## API Modes\n\nAs mentioned above, APIReferences takes a reference from your markdown source and splits it into groups. It then uses these groups to find the correct id on the API website. How this search is performed is determined by *API Mode*. It can search for a specific tag on the page by tag content or by its id; it can also search for the operation in an OpenAPI specification file or just construct an id without any checks, depending on the mode you've chosen. The mode is specified in `API -> <api name> -> mode` config option.\n\n### `generate_anchor` mode\n\n`generate_anchor` is the simplest mode. It just generates the anchor basing on the `anchor_template` parameter. It doesn't perform any checks on the API website and doesn't even require the website to be reachable at the time of building your Foliant project.\n\nLet's assume that your API website code looks like this:\n\n```html\n...\n<h2 id=\"user-content-get-userlogin\">GET /user/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n\n<h2 id=\"user-content-get-apiv2adminstatus\">GET /api/v2/admin/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n...\n```\n\nAPIReferences config in your `foliant.yml` in this case may look like this:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            My-API:\n                mode: generate_anchor\n                url: http://example.com/api\n                anchor_template: 'user content {verb} {command}'\n                anchor_converter: pandoc\n```\n\nAs you may have noticed, there's no `reference` section in the example above. That's because we will be using default values for the reference.\n\nNow let's reference a **GET /user/status** method in our Markdown source:\n\n```\nTo find out user's status use `My-API: GET /user/status` method.\n```\n\n> Note that for `generate_anchor` mode, the API prefix (`My-API` in our case) is required in the reference. More info about prefixes in **Handling Multiple APIs** section.\n\nAPIReferences will notice a reference mentioned in our markdown: \\``My-API: GET /user/status`\\`. It will capture it and split into three groups:\n\n- **prefix**: `My-API`,\n- **verb**: `GET`,\n- **command**: `/user/status`.\n\nThen it will pass it to the anchor template `'user content {verb} {command}'` which we've stated in our config, and this will result in a string:\n\n`'user content GET /user/status'`\n\nAfter that, APIReferences will convert this string into an id with an anchor converter. We've chosen `pandoc` converter in our config, which will turn the string into this: `user-content-getuserstatus`. That's exactly the id we needed, look at the webpage source:\n\n```html\n<h2 id=\"user-content-get-userstatus\">GET /user/status</h2>\n```\n\nAPIReferences will add this id to our API url (which we've stated in config) to form a link: `http://example.com/api#user-content-get-userstatus`.\n\nFinally, it's time to construct a Markdown link. APIReferences takes an `output_template` from the reference config (which is omitted in our example foliant.yml because we are using defaults): `'[{verb} {command}]({url})'`.\n\nPlaceholders in the output template are replaced by groups from our reference, except `{url}` placeholder which is replaced with the url constructed above:\n\n`[GET /user/status](http://example.com/api#user-content-get-userstatus)`\n\nThe conversion is done. Our Markdown content will now look like this:\n\n```\nTo find out user's status use [GET /user/status](http://example.com/api#user-content-get-userstatus) method.\n```\n\n### `find_by_anchor` mode\n\n`find_by_anchor` generates the id by `anchor_template` parameter and searches for this id on the API web page. If an element with such id is found, the reference is converted into a Markdown link. If not — the reference is skipped.\n\nLet's assume that your API website code looks like this:\n\n```html\n...\n<h2 id=\"api-method-get-userstatus\">GET /user/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n\n<h2 id=\"api-method-get-apiv2adminstatus\">GET /api/v2/admin/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n...\n```\n\nAPIReferences config in your `foliant.yml` in this case may look like this:\n\n```yaml\npreprocessors:\n    apireferences:\n        reference:\n            output_template: '**[{verb} {command}]({url})**'\n            # other reference properties are default\n        API:\n            My-API:\n                mode: find_by_anchor\n                url: http://example.com/api\n                tags: ['h1', 'h2']\n                anchor_template: 'api-method {verb} {command}'\n                anchor_converter: pandoc\n```\n\nNow let's reference a **GET /user/status** method in our Markdown source:\n\n```\nTo find out user's status use `GET /user/status` method.\n```\n\nAPIReferences will notice a reference mentioned in our markdown: \\``GET /user/status`\\`. It will capture it and split into two groups:\n\n- **verb**: `GET`,\n- **command**: `/user/status`.\n\nThen it will pass it to the anchor template `'api-method {verb} {command}'` which we've stated in our config, and this will result in a string:\n\n`'user content GET /user/status'`\n\nAfter that, APIReferences will convert this string into an id with an anchor converter. We've used `pandoc` converter in our config, which will turn the string into this: `api-method-getuserstatus`.\n\nNow APIReferences will parse the web page and look for all `h1` and `h2` tags (as specified in `tags` parameter) that have ids and compare these ids to our generated id.\n\nOne of the elements satisfies the requirement:\n\n```html\n<h2 id=\"api-method-get-userstatus\">GET /user/status</h2>\n```\n\nIt means that referenced method is present on API web page, so APIReferences will add this id to our API url (which we've stated in config) to form a link: `http://example.com/api#api-method-get-userstatus`.\n\nFinally, it's time to construct a Markdown link. APIReferences takes an `output_template` from the reference config: `'**[{verb} {command}]({url})**'`.\n\nPlaceholders in the output template are replaced by groups from our reference, except `{url}` placeholder which is replaced with the url constructed above:\n\n`**[GET /user/status](http://example.com/api#api-method-get-userstatus)**`\n\nThe conversion is done. Our Markdown content will now look like this:\n\n```\nTo find out user's status use **[GET /user/status](http://example.com/api#api-method-get-userstatus)** method.\n```\n\n### `find_by_tag_content` mode\n\n`find_by_tag_content` generates tag content by the `content_template` and searches for an HTML element with such content on the API web page. If an element is found, the reference is converted into a Markdown link. If not — the reference is skipped.\n\nThis mode is convenient when there's no way to determine tag ID based on the reference, for example, when ids are random strings.\n\nLet's assume that your API website code looks like this:\n\n```html\n...\n<h2 id=\"o1egwb7agw\">GET /user/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n\n<h2 id=\"y3yn8ewg32\">GET /api/v2/admin/status</h2>\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>\n...\n```\n\nAPIReferences config in your `foliant.yml` in this case may look like this:\n\n```yaml\npreprocessors:\n    apireferences:\n        reference:\n            output_template: '[{prefix}: {verb} {command}]({url})'\n            # other reference properties are default\n        API:\n            My-API:\n                mode: find_by_tag_content\n                url: http://example.com/api\n                tags: ['h1', 'h2']\n                content_template: '{verb} {command}'\n```\n\nNow let's reference a **GET /user/status** method in our Markdown source:\n\n```\nTo find out user's status use `My-API: GET /user/status` method.\n```\n\nAPIReferences will notice a reference mentioned in our markdown: \\``My-API: GET /user/status`\\`. The reference has the prefix `My-API`, which means that `My-API` from the `API` section should be used. It will capture it and split into three groups:\n\n- **prefix**: `My-API`,\n- **verb**: `GET`,\n- **command**: `/user/status`.\n\nThen it will pass it to the header template `'{verb} {command}'` which we've stated in our config, and this will result in a string:\n\n`'GET /user/status'`\n\nNow APIReferences will parse the web page and look for all `h1` and `h2` tags (as specified in the `tags` parameter) whose content equals to our generated content.\n\nOne of the elements satisfies the requirement:\n\n```html\n<h2 id=\"o1egwb7agw\">GET /user/status</h2>\n```\n\nIt means that referenced method is present on the API web page, so APIReferences will take an id `o1egwb7agw` from it and add it to our API url (which we've stated in config) to form a link: `http://example.com/api#o1egwb7agw`.\n\nFinally, it's time to construct a Markdown link. APIReferences takes an `output_template` from the reference config: `'[{prefix}: {verb} {command}]({url})'`.\n\nPlaceholders in the output template are replaced by groups from our reference, except `{url}` placeholder which is replaced with the url constructed above:\n\n`[My-API: GET /user/status](http://example.com/api#api-method-get-userstatus)`\n\nThe conversion is done. Our Markdown content will now look like this:\n\n```\nTo find out user's status use [My-API: GET /user/status](http://example.com/api#api-method-get-userstatus) method.\n```\n\n### `find_for_swagger` mode\n\n`find_for_swagger` mode parses the OpenAPI spec file and looks for the referenced method in it. It then generates an anchor for SwaggerUI website based on data from the reference and the operation properties in the spec.\n\nLet's assume that your OpenAPI specification looks like this:\n\n```json\n{\n    \"swagger\": \"2.0\",\n    ...\n    \"paths\": {\n        \"/user/status\": {\n            \"GET\": {\n                \"tags\": [\"userauth\"],\n                \"summary\": \"Returns user auth status\",\n                \"operationId\": \"checkStatus\",\n                ...\n            },\n        }\n    ...\n\n```\n\nOn the default SwaggerUI website the anchor to this method will be `#/userauth/checkStatus`. It consists of the first tag from the operation properties and the operationId. So to generate the proper anchor APIReferences, will need to get those parts from the spec. \n\nAPIReferences config in your `foliant.yml` in this case may look like this:\n\n```yaml\npreprocessors:\n    apireferences:\n        # reference options are default in this example\n        API:\n            My-API:\n                mode: find_for_swagger\n                url: http://example.com/api\n                spec: !path swagger.json\n                anchor_template: '/{tag}/{operation_id}'  # you can omit this line because it's the default value\n```\n\nNow let's reference a **GET /user/status** method in our Markdown source:\n\n```\nTo find out user's status use `GET /user/login` method.\n```\n\nAPIReferences will notice a reference mentioned in our markdown: \\``GET /user/login`\\`. It will capture it and split into two groups:\n\n- **verb**: `GET`,\n- **command**: `/user/login`.\n\n> Note that `verb` and `command` groups are required for this mode if you are to redefine default reference regex.\n\nNow, when we have a verb and a command, we can search for it in the OpenAPI spec. APIReferences parses the spec and searches the `paths` section for our operation. From the operation properties APIReferences takes two values: \n\n- **tag**: first element from the `tags` list,\n- **operationId**.\n\nThese values are then passed to the anchor template `'/{tag}/{operation_id}'`, along with groups from our reference, this will result in a string:\n\n`'/userauth/checkStatus'`\n\nThat's the ID we were looking for. APIReferences will add it to our API url (which we've stated in config) to form a link: `http://example.com/api#/userauth/checkStatus`.\n\nFinally, it's time to construct a Markdown link. APIReferences takes an `output_template` from the reference config, which is default: `'[{verb} {command}]({url})'`.\n\nPlaceholders in the output template are replaced by groups from our reference, except `{url}` placeholder which is replaced with the url constructed above:\n\n`[GET /user/login](http://example.com/api#/userauth/checkStatus)`\n\nThe conversion is done. Our Markdown content will now look like this:\n\n```\nTo find out user's status use [GET /user/login](http://example.com/api#/userauth/checkStatus) method.\n```\n\n### `find_for_redoc` mode\n\n`find_for_redoc` is similar to `find_for_swagger` mode, except that default anchor template is `'operation/{operation_id}'`.\n\n## Handling Multiple APIs\n\nAPIReferences can work with several APIs at once, and honestly, it's very good at this.\n\nLet's consider an example foliant.yml:\n\n```yaml\npreprocessors:\n    apireferences:\n        API:\n            Client-API:\n                mode: find_by_tag_content\n                url: http://example.com/api/client\n                content_template: '{verb} {command}'\n            Admin-API:\n                mode: find_by_anchor\n                url: http://example.com/api/admin\n                content_template: '{verb} {command}'\n```\n\nIn this example we've defined two APIs: `Client-API` and `Admin-API`, these are just names, they may be anything you want. Now we can reference both APIs:\n\n```\nWhen user clicks \"LOGIN\" button, the app sends a request `POST /user/login`.\n\nTo restrict user from logging in run `PUT /admin/ban_user/{id}`.\n```\n\nAfter applying the preprocessor, this source will turn into:\n\n```\nWhen user clicks \"LOGIN\" button, the app sends a request [POST /user/login](http://example.com/api/client#post-userlogin).\n\nTo restrict user from logging in run [PUT /admin/ban_user/{id}](](http://example.com/api/admin#put-adminbanuser-id).\n```\n\nAs you see, APIReferences determined, which reference corresponds to which API. That is possible because when APIReferences meets a non-prefixed reference, it goes through each defined API and searches for the mentioned method.\n\nBut what happens if we reference a method which is present in both APIs?\n\n```\nRun `GET /system/healthcheck` for debug information.\n```\n\nYou have to understand that, even though APIReferences is very powerful, it doesn't understand the concept of free will. It can't make the choice for you, so instead, it will show a warning and skip this reference:\n\n```\nWARNING: [index.md] Failed to process reference. Skipping. `GET /system/healthcheck` is present in several APIs (Client-API, Admin-API). Please, use prefix.\n```\n\nIn the warning text, there's a suggestion to use a *prefix*. A prefix is a way to make your reference more specific and point APIReferences to the correct API. The value of the prefix is the API name as defined in the config. So for Client API, the prefix would be `Client-API`, for Admin — `Admin-API`. Let's fix our example:\n\n```\nRun `Admin-API: GET /system/healthcheck` to get debug information about the Admin API service.\n\nRun `Client-API: GET /system/healthcheck` to get debug information about the Client API service.\n```\n\n> If you don't like the format in which we supply prefix (`<prefix>: <verb> <command>`), you can change it by tweaking reference regex. More info in **Capturing References** section.\n\nIt's recommended to always use prefixes for unambiguity. The `generate_anchor` mode won't work at all for references without prefixes, because it doesn't perform any checks and almost always returns a link.\n\n## Handling Multiple Reference Configuration\n\nYou can not only make APIReferences work with different APIs but also with different reference configurations. `reference` parameter is a list for a reason. And because `output_template` is part of reference configuration, you can make different references transform into different values.\n\nHere's an example config:\n\n```yaml\npreprocessors:\n    apireferences:\n        reference:\n            - only_with_prefixes: true\n              output_template: '**[{verb} {command}]({url})**'\n            - only_with_prefixes: false\n              output_template: '[{verb} {command}]({url})'\n        API:\n            ...\n```\n\nWith such config references with prefixes will be transformed into **bold links**, while non-prefixed references will remain regular links.\n\n## Commands and Endpoint Prefixes\n\nAPIReferences treats the `command` part of your reference in a special way. While searching for it on the API website, it will try to substitute the command placeholder:\n\n- with and without leading slash (`/user/login` and `user/login`),\n- with and without endpoint prefix, if one is defined (`/api/v1/user/login` and `/user/login`).\n\nHere's an example config to illustrate this feature:\n\n```yaml\npreprocessors:\n    apireferences:\n        reference:\n            - only_with_prefixes: true\n              output_template: '**[{verb} {command}]({url})**'\n            - only_with_prefixes: false\n              output_template: '[{verb} {command}]({url})'\n        API:\n            My-API:\n                mode: find_by_tag_content\n                url: http://example.com/api\n                content_template: '{verb} {command}'\n                endpoint_prefix: /api/v1\n```\n\nConsidering that the API website source looks like this:\n\n```html\n<h2 id=\"asoi17uo\">GET /api/v1/user/status</h2>\n```\n\nWhich of these references, do you think, will give us the desired result?\n\n```\n`GET /user/status`\n`GET user/status`\n`GET /api/v2/user/status`\n```\n\nIf you were reading carefully, you already know the answer — all of these references will result in the same link:\n\n```\n[GET /user/status](http://example.com/api#asoi17uo)\n[GET /user/status](http://example.com/api#asoi17uo)\n[GET /user/status](http://example.com/api#asoi17uo)\n```\n\n\n# Capturing References\n\nAPIReferences uses regular expressions to capture *references* to API methods in Markdown files.\n\nThe default reg-ex is:\n\n```re\n`\\s*((?P<prefix>[\\w-]+):\\s*)?(?P<verb>OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P<command>[^`]+)\\s*`\n```\n\nThis expression accepts references like these:\n\n- `Client-API: GET user/info`\n- `UPDATE user/details`\n\nNotice that the default expression uses [Named Capturing Groups](https://docs.python.org/3/howto/regex.html#non-capturing-and-named-groups). You have to use them too, if you are to redefine the expression. You can name these groups as you like and have as many or as few as you wish, but it's recommended to include the `prefix` group for API prefix logic to work. It is also required for all groups which are in the `output_template` also to be present in the regex.\n\nTo redefine the regular expression, add an option `regex` to the reference config.\n\nFor example, if you want to capture ONLY references with prefixes, you may use the following:\n\n```yaml\npreprocessors:\n  - apireferences:\n      reference:\n      - regex: '\\s*((?P<prefix>[\\w-]+):\\s*)(?P<verb>POST|GET|PUT|UPDATE|DELETE)\\s+(?P<command>[^`]+)`\\s*'\n```\n\n> This example is for illustrative purposes only. You can achieve the same goal by just switching on the `only_with_prefixes` option.\n\nNow the references without prefix (`UPDATE user/details`) will be ignored.\n\n# Customizing Output\n\nYou can customize the *output*-string which will replace the *reference* string. To do that add a template into your reference configuration.\n\nA *template* is a string that may contain placeholders, surrounded by curly braces. These placeholders will be replaced with the values, and all the rest will remain unchanged.\n\nFor example, look at the default template:\n\n```yaml\npreprocessors:\n  - apireferences:\n    reference:\n      - output_template: '[{verb} {command}]({url})',\n```\n\n> Don't forget the single quotes around the template. These braces and parenthesis easily make YAML think that it is an embedded dictionary or list.\n\nWith the default template, the reference string will be replaced by something like that:\n\n```md\n[GET user/info](http://example.com/api/#get-user-info)\n```\n\nIf you want references to be transformed into something else, create your own template. You can use placeholders from the reference regular expression along with some additional:\n\n| placeholder     | description                                | example                                 |\n|-----------------|--------------------------------------------|-----------------------------------------|\n| source          | Full original reference string             | \\``Client-API: GET user/info`\\`         |\n| url             | Full url to the method description         | `http://example.com/api/#get-user-info` |\n| endpoint_prefix | API endpoint prefix from API configuration | `/api/v2`                               |\n\nPlaceholders from the default regex are:\n\n| placeholder | description                                               | example      |\n|-------------|-----------------------------------------------------------|--------------|\n| prefix      | API Prefix used in the reference                          | `Client-API` |\n| verb        | HTTP verb used in the reference                           | `GET`        |\n| command     | API command being referenced with endpoint prefix removed | `/user/info` |\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/foliant-docs/foliantcontrib.apireferences",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "foliantcontrib.apireferences",
    "package_url": "https://pypi.org/project/foliantcontrib.apireferences/",
    "platform": "any",
    "project_url": "https://pypi.org/project/foliantcontrib.apireferences/",
    "project_urls": {
      "Homepage": "https://github.com/foliant-docs/foliantcontrib.apireferences"
    },
    "release_url": "https://pypi.org/project/foliantcontrib.apireferences/1.0.7/",
    "requires_dist": [
      "foliant (>=1.0.8)",
      "foliantcontrib.utils (>=1.0.2)",
      "lxml"
    ],
    "requires_python": "",
    "summary": "Preprocessor for replacing references to API methods with links to their description.",
    "version": "1.0.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15372436,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2a39431cd89ca5b5a98f48cc5ab6c2b3adac3f7d24de4e56504e06c88a5bc767",
          "md5": "e8355373c2ae0688e7f5d142cf32215f",
          "sha256": "2396fc3f67f2186d5f3e1305cef088dcdbe2a268caa240c3b42523df16c4d1e8"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e8355373c2ae0688e7f5d142cf32215f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21399,
        "upload_time": "2021-03-09T08:40:37",
        "upload_time_iso_8601": "2021-03-09T08:40:37.761163Z",
        "url": "https://files.pythonhosted.org/packages/2a/39/431cd89ca5b5a98f48cc5ab6c2b3adac3f7d24de4e56504e06c88a5bc767/foliantcontrib.apireferences-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "52998824e14cd066f7b85f8c5a25ef0353c4fbef5169131ccf1094376bbe0877",
          "md5": "aff0b250788711596fa564e6c2611469",
          "sha256": "10d37c5212e9866828ae3cccfebb9fbd04afc49e9bda3eb1f14460857c777484"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "aff0b250788711596fa564e6c2611469",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 37810,
        "upload_time": "2021-03-09T08:40:40",
        "upload_time_iso_8601": "2021-03-09T08:40:40.166346Z",
        "url": "https://files.pythonhosted.org/packages/52/99/8824e14cd066f7b85f8c5a25ef0353c4fbef5169131ccf1094376bbe0877/foliantcontrib.apireferences-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6581bf2defe0f7923d49b18b6aa35e5c9014a9870ef0bc421317d2ae6c73f648",
          "md5": "4aea6d485f417903598a81609699df87",
          "sha256": "7d824090068e7805df7b631d88305a22259f26f8b23b95dacdfa80950aa1bb8f"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4aea6d485f417903598a81609699df87",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21672,
        "upload_time": "2021-03-11T07:14:15",
        "upload_time_iso_8601": "2021-03-11T07:14:15.634795Z",
        "url": "https://files.pythonhosted.org/packages/65/81/bf2defe0f7923d49b18b6aa35e5c9014a9870ef0bc421317d2ae6c73f648/foliantcontrib.apireferences-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4fad0ffac7eeb230c5f46cbd90eddbbc559fb932ffc998c73836f4cd3ef48889",
          "md5": "dbc7224077cfc6a3caa7b5b60b4cd45b",
          "sha256": "1fdfe0050f3f9589f68fdd0bad37304941641453eb921a8f969b7ced6e046cce"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "dbc7224077cfc6a3caa7b5b60b4cd45b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38269,
        "upload_time": "2021-03-11T07:14:17",
        "upload_time_iso_8601": "2021-03-11T07:14:17.078790Z",
        "url": "https://files.pythonhosted.org/packages/4f/ad/0ffac7eeb230c5f46cbd90eddbbc559fb932ffc998c73836f4cd3ef48889/foliantcontrib.apireferences-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "26ed89e3b7f8c3dcedb278873fededa2d1be320c6d9f7e8a6f92786025ff4ff4",
          "md5": "28d9eb7839ab7f92f69bf16008a47117",
          "sha256": "711405df2007134d042835fbbf0f22b595a2f4fe34a158aafa15070c214400df"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "28d9eb7839ab7f92f69bf16008a47117",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21661,
        "upload_time": "2021-07-20T13:12:28",
        "upload_time_iso_8601": "2021-07-20T13:12:28.961793Z",
        "url": "https://files.pythonhosted.org/packages/26/ed/89e3b7f8c3dcedb278873fededa2d1be320c6d9f7e8a6f92786025ff4ff4/foliantcontrib.apireferences-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7cce8f8363307500d8dba404c4b04099803632b71c8f898469ac3e3297fcfda6",
          "md5": "2c24e7dfa52167e6615b82d68d332260",
          "sha256": "b50fedb0bde65dd409035ed48044133142d4c109fe609bf455fb2713630b6a42"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "2c24e7dfa52167e6615b82d68d332260",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38954,
        "upload_time": "2021-07-20T13:12:31",
        "upload_time_iso_8601": "2021-07-20T13:12:31.222968Z",
        "url": "https://files.pythonhosted.org/packages/7c/ce/8f8363307500d8dba404c4b04099803632b71c8f898469ac3e3297fcfda6/foliantcontrib.apireferences-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d5abbdd8fd80317d90fdfe6245567ab32298ea54e3d984936e8243913424f91f",
          "md5": "4a3ab021372ff327b230255c3736cb09",
          "sha256": "52ec8cf50840c606007dc38c70abf2be92c8ac18a57ecb59d8c1085860dda0d6"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4a3ab021372ff327b230255c3736cb09",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 21879,
        "upload_time": "2022-06-09T07:23:49",
        "upload_time_iso_8601": "2022-06-09T07:23:49.387082Z",
        "url": "https://files.pythonhosted.org/packages/d5/ab/bdd8fd80317d90fdfe6245567ab32298ea54e3d984936e8243913424f91f/foliantcontrib.apireferences-1.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "92df54ac759b6f1a3fa0102fc2bc690ef03890d2b9a04316107972c2a97799b2",
          "md5": "1ec24fbb43d0a53669e04278b3a44374",
          "sha256": "4321677052332eef41340281369bc65ea34ab8556c3f7b7cbaba5ae59e4fce8a"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "1ec24fbb43d0a53669e04278b3a44374",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38860,
        "upload_time": "2022-06-09T07:23:50",
        "upload_time_iso_8601": "2022-06-09T07:23:50.656894Z",
        "url": "https://files.pythonhosted.org/packages/92/df/54ac759b6f1a3fa0102fc2bc690ef03890d2b9a04316107972c2a97799b2/foliantcontrib.apireferences-1.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f374fe8c896f9f46f89a60039ebf8f308bde0b23e96c2f06ba9654680cb2eb78",
          "md5": "fd7ee082ef0f2872f9c93e829534f852",
          "sha256": "577f6c5785ad22a24902329b45b60c97187ae0e7fec4262bb91a38981f128ec3"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fd7ee082ef0f2872f9c93e829534f852",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 22142,
        "upload_time": "2022-06-15T12:01:51",
        "upload_time_iso_8601": "2022-06-15T12:01:51.782922Z",
        "url": "https://files.pythonhosted.org/packages/f3/74/fe8c896f9f46f89a60039ebf8f308bde0b23e96c2f06ba9654680cb2eb78/foliantcontrib.apireferences-1.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0fd3a3144c00269d17e19090204d9071f1403a8b197666b8ba0ac52a3776728e",
          "md5": "390c4f1edcaccd6281fa28c39172942f",
          "sha256": "7aac79ca70b2a21fd1380a99426e60e85b912cdd1e2ceb5c4367e5fe2f5a37ba"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "390c4f1edcaccd6281fa28c39172942f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39401,
        "upload_time": "2022-06-15T12:01:53",
        "upload_time_iso_8601": "2022-06-15T12:01:53.294933Z",
        "url": "https://files.pythonhosted.org/packages/0f/d3/a3144c00269d17e19090204d9071f1403a8b197666b8ba0ac52a3776728e/foliantcontrib.apireferences-1.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "88c4c17705aa27e02172238476a5438cbe5da5c8c89e281f62edcb09205a7d4b",
          "md5": "46d9d903619cb75ae46d4dad95b9d2cd",
          "sha256": "d7e29c0eb506a1e0f3ff042d5e8d65e261e5532daf45440a02b91ab7532b9066"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "46d9d903619cb75ae46d4dad95b9d2cd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 22504,
        "upload_time": "2022-06-22T10:19:45",
        "upload_time_iso_8601": "2022-06-22T10:19:45.271859Z",
        "url": "https://files.pythonhosted.org/packages/88/c4/c17705aa27e02172238476a5438cbe5da5c8c89e281f62edcb09205a7d4b/foliantcontrib.apireferences-1.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f41c22c277b26760ca0492e6f52a401b4ae199867389e10c52be11eaeb1e1d56",
          "md5": "f0d9a9b49c2afbf388a0039b9e183323",
          "sha256": "997128cc21a4a0f0cfb6e9846ba5f901cb593f9de7dcb843c500a6c82e06c8d4"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "f0d9a9b49c2afbf388a0039b9e183323",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39819,
        "upload_time": "2022-06-22T10:19:46",
        "upload_time_iso_8601": "2022-06-22T10:19:46.670338Z",
        "url": "https://files.pythonhosted.org/packages/f4/1c/22c277b26760ca0492e6f52a401b4ae199867389e10c52be11eaeb1e1d56/foliantcontrib.apireferences-1.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0158efa35bbe4aee1cc476214a8085ac48c5c484081d9bf6e58e71d9dd2dff00",
          "md5": "8fd7b7faa403faa6f4be7ac8c1d68beb",
          "sha256": "36d1f2fc5b1dddce2a0c5a71551e0a09b2328d7ee2e930adc4dd76a512e8fd5e"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8fd7b7faa403faa6f4be7ac8c1d68beb",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 22524,
        "upload_time": "2022-09-21T11:21:49",
        "upload_time_iso_8601": "2022-09-21T11:21:49.734971Z",
        "url": "https://files.pythonhosted.org/packages/01/58/efa35bbe4aee1cc476214a8085ac48c5c484081d9bf6e58e71d9dd2dff00/foliantcontrib.apireferences-1.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d8d3e0479ac08752e920142649e7a90fff37766c3a793c903cdc5d8cd7b770ea",
          "md5": "5139b4a7c74ad4c48199a1e7a80d7fbe",
          "sha256": "afadb75e770f3b056dc72aaa7cb2b3b96cc726e9e68918dcb4c5909cc2e4cc84"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "5139b4a7c74ad4c48199a1e7a80d7fbe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39888,
        "upload_time": "2022-09-21T11:21:51",
        "upload_time_iso_8601": "2022-09-21T11:21:51.918772Z",
        "url": "https://files.pythonhosted.org/packages/d8/d3/e0479ac08752e920142649e7a90fff37766c3a793c903cdc5d8cd7b770ea/foliantcontrib.apireferences-1.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "84c9088f1afec1d539fd6da3c1c62e88f7f057c666ba156bfd14a7a48e8e8aec",
          "md5": "732d04222da2ec5490da2dedd5a51392",
          "sha256": "cb86e6b38fc7b4a763858c493d1876409e3ec4fef720e67b0184d4b424a40044"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "732d04222da2ec5490da2dedd5a51392",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 22524,
        "upload_time": "2022-10-11T11:15:42",
        "upload_time_iso_8601": "2022-10-11T11:15:42.210102Z",
        "url": "https://files.pythonhosted.org/packages/84/c9/088f1afec1d539fd6da3c1c62e88f7f057c666ba156bfd14a7a48e8e8aec/foliantcontrib.apireferences-1.0.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cebe704c974f1a488d53df85afa587b3041270bed94486a957845c29a9134f7c",
          "md5": "b42b0fe7b5cc8c89f3f2455d96d7341a",
          "sha256": "906d37604c27299777963584ddf14d0813ca719d8167884cec1ee190a7b1c716"
        },
        "downloads": -1,
        "filename": "foliantcontrib.apireferences-1.0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "b42b0fe7b5cc8c89f3f2455d96d7341a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39882,
        "upload_time": "2022-10-11T11:15:44",
        "upload_time_iso_8601": "2022-10-11T11:15:44.049812Z",
        "url": "https://files.pythonhosted.org/packages/ce/be/704c974f1a488d53df85afa587b3041270bed94486a957845c29a9134f7c/foliantcontrib.apireferences-1.0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "84c9088f1afec1d539fd6da3c1c62e88f7f057c666ba156bfd14a7a48e8e8aec",
        "md5": "732d04222da2ec5490da2dedd5a51392",
        "sha256": "cb86e6b38fc7b4a763858c493d1876409e3ec4fef720e67b0184d4b424a40044"
      },
      "downloads": -1,
      "filename": "foliantcontrib.apireferences-1.0.7-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "732d04222da2ec5490da2dedd5a51392",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 22524,
      "upload_time": "2022-10-11T11:15:42",
      "upload_time_iso_8601": "2022-10-11T11:15:42.210102Z",
      "url": "https://files.pythonhosted.org/packages/84/c9/088f1afec1d539fd6da3c1c62e88f7f057c666ba156bfd14a7a48e8e8aec/foliantcontrib.apireferences-1.0.7-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "cebe704c974f1a488d53df85afa587b3041270bed94486a957845c29a9134f7c",
        "md5": "b42b0fe7b5cc8c89f3f2455d96d7341a",
        "sha256": "906d37604c27299777963584ddf14d0813ca719d8167884cec1ee190a7b1c716"
      },
      "downloads": -1,
      "filename": "foliantcontrib.apireferences-1.0.7.tar.gz",
      "has_sig": false,
      "md5_digest": "b42b0fe7b5cc8c89f3f2455d96d7341a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 39882,
      "upload_time": "2022-10-11T11:15:44",
      "upload_time_iso_8601": "2022-10-11T11:15:44.049812Z",
      "url": "https://files.pythonhosted.org/packages/ce/be/704c974f1a488d53df85afa587b3041270bed94486a957845c29a9134f7c/foliantcontrib.apireferences-1.0.7.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}