{
  "info": {
    "author": "Yann Bouyeron",
    "author_email": "yann.bouyeron@hotmail.fr",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "# Genopy\n\n\nAnalyses génétiques et phylogénétiques pour les SVT\n\n\n## Sommaire:\n\n[Installation](#installgenopy)\n\n[Créer des séquences](#creatseq)\n\n[Créer des fichiers fasta](#creatfasta)\n\n[Convertir des fichiers .edi (anagene) en fichiers fasta](#convedi)\n\n[Rechercher et afficher des séquences](#openseq)\n\n[Transcrire](#transc)\n\n[Traduire](#transl)\n\n[Rétro-Transcrire](#rt)\n\n[Afficher les tables du code génétique](#tablecode)\n\n[Comparer des séquences: alignement par paires](#needlewater)\n\n[Comparer des séquences: alignement multiple (clustal)](#clustal)\n\n[Afficher et sauvegarder une matrice de distances](#matrix)\n\n[Tracer un arbre phylogénétique à partir d'une matrice de distances](#phylomatrix)\n\n[Tracer un arbre phylogénétique à partir d'une liste de séquences](#phyloseq)\n\n\n\n\n## Installation\n\n<a name =\"installgenopy\"></a>\n\n\n### Installation des dépendances.\n\nGenopy requiert python >= 3.4 et des dépendances python qui ne sont pas présentes dans la librairie standard (numpy, biopython, pandas, matplotlib, seaborn, ipfshttpclient) et des dépendances non python (Clustalw, Emboss, Rebase, Phylip).\n\n#### Installation des dépendances Python.\n\n\tsudo pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n\nSi vous avez plusieurs versions de python et que vous souhaitez installer Genopy pour la version de python 3.6 (par exemple):\n\n\tsudo python3.6 -m pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n\n#### Installation de Clustalw\n\n[http://www.clustal.org/clustal2/](http://www.clustal.org/clustal2/)\n\nSur Debian:\n\n\tsudo apt-get install clustalw\n\n#### Installation de Emboss\n\n[http://emboss.sourceforge.net/download/](http://emboss.sourceforge.net/download/)\n\nSur Debian:\n\n\tsudo apt-get install emboss\n\n\n#### Installation rebase pour emboss. (Facultatif)\n\nRebase permet  d’utiliser certaines fonctions liées aux enzymes de restriction; il s'agit notamment des fonctions restrict et remap.\n\n1: placez vous dans le répertoire de rebase\n\n\tcd /usr/share/EMBOSS/data/REBASE\n\n2: télécharger les fichiers withrefm et proto depuis le serveur ftp de rebase\n\n\tsudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/withrefm*\n\nPuis \n\n\tsudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/proto*\n\n3: décompresser \n\n\tsudo uncompress withrefm.707.gz\n\nEt \n\n\tsudo uncompress proto.707.gz\n\nVous n'aurez pas forcément le version 707.... c'est à adapter\n\n4: extraire rebase\n\n\trebaseextract\n\nEt voilà... c'est terminé.\n\n#### Installation de Phylip\n\n[http://evolution.genetics.washington.edu/phylip/install.html](http://evolution.genetics.washington.edu/phylip/install.html)\n\n\nSur Debian:\n\n\tsudo apt-get install phylip\n\n### Installation de genopy\n\n#### Avec pip:\n\n    sudo pip install genopy\n\nOu, pour une version donnée de python (exemple 3.6):\n\n    sudo python3.6 -m pip install genopy\n\n\n#### Depuis github:\n\n\tgit clone https://github.com/YannBouyeron/genopy\n\n\tcd genopy\n\n\tsudo python setup.py install\n\n\n## Licence\n\nCe code est sous licence <a href=\"http://www.gnu.org/licenses\">GPL3</a>\n\n\n## Exemple\n\n\n\t>>> import genopy as gp\n\t>>>\n\t>>> list_seq = gp.search(\"primates\")\n\n\n\t>>> list_seq\n\t[SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA...ACG', SingleLetterAlphabet()), id='Bonobo.adn', name='Bonobo.adn', description='Bonobo.adn  BONOBO', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCA...CCC', SingleLetterAlphabet()), id='G\u0001orille.adn', name='Gorille.adn', description='Gorille.adn  GORILLE', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA...CAC', SingleLetterAlphabet()), id='Pan_AJ586556.adn', name='Pan_AJ586556.adn', description='Pan_AJ586556.adn  AJ586556-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTACTGGCTCATTCATTA...CGG', SingleLetterAlphabet()), id='Pan_AJ586557.adn', name='Pan_AJ586557.adn', description='Pan_AJ586557.adn  AJ586557-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTATAGGGGGGAAAGAACTCAAAGAACAACCTAAGTACTAACTTAATCTCCC...AGT', SingleLetterAlphabet()), id='Colobe.adn', name='Colobe.adn', description='Colobe.adn  COLOBE', dbxrefs=[])]\n\t>>> \n\n\n\t>>> list_seq[1]\n\tSeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[])\n\t>>> \n\t>>> for i in list_seq:\n\t...     print(i.name)\n\t... \n\tRefhumaine.adn\n\tOrangoutan.adn\n\tBonobo.adn\n\tGorille.adn\n\tPan_AJ586556.adn\n\tPan_AJ586557.adn\n\tColobe.adn\n\t>>> \n\n\n\n\t>>> list_seq[1].name\n\t'Orangoutan.adn'\n\t>>> \n\n\t>>> gp.show(list_seq[1])\n\n\n          TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAGCGGCCT\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   10        20        30        40        50        60\n\n          ATGTATTTCGTACATTCCTGCCAGCCAACATGAATATCACCCAACACAACAATCGCTTAA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   70        80        90        100       110       120\n\n          CCACCTATAACACATACAAAGCCCAATCCACACCCAACCTCCACCCCCCGCTTACAAGCA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   130       140       150       160       170       180\n\n          AGTACCCCCCCATGCCCCCCCACCCAAACACATACATCGATTCCCCCACATAACCCCTTC\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   190       200       210       220       230       240\n\n          CCCCCCCGCATACCAACCAACCCAATCAAGCTTTAAAGTACATAGCACATAACACCCCTA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   250       260       270       280       290       300\n\n          CCGTACATAGCACATTTCTACTAACTCCCTGCTTAACCCTACGGA\n          ----:----|----:----|----:----|----:----|----:\n                   310       320       330       340\n\n\n\n\n\t>>> c = gp.clustal(*list_seq[1:5])\n\t>>> \n\t>>> gp.showgenix(c)\n\n\n    \t                *************   ** ****  ** *****  ****    *  *      *      \n\tBonobo.adn              TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA-TAACC\n\tPan_AJ586556.adn        TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA-CAACC\n\tGorille.adn             TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCAACAATT\n\tOrangoutan.adn          TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTT-CCAGCGGCC\n\n    \t                ----:----|----:----|----:----|----:----|----:----|----:----|\n        \t                         10        20        30        40        50        60\n\n\n\n\t...\n\t...\n\n\n\n\t>>> m = gp.matrix(c)\n\n\t>>> print(m)\n\tBonobo.adn       0\n\tPan_AJ586556.adn 0.13276836158192096    0\n\tGorille.adn      0.25988700564971756    0.2542372881355932    0\n\tOrangoutan.adn   0.3220338983050848     0.3220338983050848    0.36723163841807904     0\n       \t         Bonobo.adn             Pan_AJ586556.adn      Gorille.adn             Orangoutan.adn\n\n\n\t>>> tree = gp.tree_nj(m)\n\n\n\t  _______________ Bonobo.adn\n\t |\n\t_|______________ Pan_AJ586556.adn\n\t |\n\t |         ___________________________________________________ Orangoutan.adn\n\t |________|\n\t          |___________________________________ Gorille.adn\n\n\n## Tutoriel\n\n<a name=\"creatseq\"></a>\n\n### Créer des séquences\n\nLe module genopy dépend de biopython, on peut créer des sequences sous deux types d'objets différents: les objets Seq et SeqRecord. \n\nCréer un objet Seq\n\n    >>> from genopy import *\n\n    >>> s1 = Seq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCTTAGCCGT\") \n    >>> s1\n    Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT')\n\nLa fonction toSeq de genopy permet de créer plus facilement des objets Seq. Elle ajoute automatiquement le type.\n\n    >>> s2 = toSeq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCTTACCCGT\")\n    >>> s2\n    Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()) \n\nLes objets SeqRecord contiennent davantage d'informations:\n\n    >>> sr1 = SeqRecord(s1, id=\"sequence1\", name=\"sequence1\", description=\"une sequence\")\n    >>> sr1\n    SeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT'), id='sequence1', name='sequence1',      description='une sequence', dbxrefs=[])\n\n    >>> sr2 = SeqRecord(s2, id=\"sequence2\", name=\"sequence2\", description=\"une autre sequence\")\n    >>> sr2\n    SeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()), id='sequence2', name='sequence2', description='une sequence', dbxrefs=[])\n\n<a name=\"creatfasta\"></a>\n\n### Sauvegarder un ou plusieurs SeqRecord dans un ou plusieurs fichiers fasta\n\nCréer un fasta contenant un seul SeqRecord. Le fichier fasta serra enregistré dans le repertoire courant et portera le nom du SeqRecord avec l'extension .fas\n\n    >>> mkfas(sr1)\n\n\nCréer plusieurs fichiers fasta mono séquence:\n\n    >>> mkfas(sr1, sr2)\n\nCréer un fasta multisequence contenant plusieurs SeqRecord. Le fichier fasta serra enregistré dans le path indiqué en argument:\n\n    >>> mkfasx(\"myfasta.fas\", sr1, sr2)\n\n##### Créer un SeqRecord et un fasta avec la fonction creat()\n\n    >>> help(creat)\n    Help on function creat in module genopy:\n\n    creat(seq_name, seq, des='', out=False)\n        Création d'un SeqRecord et d'un fasta mono séquence\n\n    arguments:\n            seq_name: (str) nom de la séquence créée\n            seq: (str) ou (Seq) ou (SeqRecord) la séquence\n            des: (str) déscription du SeqRecord\n            out (bool): si False (défaut) , le fasta n'est pas créé\n\n    retrun: \n            le SeqRecord créé\n\n\n\n    >>> s = creat(\"un_adn\", \"ATCTCGTAGCTAGT\", des=\"human adn\", out=True)\n    >>> s\n    SeqRecord(seq=Seq('ATCTCGTAGCTAGT', IUPACUnambiguousDNA()), id='un_adn', name='un_adn', description='human adn', dbxrefs=[])\n\n\n\n<a name=\"convedi\"></a>\n\n### Convertir des fichiers anagène avec l'extension .edi en fichiers fasta\n\nOn commence par importer les modules genopy et os:\n\n    >>> from genopy import *\n    >>> import os\n\nOn liste les fichiers du repertoire dans lequel on se trouve (ou un autre repertoire si on indique son path en argument de listdir):\n\n    >>> ld = os.listdir()\n    >>> \n    >>> ld\n    ['__pycache__', 'genes-Opsines.edi', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n\nOn remarque ici deux fichiers en .edi\nOn utilise une boucle for pour selectionner les fichiers .edi et les convertir en .fas grace à la fonction edi2fasta. Cette fonction attend 2 arguments: edi2fasta(file_name.edi, file_name.fas):\n\n    >>> for i in ld:\n    ...     if i[len(i)-4:] == \".edi\":\n    ...             edi2fasta(i, i[:len(i)-4]+\".fas\")\n    ... \n    >>> \n\nOn liste à nouveau les fichiers du repertoire:\n\n    >>> os.listdir()\n    ['__pycache__', 'genes-Opsines.edi', 'allelesFamillechoree.fas', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'genes-Opsines.fas', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n\n\n<a name=\"openseq\"></a>\n\n### Ouvrir des séquences\n\nLes séquences doivent être hébergées localement.\n\nOn commence par rechercher les séquences avec la fonction 'search()' :\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"Opsine\")\n    >>> \n    >>> q\n    [SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gen\u0001e_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_verte', name='gene_opsine_verte', descripti\u0001on='gene_opsine_verte red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGAGAAAAATGTCGGAGGAAGAGTTTTATCTGTTCAAAAATATCTCTTCAGTG...TGA', SingleLetterAlphabet()), id='gene_opsine_bleue', name='gene_opsine_bleue', description='gene_opsine_bleue Blue\u0001 opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])]\n\nOn obtient une liste de SeqRecord correspondant à notre recherche.\n\n    >>> len(q)\n    3\n    >>> \n    >>> for i, j in enumerate(q):\n    ...     print(str(i) + \" \" + j.name)\n    ... \n    0 gene_opsine_rouge\n    1 gene_opsine_verte\n    2 gene_opsine_bleue\n\nOn peut alors afficher la séquence du gène de l'opsine verte dont l'indice dans la liste est 1 avec la fonction 'show()':\n\n    >>> show(q[1])\n\n\n          ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGCTATGAG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   10        20        30        40        50        60\n\n          GACAGCACCCAGTCCAGCATCTTCACCTACACCAACAGCAACTCCACCAGAGGCCCCTTC\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   70        80        90        100       110       120\n\n          GAAGGCCCGAATTACCACATCGCTCCCAGATGGGTGTACCACCTCACCAGTGTCTGGATG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   130       140       150       160       170       180\n\n          ATCTTTGTGGTCATTGCATCCGTTTTCACAAATGGGCTTGTGCTGGCGGCCACCATGAAG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   190       200       210       220       230       240\n\n          TTCAAGAAGCTGCGCCACCCGCTGAACTGGATCCTGGTGAACCTGGCGGTCGCTGACCTG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   250       260       270       280       290       300\n\n          GCAGAGACCGTCATCGCCAGCACTATCAGCGTTGTGAACCAGGTCTATGGCTACTTCGTG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   310       320       330       340       350       360\n\n\n\n(la séquence n'est pas représentée entierement dans ce tutoriel)\n\n\n\n### Transcrire, Traduire, Rétro-transcrire\n\n<a name=\"transc\"></a>\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"Opsine\")\n    >>> dna = q[0]\n    >>> \n    >>> dna\n    SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gene_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])\n\n#### Transcrire\n\n    >>> rna = transcribe(dna)\n    >>> rna\n    SeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n\n\n<a name=\"transl\"></a>\n\n#### Traduire\n\n    >>> help(translate)\n    Help on function translate in module genopy:\n\n    translate(*seq, table_id=1, to_stop=True, stop_symbol=' ', cds=True, out=False)\n    Traduction d'un ou plusieurs dna ou rna SeqRecord. \n\n    arguments:\n        *seq: liste de dna ou rna Seq ou SeqRecord\n        table_id: indice de la table du code génétique à utiliser (par defaut: 1 c'est le code standard)\n        to_stop: bool  True par défaut: la traduction s'arrete au codon stop\n        stop_symbol: représentation de l'arret de la traduction\n        cds: coding sequence: bool  True par défaut: la traduction commence au condon initiateur et se termine au codon stop\n        out: bool False par défaut. Si out == True, chaque sequence peptidique est sauvegardée dans un fasta. \n\n    return: proteine SeqRecord ou une liste de proteines SeqRecord\n\n> ORF: open reading frame ou phase ouverte de lecture, c'est la séquence du brin non transcrit (brin codant) de l'adn (ou de l'arn pré-messager) située entre le premier codon initiateur jusqu'au premier codon stop \n> \n> CDS: coding sequence ou séquence codante, c'est l'ORF sans les introns\n\nIl est possible de choisir la table du code génétique utilisée (par défaut c'est le code standard)\n\nL'argument to_stop = True permet d'arreter la traduction au codon stop\n\nL'argument stop_symbol permet de spécifier la représentation de l'arret de la traduction\n\nL'argument cds = True implique que la traduction commencera au premier codon initiateur rencontré et se terminera au premier codon stop rencontré sur le cadre de lecture. La majorité des séquences importées depuis anangene sont déjà des CDS, donc ca change rien; mais ce n'est pas le cas des fasta téléchargés depuis les banques de séquences. \n\n    >>> pep = translate(rna)\n    >>> pep\n    SeqRecord(seq=Seq('MAQQWSLQRLAGRHPQDSYEDSTQSSIFTYTNSNSTRGPFEGPNYHIAPRWVYH...SPA', ExtendedIUPACProtein()), id='gene_opsine_rouge.rna.prot', name='gene_opsine_rouge.rna.prot', description='traduction de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigmen\u0001ts), mRNA]]', dbxrefs=[])\n\n    >>> show(pep)\n\n\n          MetAlaGlnGlnTrpSerLeuGlnArgLeuAlaGlyArgHisProGlnAspSerTyrGluAspSerThrGlnSerSerIlePheThrTyr\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      10                            20                            30\n\n          ThrAsnSerAsnSerThrArgGlyProPheGluGlyProAsnTyrHisIleAlaProArgTrpValTyrHisLeuThrSerValTrpMet\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      40                            50                            60\n\n          IlePheValValThrAlaSerValPheThrAsnGlyLeuValLeuAlaAlaThrMetLysPheLysLysLeuArgHisProLeuAsnTrp\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      70                            80                            90\n\n          IleLeuValAsnLeuAlaValAlaAspLeuAlaGluThrValIleAlaSerThrIleSerIleValAsnGlnValSerGlyTyrPheVal\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      100                           110                           120\n\n          LeuGlyHisProMetCysValLeuGluGlyTyrThrValSerLeuCysGlyIleThrGlyLeuTrpSerLeuAlaIleIleSerTrpGlu\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      130                           140                           150\n\n<a name=\"rt\"></a>\n\n#### Rétro transcrire\n\n    >>> rna\n    SeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n\n\n    >>> dna_c = retro_transcribe(rna)\n    >>> dna_c\n    SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', DNAAlphabet()), id='gene_opsine_rouge.rna.dnac', name='gene_opsine_rouge.rna.dnac', description='retro transcription de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]]', dbxrefs=[])\n\n    >>> dna.seq == dna_c.seq\n    True\n\n<a name=\"tablecode\"></a>\n\n### Afficher les tables du code génétique\n\n    >>> from genopy import *\n    >>>\n    >>> codegen()\n\n\n    1 : Standard\n    2 : Vertebrate Mitochondrial\n    3 : Yeast Mitochondrial\n    4 : Mold Mitochondrial\n    5 : Invertebrate Mitochondrial\n    6 : Ciliate Nuclear\n    9 : Echinoderm Mitochondrial\n    10 : Euplotid Nuclear\n    11 : Bacterial\n    12 : Alternative Yeast Nuclear\n    13 : Ascidian Mitochondrial\n    14 : Alternative Flatworm Mitochondrial\n    15 : Blepharisma Macronuclear\n    16 : Chlorophycean Mitochondrial\n    21 : Trematode Mitochondrial\n    22 : Scenedesmus obliquus Mitochondrial\n    23 : Thraustochytrium Mitochondrial\n    24 : Pterobranchia Mitochondrial\n    25 : Candidate Division SR1\n    26 : Pachysolen tannophilus Nuclear\n    27 : Karyorelict Nuclear\n    28 : Condylostoma Nuclear\n    29 : Mesodinium Nuclear\n    30 : Peritrich Nuclear\n    31 : Blastocrithidia Nuclear\n\n\n\n\n    Entrez le numéro de la table à afficher: 1\n\n\n    RNA table: \n\n    Table 1 Standard, SGC0\n\n      |  U      |  C      |  A      |  G      |\n    --+---------+---------+---------+---------+--\n    U | UUU F   | UCU S   | UAU Y   | UGU C   | U\n    U | UUC F   | UCC S   | UAC Y   | UGC C   | C\n    U | UUA L   | UCA S   | UAA Stop| UGA Stop| A\n    U | UUG L(s)| UCG S   | UAG Stop| UGG W   | G\n    --+---------+---------+---------+---------+--\n    C | CUU L   | CCU P   | CAU H   | CGU R   | U\n    C | CUC L   | CCC P   | CAC H   | CGC R   | C\n    C | CUA L   | CCA P   | CAA Q   | CGA R   | A\n    C | CUG L(s)| CCG P   | CAG Q   | CGG R   | G\n    --+---------+---------+---------+---------+--\n    A | AUU I   | ACU T   | AAU N   | AGU S   | U\n    A | AUC I   | ACC T   | AAC N   | AGC S   | C\n    A | AUA I   | ACA T   | AAA K   | AGA R   | A\n    A | AUG M(s)| ACG T   | AAG K   | AGG R   | G\n    --+---------+---------+---------+---------+--\n    G | GUU V   | GCU A   | GAU D   | GGU G   | U\n    G | GUC V   | GCC A   | GAC D   | GGC G   | C\n    G | GUA V   | GCA A   | GAA E   | GGA G   | A\n    G | GUG V   | GCG A   | GAG E   | GGG G   | G\n    --+---------+---------+---------+---------+--\n\n\n    <Bio.Data.CodonTable.NCBICodonTableRNA object at 0x74a047d0>\n\n\n\n\n    >>> cg = codegen(1, bydna=True)\n\n\n    DNA table: \n\n    Table 1 Standard, SGC0\n\n      |  T      |  C      |  A      |  G      |\n    --+---------+---------+---------+---------+--\n    T | TTT F   | TCT S   | TAT Y   | TGT C   | T\n    T | TTC F   | TCC S   | TAC Y   | TGC C   | C\n    T | TTA L   | TCA S   | TAA Stop| TGA Stop| A\n    T | TTG L(s)| TCG S   | TAG Stop| TGG W   | G\n    --+---------+---------+---------+---------+--\n    C | CTT L   | CCT P   | CAT H   | CGT R   | T\n    C | CTC L   | CCC P   | CAC H   | CGC R   | C\n    C | CTA L   | CCA P   | CAA Q   | CGA R   | A\n    C | CTG L(s)| CCG P   | CAG Q   | CGG R   | G\n    --+---------+---------+---------+---------+--\n    A | ATT I   | ACT T   | AAT N   | AGT S   | T\n    A | ATC I   | ACC T   | AAC N   | AGC S   | C\n    A | ATA I   | ACA T   | AAA K   | AGA R   | A\n    A | ATG M(s)| ACG T   | AAG K   | AGG R   | G\n    --+---------+---------+---------+---------+--\n    G | GTT V   | GCT A   | GAT D   | GGT G   | T\n    G | GTC V   | GCC A   | GAC D   | GGC G   | C\n    G | GTA V   | GCA A   | GAA E   | GGA G   | A\n    G | GTG V   | GCG A   | GAG E   | GGG G   | G\n    --+---------+---------+---------+---------+--\n\n\n    >>> cg.\n    cg.back_table           cg.id                   cg.nucleotide_alphabet  cg.start_codons         \n    cg.forward_table        cg.names                cg.protein_alphabet     cg.stop_codons          \n\n    >>> cg.start_codons\n    ['TTG', 'CTG', 'ATG']\n\n    >>> cg.back_table\n    {'K': 'AAG', 'N': 'AAT', 'T': 'ACT', 'R': 'CGT', 'S': 'TCT', 'I': 'ATT', 'M': 'ATG', 'Q': 'CAG', 'H': 'CAT', 'P': 'CCT', 'L': 'TTG', 'E': 'GAG', 'D': 'GAT', 'A': 'GCT', 'G': 'GGT', 'V': 'GTT', 'Y': 'TAT', 'C': 'TGT', 'W': 'TGG', 'F': 'TTT', None: 'TAA'}\n\n    >>> cg.forward_table\n    {'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'TAT': 'Y', 'TAC': 'Y', 'TGT': 'C', 'TGC': 'C', 'TGG': 'W', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P', 'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GTT': 'V', 'GTC': 'V',\u0001 'GTA': 'V', 'GTG': 'V', 'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A', 'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'}\n\n    >>> cg.forward_table[\"AAC\"]\n    'N' \n\n\n\n\n<a name=\"needlewater\"></a>\n\n### Comparer deux séquences: alignement par Needle ou Water\n\nOn commence par rechercher des séquences:\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"primates\")\n    >>> \n    >>> len(q)\n    7\n    >>> \n    >>> q[0]\n    SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[])\n\nOn va ensuite comparer les séquences 2 à 2. \n\nIl est possible de faire un alignement global (needle) ou local (water)\n\n    >>> help(needle)\n    Help on function needle in module genopy:\n\n    needle(*seq, gapopen=10, gapextend=0.5, out='emb.aln')\n        Alignement global par la méthode de Needleman\n\n    arguments:\n\n            seq: couple de 2 SeqRecord à aligner\n            gapopen: pénalité de gap\n            gapextend: pénalité d'expansion\n            out: nom du fichier emboss créé\n\n    return: un objet align\n\nL'alignement est enregistré par défaut dans le fichier emb.aln (qui serra écrasé au prochain alignement réalisé)\n\nDans les 2 cas on peut eventuellement modifier les pénalités pour les ouvertures ou les extensions de gap.\n\n\n    >>> n = needle(q[0], q[1])\n    >>> \n    >>> w = water(q[0], q[1])\n    >>> \n    >>> n\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 365, SingleLetterAlphabet()) at 70615df0>\n    >>> w\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 361, SingleLetterAlphabet()) at 7061def0>\n\n\nOn obtient des objets \"align\" que l'on peut alors exploiter de différentes façons:\n\nObtenir des informations de base sur l'alignement:\n\n    >>> print(n)\n    SingleLetterAlphabet() alignment with 2 rows and 365 columns\n    TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGAC...--- Refhumaine.adn\n    TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----AC...GGA Orangoutan.adn\n\n    >>> n.\n    n.add_sequence(          n.append(                n.extend(                n.get_alignment_length(  \n    n.annotations            n.column_annotations     n.format(                n.sort(                  \n\n    >>> n.get_alignment_length()\n    365\n\n    >>> len(n)\n    2\n\n    >>> n[0]\n    SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...---', SingleLetterAlphabet()), id='Refhumaine.adn', name='<unknown name>', description='Refhumaine.adn', dbxrefs=[])\n\n\n\nAfficher l'alignement avec les fonctions shogenix(), showanag(), (ou showgenix3() pour les séquences peptidiques avec acides aminés représentés à trois lettres)\n\nL'affichage via showgenix représente toutes les séquences. Les similitudes sont symbolisées par une * et les délétions par des - . \n\n    >>> showgenix(n)\n\n\n                          ************* * *********** ****** ***    **  ******   ** * \n    Refhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\n    Orangoutan.adn        TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCCATTTCCAGCG\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   10        20        30        40        50        60\n\n\n\n                          * ****************** ********** *********   **   ** **  *** \n    Refhumaine.adn        G-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC-CATAAAT-\n    Orangoutan.adn        GCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATAT--CACCCAACACAACAATC\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   70        80        90        100       110       120\n\n\nL'affichage via showanag utilise le même mode de symbolisation que le logiciel anagene.\n\n    >>> showanag(n)\n\n\n                          ************* * *********** ****** ***    **  ******   ** * \n    Refhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\n    Orangoutan.adn        -------------G-T-----------A------C---____--CG------TTC--G-G\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   10        20        30        40        50        60\n\n\n\n                          * ****************** ********** *********   **   ** **  *** \n    Refhumaine.adn        G_CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC_CATAAAT_\n    Orangoutan.adn        -C------------------C----------A---------__C--CCA--A--AC---C\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   70        80        90        100       110       120\n\n\n\n\n\nIl est aussi possible de lire l'alignement enregistré dans le fichier emb.aln avec la fonction reademboss() \n\n\n\n    >>> n = needle(q[0], q[1])\n\n    >>> reademboss(\"emb.aln\")    # ou reademboss()\n\n    ########################################\n    # Program: needle\n    # Rundate: Sun 14 Jul 2019 11:13:59\n    # Commandline: needle\n    #    -outfile emb.aln\n    #    -asequence seqa.fas\n    #    -bsequence seqb.fas\n    #    -gapopen 10\n    #    -gapextend 0.5\n    # Align_format: srspair\n    # Report_file: emb.aln\n    ########################################\n\n    #=======================================\n    #\n    # Aligned_sequences: 2\n    # 1: Refhumaine.adn\n    # 2: Orangoutan.adn\n    # Matrix: EDNAFULL\n    # Gap_penalty: 10.0\n    # Extend_penalty: 0.5\n    #\n    # Length: 365\n    # Identity:     255/365 (69.9%)\n    # Similarity:   255/365 (69.9%)\n    # Gaps:          40/365 (11.0%)\n    # Score: 824.5\n    # \n    #\n    #=======================================\n\n    Refhumaine.ad      1 TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCC     50\n                         |||||||||||||.|.|||||||||||.||||||.|||    ||..||||\n    Orangoutan.ad      1 TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCC     46\n\n    Refhumaine.ad     51 ATCAACAACCG-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATA     99\n                         ||...||.|.| ||||||||||||||||||.||||||||||.||||||||\n    Orangoutan.ad     47 ATTTCCAGCGGCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATA     96\n\n\n    #---------------------------------------\n    #---------------------------------------\n\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 365, SingleLetterAlphabet()) at 70603ab0>\n\n\n(Les alignements ne sont pas représentés en entier dans ce tutoriel)\n\nIl est possible d'afficher le % de similitudes ou de différences en utilisant la fonction reademboss (comme ci dessous) ou en affichant la matrice de distance avec la fonction matrix()\n\n    >>> m = matrix(n)\n    >>> print(m)\n    Refhumaine.adn  0\n    rangoutan.adn   0.3013698630136986      0\n                    Refhumaine.adn          Orangoutan.adn\n\n<a name=\"clustal\"></a>\n\n### Comparaison multiple de séquences avec Clustal\n\nOn commence par importer des séquences:\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> \n    >>> len(q)\n    25\n    >>> \n    >>> q[0]\n    SeqRecord(seq=Seq('ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGC...TAA', SingleLetterAlphabet()), id='Tyrcod2', name='Tyrcod2', description=\"Tyrcod2  Partie strictement codante d'un allele du gene de la tyrosinase (ref erence 2).\", dbxrefs=[])\n\nPuis on utilise la fonction clustal: exemple ici pour comparer les séquence d’index 5, 6, 7, 8\n\n    >>> c = clustal(*q[5:9])  # ou clustal(q[5], q[6], q[7], q[8])\n    >>> c\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (4 records of length 1590, SingleLetterAlphabet()) at 704f06f0>\n\n\nAffichage simple: \n\n    >>> print(c)\n    SingleLetterAlphabet() alignment with 4 rows and 1590 columns\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all1\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all2\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all2\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all1\n    >>> \n\nMéthodes applicables à l'objet align:\n\n    >>> c.\n    c.add_sequence(          c.append(                c.extend(                c.get_alignment_length(  \n    c.annotations            c.column_annotations     c.format(                c.sort(                  \n\nAffichage au format clustal:\n\n    >>> print(c.format(\"clustal\"))\n    CLUSTAL 2.1 multiple sequence alignment\n\n\n    F4_I2all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I2all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I1all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I1all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n                  **************************************************\n\n\nAffichage au format phylip:\n\n    >>> print(c.format(\"phylip\"))\n    4 1590\n    F4_I2all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I2all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I1all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I1all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n\n\nAffichage au format genix:\n\n    >>> showgenix(c)\n\n\n                     ************************************************************\n    F4_I2all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I2all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I1all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I1all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n\n                     ----:----|----:----|----:----|----:----|----:----|----:----|\n                              10        20        30        40        50        60\n\nIl est aussi possible de faire un affichage de l'alignement au format anagene avec la fonction showanag().\n\n<a name=\"matrix\"></a>\n\n#### Afficher une matrice de distances:\n\nLa fonction matrix attend un alignement (needle, water ou clustal) en argument obligatoire:\n\n    >>> m = matrix(c)\n    >>> print(m)\n    F4_I2all1       0\n    F4_I2all2       0.0006289308176100628   0\n    F4_I1all2       0.0012578616352201255   0.0006289308176100628   0\n    F4_I1all1       0.0012578616352201255   0.0006289308176100628   0.0012578616352201255   0\n                    F4_I2all1               F4_I2all2               F4_I1all2               F4_I1all1\n\nLa matrice peut être convertie en table HTML et déployée sur [IPFS](https://gist.github.com/YannBouyeron/53e6d67782dcff5995754b0a7333fa0b) avec la fonction matrix2ipfs:\n\n    >>> matrix2ipfs(m)\n    'QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK'\n\nOn obtient le hash du fichier HTML, consultable sur votre noeud ipfs ou via ipfs.io: https://ipfs.io/ipfs/<hash>:\n\n[https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK](https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK)\n\nLa matrice peut aussi être sauvegardée sous forme d'image png qui serra enregistrée localement:\n\n    >>> matrix2png(m, path=\"ma_matrice.png\")\n    <matplotlib.axes._subplots.AxesSubplot object at 0x704f0a50>\n\n\n<p align=\"center\">\n  <img src=\"Images/ma_matrice.png\">\n</p>\n\n<a name=\"phylomatrix\"></a>\n\n### Construire un arbre phylogénétique à partir d'une matrice de distances\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> c = clustal(*q[5:10])\n    >>> m = matrix(c)\n\n    >>> print(m)\n    F4_I2all2       0\n    4_II1all1       0.0                     0\n    F4_I2all1       0.0006289308176100628   0.0006289308176100628   0\n    F4_I1all2       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0\n    F4_I1all1       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0.0012578616352201255   0\n                    F4_I2all2               F4_II1all1              F4_I2all1               F4_I1all2               F4_I1all1\n\n\nNeighbor-joining:\n\n    >>> help(tree_nj)\n\n    Help on function tree_nj in module genopy:\n\n    tree_nj(dm)\n        Création d'un arbre nj à partir de la matrice de distance retournée par la fonction matrix\n        return: tree\n\n\n\n    >>> nj = tree_nj(m)\n\n\n     , F4_I2all2\n     |\n     | F4_II1all1\n     |\n     |_________________________________________________________________ F4_I2all1\n    _|\n     |_________________________________________________________________ F4_I1all2\n     |\n     |_________________________________________________________________ F4_I1all1\n\n\n    >>> nj\n    Tree(rooted=True)\n\n\nUPGMA:\n\n    >>> help(tree_upgma)\n\n    Help on function tree_upgma in module genopy:\n\n    tree_upgma(dm)\n        Création d'un arbre upgma à partir de la matrice de distance retournée par la fonction matrix\n        return: tree\n\n\n    >>> up = tree_upgma(m)\n\n\n      _________________________________________________________________ F4_I2all1\n    _|\n     |         ________________________________________________________ F4_I1all2\n     |________|\n              |                   _____________________________________ F4_I1all1\n              |__________________|\n                                 |                                     , F4_II1all1\n                                 |_____________________________________|\n                                                                       | F4_I2all2\n\n\nParcimonie:\n\n    >>> help(parsimony_tree)\n\n    Help on function parsimony_tree in module genopy:\n\n    parsimony_tree(align, starting_tree)\n        Création d'un arbre basé sur la méthode de parcimonie à partir de l'alignement et d'un arbre de départ (nj)\n\n    arguments:\n            align: objet align retourné par clustal()\n            satrting_tree: objet tree retourné par tree_nj()\n\n    return: tree\n\n\n    >>> pa = parsimony_tree(c, nj)\n\n\n      _________________________________________________________________ F4_I2all1\n     |\n     , F4_II1all1\n     |\n     | F4_I2all2\n    _|\n     |_________________________________________________________________ F4_I1all1\n     |\n     |_________________________________________________________________ F4_I1all2\n\n\n\nPour afficher les distances sur les branches de l'arbre:\n\n     >>> nj = tree_nj(m)\n\n     >>> dnj = draw_tree(nj, distance=True)\n\n\n<a name=\"phyloseq\"></a>\n\n### Construire un arbre phylogénétique à partir d'une liste de séquences\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> \n    >>> len(q)\n    25\n    >>> \n    >>> help(phylo)\n\n    Help on function phylo in module genopy:\n\n    phylo(*seq, out='comp.aln')\n        Méthode simplifiée de création d'un arbre phylogénétique à partir d'une liste de SeqRecord\n\n            argument: *seq: liste de SeqRecord à aligner\n            return: (align, stdout, tree)\n\n\n    >>> p = phylo(*q[3:7])\n\n\n               Tyralb_TS  F4_I1all2  Tyralb_A5  F4_I1all1\n    Tyralb_TS   0.000000   0.000000   0.001887   0.001258\n    F4_I1all2   0.000000   0.000000   0.001887   0.001258\n    Tyralb_A5   0.001887   0.001887   0.000000   0.000629\n    F4_I1all1   0.001258   0.001258   0.000629   0.000000\n\n\n\n\n                                                   ______________________ Tyralb_A5\n      ____________________________________________|\n     |                                            | F4_I1all1\n    _|\n     | Tyralb_TS\n     |\n     | F4_I1all2\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "genopy",
    "package_url": "https://pypi.org/project/genopy/",
    "platform": "",
    "project_url": "https://pypi.org/project/genopy/",
    "project_urls": {
      "Source": "https://github.com/YannBouyeron/genopy/"
    },
    "release_url": "https://pypi.org/project/genopy/0.0.2/",
    "requires_dist": [
      "numpy",
      "biopython",
      "pandas",
      "matplotlib",
      "seaborn",
      "ipfshttpclient"
    ],
    "requires_python": ">=3.4",
    "summary": "Analyses genetiques et phylogenetiques",
    "version": "0.0.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5548059,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cc41b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81",
          "md5": "815e1c5cb6ea3b1be8df4e6ca26ee42e",
          "sha256": "7eafccef2038ec0a6bc0d736d3045bccaa2b098874a8d889521c22143392c045"
        },
        "downloads": -1,
        "filename": "genopy-0.0.2-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "815e1c5cb6ea3b1be8df4e6ca26ee42e",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": ">=3.4",
        "size": 32866,
        "upload_time": "2019-07-17T22:48:25",
        "upload_time_iso_8601": "2019-07-17T22:48:25.199217Z",
        "url": "https://files.pythonhosted.org/packages/cc/41/b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81/genopy-0.0.2-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "26f4574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba",
          "md5": "910a95d16c2fe612edccdbe22d224148",
          "sha256": "d736f4cae8230b560f1b0d038f9e24c77c3e316de97eb57bd5e40ee7b30d9d7b"
        },
        "downloads": -1,
        "filename": "genopy-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "910a95d16c2fe612edccdbe22d224148",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.4",
        "size": 42972,
        "upload_time": "2019-07-17T22:48:29",
        "upload_time_iso_8601": "2019-07-17T22:48:29.297738Z",
        "url": "https://files.pythonhosted.org/packages/26/f4/574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba/genopy-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "cc41b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81",
        "md5": "815e1c5cb6ea3b1be8df4e6ca26ee42e",
        "sha256": "7eafccef2038ec0a6bc0d736d3045bccaa2b098874a8d889521c22143392c045"
      },
      "downloads": -1,
      "filename": "genopy-0.0.2-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "815e1c5cb6ea3b1be8df4e6ca26ee42e",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": ">=3.4",
      "size": 32866,
      "upload_time": "2019-07-17T22:48:25",
      "upload_time_iso_8601": "2019-07-17T22:48:25.199217Z",
      "url": "https://files.pythonhosted.org/packages/cc/41/b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81/genopy-0.0.2-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "26f4574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba",
        "md5": "910a95d16c2fe612edccdbe22d224148",
        "sha256": "d736f4cae8230b560f1b0d038f9e24c77c3e316de97eb57bd5e40ee7b30d9d7b"
      },
      "downloads": -1,
      "filename": "genopy-0.0.2.tar.gz",
      "has_sig": false,
      "md5_digest": "910a95d16c2fe612edccdbe22d224148",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.4",
      "size": 42972,
      "upload_time": "2019-07-17T22:48:29",
      "upload_time_iso_8601": "2019-07-17T22:48:29.297738Z",
      "url": "https://files.pythonhosted.org/packages/26/f4/574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba/genopy-0.0.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}