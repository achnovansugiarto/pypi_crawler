{
  "info": {
    "author": "ktkalaru",
    "author_email": "ktkalaru+yamlfig@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Topic :: Software Development :: Libraries",
      "Topic :: Text Processing :: Markup"
    ],
    "description": "The **yamlfig** package provides developers with a framework for\ndefining rules that test and verify a config file's structure.  Those\nrules are captured in a parser object which can be applied to\nYAML-based config files to validate them.\n\nIn particular, this module enables a developer to:\n\n  - define which fields are required, optional, or will be assigned\n    default values if omitted;\n\n  - declare types for those fields (e.g., `str`, `int`, `date`, `dict`,\n    `list`, etc.);\n\n  - run arbitrary functions to test the values in each field (e.g.,\n    regular expressions matches or file-path-existence checks).\n\nAfter a config file is parsed, validated, and accepted, the returned\nobject can be used to access the field values with some confidence\nthat they exist, are of the expected type, and have whatever other\nproperties the rules established.  If a config file is rejected, an\nerror explaining the violated rule is raised.\n\nThis package was inspired by the similar capability that `argparse`\nbrought to command-line argument parsing.\n\n## Contents\n\n  * [Getting Started](#getting-started)\n    - [Installation](#installation)\n    - [Website and Repository](#website-and-repository)\n    - [Example Usage](#example-usage)\n    - [Walk-through](#walk-through)\n  * [Details](#details)\n    - [Basic Usage](#basic-usage)\n    - [Fields, Paths, and Structure](#fields-paths-and-structure)\n    - [Handling Parsed Objects](#handling-parsed-objects)  \n    - [Optional, Default, and No-Follow Rules](#optional-default-and-no-follow-rules)\n    - [Path Type Checking](#path-type-checking)\n    - [Rule Test Functions](#rule-test-functions)\n    - [Warnings and Caveats](#warnings-and-caveats)\n  * [Next Steps](#next-steps)\n    - [Future Work](#future-work)\n    - [Support and Collaboration](#support-and-collaboration)\n\n\n## Getting Started\n\n### Installation\n\n  `pip install yamlfig`\n\n### Website and Repository\n\nThe Python package is hosted on PyPI:\n\n  * https://pypi.com/project/yamlfig\n\nThe source code, documentation, and issue tracker is hosted on GitHub:\n\n  * https://github.com/ktkalaru/yamlfig\n\n### Example Usage\n\nAs an example for when a developer might use **yamlfig**, consider\ndeveloping a server that binds to an address and port.  When any of a\nlist of authorized users connects, it displays the server's name and\nthe contents of a file.  The following YAML file could act as the\nconfig file for such a server:\n\n  `$ cat > quickstart_server.yaml`\n\n```yaml\nname: Simple Single-File Server\nserver:\n  port: 81\nfile_path: 'quickstart_shared_file.txt'\nusers:\n- alice\n- bob\n- carol\n```\n\nThe following script uses the **yamlfig** package to construct a\nparser for this example server.  It instantiates a parser object and\nadds a set of rules that establish which fields and structures should\nbe in a server's config file.  Those rules establish what form those\nfields must take and what to do if they are missing.  It then invokes\nthis parser on a config file passed as a command line argument.  Where\nan actual server script would then use those values to spin up a\nserver, this script just demonstrates that the values can be accessed\nfrom the parsed object by printing them:\n\n  `$ cat > quickstart_server.py`\n\n```python\nfrom __future__ import print_function\nimport sys\nfrom yamlfig import YamlConfigParser, test\n\n# Construct a parser for the server config file\nconfp = YamlConfigParser()\nconfp.add_rule('name', path_type=str)\nconfp.add_rule('description', optional=True)\nconfp.add_rule('server.addr', path_type=str, default='127.0.0.1', test=test.is_ipv4_address)\nconfp.add_rule('server.port', path_type=int, test=test.is_interval(1, 65535, include_upper=True))\nconfp.add_rule('file_path', path_type=str, test=test.is_file_path('exists', 'isfile'))\nconfp.add_rule('users', path_type=list)\nconfp.add_rule('users.*', test=test.is_regex('^[a-z][a-z0-9]*$'))\n\n# Parse the config file\nconf = confp.parse_file(sys.argv[1])\n\n# Retrieve values from the conf object\nprint('conf.name = {0}'.format(repr(conf.name)))\nprint('conf.description = {0}'.format(repr(conf.description)))\nprint('conf.server.addr = {0}'.format(repr(conf.server.addr)))\nprint('conf.server.port = {0}'.format(repr(conf.server.port)))\nprint('conf.file_path = {0}'.format(repr(conf.file_path)))\nfor idx in conf.users:\n  print('conf.users[{0}] = {1}'.format(idx, repr(conf.users[idx])))\n```\n\nWhen we execute this server script on the above config file, it prints\nthe following values:\n\n  `$ python quickstart_server.py quickstart_server.yaml`\n\n```\nconf.name = 'Simple Single-File Server'\nconf.description = None\nconf.server.addr = '127.0.0.1'\nconf.server.port = 81\nconf.file_path = 'quickstart_shared_file.txt'\nconf.users[0] = 'alice'\nconf.users[1] = 'bob'\nconf.users[2] = 'carol'\n```\n\nNote how the fields and values printed came not only from the config\nfile but also from the rules.  Fields marked as optional or taking a\ndefault are present even though they were not in the config file.\nAlso note how the values have the type and form required by the rules\n(e.g., an integer within a given interval, a string in IPv4\ndotted-quad notation, and a list of usernames that all match a regular\nexpression).\n\n### Walk-through\n\nIn this example, the config file specified a ``name`` to display, a\n``port`` to listen on within a ``server`` block, a ``file_path`` to a\nfile to share, and the list of accounts of authorized ``users``.  The\nrules added to the `confp` parser ensure that those rules exist; they\nalso define rules for some paths not in the config file and configured\nas ``optional`` or taking a ``default`` value:\n\n  - a `description` field, if provided, would be displayed to the user, but\n    it is optional;\n\n  - an `addr` field within the `server` block that, if provided, would\n    set the binding IP address, but that takes a default of\n    `127.0.0.1` if omitted.\n\nAdditionally, the `confp` parser verifies that the values present in\nthe config file are suitable for our intended use.  Some of the values\nare type-checked or otherwise validated:\n\n   - the `addr` field, if provided, will be tested to confirm that it\n     has the format of an IPv4 address (i.e., a string in dotted-quad\n     notation);\n\n   - the `port` field will have its type checked to ensure it is an\n     `int`, and its value will be tested to confirm that in the range\n     1 to 65535;\n\n   - the `file_path` will be interpreted as a path to a filesystem\n     object, and that object will be tested to confirm it exists and\n     is a file (rather than a directory);\n\n   - all the account names in the `users` list will be tested against\n     a regular expression to confirm they match the format of accounts\n     on this particular system (i.e., they start with a lowercase\n     letters followed by zero or more digits or lowercase letters).\n\nOnce the `confp` parser is constructed and configured, its\n`parse_file` method is called on the config-file path given on the\ncommand line, and it returns a parsed `conf` object.  To demonstrate\nthat the `conf` object contains all the fields and values from the\nconfig file merged with the optional fields and defaults from the\nparser rules, it prints those fields and values.\n\nThe values in the `conf` object returned by `parse_file` have also\nbeen type-checked and tested.  Had the fields and values in the config\nfile not conformed to the rules of the `confp` parser, a `ParseError`\nexception would have been raised.  Some examples:\n\n  - If the `name` field were omitted:\n\n    `ParseError: quickstart_server.yaml: \"name\" is missing`\n\n  - If the `server` block contained a field called `the_ip_address`\n    that did not match any of the parser's rules:\n\n    `ParseError: quickstart_server.yaml: \"server.the_ip_address\"\n    unexpected by parser`\n\n  - If the `port` field of the `server` block contained the string\n    `\"eighty-one\"` rather than the integer `81`:\n\n    `ParseError: quickstart_server.yaml: \"server.port\" has type str\n    not type int`\n\n  - If the `addr` field were present in the server block and had\n    the value `452.34.256.193`:\n\n    `ParseError: quickstart_server.yaml: \"server.addr\" failed test:\n    1st octet of \"452.34.256.193\" exceeds 255`\n\n  - If the `file_path` field had been the path to an existing\n    directory named `some_directory` instead of the path to an\n    existing file:\n\n    `ParseError: quickstart_server.yaml: \"file_path\" failed test:\n    \"some_directory\" is not a file`\n\n  - If the 3rd value of the `users` list been the display name `Carol\n    C.` instead of the username `carol` (and noting zero-based\n    indexing):\n\n    `ParseError: quickstart_server.yaml: \"users.2\" failed test: \"Carol\n    C.\" does not match /^[a-z][a-z0-9]*$/`\n\nThe presence of such errors in the config file would have stopped\nexecution and provided a relatively informative explanation of which\nrule failed and why.  Because none of these errors were raised, a\ndeveloper has some assurance that the structure and values in the\n`conf` object meets their expectations.\n\nJust as important as what happened in this example above is *what\ndidn't happen*.  When the ``read_file`` function returned the `conf`\nobject, it didn't raise a `ParseError` exception.  Since it executed\nsuccessfully, we know that all the parser assertions hold about which\nfields must exist and what formats they take; the remaining code does\nnot need to perform such checks and error handling itself.\n\n\n## Details\n\nWhat **yamlfig** provides beyond a standard YAML parser is validation,\nspecifically verification that a config file conforms to the various\nrules established for it.  In this section, we introduce and describe\nthese rules, and the various constraints that can be placed on\na config file's structure and values.\n\n### Basic Usage\n\nThe typical steps when using **yamlfig** are:\n\n  1. instantiate a `YamlConfigParser` object, which we usually call\n     `confp`,\n\n  2. configure it by using `add_rule` to add rules for each field we\n     intend to control through a config file,\n\n  3. invoke `parse_file` on a config file which either raises a\n     `ParseError` or returns a `YamlConfig` object, usually called\n     `conf`, and\n\n  4. use that `YamlConfig` in subsequent code, confident that its\n     structure and values have already been validated.\n\nThe following script illustrates this typical pattern by using\n**yamlfig**.  For the sake of the example, let's say we need a config\nfile to drive how often a loop is run, which of two functions is\ncalled by the loop, and what parameter is passed to that function:\n\n  `$ cat basic_usage.py`\n\n```python\nimport sys\n\nfrom yamlfig import YamlConfigParser\n\n# 1. Instantiate a YamlConfigParser object (confp)\nconfp = YamlConfigParser()\n\n# 2. Configure the parser by adding rules for each field\nconfp.add_rule('loop_count')\nconfp.add_rule('do_special_function')\nconfp.add_rule('function_parameter')\n\n# 3. Invoke the parser on a config file (provided as an argument)\nconf = confp.parse_file(sys.argv[1])\n\n# 4. Use the YamlConfig object in subsequent code\nfor loop_index in range(conf.loop_count):\n  if conf.do_special_function:\n    special_function(conf.function_parameter)\n  else:\n    regular_function(conf.function_parameter)\n```\n\nOne config file would cause the script to produce one behavior:\n\n  `$ cat basic_config_1.yaml`\n\n```yaml\nloop_count: 7\ndo_special_function: yes\nfunction_parameter: \"a meerkat\"\n```\n\nRunning the script on `basic_config_1.yaml` would cause\n`special_function` to be invoked 7 times, each with the parameter `\"a\nmeerkat\"`.\n\nAnother config file would cause the script to produce a different behavior:\n\n  `$ cat basic_config_2.yaml`\n\n```yaml\nloop_count: 3\ndo_special_function: no\nfunction_parameter: a pony\n```\n\nRunning the script on `basic_config_2.yaml` would cause\n`regular_function` to be invoked 3 times, each with the parameter `\"a\npony\"`.\n\nJust as important is understanding the behavior of the script on a bad\nconfig file.  The following config file is missing one of the three\nrequired fields:\n\n  `$ cat basic_config_bad.yaml`\n\n```yaml\nloop_count: 3\nfunction_parameter: 'a unicorn'\n```\n\nRunning the script on `basic_config_bad.yaml` exits unsuccessfully and\nprints an exception:\n\n```\nTraceback (most recent call last):\n  File \"basic_usage.py\", line 22, in <module>\n    conf = confp.parse_file(sys.argv[1])\n  [...]\nyamlfig.base.ParseError: basic_config_bad.yaml: \"do_special_function\" is missing\n```\n\nThe error is raised within the `confp.parse_file` function.  All\nverification and validation occurs as part of that function called in\nstep 3 of the pattern, so if it return successfully, the `YamlConfig`\nobject conforms with the parser rules.\n\n### Fields, Paths, and Structure\n\nThe fundamental thing that **yamlfig** rules do is establish which\nfields should be in a config file and which fields should not.\n\n#### Test that a field exists\n\n```python\nconfp.add_rule('dirname')\n```\n\nThe first argument to `add_rule` is the `rule_path`.  Every rule added\nto a `confp` object must have one, and&mdash;unless additional\nmodifiers make the field optional or take a default value&mdash;it is\nan existence requirement for the field.  Given the rule above, any\nconfig file must contain a line such as:\n\n```yaml\ndirname: /var/share/SomeApp/SharedDir\n```\n\nA config file without a `dirname` field would generate a parse error.\n\n#### Test that a path exists\n\nPart of YAML's descriptive power comes from its ability to encode\nnested structures, like maps and lists, and **yamlfig** rules can\ndescribe constraints on that structure:\n\n```python\nconfp.add_rule('server.storage.dirname')\n```\n\nRules use the `'.'` character\nto delimit fields within a nested structure.  The rule above expects\nthere to be a `server` block, within which is contained a `storage`\nblock, within which there is a `dirname` field.  The following config\nwould satisfy such a rule:\n\n```yaml\nserver:\n  storage:\n    dirname: /var/share/SomeApp/SharedDir\n```\n\nSuch a rule path implicitly includes existence requirements for\n`server` and `server.storage`.  The existence of those paths would not\nneed to be explicitly required through separate rules, unless we\nwanted to modify them (e.g., by making them optional or take defaults\nas described in a [later\nsection](#optional-default-and-no-follow-rules).\n\n#### Test that a block has a specific substructure\n\nIn this example, we need a config file to describe how a server's\nlocal storage cache is configured (i.e., where it is on the\nfilesystem, how big it can grow, and what permissions the cache files\nhave).\n\n```python\nconfp.add_rule('server.storage.dirname')\nconfp.add_rule('server.storage.maxsize')\nconfp.add_rule('server.storage.umask')\n```\n\nIn combination, these three rules describe the structure that the\n`server.storage` block must have (i.e., three fields with the names\n`dirname`, `maxsize`, and `umask`).\n\nThe following config file would be accepted by this parser:\n\n```yaml\nserver:\n  storage:\n    dirname: /var/share/SomeApp/SharedDir\n    maxsize: 10GB\n    umask: 0644\n```\n\n#### Test that a field or path *does not* exist\n\nAny field or path for which there is no matching rule will raise a\nparse error.  In a sense, the **yamlfig** field-existence validation\nis deny-by-default.  We do not need to do anything specific to assert\nthat a field does not exist; just don't add an existence requirement.\n\n#### Test that a block contains fields without specifying which fields by using wildcards\n\nA rule path can contain wildcards.  For the sake of this example, we\nneed a config file to specify upload paths for each of one or more\nusers.  A `server.upload_paths` block will map from username to their\ncorresponding upload directory, as in the following example:\n\n```yaml\nserver:\n  upload_paths:\n    alice:   /home/alice/uploads\n    bob:     /home/bob/public\n```\n\nSince we do not want to hardcode the usernames in the parser, we can\nuse a wildcard rule to accept one or more fields within a block\nwithout specifying the specific field names:\n\n```python\nconfp.add_rule('server.upload_paths.*')\n```\n\nSuch a rule asserts that the `server.upload_paths` block contains\nnon-empty substructure (i.e., it is a block), but not the specific\nfield names within the substructure.  In the above example config\nfile, the wildcard woudl match both `alice` and `bob`, even though\nneither are explicitly listed field paths.\n\nA new user could be added with their own upload path, and the same\nparser would accept the config file:\n\n```yaml\nserver:\n  upload_paths:\n    alice:   /home/alice/uploads\n    bob:     /home/bob/public\n    carol:   /home/carol/tmp\n```\n\nNote that a wildcard rule must match *one or more* fields, not zero.\nIf the `server.upload_paths` block were empty, the config file would\nraise an error: `\"server.upload_paths\" must contain at least one\nfield`.  A [later\nsegment](#default-block-and-optional-wildcarded-path-recognize-zero-or-more)\ndescribes how the `optional` and `default` flags can be used with\nwildcards to implement a zero-or-more match.\n\nAlso note that *partial* wildcard matches are not currently supported.\nA path like `server.upload_paths.user-*` intending to accept fields\nlike `user-alice` and `user-bob` would instead raise an error.  As\ndescribed in a [different later\nsegment](#writing-our-own-test-functions), one way to implement such a\ncheck would be to write a function that tests every field within a\nblock against a regular expression, and then specify that function as\na test function for the `server.upload_paths` block.\n\n#### Wildcard fields can have substructure and rules can enforce matching substructure\n\nFor the sake of this example, a server hosts one or more projects,\neach of which has a directory of static web pages associated with it,\nand a backend database.  Our configuration file maps from one or more\narbitrary project names (e.g., `ProjectX` and `meerkat_works`) to\nblocks that contain precisely three datapoints (1) a path to a\ndirectory of webpages, (2) a path or URL to a database, and (3) the\ntype of the database (e.g., `sqlite`, `mysql`, or `mongodb`).\n\nThe following config file gives an example of this structure:\n\n```yaml\nprojects:\n  ProjectX:\n    webpath: /home/alice/projx/html\n    dbpath:  /home/alice/projx/project.db\n    dbtype: sqlite\n  meerkat_works:\n    webpath: /home/bob/public/meerkat/www\n    dbpath:  mongodb://192.168.1.200:27017\n    dbtype: mongodb\n```\n\nWith **yamlfig**, we can specify wildcards on paths while still\nrequiring that any fields matching the wildcard have a required,\nfixed-field substructure.  The following parser will accept one or\nmore blocks, each corresponding to a project name, but every one must\nhave the three required fields:\n\n```python\nconfp.add_rule('projects.*.webpath')\nconfp.add_rule('projects.*.dbpath')\nconfp.add_rule('projects.*.dbtype')\n```\n\nThese rules implicitly assert that the `projects` block exists and\ncontains one or more sub-blocks, with no restriction on their field\nnames.  The rules explicitly assert that each one of those sub-blocks\nmust contain exactly three fields: `webpath`, `dbpath`, and `dbtype`.\nThis parser would accept the example config file above.\n\nIf a project sub-block were missing one of the three required fields\nor had an extra field, an error would have been raised.\n\n\n#### Wildcards are also useful for accepting lists of values\n\nYAML's nested structure supports not only the mappings described above\nbut also lists.  Technically, YAML offers a whole lot of different\nnesting types (e.g., `omap`, `pairs`, etc.) but our python parser\nrepresents them all as either `dict` or `list` objects, with mappings\nrepresented as `dict` objects and lists as `lists`.  To most easily\nand succinctly accommodate both mappings and lists, **yamlfig**\neffectively treats lists as a very specific kind of mapping, where\neach field is a list index and each value is the item in the list.\n\nConsider a config file where a `users` block contains a list of one or\nmore authorized users:\n\n```yaml\nusers:\n- alice\n- bob\n- carol\n```\n\nThe following rule would accept such a `users` block:\n\n```python\nconfp.add_rule('users.*')\n```\n\nNote that the wildcard rule by itself just ensure that there are\nsubfields, not that they take the form of a list as opposed to a\nmapping.  That same parser would accept a config file with a mapping:\n\n```yaml\nusers:\n  alice:  Alice A.\n  bob:    Bob B.\n  carol:  Carol C.\n```\n\nThese two config files&mdash;the list version and the mapping\nversion&mdash;have very different structures, and a program would\nlikely be expecting one and not the other.  To ensure that a rule with\na wildcard matches only a list (and not a map) or only a map (and not\na list), we would need to use type checking, as described in a [later\nsegment](#ensure-that-a-path-contains-a-map-or-a-list), to assert that\nthe type of the block is either `list` or `dict` respectively.\n\nAlso note that when accessing list values parsed into a `conf` object,\nwe need to be aware of some difference in their behavior from that of\na standard python list, as described in the [Handling Parsed\nObjects](#handling-parsed-objects) section.\n\n#### Test that a list has exactly *n* elements\n\nWhile not a typical occurrence, parser rules can be configured to\nensure that a list has a specific number of elements.  The following\nrules would accept a list of length 2 by explicitly requiring fields\nnamed `0` and `1`:\n\n```python\nconfp.add_rule('network.route.0')\nconfp.add_rule('network.route.1')\n```\n\nFor the sake of the example, perhaps the application must have two\nnetwork routes, a primary and a secondary.\n\nAs noted above, **yamlfig** treats lists as mappings from numeric\nfields to values, so the parser would accept the following config:\n\n```yaml\nnetwork:\n  route:\n  - 192.0.2.1\n  - 198.51.100.1\n```\n\nAs a side note, the same two rules would accept a config in which the\n`route` block contained a mapping from numeric string fields (i.e.,\n`\"0\"` and `\"1\"`) to the two IPv4 addresses.  As we keep stressing, the\nrules simply treat lists as mappings from numeric fields to the list\nelements.  To differentiate a list from a mapping, we would need to\nuse type checking, as described in a [later\nsegment](#ensure-that-a-path-contains-a-map-or-a-list)\n\n\n### Handling Parsed Objects\n\nAs described in the [Basic Usage](#basic-usage) section, to parse a\nconfig file, a parser's `parse_file` method would be called with the\nname of the file:\n\n```python\nconf = confp.parse_file(conffile)\n```\n\nAssuming the parsing and validation succeeds, the `conf` object would\nhave type `YamlConfig` or `YamlConfigList`, depending on whether the\nroot-level YAML object in the config file is a mapping or a list.\nTypically, a YAML-formatted config file will have a mapping as its\nroot-level structure, and so we will consider that common case first.\n\nThroughout this section, assume that we have successfully parsed the\nfollowing config file into a `YamlConfig` object named `conf`:\n\n```yaml\ndirname: /var/share/SomeApp/SharedDir\nserver:\n  projects:\n    ProjectX:\n      webpath: /home/alice/projx/html\n      dbpath:  /home/alice/projx/project.db\n      dbtype:  sqlite\n    meerkat_works:\n      webpath: /home/bob/public/meerkat/www\n      dbpath:  mongodb://192.168.1.200:27017\n      dbtype:  mongodb\nusers:\n- alice\n- bob\n- carol\n- dave\n```\n\nWhile the focus of this section is on accessing the `conf` object\nafter `confp` successfully parses and validates the config file, for\nthe sake of completeness, the following rules would configure a\nparser that accepts this file:\n\n```python\nconfp = YamlConfigParser()\nconfp.add_rule('dirname')\nconfp.add_rule('server.projects.*.webpath')\nconfp.add_rule('server.projects.*.dbpath')\nconfp.add_rule('server.projects.*.dbtype')\nconfp.add_rule('users.*')\n```\n\n#### Fields and paths can be accessed as attributes\n\nFields in a config file can be accessed as attributes of the\n`YamlConfig` object.\n\n```python\nconf.dirname                # '/var/share/SomeApp/SharedDir'\n```\n\nIf an attribute corresponds to a block in a config file, it will\nreturn that block as a `YamlConfig` or `YamlConfigList` object.\n\n```python\nconf.server                 # <YamlConfig object at 0x[...]>\nconf.users                  # <YamlConfigList object at 0x[...]>\n```\n\nAs such, attributes can be strung together in a sequence:\n\n```python\nconf.server.projects.ProjectX.webpath      # '/home/alice/projx/html'\nconf.server.projects.ProjectX.dbpath       # '/home/alice/projx/project.db'\nconf.server.projects.ProjectX.dbtype       # 'sqlite'\n```\n\n```python\nconf.server.projects.meerkat_works.dbtype  # 'mongodb'\n```\n\nNote that to be accessed as an attribute, a field must be a valid\nPython attribute (e.g., must be a string, cannot start with a number,\netc.).\n\n#### Fields and paths can be accessed via index lookups\n\nA values stored in a `YamlConfig` object can also be accessed via\nindex lookup.\n\n```python\nconf.server.projects['ProjectX'].dbtype               # 'sqlite'\n```\n\n```python\nproj = 'ProjectX'\nconf.server.projects[proj].dbtype                     # 'sqlite'\n````\n\n````python\nconf['server']['projects']['ProjectX']['dbtype']      # 'sqlite'\n````\n\n````python\npath = ['server', 'projects', 'ProjectX', 'dbtype']\nfunctools.reduce(lambda d, idx: d[idx], path, conf)   # 'sqlite'\n````\n\n#### List values can be accessed via index lookups\n\nIndex lookups must be used to access the elements of a `YamlConfigList`\nsince attributes cannot be numbers.\n\n```python\nconf.users[0]             # 'alice'\nconf.users[1]             # 'bob'\nconf.users[2]             # 'carol'\nconf.users[3]             # 'carol'\n```\n\n```python\nconf.users[-1]            # 'dave'\nconf.users[-2]            # 'carol'\n```\n\nIn a departure from standard python lists, a `YamlConfigList` object\nwill translate to or from a string representation of an index as\nneeded.\n\n```python\nconf.users[\"1\"]           # 'bob'\nconf.users['-2']          # 'carol'\n```\n\nOnce again, this is to allow&mdash;as much as possible&mdash;lists to\nbe treated like mappings from the list indexes to the list elements.\n\n#### Length checks can be used to determine the number of fields\n\nAs with `dict` and `list` objects, we can see how many elements are\nin a `YamlConfig` and `YamlConfigList` object by querying their\nlength.\n\n```python\nlen(conf)                                  # 3\nlen(conf.server)                           # 1\nlen(conf.server.projects)                  # 2\nlen(conf.server.projects.ProjectX)         # 3\nlen(conf.server.projects.meerkat_works)    # 3\nlen(conf.users)                            # 4\n```\n\n#### Iterators return field names for `YamlConfig` objects\n\nIterating on a `YamlConfig` object will return the field names\ncontained within the block, like what we would get from iterating on\na `dict` object:\n\n```python\nlist(conf)                                 # ['dirname', 'server', 'users']\nlist(conf.server)                          # ['projects']\nlist(conf.server.projects)                 # ['ProjectX', 'meerkat_works']\nlist(conf.server.projects.ProjectX)        # ['webpath', 'dbpath', 'dbtype']\nlist(conf.server.projects.meerkat_works)   # ['webpath', 'dbpath', 'dbtype']\n```\n\nNote that the order in which `YamlConfig` fields are returned is **the\norder the rules were added to the parser**, not the order in which the\nrules appear in the config file.  When a single parser rule matches\nmultiple fields (i.e., a wildcard rule), the fields are returned in\narbitrary order.  Note however, that around Python 3.6 and Python 3.7,\nthey have started being returned in the order they appear in the\nconfig file, likely due to `dict` objects beginning to return keys in\nthe order they were inserted.\n\n#### Iterators return list indexes _not values_ for `YamlConfigList` objects\n\nIterating on a `YamlConfigList` object is **significantly different\nfrom iterating on a python list**.  In particular, it will return the\nlist of index values as strings, **not the actual list values**:\n\n```python\nlist(conf.users)                            # ['0','1','2','3']\n```\n\nAs noted previously, a `YamlConfigList` treats lists less like lists\nper-se and more like mappings from zero-based, sequential, numeric\nindexes to values.  As such, its iterator returns field names that can\nbe used as indexes to look up values, not the values themselves.\n\nThis behavior is likely unexpected at first and arguably\ncontroversial, but was chosen for greater overall simplicity.  A lot\nof code can iterate over fields, descend into blocks, and so on much\nmore simply, when it does not need to treat `YamlConfigList` objects\nas a special case, separate from `YamlConfig` objects.\n\nTo get the values rather than the indexes, we recommend list\ncomprehension:\n\n```python\n[conf.users[idx] for idx in conf.users]     # ['alice', 'bob', 'carol', 'dave']\n```\n\nUnlike the fields of a `YamlConfig`, indexes of a `YamlConfigList`\nwill be returned in a specific order: sequential and increasing from\na base of zero.\n\n### Optional, Default, and No-Follow Rules\n\nHaving examined how to configure a parser to require certain fields\nand structure, and how values will be represented in the parsed\nobject, we introduce ways to make rules optional, take default values,\nand have the parser ignore their substructure.\n\n#### A field flagged as optional can be omitted\n\nWhen instantiating and adding a new rule, we can specify `optional=True`:\n\n```python\nconfp.add_rule('name')\nconfp.add_rule('description', optional=True)\n```\n\nThe above parser would require a `name` field but not a description\nfield, as in the following config file:\n\n```yaml\nname: Simple Single-File Server\n```\n\nThe parser will accept the file, create a `description` field, and assign\nit the value `None`.\n\n```python\nconf.name                           # 'Simple Single-File Server'\nconf.description                    # None\n```\n\nA program acting on the `conf` object can assume that the optional\nfield exists, but it will have the value `None` if it was not present\nin the config file (or if it was explicitly assigned the value `None`\nsince the two are treated as equivalent).\n\n#### Optional fields can have required substructure\n\nA rule representing a nested block can be marked optional and still\nhave substructure with required fields.  For the sake of example, a\nserver requires three files in order to encrypt its communications\nusing SSL.  If a `server.ssl` block is present in the config file,\nthose files must be provided, and the server will use SSL.  If the\nblock is omitted, the config file should still be accepted, but the\nserver will fall back to unencrypted communications.\n\nThe following parser is configured with an optional `server.ssl` block\nthat, if it exists, must have three specific fields:\n\n```python\nconfp.add_rule('server.addr')\nconfp.add_rule('server.port')\nconfp.add_rule('server.ssl', optional=True)\nconfp.add_rule('server.ssl.key')\nconfp.add_rule('server.ssl.cert')\nconfp.add_rule('server.ssl.chain')\n```\n\nIn the following config, the optional `ssl` block and its substructure\nhave been omitted:\n\n```yaml\nserver:\n  addr: 127.0.0.1\n  port: 81\n```\n\nSince the block was not included, the `ssl` field is present in the\n`conf` object but assigned a value of None.\n\n```python\nconf.server.ssl           # None\n```\n\nIn the following config, the optional `ssl` block and its substructure\nhave been included:\n\n```yaml\nserver:\n  addr: 127.0.0.1\n  port: 81\n  ssl:\n    key: /etc/ssl/privkey.pem\n    cert: /etc/ssl/cert.pem\n    chain: /etc/ssl/full_chain.pem\n```\n\nSince the block was included, its substructure was parsed and\nvalidated.  The `conf` object includes the block and its substructure.\n\n```python\nconf.server.ssl               # <YamlConfig object at 0x[...]>\nconf.server.ssl.key           # '/etc/ssl/privkey.pem'\nconf.server.ssl.cert          # '/etc/ssl/cert.pem'\nconf.server.ssl.chain         # '/etc/ssl/full_chain.pem'\n```\n\nThe existence requirements on the substructure will only be checked\nand enforced if the optional field is present.  In the following\nconfig, the optional `ssl` block is present, but it is missing one of\nits required fields:\n\n```yaml\nserver:\n  addr: 127.0.0.1\n  port: 81\n  ssl:\n    key: /etc/ssl/privkey.pem\n    # cert: /etc/ssl/cert.pem\n    chain: /etc/ssl/full_chain.pem\n```\n\nWhen `parse_file` is invoked on this config file, a `ParseError` is\nraised: `\"server.ssl.cert\" is missing`.\n\n\n#### A default field will take a default value if omitted\n\nWhen instantiating and adding a new rule, we can specify a `default`.\n\n```python\nconfp.add_rule('server.addr', default='127.0.0.1')\nconfp.add_rule('server.port')\n```\n\nIn the following config, the default rule has been omitted:\n\n```yaml\nserver:\n  port: 81\n```\n\nThe parser will accept the file, create not only a `port` field but\nalso an `addr` field within the `server` block, and since the `addr`\nfield does not appear in the config, it will assign the default value\n(`127.0.0.1`) to the field.\n\n```python\nconf.server.port            # 81\nconf.server.addr            # '127.0.0.1'\n```\n\n#### Default substructure must still undergo validation\n\nThe following config rule will provide an entire server block if none\nis specified in the config file:\n\n```python\nconfp.add_rule('server', default={'addr': '127.0.0.1', port: 81})\n```\n\nProviding such structure is possible, but the above rule would\ngenerate a `ParseError` unless it was accompanied by rules to accept\nthe `server.addr` and `server.port` paths.  With only the rule above,\na config file that triggered the default would raise a `ParseError`:\n `\"server.addr\" unexpected by parser`.\n\nWe need to add rules to prepare the parser for the substructure, as\nin the following parser that accompanies the default rule with two\nmore:\n\n```python\nconfp.add_rule('server', default={'addr': '127.0.0.1', port: 81})\nconfp.add_rule('server.addr')\nconfp.add_rule('server.port')\n```\n\nWith these two additional rules, a config file will be accepted with\nthe default values if `server` is omitted, and it will require those\ntwo values be present if a `server` block is present.  In both cases,\nonce parsing is successful, the program can assume that\n`conf.server.addr` and `conf.server.port` exist.\n\nIf we really did not want to validate the fields of the default\nsubstructure, rather than adding rules for the fields, we could mark\nthe block as no-follow as described in a [later\nsegment](#a-path-marked-no-follow-can-also-be-optional-or-take-defaults-but-not-both).\n\n#### Fields cannot both be optional and take a default\n\nThe `optional` and `default` parameters to `add_rule` are mutually\nexclusive; if both are specified, an error will be raised.\nEssentially, `optional=True` acts like a default rule for which the\ndefault value is `None`.  In fact, setting `optional=True` is the only\nway for a missing field to be assigned a value of `None`, since\nsetting `default=None` is a no-op.  A value of `None` for `default`\nactually signals that no default has been specified, so the field is\nstill required.\n\nIt is unclear what the semantics would even be for an optional rule\nthat also takes a default, so the pairing is just not allowed.\n\n#### A default path *can* have optional subpaths and vice versa\n\nIn the following parser configuration, the `server` block takes a default,\nwhile the `server.ssl` block is optional:\n\n```python\nconfp.add_rule('server', default={'addr': '127.0.0.1', 'port': 81})\nconfp.add_rule('server.addr')\nconfp.add_rule('server.port')\nconfp.add_rule('server.ssl', optional=True)\nconfp.add_rule('server.ssl.key')\nconfp.add_rule('server.ssl.cert')\nconfp.add_rule('server.ssl.chain')\n```\n\nWe can see what will happen in the following config, where the\n`server` field is omitted.  Note that this config file uses the\nconvention that leaving a field value blank assigns it a value of\n`None` (or `null` in YAML terms), and that causes it to be treated as\nomitted by **yamlfig**:\n\n```yaml\nserver:\n```\n\nThe parser above will accept this config file.  Since the `server`\nblock has been omitted, it will substitute its default value.  Since\nthe `server.addr` and `server.port` fields are provided by the\ndefault, they will pass the rules requiring their existence.  The\n`server.ssl` field has not been provided by the default, but since\nit is flagged as optional, the field will be created and assigned a\nvalue of None:\n\n```python\nconf.server                  # <YamlConfig object at 0x[...]>\nconf.server.addr             # '127.0.0.1'\nconf.server.port             # 81\nconf.server.ssl              # None\n```\n\nThe reverse is also true.  Default fields can be included in the\nsubstructure of an optional field, and they will take the default\nvalues if they are omitted from the config but the optional block is\nincluded.  Other combinations work as well (e.g., default fields\nwithin default blocks; optional fields within optional blocks;\noptional fields within default blocks within optional blocks; etc.).\n\nIf it helps, we can think of optional and default flags being handled\nfrom the top down in a cascade.  If a parent field is omitted, it will\nbe checked for `optional` or `default` flags first.  If it is\noptional, the field will be created with a `None` value and the\nparsing will move on.  If it takes a default, the field will be\ncreated with the default value or substructure, and the parser will\ndescend into that substructure, checking those fields and values before\nmoving on.  The parser will only encounter child fields and values\nafter the parent's optional or default nature has been handled.\n\n\n#### Default block and optional wildcarded path recognize *zero-or-more*\n\nAs noted earlier, a wildcard rule path requires that a config file\nhave one or more fields matching the path.  By default, a wildcard\nrule will raise an error if there are no fields matching it, but there\nare times when we want to accept zero-or-more matches.\n\nThe following rules configure a parser for cases where we want a block\nwith zero or more subfields:\n\n```python\nconfp.add_rule('server.upload_paths', default={})\nconfp.add_rule('server.upload_paths.*', optional=True)\n```\n\nThe `optional` flag on the wildcard path will cause the parser to\nallow the `upload_paths` block to contain no fields.  The default on\nthe `upload_paths` field will create that empty block if the field is\nnull.  The following config file would be accepted by this parser:\n\n```yaml\nserver:\n  upload_paths:\n```\n\nBy leaving `upload_paths` null, we signal that it has been explicitly\nomitted, so it is given its default value (i.e., an empty mapping).\nThen, since the wildcard path for the fields within `upload_paths` is\nflagged as optional, that rule will be satisfied with zero fields.\nThe `YamlConfig` object would exist but contain zero fields:\n\n```python\nconf.server.upload_paths         # <YamlConfig object at 0x[...]>\nlen(conf.server.upload_paths)    # 0\n```\n\nFor completeness sake, the same parser would also accept a config\nfile with one or more fields within `upload_paths`:\n\n```yaml\nserver:\n  upload_paths:\n    alice:   /home/alice/uploads\n    bob:     /home/bob/public\n```\n\nIn this case, the `YamlConfig` object would contain two fields:\n\n```python\nconf.server.upload_paths         # <YamlConfig object at 0x[...]>\nlen(conf.server.upload_paths)    # 2\nset(conf.server.upload_paths)    # {'alice','bob'}\n```\n\nThis pattern&mdash;with the block taking an empty substructure as the\ndefault and the wildcard rule flagged as optional&mdash;is the\nrecommended way to implement a parser that accepts zero-or-more fields\nor list elements.\n\n\n#### A path marked no-follow can have any and arbitrary substructure\n\nIn some cases, we want to stop a **yamlfig** parser from attempting to\nvalidate a substructure, either because the program is designed to\nhandle whatever is beneath that value or, more often the case, the\nactual structure follows a complicated syntax, but the program will be\npassing that structure to another package, and it has its own\nfunctions for validating the input.\n\nFor example, consider an example where a program needs to pull back a\nlist of projects from a MongoDB database.  The following config file\nprovides values that might be needed to (1) access the database, (2)\nreference the specific collection within the database, and (3) filter\nthe results to only a subset of all projects, using a MongoDB query:\n\n```yaml\nmongodburl: mongodb://192.168.1.200:27017/\ncollection: projects\nfilterquery: { 'is_private': { '$ne': true } }\n```\n\nAll three fields must exist, but the `filterquery` field contains a\nMongoDB query *as* its substructure.  MongoDB queries can be expressed\nas JSON objects, and YAML syntax is a superset of JSON, so the query\ncan be expressed as JSON/YAML right within the YAML config file.\n\nBy default, the **yamlfig** parser will try to validate that object\n(i.e., check whether the paths `filterquery.is_private` and\n`filterquery.is_private['$ne']` are expected by the parser).\nConfiguring a `confp` parser to correctly validate the syntax of an\narbitrary MongoDB query is impossible and an unnecessary waste of\ncomplexity.  As soon as the script hands the query off to MongoDB, it\nis going to do a much better job of validating it.\n\nThe following parser is configured to accept the above config file:\n\n```python\nconfp.add_rule('mongodburl')\nconfp.add_rule('collection')\nconfp.add_rule('filterquery', nofollow=True)\n```\n\nThis parser will require that a `filterquery` field exists along with\nthe `mongodburl` and `collection` fields, but the `nofollow` argument\nensures that it will not descend into the substructure within the\n`filterquery` field.  No additional validation of that substructure\nwill take place.\n\nThe value at `conf.filterquery` is a standard python `dict` which can be\npassed to a MongoDB `find` command as-is.\n\n```python\nconf.filterquery        # {'is_private': {'$ne': True}}\n```\n\nAs an aside, note that until this example, we have been using YAML\nblock-structure syntax rather than JSON syntax, but there is no\ndifference between the two formats once parsed.  The config file\nabove could have been written equivalently as follows:\n\n```yaml\nmongodburl: mongodb://192.168.1.200:27017\ncollection: projects\nfilterquery:\n  is_private:\n    \"$ne\": true\n```\n\nA distinct alternative would have been to encode the MongoDB query\nobject as a string, as in the following line:\n\n```yaml\nfilterquery: \"{ is_private: { $ne: { true }}}\"`\n```\n\nWhile a viable alternative, there are benefits to *not* doing so.  By\nstoring the query object as a query object, we actually do perform\nsome syntax checking at parse time, before handing it off to MongoDB.\nWe ensure that the brackets are balanced and the JSON is legal.  We\nalso get whatever syntax highlighting our editor provides to\nYAML/JSON.  A string would simply be treated as a string by the\n**yamlfig** parser, and we would eventually have to invoke a JSON\nparser ourselves.\n\n\n#### A path marked no-follow can also be optional or take defaults (but not both)\n\nThe `nofollow` parameter really affects the handling of the value not\nthe field, whereas `optional` and `default` are parameters that affect\nthe handling of the field (i.e., what to do if it is omitted).\n\nIf a field is omitted from a config, and if its path is marked in the\nparser as both optional and no-follow, the field will be created and\nassigned the value `None`.  If it were not optional, an error would be\nraised.  Since the value `None` is terminal and has no substructure,\nbeing marked no-follow has little effect.\n\nIf a field is omitted from a config, and if its path is marked in the\nparser as no-follow and taking a default, the field will be created\nand the default value will be substituted.  If the default value has\nsubstructure (i.e., it is a `dict` or a `list`), then the no-follow\nmarking would apply and no additional validation would be performed by\nthe parser on that substructure.\n\n\n#### A path marked no-follow cannot have any subrules\n\nA parser configuration such as the following would raise an error:\n\n```python\nconfp.add_rule('filterquery', nofollow=True)\nconfp.add_rule('filterquery.is_private')\n```\n\nThe no-follow condition on a path means that no rules on descendant\npaths will ever be checked or validated, so we prevent such rules from\nbeing added.  For this example, a `ValueError` would be raised\nexplaining that `\"filterquery.is_private\" is a descendant of a\nno-follow rule`.\n\n### Path Type Checking\n\nWithin the **yamlfig** parser, after establishing that every required\nfield exists, that every optional or default field has been handled,\nand that there are no unexpected fields, the parser's next step is to\ncheck that any type assertions on the values for each field are\nsatisfied.\n\n#### Ensure that a field is a str (or int or bool or float, etc.)\n\nWhen instantiating and adding a new rule, we can specify a `path_type`.\n\n```python\nconfp.add_rule('server.addr', path_type=str)\nconfp.add_rule('server.port', path_type=int)\n```\n\nIn addition to requiring that the `server` block contains an `addr`\nfield and a `port` field, these rules will further check that the\nvalues are instances of the given `path_type` types.\n\nThe following config has a null in the `addr` field:\n\n```yaml\nserver:\n  addr: ~\n  port: 81\n```\n\nThe above parser would raise an error: `\"server.addr\" has type\nNoneType not type str`.\n\nLikewise, the following config has a string in the port field:\n\n```yaml\nserver:\n  addr: 127.0.0.1\n  port: \"81\"\n```\n\nThe above parser would raise an error: `\"server.port\" has type\nstr not type int`.\n\nThe type that a value takes is determined by the underlying raw-YAML\nparser that **yamlfig** uses.  By defalt, we use `SafeLoader` within\n[`PyYAML`](https://github.com/yaml/pyyaml).  It recognizes the\nfollowing types:\n\n  * `bool`\n  * `str`\n  * `unicode` (in Python 2, when the value contains non-ASCII characters)\n  * `int`\n  * `long` (in Python 2, when the value is larger than `sys.maxint`)\n  * `float`\n  * `date` (in the `datetime` package)\n  * `datetime` (in the `datetime` package)\n  * `dict` (for mappings and mapping-like tags)\n  * `list` (for lists and list-like tags)\n  * `NoneType` (i.e., `path_type=type(None)`)\n\nAny of those types could arise in a config and be accepted or rejected\nby a `path_type` argument.  Additionally, it is possible to replace\n`SafeLoader` with a different YAML parsing class, in which case the\nset of types would depend on what types it constructed.\n\n\n#### Union types handle complex types like *a number* or *a string*\n\nIn the following config, the `timeout` field will be parsed as a float:\n\n```yaml\nserver:\n  timeout: 1.2\n```\n\nBut in the following config, the `timeout` value will be parsed as an int:\n\n```yaml\nserver:\n  timeout: 1\n```\n\nAssuming the underlying server wants a float but handles the\nconversion of an int all by itself, we don't really want to force a\nuser to add spurious decimal points (e.g., changing `1` to `1.` will\nensure the parser returns a float) just to consistently achieve a\nsingle type across all configs.\n\nThe following parser configuration rule will accept a `timeout` that\nis either an `int` or a `float`:\n\n```python\nconfp.add_rule('server.timeout', path_type=(int, float))\n```\n\nBy specifying a tuple of types, we can direct **yamlfig** to accept\nvalues that are instances of either type.\n\nThis feature was a lot more urgent in Python 2, where we almost always\nwanted a string to be checked against `(str, unicode)`, so that the\nappearance of a word with an accent or umlaut in a descriptive string\nwouldn't suddenly cause our config file to be rejected.  Things have\ngotten calmer with Python 3 (e.g., `str` vs `unicode` and `int` vs\n`long` are no longer issues), but union types do still arise (e.g.,\n`int` vs `float`).\n\n#### Ensure that a path contains a map or a list\n\nConsider this parser configured to accept mappings from project names\nto descriptions:\n\n```python\nconfp.add_rule('projects', path_type=dict)\nconfp.add_rule('projects.*')\n```\n\nContrast it with this parser configured to accept lists of authorized\nuser names:\n\n```python\nconfp.add_rule('users', path_type=list)\nconfp.add_rule('users.*')\n```\n\nIn both cases, the wildcard rule accepts one-or-more arbitrary fields\nwithin the block, but as noted in an [earlier\nsegment](#wildcards-are-also-useful-for-accepting-lists-of-values),\nthe wildcard does not distinguish a map from a list.  The\n`path_type=dict` constraint is what ensures that the first parser\naccepts config files with a map, like this:\n\n```yaml\nprojects:\n  ProjectX: \"Project X is an eXtreme project (for more info talk to Alice)\"\n  meerkat_works: \"Bob's not-quite skunkworks project\"\n```\n\nThe `path_type=list` constraint is what ensures that the second parser\naccepts config files with a list, like this:\n\n```yaml\nusers:\n- alice\n- bob\n- carol\n```\n\nSince few programs are written to expect either a mapping or a list,\nwe typically want to use type checking to ensure that a config-file\nblock contains the expected structure.\n\n#### A config file itself can be verified as either a list or a map\n\nWhile we have so far considered YAML files with a map structure at the\nroot level, a YAML file could also be a list:\n\n```yaml\n- addr: 192.0.2.200\n  port: 81\n- addr: 192.0.2.201\n  port: 81\n- addr: 198.51.100.15\n  port: 8080\n- addr: 203.0.113.130\n  port: 8080\n```\n\nIn this example, these address-port pairs might be a list of mirrors,\nordered by proximity.  The following parser is configured to check that\nthe YAML file itself is a list, and then that each element of the list\nhas the proper substructure:\n\n```python\nconfp = YamlConfigParser(path_type=list)\nconfp.add_rule('*.addr', path_type=str)\nconfp.add_rule('*.port', path_type=int)\n```\n\nAfter reading and validating the above config file, this parser\nreturns a `YamlConfigList` object:\n\n```python\nlen(conf)                  # 4\nconf[0].addr               # '192.0.2.200'\nconf[0].port               # 81\n```\n\nNote that in this example, we actually included the instantiation of\nthe `YamlConfigParser` as `confp`.  All our previous examples (after\n[Basic Usage](#basic-usage)) assumed that step.  But when we are\nmaking assertions about the top-level object parsed from the config\nfile, those are configured as part of the `YamlConfigParser`\ninstantiation.\n\nDown deep, every rule that gets added to the parser is of type\n`YamlConfigRule`.  The `YamlConfigParser` class inherits from\n`YamlConfigRule`, and any arguments are used to validate the\nroot-level object rather than any particular field or path within the\nobject.  The primary difference between the root `YamlConfigParser`\nobject and the `YamlConfigRule` objects that are added to it is that\nthe `YamlConfigParser` cannot have a `rule_path` while the other\nobjects must.  Additionally, the root-level object cannot be optional\nor take a default.  (It can be flagged no-follow, though.)\n\n\n#### A config file cannot be an atomic value; it must be a map or list\n\nA **yamlfig** parser will not accept a config file without any\nsubstructure.  Technically, this is a valid YAML file:\n\n```yaml\n42\n```\n\nA standard YAML parser will parsed it as an `int`.  However,\n**yamlfig** will raise an error: `config is a(n) int but a record or\nlist is expected`.\n\nHonestly, if our program must accept config files consisting of a\nsingle value, **yamlfig** might not be the right tool for the\nsituation.  If we still desired to make a go of it, we could nest that\nvalue in a single-field mapping, like so:\n\n```yaml\nnumber: 42\n```\n\nThe following parser would accept that config file, with a single\nfield, the value of which is a list:\n\n```python\nconfp = YamlConfigParser(path_type=dict)\nconfp.add_rule('number', path_type=int)\n```\n\nEven more concisely, we could nest the value in a singleton list:\n\n```yaml\n- 42\n```\n\nThe following parser would accept such a config file:\n\n```python\nconfp = YamlConfigParser(path_type=list)\nconfp.add_rule('0', path_type=int)\n```\n\nNote the space between `-` and `42`.  Without it, the singleton list\ncollapses back to a single (negative) integer:\n\n```yaml\n-42\n```\n\nSuch a single value would not be accepted.\n\n\n### Rule Test Functions\n\nWhile type checking helps validate the values in a config file, we\noften want to place additional constraints on those values.  For\ninstance, we might want a value not only to be an `int` but to fall\nwithin a particular range.  We might want another value not only to be\na `str`, but also to match a regular expression.  We might want a\nthird value not only to be a `str` but also to point to an existing\nfile.\n\nWhen adding a rule to a parser, we can specify a test function using\nthe `test` argument, to perform additional checking of values.  The\n`yamlfig.test` package contains a variety of pre-packaged test\nfunctions for some common validation scenarios.\n\n#### Verify that a value matches a regular expression\n\nThis parser rule will constrain `username` to start with a lower case\nletter and be followed by zero or more lowercase letters or numbers:\n\n```python\nconfp.add_rule('username', test=test.is_regex('^[a-z][a-z0-9]*$'))\n```\n\nThis config file would be accepted by such a parser:\n\n```yaml\nusername: 'carol57'\n```\n\nThis config file would be rejected:\n\n```yaml\nusername: 'Carol C.'\n```\n\nThe parse error would include the explanation `\"username\" failed test:\n\"Carol C.\" does not match /^[a-z][a-z0-9*$/`.\n\n#### Verify that a value is an IPv4 address\n\nThis parser rule will constrain the `addr` field of the `server` block to\nbe a valid dotted-quad IPv4 address:\n\n```python\nconfp.add_rule('server.addr', test=test.is_ipv4_address)\n```\n\n#### Test functions packaged within yamlfig\n\nThe `yamlfig.test` module that contains various common validation\ntests has been directly imported as the `test` object in the examples\nof this documentation, but would otherwise be accessed as\n`yamlfig.test` (e.g., `test=yamlfig.test.is_regex('^[a-z][a-z0-9]*$')`).\n\nThe following test functions are available in the `yamlfig.test`\nmodule:\n\n * `is_interval(lower, upper)` verifies that the value is within the\n   range defined by the lower and upper bounds;\n\n * `is_regex(regex, invert=False)` verifies that the value matches the\n   regular expression (or does not match it, if inverted);\n\n * `is_ipv4_address` verifies that the value is an IPv4 address in\n   dotted-quad notation;\n\n * `is_domain_name` verifies that the value conforms to the\n   specification of a DNS domain name (which, note, is a looser\n   constraint than that it be an actual operating and reachable domain\n   name);\n\n * `is_email_address` verifies that the value (roughly) conforms to\n   the specification of an email address;\n\n * `is_url` verifies that the value (roughly) conforms to the\n   specification for URLs;\n\n * `is_file_path(*ostests)` takes one or more strings corresponding to\n   properties of filesystem objects, interprets the value as a\n   filesystem path, and verifies that the path satisfies *all* of the\n   listed properties.  Properties include:\n\n   * `'exists'` and `'!exists'`: the path exists (or is not);\n   * `'isdir'` and `'!isdir'`: the path is a directory (or is not);\n   * `'isfile'` and `'!isfile'`: the path is a file (or is not);\n   * `'islink'` and `'!islink'`: the path is a symlink (or is not);\n   * `'ismount'` and `'!ismount'`: the path is a mount point (or is not).\n\nNote that for higher-order functions (i.e., the ones that return the\ntest functions suitable for `test`), not all optional parameters are\nshown and described.  Check the help documentation for each function\nfor additional detail on usage and options.\n\n#### Writing our own test functions\n\nThe `test` parameter to `add_rule` takes a function with three\nparameters: `conf`, `path`, and `value`.  It signals acceptance of the\nvalue by returning None, and rejection by returning a string\nexplaining what caused the failure.\n\nSome of the test functions packaged within **yamlfig**, like\n`test.is_ipv4_address`, directly match that specification.  Others,\nlike `test.is_regex`, return a function that matches the specification\nbased on their arguments.\n\nIn an [earlier\nsegment](#test-that-a-block-contains-fields-without-specifying-which-fields-by-using-wildcards),\nwe explained that rule paths could not contain *partial* wildcards\n(e.g., `user-*` to require that all fields start with a particular\nprefix).  However, test functions do offer a way to recognize such\nproperties and more.  Consider a config file in which a block must\ncontain a `default` field, and can optionally contain zero or more\nfields that must all match a partial wildcard like `user-*`.\n\nTest functions offer a way to implement any test that we can write as\na Python function:\n\n```python\ndef has_default_and_user_fields(conf, path, value):\n  if not 'default' in value:\n    return '\"default\" field is missing'\n  for field in value:\n    if field != 'default' and not field.startswith('user-'):\n      return '\"{0}\" is neither \"default\" nor starts with \"user-\"'.format(field)\n  return None\n\nconfp = YamlConfigParser()\nconfp.add_rule('uploads', test=has_default_and_user_fields)\nconfp.add_rule('uploads.*', path_type=str, optional=True)\n```\n\nThe following config file would be accepted by this parser:\n\n```yaml\nuploads:\n  default: /var/share/SomeApp/uploads\n  user-alice: /home/alice/uploads\n  user-bob: /home/bob/public\n```\n\nThe following config file would be rejected by this parser:\n\n```yaml\nuploads:\n  user-alice: /home/alice/uploads\n  user-bob: /home/bob/public\n```\n\nThe parse error would include the explanation `\"uploads\" test failed:\n\"default\" field is missing`.\n\nOf the three parameters (i.e., `conf`, `path`, and `value`), all of\nthe packaged test functions depend only on the `value`, and that will\ntypically be the case.  By providing the entire `conf` object as well\nas the `path` to the value being verified, **yamlfig** enables the\ntest to evaluate the value in the context of the rest of the config\nfile if necessary.\n\n### Warnings and Caveats\n\n * **Field names with leading underscores** &ndash; While accessing\n   `YamlConfig` fields as attributes is convenient, the drawback is\n   that any field names that start with a leading underscore risk\n   colliding with the methods and attributes that implement the class.\n   Consequently, if the parser encounters any field that start with\n   `'_'`, a warning will be raised.  The warning can be suppressed by\n   setting `yamlfig.print_underscore_warning.off = True`.  As with\n   non-string field names, we can always look up a field with leading\n   underscores via index lookup (e.g., `conf[\"_field\"]` rather than\n   `conf._field`), but the warning is intended to make us aware of the\n   possibility for collision.\n\n * **References to `transform` functions in code and documentation**\n   &ndash; The API for the `YamlConfigRule` class and the\n   `YamlBaseConfig` classes expose references to a `transform`\n   function or the ability to invoke `do_transform` on the container\n   object.  The ability to specify a transform is planned (and\n   described in more detail [below](#future-work)).  As the code\n   indicates, work on this feature was already underway when this\n   version was released, but consider it untested, incompletely\n   documented, and subject to change.\n\n## Next Steps\n\n\n### Future Work\n\nSeveral features are already on our list of things we would like to or\nhave started to implement:\n\n  * Allow standard fielded rules to co-exist alongside wildcard rules,\n    with the standard rule taking precedence if it matches and the\n    wildcard being used as a catch-all.  We probably still want to\n    disallow partial wildcards since (a) they can already be handled\n    with test functions, and (b) they would raise the possibility of\n    allowing multiple partial wildcard rules attached to the same\n    parent path, and that would raise all sorts of ambiguity about\n    what to do if multiple rules match the same field.\n\n  * Allow a user to more easily specify a constraint on field names,\n    for instance a `field_type` to do the same type checking on a\n    field that `path_type` does on the value, and/or a `field_regex`\n    to specify a pattern that the field must match.  Currently these\n    are possible, but would require the user to implement their own\n    rule test, as described above.\n\n  * Add options to `test.is_file_path` that (1) allow the user to\n    specify a directory from which all relative paths are resolved,\n    and (2) allow the user to specify a path into `conf` where such a\n    base directory would be stored.  These would enable support for a\n    config file where one `homepath` field specifies where the program\n    will `chdir` to, and then all the other paths (e.g., `dbfile` or\n    `htmldir` are specified relative to `homepath`).\n\n  * Extend the `rule_path` specification to allow us to express field\n    types that are not strings or are strings that include 'special\n    characters' like whitespace, the delimiter (`.`), or the wildcard\n    (`*`).  Right now, we're thinking of using square brackets in a\n    rule path, so that the string resembles the path that would be\n    used to access the value once parsed (e.g.,\n    `rule_path=\"dbhosts['192.0.2.1'].port\"` would indicate the config\n    file had a structure where a `dbhosts` block contained a field\n    field named `192.0.2.1` which maps to a sub-block that has a\n    `port` field).\n\n  * Implement a `test.is_in_choiceset` which verifies that the value\n    is one of the configured options or choices.  So, if a rule for a\n    `dbtype` path had `test=test.is_in_choiceset(['sqlite', 'mysql',\n    'mongodb'])`, it would verify that the `dbtype` value took one of\n    those values, returning an explanatory error message if not.\n\n  * Extend `YamlConfigParser` with a function to write a config-file\n    template (or and actual config file if provided with a `conf`\n    object) to use for the values.  For each rule, it is already\n    possible to specify a `desc` describing the purpose of the path,\n    and an `example` value.  These values could be incorporated into\n    the config-file template, making it somewhat self documented, and\n    making it easier for a program to provide its users with a\n    template.  In truth, we would probably want to implement this as a\n    `Representer` class that inherits from and extends `SafeDumper`,\n    but with that class invoked by something like\n    `conf.write_file(filename, conf=None)`.\n\n  * Extend `YamlConfigRule` with support for transformations.  A goal\n    for **yamlfig** was to gather into one package all of the things\n    that we find ourselves doing over and over again when we read in a\n    config file (e.g., checking whether fields exist, that they have\n    the right types, and that they meet various other conditions).\n    Another thing we do at this stage is converting them to the\n    objects that we really want to use in our program.  For instance,\n    we don't really want the path to the log file, we want the open\n    filehandle to it; we don't really want the IPv4 address in\n    dotted-quad notation, we want the `IPv4Address` object that we can\n    construct with it.  Some initial groundwork for such\n    transformations already exists within the code, but it needs to be\n    built out and tested (lots and lots of testing, especially the\n    interaction with the write-out-configs extension described above).\n\nThis list is neither exhaustive nor a promise of what is certain to\ncome.  Other suggestions are also welcome, of course, too.\n\n\n### Support and Collaboration\n\nWe welcome reports of issues and other contributions through our\npackage's page on GitHub:\n\n  * https://github.com/ktkalaru/yamlfig\n\nNote that this is our first open-source project, and it was shared in\npart so that we could get more experience with the standard tools and\nworkflows.  We aim to respond to any issues, requests, or other\nfeedback promptly and professionally, but some understanding may be\nrequired since we are learning as we go.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ktkalaru/yamlfig",
    "keywords": "config-file,validation,yaml",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "yamlfig",
    "package_url": "https://pypi.org/project/yamlfig/",
    "platform": "any",
    "project_url": "https://pypi.org/project/yamlfig/",
    "project_urls": {
      "Homepage": "https://github.com/ktkalaru/yamlfig"
    },
    "release_url": "https://pypi.org/project/yamlfig/1.0.0/",
    "requires_dist": [
      "pyyaml"
    ],
    "requires_python": ">=2.7, !=3.0, !=3.1, !=3.2, !=3.3, !=3.4, <4",
    "summary": "Verify the structure of YAML-formatted configuration files.",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7456830,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a189ed93707b0e2217f42b5b1772d49429d0669eb82ee97f9d8af8855d6ccaa5",
          "md5": "fb2b58f6f5e132b0e97fc47b512fbe56",
          "sha256": "e7e06a297708bd13d90dbc3b0aafa92829cfb24babf67cbb712269da7ecb2319"
        },
        "downloads": -1,
        "filename": "yamlfig-1.0.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "fb2b58f6f5e132b0e97fc47b512fbe56",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": ">=2.7, !=3.0, !=3.1, !=3.2, !=3.3, !=3.4, <4",
        "size": 38121,
        "upload_time": "2020-06-11T21:28:40",
        "upload_time_iso_8601": "2020-06-11T21:28:40.425219Z",
        "url": "https://files.pythonhosted.org/packages/a1/89/ed93707b0e2217f42b5b1772d49429d0669eb82ee97f9d8af8855d6ccaa5/yamlfig-1.0.0-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5524dbafde6bbbdf6a7901a0da476c99fd7dae8249cae61833dbcf5f6b21cf70",
          "md5": "3312656d5cf900dd0998f137fca40d3f",
          "sha256": "96392a5bf319c6ae8bdc2d23249c9619bd73b56796903c83e98466feeb54416e"
        },
        "downloads": -1,
        "filename": "yamlfig-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3312656d5cf900dd0998f137fca40d3f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0, !=3.1, !=3.2, !=3.3, !=3.4, <4",
        "size": 76979,
        "upload_time": "2020-06-11T21:28:42",
        "upload_time_iso_8601": "2020-06-11T21:28:42.877956Z",
        "url": "https://files.pythonhosted.org/packages/55/24/dbafde6bbbdf6a7901a0da476c99fd7dae8249cae61833dbcf5f6b21cf70/yamlfig-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a189ed93707b0e2217f42b5b1772d49429d0669eb82ee97f9d8af8855d6ccaa5",
        "md5": "fb2b58f6f5e132b0e97fc47b512fbe56",
        "sha256": "e7e06a297708bd13d90dbc3b0aafa92829cfb24babf67cbb712269da7ecb2319"
      },
      "downloads": -1,
      "filename": "yamlfig-1.0.0-py2.py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "fb2b58f6f5e132b0e97fc47b512fbe56",
      "packagetype": "bdist_wheel",
      "python_version": "py2.py3",
      "requires_python": ">=2.7, !=3.0, !=3.1, !=3.2, !=3.3, !=3.4, <4",
      "size": 38121,
      "upload_time": "2020-06-11T21:28:40",
      "upload_time_iso_8601": "2020-06-11T21:28:40.425219Z",
      "url": "https://files.pythonhosted.org/packages/a1/89/ed93707b0e2217f42b5b1772d49429d0669eb82ee97f9d8af8855d6ccaa5/yamlfig-1.0.0-py2.py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5524dbafde6bbbdf6a7901a0da476c99fd7dae8249cae61833dbcf5f6b21cf70",
        "md5": "3312656d5cf900dd0998f137fca40d3f",
        "sha256": "96392a5bf319c6ae8bdc2d23249c9619bd73b56796903c83e98466feeb54416e"
      },
      "downloads": -1,
      "filename": "yamlfig-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "3312656d5cf900dd0998f137fca40d3f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=2.7, !=3.0, !=3.1, !=3.2, !=3.3, !=3.4, <4",
      "size": 76979,
      "upload_time": "2020-06-11T21:28:42",
      "upload_time_iso_8601": "2020-06-11T21:28:42.877956Z",
      "url": "https://files.pythonhosted.org/packages/55/24/dbafde6bbbdf6a7901a0da476c99fd7dae8249cae61833dbcf5f6b21cf70/yamlfig-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}