{
  "info": {
    "author": "",
    "author_email": "Raymond Chow <raymond.chow@ea.epson.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering",
      "Topic :: Software Development :: Embedded Systems",
      "Topic :: Software Development :: Libraries :: Python Modules",
      "Topic :: Software Development :: Localization",
      "Topic :: System :: Hardware :: Hardware Drivers"
    ],
    "description": "# Disclaimer:\n--------------\nMIT License\n\nCopyright (c) 2023, Seiko Epson Corporation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n# Table of Contents\n-------------\n1. [Python Library for Epson Sensing System Devices](#Python-Library-for-Epson-Sensing-System-Devices)\n2. [Test machine](#Test-machine)\n3. [Requirements](#Requirements)\n4. [Precautionary Notes](#Precautionary-Notes)\n5. [Installation](#Installation)\n6. [Logger Usage](#Logger-Usage)\n7. [SensorDevice Class Library Usage](#SensorDevice-Class-Library-Usage)\n8. [LoggerHelper Class Library Usage](#LoggerHelper-Class-Library-Usage)\n9. [File Listing](#File-Listing)\n10. [Change Record](#Change-Record)\n\n\n# Python Library for Epson Sensing System Devices\n-------------\nThis a general python library for developing and evaluating the Epson Sensing System\nDevices in a Python 3.x environment using the UART interface\n\nThis package consists of two parts:\n * *SensorDevice* library class which allows the user to communicate and control the sensing device\n   * Provides low-level functions to read/write registers\n   * Provides functions to perform selftests, software reset,\n   * Provides flash-related functions\n   * Provides functions to configure the device, and enter CONFIG/SAMPLING modes\n   * Provides function to read a burst sample when in SAMPLING mode\n   * Exposes read-only property attributes to read various statuses and model information\n * Logger script *logger.py* which is built around the *LoggerHelper* library class and intended as reference on how to use the *SensorDevice* class\n   * Command Line driven application with full set of arguments for configuring the device and logger output\n   * serial port setting, i.e. port, baudrate\n   * logging duration\n   * device configuration, i.e. output rate, filter setting, model, etc\n   * flash operations\n   * output to stdout or CSV file\n\n\n# Test machine\n-------------\n * Windows 10 Pro 64-bit\n * Intel Core i5-6500 @ 3.2GHz, 16GB RAM\n\n\n# Requirements\n-------------\n * Python 3.7+\n * Python packages (can be installed using [pypi](https://pypi.org):\n\t* [serial](https://pypi.org/project/pyserial)\n\t* [tqdm](https://pypi.org/project/tqdm)\n\t* [tabulate](https://pypi.org/project/tabulate)\n * Epson sensing device connected to the host UART interface i.e. WIN/PC, Linux/PC or any embedded system with serial port\n  * M-G320PDG0, M-G354PDH0, M-G364PDC0, M-G364PDCA\n\t* M-G365PDC1, M-G365PDF1, M-G370PDF1\n\t* M-G330PDG0, M-G366PDG0, preliminary (M-G370PDG0, M-G370PDT0)\n * Epson USB evaluation board [M-G32EV041](https://global.epson.com/products_and_drivers/sensing_system/assets/pdf/m-g32ev041_e_rev201910.pdf)\n\n\n# Precautionary Notes\n------------\nFor WIN/PC:\n\n * Before running the program, please ensure the Epson IMU USB evaluation port is plugged into the USB port\nand the BM Options -> Latency Timer to 1msec\n * This is especially necessary to support sampling rates > 125sps\n * By default, the Latency Timer is set to 16ms unless changed\n * A 16msec Latency Timer may cause the serial link to drop some bytes during transmission\n * Change the serial port Latency Timer to 1msec in Windows 10, go to:\n   * Control Panel -> Hardware and Sound -> Device Manager -> Ports (COM & LPT) -> USB Serial Port (COMx) -> Properties ->  Port Settings -> Advanced -> BM Options -> Latency Timer (msec) -> set to 1\n\nFor all systems:\n\n * Connect IMU to the USB Evalboard\n * Connect the USB Evalboard to the PC via USB cable\n\n# Installation\n--------------\n * The conventional method to install this package is to use [pip](https://pip.pypa.io/en/stable/)\n * Read more about [installing python packages](https://packaging.python.org/en/latest/tutorials/installing-packages/)\n * As an example, this package is installed from [PyPi](https://pypi.org/) using the following command:\n```\npython3 -m pip install esensorlib\n```\n * Alternatively, if you downloaded the package locally to install, use the following commad:\n\n For tar.gz file:\n ```\n python3 -m pip install <path to file>/esensorlib-x.x.x.tar.gz\n ```\n For whl file:\n ```\n python3 -m pip install <path to file>/esensorlib-x.x.x-py3-none-any.whl\n ```\n\n\n# Logger Usage\n--------------\nNOTE: Use the -h switch for the help menu\n\n## Sending Sensor Data:\n\nOpen a command prompt and run the logger.py python script with the appropriate command line switches:\n1. Select COM port with -s switch (i.e., \"-s com6\")\n2. Select IMU model --model switch (i.e., \"--model G370PDF1\") or let the software auto-detect by not specifying this switch\n3. Select the desired output rate with the --drate switch (i.e., \"--drate 200\" for 200Hz)\n4. Select the desired filter setting with the --filter switch (i.e., \"--filter K128_FC50\") or let the software choose a valid moving average filter by not specifying this switch\n5. Select the desired time duration in seconds with the --secs switch (i.e., \"--secs 60\") or number of samples with the --samples switch (i.e., \"--samples 5000\")\n6. Select if the sensor data to be written to a CSV file with the --csv switch\n\n### To output to console:\n```\npython3 logger.py -s com6 --drate 200 --filter K128_FC25 --secs 100\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nAttitude or Quaternion not supported.\nStart Log: 2023-02-23 20:58:50.056749\n#Log created in Python,,,Sample Rate,200.0,Filter Cfg,k128_fc25,,,\n#Creation Date:,2023-02-23 20:58:50.056749,PROD_ID=G370PDS0,VERSION=29FD,SERIAL_NUM=W0000015,,,,,,\n#Scaled Data,SF_GYRO=+0.00666667 / 2^16 (deg/s)/bit,SF_ACCL=+0.40000000 / 2^16 mg/bit\nSample No.,Gx[dps],Gy[dps],Gz[dps],Ax[mG],Ay[mG],Az[mG]\n0,0.05045105,0.61051066,-0.05250793,12.31838989,10.00319214,6.27946777\n1,0.05047262,0.61033732,-0.05248606,12.30870361,9.88743286,5.97288818\n2,0.05077443,0.60953054,-0.05238241,12.26567383,9.36682739,4.59973145\n3,0.05161662,0.60802389,-0.05219604,12.18662109,8.40490723,2.07177734\n.\n.\n.\n74,0.12697825,0.04116516,0.00080088,-17.93453979,-346.55579834,-940.4909668\n75,0.20138194,0.05390228,0.00061808,-17.59989014,-347.20582886,-940.01728516\n76,0.25439443,0.06177979,0.00140025,-17.30096436,-348.21726074,-939.44940796\n77,0.28146159,0.0647109,0.00308879,-17.08118286,-349.47402954,-938.86427002\nCTRL-C: Exiting\nStop reading sensor\n#Log End,2023-02-21 21:31:11.226411,,,,,,,,\n#Sample Count,000000078,,,,,,,,\n#Data Rate,200.0,sps,,Filter Cfg,k128_fc25,,,,\n-----------------  -----------------  ----------------  -------------\nDate: 2023-02-23   Time: 20:58:50\n-----------------  -----------------  ----------------  -------------\nPROD_ID: G370PDS0  VERSION: 29FD      SERIAL: W0000015\nDOUT_RATE: 200.0   FILTER: K128_FC25\nNDFLAG: False      TEMPC: False       COUNTER: None     CHKSUM: False\nDLT: False         ATTI: False        QTN: False        BIT32: True\n-----------------  -----------------  ----------------  -------------\nClose:  com6 ,  460800 baud\n```\n\n### To output to csv file:\n```\npython3 logger.py -s com6 --drate 200 --filter K128_FC25 --secs 10 --csv\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nAttitude or Quaternion not supported.\nStart Log: 2023-02-23 21:00:49.560112\n100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2000/2000 [00:09<00:00, 202.90it/s]\n-----------------  -----------------  ----------------  -------------\nDate: 2023-02-23   Time: 21:00:59\n-----------------  -----------------  ----------------  -------------\nPROD_ID: G370PDS0  VERSION: 29FD      SERIAL: W0000015\nDOUT_RATE: 200.0   FILTER: K128_FC25\nNDFLAG: False      TEMPC: False       COUNTER: None     CHKSUM: False\nDLT: False         ATTI: False        QTN: False        BIT32: True\n-----------------  -----------------  ----------------  -------------\nClose:  com6 ,  460800 baud\nCSV closed\n```\n\n## Reading Out All the Current IMU Registers\n\nOpen a command prompt and run the *logger.py* python script with the appropriate command line switches:\n1. Select COM port with -s switch (i.e., \"-s COM6\")\n2. Select IMU model --model switch (i.e., \"--model G370PDF1\") or do not specify the switch to let the software auto-detect\n3. Select --dump_reg switch (i.e., \"--dump_reg\")\n\n```\npython3 logger.py -s com6 --dump_reg\nD:\\projects\\py_esensorlib\\src\\logger>logger.py -s com6 --dump_reg\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nReading registers:\nREG[0x02, (W0)] => 0x0400       REG[0x04, (W0)] => 0x0000       REG[0x06, (W0)] => 0x0100\nREG[0x08, (W0)] => 0x0000       REG[0x0A, (W0)] => 0x2729       REG[0x0C, (W0)] => 0x3001\nREG[0x0E, (W0)] => 0x0C4F       REG[0x10, (W0)] => 0xBD09       REG[0x12, (W0)] => 0xFFDC\nREG[0x14, (W0)] => 0x73E4       REG[0x16, (W0)] => 0xFFFB       REG[0x18, (W0)] => 0x4A63\nREG[0x1A, (W0)] => 0x0000       REG[0x1C, (W0)] => 0x5874       REG[0x1E, (W0)] => 0xFFD1\nREG[0x20, (W0)] => 0xFD58       REG[0x22, (W0)] => 0xFCA4       REG[0x24, (W0)] => 0x9056\nREG[0x26, (W0)] => 0xF6CD       REG[0x28, (W0)] => 0x588D       REG[0x2A, (W0)] => 0x0000\n.\n.\n.\nREG[0x48, (W1)] => 0x4000       REG[0x4A, (W1)] => 0x4000       REG[0x4C, (W1)] => 0x0000\nREG[0x4E, (W1)] => 0x0000       REG[0x50, (W1)] => 0x0000       REG[0x52, (W1)] => 0x4000\nREG[0x54, (W1)] => 0x0000       REG[0x56, (W1)] => 0x0000       REG[0x58, (W1)] => 0x0000\nREG[0x5A, (W1)] => 0x4000       REG[0x6A, (W1)] => 0x3347       REG[0x6C, (W1)] => 0x3037\nREG[0x6E, (W1)] => 0x4450       REG[0x70, (W1)] => 0x3053       REG[0x72, (W1)] => 0x29FD\nREG[0x74, (W1)] => 0x3057       REG[0x76, (W1)] => 0x3030       REG[0x78, (W1)] => 0x3030\nREG[0x7A, (W1)] => 0x3531       REG[0x7E, (W0)] => 0x0000       Close:  com6 ,  460800 baud\n```\n\n## Configuring the Device for AUTOSTART Mode\n\nAUTOSTART mode means that the device will automatically retrieve user-programmed device settings from Flash after power-on or reset\nand enter SAMPLING mode to start sending sensor data\n\nThis is a two stage process. The *logger.py* script is first run to configure the desired settings with AUTOSTART enabled.\nThen, the *logger.py* script is run again with the --flash_update switch.\n\nOpen a command prompt and run the *logger.py* python script with the desired command line switches:\n\n1. Select COM port with -s switch (i.e., \"-s com6\")\n2. Select IMU model --model switch (i.e., \"--model G370PDF1\") or do not specify the switch to let the software auto-detect\n3. Select the desired output rate with the --drate switch (i.e., \"--drate 200\" for 200Hz)\n4. Select the desired filter setting --filter switch (i.e., \"--filter K128_FC25\")\n5. Select --autostart switch\n6. Select other output field options as desired such as --ndflags --tempc --counter sample --chksm\n\n```\npython3 logger.py -s com6 --drate 200 --filter K128_FC25 --autostart --ndflags --tempc --counter sample --chksm\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nAttitude or Quaternion not supported.\nStart Log: 2023-02-23 21:04:06.935868\n#Log created in Python,,,Sample Rate,200.0,Filter Cfg,k128_fc25,,,\n#Creation Date:,2023-02-23 21:04:06.935868,PROD_ID=G370PDS0,VERSION=29FD,SERIAL_NUM=W0000015,,,,,,\n#Scaled Data,SF_GYRO=+0.00666667 / 2^16 (deg/s)/bit,SF_ACCL=+0.40000000 / 2^16 mg/bit,SF_TEMPC=-0.00379180 / 2^16 degC/bit\nSample No.,Flags[hex],Ts[deg.C],Gx[dps],Gy[dps],Gz[dps],Ax[mG],Ay[mG],Az[mG],Counter[dec],Chksm16[dec]\n0,65276,34.9878,0.05045481,0.61051107,-0.05250783,12.32171631,9.99328003,6.27833252,5,46256\n1,65276,34.9834,0.05044586,0.61031555,-0.0524821,12.22573242,10.13508911,6.00200195,10,17504\n2,65276,34.9636,0.0504128,0.60951121,-0.05234721,11.79653931,10.77099609,4.76342163,15,52116\n3,65276,34.9272,0.0503476,0.60810201,-0.05207926,11.00755005,11.94151611,2.48411255,20,30445\n.\n.\n.\n78,65276,21.4056,0.01772471,-0.00318665,-0.00625661,-282.01542358,447.45990601,-846.54857788,395,29988\n79,65276,21.4057,0.01102142,-0.00939178,-0.02012268,-282.372229,447.215625,-846.31990356,400,31254\n80,65276,21.4058,-0.00463511,-0.0199587,-0.02862864,-283.0545105,446.97546387,-846.23619385,405,9847\n81,65276,21.4057,-0.02773682,-0.03746836,-0.0320049,-284.0480835,446.84927979,-846.26987915,410,44621\n82,65276,21.4056,-0.05128143,-0.05793732,-0.03223145,-285.33282471,446.89196167,-846.31789551,415,56327\nCTRL-C: Exiting\nStop reading sensor\n#Log End,2023-02-23 21:04:07.232625,,,,,,,,\n#Sample Count,000000083,,,,,,,,\n#Data Rate,200.0,sps,,Filter Cfg,k128_fc25,,,,\n-----------------  -----------------  ----------------  ------------\nDate: 2023-02-23   Time: 21:04:07\n-----------------  -----------------  ----------------  ------------\nPROD_ID: G370PDS0  VERSION: 29FD      SERIAL: W0000015\nDOUT_RATE: 200.0   FILTER: K128_FC25\nNDFLAG: True       TEMPC: True        COUNTER: Sample   CHKSUM: True\nDLT: False         ATTI: False        QTN: False        BIT32: True\n-----------------  -----------------  ----------------  ------------\nClose:  com6 ,  460800 baud\n```\n\nThen run the *logger.py* python script again:\n1. Select COM port with -s switch (i.e., \"-s com6\")\n2. Select --flash_update to store settings in the device\n\n```\npython3 logger.py -s com6 --flash_update\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nFlash Backup Completed\nClose:  com6 ,  460800 baud\n```\n\n## Configuring the Device Back to Factory Default Registers Settings\n\nOpen a command prompt and run the *logger.py* python script with the appropriate command line switches:\n\n1. Select COM port with with -s switch (i.e., \"-s com6\")\n2. Select --init_default\n\n```\npython3 logger.py -s com6 --initdefault\nModel not specified, attempting to auto-detect\nDetected: G370PDS0\nInitial Backup Completed\nClose:  com6 ,  460800 baud\n```\n\n## Help Screen Options:\n\n```\nusage: logger.py [-h] [-s SERIAL_PORT] [-b {921600,460800,230400}] [--secs SECS | --samples SAMPLES]\n                   [--drate {2000,1000,500,250,125,62.5,31.25,15.625,400,200,100,80,50,40,25,20}]\n                   [--filter {mv_avg0,mv_avg2,mv_avg4,mv_avg8,mv_avg16,mv_avg32,mv_avg64,mv_avg128,k32_fc25,k32_fc50,k32_fc100,k32_fc200,k32_fc400,k64_fc25,k64_fc50,k64_fc100,k64_fc200,k64_fc400,k128_fc25,k128_fc50,k128_fc100,k128_fc200,k128_fc400}]\n                   [--model {g320,g354,g364pdc0,g364pdca,g365pdc1,g365pdf1,g370pdf1,g370pds0,g330pdg0,g366pdg0,g370pdg0}] [--a_range] [--bit16] [--csv] [--noscale]\n                   [--ndflags] [--tempc] [--chksm] [--counter {reset,sample} | --ext_trigger]\n                   [--dlt {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15} {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}] [--atti {euler,incl}] [--qtn]\n                   [--atti_profile {modea,modeb,modec}] [--atti_conv {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23}] [--autostart] [--init_default]\n                   [--flash_update] [--dump_reg] [--verbose]\n\nThis program is intended as sample code for evaluation testing the Epson device with the UART I/F. This program will initialize the device with user specified arguments\nand retrieve sensor data and format the output to console or CSV file. Other misc. utility functions are described in the help\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SERIAL_PORT, --serial_port SERIAL_PORT\n                        specifies the serial port comxx or /dev/ttyUSBx\n  -b {921600,460800,230400}, --baud_rate {921600,460800,230400}\n                        specifies baudrate of the serial port, default is 460800\n  --secs SECS           specifies time duration of reading sensor data in seconds, default 5 seconds. Press CTRL-C to abort and exit early\n  --samples SAMPLES     specifies the approx number samples to read sensor data. Press CTRL-C to abort and exit early\n  --drate {2000,1000,500,250,125,62.5,31.25,15.625,400,200,100,80,50,40,25,20}\n                        specifies IMU output data rate in sps, default is 200sps\n  --filter {mv_avg0,mv_avg2,mv_avg4,mv_avg8,mv_avg16,mv_avg32,mv_avg64,mv_avg128,k32_fc25,k32_fc50,k32_fc100,k32_fc200,k32_fc400,k64_fc25,k64_fc50,k64_fc100,k64_fc200,k64_fc400,k128_fc25,k128_fc50,k128_fc100,k128_fc200,k128_fc400}\n                        specifies the filter selection. If not specified, moving average based on selected output data rate will automatically be selected. NOTE: Refer\n                        to datasheet for valid settings.\n  --model {g320,g354,g364pdc0,g364pdca,g365pdc1,g365pdf1,g370pdf1,g370pds0,g330pdg0,g366pdg0,g370pdg0}\n                        specifies the IMU model type, if not specified will auto-detect\n  --a_range             specifies to use 16G accelerometer output range instead of 8G. NOTE: Not all devices support this mode.\n  --bit16               specifies to output 16-bit resolution, otherwise use 32-bit\n  --csv                 specifies to read sensor data to file otherwise sends to console. An optional string parameter if specified will be appended to filename\n  --noscale             specifies to keep sensor data as digital counts (without applying scale factors)\n  --counter {reset,sample}\n                        specifies to enable reset counter(GPIO2) or sample counter in the sensor data\n  --ext_trigger         specifies to enable external trigger mode on GPIO2\n\noutput field options:\n  --ndflags             specifies to enable ND/EA flags in sensor data\n  --tempc               specifies to enable temperature data in sensor data\n  --chksm               specifies to enable 16-bit checksum in sensor data\n\nattitude options:\n  --atti {euler,incl}   specifies to enable attitude output in sensor data in euler mode or inclination mode NOTE: Not all devices support this mode.\n  --qtn                 specifies to enable attitude quaternion data in sensor data. NOTE: Not all devices support this mode.\n  --atti_profile {modea,modeb,modec}\n                        specifies the attitude motion profile when attitude euler or quaternion output is enabled. NOTE: Not all devices support this feature.\n  --atti_conv {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23}\n                        specifies the attitude axis conversion when attitude euler output is enabled. Must be between 0 to 23 (inclusive). This must be set to 0 for\n                        when quaternion output is enabled NOTE: Not all devices support this feature.\n\ndelta angle/velocity options:\n  --dlt {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15} {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}\n                        specifies to enable delta angle & delta velocity in sensor data with specified delta angle, delta velocity scale factors. NOTE: Not all devices\n                        support this mode.\n\nflash-related options:\n  --autostart           Enables AUTO_START fucntion. Should run afterwards with --flashupdate to store the settings to flash\n  --init_default        This sets the IMU flash setting with default register settings per datasheet.\n  --flash_update        specifies to store current IMU register settings to flash. This is normally used with --autostart or --initdefault\n\ndebug options:\n  --dump_reg            specifies to read out all the registers from the device without configuring device\n  --verbose             specifies to enable low-level register messages for debugging\n```\n\n# SensorDevice Class Library Usage\n-----------------------------------\n * *SensorDevice* is the main library class in the *esesnorlib* package for communicating and controlling the Epson sensor device\n * Provides low-level functions to read/write registers\n * Provides functions to perform selftests, software reset,\n * Provides flash-related functions\n * Provides functions to configure the device, and enter CONFIG/SAMPLING modes\n * Provides function to read a burst sample when in SAMPLING mode\n * Exposes read-only property attributes to read device statuses and model information\n\n\n## Importing\n * Assuming the *esensorlib* package has been properly installed (see [Installation](#Installation)), the package must first be imported into the current python environment\n * *SensorDevice()* class is located in the *sensor_core.py* file in directory *src/esensorlib*\n\n```\nimport esensorlib.sensor_core as sensor\n```\n\n## Instantiating\n * After importing the package, instantiate the class by passing the name of the serial port where the sensor device is attached\n * Optionally specify the baudrate (defaults to 460800 baud if not specified) and device model (auto-detects if not specified)\n```\n>>> imu = sensor.SensorDevice('com6')\nDetected: G370PDS0\n```\n\n## Configuring\n * The device should be configured by passing the \"basic\" configuration dict, *basic_cfg*, when calling the *config()* method\n * Two optional configuration dicts can also be passed:\n   * \"delta angle / velocity\" configuration (*dlt_cfg*)\n   * \"attitude / quaternion\" configuration (*atti_cfg*)\n\n### Default Configuration\n * If no configuration dicts are passed when calling the *config()* method, the defaults in [Default Basic](#Default-Basic) are used\n\n```\n>>> imu.config()\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n```\n\n#### Default Basic (*basic_cfg*)\n\nKey             | Value        | Description / Comment\n----------------|--------------|-----------------------\ndout_rate       | 200          | 200 Hz\nfilter          | None         | Will auto-set to Moving Average TAP=16\nndflags         | True         | Include NDFLAGS field\ntempc           | True         | Include temperature field\ncounter         | sample       | Include counter field containing sample count\nchksm           | False        | Do not include 16-bit checksum field\nauto_start      | False        | Disable AUTO_START function\nis_32bit        | True         | Sensor data is 32-bit resolution i.e. Gyro, Accl, Temperature, etc\na_range         | False        | Set M-G330PDG0, M-G366PDG0, M-G370PDG0, M-G370PDT0 accelerometer output range to 8G (ignored for other models)\next_trigger     | False        | Disable external trigger\nuart_auto       | False        | UART_AUTO mode is disabled\n\n#### Default Delta Angle / Velocity  (*dlt_cfg*)\n\nKey             | Value        | Description / Comment\n----------------|--------------|-----------------------\ndlta            | False        | Delta Angle output disabled\ndltv            | False        | Delta Velcoity output disabled\ndlta_sf_range   | 12           | If None, Delta Angle Scale Factor setting is 12\ndltv_sf_range   | 12           | If None, Delta Velocity Scale Factor setting is 12\n\n#### Default Attitude / Quaternion  (*atti_cfg*)\n\nKey             | Value        | Description / Comment\n----------------|--------------|-----------------------\natti            | False        | Attitude output disabled\nmode            | \"euler\"      | Attitude mode is Euler mode\nconv            | 0            | Attitude conversion mode is 0\nprofile         | \"modea\"      | Attitude Motion Profile is ModeA\nqtn             | False        | Quaternion output is disabled\n\n\n### Basic Configuration\n * Create a dict with desired basic settings and pass it in to the *basic_cfg* parameter when calling the *config()* method\n * *dlt_cfg* and *atti_cfg* parameters are optional and may be ommitted\n * NOTE: If *dlt_cfg* and *atti_cfg* are not specified it will use [defaults](#Default-Delta-Angle-/-Velocity)\n\n```\nmy_basic = {\n    \"dout_rate\": 250,\n    \"filter\": \"mv_avg16\",\n    \"ndflags\": True,\n    \"tempc\": True,\n    \"counter\": \"sample\",\n    \"chksm\": False,\n    \"uart_auto\": True,\n    \"auto_start\": False,\n    \"is_32bit\": True,\n    \"a_range\": 0,\n    \"ext_trigger\": False,\n}\nimu.config(basic_cfg=my_basic)\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n```\n\n * NOTE: Not all key, value pairs need to be included in the *basic_cfg* dict, only \"dout_rate\" is mandatory.\n\n```\nmy_basic = {\n    \"dout_rate\": 200,\n    \"ndflags\": True,\n    \"tempc\": True,\n    \"counter\": \"sample\",\n    \"is_32bit\": True,\n}\nimu.config(basic_cfg=my_basic)\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n```\n\n### Delta Angle / Velocity Configuration\n * Create a dict with delta angle/velocity settings and pass it to the *dlt_cfg* parameter when calling the *config()* method\n * NOTE: If *basic_cfg* or *atti_cfg* are not specified it will use [defaults](#Default-Basic)\n\n```\nmy_dlt = {\n    \"dlta\": True,\n    \"dltv\": True,\n    \"dlta_sf_range\": 4,\n    \"dltv_sf_range\": 4,\n}\nimu.config(dlt_cfg=my_dlt)\nNo atti_cfg specified. Bypassing.\n```\n\n### Attitude / Quaternion Configuration\n * Create a dict with attitude / quaternion settings and pass it to the *atti_cfg* parameter when calling the *config()* method\n * NOTE: Not all models support attitude or quaternion output\n * NOTE: If *basic_cfg* or *dlt_cfg* are not specified it will use [defaults](#Default-Basic)\n\n```\nmy_atti = {\n    \"atti\": True,\n    \"mode\": \"euler\",\n    \"conv\": 0,\n    \"profile\": \"modea\",\n    \"qtn\": True,\n}\nimu.config(atti_cfg=my_atti)\nNo dlt_cfg specified. Bypassing.\n```\n\n## Entering Sampling Mode or Config Mode\n * By default, the device will starts in CONFIG mode for general configuration by reading and writing registers\n * After the device has been configured (by calling *config()*), it must be put into SAMPLING mode to be able to read back sensor data\n\n```\nimu.goto('sampling')\n```\n * NOTE: In SAMPLING mode, other than reading sensor data, the device can only go back to CONFIG mode (or calling a software reset)\n\n```\nimu.goto('config')\n```\n\n## Reading Sensor Data\n * When the device is in SAMPLING mode, calling *read_sample()* will return a tuple containing scaled sensor values\n * To return unscaled sensor data pass the parameter *scale_mode*=False when calling *read_sample()*\n * The type of fields in the returned sample data depends on the configuration of the device (after *config()* was called)\n * To check the type of burst field content and ordering for the *read_sample()* read the *burst_fields* property\n\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> imu.config()\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n>>> imu.goto('sampling')\n>>> imu.read_sample()\n(65277, 24.4844, -0.09913381, -0.04506152, -0.02306736, -7.28860474, -0.18999481, -1005.48262787, 30950)\n>>> imu.read_sample(False)\n(65277, -8912896, -224449, -122431, -45655, -2016294, 199122, -263534044, 14054)\n>>> imu.burst_fields\n('ndflags', 'tempc32', 'gyro32_X', 'gyro32_Y', 'gyro32_Z', 'accl32_X', 'accl32_Y', 'accl32_Z', 'counter')\n```\n\n## Public Methods and Attributes\n\n### Public Attributes\n\nAttribute       | Type         | Description / Comment\n----------------|--------------|-----------------------\ninfo            | dict         | Device info such as prod_id, version_id, serial_id, comport, model\nstatus          | dict         | Configuration status such as dout_rate, filter, ndflags, tempc, counter, chksm, auto_start, is_32bit, a_range, ext_trigger, uart_auto, is_config\ndlt_status      | dict         | Delta angle / velocity status such as dlta, dltv, dlta_sf_range, dltv_sf_range\natti_status     | dict         | Atittiude/Quaternion status such as atti, mode, conv, profile, qtn\nburst_out       | dict         | Burst output status such as ndflags, tempc, gyro, accl, dlta, dltv, qtn, atti, gpio, counter, chksm, tempc32, gyro32, accl32, dlta32, dltv32, qtn32, atti32\nburst_fields    | tuple        | Types of fields contained in a burst read\nmdef            | object       | Object that stores the current model's specific definitions and constants\n\n\n### Public Method\n\nMethod                                | Description / Comment\n--------------------------------------|-------------------------------\nget_reg(winnum, regaddr)              | Perform 16-bit read from specified register address\nset_reg(winnum, regaddr, write_byte)  | Perform 8-bit write to register address with specified byte\ninit_check()                          | Read status for hardware error (HARD_ERR)\ndo_selftest()                         | Perform selftest and check for errors (ST_ERR)\ndo_softreset()                        | Perform software reset\ntest_flash()                          | Perform flash test and check for errors (FLASH_ERR)\nbackup_flash()                        | Backup current register settings to flash and check for errors (FLASH_BU_ERR)\ninit_backup()                         | Clear backup setting in flash back to factory defaults\ndump_reg(columns)                     | Print out all registers (specify number of columns to format to)\nconfig(basic_cfg, dlt_cfg, atti_cfg)  | Configure device settings for basic, delta angle/velocity, attitude/quaternion\ngoto(mode, post_delay)                | Put device in CONFIG or SAMPLING mode and delay for specified time(post_delay) in seconds\nget_mode()                            | Read the device for current mode (CONFIG or SAMPLING)\nread_sample(scale_mode)               | Burst read a sample set from device specifying scaled values or not (scale_mode)\n\n\n# LoggerHelper Class Library Usage\n-----------------------------------\n * This *LoggerHelper* class is used by the *logger.py* to handle formatting of the sensor data output to console or csv file\n * NOTE: *LoggerHelper* requires a properly instantiated and configured *SensorDevice* object\n\n## Importing\n * NOTE: Before using *LoggerHelper* class library, a *SensorDevice* should be instantiated from the *esensorlib* package\n * *LoggerHelper()* class is located in the *helper.py* file in the logger subdirectory where the *esensorlib* package is installed in your system (i.e. <python>\\Lib\\site-packages\\esensorlib\\logger)\n\n```\nimport helper\n```\n\n## Instantiating\n * After importing the *helper.py*, instantiate a LoggerHelper class while passing the *SensorDevice* instance to the sensor parameter\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> import esensorlib.logger.helper as helper\n>>> log = helper.LoggerHelper(sensor=imu)\n```\n\n## Setting Output to CSV File\n * By default, *LoggerHelper* class methods *write()*, *write_header()*, *write_trailer()* will send output to the console\n * To send to a CSV file instead of the console, call the *LoggerHelper* *set_writer()* method specifying the *to* parameter\n * In the *to* parameter pass a list of strings which will combined with \"_\" to create a filename\n * The *set_writer* method will also insert the *SensorDevice* *prod_id*, *dout_rate*, *filter* values when creating teh filename\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> import esensorlib.logger.helper as helper\n>>> log = helper.LoggerHelper(sensor=imu)\n>>> log.set_writer(to=['my_csv'])\n```\n\n * If output is currently directed to a csv file, to close the file and redirect back to the console, call the *LoggerHelper* *set_writer()* method without a parameter\n```\n>>> log.set_writer()\nCSV closed\n```\n\n## Writing Header\n * To write header rows containing device & configuration information to the csv file or console call the *write_header()* method\n * NOTE: The *SensorDevice* should be properly configured (by *config()* method) before calling the *write_header* method\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> imu.config()\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n>>> import esensorlib.logger.helper as helper\n>>> log = helper.LoggerHelper(sensor=imu)\n>>> log.write_header()\nStart Log: 2023-02-23 17:06:39.331964\n#Log created in Python,,,Sample Rate,200,Filter Cfg,MV_AVG16,,,\n#Creation Date:,2023-02-23 17:06:39.331964,PROD_ID=G366PDG0,VERSION=373,SERIAL_NUM=T1000062,,,,,,\n#Scaled Data,SF_GYRO=+0.01515152 / 2^16 (deg/s)/bit,SF_ACCL=+0.25000000 / 2^16 mg/bit,SF_TEMPC=+0.00390625 / 2^16 degC/bit\nSample No.,Flags[hex],Ts[deg.C],Gx[dps],Gy[dps],Gz[dps],Ax[mG],Ay[mG],Az[mG],Counter[dec]\n>>>\n```\n\n## Writing Sample Data\n * To write a burst sensor sample to the console or csv file call the *write()* method with the output fron the *SensorDevice* *read_sample()* method\n * NOTE: The *SensorDevice* should be be properly configured (by *config()* method) before calling the *read_sample()* method\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> imu.config()\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n>>> imu.goto('sampling')\n>>> import esensorlib.logger.helper as helper\n>>> log = helper.LoggerHelper(sensor=imu)\n>>> log.write(imu.read_sample())\n>>>\n```\n\n * To write 1000 burst sensor samples to the csv file call the *write()* method with the output fron the *SensorDevice* *read_sample()* method\n```\n>>> import esensorlib.sensor_core as sensor\n>>> imu = sensor.SensorDevice('com7')\nDetected: G366PDG0\n>>> imu.config()\nNo dlt_cfg specified. Bypassing.\nNo atti_cfg specified. Bypassing.\n>>> imu.goto('sampling')\n>>> import esensorlib.logger.helper as helper\n>>> log = helper.LoggerHelper(sensor=imu)\n>>> for i in range(1000):\n... \tlog.write(imu.read_sample())\n>>>\n```\n\n## Writing Trailer\n * To write trailer rows data to the csv file or console call the *write_trailer()* method\n * NOTE: The *SensorDevice* should be be properly configured (by *config()* method) before calling the *read_sample()* method\n```\n>>> log.write_trailer()\n#Log End,2023-02-23 17:09:06.114034,,,,,,,,\n#Sample Count,000000000,,,,,,,,\n#Data Rate,200,sps,,Filter Cfg,MV_AVG16,,,,\n```\n\n## Printing Device Status\n * To print to console current date/time and device, and configuration info call the *get_dev_info()* method\n * NOTE: The *SensorDevice* should be be properly configured (by *config()* method) before calling the *get_dev_info()* method\n```\n>>>log.get_dev_info()\n-----------------  -----------------  ----------------  ------------\nDate: 2023-02-23   Time: 21:04:07\n-----------------  -----------------  ----------------  ------------\nPROD_ID: G370PDS0  VERSION: 29FD      SERIAL: W0000015\nDOUT_RATE: 200.0   FILTER: K128_FC25\nNDFLAG: True       TEMPC: True        COUNTER: Sample   CHKSUM: True\nDLT: False         ATTI: False        QTN: False        BIT32: True\n-----------------  -----------------  ----------------  ------------\n```\n## Public Methods and Attributes\n\n### Public Attributes\n * These are mirrors of the *SensorDevice* attributes propogated to the *LoggerHelper* class\n\nAttribute       | Type         | Description / Comment\n----------------|--------------|-----------------------\ndev_info        | dict         | Device info such as prod_id, version_id, serial_id, comport, model\ndev_status      | dict         | Configuration status such as dout_rate, filter, ndflags, tempc, counter, chksm, auto_start, is_32bit, a_range, ext_trigger, uart_auto, is_config\ndev_dlt_status  | dict         | Delta angle / velocity status such as dlta, dltv, dlta_sf_range, dltv_sf_range\ndev_atti_status | dict         | Atittiude/Quaternion status such as atti, mode, conv, profile, qtn\ndev_burst_out   | dict         | Burst output status such as ndflags, tempc, gyro, accl, dlta, dltv, qtn, atti, gpio, counter, chksm, tempc32, gyro32, accl32, dlta32, dltv32, qtn32, atti32\ndev_mdef        | object       | Object that stores the current model's specific definitions and constants\n\n\n### Public Method\n\nMethod                                | Description / Comment\n--------------------------------------|-------------------------------\nset_writer(to)                        | Set the writer to csv file with filename derived from list of strings (parameter) or to the console (no parameter)\nwrite(sample_data)                    | Send specified sample_data (tuple) to csv file or console\nwrite_header(scale_mode, start_date)  | Write header information to csv file or console\nwrite_trailer(end_date)               | Write trailer information to csv file or console\nget_dev_status()                      | Send current info about device and configuration to console\nclear_count()                         | Clear the internal sample counter which increments on every call to *write()*\n\n\n# File Listing\n--------------\n\nFile                              | Description / Comment\n----------------------------------|----------------------\nsrc\\                              | Python source files\nsrc\\esensorlib\\sensor_core.py     | SensorDevice library class\nsrc\\esensorlib\\model\\mcore.py     | Core model definition/constants (temporarily used for auto-detect)\nsrc\\esensorlib\\model\\mg320.py     | M-G320PDG0 model definition/constants\nsrc\\esensorlib\\model\\mg354.py     | M-G354PDH0 model definition/constants\nsrc\\esensorlib\\model\\mg364pdc0.py | M-G364PDC0 model definition/constants\nsrc\\esensorlib\\model\\mg364pdca.py | M-G364PDCA model definition/constants\nsrc\\esensorlib\\model\\mg365pdc1.py | M-G365PDC1 model definition/constants\nsrc\\esensorlib\\model\\mg365pdf1.py | M-G365PDF1 model definition/constants\nsrc\\esensorlib\\model\\mg366pdg0.py | M-G366PDG0 model definition/constants\nsrc\\esensorlib\\model\\mg370pdf1.py | M-G370PDF1 model definition/constants\nsrc\\esensorlib\\model\\mg370pds0.py | M-G370PDS0 model definition/constants\nsrc\\esensorlib\\model\\mg370pdt0.py | M-G370PDT0 model definition/constants\nsrc\\esensorlib\\logger\\logger.py   | Logger script\nsrc\\esensorlib\\logger\\helper.py   | Logger helper class (for formatting and file I/O)\ntests\\                            | Test files (currently empty)\nLICENSE                           | License description\npyproject.toml                    | Contains build system requirements and information, which are used by pip to build the package\nREADME.md                         | This readme file\n\n\n# Change Record\n--------------\n\nDate        | Version   | Description / Comment\n------------|-----------|----------------------\n2023-02-24  | v1.0.0    | Initial release\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "accelerometer,gyroscope,imu,inertial,navigation,sensor",
    "license": "MIT License  Copyright (c) 2023, Seiko Epson Corporation  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
    "maintainer": "",
    "maintainer_email": "",
    "name": "esensorlib",
    "package_url": "https://pypi.org/project/esensorlib/",
    "platform": null,
    "project_url": "https://pypi.org/project/esensorlib/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/esensorlib/1.0.0/",
    "requires_dist": [
      "pyserial>=3.5",
      "tabulate>=0.9.0",
      "tqdm>=4.62.3"
    ],
    "requires_python": ">=3.7",
    "summary": "Python driver package for Epson Sensing System devices",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17150494,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7bfb2bfa4418d36d7f636181d945bff9ed99e7d4d5305b0bcdc17e54f7bac5be",
          "md5": "1c7e063a4b659dab609b688296c11216",
          "sha256": "e95389ec7f227fe00a6dbf3418376ffa12fcfb31784a681cd5fe8f2bbfaddee3"
        },
        "downloads": -1,
        "filename": "esensorlib-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1c7e063a4b659dab609b688296c11216",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 62536,
        "upload_time": "2023-03-03T23:23:52",
        "upload_time_iso_8601": "2023-03-03T23:23:52.403416Z",
        "url": "https://files.pythonhosted.org/packages/7b/fb/2bfa4418d36d7f636181d945bff9ed99e7d4d5305b0bcdc17e54f7bac5be/esensorlib-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "469f6cf16b170ba72bb0556d931429537135ae492c3235ab83cf9c3804d03e9f",
          "md5": "0caa975f0aaffb848f95d33539c29749",
          "sha256": "e857e5489c5689e29dd9f954ecf45219bb97567bb363e745e52c401f9db3d1f5"
        },
        "downloads": -1,
        "filename": "esensorlib-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "0caa975f0aaffb848f95d33539c29749",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 44810,
        "upload_time": "2023-03-03T23:23:54",
        "upload_time_iso_8601": "2023-03-03T23:23:54.173335Z",
        "url": "https://files.pythonhosted.org/packages/46/9f/6cf16b170ba72bb0556d931429537135ae492c3235ab83cf9c3804d03e9f/esensorlib-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7bfb2bfa4418d36d7f636181d945bff9ed99e7d4d5305b0bcdc17e54f7bac5be",
        "md5": "1c7e063a4b659dab609b688296c11216",
        "sha256": "e95389ec7f227fe00a6dbf3418376ffa12fcfb31784a681cd5fe8f2bbfaddee3"
      },
      "downloads": -1,
      "filename": "esensorlib-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "1c7e063a4b659dab609b688296c11216",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 62536,
      "upload_time": "2023-03-03T23:23:52",
      "upload_time_iso_8601": "2023-03-03T23:23:52.403416Z",
      "url": "https://files.pythonhosted.org/packages/7b/fb/2bfa4418d36d7f636181d945bff9ed99e7d4d5305b0bcdc17e54f7bac5be/esensorlib-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "469f6cf16b170ba72bb0556d931429537135ae492c3235ab83cf9c3804d03e9f",
        "md5": "0caa975f0aaffb848f95d33539c29749",
        "sha256": "e857e5489c5689e29dd9f954ecf45219bb97567bb363e745e52c401f9db3d1f5"
      },
      "downloads": -1,
      "filename": "esensorlib-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "0caa975f0aaffb848f95d33539c29749",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 44810,
      "upload_time": "2023-03-03T23:23:54",
      "upload_time_iso_8601": "2023-03-03T23:23:54.173335Z",
      "url": "https://files.pythonhosted.org/packages/46/9f/6cf16b170ba72bb0556d931429537135ae492c3235ab83cf9c3804d03e9f/esensorlib-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}