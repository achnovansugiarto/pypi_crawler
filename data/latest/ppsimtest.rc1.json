{
  "info": {
    "author": "Eric Severson and David Doty",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# ppsim Python package\n\nThe `ppsim` package is used for simulating population protocols. The package and further example notebooks can be found on [Github](https://github.com/UC-Davis-molecular-computing/ppsim).\n\nThe core of the simulator uses a [batching algorithm](https://arxiv.org/abs/2005.03584) which gives significant asymptotic gains for protocols with relatively small reachable state sets. The package is designed to be run in a Python notebook, to concisely describe complex protocols, efficiently simulate their dynamics, and provide helpful visualization of the simulation.\n\n## Table of contents\n\n* [Installation](#installation)\n* [First example protocol](#first-example-protocol)\n* [Larger state protocol](#larger-state-protocol)\n* [Protocol with Multiple Fields](#protocol-with-multiple-fields)\n* [Simulating Chemical Reaction Networks (CRNs)](#simulating-chemical-reaction-networks-crns)\n\n## Installation\n\nThe package can be installed with `pip` via\n\n\n```python\npip install ppsim\n```\n\nThe most important part of the package is the `Simulation` class, which is responsible for parsing a protocol, performing the simulation, and giving data about the simulation.\n\n\n```python\nfrom ppsim import Simulation\n```\n\n## First example protocol\n\nA state can be any hashable Python object. The simplest way to describe a protocol is a dictionary mapping pairs of input states to pairs of output states.\nFor example, here is a description of the classic 3-state [approximate majority protocol](http://www.cs.yale.edu/homes/aspnes/papers/approximate-majority-journal.pdf). There are two initial states `A` and `B`, and the protocol converges with high probability to the majority state with the help of a third \"undecided\" state `U`.\n\n\n```python\na, b, u = 'A', 'B', 'U'\napproximate_majority = {\n    (a,b): (u,u),\n    (a,u): (a,a),\n    (b,u): (b,b)\n}\n```\n\nTo instantiate a `Simulation`, we must specify a protocol along with an initial condition, which is a dictionary mapping states to counts. Let's simulate approximate majority with in a population of one billion agents with a slight majority of `A` agents.\n\n\n```python\nn = 10 ** 9\ninit_config = {a: 0.501 * n, b: 0.499 * n}\nsim = Simulation(init_config, approximate_majority)\n```\n\nNow let's run this simulation for `10` units of parallel time (`10 * n` interactions). We will record the configuration every `0.1` units of time.\n\n\n```python\nsim.run(10, 0.1)\n```\n\n     Time: 10.000\n    \n\nThe `Simulation` class can display all these configurations in a `pandas` dataframe in the attribute `history`.\n\n\n```python\nsim.history\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n      <th>U</th>\n    </tr>\n    <tr>\n      <th>time (n interactions)</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.0</th>\n      <td>501000000</td>\n      <td>499000000</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>0.1</th>\n      <td>459457762</td>\n      <td>457439751</td>\n      <td>83102487</td>\n    </tr>\n    <tr>\n      <th>0.2</th>\n      <td>430276789</td>\n      <td>428217565</td>\n      <td>141505646</td>\n    </tr>\n    <tr>\n      <th>0.3</th>\n      <td>409027376</td>\n      <td>406898254</td>\n      <td>184074370</td>\n    </tr>\n    <tr>\n      <th>0.4</th>\n      <td>393162729</td>\n      <td>390949934</td>\n      <td>215887337</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>9.7</th>\n      <td>771074143</td>\n      <td>55357812</td>\n      <td>173568045</td>\n    </tr>\n    <tr>\n      <th>9.8</th>\n      <td>789103074</td>\n      <td>48973925</td>\n      <td>161923001</td>\n    </tr>\n    <tr>\n      <th>9.9</th>\n      <td>806667929</td>\n      <td>43076383</td>\n      <td>150255688</td>\n    </tr>\n    <tr>\n      <th>10.0</th>\n      <td>823641388</td>\n      <td>37668547</td>\n      <td>138690065</td>\n    </tr>\n    <tr>\n      <th>10.0</th>\n      <td>823641389</td>\n      <td>37668547</td>\n      <td>138690064</td>\n    </tr>\n  </tbody>\n</table>\n<p>102 rows × 3 columns</p>\n</div>\n\n\n\n\n```python\np = sim.history.plot()\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_12_0.png)\n    \n\n\nWithout specifying an end time, `run` will run the simulation until the configuration is silent (all interactions are null). In this case, that will be when the protocol reaches a silent majority consensus configuration.\n\n\n```python\nsim.run()\np = sim.history.plot()\n```\n\n     Time: 21.000\n    \n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_14_1.png)\n    \n\n\nNote that by default, `Simulation` assumes that input pair `(b,a)` will have the same transition as `(a,b)`, so order doesn't matter, with the default setting `transition_order = 'symmetric'`.\nThus we have the exact same protocol as if we had spent more time explicitly specifying\n\n\n```python\napproximate_majority_symmetric = {\n    (a,b): (u,u), (b,a): (u,u),\n    (a,u): (a,a), (u,a): (a,a),\n    (b,u): (b,b), (u,b): (b,b)\n}\n```\n\nIf we intentionally meant for these pairwise transitions to only happen in this specified order, we can declare that. We see in this case that it has the same behavior, but just runs twice as slow because now every interaction must happen in a specified order.\n\n\n```python\nsim = Simulation(init_config, approximate_majority, transition_order='asymmetric')\nprint(sim.reactions)\nsim.run()\np = sim.history.plot()\n```\n\n    A, B  -->  U, U      with probability 0.5\n    A, U  -->  A, A      with probability 0.5\n    B, U  -->  B, B      with probability 0.5\n     Time: 44.000\n    \n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_18_1.png)\n    \n\n\nA key result about this protocol is it converges in expected O(log n) time, which surprisingly is very nontrivial to prove. We can use this package to very quickly gather some convincing data that the convergence really is O(log n) time, with the function `time_trials`.\n\n\n```python\nfrom ppsim import time_trials\nimport numpy as np\n\nns = [int(n) for n in np.geomspace(10, 10 ** 8, 20)]\ndef initial_condition(n):\n    return {'A': n // 2, 'B': n // 2}\ndf = time_trials(approximate_majority, ns, initial_condition, num_trials=100, max_wallclock_time = 30)\ndf\n```\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>n</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>10</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>10</td>\n      <td>2.1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>10</td>\n      <td>2.8</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>10</td>\n      <td>2.7</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>10</td>\n      <td>3.8</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>1492</th>\n      <td>42813323</td>\n      <td>23.8</td>\n    </tr>\n    <tr>\n      <th>1493</th>\n      <td>100000000</td>\n      <td>28.1</td>\n    </tr>\n    <tr>\n      <th>1494</th>\n      <td>100000000</td>\n      <td>25.2</td>\n    </tr>\n    <tr>\n      <th>1495</th>\n      <td>100000000</td>\n      <td>25.1</td>\n    </tr>\n    <tr>\n      <th>1496</th>\n      <td>100000000</td>\n      <td>24.6</td>\n    </tr>\n  </tbody>\n</table>\n<p>1497 rows × 2 columns</p>\n</div>\n\n\n\nThis dataframe collected time from up to 100 trials for each population size n across a many orders of magnitude, limited by the budget of 30 seconds of wallclock time that we gave it.\nWe can now use the `seaborn` library to get a convincing plot of the data.\n\n\n```python\nimport seaborn as sns\nlp = sns.lineplot(x='n', y='time', data=df)\nlp.set_xscale('log')\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_22_0.png)\n    \n\n\n## Larger state protocol\n\nFor more complicated protocols, it would be very tedious to use this dictionary format. Instead we can give an arbitrary Python function which takes a pair of states as input (along with possible other protocol parameters) and returns a pair of states as output (or if we wanted a randomized transition, it would output a dictionary which maps pairs of states to probabilities).\n\nAs a quick example, let's take a look at the discrete averaging dynamics, as analyzed [here](https://arxiv.org/abs/1808.05389) and [here](https://hal-cnrs.archives-ouvertes.fr/hal-02473856/file/main_JAP.pdf), which have been a key subroutine used in counting and majority protocols.\n\n\n```python\nfrom math import ceil, floor\n\ndef discrete_averaging(a, b):\n    avg = (a + b) / 2\n    return floor(avg), ceil(avg)\n\nn = 10 ** 6\nsim = Simulation({0: n // 2, 50: n // 2}, discrete_averaging)\n```\n\nWe did not need to explicitly describe the state set. Upon initialization, `Simulation` used breadth first search to find all states reachable from the initial configuration.\n\n\n```python\nprint(sim.state_list)\n```\n\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\n    \n\nThis enumeration will call the function `rule` we give it O(q^2) times, where q is the number of reachable states. This preprocessing step also builds an internal representation of the transition function, so it will not need to continue calling `rule`. Thus we don't need to worry too much about our code for `rule` being efficient.\n\nRather than the dictionary format used to input the configuration, internally `Simulation` represents the configuration as an array of counts, where the ordering of the indices is given by `state_list`.\n\n\n```python\nsim.config_dict\n```\n\n\n\n\n    {0: 500000, 50: 500000}\n\n\n\n\n```python\nsim.config_array\n```\n\n\n\n\n    array([500000,      0,      0,      0,      0,      0,      0,      0,\n                0,      0,      0,      0,      0,      0,      0,      0,\n                0,      0,      0,      0,      0,      0,      0,      0,\n                0,      0,      0,      0,      0,      0,      0,      0,\n                0,      0,      0,      0,      0,      0,      0,      0,\n                0,      0,      0,      0,      0,      0,      0,      0,\n                0,      0, 500000], dtype=int64)\n\n\n\nA key result about these discrete averaging dynamics is that they converge in O(log n) time to at most 3 consecutive values. It could take longer to reach the ultimate silent configuration with only 2 consecutive values, so if we wanted to check for the faster convergence condition, we could use a function that checks for the condition. This function takes a configuration dictionary (mapping states to counts) as input and returns `True` if the convergence criterion has been met.\n\n\n```python\ndef three_consecutive_values(config):\n    states = config.keys()\n    return max(states) - min(states) <= 2\n```\n\nNow we can run until this condition is met (or also use `time_trials` as above to generate statistics about this convergence time).\n\n\n```python\nsim.run(three_consecutive_values, 0.1)\nsim.history\n```\n\n     Time: 14.800\n    \n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n      <th>9</th>\n      <th>...</th>\n      <th>41</th>\n      <th>42</th>\n      <th>43</th>\n      <th>44</th>\n      <th>45</th>\n      <th>46</th>\n      <th>47</th>\n      <th>48</th>\n      <th>49</th>\n      <th>50</th>\n    </tr>\n    <tr>\n      <th>time (n interactions)</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.0</th>\n      <td>500000</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>500000</td>\n    </tr>\n    <tr>\n      <th>0.1</th>\n      <td>450215</td>\n      <td>1</td>\n      <td>1</td>\n      <td>20</td>\n      <td>3</td>\n      <td>1</td>\n      <td>391</td>\n      <td>134</td>\n      <td>2</td>\n      <td>8</td>\n      <td>...</td>\n      <td>9</td>\n      <td>0</td>\n      <td>125</td>\n      <td>395</td>\n      <td>0</td>\n      <td>2</td>\n      <td>16</td>\n      <td>0</td>\n      <td>0</td>\n      <td>450243</td>\n    </tr>\n    <tr>\n      <th>0.2</th>\n      <td>401257</td>\n      <td>11</td>\n      <td>11</td>\n      <td>229</td>\n      <td>30</td>\n      <td>14</td>\n      <td>2125</td>\n      <td>694</td>\n      <td>18</td>\n      <td>199</td>\n      <td>...</td>\n      <td>188</td>\n      <td>26</td>\n      <td>684</td>\n      <td>2165</td>\n      <td>11</td>\n      <td>27</td>\n      <td>176</td>\n      <td>10</td>\n      <td>7</td>\n      <td>401337</td>\n    </tr>\n    <tr>\n      <th>0.3</th>\n      <td>354726</td>\n      <td>46</td>\n      <td>61</td>\n      <td>715</td>\n      <td>146</td>\n      <td>70</td>\n      <td>4818</td>\n      <td>1643</td>\n      <td>114</td>\n      <td>721</td>\n      <td>...</td>\n      <td>753</td>\n      <td>134</td>\n      <td>1730</td>\n      <td>5086</td>\n      <td>75</td>\n      <td>122</td>\n      <td>720</td>\n      <td>53</td>\n      <td>33</td>\n      <td>354312</td>\n    </tr>\n    <tr>\n      <th>0.4</th>\n      <td>310248</td>\n      <td>106</td>\n      <td>145</td>\n      <td>1572</td>\n      <td>360</td>\n      <td>251</td>\n      <td>8297</td>\n      <td>2953</td>\n      <td>340</td>\n      <td>1720</td>\n      <td>...</td>\n      <td>1708</td>\n      <td>399</td>\n      <td>2926</td>\n      <td>8523</td>\n      <td>233</td>\n      <td>327</td>\n      <td>1653</td>\n      <td>161</td>\n      <td>116</td>\n      <td>309999</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>14.4</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>14.5</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>14.6</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>14.7</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>14.8</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n<p>149 rows × 51 columns</p>\n</div>\n\n\n\nWith a much larger number of states, the `history` dataframe is more unwieldly, so trying to directly call `history.plot()` would be very messy and not very useful. Instead, we will define a function that makes a barplot, using the data in a single row of `sim.history` to visualize the distribution at that recorded time step.\n\n\n```python\nfrom matplotlib import pyplot as plt\ndef plot_row(row):\n    fig, ax = plt.subplots(figsize=(12,5))\n    sim.history.iloc[row].plot(ax=ax, kind='bar', \n                              title=f'Discrete averaging at time {sim.history.index[row]:.2f}', \n                              xlabel='minute',\n                              ylim=(0,n))\nplot_row(0)\nplot_row(30)\nplot_row(-1)\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_35_0.png)\n    \n\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_35_1.png)\n    \n\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_35_2.png)\n    \n\n\nThe `ipywidgets` library gives a quick way to make a slider that lets us visualize the evolution of this distribution:\n\n\n```python\nimport ipywidgets as widgets\nbar = widgets.interact(plot_row, row = widgets.IntSlider(\n    min=0, max=len(sim.history)-1, step=1, value=0, layout = widgets.Layout(width='100%')))\n```\n\n![gif](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/barplot1.gif)\n\nIt is recommended to use an interactive matplotlib backend, such as `ipympl`, which can be installed with `pip install ipympl` and then activated with the cell magic `%matplotlib widget`. The recommended environment to use for these notebooks is [Jupyter Lab](https://jupyterlab.readthedocs.io/en/stable/). Unfortunately, these interactive backends are not supported with [Google Colab](https://colab.research.google.com/), so there does not seem to be an easy way to have access to interactive backends with something that can be run only in a browser without local installation.\n\nThe code with the slider above was designed to work in the non-interactive backend. The following cell shows how to accomplish the same thing with an interactive backend:\n\n\n```python\n# The following example uses the ipympl backend. It creates one figure and axis once and then modifies the axis directly with plot_row.\n# If ipympl is installed, then uncommenting and running the following code will produce a slider that changes one single interactive figure object.\n\n# %matplotlib widget\n# def plot_row(row):\n#     ax.clear()\n#     sim.history.iloc[row].plot(ax=ax, kind='bar', \n#                               title=f'Discrete averaging at time {sim.history.index[row]:.2f}', \n#                               xlabel='minute',\n#                               ylim=(0,n))\n#     fig.canvas.draw()\n    \n# fig, ax = plt.subplots()\n# bar = widgets.interact(plot_row, row = widgets.IntSlider(\n#     min=0, max=len(sim.history)-1, step=1, value=0, layout = widgets.Layout(width='100%')))\n```\n\nBecause the population average was exactly 25, the ultimate silent configuration will have every agent in state 50, but it will take a a very long time to reach, as we must wait for pairwise interactions between dwindling counts of states 24 and 26. We can check that this reaction is now the only possible non-null interaction.\n\n\n```python\nprint(sim.enabled_reactions)\n```\n\n    24, 26  -->  25, 25\n    \n\nAs a result, the probability of a non-null interaction will grow very small, upon which the simulator will switch to the Gillespie algorithm. This allows it to relatively quickly run all the way until silence, which we can confirm takes a very long amount of parallel time.\n\n\n```python\n# Setting history_interval to be a function of time t that shrinks, to not record too many configurations over a long time scale\nsim.run(history_interval=lambda t: 10 ** len(str(int(t))) / 100)\n```\n\n     Time: 578983.800\n    \n\nTo better visualize small count states, we add an option to change `yscale` from `linear` to `symlog`.\n\n\n```python\ndef plot_row(row, yscale):\n    fig, ax = plt.subplots(figsize=(12,5))\n    sim.history.iloc[row].plot(ax=ax, kind='bar', \n                              title=f'Discrete averaging at time {sim.history.index[row]:.2f}', \n                              xlabel='minute',\n                              ylim=(0,n))\n    ax.set_yscale(yscale)\n    \nbar = widgets.interact(plot_row, \n                       row = widgets.IntSlider(min=0, max=len(sim.history)-1, step=1, value=0, layout = widgets.Layout(width='100%')),\n                      yscale = ['linear','symlog'])\n```\n\n![gif](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/barplot2.gif)\n\n## Protocol with Multiple Fields\n\nFor more complicated protocol, it is helpful to have the states be more complicated Python objects. A recommended method is to define an Agent [dataclass](https://docs.python.org/3/library/dataclasses.html) that includes various fields.\n\nAs a concrete example, we will use the protocol from [Simple and Efficient Leader Election](https://drops.dagstuhl.de/opus/volltexte/2018/8302/pdf/OASIcs-SOSA-2018-9.pdf). We start by translating the explicit description of an agents state into our Agent class.\n\n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/SimpleLeaderElection1.PNG)\n\n\n```python\nimport dataclasses\nfrom dataclasses import dataclass\n\n# The parameter unsafe_hash=True makes the state hashable, as required, but still lets the transition code change the field values\n# Note that ppsim will by default make safe copies of the agent states before applying the rule,\n#  so it is safe to mutate the fields of an agent in the transition rule\n\n@dataclass(unsafe_hash=True)\nclass Agent:\n    role: str = 'contender'\n    flip_bit: int = 0\n    marker: int = 0\n    phase: str = 'marking'\n    counter: int = 0\n```\n\n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/SimpleLeaderElection2.PNG)\n\n\n```python\ndef leader_election(v: Agent, u: Agent, loglogn: int, Ulogn: int):\n    # marking phase\n    if v.phase == 'marking':\n        if v.counter >= 3 * loglogn and u.flip_bit == 0:\n            v.phase = 'tournament'\n        else:\n            v.counter += 1\n        if v.counter == 4 * loglogn:\n            v.marker = 1\n            v.phase = 'tournament'\n    \n    if v.phase == 'tournament':\n        if v.role == 'contender':\n            if u.marker and v.counter <= Ulogn:\n                v.counter += 1\n            if v.counter < u.counter:\n                v.role = 'minion'\n            if u.role == 'contender' and v.counter == u.counter and v.flip_bit < u.flip_bit:\n                v.role = 'minion'\n        v.counter = max(v.counter, u.counter)\n        \n    v.flip_bit = 1 - v.flip_bit\n    \n    return v\n```\n\nThe pseudocode was described in the following way:\n\n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/SimpleLeaderElection3.PNG)\n\nWe can implement this assumption by having our transition rule call the the `leader_election` function twice:\n\n\n```python\ndef transition(v: Agent, u: Agent, loglogn: int, Ulogn: int):\n    return leader_election(v, dataclasses.replace(u), loglogn, Ulogn), leader_election(u, dataclasses.replace(v), loglogn, Ulogn)\n```\n\nWe can first check instantiate the protocol for various population sizes, to confirm that the number of reachable states is scaling like we expect.\n\n\n```python\nimport numpy as np\nns = [int(n) for n in np.geomspace(10, 10 ** 8, 8)]\nstates = []\nfor n in ns:\n    sim = Simulation({Agent(): n}, transition, loglogn=int(np.log2(np.log2(n))), Ulogn= u * int(np.log2(n)))\n    states.append(len(sim.state_list))\nplt.plot(ns, states)\nplt.xscale('log')\nplt.xlabel('population size n')\nplt.ylabel('number of states')\nplt.show()\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_53_0.png)\n    \n\n\nNow we will simulate the rule for a population of one billion agents, and run it until it gets to one leader.\n\n\n```python\nn = 10 ** 9\nsim = Simulation({Agent(): n}, transition, loglogn=int(np.log2(np.log2(n))), Ulogn= u * int(np.log2(n)))\ndef one_leader(config):\n    leader_states = [state for state in config.keys() if state.role == 'contender']\n    return len(leader_states) == 1 and config[leader_states[0]] == 1\nsim.run(one_leader)\n```\n\n     Time: 67.253\n    \n\nBecause there are hundreds of states, the full history dataframe is more complicated.\n\n\n```python\nsim.history\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr>\n      <th>role</th>\n      <th colspan=\"10\" halign=\"left\">contender</th>\n      <th>...</th>\n      <th colspan=\"10\" halign=\"left\">minion</th>\n    </tr>\n    <tr>\n      <th>flip_bit</th>\n      <th colspan=\"10\" halign=\"left\">0</th>\n      <th>...</th>\n      <th colspan=\"10\" halign=\"left\">1</th>\n    </tr>\n    <tr>\n      <th>marker</th>\n      <th colspan=\"10\" halign=\"left\">0</th>\n      <th>...</th>\n      <th colspan=\"10\" halign=\"left\">1</th>\n    </tr>\n    <tr>\n      <th>phase</th>\n      <th colspan=\"8\" halign=\"left\">marking</th>\n      <th colspan=\"2\" halign=\"left\">tournament</th>\n      <th>...</th>\n      <th colspan=\"10\" halign=\"left\">tournament</th>\n    </tr>\n    <tr>\n      <th>counter</th>\n      <th>0</th>\n      <th>2</th>\n      <th>4</th>\n      <th>6</th>\n      <th>8</th>\n      <th>10</th>\n      <th>12</th>\n      <th>14</th>\n      <th>12</th>\n      <th>13</th>\n      <th>...</th>\n      <th>50</th>\n      <th>51</th>\n      <th>52</th>\n      <th>53</th>\n      <th>54</th>\n      <th>55</th>\n      <th>56</th>\n      <th>57</th>\n      <th>58</th>\n      <th>59</th>\n    </tr>\n    <tr>\n      <th>time (n interactions)</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.000000</th>\n      <td>1000000000</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1.000000</th>\n      <td>135336837</td>\n      <td>270661696</td>\n      <td>90227329</td>\n      <td>12028156</td>\n      <td>859080</td>\n      <td>38162</td>\n      <td>1148</td>\n      <td>6</td>\n      <td>10</td>\n      <td>8</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2.000000</th>\n      <td>18312018</td>\n      <td>146524448</td>\n      <td>195383216</td>\n      <td>104189030</td>\n      <td>29773512</td>\n      <td>5298122</td>\n      <td>641440</td>\n      <td>13908</td>\n      <td>30153</td>\n      <td>14976</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3.000000</th>\n      <td>2478690</td>\n      <td>44626126</td>\n      <td>133867363</td>\n      <td>160631023</td>\n      <td>103263148</td>\n      <td>41305948</td>\n      <td>11269344</td>\n      <td>556907</td>\n      <td>1287669</td>\n      <td>649759</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4.000000</th>\n      <td>335736</td>\n      <td>10736616</td>\n      <td>57260444</td>\n      <td>122138990</td>\n      <td>139568370</td>\n      <td>99261227</td>\n      <td>48123925</td>\n      <td>4232398</td>\n      <td>10487317</td>\n      <td>5527630</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>64.000000</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>65.000000</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>66.000000</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>67.000000</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>67.252549</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>...</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n<p>69 rows × 384 columns</p>\n</div>\n\n\n\nBecause we defined a state as a dataclass `Agent`, which had fields, the columns of the `history` dataframe are a pandas [MultiIndex](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.MultiIndex.html).\n\n\n```python\nsim.history.columns\n```\n\n\n\n\n    MultiIndex([('contender', 0, 0,    'marking',  0),\n                ('contender', 0, 0,    'marking',  2),\n                ('contender', 0, 0,    'marking',  4),\n                ('contender', 0, 0,    'marking',  6),\n                ('contender', 0, 0,    'marking',  8),\n                ('contender', 0, 0,    'marking', 10),\n                ('contender', 0, 0,    'marking', 12),\n                ('contender', 0, 0,    'marking', 14),\n                ('contender', 0, 0, 'tournament', 12),\n                ('contender', 0, 0, 'tournament', 13),\n                ...\n                (   'minion', 1, 1, 'tournament', 50),\n                (   'minion', 1, 1, 'tournament', 51),\n                (   'minion', 1, 1, 'tournament', 52),\n                (   'minion', 1, 1, 'tournament', 53),\n                (   'minion', 1, 1, 'tournament', 54),\n                (   'minion', 1, 1, 'tournament', 55),\n                (   'minion', 1, 1, 'tournament', 56),\n                (   'minion', 1, 1, 'tournament', 57),\n                (   'minion', 1, 1, 'tournament', 58),\n                (   'minion', 1, 1, 'tournament', 59)],\n               names=['role', 'flip_bit', 'marker', 'phase', 'counter'], length=384)\n\n\n\nWe can use the pandas [groupby](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html) function to conveniently look at the values of just one field. For a field whose name is the string `field`, then calling `sim.history.groupby(field, axis=1).sum()` gives the counts of values of just a single state. If we have a set of fields `field1, field2, ...` then calling `sim.history.groupby([field1, field2, ...], axis=1).sum()` will give the counts of values of just those fields.\n\n\n```python\nsim.history.groupby('role', axis=1).sum()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>role</th>\n      <th>contender</th>\n      <th>minion</th>\n    </tr>\n    <tr>\n      <th>time (n interactions)</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.000000</th>\n      <td>1000000000</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1.000000</th>\n      <td>1000000000</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2.000000</th>\n      <td>999999972</td>\n      <td>28</td>\n    </tr>\n    <tr>\n      <th>3.000000</th>\n      <td>999969579</td>\n      <td>30421</td>\n    </tr>\n    <tr>\n      <th>4.000000</th>\n      <td>998042414</td>\n      <td>1957586</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>64.000000</th>\n      <td>2</td>\n      <td>999999998</td>\n    </tr>\n    <tr>\n      <th>65.000000</th>\n      <td>2</td>\n      <td>999999998</td>\n    </tr>\n    <tr>\n      <th>66.000000</th>\n      <td>2</td>\n      <td>999999998</td>\n    </tr>\n    <tr>\n      <th>67.000000</th>\n      <td>2</td>\n      <td>999999998</td>\n    </tr>\n    <tr>\n      <th>67.252549</th>\n      <td>1</td>\n      <td>999999999</td>\n    </tr>\n  </tbody>\n</table>\n<p>69 rows × 2 columns</p>\n</div>\n\n\n\nThis lets us quickly plot the counts of leaders, to see how it decreases down to one leader, and the count in each phase, to see when the agents transition from the marking phase to the tournament phase.\n\n\n```python\nsim.history.groupby('role', axis=1).sum().plot()\nplt.yscale('symlog')\nplt.ylim(0, 2*n)\nplt.show()\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_63_0.png)\n    \n\n\n\n```python\nsim.history.groupby('phase', axis=1).sum().plot()\nplt.show()\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_64_0.png)\n    \n\n\nFor this protocol, a good understanding of why it is working comes from looking at the product of `role` and `counter` values. The way the protocol works is that contenders increase their counter values, which spread by epidemic among all minions, to eliminate other contenders with smaller counter values.\n\nWe will again try to visualize a single row of the dataframe that projects onto just the `role` and `counter` values. Calling `df.iloc[index]` gives us a [Series](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html)\n\n\n```python\ndf = sim.history.groupby(['counter','role'], axis=1).sum()\ndf.iloc[10]\n```\n\n\n\n\n    counter  role     \n    0        contender        2\n    1        contender       48\n    2        contender      441\n    3        contender     2876\n    4        contender    13600\n                          ...  \n    57       minion           0\n    58       contender        0\n             minion           0\n    59       contender        0\n             minion           0\n    Name: 10.0, Length: 108, dtype: int64\n\n\n\nThen calling `unstack()` on the series will give pull off the first field, and give us a dataframe that can immediately plotted as a multibar plot.\n\n\n```python\ndf.iloc[10].unstack()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>role</th>\n      <th>contender</th>\n      <th>minion</th>\n    </tr>\n    <tr>\n      <th>counter</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>48.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>441.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2876.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>13600.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>55257.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>183276.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>523542.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>1305762.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2908411.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>5815321.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>10577404.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>19519273.0</td>\n      <td>144731.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>15633037.0</td>\n      <td>2774308.0</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>12659059.0</td>\n      <td>11179251.0</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>9794528.0</td>\n      <td>30343520.0</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>31088600.0</td>\n      <td>522306882.0</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>7599591.0</td>\n      <td>292467764.0</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>951336.0</td>\n      <td>21176355.0</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>82136.0</td>\n      <td>856059.0</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>5498.0</td>\n      <td>30677.0</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>277.0</td>\n      <td>1087.0</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>10.0</td>\n      <td>68.0</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>0.0</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>24</th>\n      <td>1.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>26</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>27</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>28</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>29</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>30</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>31</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>32</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>33</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>34</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>35</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>36</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>37</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>38</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>39</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>40</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>41</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>42</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>43</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>44</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>45</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>46</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>47</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>48</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>49</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>50</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>51</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>52</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>53</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>54</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>55</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>56</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>57</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>58</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>59</th>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n\n```python\ndf.iloc[10].unstack().plot(kind='bar', figsize=(12,5))\nplt.show()\n```\n\n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_69_0.png)\n    \n\n\nNow we can define a function that creates one of these plots at an arbitrary row, to get a similar slider that lets us quickly visualize the evolution of the distributions.\n\n\n```python\ndef plot_row(row, yscale):\n    fig, ax = plt.subplots(figsize=(12,5))\n    df.iloc[row].unstack().plot(ax=ax, kind='bar', \n                              ylim=(0,n))\n    ax.set_yscale(yscale)\n\nbar = widgets.interact(plot_row, \n                       row = widgets.IntSlider(min=0, max=len(sim.history)-1, step=1, value=0, layout = widgets.Layout(width='100%')),\n                      yscale = ['linear','symlog'])\n```\n\n![gif](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/barplot3.gif)\n\n\n## Simulating Chemical Reaction Networks (CRNs)\n\n`ppsim` is able to simulate any Chemical Reaction Network that has only bimolecular (2-input, 2-output) and unimolecular (1-input, 1-output) reactions. There is a special syntax used to specify CRNs, such as\n\n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/CRN.PNG)\n\n\n\n```python\nfrom ppsim import species\n\na,b,c,d = species('A B C D')\ncrn = [(a+b | 2*c).k(0.5).r(4), (c >> d).k(5)]\n```\n\nFirst we define `species` objects `a,b,c,d`. We then create `crn`, a list of `reaction` objects, which are created by composing these species. Using the `>>` operator creates an irreversible (one-way) reaction, while using the `|` operator creates a reversible (two-way) reaction. A rate constant can be added with the method `reaction.k(...)`, and the reverse rate constant is added with the method `reaction.r(...)`. If not specified, rate constants are assumed to be 1.\n\n\n```python\nsim = Simulation({a: 2000, b:1000}, crn)\nsim.run()\np = sim.history.plot()\n```\n\n     Time: 37.000\n    \n\n    \n![png](https://github.com/UC-Davis-molecular-computing/ppsim/blob/main/README_files/README_75_1.png)\n    \n\n\nCRNs are normally modelled by Gillespie kinetics, which gives a continuous time Markov process. The unimolecular reaction `C ->(5) D` happens as a Poisson process with rate 5. The forward bimolecular reaction `A+B ->(0.5) 2C` happens as a Poisson process with rate `0.5 (#A * #B / v)`, and the reverse bimolecular reaction happens as a Poisson process with rate `4 * #B (\\#B - 1) / (2*v)`, where `v` is the volume parameter.\n\nWhen creating a `Simulation` with a list of `reaction` objects, `ppsim` will by default use this continuous time model.\nBy default, `ppsim` sets the volume `v` to be the population size `n`, which makes the time units independent of population size. In some models, this volume parameter is instead baked directly into the numerical rate constant. In this case, the volume should be set manually in the Simulation constructor, with `Simulation(..., volume = 1)`. In addition, if these numerical rate constants are specified in specific time units (such as per second), this can be specified with `Simulation(..., time_units='seconds')`, and then all times will appear with appropriate units.\n\nFor more details about the CRN model and how it is faithfully represented as a continuous time population protocol, see [this paper](https://arxiv.org/abs/2105.04702).\n\n## More examples\nSee https://github.com/UC-Davis-molecular-computing/population-protocols-python-package/tree/main/examples/\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/UC-Davis-molecular-computing/ppsim",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ppsimtest",
    "package_url": "https://pypi.org/project/ppsimtest/",
    "platform": "",
    "project_url": "https://pypi.org/project/ppsimtest/",
    "project_urls": {
      "Homepage": "https://github.com/UC-Davis-molecular-computing/ppsim"
    },
    "release_url": "https://pypi.org/project/ppsimtest/0.1.6/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "A package for simulating population protocols.",
    "version": "0.1.6",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12437403,
  "releases": {
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3280f0e2790e7edf9dabe3e9311ee84daffc1f075a1ae651064c39d4102b89e8",
          "md5": "f0d40a329956b62a17e138d9590029dc",
          "sha256": "f12a68017c9bcf957afae38a3046503b4f9a26b8a47d270b056683f97015f140"
        },
        "downloads": -1,
        "filename": "ppsimtest-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "f0d40a329956b62a17e138d9590029dc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 220515,
        "upload_time": "2021-12-30T03:55:11",
        "upload_time_iso_8601": "2021-12-30T03:55:11.875169Z",
        "url": "https://files.pythonhosted.org/packages/32/80/f0e2790e7edf9dabe3e9311ee84daffc1f075a1ae651064c39d4102b89e8/ppsimtest-0.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3280f0e2790e7edf9dabe3e9311ee84daffc1f075a1ae651064c39d4102b89e8",
        "md5": "f0d40a329956b62a17e138d9590029dc",
        "sha256": "f12a68017c9bcf957afae38a3046503b4f9a26b8a47d270b056683f97015f140"
      },
      "downloads": -1,
      "filename": "ppsimtest-0.1.6.tar.gz",
      "has_sig": false,
      "md5_digest": "f0d40a329956b62a17e138d9590029dc",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 220515,
      "upload_time": "2021-12-30T03:55:11",
      "upload_time_iso_8601": "2021-12-30T03:55:11.875169Z",
      "url": "https://files.pythonhosted.org/packages/32/80/f0e2790e7edf9dabe3e9311ee84daffc1f075a1ae651064c39d4102b89e8/ppsimtest-0.1.6.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}