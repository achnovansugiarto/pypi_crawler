{
  "info": {
    "author": "Arthur Dujardin, Cédric Périon",
    "author_email": "arthur.dujardin@ensg.eu",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Programming Language :: Python :: 3",
      "Topic :: Software Development :: Build Tools"
    ],
    "description": "![GitHub last commit](https://img.shields.io/github/last-commit/arthurdjn/colorply) \n[![](https://img.shields.io/readthedocs/colorply)](https://colorply.readthedocs.io/en/latest/index.html)\n[![Website](https://img.shields.io/website?url=http%3A%2F%2Farthurdujardin.com%2Fproject%2Fcolorply.html)](http://arthurdujardin.com/project/colorply.html) \n![GitHub stars](https://img.shields.io/github/stars/arthurdjn/colorply?style=social)\n\n# colorply\n\n**A multispectral photogrammetry application**\n\n## Overview\n\n**Colorply** is an open source python application which add new wavelength channels to a 3D cloud of points from a set of referenced images and uses images calibration from MicMac. \nThis package comes with a **GUI**, to make tasks easier if you are not used to *MicMac*.\n\n<p align=\"center\">\n  <b>Multispectral Cloud of Points</b><br>\n  <img src=\"img/cloud_points_all_wavelength.gif\">\n  <br>\n</p>\n\nThese models are models oriented in the same relative coordinate system. However, these models\nare composed of only one channel. **Colorply** merges any channels from any models, as long as they are \nin the same coordinate system.\n\n### About\n\nThis project alone was made in a week, in a bigger project of photogrammetry engineering. The whole project focused in testing and evaluating a multispectral camera, the *Parot Sequoia*. Then, a major part used this camera to generate multispectral 3D cloud of points for remote sensing purposes like vegetation classification, all in 3D. Because *MicMac* works only for RGB (or maximum 3-channels images), **Colorply** was created and handles as many channels as you want and complete an existing 3D points from multispectral images.\n\n### Dependencies\n\nThis package depends on :\n  - PyQt5\n  - lxml\n  - plyfile\n  - numpy\n \nPyQt5 is only used fot the **GUI** of this application. As it can be a bit tricky to understand the file and directory names generated by *MicMac*, we decided to create an interface for it. It is not obligatory to use this interface, you can freely use and modify the python modules.\n\n### Installation\n\nTo install this package, clone this repository and from the command line in the root folder, use :\n\n`pip install .`\n\nThis will install all the dependencies and add **Colorply** to your python environment, usually saved in *path_to_anaconda\\lib\\site-packages*.\n\n\n## Usage\n\n### MicMac\n\n**Colorply** works hands in hands with *MicMac* which is an open source photogrammetric software. You can download it from GitHub at https://github.com/micmacIGN/micmac, or from the main page at https://micmac.ensg.eu/index.php/Install.\nIf you are new to *MicMac*, take a look a the documentation https://github.com/micmacIGN/Documentation/blob/master/DocMicMac.pdf and this active forum :http://forum-micmac.forumprod.com/.\n\n\n### Colorply\n\n#### How it looks\n\nThe interface is simple, but all options are linked !\n\n<p align=\"center\">\n  <b>Colorply GUI</b><br>\n  <img src=\"img/colorply.gif\">\n  <br>\n</p>\n\nTo use this package, run main.py or \n\n```python\nfrom colorply.ui import interface\n\ninterface()\n```\n\nIf you prefer doing it manually, you can use the functional implementation:\n\n```python\nfrom colorply import add_cloud_channel\n\n# Load the 3D model\ninput_ply = \"test/data/result/RVB_GRE.ply\"\n# Load MicMac calibration files\ncalibration_file = \"test/data/calibration/Ori-1bande_All_CampariGCP/AutoCal_Foc-4000_Cam-SequoiaSequoia-GRE.xml\"\n# Load the orientation files for all images in the scene\norientation_dir = \"test/data/calibration/Ori-1bande_All_CampariGCP\"\n# Load the images (corresponding to the orientation files)\nimage_dir = \"test/data/images/RED\"\n# Additional arguments\nimage_ext = \"TIF\"\nchannel = \"RED\"\n# Resulting ply\noutput_ply = \"output.ply\"\n\n# Project all points in `input_ply` to `images_dir`.\n# Create a new ply, the operation is not inplace.\nadd_cloud_channel(input_ply, output_ply,\n                  calibration_file, orientation_dir, \n                  image_dir, image_ext, channel)\n```\n\nYou can also use the commandlines system\n\n```pycon\n$ python colorply   --inply path/to/input_ply\n                    --outply path/to/output_ply\n                    --calib path/to/calib_xml\n                    --oridir path/to/orientation_folder\n                    --imdir path/to/image_folder\n                    --imext image_extension\n                    --channel name_of_new_channel\n                    --mode mode_used_to_merge_new_radiometry\n```\nUse help --argument for additional information.\n\n#### How it works\n\nThe main algorithm is based on the so called *image formula*. This equation links 3D coordinates points *M* to image coordinates points *m*, and depends on the camera calibration (the rotation *R*, the distorsion and PPS *S*, focal length *F*).\n\n\n<p align=\"center\">\n  <img src=\"https://latex.codecogs.com/svg.latex?\\Large&space;m=F-\\frac{k^TFR^{-1}(M-S)}{k^TR^{-1}(M-S)}\"/>\n</p>\n\nTo visualize this formula, let's consider this short animation :\n\n<p align=\"center\">\n  <img src=\"img/image_formula.gif\"/>\n</p>\n\nThe red crosses represent the dense cloud points, computed from the RED channel. These points are projected in NIR channel images. The radiometry at this location is then affected back to the points, adding an extra channel to the cloud.\n\n\n## Application\n\n<p align=\"center\">\n  <img src=\"img/image1.jpg\"/>\n</p>\n\n### About\n\nThis project was used for remote sensing classification from a multispectral camera. The camera *Parrot Sequoia* was first calibrated and tested on sample areas. Then, it was fixed to a civil drone and we flew over high altitudes forest to estimate the evolution of vegetation species. **Colorply** was used to create a multispectral cloud of points, to improve our classification by adding extra features. The clusters were made from a random forest skeleton, using all radiometries (RED, REG, NIR, GRE) and the points 3D positions.\n\n### Classification\n\nIn this repository, you can run the classification on the provided data [here](test/data/result/RVB_GRE_RED_REG_NIR_NDVI.ply).\nFor this short example (for fast processing), the classification results are described as follows :\n\n<p align=\"center\">\n  <img src=\"img/result_4channels.gif\" width=\"48%\"/>\n  <img src=\"img/result_classif.gif\" width=\"48%\"/>\n</p>\n\nThe confusion matrix for this sample is :\n\n|           | Terrain   | Oak       | Shrub     | Grass     |\n|-----------|-----------|-----------|-----------|-----------|\n|**Terrain**| **410**   | 0         | 0         | 16        |\n| **Oak**   | 0         | **260**   | 10        | 0         |\n| **Shrub** | 0         | 10        | **137**   | 16        |\n| **Grass** | 23        | 0         | 11        | **192**   |\n\n**Global accuracy : 92.07%.**\n\n## Licence\nThe code is under the MIT licence",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/arthurdjn/colorply",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "colorply",
    "package_url": "https://pypi.org/project/colorply/",
    "platform": "",
    "project_url": "https://pypi.org/project/colorply/",
    "project_urls": {
      "Homepage": "https://github.com/arthurdjn/colorply"
    },
    "release_url": "https://pypi.org/project/colorply/0.0.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "MicMac application for multispectral photogrammetry.",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7305840,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6fc3aa8c3f1c5f3aa7dbde744238a01db6d596891cb5789ff23112356cccef36",
          "md5": "34d3d6f11b0e84666875feccca6fc812",
          "sha256": "c3ed9b1b4772c9c0b7db2e0454ecfb19e6bbcf765d8d443d907491af70fd30e5"
        },
        "downloads": -1,
        "filename": "colorply-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "34d3d6f11b0e84666875feccca6fc812",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18919,
        "upload_time": "2020-05-22T22:15:56",
        "upload_time_iso_8601": "2020-05-22T22:15:56.320856Z",
        "url": "https://files.pythonhosted.org/packages/6f/c3/aa8c3f1c5f3aa7dbde744238a01db6d596891cb5789ff23112356cccef36/colorply-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6fc3aa8c3f1c5f3aa7dbde744238a01db6d596891cb5789ff23112356cccef36",
        "md5": "34d3d6f11b0e84666875feccca6fc812",
        "sha256": "c3ed9b1b4772c9c0b7db2e0454ecfb19e6bbcf765d8d443d907491af70fd30e5"
      },
      "downloads": -1,
      "filename": "colorply-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "34d3d6f11b0e84666875feccca6fc812",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 18919,
      "upload_time": "2020-05-22T22:15:56",
      "upload_time_iso_8601": "2020-05-22T22:15:56.320856Z",
      "url": "https://files.pythonhosted.org/packages/6f/c3/aa8c3f1c5f3aa7dbde744238a01db6d596891cb5789ff23112356cccef36/colorply-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}