{
  "info": {
    "author": "S. Andrew Sheppard",
    "author_email": "andrew@wq.io",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Django",
      "Framework :: Django :: 2.2",
      "Framework :: Django :: 3.0",
      "Framework :: Django :: 3.1",
      "Framework :: Django :: 3.2",
      "Framework :: Django :: 4.0",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Programming Language :: JavaScript",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Database :: Database Engines/Servers",
      "Topic :: Scientific/Engineering :: GIS"
    ],
    "description": "**Django Data Wizard** is an interactive tool for mapping tabular data (e.g. Excel, CSV, XML, JSON) into a normalized database structure via [Django REST Framework] and [IterTable].  Django Data Wizard allows novice users to map spreadsheet columns to serializer fields (and cell values to foreign keys) on-the-fly during the import process.  This reduces the need for preset spreadsheet formats, which most data import solutions require.\r\n\r\n<img width=\"33%\"\r\n     alt=\"Column Choices\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/02-columns.png\">\r\n<img width=\"33%\"\r\n     alt=\"Auto Import - Progress Bar\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/08-data75.png\">\r\n<img width=\"33%\"\r\n     alt=\"Imported Records\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/10-records.png\">\r\n\r\nThe Data Wizard supports straightforward one-to-one mappings from spreadsheet columns to database fields, as well as more complex scenarios like [natural keys] and [Entity-Attribute-Value] (or \"wide\") table mappings.  It was originally developed for use with the [ERAV data model][ERAV] provided by [vera].\r\n\r\n[![Latest PyPI Release](https://img.shields.io/pypi/v/data-wizard.svg)](https://pypi.org/project/data-wizard)\r\n[![Release Notes](https://img.shields.io/github/release/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/releases)\r\n[![License](https://img.shields.io/pypi/l/data-wizard.svg)](https://github.com/wq/django-data-wizard/blob/master/LICENSE)\r\n[![GitHub Stars](https://img.shields.io/github/stars/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/stargazers)\r\n[![GitHub Forks](https://img.shields.io/github/forks/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/network)\r\n[![GitHub Issues](https://img.shields.io/github/issues/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/issues)\r\n\r\n[![Tests](https://github.com/wq/django-data-wizard/actions/workflows/test.yml/badge.svg)](https://github.com/wq/django-data-wizard/actions/workflows/test.yml)\r\n[![Python Support](https://img.shields.io/pypi/pyversions/data-wizard.svg)](https://pypi.org/project/data-wizard)\r\n[![Django Support](https://img.shields.io/pypi/djversions/data-wizard.svg)](https://pypi.org/project/data-wizard)\r\n\r\n# Usage\r\n\r\nDjango Data Wizard provides a [web interface](#api-documentation), [JSON API](#api-documentation), and [CLI](#command-line-interface) for specifying a [data source](#custom-data-sources) to import (e.g. a previously-uploaded file), selecting a [serializer](#custom-serializers), mapping the data [columns](#columns) and [identifiers](#ids), and (asynchronously) importing the [data](#data) into any target model in the database.\r\n\r\nData Wizard is designed to allow users to iteratively refine their data import flow.  For example, decisions made during an initial data import are preserved for future imports of files with the same structure.  The included [data model](#data-model) makes this workflow possible. \r\n\r\n### Table Of Contents\r\n \r\n 1. **Getting Started**\r\n    * [Installation](#installation)\r\n    * [Initial Configuration](#initial-configuration)\r\n    * [**Target Model Registration (required)**](#target-model-registration)\r\n 2. **API Documentation**\r\n    * [Run API & Admin Screens](#api-documentation)\r\n    * [Data Model](#data-model)\r\n    * [Command-Line Interface](#command-line-interface)\r\n 3. **Advanced Customization**\r\n    * [Custom Serializers](#custom-serializers)\r\n    * [Custom Data Sources](#custom-data-sources)\r\n    * [Custom Tasks](#custom-tasks)\r\n    * [Task Backends](#task-backends)\r\n    * [wq Framework Integration](#wq-framework-integration)\r\n\r\n## Installation\r\n\r\n```bash\r\n# Recommended: create virtual environment\r\n# python3 -m venv venv\r\n# . venv/bin/activate\r\n\r\npython3 -m pip install data-wizard\r\n```\r\n\r\nSee <https://github.com/wq/django-data-wizard> to report any issues.\r\n\r\n## Initial Configuration\r\n\r\nWithin a new or existing Django project, add `data_wizard` to your `INSTALLED_APPS`:\r\n\r\n```python\r\n# myproject/settings.py\r\nINSTALLED_APPS = (\r\n   # ...\r\n   'data_wizard',\r\n   'data_wizard.sources',  # Recommended\r\n)\r\n\r\n# This can be omitted to use the defaults\r\nDATA_WIZARD = {\r\n    'BACKEND': 'data_wizard.backends.threading',\r\n    'LOADER': 'data_wizard.loaders.FileLoader',\r\n    'IDMAP': 'data_wizard.idmap.existing',\r\n    'AUTHENTICATION': 'rest_framework.authentication.SessionAuthentication',\r\n    'PERMISSION': 'rest_framework.permissions.IsAdminUser',\r\n    'AUTO_IMPORT_TASKS': (\r\n        'data_wizard.tasks.check_serializer',\r\n        'data_wizard.tasks.check_iter',\r\n        'data_wizard.tasks.check_columns',\r\n        'data_wizard.tasks.check_row_identifiers',\r\n        'data_wizard.tasks.import_data',\r\n    ),\r\n}\r\n```\r\n\r\nIf you would like to use the built-in data source tables (`FileSource` and `URLSource`), also include `data_wizard.sources` in your `INSTALLED_APPS`.  Otherwise, you will want to configure one or more [custom data sources (see below)](#custom-data-sources).\r\n\r\n> Note: By default, Django Data Wizard uses a simple [threading backend](#data_wizardbackendsthreading) for executing asynchronous tasks.  [Celery and Redis](#data_wizardbackendscelery) can be used instead, but this is not required.\r\n\r\n\r\nNext, add `\"data_wizard.urls\"` to your URL configuration.\r\n\r\n```python\r\n# myproject/urls.py\r\nfrom django.urls import path, include\r\n\r\nurlpatterns = [\r\n    # ...\r\n    path('datawizard/', include('data_wizard.urls')),\r\n]\r\n```\r\n\r\n### Target Model Registration\r\n\r\nIn order to use the wizard, you **must** register one or more target models and/or serializers.  Target model registration helps the wizard know where to put the data it finds in each row of the source spreadsheet.  (By contrast, *source* model registration is optional, as long as you are using the provided `data_wizard.sources` app.)\r\n\r\nThe registration API is modeled after the  Django admin and `admin.py`.  Specifically, Data Wizard will look for a `wizard.py` file in your app directory, which should have the following structure:\r\n\r\n```python\r\n# myapp/wizard.py\r\nimport data_wizard\r\nfrom .models import MyModel\r\n\r\ndata_wizard.register(MyModel)\r\n```\r\n\r\nInternally, the wizard will automatically create a Django REST Framework serializer class corresponding to the target model.  If needed, you can also specify a [custom serializer class](#custom-serializers) to configure how the target model is validated and populated.\r\n\r\nOnce everything is configured, upload a source file in the Django admin, select \"Import via data wizard\" from the admin actions menu, and navigate through the screens described below.\r\n\r\n## API Documentation\r\n\r\nDjango Data Wizard is implemented as a series of views that can be accessed via the Django admin as well as via a JSON API.\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Select Source & Start Import\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/A2-source-list.png\">\r\n\r\n### New Run\r\n\r\n#### `POST /datawizard/`\r\n\r\nCreates a new instance of the wizard (i.e. a `Run`).  If you are using the Django admin integration, this step is executed when you select \"Import via Data Wizard\" from the admin actions menu.  If you are using the JSON API, the returned run `id` should be used in all subsequent calls to the API.  Each `Run` is tied to the source model via a [generic foreign key].\r\n\r\nparameter         | description\r\n------------------|----------------------------------------\r\n`object_id` | The primary key of the *source* model instance containing the data to be imported.\r\n`content_type_id` | The *source* model's app label and model name (in the format `app_label.modelname`).\r\n`loader` | (Optional) The class name to use for loading the source dataset via [IterTable].  The default loader (`data_wizard.loaders.FileLoader`) assumes that the source model contains a `FileField` named `file`.\r\n`serializer` | (Optional) The serializer class to use when populating the *target* model.  This can be left unset to allow the user to select the target during the wizard run.\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Auto Import - Progress Bar\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/06-data25.png\">\r\n     \r\n### auto\r\n#### `POST /datawizard/[id]/auto`\r\n\r\n\r\nThe `auto` task attempts to run the entire data wizard process from beginning to end.  If any input is needed, the import will halt and redirect to the necessary screen.  If no input is needed, the `auto` task is equivalent to starting the `data` task directly.  This is an asynchronous method, and returns a `task_id` to be used with the status API.\r\n\r\nThe [run_detail.html] template provides an example form that initiates the `auto` task.  The `auto` task itself uses the [run_auto.html] template.\r\n\r\nThe default sequence of tasks is defined by the [`AUTO_IMPORT_TASKS` setting](#initial-configuration)  Note that the `check_*` tasks do not provide a direct UI or HTTP API.  Instead, these tasks redirect to a corresponding UI task by raising `data_wizard.InputNeeded` if necessary.  For example, `data_wizard.tasks.check_columns` raises `InputNeeded` and redirects to the [columns](#columns) task if the spreadsheet contains unexpected column headers.  Once the form is submitted, the [updatecolumns](#updatecolumns) task processes the user input and runs the check again.  Once the check succeeds (i.e. all columns have been mapped), the user is able to restart the auto task.\r\n\r\nHere are the corresponding Input and Form Processing tasks for each of the tasks in the default sequence:\r\n\r\nAuto Task | Input Task | Form Processing Task\r\n--|--|--\r\n`check_serializer` | [`list_serializers`](#serializers) | [`updateserializer`](#updateserializer)\r\n`check_iter` | *N/A* | *N/A*\r\n`check_columns` | [`read_columns`](#columns) | [`update_columns`](#updatecolumns)\r\n`check_row_identifiers` | [`read_row_identifiers`](#ids) | [`update_row_identifiers`](#updateids)\r\n[`import_data`](#data) | *N/A* | *N/A*\r\n\r\nSee [Custom Tasks](#custom-tasks) for details on customizing the task sequence.\r\n\r\n> Source: [`data_wizard.tasks.auto_import`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L58)\r\n\r\n---\r\n\r\n### status\r\n#### `GET /datawizard/[id]/status.json?task=[task]`\r\n\r\nThe `status` API is used to check the status of an asynchronous task (one of `auto` or `data`).  The API is used by the provided [data_wizard/js/progress.js] to update the `<progress>` bar in the [run_auto.html] and [run_data.html] templates.  Unlike the other methods, this API is JSON-only and has no HTML equivalent.  An object of the following format will be returned:\r\n\r\n```js\r\n{\r\n    // General properties\r\n    \"status\": \"PROGRESS\", // or \"SUCCESS\", \"FAILURE\"\r\n    \"stage\": \"meta\",      // or \"data\"\r\n    \"current\": 23,        // currently processing row\r\n    \"total\": 100,         // total number of rows\r\n    \r\n    // \"FAILURE\"\r\n    \"error\": \"Error Message\",\r\n\r\n    // Task complete (\"SUCCESS\")\r\n    \"action\": \"records\",        // or \"serializers\", \"columns\" \"ids\"\r\n    \"message\": \"Input Needed\",  // if action is not \"records\"\r\n    \"skipped\": [...],           // rows that could not be imported\r\n    \"location\": \"/datawizard/[id]/records\",\r\n}\r\n```\r\n\r\nThe potential values for the  `status` field are the same as common [Celery task states], even when not using the `celery` backend.  When running an `auto` task, the result is `SUCCESS` whenever the task ends without errors, even if there is additional input needed to fully complete the run.\r\n\r\nThe default [run_auto.html] and [run_data.html] templates include a `<progress>` element for use with the status task.\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Serializer Choices\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/00-serializers.png\">\r\n\r\n### serializers\r\n#### `GET /datawizard/[id]/serializers`\r\n     \r\nThe `serializers` task provides a list of all registered serializers (i.e. target models).  This screen is shown by the `auto` task if a serializer was not specified when the `Run` was created.  The default [run_serializers.html] template includes an interface for selecting a target.  If a serializer is already selected, the template will display the label and a button to (re)start the `auto` task.\r\n\r\n> Source: [`data_wizard.tasks.list_serializers`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L78)\r\n\r\n<br>\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Serializer Selected\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/01-updateserializer.png\">\r\n     \r\n### updateserializer\r\n#### `POST /datawizard/[id]/updateserializer`\r\n\r\nThe `updateserializer` task updates the specified `Run` with the selected target serializer name.  This is typically called from [the form][run_serializers.html] generated by the `serializers` task, and will redirect to that task when complete.\r\n\r\nparameter    | description\r\n-------------|----------------------------------------\r\n`serializer` | The class name (or label) of the target serializer to use for this run.\r\n\r\n> Source: [`data_wizard.tasks.updateserializer`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L90)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Column Choices\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/02-columns.png\">\r\n\r\n### columns\r\n#### `GET /datawizard/[id]/columns`\r\n\r\nThe `columns` task lists all of the columns found in the source dataset (i.e. spreadsheet) and their mappings to target serializer fields.  This screen is shown by the `auto` task if there are any column names that could not be automatically mapped.  The potential mappings are one of:\r\n\r\n  * simple serializer field names (e.g. `field`)\r\n  * nested field names (for [natural keys], e.g. `nested[record][field]`)\r\n  * [EAV][Entity-Attribute-Value] attribute-value mappings (e.g. `values[][value];attribute_id=1`).  Note that EAV support requires a [custom serializer class](#custom-serializers).\r\n\r\nThe default [run_columns.html] template includes an interface for mapping data columns to serializer fields.  If all columns are already mapped, the template will display the mappings and a button to (re)start the `auto` task.\r\n\r\n> Source: [`data_wizard.tasks.read_columns`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L287)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Columns Selected\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/03-updatecolumns.png\">\r\n     \r\n### updatecolumns\r\n#### `POST /datawizard/[id]/updatecolumns`\r\n\r\nThe `updatecolumns` task saves the specified mappings from source data columns to target serializer fields.  This is typically called from [the form][run_columns.html] generated by the `columns` task, and will redirect to that task when complete.\r\n\r\nparameter     | description\r\n--------------|----------------------------------------\r\n`rel_[relid]` | The column to map to the specified serializer field.  The `relid` and the complete list of possible mappings will be provided by the `columns` task.\r\n\r\n> Source: [`data_wizard.tasks.update_columns`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L459)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Identifier Choices\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/04-ids.png\">\r\n\r\n### ids\r\n#### `GET /datawizard/[id]/ids`\r\n\r\nThe `ids` task lists all of the foreign key values found in the source dataset (i.e. spreadsheet).  If there are any unmapped foreign key values, the auto task will stop and redirect to the `ids` task.  The default [run_ids.html] template includes an interface for mapping row identifiers to foreign key values.  The potential mappings depend on the serializer field used to represent the foreign key.\r\n\r\n * For [PrimaryKeyRelatedField], [SlugRelatedField], and [NaturalKeySerializer][natural keys], the choices will include all existing record ID or slugs.\r\n * For `NaturalKeySerializer` only, a`\"new\"` choice will also be included, allowing for the possibility of creating new records in the foreign table on the fly.\r\n \r\nOnce all ids are mapped, the template will display the mappings and a button to (re)start the `auto` task.\r\n\r\nNote that the `auto` task will skip the `ids` task entirely if any of the following are true:\r\n  * The file contains no foreign key columns\r\n  * All foreign key values were already mapped during a previous import run\r\n  * All foreign key values can be automatically mapped via the `DATA_WIZARD['IDMAP']` setting:\r\n  \r\n`DATA_WIZARD['IDMAP']` | detail\r\n--|--\r\n`\"data_wizard.idmap.existing\"` (default) | Automatically map existing IDs, but require user to map unknown ids\r\n`\"data_wizard.idmap.never\"` | Require user to manually map all IDs the first time they are found in a file\r\n`\"data_wizard.idmap.always\"` | Always map IDs (skip manual mapping).  Unknown IDs will be passed on as-is to the serializer, which will cause per-row errors unless using natural keys.\r\n(custom import path) | The function should accept an identifier and a serializer field, and return the mapped value (or `None` if no automatic mapping is available).  See the [built-in functions][idmap.py] for examples.\r\n\r\nNote that the configured `IDMAP` function will only be called the first time a new identifier is encountered.  Once the mapping is established (manually or automatically), it will be re-used in subsequent wizard runs.\r\n\r\n> Source: [`data_wizard.tasks.read_row_identifiers`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L520)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Identifiers Selected\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/05-updateids.png\">\r\n     \r\n### updateids\r\n#### `POST /datawizard/[id]/updateids`\r\n\r\nThe `updateids` task saves the specified mappings from row identifiers to foreign key values.  This is typically called from [the form][run_ids.html] generated by the `ids` task, and will redirect to that task when complete.\r\n\r\nparameter            | description\r\n---------------------|----------------------------------------\r\n`ident_[identid]_id` | The identifier to map to the specified foreign key value.  The `identid` and the complete list of possible mappings will be provided by the `ids` task.\r\n\r\n> Source: [`data_wizard.tasks.update_row_identifiers`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L686)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Auto Import - Progress Bar\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/08-data75.png\">\r\n\r\n### data\r\n#### `POST /datawizard/[id]/data`\r\n\r\nThe `data` task starts the actual import process (and is called by `auto` behind the scenes).  Unlike `auto`, calling `data` directly will not cause a redirect to one of the other tasks if any meta input is needed.  Instead, `data` will attempt to import each record as-is, and report any errors that occured due to e.g. missing fields or unmapped foreign keys.\r\n\r\nThis is an asynchronous method, and returns a `task_id` to be used with the `status` API.  The default [run_data.html] template includes a `<progress>` element for use with status task.\r\n\r\n> Source: [`data_wizard.tasks.import_data`](https://github.com/wq/django-data-wizard/blob/main/data_wizard/tasks.py#L733)\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Imported Records\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/10-records.png\">\r\n\r\n### records\r\n#### `GET /datawizard/[id]/records`\r\n\r\nThe `records` task provides a list of imported rows (including errors).  It is redirected to by the `auto` and `data` tasks upon completion.  Successfully imported `Record` instances will have a [generic foreign key] pointing to the target model.  The `records` task will include links to the `get_absolute_url()` or admin screen for each newly imported target model instance.  The default [run_records.html] template includes an interface for displaying the record details.\r\n\r\n<br>\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Run List\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/11-run-list.png\">\r\n\r\n### Run List\r\n#### `GET /datawizard/`\r\n\r\nDjango Data Wizard provides a list view that summarises prior runs and the number of records imported by each.  Incomplete runs can also be restarted from this list.\r\n\r\n<br><br>\r\n\r\n---\r\n\r\n<img align=\"right\" width=320 height=240\r\n     alt=\"Identifier Admin\"\r\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/A3-identifiers.png\">\r\n     \r\n### Identifier Admin\r\n#### `GET /admin/data_wizard/identifer/`\r\n\r\nDjango Data Wizard identifier mappings can be viewed and edited via the Django Admin.  Runs can also be viewed through the admin - though the Run List above will generally be more useful.\r\n\r\n<br>\r\n\r\n## Data Model\r\n\r\nDjango Data Wizard provides a number of Django models that help track the import process, and preserve data mapping decisions for future reuse.  While a *source* model is required, your *target* data model(s) generally do not have to be changed to support Data Wizard integration.\r\n\r\nstep | description | model\r\n-----|-------------|--------\r\n0 | Upload **source** file | Create `FileSource` (or custom source model)\r\n1 | Start data wizard run | Create `Run`\r\n2 | Select serializer (& target model) | Update `Run`\r\n3 | Map columns to database field names | One `Identifier` per column, if needed\r\n4 | Map cell values to foreign keys | One `Identifier` per unique value\r\n5 | Import data into **target** model | One `Record` + one target model instance per row\r\n\r\nThe `Run` model includes a [generic foreign key] pointing to the source model (e.g. `FileSource`.)  Each row in the source spreadsheet will be mapped to a `Record`.  If the row was successfully imported, a new instance of the target data model will be created, and the `Record` will have a generic foreign key pointing to it.  The `Identifier` model contains no foreign keys, since identifier mappings are reused for subsequent imports.  Instead, a separate `Range` model tracks the location(s) (rows/columns) of each `Identifier` in each `Run`.\r\n\r\nNote that the above workflow just describes the most common use case.  You can create [custom serializers](#custom-serializers) that update more than one target data model per spreadsheet row.  And you can specify [custom data sources](#custom-data-sources) that might not be a spreadsheet or even a file.\r\n\r\n## Command-Line Interface\r\n\r\nDjango Data Wizard provides a single [management command], `runwizard`, that can be used to initiate the `auto` task from the command line.  This can be used to facilitate automated processing, for example as part of a regular cron job.  Note that the CLI does not (currently) support interactively mapping columns and ids, so these should be pre-mapped using the web or JSON API.\r\n\r\nUsage:\r\n\r\n```bash\r\n./manage.py runwizard myapp.mymodel 123 \\\r\n    --loader myapp.loaders.customloader \\\r\n    --serializer myapp.serializer.customserializer \\\r\n    --username myusername\r\n```\r\n\r\nThe basic usage is similar to the [New Run API](#new-run).  Only a content type and object id are required, while the other arguments will be auto-detected if possible.  In particular, you may want to use [set_loader()](#custom-loader) to predefine the default `loader` and `serializer` for any models you plan to use with the CLI.\r\n\r\nThe `runwizard` command will create a new `Run` and immediately start the `auto` task.  Errors will be shown on the console.\r\n\r\n## Custom Serializers\r\n\r\nData Wizard uses instances of Django REST Framework's [Serializer class][ModelSerializer] to determine the destination fields on the target model.  Specifically, the default serializer is [NaturalKeyModelSerializer], which is based on [ModelSerializer].\r\n\r\nYou can override the default serializer by calling `data_wizard.register()` with a name and a serializer class instead of a model class.  Multiple serializers can be registered with the wizard to support multiple import configurations and target models.  \r\n\r\n```python\r\n# myapp/wizard.py\r\nfrom rest_framework import serializers\r\nimport data_wizard\r\nfrom .models import TimeSeries\r\n\r\n\r\nclass TimeSeriesSerializer(serializers.ModelSerializer):\r\n    # (custom fields here)\r\n    class Meta:\r\n        model = TimeSeries\r\n        fields = '__all__'\r\n\r\n        # Optional - see options below\r\n        data_wizard = {\r\n            'header_row': 0,\r\n            'start_row': 1,\r\n            'show_in_list': True,\r\n            'idmap': data_wizard.idmap.existing,\r\n            'auto_import_tasks': [ custom task list ],\r\n        }\r\n\r\n# Use default name & serializer\r\ndata_wizard.register(TimeSeries)\r\n\r\n# Use custom name & serializer\r\ndata_wizard.register(\"Time Series - Custom Serializer\", TimeSeriesSerializer)\r\n```\r\n\r\nAt least one serializer or model should be registered in order to use the wizard.  Note the use of a human-friendly serializer label when registering a serializer.  This name should be unique throughout the project, but can be changed later on without breaking existing data.  (The class path is used as the actual identifier behind the scenes.)\r\n\r\n### Serializer Options\r\n\r\nIn general, custom serializers have all the capabilities of regular [Django REST Framework serializers][serializers], including custom validation rules and the ability to populate multiple target models.  While the `request` context is not available, information about the run (including the user) can be retrieved through the `data_wizard` context instead.\r\n\r\nWhen overriding a serializer for a [natural key model][natural keys], be sure to extend [NaturalKeyModelSerializer], as in [this example][naturalkey_wizard].  In other cases, extend [ModelSerializer] (as in the example above) or the base [Serializer](serializers) class.\r\n\r\nCustom serializers can be used to support [Entity-Attribute-Value] spreadsheets where the attribute names are specified as additional columns.  To support this scenario, the `Entity` serializer should include a nested `Value` serializer with `many=True`, and the `Value` serializer should have a foreign key to the `Attribute` table, as in [this example][eav_wizard].\r\n\r\nData Wizard also supports additional configuration by setting a `data_wizard` attribute on the `Meta` class of the serializer.  The following options are supported.\r\n\r\nname | default | notes\r\n--|--|--\r\n`header_row` | 0 | Specifies the first row of the spreadsheet that contains column headers.  If this is greater than 0, the space above the column headers will be scanned for anything that looks like a one-off \"global\" value intended to be applied to every row in the imported data.\r\n`start_row` | 1 | The first row of data.  If this is greater than `header_row + 1`, the column headers will be assumed to span multiple rows.  A common case is when EAV parameter names are on the first row and units are on the second.\r\n`show_in_list` | `True` | If set to `False`, the serializer will be available through the API but not listed in the wizard views.  This is useful if you have a serializer that should only be used during fully automated workflows.\r\n`idmap` | [`IDMAP` setting](#ids) | Can be any of `data_wizard.idmap.*` or a custom function.  Unlike the `IDMAP` setting, this should always be an actual function and not an import path.\r\n`auto_import_tasks` | [`AUTO_IMPORT_TASKS` setting](#auto) | A list of import paths to functions registered with `@data_wizard.wizard_task` (see [Custom Tasks](#custom-tasks).\r\n\r\n## Custom Data Sources\r\n\r\nDjango Data Wizard uses [IterTable] to determine the source columns present on the spreadsheet or other data source.  Django Data Wizard can use any Django model instance as a source for its data, provided there is a registered loader that can convert the source model into a [Iter class][IterTable].  Data Wizard provides two out-of-the the box loaders, [FileLoader] and [URLLoader], that can be used with the provided models in `data_wizard.sources` (`FileSource` and `URLSource`, respectively).\r\n\r\n### Extending FileLoader\r\nThe default `FileLoader` can be used with any Django model with a `FileField` named `file`.  You can use a model with a different `FileField` name by creating a subclass of `data_wizard.loaders.FileLoader` and setting it as the loader for your model.\r\n\r\n```python\r\n# myapp/models.py\r\nfrom django.db import models\r\n\r\nclass FileModel(models.Model):\r\n    spreadsheet = models.FileField(upload_to='spreadsheets')\r\n```\r\n\r\n```python\r\n# myapp/loaders.py\r\nfrom data_wizard import loaders\r\n\r\nclass FileLoader(loaders.FileLoader):\r\n    file_attr = 'spreadsheet'\r\n```\r\n\r\n```python\r\n# myapp/wizard.py\r\nimport data_wizard\r\nfrom .models import FileModel\r\n\r\ndata_wizard.set_loader(FileModel, \"myapp.loaders.FileLoader\")\r\n```\r\n\r\nIf you have a generic loader that can work with multiple source models, you can also set the default loader globally:\r\n\r\n```python\r\n# myapp/settings.py\r\nDATA_WIZARD = {\r\n    'LOADER': 'myapp.loaders.FileLoader'\r\n}\r\n```\r\n\r\nYou should register a custom `ModelAdmin` class to add the Import action in the admin panel for your model.\r\n\r\n```python\r\n# myapp/admin.py\r\nfrom django.contrib import admin\r\nfrom data_wizard.admin import ImportActionModelAdmin\r\n\r\nfrom .models import FileModel\r\n\r\n\r\n@admin.register(FileModel)\r\nclass FileModelAdmin(ImportActionModelAdmin):\r\n    pass\r\n```\r\n    \r\n### Custom Loader\r\nThe default loaders support any file format supported by [IterTable] (Excel, CSV, JSON, and XML).  Additional formats can be integrating by creating a [custom IterTable class][custom-iter] and then registering it with the wizard.  For example, the [Climata Viewer] uses Django Data Wizard to import data from [climata]'s IterTable-based web service client.  To do this, extend `data_wizard.loaders.BaseLoader` with a custom `load_iter()` function that returns the data from IterTable, as in the example below.\r\n\r\nIt is likely that you will want to use a specific serializer with your custom loader.  If so, override `default_serializer` or `get_serializer_name()` on the loader.  By default, these return `None`, which requires the user to specify the serializer when creating or executing the `Run`.\r\n\r\n```python\r\n# myapp/models.py\r\nfrom django.db import models\r\n\r\nclass CustomIterSource(models.Model):\r\n    some_option = models.TextField()\r\n```\r\n\r\n```python\r\n# myapp/loaders.py\r\nfrom data_wizard import loaders\r\nfrom .iter import CustomIter\r\n\r\nclass CustomIterLoader(loaders.BaseLoader):\r\n    default_serializer = 'mydataapp.wizard.CustomSerializer'\r\n    def load_iter(self):\r\n        source = self.run.content_object\r\n        return CustomIter(some_option=source.some_option)\r\n```\r\n\r\n```python\r\n# myapp/wizard.py\r\nimport data_wizard\r\nfrom .models import CustomIterSource\r\n\r\ndata_wizard.set_loader(CustomIterSource, \"myapp.loaders.CustomIterLoader\")\r\n```\r\n\r\n## Custom Tasks\r\n\r\nIt is possible to override the sequence of tasks excecuted by the [auto](#auto) task, to remove steps or add new ones.  The list can be overridden globally (by setting `DATA_WIZARD['AUTO_IMPORT_TASKS']`), or on a per-serializer basis (by setting `Meta.data_wizard['auto_import_tasks']`).\r\n\r\nEach custom task function should be registered with the `@data_wizard.wizard_task` decorator to configure a label and optionally the API path relative to `/datawizard/[id]/`.  The arguments to the decorator and the function determine the task type.\r\n\r\n\r\n### Check Tasks\r\n\r\n```python\r\n@data_wizard.wizard_task(label=\"Custom Check\", url_path=False)\r\ndef custom_check(run):\r\n    if not some_condition_satisfied(run):\r\n        raise data_wizard.InputNeeded(\"custominput\")\r\n```\r\n\r\nCheck tasks validate whether some condition is satisfied, redirecting to an Input task if needed.  `url_path` is usually set to False to disable the HTTP endpoint.  The task label will be shown in the progress bar (if the task takes more than a couple seconds to run).\r\n\r\n### Input Tasks\r\n\r\n```python\r\n@data_wizard.wizard_task(label=\"Custom Input\", url_path=\"custominput\")\r\ndef custom_input(run):\r\n   return {\"some_template_context\": []}\r\n```\r\n\r\nInput tasks enable the user to provide feedback to guide the wizard.  They should have a `url_path` (which will default to the function name) and a corresponding template (e.g. `data_wizard/run_custominput.html`).  The context returned by the task will be in the template under the `result` variable.  The template typically either renders a form with the needed inputs, or (if all inputs have been entered) a summary with the option to restart the auto task.\r\n\r\n### Form Processing Tasks\r\n\r\n```python\r\n@data_wizard.wizard_task(label=\"Custom Input\", url_path=\"customsave\")\r\ndef custom_save(run, post={}):\r\n   some_save_method(run, post)\r\n   return {\r\n       **custom_input(run),\r\n       \"current_mode\": \"custominput\",\r\n   }\r\n```\r\n\r\nForm Processing Tasks process the form submitted from a prior input task.  Registration is similar to Input Tasks except the function itself should accept an optional `post` kwarg.  Form Processing tasks should be registered with `url_path`, and redirect back to the input task (by setting `current_mode` on the response).\r\n\r\n### Custom Auto Tasks\r\n\r\nIn very advanced use cases, it might be necessary to generate the list of tasks dynamically depending on a number of factors.  In that case, it is possible to define a fully custom auto task:\r\n\r\n```python\r\n@data_wizard.wizard_task(label=\"Custom Workflow\", url_path=\"customauto\", use_async=True)\r\ndef custom_auto(run):\r\n    task_list = somehow_determine_tasks(run)\r\n    return run.run_all(task_list)\r\n```\r\n\r\nRegistration is similar as that for other tasks with the addition of the `use_async` keyword, which facilitates background processing via the configured task backend.\r\n\r\nIn general, the tasks in an automated task list should be check tasks or other auto tasks.  Input and Form Processing tasks should be executed outside of the automated flow.\r\n\r\n## Task Backends\r\n\r\nAny of the following backends can be configured with via the `BACKEND` setting:\r\n\r\n```python\r\n# myproject/settings.py\r\n\r\nDATA_WIZARD = {\r\n   \"BACKEND\": \"data_wizard.backends.threading\"  # Default\r\n              \"data_wizard.backends.immediate\"\r\n              \"data_wizard.backends.celery\"\r\n}\r\n```\r\n\r\n### `data_wizard.backends.threading`\r\n\r\nThe `threading` backend creates a separate thread for long-running asynchronous tasks (i.e. `auto` and `data`).  The threading backend leverages the Django cache to pass results back to the status API.  This is the default backend, but it is still a good idea to set it explicitly.\r\n\r\n### `data_wizard.backends.immediate`\r\n\r\nThe `immediate` backend completes all processing before returning a result to the client, even for the otherwise \"asynchronous\" tasks (`auto` and `data`).  This backend is suitable for small spreadsheets, or for working around threading issues.  This backend maintains minimal state, and is not recommended for use cases involving large spreadsheets or multiple simultanous import processes.\r\n\r\n### `data_wizard.backends.celery`\r\n\r\nThe `celery` backend leverages [Celery] to handle asynchronous tasks, and is usually used with [Redis] as the memory store.\r\nThese additional dependencies are not installed with Django Data Wizard by default.  If you want to use this backend, be sure to configure these libraries first or the REST API may not work as expected.  You can use these steps on Ubuntu:\r\n\r\n```bash\r\n# Install redis and celery\r\nsudo apt-get install redis-server\r\npip install celery redis\r\n```\r\n\r\nOnce Redis is installed, configure the following files in your project:\r\n```python\r\n# myproject/settings.py\r\nDATA_WIZARD {\r\n    'BACKEND': 'data_wizard.backends.celery'\r\n}\r\nCELERY_RESULT_BACKEND = BROKER_URL = 'redis://localhost:6379/1'\r\n\r\n# myproject/celery.py\r\nfrom __future__ import absolute_import\r\nfrom celery import Celery\r\nfrom django.conf import settings\r\napp = Celery('myproject')\r\napp.config_from_object('django.conf:settings')\r\napp.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\r\n\r\n# myproject/__init__.py\r\nfrom .celery import app as celery_app\r\n```\r\n\r\nFinally, run celery with `celery -A myproject`.  You may want to use celery's [daemonization] to keep the process running in the background.  Any time you change your serializer registration, be sure to reload celery in addition to restarting the Django WSGI instance.\r\n\r\n> Note that the requirement for an extra daemon means this backend can break more easily after a server restart.  Even worse, you may not notice that the backend is down for several months (e.g. until a user tries to import a spreadsheet).  For this reason, **we recommend using one of the other backends** unless you are already using celery for other background processing tasks.\r\n\r\n## wq Framework integration\r\n\r\nThe Django Data Wizard has built-in support for integration with the [wq framework].  On the server, configuration is mostly the same, except that you do not need to add `\"data_wizard.urls\"` to your urls.py as the wizard will register itself with [wq.db] instead.\r\n\r\nData Wizard provides mustache templates for each of the above tasks to integrate with the wq.app UI.  These are rendered on the server and do not need to be included in your JavaScript build.  However, you should install the [@wq/progress] plugin via NPM and register it with [@wq/app].\r\n\r\n```javascript\r\n// src/index.js\r\nimport app from '@wq/app';\r\nimport progress from '@wq/progress';\r\n\r\napp.use(progress);\r\napp.init(config).then(...);\r\n```\r\n\r\nOnce everything is set up, add the following `<form>` to the detail template that wq generates for your source model.  Note that you will need to add this `<form>` manually even if the source model is one of `data_wizard.sources`.  After adding the form, be sure to skip template regeneration for the source model.\r\n\r\n```html\r\n<!-- filesource_detail.html -->\r\n<h1>{{label}}</h1>\r\n<a href=\"{{rt}}/media/{{file}}\" rel=\"external\">Download File</a>\r\n\r\n<form action=\"{{rt}}/datawizard/\" method=\"post\">\r\n  {{>csrf}}\r\n  <input type=\"hidden\" name=\"content_type_id\" value=\"sources.filesource\">\r\n  <input type=\"hidden\" name=\"object_id\" value=\"{{id}}\">\r\n  <button type=\"submit\">Import Data from This File</button>\r\n</form>\r\n```\r\n\r\n[IterTable]: https://github.com/wq/itertable\r\n[Django REST Framework]: http://www.django-rest-framework.org/\r\n[natural keys]: https://github.com/wq/django-natural-keys\r\n[Entity-Attribute-Value]: https://wq.io/docs/eav-vs-relational\r\n[ERAV]: https://wq.io/docs/erav\r\n[vera]: https://wq.io/vera\r\n\r\n[wq.db]: https://wq.io/wq.db\r\n[custom-iter]: https://github.com/wq/itertable/blob/master/docs/about.md\r\n[Climata Viewer]: https://github.com/heigeo/climata-viewer\r\n[climata]: https://github.com/heigeo/climata\r\n[wq framework]: https://wq.io/\r\n[wq.db.rest]: https://wq.io/docs/about-rest\r\n[ModelSerializer]: http://www.django-rest-framework.org/api-guide/serializers/#modelserializer\r\n[serializers]: http://www.django-rest-framework.org/api-guide/serializers/\r\n[NaturalKeyModelSerializer]: https://github.com/wq/django-natural-keys#naturalkeymodelserializer\r\n[FileLoader]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\r\n[URLLoader]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\r\n[generic foreign key]: https://docs.djangoproject.com/en/1.11/ref/contrib/contenttypes/\r\n[data_wizard/js/progress.js]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/static/data_wizard/js/progress.js\r\n[wq/progress.js]: https://wq.io/docs/progress-js\r\n[Celery]: http://www.celeryproject.org/\r\n[Redis]: https://redis.io/\r\n[daemonization]: http://docs.celeryproject.org/en/latest/userguide/daemonizing.html\r\n[wq.app]: https://wq.io/wq.app\r\n[Celery task states]: http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-states\r\n\r\n[PrimaryKeyRelatedField]: http://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield\r\n[SlugRelatedField]: http://www.django-rest-framework.org/api-guide/relations/#slugrelatedfield\r\n\r\n[run_detail.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_detail.html\r\n[run_auto.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_auto.html\r\n[run_serializers.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_serializers.html\r\n[run_columns.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_columns.html\r\n[run_ids.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_ids.html\r\n[idmap.py]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/idmap.py\r\n[run_data.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_data.html\r\n[run_records.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_records.html\r\n\r\n[naturalkey_wizard]: https://github.com/wq/django-data-wizard/blob/master/tests/naturalkey_app/wizard.py\r\n[eav_wizard]: https://github.com/wq/django-data-wizard/blob/master/tests/eav_app/wizard.py\r\n[management command]: https://docs.djangoproject.com/en/2.1/ref/django-admin/\r\n\r\n[@wq/progress]: https://github.com/wq/django-data-wizard/tree/master/packages/progress\r\n[@wq/app]: https://wq.io/docs/app-js\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/wq/django-data-wizard",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "data-wizard-edx-copy",
    "package_url": "https://pypi.org/project/data-wizard-edx-copy/",
    "platform": null,
    "project_url": "https://pypi.org/project/data-wizard-edx-copy/",
    "project_urls": {
      "Homepage": "https://github.com/wq/django-data-wizard"
    },
    "release_url": "https://pypi.org/project/data-wizard-edx-copy/1.3.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Interactive web-based wizard for importing structured data into Django models.",
    "version": "1.3.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14107687,
  "releases": {
    "1.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "06f6f2af785647f862a59adb11e924f2221241a9297f77970f99b2756c0467d0",
          "md5": "31de601e409b3fb3c609f836ba063f67",
          "sha256": "4b23eba6fba777126f24ea84e7467589ade7f1c861d7cf511f6c7641925d8f32"
        },
        "downloads": -1,
        "filename": "data-wizard-edx-copy-1.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "31de601e409b3fb3c609f836ba063f67",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 127641,
        "upload_time": "2022-06-12T13:44:53",
        "upload_time_iso_8601": "2022-06-12T13:44:53.097001Z",
        "url": "https://files.pythonhosted.org/packages/06/f6/f2af785647f862a59adb11e924f2221241a9297f77970f99b2756c0467d0/data-wizard-edx-copy-1.3.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c0b902389b547d8cf3f04c59109d6f55ad5638217f43f0c38b960ab48e0fdfbe",
          "md5": "3b3576d08a0a9780948f718e16cc51ce",
          "sha256": "fa66fbd665e4736e67c749d7e73c6cc124032beb0d1c88075110aed48dc23430"
        },
        "downloads": -1,
        "filename": "data-wizard-edx-copy-1.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "3b3576d08a0a9780948f718e16cc51ce",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 127687,
        "upload_time": "2022-06-12T16:25:40",
        "upload_time_iso_8601": "2022-06-12T16:25:40.014363Z",
        "url": "https://files.pythonhosted.org/packages/c0/b9/02389b547d8cf3f04c59109d6f55ad5638217f43f0c38b960ab48e0fdfbe/data-wizard-edx-copy-1.3.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c0b902389b547d8cf3f04c59109d6f55ad5638217f43f0c38b960ab48e0fdfbe",
        "md5": "3b3576d08a0a9780948f718e16cc51ce",
        "sha256": "fa66fbd665e4736e67c749d7e73c6cc124032beb0d1c88075110aed48dc23430"
      },
      "downloads": -1,
      "filename": "data-wizard-edx-copy-1.3.2.tar.gz",
      "has_sig": false,
      "md5_digest": "3b3576d08a0a9780948f718e16cc51ce",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 127687,
      "upload_time": "2022-06-12T16:25:40",
      "upload_time_iso_8601": "2022-06-12T16:25:40.014363Z",
      "url": "https://files.pythonhosted.org/packages/c0/b9/02389b547d8cf3f04c59109d6f55ad5638217f43f0c38b960ab48e0fdfbe/data-wizard-edx-copy-1.3.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}