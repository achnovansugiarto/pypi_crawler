{
  "info": {
    "author": "Thor Whalen",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "- [oldpy2store](#oldpy2store)\n- [Quick peek](#quick-peek)\n- [Use cases](#use-cases)\n  * [Interfacing reads](#interfacing-reads)\n  * [Changing where and how things are stored](#changing-where-and-how-things-are-stored)\n  * [Adapters: When the learning curve is in the way of learning](#adapters--when-the-learning-curve-is-in-the-way-of-learning)\n  * [Thinking about storage later, if ever](#thinking-about-storage-later--if-ever)\n- [Remove data access entropy](#remove-data-access-entropy)\n  * [Get a key-value view of files](#get-a-key-value-view-of-files)\n    + [LocalBinaryStore: A base store for local files](#localbinarystore--a-base-store-for-local-files)\n    + [key filtering](#key-filtering)\n    + [value transformation (a.k.a. serialization and deserialization)](#value-transformation--aka-serialization-and-deserialization-)\n    + [key transformation](#key-transformation)\n    + [caching](#caching)\n    + [Aggregating these transformations to be able to apply them to other situations (DRY!)](#aggregating-these-transformations-to-be-able-to-apply-them-to-other-situations--dry--)\n  * [Other key-value views and tools](#other-key-value-views-and-tools)\n  * [Graze](#graze)\n    + [Example using baby names data](#example-using-baby-names-data)\n    + [Example using emoji image urls data](#example-using-emoji-image-urls-data)\n    + [A little oldpy2store exercise: A store to get image objects of emojis](#a-little-oldpy2store-exercise--a-store-to-get-image-objects-of-emojis)\n  * [Grub](#grub)\n    + [search your code](#search-your-code)\n    + [search jokes (and download them automatically](#search-jokes--and-download-them-automatically)\n- [More examples](#more-examples)\n  * [Looks like a dict](#looks-like-a-dict)\n  * [Converting keys: Relative paths and absolute paths](#converting-keys--relative-paths-and-absolute-paths)\n  * [Serialization/Deserialization](#serialization-deserialization)\n  * [A pickle store](#a-pickle-store)\n  * [But how do you change the persister?](#but-how-do-you-change-the-persister-)\n  * [Talk your own CRUD dialect](#talk-your-own-crud-dialect)\n  * [Transforming keys](#transforming-keys)\n- [How it works](#how-it-works)\n- [A few persisters you can use](#a-few-persisters-you-can-use)\n  * [Local Files](#local-files)\n  * [MongoDB](#mongodb)\n  * [S3, SQL, Zips, Dropbox](#s3--sql--zips--dropbox)\n- [Philosophical FAQs](#philosophical-faqs)\n  * [Is a store an ORM? A DAO?](#is-a-store-an-orm--a-dao-)\n  * [Should storage transform the data?](#should-storage-transform-the-data-)\n- [Some links](#some-links)\n\n<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>\n\n# oldpy2store\nStorage CRUD how and where you want it.\n\nList, read, write, and delete data in a structured data source/target, \nas if manipulating simple python builtins (dicts, lists), or through the interface **you** want to interact with, \nwith configuration or physical particularities out of the way. \nAlso, being able to change these particularities without having to change the business-logic code. \n\nIf you're not a \"read from top to bottom\" kinda person, here are some tips: \n[Quick peek](#quick-peek) will show you a simple example of how it looks and feels. \n[Use cases](#use-cases) will give you an idea of how oldpy2store can be useful to you, if at all. \n\nThe section with the best bang for the buck is probably \n[remove (much of the) data access entropy](#remove--much-of-the--data-access-entropy). \nIt will give you simple (but real) examples of how to use `oldpy2store` tooling \nto bend your interface with data to your will. \n\n[How it works](#how-it-works) will give you a sense of how it works.\n[More examples](#more-examples) will give you a taste of how you can adapt the three main aspects of \nstorage (persistence, serialization, and indexing) to your needs.\n\nInstall it (e.g. `pip install oldpy2store`).\n\n# Quick peek\n\nThink of type of storage you want to use and just go ahead, like you're using a dict.\nHere's an example for local storage (you must you string keys only here).\n\n```pydocstring\n>>> from oldpy2store import QuickStore\n>>>\n>>> store = QuickStore()  # will print what (tmp) rootdir it is choosing\n>>> # Write something and then read it out again\n>>> store['foo'] = 'baz'\n>>> 'foo' in store  # do you have the key 'foo' in your store?\nTrue\n>>> store['foo']  # what is the value for 'foo'?\n'baz'\n>>>\n>>> # Okay, it behaves like a dict, but go have a look in your file system,  \n>>> # and see that there is now a file in the rootdir, named 'foo'!\n>>> \n>>> # Write something more complicated\n>>> store['hello/world'] = [1, 'flew', {'over': 'a', \"cuckoo's\": map}]\n>>> stored_val = store['hello/world']\n>>> stored_val == [1, 'flew', {'over': 'a', \"cuckoo's\": map}]  # was it retrieved correctly?\nTrue\n>>>\n>>> # how many items do you have now?\n>>> assert len(store) >= 2  # can't be sure there were no elements before, so can't assert == 2\n>>> \n>>> # delete the stuff you've written\n>>> del store['foo']\n>>> del store['hello/world']\n```\n\n`QuickStore` will by default store things in local files, using pickle as the serializer.\nIf a root directory is not specified, \nit will use a tmp directory it will create (the first time you try to store something) \nIt will create any directories that need to be created to satisfy any/key/that/contains/slashes.\nOf course, everything is configurable.\n\n# Use cases\n\n## Interfacing reads\n\nHow many times did someone share some data with you in the form of a zip of some nested folders \nwhose structure and naming choices are fascinatingly obscure? And how much time do you then spend to write code \nto interface with that freak of nature? Well, one of the intents of oldpy2store is to make that easier to do. \nYou still need to understand the structure of the data store and how to deserialize these datas into python \nobjects you can manipulate. But with the proper tool, you shouldn't have to do much more than that.\n\n## Changing where and how things are stored\n\nEver have to switch where you persist things (say from file system to S3), or change the way key into your data, \nor the way that data is serialized? If you use oldpy2store tools to separate the different storage concerns, \nit'll be quite easy to change, since change will be localized. And if you're dealing with code that was already \nwritten, with concerns all mixed up, oldpy2store should still be able to help since you'll be able to\nmore easily give the new system a facade that makes it look like the old one. \n\nAll of this can also be applied to data bases as well, in-so-far as the CRUD operations you're using \nare covered by the base methods.\n\n## Adapters: When the learning curve is in the way of learning\n\nShinny new storage mechanisms (DBs etc.) are born constantly, and some folks start using them, and we are eventually lead to use them \nas well if we need to work with those folks' systems. And though we'd love to learn the wonderful new \ncapabilities the new kid on the block has, sometimes we just don't have time for that. \n\nWouldn't it be nice if someone wrote an adapter to the new system that had an interface we were familiar with? \nTalking to SQL as if it were mongo (or visa versa). Talking to S3 as if it were a file system. \nNow it's not a long term solution: If we're really going to be using the new system intensively, we \nshould learn it. But when you just got to get stuff done, having a familiar facade to something new \nis a life saver. \n\noldpy2store would like to make it easier for you roll out an adapter to be able to talk \nto the new system in the way **you** are familiar with.\n\n## Thinking about storage later, if ever\n\nYou have a new project or need to write a new app. You'll need to store stuff and read stuff back. \nStuff: Different kinds of resources that your app will need to function. Some people enjoy thinking \nof how to optimize that aspect. I don't. I'll leave it to the experts to do so when the time comes. \nOften though, the time is later, if ever. Few proof of concepts and MVPs ever make it to prod. \n\nSo instead, I'd like to just get on with the business logic and write my program. \nSo what I need is an easy way to get some minimal storage functionality. \nBut when the time comes to optimize, I shouldn't have to change my code, but instead just change the way my \nDAO does things. What I need is oldpy2store.\n\n\n# Remove data access entropy\n\nData comes from many different sources, organization, and formats. \n\nData is needed in many different contexts, which comes with its own natural data organization and formats. \n\nIn between both: A entropic mess of ad-hoc connections and annoying time-consuming and error prone boilerplate. \n\n`oldpy2store` (and it's now many extensions) is there to mitigate this. \n\nThe design gods say SOC, DRY, SOLID* and such. That's good design, yes. But it can take more work to achieve these principles. \nWe'd like to make it _easier_ to do it right than do it wrong.\n\n_(*) Separation (Of) Concerns, Don't Repeat Yourself, https://en.wikipedia.org/wiki/SOLID))_\n\nWe need to determine what are the most common operations we want to do on data, and decide on a common way to express these operations, no matter what the implementation details are. \n- get/read some data\n- set/write some data\n- list/see what data we have\n- filter\n- cache\n...\n\nLooking at this, we see that the base operations for complex data systems such as data bases and file systems overlap significantly with the base operations on python (or any programming language) objects. \n\nSo we'll reflect this in our choice of a common \"language\" for these operations. For examples, once projected to a `oldpy2store` object, iterating over the contents of a data base, or over files, or over the elements of a python (iterable) object should look the same, in code. Achieving this, we achieve SOC, but also set ourselves up for tooling that can assume this consistency, therefore be DRY, and many of the SOLID principles of design.\n\nAlso mentionable: So far, `oldpy2store` core tools are all pure python -- no dependencies on anything else. \n\nNow, when you want to specialize a store (say talk to data bases, web services, acquire special formats (audio, etc.)), then you'll need to pull in a few helpful packages. But the core tooling is pure.\n\n## Get a key-value view of files\n\nLet's get an object that gives you access to local files as if they were a dictionary (a `Mapping`). \n\n### LocalBinaryStore: A base store for local files\n\n\n```python\nimport os\nimport oldpy2store\nrootdir = os.path.dirname(oldpy2store.__file__)\nrootdir\n```\n\n\n\n\n    '/Users/Thor.Whalen/Dropbox/dev/p3/proj/i/oldpy2store/oldpy2store'\n\n\n\n\n```python\nfrom oldpy2store import LocalBinaryStore\n\ns = LocalBinaryStore(rootdir)\nlen(s)\n```\n\n\n\n\n    213\n\n\n\n\n```python\nlist(s)[:10]\n```\n\n\n\n\n    ['filesys.py',\n     'misc.py',\n     'mixins.py',\n     'test/trans_test.py',\n     'test/quick_test.py',\n     'test/util.py',\n     'test/__init__.py',\n     'test/__pycache__/simple_test.cpython-38.pyc',\n     'test/__pycache__/__init__.cpython-38.pyc',\n     'test/__pycache__/quick_test.cpython-38.pyc']\n\n\n\n\n```python\nv = s['filesys.py']\ntype(v), len(v)\n```\n\n\n\n\n    (bytes, 9470)\n\n\n\nAnd really, it's an actual `Mapping`, so you can interact with it as you would with a `dict`. \n\n\n```python\nlen(s)\ns.items()\ns.keys()\ns.values()\n'filesys.py' in s\n```\n\n\n\n\n    True\n\n\n\nIn fact more, it's a subclass of `collections.abc.MutableMapping`, so can write data to a key by doing this:\n\n```python\ns[key] = data\n```\n\nand delete a key by doing\n\n```python\ndel s[key]\n```\n\n(We're not demoing this here because we don't want you to write stuff in oldpy2store files, which we're using as a demo folder.)\n\nAlso, note that by default `oldpy2store` \"persisters\" (as these mutable mappings are called) have their `clear()` method removed to avoid mistakingly deleting a whole data base or file system. \n\n### key filtering\n\nSay you only want `.py` files...\n\n\n```python\nfrom oldpy2store import filt_iter\n\ns = filt_iter(s, filt=lambda k: k.endswith('.py'))\nlen(s)\n```\n\n\n\n\n    102\n\n\n\nWhat's the value of a key?\n\n\n```python\nk = 'filesys.py'\nv = s[k]\nprint(f\"{type(v)=}, {len(v)=}\")\n```\n\n    type(v)=<class 'bytes'>, len(v)=9470\n\n\n### value transformation (a.k.a. serialization and deserialization)\n\nFor `.py` files, it makes sense to get data as text, not bytes. \nSo let's tell our reader/store that's what we want...\n\n\n```python\nfrom oldpy2store import wrap_kvs\n\ns = wrap_kvs(s, obj_of_data=lambda v: v.decode())\n\nv = s[k]  # let's get the value of that key again\nprint(f\"{type(v)=}, {len(v)=}\")  # and see what v is like now...\n```\n\n    type(v)=<class 'str'>, len(v)=9470\n\n\n\n```python\nprint(v[:300])\n```\n\n    import os\n    from os import stat as os_stat\n    from functools import wraps\n\n    from oldpy2store.base import Collection, KvReader, KvPersister\n    from oldpy2store.key_mappers.naming import (\n        mk_pattern_from_template_and_format_dict,\n    )\n    from oldpy2store.key_mappers.paths import mk_relative_path_store\n\n    file_sep = os.pat\n\n\n### key transformation\n\nThat was \"value transformation\" (in many some cases, known as \"(de)serialization\"). \n\nAnd yes, if you were interested in transforming data on writes (a.k.a. serialization), you can specify that too.\n\nOften it's useful to transform keys too. Our current keys betray that a file system is under the hood; We have extensions (`.py`) and file separators. \nThat's not pure `SOC`. \n\nNo problem, let's transform keys too, using tuples instead...\n\n\n```python\ns = wrap_kvs(s, \n             key_of_id=lambda _id: tuple(_id[:-len('.py')].split(os.path.sep)),\n             id_of_key=lambda k: k + '.py' if isinstance(k, str) else os.path.sep.join(k) + '.py'\n            )\nlist(s)[:10]\n```\n\n\n\n\n    [('filesys',),\n     ('misc',),\n     ('mixins',),\n     ('test', 'trans_test'),\n     ('test', 'quick_test'),\n     ('test', 'util'),\n     ('test', '__init__'),\n     ('test', 'local_files_test'),\n     ('test', 'simple_test'),\n     ('test', 'scrap')]\n\n\n\nNote that we made it so that when there's only one element, you can specify as string itself: both `s['filesys']` or `s[('filesys',)]` are valid\n\n\n```python\nprint(s['filesys'][:300])\n```\n\n    import os\n    from os import stat as os_stat\n    from functools import wraps\n\n    from oldpy2store.base import Collection, KvReader, KvPersister\n    from oldpy2store.key_mappers.naming import (\n        mk_pattern_from_template_and_format_dict,\n    )\n    from oldpy2store.key_mappers.paths import mk_relative_path_store\n\n    file_sep = os.pat\n\n\n### caching\n\nAs of now, every time you iterate over keys, you ask the file system to list files, then filter them (to get only `.py` files). \n\nThat's not a big deal for a few hundred files, but if you're dealing with lots of files you'll feel the slow-down (and your file system will feel it too). \n\nIf you're not deleting or creating files in the root folder often (or don't care about freshness), your simplest solution is to cache the keys.\n\nThe simplest would be to do this:\n\n```python\nfrom oldpy2store import cached_keys\ns = cached_keys(s)\n```\n\nOnly, you won't really see the difference if we just do that (unless your rootdir has many many files). \n\nBut `cached_keys` (as the other functions we've introduced above) has more too it, and we'll demo that here so you can actually observe a difference. \n\n`cached_keys` has a (keyword-only) argument called `keys_cache` that specifies what to cache the keys into (more specifically, what function to call on the first key iteration (when and if it happens)). The default is `keys_cache`. But say we wanted to always get our keys in sorted order. \n\nWell then...\n\n\n```python\nfrom oldpy2store import cached_keys\n\ns = cached_keys(s, keys_cache=sorted)\nlist(s)[:10]\n```\n\n\n\n\n    [('__init__',),\n     ('access',),\n     ('appendable',),\n     ('base',),\n     ('caching',),\n     ('core',),\n     ('dig',),\n     ('errors',),\n     ('examples', '__init__'),\n     ('examples', 'code_navig')]\n\n\n\nNote that there's a lot more too caching. We'll just mention two useful things to remember here:\n\n- You can use `keys_cache` to specify a \"precomputed/explicit\" collection of keys to use in the store. This allows you to have full flexibility on defining sub-sets of stores.\n\n- Here we talked about caching keys, but caching values is arguably more important. If it takes a long time to fetch remote data, you want to cache it locally. Further, if loading data from local storage to RAM is creating lag, you can cache in RAM. And you can do all this easily (and separate from the concern of both source and cache stores) using tools you an find in `oldpy2store.caching`. \n\n### Aggregating these transformations to be able to apply them to other situations (DRY!)\n\n\n```python\nfrom lined import Line  # Line just makes a function by composing/chaining several functions\nfrom oldpy2store import LocalBinaryStore, filt_iter, wrap_kvs, cached_keys\n\nkey_filter_wrapper = filt_iter(filt=lambda k: k.endswith('.py'))\n\nkey_and_value_wrapper = wrap_kvs(\n    obj_of_data=lambda v: v.decode(),\n    key_of_id=lambda _id: tuple(_id[:-len('.py')].split(os.path.sep)),\n    id_of_key=lambda k: k + '.py' if isinstance(k, str) else os.path.sep.join(k) + '.py'\n)\n\ncaching_wrapper = cached_keys(keys_cache=sorted)\n\n# my_cls_wrapper is basically the pipeline: input -> key_filter_wrapper -> key_and_value_wrapper -> caching_wrapper\nmy_cls_wrapper = Line(key_filter_wrapper, key_and_value_wrapper, caching_wrapper)  \n\n@my_cls_wrapper\nclass PyFilesReader(LocalBinaryStore):\n    \"\"\"Access to local .py files\"\"\"\n\n\ns = PyFilesReader(rootdir)\nlen(s)\n```\n\n\n\n\n    102\n\n\n\n\n```python\nlist(s)[:10]\n```\n\n\n\n\n    [('__init__',),\n     ('access',),\n     ('appendable',),\n     ('base',),\n     ('caching',),\n     ('core',),\n     ('dig',),\n     ('errors',),\n     ('examples', '__init__'),\n     ('examples', 'code_navig')]\n\n\n\n\n```python\nprint(s['caching'][:300])\n```\n\n    \"\"\"Tools to add caching layers to stores.\"\"\"\n\n    from functools import wraps, partial\n    from typing import Iterable, Union, Callable, Hashable, Any\n\n    from oldpy2store.trans import store_decorator\n\n\n    ###############################################################################################################\n\n\n## Other key-value views and tools\n\nNow that you've seen a few tools (key/value transformation, filtering and caching) you can use to change one mapping to another, what about getting a mapping (i.e. \"`dict`-like\") view of a data source in the first place? \n\nIf you're advanced, you can just make your own by sub-classing `KvReader` or `KvPersister`, and adding the required `__iter__` and `__getitem__` methods (as well as `__setitem__` and `__delitem__` for `KvPersister`, if you want to be able to write/delete data too). \n\nBut we (and others) are offer an ever growing slew of mapping views of all kinds of data sources. \n\nHere are a few you can check out:\n\nThe classics (data bases and storage systems):\n\n```python\nfrom oldpy2store import (\n    S3BinaryStore,  # to talk to AWS S3  (uses boto)\n    SQLAlchemyStore,  # to talk to sql (uses alchemy)\n)\n# from oldpy2store.stores.mongo_store import MongoStore  # moved to mongodol\n```\n\nTo access configs and customized store specifications:\n\n```python\nfrom oldpy2store import (\n    myconfigs,\n    mystores\n)\n```\n\nTo access contents of zip files:    \n\n```python\nfrom oldpy2store import (\n    FilesOfZip, \n    FlatZipFilesReader,   \n)\n```\n\nTo customize the format you want your data in (depending on the context... like a file extension):\n\n```python\nfrom oldpy2store.misc import (\n    get_obj,\n    MiscReaderMixin,\n    MiscStoreMixin,\n    MiscGetterAndSetter,\n\n)\n```\n\nTo define string, tuple, or dict formats for keys, and move between them:\n\n```python\nfrom oldpy2store.key_mappers.naming import StrTupleDict\n```\n\nBut probably the best way to learn the way of `oldpy2store` is to see how easily powerful functionalities can be made with it.\n\nWe'll demo a few of these now.\n\n## Graze\n\n[graze](https://github.com/thorwhalen/graze)'s jingle is _\"Cache the internet\"_. \n\nThat's (sort of) what it does. \n\nGraze is a mapping that uses urls as keys, pulling content from the internet and caching to local files. \n\nQuite simply:\n\n```python\nfrom graze import Graze\ng = Graze()\nlist(g)  # lists the urls you already have locally\ndel g[url]  # deletes that local file you have cached\nb = g[url]  # gets the contents of the url (taken locally if there, or downloading from the internet (and caching locally) if not. \n```\n\nMain use case: Include the data acquisition code in your usage code. \n\nSuppose you want to write some code that uses some data. You need that data to run the analyses. What do you do? \n- write some instructions on where and how to get the data, where to put it in the file system, and/or what config file or environment variable to tinker with to tell it where that data is, or...\n- use graze\n\nSince it's implemented as a mapping, you can easily transform it to do all kinds of things (namely, using [oldpy2store tools](https://github.com/i2mint/oldpy2store)). Things like\n- getting your content in a more ready-to-use object than bytes, or\n- putting an expiry date on some cached items, so that it will automatically re-fresh the data\n\nThe [original code](https://github.com/thorwhalen/graze/blob/ed8b6d4b5334996f91c508dfe6049d2243fa6740/graze/__init__.py) \nof Graze was effectively 57 lines (47 without imports). [Check it out](https://github.com/thorwhalen/graze/blob/ed8b6d4b5334996f91c508dfe6049d2243fa6740/graze/__init__.py). That's because it it had to do is:\n- define url data fetching as `internet[url]`\n- define a local files (py2)store\n- connect both through caching logic\n- do some key mapping to get from url to local path and visa-versa\n\nAnd all those things are made easy with [oldpy2store](https://github.com/i2mint/oldpy2store).\n\n\n```python\nfrom graze import Graze\n\ng = Graze()  # uses a default directory to store stuff, but is customizable\nlen(g)  # how many grazed files do we have?\n```\n\n\n\n\n    52\n\n\n\n\n```python\nsorted(g)[:3]  # first (in sorted order) 3 keys\n```\n\n\n\n\n    ['http://www.ssa.gov/oact/babynames/state/namesbystate.zip',\n     'https://api.nasdaq.com/api/ipo/calendar?date=2020-12',\n     'https://en.wikipedia.org/wiki/List_of_chemical_elements']\n\n\n\n### Example using baby names data\n\n\n```python\nfrom io import BytesIO\nimport pandas as pd\nfrom oldpy2store import FilesOfZip\n\n# getting the raw data\nurl = 'http://www.ssa.gov/oact/babynames/state/namesbystate.zip'  # this specifies both where to get the data from, and where to put it locally!\nb = g[url]\nprint(f\"b is an array of {len(b)} {type(b)} of a zip. We'll give these to FilesOfZip to be able to read them\")\n\n# formatting it to be useful\nz = FilesOfZip(b)\nprint(f\"First 4 file names in the zip: {list(z)[:4]}\")\nv = z['AK.TXT']  # bytes of that (zipped) file\ndf = pd.read_csv(BytesIO(v), header=None)\ndf.columns = ['state', 'gender', 'year', 'name', 'number']\ndf\n```\n\n    b is an array of 22148032 <class 'bytes'> of a zip. We'll give these to FilesOfZip to be able to read them\n    First 4 file names in the zip: ['AK.TXT', 'AL.TXT', 'AR.TXT', 'AZ.TXT']\n\n\n\n\n\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>state</th>\n      <th>gender</th>\n      <th>year</th>\n      <th>name</th>\n      <th>number</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>AK</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>14</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>AK</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Annie</td>\n      <td>12</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>AK</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Anna</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>AK</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>AK</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>28957</th>\n      <td>AK</td>\n      <td>M</td>\n      <td>2019</td>\n      <td>Patrick</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>28958</th>\n      <td>AK</td>\n      <td>M</td>\n      <td>2019</td>\n      <td>Ronin</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>28959</th>\n      <td>AK</td>\n      <td>M</td>\n      <td>2019</td>\n      <td>Sterling</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>28960</th>\n      <td>AK</td>\n      <td>M</td>\n      <td>2019</td>\n      <td>Titus</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>28961</th>\n      <td>AK</td>\n      <td>M</td>\n      <td>2019</td>\n      <td>Tucker</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n<p>28962 rows × 5 columns</p>\n</div>\n\n\n\n### Example using emoji image urls data\n\n\n```python\nurl = 'https://raw.githubusercontent.com/thorwhalen/my_sources/master/github_emojis.json'\nif url in g:  # if we've cached this already\n    del g[url]  # remove it from cache\nassert url not in g\n```\n\n\n```python\nimport json\nd = json.loads(g[url].decode())\nlen(d)\n```\n\n\n\n\n    1510\n\n\n\n\n```python\nlist(d)[330:340]\n```\n\n\n\n\n    ['couple_with_heart_woman_man',\n     'couple_with_heart_woman_woman',\n     'couplekiss_man_man',\n     'couplekiss_man_woman',\n     'couplekiss_woman_woman',\n     'cow',\n     'cow2',\n     'cowboy_hat_face',\n     'crab',\n     'crayon']\n\n\n\n\n```python\nd['cow']\n```\n\n\n\n\n    'https://github.githubassets.com/images/icons/emoji/unicode/1f42e.png?v8'\n\n\n\n### A little oldpy2store exercise: A store to get image objects of emojis\n\nAs a demo of oldpy2store, let's make a store that allows you to get (displayable) image objects of emojis, taking care of downloading and caching \nthe name:url information for you.\n\n\n```python\nfrom functools import cached_property\nimport json\n\nfrom oldpy2store import KvReader\nfrom graze import graze\n\nclass EmojiUrls(KvReader):\n    \"\"\"A store of emoji urls. Will automatically download and cache emoji (name, url) map to a local file when first used.\"\"\"\n    data_source_url = 'https://raw.githubusercontent.com/thorwhalen/my_sources/master/github_emojis.json'\n\n    @cached_property\n    def data(self):\n        b = graze(self.data_source_url)  # does the same thing as Graze()[url]\n        return json.loads(b.decode())\n\n    def __iter__(self):\n        yield from self.data\n\n    def __getitem__(self, k):\n        return self.data[k]\n\n    # note, normally you would define an explicit __len__ and __contains__ to make these more efficient\n\nemojis = EmojiUrls()\nlen(emojis), emojis['cow']\n```\n\n\n\n\n    (1510,\n     'https://github.githubassets.com/images/icons/emoji/unicode/1f42e.png?v8')\n\n\n\n\n```python\nfrom IPython.display import Image\nimport requests\nfrom oldpy2store import wrap_kvs, add_ipython_key_completions\n\n@add_ipython_key_completions  # this enables tab-completion of keys in jupyter notebooks\n@wrap_kvs(obj_of_data=lambda url: Image(requests.get(url).content))\nclass EmojiImages(EmojiUrls):\n    \"\"\"An emoji reader returning Image objects (displayable in jupyter notebooks)\"\"\"\n\n\nemojis = EmojiImages()\nlen(emojis)\n```\n\n\n\n\n    1510\n\n\n\n\n```python\nemojis['cow']\n```\n\n\n![png](https://github.githubassets.com/images/icons/emoji/unicode/1f42e.png?v8)\n\n\n## Grub\n\nQuick and easy search engine of anything (that can be expressed as a key-value store of text).\n\n### search your code\n\n```python\n# Make a store to search in (only requirements is that it provide text values)\nimport os\nimport oldpy2store\nrootdir = os.path.dirname(oldpy2store.__file__)\nstore_to_search = LocalBinaryStore(os.path.join(rootdir) + '{}.py')  # The '{}.py' is a short-hand of LocalBinaryStore to filter for .py files only\n\n# make a search object for that store\nfrom grub import SearchStore\nsearch = SearchStore(store_to_search)\n```\n\n\n```python\nsearch('cache key-value pairs')\n```\n\n    array(['oldpy2store/caching.py', 'oldpy2store/utils/cumul_aggreg_write.py',\n           'oldpy2store/trans.py', 'oldpy2store/examples/write_caches.py',\n           'oldpy2store/utils/cache_descriptors.py',\n           'oldpy2store/utils/explicit.py',\n           'oldpy2store/persisters/arangodb_w_pyarango.py',\n           'oldpy2store/persisters/dynamodb_w_boto3.py',\n           'oldpy2store/stores/delegation_stores.py', 'oldpy2store/util.py'],\n          dtype=object)\n### search jokes (and download them automatically\n\nSome code that acquires and locally caches a joke data, makes a mapping view of it (here just a `dict` in memory), and builds a search engine to find jokes. All that, in a few lines.\n\n\n```python\nimport json\nfrom graze.base import graze\nfrom grub import SearchStore\n\n# reddit jokes (194553 at the time of writing this)\njokes_url = 'https://raw.githubusercontent.com/taivop/joke-dataset/master/reddit_jokes.json'\nraw_data = json.loads(graze(jokes_url).decode())\njoke_store = {x['id']: f\"{x['title']}\\n--> {x['body']}\\n(score: {x['score']})\" for x in raw_data}\nsearch_joke = SearchStore(joke_store)\n```\n\n\n```python\nresults_idx = search_joke('searching for something funny')\nprint(joke_store[results_idx[0]])  # top joke (not by score, but by relevance to search terms)\n```\n\n    want to hear me say something funny?\n    --> well alright then....\"something funny\" there\n    (score: 0)\n\n\n\n# More examples\n\n## Looks like a dict\nBelow, we make a default store and demo a few basic operations on it.\nThe default store uses a dict as it's backend persister. \nA dict is neither really a backend, nor a persister. But it helps to try things out with no\nfootprint.\n\n```python\nfrom oldpy2store.base import Store\n\ns = Store()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'bar'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['bar']  # list all the values\nassert len(s) == 1  # Number of items in my store\ns['another'] = 'item'  # store another item\nassert len(s) == 2  # Now I have two!\nassert list(s) == ['foo', 'another']  # here they are\n```\n\nThere's nothing fantastic in the above code. \nI've just demoed some operations on a dict.\nBut it's exactly this simplicity that oldpy2store aims for. \nYou can now replace the `s = Store()` with `s = AnotherStore(...)` where `AnotherStore` \nnow uses some other backend that could be remote or local, could be a database, or any \nsystem that can store `something` (the value) `somewhere` (the key).\n\nYou can choose from an existing store (e.g. local files, for AWS S3, for MongoDB) or \nquite easily make your own (more on that later).\n\nAnd yet, it will still look like you're talking to a dict. This not only means that you can \ntalk to various storage systems without having to actually learn how to, but also means \nthat the same business logic code you've written can be reused with no modification. \n\nBut oldpy2store offers more than just a simple consistent facade to **where** you store things, \nbut also provides means to define **how** you do it.\n\nIn the case of key-value storage, the \"how\" is defined on the basis of the keys (how you reference) \nthe objects you're storing and the values (how you serialize and deserialize those objects).\n\n\n## Converting keys: Relative paths and absolute paths\nTake a look at the following example, that adds a layer of key conversion to a store.\n\n```python\n# defining the store\nfrom oldpy2store.base import Store\n\nclass PrefixedKeyStore(Store):\n    prefix = ''\n    def _id_of_key(self, key):\n        return self.prefix + key  # prepend prefix before passing on to store\n    def _key_of_id(self, _id):\n        if not _id.startswith(self.prefix):\n            raise ValueError(f\"_id {_id} wasn't prefixed with {self.prefix}\")\n        else:\n            return _id[len(self.prefix):]  # don't show the user the prefix\n\n# trying the store out            \ns = PrefixedKeyStore()\ns.prefix = '/ROOT/'\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'bar'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['bar']  # list all the values\nassert len(s) == 1  # Number of items in my store\ns['another'] = 'item'  # store another item\nassert len(s) == 2  # Now I have two!\nassert list(s) == ['foo', 'another']  # here they are      \n```\n\n\nQ: That wasn't impressive! It's just the same as the first Store. What's this prefix all about?\n\nA: The prefix thing is hidden, and that's the point. You want to talk the \"relative\" (i.e \"prefix-free\")\nlanguage, but may have the need for this prefix to be prepended to the key before persisting the data\nand that prefix to be removed before being displayed to the user. \nThink of working with files. Do you want to have to specify the root folder every time you store something\nor retrieve something?\n\nQ: Prove it!\n\nA: Okay, let's look under the hood at what the underlying store (a dict) is dealing with:\n\n```python\nassert list(s.store.items()) == [('/ROOT/foo', 'bar'), ('/ROOT/another', 'item')]\n```\n\nYou see? The keys that the \"backend\" is using are actually prefixed with `\"/ROOT/\"`\n\n## Serialization/Deserialization\n\nLet's now demo serialization and deserialization. \n\nSay we want to deserialize any text we stored by appending `\"hello \"` to everything stored.\n\n```python\n# defining the store\nfrom oldpy2store.base import Store\n\nclass MyFunnyStore(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n\n# trying the store out            \ns = MyFunnyStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'hello bar'  # the value that 'foo' contains SEEMS to be 'hello bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'hello bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['hello bar']  # list all the values    \n```\n\nNote: This is an easy example to demo on-load transformation of data (i.e. deserialization), \nbut wouldn't be considered \"deserialization\" by all. \nSee the [Should storage transform the data?](#should-storage-transform-the-data) discussion below.\n\nIn the following, we want to serialize our text by upper-casing it (and see it as such) \nwhen we retrieve the text.\n\n```python\n# defining the store\nfrom oldpy2store.base import Store\n\nclass MyOtherFunnyStore(Store):\n    def _data_of_obj(self, obj):\n        return obj.upper()\n\n# trying the store out              \ns = MyOtherFunnyStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'BAR'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'BAR')]  # list all the (key, value) pairs\nassert list(s.values()) == ['BAR']  # list all the values\n``` \n\nIn the last to serialization examples, we only implemented one way transformations. \nThat's all fine if you just want to have a writer (so only need a serializer) or a reader (so only \nneed a deserializer). \nIn most cases though, you will need two way transformations, specifying how the object \nshould be serialized to be stored, and how it should be deserialized to get your object back. \n\n\n## A pickle store\n\nSay you wanted the store to pickle as your serializer. Here's how this could look like.\n\n```python\n# defining the store\nimport pickle\nfrom oldpy2store.base import Store\n\n\nclass PickleStore(Store):\n    protocol = None\n    fix_imports = True\n    encoding = 'ASCII'\n    def _data_of_obj(self, obj):  # serializer\n        return pickle.dumps(obj, protocol=self.protocol, fix_imports=self.fix_imports)\n    def _obj_of_data(self, data):  # deserializer\n        return pickle.loads(data, fix_imports=self.fix_imports, encoding=self.encoding)\n\n# trying the store out              \ns = PickleStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert s['foo'] == 'bar'  # I can get 'bar' back\n# behind the scenes though, it's really a pickle that is stored:\nassert s.store['foo'] == b'\\x80\\x03X\\x03\\x00\\x00\\x00barq\\x00.'\n``` \n\nAgain, it doesn't seem that impressive that you can get back a string that you stored in a dict. \nFor two reasons: (1) you don't really need to serialize strings to store them and (2) you don't need to serialize python \nobjects to store them in a dict. \nBut if you (1) were trying to store more complex types and (2) were actually persisting them in a file system or database, \nthen you'll need to serialize.\nThe point here is that the serialization and persisting concerns are separated from the storage and retrieval concern. \nThe code still looks like you're working with a dict.\n\n## But how do you change the persister?\n\nBy using a persister that persists where you want. \nYou can also write your own. All a persister needs to work with oldpy2store is that it follows the interface \npython's `collections.MutableMapping` (or a subset thereof). More on how to make your own persister later\nYou just need to follow the collections.MutableMapping interface. \n\nBelow a simple example of how to persist in files under a given folder.\n(Warning: If you want a local file store, don't use this, but one of the easier to use, robust and safe stores in the \nstores folder!)\n\n```python\nimport os\nfrom collections.abc import MutableMapping\n\nclass SimpleFilePersister(MutableMapping):\n    \"\"\"Read/write (text or binary) data to files under a given rootdir.\n    Keys must be absolute file paths.\n    Paths that don't start with rootdir will be raise a KeyValidationError\n    \"\"\"\n\n    def __init__(self, rootdir, mode='t'):\n        if not rootdir.endswith(os.path.sep):\n            rootdir = rootdir + os.path.sep\n        self.rootdir = rootdir\n        assert mode in {'t', 'b', ''}, f\"mode ({mode}) not valid: Must be 't' or 'b'\"\n        self.mode = mode\n\n    def __getitem__(self, k):\n        with open(k, 'r' + self.mode) as fp:\n            data = fp.read()\n        return data\n\n    def __setitem__(self, k, v):\n        with open(k, 'w' + self.mode) as fp:\n            fp.write(v)\n\n    def __delitem__(self, k):\n        os.remove(k)\n\n    def __contains__(self, k):\n        \"\"\" Implementation of \"k in self\" check.\n        Note: MutableMapping gives you this for free, using a try/except on __getitem__,\n        but the following uses faster os functionality.\"\"\"\n        return os.path.isfile(k)\n\n    def __iter__(self):\n        yield from filter(os.path.isfile, \n                          map(lambda x: os.path.join(self.rootdir, x), \n                              os.listdir(self.rootdir)))\n\n    def __len__(self):\n        \"\"\"Note: There's system-specific faster ways to do this.\"\"\"\n        count = 0\n        for _ in self.__iter__():\n            count += 1\n        return count\n\n    def clear(self):\n        \"\"\"MutableMapping creates a 'delete all' functionality by default. Better disable it!\"\"\"\n        raise NotImplementedError(\"If you really want to do that, loop on all keys and remove them one by one.\")\n```\n\nNow try this out:\n```python\nimport os\n# What folder you want to use. Defaulting to the home folder. You can choose another place, but make sure \nrootdir = os.path.expanduser('~/')  # Defaulting to the home folder. You can choose another place\n\npersister = SimpleFilePersister(rootdir)\nfoo_fullpath = os.path.join(rootdir, 'foo')\npersister[foo_fullpath] = 'bar'  # write 'bar' to a file named foo_fullpath\nassert persister[foo_fullpath] == 'bar'  # see that you can read the contents of that file to get your 'bar' back\nassert foo_fullpath in persister  # the full filepath indeed exists in (i.e. \"is a key of\") the persister\nassert foo_fullpath in list(persister)  # you can list all the contents of the rootdir and file foo_fullpath in it\n```\n\n## Talk your own CRUD dialect\n\nDon't like this dict-like interface? Want to talk **your own** CRUD words? \nWe got you covered! Just subclass `SimpleFilePersister` and make the changes you want to make:\n\n```python\nclass MySimpleFilePersister(SimpleFilePersister):    \n    # If it's just renaming, it's easy\n    read = SimpleFilePersister.__getitem__\n    exists = SimpleFilePersister.__contains__\n    n_files = SimpleFilePersister.__len__\n\n    # here we want a new method that gives us an actual list of the filepaths in the rootdir\n    list_files = lambda self: list(self.__iter__())\n\n    # And for write we want val and key to be swapped in our interface, \n    def write(self, val, key):  # note that we wanted val to come first here (as with json.dump and pickle.dump interface)\n        return self.__setitem__(key, val)  \n\nmy_persister = MySimpleFilePersister(rootdir)\n\nfoo_fullpath = os.path.join(rootdir, 'foo1')\nmy_persister.write('bar1', foo_fullpath)  # write 'bar1' to a file named foo_fullpath\nassert my_persister.read(foo_fullpath) == 'bar1'  # see that you can read the contents of that file to get your 'bar1' back\nassert my_persister.exists(foo_fullpath)  # the full filepath indeed exists in (i.e. \"is a key of\") the persister\nassert foo_fullpath in my_persister.list_files()  # you can list all the contents of the rootdir and file foo_fullpath in it\n```\n\n## Transforming keys\n\nBut dealing with full paths can be annoying, and might couple code too tightly with a particular local system.\nWe'd like to use relative paths instead. \nEasy: Wrap the persister in the `PrefixedKeyStore` defined earlier. \n\n```python\ns = PrefixedKeyStore(store=persister)  # wrap your persister with the PrefixedKeyStore defined earlier\nif not rootdir.endswith(os.path.sep): \n    rootdir = rootdir + os.path.sep  # make sure the rootdir ends with slash\ns.prefix = rootdir  # use rootdir as prefix in keys\n\ns['foo2'] = 'bar2'  # write 'bar2' to a file \nassert s['foo2'] == 'bar2'  # see that you can read the contents of that file to get your 'bar2' back\nassert 'foo2' in s  \nassert 'foo2' in list(s)  \n```\n\n# How it works\n\noldpy2store offers three aspects that you can define or modify to store things where you like and how you like it:\n* **Persistence**: Where things are actually stored (memory, files, DBs, etc.)\n* **Serialization**: Value transformaton. \nHow python objects should be transformed before it is persisted, \nand how persisted data should be transformed into python objects.\n* **Indexing**: Key transformation. How you name/id/index your data. \nFull or relative paths. Unique combination of parameters (e.g. (country, city)). Etc.\n\nAll of this allows you to do operations such as \"store this (value) in there (persitence) as that (key)\", \nmoving the tedious particularities of the \"in there\" as well how the \"this\" and \"that\" are transformed to fit \nin there, all out of the way of the business logic code. The way it should be.\n\n![alt text](img/oldpy2store_how_it_works.png)\n\nNote: Where data is actually persisted just depends on what the base CRUD methods \n(`__getitem__`, `__setitem__`, `__delitem__`, `__iter__`, etc.) define them to be. \n\n# A few persisters you can use\n\nWe'll go through a few basic persisters that are ready to use.\nThere are more in each category, and we'll be adding new categories, but \nthis should get you started.\n\nHere is a useful function to perform a basic test on a store, given a key and value.\nIt doesn't test all store method (see test modules for that), but demos \nthe basic functionality that pretty much every store should be able to do.\n\n```python\ndef basic_test(store, k='foo', v='bar'):\n    \"\"\" This test performs \n    Warning: Don't use on a key k that you don't want to loose!\"\"\"\n    if k in store:  # deleting all docs in tmp\n        del store[k]\n    assert (k in store) == False  # see that key is not in store (and testing __contains__)\n    orig_length = len(store)  # the length of the store before insertion\n    store[k] = v  # write v to k (testing __setitem__)\n    assert store[k] == v  # see that the value can be retrieved (testing __getitem__, and that __setitem__ worked)\n    assert len(store) == orig_length + 1  # see that the number of items in the store increased by 1\n    assert (k in store) == True  # see that key is in store now (and testing __contains__ again)\n    assert k in list(store)  # testing listing the (key) contents of a store (and seeing if )\n    assert store.get(k) == v  # the get method\n    _ = next(iter(store.keys()))  # get the first key (test keys method)\n    _ = next(iter(store.__iter__()))  # get the first key (through __iter__)\n    k in store.keys()  # test that the __contains__ of store.keys() works\n\n    try: \n        _ = next(iter(store.values()))  # get the first value (test values method)\n        _ = next(iter(store.items()))  # get the first (key, val) pair (test items method)\n    except Exception:\n        print(\"values() (therefore items()) didn't work: Probably testing a persister that had other data in it that your persister doesn't like\")\n\n    assert (k in store) == True # testing __contains__ again\n    del store[k]  # clean up (and test delete)\n```\n## Local Files\n\nThere are many choices of local file stores according to what you're trying to do. \nOne general (but not too general) purpose local file store is \n'oldpy2store.stores.local_store.RelativePathFormatStoreEnforcingFormat'.\nIt can do a lot for you, like add a prefix to your keys (so you can talk in relative instead of absolute paths),\nlists all files in subdirectories as well recursively, \nonly show you files that have a given pattern when you list them, \nand not allow you to write to a key that doesn't fit the pattern. \nFurther, it also has what it takes to create parametrized paths or parse out the parameters of a path. \n\n```python\nfrom oldpy2store.stores.local_store import RelativePathFormatStoreEnforcingFormat as LocalFileStore\nimport os\n\nrootdir = os.path.expanduser('~/pystore_tests/')  # or replace by the folder you want to use\nos.makedirs(rootdir, exist_ok=True)  # this will make all directories that don't exist. Don't use if you don't want that.\n\nstore = LocalFileStore(path_format=rootdir)\nbasic_test(store, k='foo', v='bar')\n```\n\nThe signature of LocalFileStore is:\n```python\nLocalFileStore(path_format, mode='',\n                buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n```\n\nOften path_format is just used to specify the rootdir, as above. \nBut you can specify the desired format further.\nFor example, the following will only yield .wav files, \nand only allow you to write to keys that end with .wav:\n```python\nstore = LocalFileStore(path_format='/THE/ROOT/DIR/{}.wav')\n```\n\nThe following will additional add the restriction that those .wav files have the format 'SOMESTRING_' \nfollowed by digits:\n```python\nstore = LocalFileStore(path_format='/THE/ROOT/DIR/{:s}_{:d}.wav')\n```\n\nYou get the point...\n\nThe other arguments of LocalFileStore or more or less those of python's `open` function.\nThe slight difference is that here the `mode` argument applies both to read and write. \nIf `mode='b'` for example, the file will be opened with `mode='rb'` when opened to read and\nwith `mode='wb'` when opened to write. For assymetrical read/write modes, the \nuser can specify a `read_mode` and `write_mode` (in this case the `mode` argument is ignored).\n\n## MongoDB\n\nA MongoDB collection is not as naturally a key-value storage as a file system is.\nMongoDB stores \"documents\", which are JSONs of data, having many (possibly nested) fields that are not \nby default enforced by a schema. So in order to talk to mongo as a key-value store, we need to \nspecify what fields should be considered as keys, and what fields should be considered as data. \n\nBy default, the `_id` field (the only field ensured by default to contain unique values) is the single key field, and \nall other fields are considered to be data fields.\n\nNote: oldpy2store mongo tools have now been moved to the mongodol project. Import from there.\nRequires `pymongo`.\n\n```python\nfrom mongodol.stores import MongoStore  # Note: project moved to mongodol now\n# The following makes a default MongoStore, the default pymongo.MongoClient settings, \n# and db_name='oldpy2store', collection_name='test', key_fields=('_id',)\nstore = MongoStore()\nbasic_test(store, k={'_id': 'foo'}, v={'val': 'bar', 'other_val': 3})\n```\n\nBut it can get annoying to specify the key as a dict every time.\nThe key schema is fixed, so you should be able to just specify the tuple of values making the keys.\nAnd you can, with MongoTupleKeyStore\n\n```python\nfrom mongodol.stores import MongoTupleKeyStore  # Note: project moved to mongodol now\nstore = MongoTupleKeyStore(key_fields=('_id', 'name'))\nbasic_test(store, k=(1234, 'bob'), v={'age': 42, 'gender': 'unspecified'})\n```\n\n## S3, SQL, Zips, Dropbox\n\nS3 persister/stores work pretty much like LocalStores, but stores in S3. You'll need to have an account with \nAWS to use this. Find S3 stores in oldpy2store.stores.s3_stores.\n\nSQL give you read and write access to SQL DBs and tables. \n\nZipReader (and other related stores) talks to one or several files, giving you the ability to operate as if the zips were uncompressed. \n\nDropbox will give you access to dropbox files through the same dict-like interface.\n\n\n# Miscellenous\n\n## Caching\n\nThere's some basic caching capabilities in oldpy2store. \nBasic, but covers a lot of use cases. \nBut if you want to bring your own caching tools, you might be able to use them here too. \n\nFor example, the very popular `cachetools` uses a ``dict`` as it's default cache store, but you can \nspecify any mutable mapping (that takes tuples as keys!). \n\nSay you want to use local files as your cache. Try something like this:\n\n```python\nfrom cachetools import cached # there's also LRUCache, TTLCache...\nfrom oldpy2store import QuickPickleStore, wrap_kvs\n\ndef tuple_to_str(k: tuple, sep: str=os.path.sep) -> str:\n    return sep.join(k)\n    if isinstance(k, tuple):\n        return os.path.sep.join(k)\n    else:\n        return k\n\ndef str_to_tuple(k: str, sep: str=os.path.sep) -> tuple:\n    return k.split(sep)\n\n@wrap_kvs(id_of_key=tuple_to_str, key_of_id=str_to_tuple)\nclass TupledQuickPickleStore(QuickPickleStore):\n    \"\"\"A local pickle store with tuple keys (to work well with cachetools)\"\"\"\n\n\nlocal_files_cache = TupledQuickPickleStore()  # no rootdir? Fine, will choose a local file\n\n@cached(cache=local_files_cache)\ndef hello(x='world'):\n    return f\"hello {x}!\"\n```\n\n```pydocstring\n>>> hello('QT')\n>>> import pickle\n>>> # Let's now verify that we actually have a file with such content\n>>> with open(os.path.join(local_files_cache._prefix, 'QT'), 'rb') as fp:\n...     file_contents = pickle.load(fp)\n>>> assert file_contents == 'hello QT!'\n```\n\n\n# Philosophical FAQs\n\n## Is a store an ORM? A DAO?\n\nCall it what you want, really.\n\nIt would be tempting to coin oldpy2store as ya(p)orm (yet another (python) object-relational mapping), \nbut that would be misleading. The intent of oldpy2store is not to map objects to db entries, \nbut rather to offer a consistent interface for basic storage operations. \n\nIn that sense, oldpy2store is more akin to an implementation of the data access object (DAO) pattern. \nOf course, the difference between ORM and DAO can be blurry, so all this should be taken with a grain of salt.\n\nAdvantages and disadvantages such abstractions are easy to search and find, but in most cases the \npros probably outweigh the cons. \n\nMost data interaction mechanisms can be satisfied by a subset of the collections.abc interfaces.\nFor example, one can use python's collections.Mapping interface for any key-value storage, making the data access \nobject have the look and feel of a dict, instead of using other popular method name choices such for \nsuch as read/write, load/dump, etc. \nOne of the dangers there is that, since the DAO looks and acts like a dict (but is not) a user might underestimate \nthe running-costs of some operations.\n\n## Should storage transform the data?\n\nWhen does \"storing data\" **not** transform data? The answer is that storage almost always transforms data in some way.\nBut some of these transformations are taken for granted, because there's so often \"attached\" \n(i.e. \"co-occur\") with the raw process of storing. In oldpy2store, the data transformation is attached to (but not entangled with) the store object. \nThis means you have a specific place where you can check or change that aspect of storage.\n\nHaving a consistent and simple interface to storage is useful. Being able to attach key and value \ntransformations to this interface is also very useful. But though you get a lot for cheap, it's \nnot free: Mapping the many (storage systems operations) to the one (consistent interface) means \nthat, through habit, you might project some misaligned expectations. \nThis is one of the known disadvantages of Data Access Objects (DAOs))\n\nHave a look at this surreal behavior:\n\n```python\n# defining the store\nfrom oldpy2store.base import Store\n\nclass MyFunnyStore(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n\n# trying the store out            \ns = MyFunnyStore()\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert s['foo'] == 'hello bar'  # the value that 'foo' contains SEEMS to be 'hello bar'\n# so look how surreal that can be:\ns['foo'] = s['foo']  # retrieve what's under 'foo' and store it back into 'foo'\nassert s['foo'] == 'hello hello bar'  # what the...\ns['foo'] = s['foo']  # retrieve what's under 'foo' and store it back into 'foo'\nassert s['foo'] == 'hello hello hello bar'  # No no no! I do not like green eggs and ham!\n```\n\nThis happens, because though you've said `s['foo'] = 'bar'`, the value returned by `s['foo']` is \nactually `'hello bar'`. Why? Because though you've stored `'bar'`, you're transforming the data when you\nread it (that's what `_obj_of_data` does). \n\nIs that a desirable behavior? Transforming the stored data before handing it to the user? \nWell, this is such a common pattern that it has it's own acronym and tools named after the acronym: ETL.\nExtract, Transform, Load. \nWhat is happening here is that we composed extraction and transformation. Is that acceptable? \n\nSay I have a big store of tagged audio files of various formats but only want to work with \nfiles containing the 'gunshot' tag and lasting no more than 10s, and further get the data as a \nwaveform (a sequence of samples).   \n\nYou'd probably find this acceptable:\n\n```python\naudio_file_type=type_of(file)\nwith open(file, 'wb') as fp:\n    file_bytes = fp.read()\nwf = convert_to_waveform(file_bytes)\n```\n\nOr this:\n```python\nfilt = mk_file_filter(tag='gunshot', max_size_s=10)\nfor file in filter(filt, audio_source):\n    with open(file, 'wb') as fp:\n        file_bytes = fp.read()\n    wf = convert_to_waveform(file_bytes, audio_file_type=type_of(file))\n    send_wf_for_analysis(wf)\n```\n\nYou might even find it acceptable to put such code in a functions called `get_waveform_from_file`, \nor `generator_of_waveforms_of_filtered_files`. \n\nSo why is it harder to accept something where you make a store that encompasses your needs. \nYou do `s = WfStore(audio_source, filt)` and then\n\n```python\nwf = s[some_file]  # get a waveform\n```\n\nor\n\n```python\nfor wf in s.values():  # iterate over all waveforms\n    send_wf_for_analysis(wf)\n```\n\nIt's harder to accept precisely because of the simplicity and consistency (with dict operations). \nWe're used to `s[some_file]` meaning \"give me THE value stored in s, in the 'some_file' slot\". \nWe're not used to `s[some_file]` meaning \n\"go get the data stored in `some_file` and give it to me in a format more convenient for my use\".\n\nStores allow you to compose extraction and transformation, or transformation and loading, \nand further specifying filter, caching, indexing, and many other aspects related to storage. \nThose, oldpy2store helps you create the perspective you want, or need. \n\nThat said, one needs to be careful that the simplicity thus created doesn't induce misuse. \nFor example, in the `MyFunnyStore` example above, we may want to use a different store to persist \nand to read, and perhaps reflect their function in their names. For example:\n\n```python\n# defining the store\nfrom oldpy2store.base import Store\n\n\nclass ExtractAndTransform(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n\nstore = Store()\nextract_and_transform = ExtractAndTransform(store)\nstore['foo'] = 'bar'  # put 'bar' in 'foo'\nassert store['foo'] == 'bar'  # the value that store contains for 'foo' is 'bar'\nassert extract_and_transform['foo'] == 'hello bar'  # the value that extract_and_transform gives you is 'bar'\n```\n\n# Some links\n\nPresentation at PyBay 2019: https://www.youtube.com/watch?v=6lx0A6oVM5E\n\nETL: Extract, Transform, Load: https://en.wikipedia.org/wiki/Extract,_transform,_load\nORM: Object-relational mapping: https://en.wikipedia.org/wiki/Object-relational_mapping\n\nDAO: Data access object: https://en.wikipedia.org/wiki/Data_access_object\n\nDRY: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\n\nSOC: Separation Of Concerns: https://en.wikipedia.org/wiki/Separation_of_concerns\n\nCOC: Convention Over Configuration: https://en.wikipedia.org/wiki/Convention_over_configuration\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/thorwhalen/oldpy2store",
    "keywords": "",
    "license": "apache-2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "oldpy2store",
    "package_url": "https://pypi.org/project/oldpy2store/",
    "platform": "any",
    "project_url": "https://pypi.org/project/oldpy2store/",
    "project_urls": {
      "Homepage": "https://github.com/thorwhalen/oldpy2store"
    },
    "release_url": "https://pypi.org/project/oldpy2store/0.0.4/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Old version of py2store",
    "version": "0.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9952797,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "50e0e957537fc8ccf01a1c5f080053c20a072e6e22ae76dbe015c3d8478c2d4e",
          "md5": "939494186df6735ce54e81af78ca3b4b",
          "sha256": "4c90f1abd9b779f831d39684d24deeb9a9c4dcdb30be65acf4afa47fbcedbe0a"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "939494186df6735ce54e81af78ca3b4b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 299082,
        "upload_time": "2021-04-01T22:38:50",
        "upload_time_iso_8601": "2021-04-01T22:38:50.022472Z",
        "url": "https://files.pythonhosted.org/packages/50/e0/e957537fc8ccf01a1c5f080053c20a072e6e22ae76dbe015c3d8478c2d4e/oldpy2store-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0d129fe149d3d6a3e5b1f5b27084df18c2fcd0fd1daaabb5efe9d7a6c7b62757",
          "md5": "36e6a17642e77dbdc937c318a9626625",
          "sha256": "cc7b8bfad76a8b662f52365dada522b2349e86e700c0be340f24105ed304ba74"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "36e6a17642e77dbdc937c318a9626625",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 293682,
        "upload_time": "2021-04-01T22:38:52",
        "upload_time_iso_8601": "2021-04-01T22:38:52.738905Z",
        "url": "https://files.pythonhosted.org/packages/0d/12/9fe149d3d6a3e5b1f5b27084df18c2fcd0fd1daaabb5efe9d7a6c7b62757/oldpy2store-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0190dc3e6b5d25572cf81d39db529146e9530f08c634ef461070428fc73c4439",
          "md5": "8f8d764a23a48b48ce372791439242f3",
          "sha256": "89d669f425304c8dd2fbbb6318e1ff4f89f312394fad9a483e3935de99d2be7e"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8f8d764a23a48b48ce372791439242f3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28824,
        "upload_time": "2021-04-01T22:44:44",
        "upload_time_iso_8601": "2021-04-01T22:44:44.007623Z",
        "url": "https://files.pythonhosted.org/packages/01/90/dc3e6b5d25572cf81d39db529146e9530f08c634ef461070428fc73c4439/oldpy2store-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7cc240533dc04cbd7752542f1b9f9e9ddbc1f536520dbe48bfe733c90a07b974",
          "md5": "e5d5a792d495ac3922ebc62b2cc5904c",
          "sha256": "94fd162cfc5bd75d9b415ecea2c04c397023496f5019f5dfe5a6d26cbfa19b00"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "e5d5a792d495ac3922ebc62b2cc5904c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 59805,
        "upload_time": "2021-04-01T22:44:46",
        "upload_time_iso_8601": "2021-04-01T22:44:46.038005Z",
        "url": "https://files.pythonhosted.org/packages/7c/c2/40533dc04cbd7752542f1b9f9e9ddbc1f536520dbe48bfe733c90a07b974/oldpy2store-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3f7a2167fcd373130b952da9e732d036a405525c3f3292aead48803dd1e693d5",
          "md5": "087e3ec21bd365c04582628df2bc57b6",
          "sha256": "812cdc2b8ed04be4586c9788dd36e0b9c0696b8ab7d961b4752d7d02ed966c40"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "087e3ec21bd365c04582628df2bc57b6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28826,
        "upload_time": "2021-04-02T00:12:36",
        "upload_time_iso_8601": "2021-04-02T00:12:36.805102Z",
        "url": "https://files.pythonhosted.org/packages/3f/7a/2167fcd373130b952da9e732d036a405525c3f3292aead48803dd1e693d5/oldpy2store-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6b71e9cd03acb01ada4e5c3e771d72a3a56fde87fd99f5efa9a6bec6f1ce3922",
          "md5": "ed6ac96bda63382b0b1338d9616f3691",
          "sha256": "639a6dda93601f3492e9998c92d7737b099234049470489652905f4c1028e618"
        },
        "downloads": -1,
        "filename": "oldpy2store-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "ed6ac96bda63382b0b1338d9616f3691",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 59804,
        "upload_time": "2021-04-02T00:12:38",
        "upload_time_iso_8601": "2021-04-02T00:12:38.883685Z",
        "url": "https://files.pythonhosted.org/packages/6b/71/e9cd03acb01ada4e5c3e771d72a3a56fde87fd99f5efa9a6bec6f1ce3922/oldpy2store-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3f7a2167fcd373130b952da9e732d036a405525c3f3292aead48803dd1e693d5",
        "md5": "087e3ec21bd365c04582628df2bc57b6",
        "sha256": "812cdc2b8ed04be4586c9788dd36e0b9c0696b8ab7d961b4752d7d02ed966c40"
      },
      "downloads": -1,
      "filename": "oldpy2store-0.0.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "087e3ec21bd365c04582628df2bc57b6",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 28826,
      "upload_time": "2021-04-02T00:12:36",
      "upload_time_iso_8601": "2021-04-02T00:12:36.805102Z",
      "url": "https://files.pythonhosted.org/packages/3f/7a/2167fcd373130b952da9e732d036a405525c3f3292aead48803dd1e693d5/oldpy2store-0.0.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6b71e9cd03acb01ada4e5c3e771d72a3a56fde87fd99f5efa9a6bec6f1ce3922",
        "md5": "ed6ac96bda63382b0b1338d9616f3691",
        "sha256": "639a6dda93601f3492e9998c92d7737b099234049470489652905f4c1028e618"
      },
      "downloads": -1,
      "filename": "oldpy2store-0.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "ed6ac96bda63382b0b1338d9616f3691",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 59804,
      "upload_time": "2021-04-02T00:12:38",
      "upload_time_iso_8601": "2021-04-02T00:12:38.883685Z",
      "url": "https://files.pythonhosted.org/packages/6b/71/e9cd03acb01ada4e5c3e771d72a3a56fde87fd99f5efa9a6bec6f1ce3922/oldpy2store-0.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}