{
  "info": {
    "author": "Alexander Aleskin",
    "author_email": "alexanderaleskin@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Framework :: Django",
      "Framework :: Django :: 3.0",
      "Framework :: Django :: 3.1",
      "Framework :: Django :: 3.2",
      "Framework :: Django :: 4.0",
      "Framework :: Django :: 4.1",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Communications :: Chat",
      "Topic :: Internet",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "Telegram Django Bot Bridge\n============================\n\nThis library provides a Python interface for creating Telegram Bots. It standardizes coding approach in the best\npractice of the web development. The library combines `Django <https://www.djangoproject.com/>`_ and `Python-Telegram-Bot <https://python-telegram-bot.org/>`_.\nand provides extra powerful utilities based on these libraries.\n\n\nNormally, Python-Telegram-Bot gives next opportunities for bot creating:\n\n* Python Interface for communication with Telegram API;\n* Web-service to get updates from telegram;\n\nand Django:\n\n* Django ORM  (communication with Database);\n* Administration panel for management.\n\n\nTelegram Django Bot Bridge provides next special opportunities:\n\n* using Django Forms;\n* using Viewsets (typical action with model (create, update, list, delete));\n* using Django localization.\n* using function routing like urls routing in Django.\n\nAnd some extra useful staff:\n\n* using function routing like urls routing in Django;\n* creating tests;\n* creating general menu items with no-coding (through Django Admin Panel);\n* extra high-level Bot functions, such as wrapper for sending delayed (or scheduled) messages;\n* collecting stats from user actions in the bot;\n* creating user triggers;\n* commonly used utilities.\n\n\n\nInstall\n------------\n\nYou can install via ``pip``:\n\n.. code-block:: shell\n\n    $ pip install telegram_django_bot\n\n\nThen you can configurate it in your app:\n\n\n1. Add \"telegram_django_bot\" to your INSTALLED_APPS setting like this:\n\n.. code-block:: python\n\n    INSTALLED_APPS = [\n        ...\n        'telegram_django_bot',\n    ]\n\n\n\n2. Run ``python manage.py migrate`` to create the telegram_django_bot models (checked that the ``AUTH_USER_MODEL`` selected\nin settings).\n\n\n3. Set up constants in Django settings file:\n\n* ``TELEGRAM_ROOT_UTRLCONF`` -  (same as ``ROOT_URLCONF`` for WEB) for using django notation in callback (routing) (strongly recommended)\n\n  Not necessary, but useful settings:\n\n* ``TELEGRAM_TOKEN`` - for adding \"triggers\",\n* ``TELEGRAM_TEST_USER_IDS`` - for adding tests for your bot,\n* Make sure, that ``LANGUAGE_CODE``, ``LANGUAGE_CODE``, ``USE_I18N`` are also used in the library for language localization.\n\n\n4. This step connects ``Telegram Django Bot Bridge`` with ``Python-Telegram-Bot``. Add ``RouterCallbackMessageCommandHandler`` in handlers for using TELEGRAM_ROOT_UTRLCONF :\n\n.. code-block:: python\n\n    updater = Updater(bot=TG_DJ_Bot(settings.TELEGRAM_TOKEN))\n    updater.dispatcher.add_handler(RouterCallbackMessageCommandHandler())\n\n\nIf you start a new project, you could use `Telegram django bot template <https://github.com/alexanderaleskin/telergam_django_bot_template>`_ with preconfigured settings.\n\n\nQuick start\n------------\n\n\n\nThe key feature of the lib is ``TelegaViewSet`` - class for manage Django ORM model. It is designed in the\nsimilar way as `Django rest framework Viewset <https://www.django-rest-framework.org/api-guide/viewsets/>`_ , but has\na significant difference: while DRF Viewset provides response in serializable format (usually in json format) to frontend app, TelegaViewSet\nprovides response to user in telegram interface in message format with buttons. So, you will manage data and receive\nresponse in human format by executing TelegaViewSet method. The methods use some kind of templates for generating human\nresponse (it is possible to overwrite these templates). By default, TelegaViewSet has 5 methods:\n\n* ``create`` - create a new instance of specified ORM model;\n* ``change`` - update instance fields of specified ORM model;\n* ``show_elem`` - show fields of the instance and buttons with actions of this instance;\n* ``show_list`` - show list of model instance (with pagination);\n* ``delete`` - delete the instance\n\n\nSo, if, for example, you have a model of some *request* in your project:\n\n.. code-block:: python\n\n    from django.db import models\n\n    class Request(models.Model):\n        text = models.TextField()\n        importance_level = models.PositiveSmallIntegerField()  # for example it will be integer field\n        project = models.ForeignKey('Project', on_delete=models.CASCADE)\n        tags = models.ManyToManyField('Tags')\n\n\nThe next piece of code gives opportunity for full managing (create, update, show, delete) of this model from Telegram:\n\n.. code-block:: python\n\n    from telegram_django_bot import forms as td_forms\n    from telegram_django_bot.td_viewset import TelegaViewSet\n\n\n    class RequestForm(td_forms.TelegaModelForm):\n        class Meta:\n            model = Request\n            fields = ['text', 'importance_level', 'project', 'tags']\n\n\n    class RequestViewSet(TelegaViewSet):\n        telega_form = RequestForm\n        queryset = Request.objects.all()\n        viewset_name = 'Request'\n\n\nIf you need, you can add extra actions to RequestViewSet for managing (see details information below) or change existed functions.\nThere are several parameters and secondary functions in TelegaViewSet for customizing logic if it is necessary.\n\nIn this example, ``TelegaModelForm`` was used. TelegaModelForm is a descendant of Django ModelForm. So, you could use\nlabels, clean and other parameters and functions for managing logic and displaying.\n\n\nTelegaViewSet is designed to answer next user actions: clicking buttons and sometimes sending messages. The library imposes\n`Django URL notation <https://docs.djangoproject.com/en/4.1/topics/http/urls/>`_ for mapping user actions to TelegaViewSet methods (or usual handlers).\nUsually, for correct mapping you just need to set ``TELEGRAM_ROOT_UTRLCONF`` and use ``RouterCallbackMessageCommandHandler`` in\ndispatcher as it is mentioned above in the *Install paragraph*.\n\nFor correct mapping *RequestViewSet*  you should write in the TELEGRAM_ROOT_UTRLCONF file something like this:\n\n.. code-block:: python\n\n    from django.urls import re_path\n    from .views import RequestViewSet\n\n    urlpatterns = [\n        re_path(r\"^rv/\", RequestViewSet, name='RequestViewSet'),\n    ]\n\nFrom this point, you can use buttons with callback data \"rv/<function_code>\" for function calling. For example:\n\n* \"rv/cr\" - RequestViewSet.create method;\n* \"rv/sl\" - RequestViewSet.show_list;\n\n\nSee these examples for great understanding:\n\n\n1. `Telegram django bot template <https://github.com/alexanderaleskin/telergam_django_bot_template>`_\n2. `Drive Bot <https://github.com/alexanderaleskin/drive_bot>`_\n\n\nDeep in details\n------------------\n\nIn this chapter, we will analyze how everything works. The main task of the library is to unify the code and\nprovide frequently used functions for developing a bot, that is why a lot of logic is based on resources and paradigms\nDjango <https://www.djangoproject.com/>`_ and `Python-Telegram-Bot <https://python-telegram-bot.org/>`_ . Let's analyze\nkey features of the library on the example of `Telegram django bot template <https://github.com/alexanderaleskin/telergam_django_bot_template>`_ .\n\n\nSince Telegram bots are designed as a tool for responding to user requests, writing a bot begins\nfrom the user request handler. For this, the standard tools of the Python-Telegram-Bot library are used Ôπ£\n``telegram.ext.Update``:\n\n.. code-block:: python\n\n     from telegram.ext import Updater\n\n     ...\n\n     def main():\n         ...\n\n         updater = Updater(bot=TG_DJ_Bot(TELEGRAM_TOKEN))\n         add_handlers(updater)\n         updater.start_polling()\n         updater.idle()\n\n     if __name__ == '__main__':\n         main()\n\n\nAs indicated in the example, to run the bot (Update) you need to specify a few things (the ``Python-Telegram-Bot`` library standard):\n\n1. an instance of the ``telegram.Bot`` model with the specified API token. In this case, a descendant ``telegram_django_bot.tg_dj_bot.TG_DJ_Bot``\nof the ``telegram.Bot`` class is used. It has additional functionality for convenience (we will return to it later);\n2. Handlers that will be called in response to user requests.\n\n\nIn the example, the list of handlers is specified in the ``add_handlers`` function:\n\n\n\n.. code-block:: python\n\n     from telegram_django_bot.routing import RouterCallbackMessageCommandHandler\n\n     ...\n\n     def add_handlers(updater: Updater):\n         dp=updater.dispatcher\n         dp.add_handler(RouterCallbackMessageCommandHandler())\n\n\nThe example adds 1 super handler ``RouterCallbackMessageCommandHandler``, which allows you to write handlers\nin the style of handling link requests in the same way as it is done in ``Django``. ``RouterCallbackMessageCommandHandler`` allows you to handle\nmessages, user commands and button clicks by users. In other words, it replaces the handlers\n``MessageHandler, CommandHandler, CallbackQueryHandler`` . Since the ``Telegram Django Bot Bridge`` library is an extension,\nit does not prohibit the use of standard handlers of the ``Python-Telegram-Bot`` library for handle user requests.\n(sometimes it is simply necessary, for example, if you need to process responses to surveys (you need to use PollAnswerHandler)).\n\n`Django notation <https://docs.djangoproject.com/en/4.1/topics/http/urls/>`_ of routing handlers is that paths to handlers are described in a separate file or files.\nAs in the ``Django`` standard, the main file (root) for routing is specified in the project settings, where paths to handlers or paths to groups of handlers are stored.\nThe ``TELEGRAM_ROOT_UTRLCONF`` (same as ``ROOT_URLCONF`` for WEB) attribute is used to specify the path to the file. In the example template, we have the following settings:\n\n\n``bot_conf.settings.py``:\n\n.. code-block:: python\n\n     TELEGRAM_ROOT_UTRLCONF = 'bot_conf.utrls'\n\n\n``bot_conf.utrls.py``:\n\n.. code-block:: python\n\n     from django.urls import re_path, include\n\n     urlpatterns = [\n         re_path('', include(('base.utrls', 'base'), namespace='base')),\n     ]\n\n\nThat is, only 1 group of handlers is connected in the file (which corresponds to the ``base`` application at the conceptual level). You can\nadd several groups as well, this can be convenient if you create several folders (applications) for storing code.\nAs you can see ``Django`` functions are imported without any redefinition.\n\nThere is following code in the specified included file ``base.utrls.py`` :\n\n\n.. code-block:: python\n\n    from django.urls import re_path\n    from django.conf import settings\n\n    from .views import start, BotMenuElemViewSet, UserViewSet, some_debug_func\n\n\n    urlpatterns = [\n        re_path('start', start, name='start'),\n        re_path('main_menu', start, name='start'),\n\n        re_path('sb/', BotMenuElemViewSet, name='BotMenuElemViewSet'),\n        re_path('us/', UserViewSet, name='UserViewSet'),\n    ]\n\n\n    if settings.DEBUG:\n        urlpatterns += [\n            re_path('some_debug_func', some_debug_func, name='some_debug_func'),\n        ]\n\nSo, the end handlers (which are defined in the ``base.views.py`` file) are specified here. Thus, if\nuser in the bot writes the command ``/start``, then ``Updater`` receives a message about the user's action and selects\nthe appropriate for the request handler ``RouterCallbackMessageCommandHandler`` from a set of handlers. Then the\nhandler ``RouterCallbackMessageCommandHandler`` searches the appropriate for string ``/start`` path in ``utrls`` and\nfinds a suitable path ``'' + 'start'``, and then executes corresponding start function.\n\nThis distribution of handlers allows you to group part of the handlers into modules and quickly connect or\nchange them, while not being afraid of confusion which handlers need to be called, as it can be if all paths from\ndifferent modules to handlers are described in one place as required by ``Python-Telegram-Bot``.\n\nIn this example file ``base.utrls.py`` also ViewSets are used in addition to simple handler functions like ``def start`` and ``def some_debug_func``.\nViewSet is an aggregator of several functions. The concept of it is that you quite often need to apply\nthe same operations for a dataset, such as create, update, show, delete an example of dataset.\nThere is the class ``telegram_django_bot.td_viewset.TelegaViewSet`` in the library  for such purposes. The class manages\nthe Django ORM database model. ``TelegaViewSet`` has 5 functions for managing the model:\n\n\n========= ======== ===========================\n –ú–µ—Ç–æ–¥     UTRL      Description\n--------- -------- ---------------------------\ncreate     cr       Create model\nchange     up       Change model attributes\ndelete     de       Deleting a model\nshow_elem  se       Display a model\nshow_list  sl       Display a list of models\n========= ======== ===========================\n\nThus, if we want to call the ``BotMenuElemViewSet.create`` method to create an element, we need to use\npath 'sb/cr', where by the first part of path 'sb/'  the router ``RouterCallbackMessageCommandHandler`` will execute\nthe ``BotMenuElemViewSet`` class, namely the ``TelegaViewSet.dispatch`` method, which in turn will call  the ``create`` method by analyzing the second part of the path\n``cr``.\n\nTo sum up the scheme of handlers routing, there are following key points:\n\n1. ``telegram.ext.Update`` is used as a receiver of messages from Telegram;\n2. Standard handlers of the ``Python-Telegram-Bot`` library can be used as handlers. For convenient use Django's path scheme and ``TelegaViewSet`` you need to use ``RouterCallbackMessageCommandHandler``.\n3. ``TelegaViewSet`` aggregates a set of standard functions for managing data, what is made possible to group code associated with one type of data type in one class (place).\n\n\n\nTelegaViewSet features\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs described above, TelegaViewSet contains standard functions for data manipulation.\nDue to such standard data processing methods, it turns out in the example to describe the logic of ``BotMenuElemViewSet`` in 40\nlines of code, also using some customization for a beautiful data displaying.\n\n\nTo use all the features of the TelegaViewSet in your class, it should be inherited from it, as, for example, this is done\nin the ``BotMenuElemViewSet``:\n\n\n.. code-block:: python\n\n    from telegram_django_bot.td_viewset import TelegaViewSet\n\n    class BotMenuElemViewSet(TelegaViewSet):\n\n\nIn order to customize the ViewSet, you must specify 3 required attributes:\n\n1. ``viewset_name`` - class name, used to display to telegram users\n2. ``telega_form`` - data form, used to specify which fields of the ORM database model to use in the viewset;\n3. ``queryset`` - basic query for getting model elements.\n\n\nThe ``BotMenuElemViewSet`` is used the following values:\n\n.. code-block:: python\n\n    from telegram_django_bot import forms as td_forms\n    from telegram_django_bot.models import BotMenuElem\n\n    class BotMenuElemForm(td_forms.TelegaModelForm):\n        form_name = _(\"Menu elem\")\n\n        class Meta:\n            model = BotMenuElem\n            fields = ['command', \"is_visable\", \"callbacks_db\", \"message\", \"buttons_db\"]\n\n    class BotMenuElemViewSet(TelegaViewSet):\n        viewset_name = 'BotMenuElem'\n        telega_form = BotMenuElemForm\n        queryset = BotMenuElem.objects.all()\n\n\nwhere ``BotMenuElemForm`` is a descendant of the ``Django ModelFrom`` class, so it has a similar structure and parameterization methods.\n`` form_name ``  stands for the name of the form and is used in some messages sent to Telegram users.\n\n\nTelegaViewSet has quite a lot in common with Viewset analogs tailored for WEB development (for example,\n`django-rest-framework viewsets <https://www.django-rest-framework.org/api-guide/viewsets/>`_ ). However, as part of the development of Telegram bots, TelegaViewSet\nhas some special features:\n\n1. An unusual way to create elements;\n2. The display of information in bots is limited and most often comes down to displaying text and buttons, so the viewset in addition to business logic includes the creation of standard responses to user actions in the form of messages with buttons.\n\n\n\nForms\n************\n\n\nSince Telegram does not have the ability to create forms (in the classic Web sense) and communication between the bot and the user takes place in a chat, then\nthe most intuitive solution for filling out a form (creating an element) is filling the form attribute by attribute,\nwhen the first element of the form is filled first, then the second, and so on. With this approach, it is necessary to use temporary storage for remembering\nspecified values in order to create an element from the form at the end. ``TelegaModelForm`` and ``TelegaForm`` are implemented just\nin such way for taking over this process. The difference between these classes and the standard Django classes is precisely\nin the modification of the method of filling in the form fields, otherwise they do not differ from standard forms.\n\n``TelegaModelForm`` and ``TelegaForm`` as Django descendants of ``ModelForm`` and ``Form`` have the following parameters, which you may need to customize:\n\n1. The clean function and other `form validation process functions <https://docs.djangoproject.com/en/4.1/ref/forms/validation/>`_ ;\n2. ``labels`` - field names;\n3. ``forms.HiddenInput`` - designation of hidden fields (hiding fields allows them not to be shown to the user, while using and configuring in forms or in ``TelegaViewSet``).\n\n\n\n``TelegaViewSet`` is designed to interact with descendants of the ``TelegaModelForm`` class and allows you to use\ngenerate forms with different fields, such as ``CharField, IntegerField`` or ``ForeignKey, ManyToManyField``. Also, it is good idea\nto use the ``prechoice_fields_values`` dictionary in ``TelegaViewSet`` descendants for improving the convenience of filling out forms for users.\nIt is possible to store a list of frequently used values of form fields in the ``prechoice_fields_values``.\nThis allows users to select the desired values by clicking buttons rather than\nwriting text manually. The template has an example of using this field:\n\n\n.. code-block:: python\n\n    class BotMenuElemViewSet(TelegaViewSet):\n        ...\n\n        prechoice_fields_values = {\n            'is_visable': (\n                (True, 'üëÅ Visable'),\n                (False, 'üö´ Disabled'),\n            )\n        }\n\nIn this case, 2 values are specified for choosing true or false for the boolean field ``is_visable``. You can also use\n``prechoice_fields_values`` for ``CharField, IntegerField`` or any other fields.\nSometimes the list of values needs to be generated dynamically, in which case you can override\n``prechoice_fields_values`` as a ``@property`` function.\n\n\nKey logic of TelegaViewSet\n************************************************\n\nThe main function of the class, which is selected the function for managing data by the request of the user,  is ``TelegaViewSet.dispatch``.\nLet's analyze its logic in more detail:\n\n.. code-block:: python\n\n    def dispatch(self, bot, update, user):\n\n        self.bot = bot\n        self.update = update\n        self.user = user\n\n        if update.callback_query:\n            utrl = update.callback_query.data\n        else:\n            utrl = user.current_utrl\n\n        self.utrl = utrl\n\n        if settings.DEBUG:\n            logging.info(f'utrl: {utrl}')\n\n        utrl_args = self.get_utrl_params(re.sub(f'^{self.prefix}', '', self.utrl))\n        if self.has_permissions(bot, update, user, utrl_args):\n            chat_action, chat_action_args = self.viewset_routing[utrl_args[0]](*utrl_args[1:])\n        else:\n            chat_action = self.CHAT_ACTION_MESSAGE\n            message = _('Sorry, you do not have permissions to this action.')\n            buttons = []\n            chat_action_args = (message, buttons)\n\n        res = self.send_answer(chat_action, chat_action_args, utrl)\n\n        utrl_path = utrl.split(self.ARGS_SEPARATOR_SYMBOL)[0]   # log without params as to much varients\n        add_log_action(self.user.id, utrl_path)\n        return res\n\n\nLike a regular handler, the function takes 3 arguments as input: bot, update, user. After saving these arguments in class,\nthe determination of the current routing path is occurred. It is determined either by pressing a button in the bot (the ``callback_data`` value of the button), or\ncan be stored in the user attribute ``user.current_utrl``. The second option is possible if the user manually enters\nsome information (for example, filled in a text field of form). After that, the arguments are extracted from the path\nto call a specific function. Storing and interacting with arguments in a path is similar to how ``sys.argv`` works. So,\nfor example, the string ``\"sl&1&20\"`` will be converted to the list ``['sl', '1', '20']``. Separator character between attributes\nis ``&`` by default and can be changed via the ``TelegaViewSet.ARGS_SEPARATOR_SYMBOL`` variable.\n\nWhen using ``TelegaViewSet`` you most likely won't have to interact with the argument string directly, since\nhow ``dispatch`` converts a string into arguments, and to create a string for a ``callback_data`` button for calling another method by user, you should use\n``TelegaViewSet.gm_callback_data`` function. In case you need more low-level interaction with function arguments, then\nyou can use the ``construct_utrl`` and ``get_utrl_params`` functions.\n\nAfter receiving the utrl_args arguments and checking access rights, the managing method (action) is directly selected and called.\nThe first argument, which is the short name for the function, is popped from the utrl_args. All other arguments are passed as parameters\ninto a function. Inside the function, the necessary business logic and the data formating for displaying to the user as a response take place.\nAny such managing function in the ``TelegaViewSet`` class must return the action type ``chat_action`` and the parameters to that action ``chat_action_args``.\nBy default, the  class has only 1 action Ôπ£ ``CHAT_ACTION_MESSAGE``, which means that the user will receive\na text message (possibly with buttons) as an answer for his/her action. The arguments to this action are the text of the message and a list of buttons (can be None).\n\n\nAfter the function is processed, a response is sent to the user  by ``send_answer`` function and the user's action is logged.\n\n\nThe methods to call in ``viewset_routing`` are the ``create, update, delete, show_elem, show_list`` methods.\nYou can also add your own methods. Suppose we want to add a ``def super_method(self, *args)`` method, then\nyou need to add the following lines in the class:\n\n.. code-block:: python\n\n    class SomeViewSetClass(TelegaViewSet):\n        ...\n\n        actions = ['create', 'change', 'delete', 'show_elem', 'show_list', 'super_method']\n\n        command_routing_super_method = 'sm'\n\n\n        def super_method(self, *args):\n            ...\n\n\nWhere ``actions`` defines the list of available methods and ``command_routing_<method>`` defines the path (url; short name) of the method.\n\nAs noted above, the ``dispatch`` method performs a permissions check by calling the ``has_permissions`` method.\nThe check is performed by the classes specified in ``permission_classes`` and the default class is ``AllowAny``:\n\n.. code-block:: python\n\n    class TelegaViewSet:\n        permission_classes = [AllowAny]\n\n\n\nAdditional TelegaViewSet Tools\n************************************************\n\nThis section describes the following class functionality that makes it easier to write code:\n\n1. External filters;\n2. Data display setting options;\n3. Helper functions for displaying data;\n4. Helper functions of business logic;\n\n\nExternal filters\n+++++++++++++++++++++\n\nQuite often, there is situation when you need to work not with all the elements of a database table, but with some\ngroup (for example, a group of elements with a specific foreign key). For such purposes, you should use the ``foreign_filters`` list,\nwhich stores the values for filtering when the method is called. How exactly to use these filters is up to you, but\nusually it is good idea to use it in the ``get_queryset`` function. Thus, it is possible to pass to functions\nadditional arguments that do not break the key logic of standard functions. Using the template example, you can modify\n``BotMenuElemViewSet`` so that if an additional parameter is specified, then the BotMenuElem list displays\nonly those elements that contain the specified parameter in their ``command`` attribute. To do this, you need to make the following changes to the code:\n\n\n.. code-block:: python\n\n    class BotMenuElemViewSet(TelegaViewSet):\n        ...\n\n        foreign_filter_amount = 1\n\n        def get_queryset(self):\n            queryset = super().get_queryset()\n            if self.foreign_filters[0]:\n                queryset = queryset.filter(command__contains=self.foreign_filters[0])\n            return queryset\n\n\nWhere ``foreign_filter_amount`` specifies the number of foreign filters. To call a method with a filter value, you must\nspecify them right after the function name in the path (utrls): ``\"sb/sl&start&2\"``, ``\"sb/sl&start&2&1\"``, ``\"sb/sl&hello``.\nIt is worth noting that if we do not want to specify a filter, then we need to skip the argument in the path (utrls) in the next way: ``\"sb/sl&&2\"``.\n\nThere is no need to construct and process filters in paths (utrls) directly, since the functions ``gm_callback_data`` and ``get_utrl_params``\nknow how to work with them. gm_callback_data also has a parameter ``add_filters`` (default True) which defines\nwhether to include filters in the generated path (utrl) or not. If the value is False , then it is necessary in the function arguments\nmanually specify filters: ``self.gm_callback_data('show_list', 'start', add_filters=False)`` (will generate ``\"sb/sl&start``).\nThis allows you to change the value of filters when generating paths.\n\nA more detailed use of external filters can be seen in the example of `Drive Bot <https://github.com/alexanderaleskin/drive_bot>`_ .\n\nData display options\n++++++++++++++++++++++++++++++++++++++++++\n\nThe ``TelegaViewSet`` has the following options for displaying model elements:\n\n* ``updating_fields: list`` - list of fields that can be changed (displayed when showing the element (``show_elem``);\n* ``show_cancel_updating_button: bool = True`` - shows a cancel button when changing fields, which leads back to the displaying element (``show_elem``);\n* ``deleting_with_confirm: bool = True`` - ask the user for confirmation when deleting an element;\n* ``cancel_adding_button: InlineKeyboardButtonDJ = None`` - cancel button when creating an element (``create`` method);\n* ``use_name_and_id_in_elem_showing: bool = True`` - enables the use of the name and ID of the element when displaying this element (methods ``show_list`` and ``show_elem``);\n* ``meta_texts_dict: dict`` - a dictionary that stores standard texts for display (texts are used in all methods).\n\n\n\nHowever, these fields are not always enough and you need to redefine the logic of helper functions for a beautiful display of information.\n\n\nHelper functions for displaying data\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nThe ``TelegaViewSet`` class describes the following helper functions for generating a response message:\n\n\n* ``def gm_no_elem`` - if no element with this ID was found;\n* ``def gm_success_created`` - successful creation of the model;\n* ``def gm_next_field`` - when moving to the next form attribute;\n* ``def gm_next_field_choice_buttons`` - generates buttons to select options for a specific form attribute (used inside ``gm_next_field``);\n* ``def gm_value_error`` - error output when adding a form attribute;\n* ``def gm_self_variant`` - generates a message about the need to write the value manually by the user;\n* ``def gm_show_elem_or_list_fields`` - displays model fields in the message (used in ``show_elem`` with ``full_show=True``, and in ``show_list`` Ôπ£with ``full_show=False``);\n* ``def gm_value_str`` - generates a string displaying a specific attribute (used in ``gm_show_elem_or_list_fields``);\n* ``def gm_show_elem_create_buttons`` - displays available buttons (actions) when showing a model element (calling ``show_elem``) ;\n* ``def gm_show_list_button_names`` - generates the names of item buttons when displaying the list (calling ``show_list``);\n\nDepending on the need for customization, it is necessary to redefine these functions.\n\n\nHelper functions of business logic\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nThe ``TelegaViewSet`` class uses the following helper functions:\n\n* ``def get_queryset`` - allows you to modify Model queries to database (most often used to filter elements, as in the example above);\n* ``def create_or_update_helper`` - main logic for ``create`` and ``update`` methods;\n* ``def show_list_get_queryset`` - allows you to customize the selection of items to display in show_list;\n\n\nhandler_decor\n~~~~~~~~~~~~~~~~\n\nWhen writing your own handlers, it is recommended to use a wrapper like ``telegram_django_bot.utils.handler_decor``,\nwhich performs the following functions:\n\n* Getting or creating a user in the database;\n* In case of an error inside the handler function, returns an error message to the user;\n* Logs the handler call;\n* Tracks where the user came from;\n* Choice of language for sending messages to the user (in the case of localization enabled);\n\nThis handler is also used inside ``RouterCallbackMessageCommandHandler``, and as a result in calling ``TelegaViewSet`` classes.\n\nLocalization\n~~~~~~~~~~~~~~~~\n\nThe library expands the `Django localization tools <https://docs.djangoproject.com/en/4.1/topics/i18n/>`_ for use in Telegram.\nTo support the use of different languages, the main elements of the Python-Telegram-Bot library are redefined in ``telegram_django_bot.telegram_lib_redefinition``:\n\n\n1. ``telegram.Bot`` -> ``telegram_django_bot.BotDJ`` ;\n2. ``telegram.ReplyMarkup`` -> ``telegram_django_bot.ReplyMarkupDJ`` ;\n3. ``telegram.KeyboardButton`` -> ``telegram_django_bot.KeyboardButtonDJ`` ;\n4. ``telegram.InlineKeyboardButton`` -> ``telegram_django_bot.InlineKeyboardButtonDJ`` ;\n5. ``telegram.InlineKeyboardMarkup`` -> ``telegram_django_bot.InlineKeyboardMarkupDJ``;\n\n\n\nWhen using these classes in code, multilingual support comes down to the following steps:\n\n1. Specifying the necessary settings in the settings.py file: ``LANGUAGES`` - list of languages, ``LANGUAGE_CODE`` - default language;\n1. Necessary texts for translation are wrapped in ``gettext`` and ``gettext_lazy`` from ``django.utils.translation`` (how it works in Django `read here <https://docs.djangoproject.com/en /4.1/topics/i18n/translation/#standard-translation>`_ )\n2. Run command ``$ django-admin makemessages -a`` to generate texts for translation (created in locale folder)\n3. Generation of translation files ``$ django-admin compilemessages``.\n\nOnly a part of the functions uses localization in the template. It is made for easy understanding. Usage of localization can be seen in the example\nfunctions ``some_debug_func``.\n\n\nExtra lib features\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe library provides some additional tools for the convenience of developing and managing the bot.\n\n–ú–æ–¥–µ–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏\n************************************\n\n\nFor the correct work of ``TelegaViewSet`` and other components the Django ORM model representing the user in the Telegram must be inherited\nfrom ``telegram_django_bot.models.TelegramUser``, as these components use its fields. ``TelegramUser`` inherited from\n``django.contrib.auth.models.AbstractUser`` (which allows you to authorize users on the site if necessary) and has\nthe following additional fields:\n\n* ``id`` - redefined to use user ID from telegrams;\n* ``seed_code`` - arbitrary value from 1 to 100 to randomly group users for tests and analysis;\n* ``telegram_username`` - username of the user in the telegram;\n* ``telegram_language_code`` - telegram language code (some languages have dialects and as a result the code designation is more than 2 symbols);\n* ``timezone`` - the user's time zone (for determining the time);\n* ``current_utrl`` - path (utrl) of the last user action (used in ``TelegaViewSet``);\n* ``current_utrl_code_dttm`` - time of the last action, when saving the path;\n* ``current_utrl_context_db`` - path context (utrl);\n* ``current_utrl_form_db`` - intermediate data for the form. Acts as a temporary data store when filling out a form;\n\nFields ``current_utrl_<suffix>`` are needed for ``TelegaViewSet``, ``TelegaModelForm`` and are needed in exceptional cases\nwhen writing code. The model also has the following methods (property) to simplify interaction with model fields:\n\n* ``current_utrl_form`` (property) - returns the current temporarily stored path form data (utrl);\n* ``current_utrl_context`` (property) - returns the current path context (utrl);\n* ``save_form_in_db`` - saves the form in the ``current_utrl_form_db`` field;\n* ``save_context_in_db`` - saves the context in the field ``current_utrl_context_db``;\n* ``clear_status`` - clears the data associated with the used path (fields ``current_utrl_<suffix>``) ;\n* ``language_code`` (property) - returns the language code in which messages should be generated for the user;\n\n\nActually, if you want, you can create your self Django ORM model representing the user, you just need to copy\n``id, telegram_username, telegram_language_code, current_utrl, current_utrl_code_dttm, current_utrl_context_db, current_utrl_form_db``\nand corresponding functions.\n\n\nThe library also describes additional models to improve the usability of the bot:\n\n* ``ActionLog`` - stores user actions. Records help to collect analytics and make triggers that work on certain actions;\n* ``TeleDeepLink`` - stores data on which links new users have clicked (to analyze input traffic);\n* ``BotMenuElem`` - Quite often a bot needs messages that have only static data. These pages can be help and start messages. ``BotMenuElem`` allows you to configure such pages through the admin panel, without having to write anything in the code. In ``BotMenuElem`` there is the ability to customize pages depending on the starting deeplinks. ``BotMenuElem`` can not only add buttons to the message, but also send different files. To do this, you must specify ``media`` and the file format ``message_format``. ``BotMenuElem`` allows you to quickly change bot menu blocks without having to make changes to the code;\n* ``BotMenuElemAttrText`` - helper model for ``BotMenuElem``, responsible for translating texts into other languages. The elements themselves are created depending on the specified languages in the ``LANGUAGES`` settings. You only need to fill in the translation in the ``translated_text`` field;\n* ``Trigger`` - allows you to create triggers depending on certain actions. For example, remind the user that he has left incomplete order, or give a discount if it is inactive for a long time. For triggers to work, you need to add tasks from ``telegram_django_bot.tasks.create_triggers`` to CeleryBeat schedule;\n* ``UserTrigger`` - helper model for ``Trigger``, controlling to whom triggers have already been sent;\n\n\nAdditional functions of TG_DJ_Bot\n*********************************************\n\nTo improve convenience, ``TG_DJ_Bot`` has several high-level functions:\n\n* ``send_format_message`` - Allows you to send a message of an arbitrary type (internally, depending on the ``message_format`` selects the appropriate method of the ``Python-Telegram-Bot`` library). An important feature of this function is that if the user clicks on the button, then the previous message of the bot is changed, rather than a new one is sent. If, nevertheless, in this case you need to send a new message to the user, then you need to set the parameter ``only_send=True`` ;\n* ``edit_or_send`` - wrapper of the ``send_format_message`` method for sending text messages with buttons;\n* ``send_botmenuelem`` - Sends a ``BotMenuElem`` to the user. The ``update`` argument can be empty;\n* ``task_send_message_handler`` - created for sending messages to many users. Handles situations where the user blocked the bot, deleted or when the limit for sending messages to users is reached;\n\n\nUtils\n**********\n\nThe following additional functions are provided in the libraries:\n\n\n* ``telegram_django_bot.utils.add_log_action`` - to create a user ActionLog;\n* ``telegram_django_bot.utils.CalendarPagination`` - class for generating a calendar with buttons;\n* ``telegram_django_bot.user_viewset.UserViewSet`` - telegram user class for changing language and time zone;\n\n\nRouting details\n********************\n\nIn this section, we will analyze the work of ``RouterCallbackMessageCommandHandler`` and ``telega_reverse`` in a little more detail.\n\nAs described earlier ``RouterCallbackMessageCommandHandler`` is used to be able to write handlers in the style\nDjango. Also ``RouterCallbackMessageCommandHandler`` provides the ability to handle calls to ``BotMenuElem`` as\nthrough commands, and through callback. This is achieved by using the functions ``all_command_bme_handler`` and\n``all_callback_bme_handler``. By default, ``BotMenuElem`` call handling is enabled and handled after\nno suitable path was found in the description of utrls (paths in Django notation). If there is no ``BotMenuElem`` element\nmatch is found, the ``BotMenuElem`` is considered to be configured incorrectly and an error message is returned to the user.\nYou can create a class with the ``only_utrl=True`` attribute, what is disable calls to ``BotMenuElem``.\n\nThe example template contains the use of the ``telega_reverse`` function, the essence of which is to generate a path (string) to\nhandler specified in the function argument. The function is analogous to the `reverse <https://docs.djangoproject.com/en/4.1/ref/urlresolvers/#reverse>`_ Django function\nand avoids errors when changing paths.\n\n\n\nTests\n**********************\n\nThe library also extends the ``django.test.TestCase`` capabilities for use with Telegram through the ``TD_TestCase`` class.\n\nThe simplest approach for testing the bot is to generate messages that the bot expects from Telegram and\nsending a response to Telegram (to check that the bot's response messages are in the correct format). Class ``TD_TestCase``\nhas a function ``create_update`` for easy and fast creation of ``Telegram.Update`` which generates the request\ntelegram user. So the overall design looks like this:\n\n1. A ``Telegram.Update`` is created for emitting a user request;\n2. The ``handle_update`` lambda function, which uses ``RouterCallbackMessageCommandHandler``,  is called with created update. It does its staff and as a result sends a real message to the test user. Due to this, the correctness of the responsing data format  is checked by Telegram;\n3. The correctness of the sent data and changes in the database is checked using the standard tools ``django.test.TestCase``.\n\nYou need to specify at least one test user ID in the ``TELEGRAM_TEST_USER_IDS`` settings section for correct tests work.\nMessages will be sent to that user, so the bot needs to have permission to write to that user.\n\nIn the ``tests`` folder you could find test examples.\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/alexanderaleskin/telegram_django_bot_bridge",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "telegram-django-bot",
    "package_url": "https://pypi.org/project/telegram-django-bot/",
    "platform": null,
    "project_url": "https://pypi.org/project/telegram-django-bot/",
    "project_urls": {
      "Homepage": "https://github.com/alexanderaleskin/telegram_django_bot_bridge"
    },
    "release_url": "https://pypi.org/project/telegram-django-bot/1.0.0/",
    "requires_dist": [
      "Django (>=3.0)",
      "python-telegram-bot (>=13.14)",
      "django-json-widget (>=1.1.1)",
      "django-admin-list-filter-dropdown (>=1.0.2)"
    ],
    "requires_python": ">=3.8",
    "summary": "Telegram Django Bot Bridge",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17288940,
  "releases": {
    "0.0.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ba53e7bc7aed1d6d169f9f9ce0bc19e600bc2f43fd39ba19553c01df3df696b8",
          "md5": "f13fa5aa815b5d3d12bb62625e3e5858",
          "sha256": "15e74a14d2969932802bfa5ba9c9dc209a5040812b1376d8fff65c314010d241"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.10-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f13fa5aa815b5d3d12bb62625e3e5858",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 31700,
        "upload_time": "2023-01-16T17:09:59",
        "upload_time_iso_8601": "2023-01-16T17:09:59.253899Z",
        "url": "https://files.pythonhosted.org/packages/ba/53/e7bc7aed1d6d169f9f9ce0bc19e600bc2f43fd39ba19553c01df3df696b8/telegram_django_bot-0.0.10-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "82fc64b2d9b86a43cc3b792a38c08f9f4d1404fe2f4c682e3a20f6496ba19e07",
          "md5": "fa8279d6441c4381b1836645828de6f0",
          "sha256": "ee5ae0c79978787b078bc7d437b62268093720fbe3d129ccd215782d02113c17"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.10.tar.gz",
        "has_sig": false,
        "md5_digest": "fa8279d6441c4381b1836645828de6f0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 30092,
        "upload_time": "2023-01-16T17:10:01",
        "upload_time_iso_8601": "2023-01-16T17:10:01.272358Z",
        "url": "https://files.pythonhosted.org/packages/82/fc/64b2d9b86a43cc3b792a38c08f9f4d1404fe2f4c682e3a20f6496ba19e07/telegram_django_bot-0.0.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ebf293a30a52862047ddfffaa462f6f2f74cc75d219b057fe5ca6ed69614f68c",
          "md5": "9b79b7db746142a49fd3c654d7869bef",
          "sha256": "c5e5f33b114e381ad448b437ff8928a6634415e8f720c2ce1e217a997df5d768"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.11-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9b79b7db746142a49fd3c654d7869bef",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 46942,
        "upload_time": "2023-01-17T13:36:02",
        "upload_time_iso_8601": "2023-01-17T13:36:02.912440Z",
        "url": "https://files.pythonhosted.org/packages/eb/f2/93a30a52862047ddfffaa462f6f2f74cc75d219b057fe5ca6ed69614f68c/telegram_django_bot-0.0.11-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3be7ac6e6267845521528d444de5c5973f8fb898acaaad2e13c232b1edabd583",
          "md5": "086c828ee87748f7109c02ef40ffacaf",
          "sha256": "855bcdb1c9bb853fac30936b1ba8defdc59463230f0cf61f8e7b0066125ddf7e"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.11.tar.gz",
        "has_sig": false,
        "md5_digest": "086c828ee87748f7109c02ef40ffacaf",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 38453,
        "upload_time": "2023-01-17T13:36:04",
        "upload_time_iso_8601": "2023-01-17T13:36:04.483590Z",
        "url": "https://files.pythonhosted.org/packages/3b/e7/ac6e6267845521528d444de5c5973f8fb898acaaad2e13c232b1edabd583/telegram_django_bot-0.0.11.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "213bdcd9e0932a294e6d1b708c9243c28316ae10fc732f28ad5d3740956fdbd3",
          "md5": "6f94448defce10d9b00d588bc1fb9034",
          "sha256": "c7f5454024cf389b67d4ca9717f5ee45bbffa4156d0f43e258f8ae8a4b128bc6"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6f94448defce10d9b00d588bc1fb9034",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 29497,
        "upload_time": "2023-01-06T13:12:10",
        "upload_time_iso_8601": "2023-01-06T13:12:10.334525Z",
        "url": "https://files.pythonhosted.org/packages/21/3b/dcd9e0932a294e6d1b708c9243c28316ae10fc732f28ad5d3740956fdbd3/telegram_django_bot-0.0.9-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "98414e4b224937a98fb4818912d3c93a9dec0050db9ae0f28e826268dba23b28",
          "md5": "cd8f0d17ac6400cf5aff06111dfbb482",
          "sha256": "b37b1b6d089638d09dec2e8ad6ed0504db23866908dd79e1acbfff08b86af768"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-0.0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "cd8f0d17ac6400cf5aff06111dfbb482",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 26118,
        "upload_time": "2023-01-06T13:12:11",
        "upload_time_iso_8601": "2023-01-06T13:12:11.977187Z",
        "url": "https://files.pythonhosted.org/packages/98/41/4e4b224937a98fb4818912d3c93a9dec0050db9ae0f28e826268dba23b28/telegram_django_bot-0.0.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "71c580e8eb0b8465b550d248da305df345e29147744087d4b794a576e1114abc",
          "md5": "0a5587559fcfa90e670e8e43dc555fee",
          "sha256": "a5c7008149289ca3337af1883b274b9d283456cf39c5900b362cd4eb3cf29da7"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0a5587559fcfa90e670e8e43dc555fee",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 58355,
        "upload_time": "2023-03-14T14:54:52",
        "upload_time_iso_8601": "2023-03-14T14:54:52.893390Z",
        "url": "https://files.pythonhosted.org/packages/71/c5/80e8eb0b8465b550d248da305df345e29147744087d4b794a576e1114abc/telegram_django_bot-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c6f84c92d5876485b5790c75d34e0b350cad4f0d7a3c7ccbe1987902d855ff48",
          "md5": "14dc3564a683646190e6228555b55cba",
          "sha256": "65da6a3032a465eeafb0a296788681f6838639ebcc9bba0013a3bb576f3c3b4e"
        },
        "downloads": -1,
        "filename": "telegram_django_bot-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "14dc3564a683646190e6228555b55cba",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 70758,
        "upload_time": "2023-03-14T14:54:55",
        "upload_time_iso_8601": "2023-03-14T14:54:55.042760Z",
        "url": "https://files.pythonhosted.org/packages/c6/f8/4c92d5876485b5790c75d34e0b350cad4f0d7a3c7ccbe1987902d855ff48/telegram_django_bot-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "71c580e8eb0b8465b550d248da305df345e29147744087d4b794a576e1114abc",
        "md5": "0a5587559fcfa90e670e8e43dc555fee",
        "sha256": "a5c7008149289ca3337af1883b274b9d283456cf39c5900b362cd4eb3cf29da7"
      },
      "downloads": -1,
      "filename": "telegram_django_bot-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0a5587559fcfa90e670e8e43dc555fee",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 58355,
      "upload_time": "2023-03-14T14:54:52",
      "upload_time_iso_8601": "2023-03-14T14:54:52.893390Z",
      "url": "https://files.pythonhosted.org/packages/71/c5/80e8eb0b8465b550d248da305df345e29147744087d4b794a576e1114abc/telegram_django_bot-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c6f84c92d5876485b5790c75d34e0b350cad4f0d7a3c7ccbe1987902d855ff48",
        "md5": "14dc3564a683646190e6228555b55cba",
        "sha256": "65da6a3032a465eeafb0a296788681f6838639ebcc9bba0013a3bb576f3c3b4e"
      },
      "downloads": -1,
      "filename": "telegram_django_bot-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "14dc3564a683646190e6228555b55cba",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 70758,
      "upload_time": "2023-03-14T14:54:55",
      "upload_time_iso_8601": "2023-03-14T14:54:55.042760Z",
      "url": "https://files.pythonhosted.org/packages/c6/f8/4c92d5876485b5790c75d34e0b350cad4f0d7a3c7ccbe1987902d855ff48/telegram_django_bot-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}