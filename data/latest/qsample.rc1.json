{
  "info": {
    "author": "Don Winter",
    "author_email": "don.winter@rwth-aachen.de",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Natural Language :: English",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "qsample\n================\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n- Docs: https://dpwinter.github.io/qsample/\n\n## Install\n\nAt the moment only build from source:\n\n    git clone https://github.com/dpwinter/qsample.git\n    cd qsample\n    python setup.py install\n\n## Prerequisites\n\n- This package requires Python 3.9 or higher.  \n- pdflatex (for circuit rendering)\n\n## When to use\n\nThis package is for you if you want to  \n\\* model circuit-level incoherent Pauli noise (we don’t do coherent\nnoise here, neither are our auxiliary qubits modelled as ideal)  \n\\* with high fidelity physical operations aka low physical error rates  \n\\* for a QEC protocol that consists of execution of one or more quantum\ncircuits with in-sequence measurements and feed-forward of measurement\ninformation  \n\\* over a specific range of varying physical error rates\n\n## Getting started\n\n------------------------------------------------------------------------\n\n### Library overview\n\n1.  Circuit\n2.  Protocol\n3.  Error Model\n4.  Simulator\n5.  Sampler  \n    5.1. Direct Sampler  \n    5.2. Interlude: Callbacks  \n    5.3. Subset Sampler\n\n### 1. Circuit\n\n- List of ticks\n- Each tick is a dictionary, key: gate type, value: set of qubit(s)\n- Recommended: 1 gate type per tick\n\n**Example:** Flagged-GHZ preparation: \\* Produce GHZ state on qubits\n0-3  \n\\* Flag-qubit 4, measure:  \n\\* 0: error-free\\*  \n\\* 1: flip on one data qubit\\*\n\n\\* Only for max. 1 allowed fault.\n\n``` python\nfrom qsample import Circuit\n```\n\n``` python\nghz = Circuit([ {\"init\": {0,1,2,3,4}},\n                {\"H\": {0}},\n                {\"CNOT\": {(0,1)}},\n                {\"CNOT\": {(1,2)}},\n                {\"CNOT\": {(2,3)}},\n                {\"CNOT\": {(3,4)}},\n                {\"CNOT\": {(0,4)}},\n                {\"measure\": {4}}], ff_det=True)\n```\n\n**ff_det**: fault-free deterministic. Set to `True` if circuit gives\nunique measurement result when executed without faults.\n\n``` python\nghz.draw()\n```\n\n![](index_files/figure-commonmark/cell-5-output-1.svg)\n\n### 2. Protocol\n\n- Graph (can be cyclic)\n  - Vertices: Circuits\n  - Edges: transition rules = boolean\\* functions (*checks*)\n  - Must include **start** and **end** nodes.\n\n\\* Exception: Correction functions can return circuits for on-the-fly\nexecution. (special case, will not show here)\n\n**Example:** Flagged-GHZ repeat(3)-until-success  \n\\* Execute flagged-GHZ circuit max. 3 times.  \n\\* Only repeat if measured `1`.  \n\\* If measured flag to be `0` within 3 iteration -\\> No fail  \n\\* If after 2 iterations 3rd measurement is also `1` -\\> Fail\n\n``` python\nfrom qsample import Protocol\n```\n\n``` python\nghz3 = Protocol(fault_tolerant=True)\n\nghz3.add_node('ghz', circuit=ghz) # Add node with corresponding circuit\nghz3.add_edge('START', 'ghz', check='True') # Transition START -> first circuit node always True\nghz3.add_edge('ghz', 'ghz', check='repeat(ghz)') # Transition to ghz if repeat(ghz) True.\nghz3.add_edge('ghz', 'FAIL', check='logErr(ghz)') # Transition to final node FAIL if logErr(ghz) True.\n```\n\n**fault_tolerant:** Define all weight-1 paths (circuit sequence with\nmax. 1 fault) to never result in a logical fail.\n\n``` python\nghz3.draw()\n```\n\n![](index_files/figure-commonmark/cell-8-output-1.png)\n\n- `repeat()` and `logErr()` are user-defined (boolean) check functions  \n- Measurement history of circuits stored during for protocol run\n  - Can access measurement history of any circuit by passing its name as\n    argument\n\nNext, we define what the two check functions should do:\n\n``` python\ndef repeat(msmt_list): # arg: list of ghz's measurment history\n    return len(msmt_list) < 3 and msmt_list[-1] == 1 # If True repeat ghz\n\ndef logErr(msmt_list):\n    return len(msmt_list) == 3 and msmt_list[-1] == 1 # If True transition to `FAIL`\n\nfunctions = {'logErr': logErr, 'repeat': repeat}\nghz3._check_fns.update(functions) # Let protocol know about user-defined checks\n```\n\n**Note**: It is also possible that **all checks are false**. In this\ncase the protocol exits “insignficantly”.  \nHere: “insignificant” when Flag=0 within 3 protocol runs -\\> Go to next\nprotocol run, i.e. sample.\n\n### 3. Error model\n\n- Strategy:\n  - Generate *fault* circuit $C_f$ of same length as reference circuit\n    $C$  \n  - During simulation iterate $C$ and $C_f$ simulateously and apply to\n    state  \n- Must include:\n  - `group()`: group circuit locations by key, e.g. all 1-qubit-gates  \n  - `select()`: picks certain amount of locations from each group (not\n    required by user)  \n  - `generate()`: generator function, returns a Pauli fault operator for\n    given location\n\n``` python\nfrom qsample import E1\n\nE1.groups, E1().group(ghz) # All gates in group `q`\n```\n\n    (['q'],\n     {'q': [(1, 0),\n       (2, (0, 1)),\n       (3, (1, 2)),\n       (4, (2, 3)),\n       (5, (3, 4)),\n       (6, (0, 4))]})\n\n### 4. Simulator\n\n- Two types available: Stabilizer (CHP) and Statevectors (ProjectQ\n  port), both well-tested\n  - https://github.com/Strilanc/python-chp-stabilizer-simulator\n  - https://github.com/ProjectQ-Framework/ProjectQ\n- Statevector simulator has more available gates and functions\n\n``` python\nfrom qsample import StabilizerSimulator as CHP\n```\n\n### 5. Sampler\n\n- Two types: Direct (Monte Carlo) and Subset sampler\n- All relevant information stored in\n  [`CountTree`](https://dpwinter.github.io/qsample/sampler.tree.html#counttree)\n  data structure\n\n### 5.1. Direct sampler\n\n``` python\nfrom qsample import DirectSampler\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\nLet’s define some physical error rates at which to sample:\n\n``` python\nsample_range = np.logspace(-3,0,5)\nerr_probs = {'q': sample_range} # Note: Must provide rate(s) for each group specified in `ErrorModel`\nerr_probs\n```\n\n    {'q': array([0.001     , 0.00562341, 0.03162278, 0.17782794, 1.        ])}\n\n``` python\ndsam = DirectSampler(protocol=ghz3, simulator=CHP, err_probs=err_probs, err_model=E1)\ndsam.run(10000)\n```\n\n    p_phy=1.00E-03:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=5.62E-03:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=3.16E-02:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=1.78E-01:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=1.00E+00:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n``` python\np_L, std = dsam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.plot(sample_range, sample_range,'k:', alpha=0.5)\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel('$p_{phy}$(q)')\nplt.ylabel('$p_L$');\n```\n\n![](index_files/figure-commonmark/cell-15-output-1.png)\n\nCheck what has been sampled for the last (1e0) physical error rate:\n\n``` python\ndsam.trees[(1.0,)].draw()\n```\n\n![](index_files/figure-commonmark/cell-16-output-1.png)\n\n### 5.2. Interlude: Callbacks\n\n- Used to receive intermediate results inside sampling process\n- E.g. we might want to avoid unnecessary samples (at large $p_{phy}$)\n  - We can use the callback `RelStdTarget`\n\n``` python\nfrom qsample import callbacks as cb\n\ndsam2 = DirectSampler(protocol=ghz3, simulator=CHP, err_probs=err_probs, err_model=E1)\ndsam2.run(10000, callbacks=[cb.RelStdTarget(target=0.2)])\n```\n\n    p_phy=1.00E-03:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=5.62E-03:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=3.16E-02:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    p_phy=1.78E-01:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    Rel. std target of 0.2 reached. Sampling stopped.\n\n    p_phy=1.00E+00:   0%|          | 0/10000 [00:00<?, ?it/s]\n\n    Rel. std target of 0.2 reached. Sampling stopped.\n\nAnother callback is\n[`VerboseCircuitExec`](https://dpwinter.github.io/qsample/callbacks.html#verbosecircuitexec),\nwhich gives a detailed log of which circuits, faults and measurements\ntook place:\n\n``` python\ndsam3 = DirectSampler(protocol=ghz3, simulator=CHP, err_probs={'q': 0.1}, err_model=E1)\ndsam3.run(10, callbacks=[cb.VerboseCircuitExec()])\n```\n\n    p_phy=1.00E-01:   0%|          | 0/10 [00:00<?, ?it/s]\n\n    ghz -> Faults: [] -> Msmt: 0\n    None\n    ghz -> Faults: [] -> Msmt: 0\n    None\n    ghz -> Faults: [(6, {'Y': {0}})] -> Msmt: 0\n    None\n    ghz -> Faults: [] -> Msmt: 0\n    None\n    ghz -> Faults: [(4, {'Z': {2}})] -> Msmt: 0\n    None\n    ghz -> Faults: [(1, {'Z': {0}})] -> Msmt: 0\n    None\n    ghz -> Faults: [] -> Msmt: 0\n    None\n    ghz -> Faults: [] -> Msmt: 0\n    None\n    ghz -> Faults: [(4, {'X': {2}})] -> Msmt: 0\n    None\n    ghz -> Faults: [(2, {'Y': {0}, 'Z': {1}}), (5, {'Z': {3}})] -> Msmt: 1\n    ghz -> Faults: [] -> Msmt: 0\n    None\n\nWe can also write our own callback. Every sampler has 6 callback\nhooks:  \n\\* Begin/End sampler  \n\\* Begin/End protocol  \n\\* Begin/End circuit\n\n### 5.3. Subset Sampler\n\n- Samples only at one physical error rate `pmax`\n- Scaling obtained analytically\n- `pmax` must be chosen in “representative” region\n\n*Note*: 1. For multi-parameter error model `pmax` is a tuple of one\nphysical error rate per group.  \n2. The choice of `pmax` has a direct impact of which subsets are\nsampled.\n\nHow to choose `pmax`? What is the heuristic?  \n\\* We want to sample, s.t. the subset occurence probability is max. for\n0-weight subset and subsequently falling for higher order subsets.  \n\\* We want to have also relatively high probability for other\n(important) subsets, i.e. weight-1, weight-2,..\n\n**Example:** For the Flagged-GHZ circuit we would choose a `pmax` close\nto 0.1:\n\n``` python\nfrom qsample.sampler.base import subset_occurence, all_subsets, err_probs_tomatrix\n\ngrp = E1().group(ghz).values()\nwgts_combis = all_subsets(grp)\n\nfor p_phy in [0.01, 0.1, 0.3]:\n    Aws = subset_occurence(grp, wgts_combis, p_phy)\n    plt.figure()\n    plt.title(\"Subset occurence prob. $A_w$ at $p_{phy}$=%.2f\" % p_phy)\n    plt.bar(range(len(Aws)), Aws)\n    plt.ylabel(\"$A_w$\")\n    plt.xlabel(\"Subsets\")\n```\n\n![](index_files/figure-commonmark/cell-19-output-1.png)\n\n![](index_files/figure-commonmark/cell-19-output-2.png)\n\n![](index_files/figure-commonmark/cell-19-output-3.png)\n\n``` python\nfrom qsample import SubsetSampler\n```\n\n``` python\npmax = {'q': 0.1}\n\nss_sam = SubsetSampler(ghz3, CHP,  pmax=pmax, err_probs=err_probs, err_model=E1)\nss_sam.run(300)\n```\n\n    p_phy=1.00E-01:   0%|          | 0/300 [00:00<?, ?it/s]\n\n*Note*: Although we passed `err_probs` those are not used for sampling.\nOnly when we call `stats()` those probs are used:\n\n``` python\np_L_low, std_low, p_L_up, std_up = ss_sam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low - std_low, p_L_low + std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up - std_up, p_L_up + std_up, alpha=0.2)\nplt.plot(sample_range, sample_range,'k:', alpha=0.5)\nplt.xlabel('$p_{phy}$(q)')\nplt.ylabel('$p_L$')\nplt.legend();\n```\n\n![](index_files/figure-commonmark/cell-22-output-1.png)\n\nWe sampled at a single error rate with much less samples and get a much\nbetter bound on the logical error rate. Let’s inspect what has been\nsampled:\n\n``` python\nss_sam.tree.draw() # only one tree\n```\n\n![](index_files/figure-commonmark/cell-23-output-1.png)\n\nWe can store and later reload our sample results:\n\n``` python\nss_sam.save('ghz3ss.samp')\n\nfrom qsample import Sampler\nstored_sam = Sampler.load('ghz3ss.samp')\ncounts_before = stored_sam.tree.root.counts\n\nstored_sam.run(200) # After loading we can for example run a few more samples.\ncounts_after = stored_sam.tree.root.counts\n\nprint(counts_before, counts_after)\n```\n\n    p_phy=1.00E-01:   0%|          | 0/200 [00:00<?, ?it/s]\n\n    300 500\n\nMore complex examples can be found here:\nhttps://github.com/dpwinter/qsample/blob/master/08_examples.ipynb\n\n## Contribute\n\n- submit your feature request via github issue\n\n## Team\n\n`qsample` was developed by Don Winter based on and in collaboration with\nSascha Heußen under supervision of Prof. Dr. Markus Müller.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/dpwinter/qsample/tree/master/",
    "keywords": "qecc,circuit,protocol,sample,sampling",
    "license": "Apache Software License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "qsample",
    "package_url": "https://pypi.org/project/qsample/",
    "platform": null,
    "project_url": "https://pypi.org/project/qsample/",
    "project_urls": {
      "Homepage": "https://github.com/dpwinter/qsample/tree/master/"
    },
    "release_url": "https://pypi.org/project/qsample/0.0.1/",
    "requires_dist": [
      "anytree",
      "chp-sim",
      "dill",
      "latextools",
      "matplotlib",
      "networkx",
      "numpy (<=1.23)",
      "projectq",
      "pydot",
      "scipy",
      "simpleeval",
      "tqdm"
    ],
    "requires_python": ">=3.9",
    "summary": "Efficient sampling of noisy quantum circuits and protocols",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16823279,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8a84d4e41dd495bf6de06a5821db0901adeaaf7119b8d2ef1c9f346be7f952da",
          "md5": "a222ee1abc7b1274eca9d0035de9cd1e",
          "sha256": "98b7023a4fbed203b7672301ebe35c37c9788a3acd15e0c7e40761f9f6b0da16"
        },
        "downloads": -1,
        "filename": "qsample-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a222ee1abc7b1274eca9d0035de9cd1e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 36539,
        "upload_time": "2023-02-12T14:47:43",
        "upload_time_iso_8601": "2023-02-12T14:47:43.946136Z",
        "url": "https://files.pythonhosted.org/packages/8a/84/d4e41dd495bf6de06a5821db0901adeaaf7119b8d2ef1c9f346be7f952da/qsample-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "12b1f0296c63f960151409464e938fa9d80e0322ff3a09fb91575474cca08af0",
          "md5": "f678417f486d9454224f92e922808520",
          "sha256": "9bc17391484d520f1a16937ef14e08059a12a0b49d3dbfc6891ee5047550e1f7"
        },
        "downloads": -1,
        "filename": "qsample-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f678417f486d9454224f92e922808520",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 39240,
        "upload_time": "2023-02-12T14:47:47",
        "upload_time_iso_8601": "2023-02-12T14:47:47.730797Z",
        "url": "https://files.pythonhosted.org/packages/12/b1/f0296c63f960151409464e938fa9d80e0322ff3a09fb91575474cca08af0/qsample-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8a84d4e41dd495bf6de06a5821db0901adeaaf7119b8d2ef1c9f346be7f952da",
        "md5": "a222ee1abc7b1274eca9d0035de9cd1e",
        "sha256": "98b7023a4fbed203b7672301ebe35c37c9788a3acd15e0c7e40761f9f6b0da16"
      },
      "downloads": -1,
      "filename": "qsample-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a222ee1abc7b1274eca9d0035de9cd1e",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.9",
      "size": 36539,
      "upload_time": "2023-02-12T14:47:43",
      "upload_time_iso_8601": "2023-02-12T14:47:43.946136Z",
      "url": "https://files.pythonhosted.org/packages/8a/84/d4e41dd495bf6de06a5821db0901adeaaf7119b8d2ef1c9f346be7f952da/qsample-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "12b1f0296c63f960151409464e938fa9d80e0322ff3a09fb91575474cca08af0",
        "md5": "f678417f486d9454224f92e922808520",
        "sha256": "9bc17391484d520f1a16937ef14e08059a12a0b49d3dbfc6891ee5047550e1f7"
      },
      "downloads": -1,
      "filename": "qsample-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "f678417f486d9454224f92e922808520",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.9",
      "size": 39240,
      "upload_time": "2023-02-12T14:47:47",
      "upload_time_iso_8601": "2023-02-12T14:47:47.730797Z",
      "url": "https://files.pythonhosted.org/packages/12/b1/f0296c63f960151409464e938fa9d80e0322ff3a09fb91575474cca08af0/qsample-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}