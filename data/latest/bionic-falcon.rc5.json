{
  "info": {
    "author": "Gary Monson, Cami McCarthy",
    "author_email": "camilla@enodoinc.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.4",
      "Topic :: Database :: Front-Ends",
      "Topic :: Internet :: WWW/HTTP",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
      "Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware"
    ],
    "description": "Bionic Falcon – Automated CRUD operations for Falcon 2\n======================================================\n\nMakes RESTful CRUD easier.\n\nAcknowledgements\n----------------\n\nThis is a Falcon 2 compatible adaptation of Gary Monson’s Falcon\nAutoCRUD package – huge props to him for building out an amazing set of\nfeatures! I very much plan to keep this package in the same spirit and\nformat as the original.\n\nQuick start for contributing\n----------------------------\n\n::\n\n   virtualenv -p `which python3` virtualenv\n   source virtualenv/bin/activate\n   pip install -r requirements.txt\n   pip install -r dev_requirements.txt\n   nosetests\n\nThis runs the tests with SQLite. To run the tests with Postgres (using\npg8000), you must have a Postgres server running, and a postgres user\nwith permission to create databases:\n\n::\n\n   export BIONIC_DSN=postgresql+pg8000://myuser:mypassword@localhost:5432\n   nosetests\n\nSome tests are run only when testing on Postgres due to only being\nrelevant to Postgres, such as when testing features to do with Postgres\ndata types.\n\nUsage\n-----\n\nDeclare your SQLAlchemy models:\n\n::\n\n   from sqlalchemy.ext.declarative import declarative_base\n   from sqlalchemy import create_engine, Column, Integer, String\n\n   Base = declarative_base()\n\n   class Employee(Base):\n       __tablename__ = 'employees'\n       id      = Column(Integer, primary_key=True)\n       name    = Column(String(50))\n       age     = Column(Integer)\n\nDeclare your resources:\n\n::\n\n   from bionic_falcon.resource import CollectionResource, SingleResource\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n   class EmployeeResource(SingleResource):\n       model = Employee\n\nApply them to your app, ensuring you pass an SQLAlchemy engine to the\nresource classes:\n\n::\n\n   from sqlalchemy import create_engine\n   import falcon\n   from bionic_falcon.middleware import Middleware\n\n   db_engine = create_engine('sqlite:///stuff.db')\n\n   app = falcon.API(\n       middleware=[Middleware()],\n   )\n\n   app.add_route('/employees', EmployeeCollectionResource(db_engine))\n   app.add_route('/employees/{id}', EmployeeResource(db_engine))\n\nThis automatically creates RESTful endpoints for your resources:\n\n::\n\n   http GET http://localhost/employees\n   http GET http://localhost/employees?name=Bob\n   http GET http://localhost/employees?age__gt=24\n   http GET http://localhost/employees?age__gte=25\n   http GET http://localhost/employees?age__lt=25\n   http GET http://localhost/employees?age__lte=24\n   http GET http://localhost/employees?name__contains=John\n   http GET http://localhost/employees?name__startswith=John\n   http GET http://localhost/employees?name__endswith=Smith\n   http GET http://localhost/employees?name__icontains=john\n   http GET http://localhost/employees?name__istartswith=john\n   http GET http://localhost/employees?name__iendswith=smith\n   http GET http://localhost/employees?name__in=[Grace Hopper,Ada Lovelace]\n   http GET http://localhost/employees?company_id__null=1\n   http GET http://localhost/employees?company_id__null=0\n   echo '{\"name\": \"Jim\"}' | http POST http://localhost/employees\n   http GET http://localhost/employees/100\n   echo '{\"name\": \"Jim\"}' | http PUT http://localhost/employees/100\n   echo '{\"name\": \"Jim\"}' | http PATCH http://localhost/employees/100\n   http DELETE http://localhost/employees/100\n   # POST an array to add entities in bulk\n   echo '[{\"name\": \"Carol\"}, {\"name\": \"Elisa\"}]' | http POST http://localhost/employees\n\nNote that by default, PUT will only update, and will not insert a new\nresource if a matching one does not exist at the address. If you wish\nnew resources to be created, then add the following to your resource:\n\n::\n\n   allow_put_insert = True\n\nLimiting methods\n~~~~~~~~~~~~~~~~\n\nBy default collections will autogenerate methods GET, POST and PATCH,\nwhile single resources will autogenerate methods GET, PUT, PATCH,\nDELETE.\n\nTo limit which methods are autogenerated for your resource, simply list\nmethod names as follows:\n\n::\n\n   # Able to create and search collection:\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n       methods = ['GET', 'POST']\n\n   # Only able to read individual accounts:\n   class AccountResource(CollectionResource):\n       model = Account\n       methods = ['GET']\n\nPre-method functionality.\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo do something before a POST or PATCH method is called, add special\nmethods as follows:\n\n::\n\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n\n       def before_post(self, req, resp, db_session, resource, *args, **kwargs):\n         # Anything you do with db_session is in the same transaction as the\n         # resource creation.  Resource is the new resource not yet added to the\n         # database.\n         pass\n\n   class AccountResource(SingleResource):\n       model = Account\n\n       def before_patch(self, req, resp, db_session, resource, *args, **kwargs):\n         # Anything you do with db_session is in the same transaction as the\n         # resource update.  Resource is the modified resource not yet saved to\n         # the database.\n         pass\n\n       def before_delete(self, req, resp, db_session, resource, *args, **kwargs):\n         # Anything you do with db_session is in the same transaction as the\n         # resource delete.  Resource is the resource to be deleted (or \"marked as\n         deleted\" - see section on \"not really deleting\").\n         pass\n\nPost-method functionality\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo do something after success of a method, add special methods as\nfollows:\n\n::\n\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n\n       def after_get(self, req, resp, collection, *args, **kwargs):\n           # 'collection' is the SQLAlchemy collection resulting from the search\n           pass\n\n       def after_post(self, req, resp, new, *args, **kwargs):\n           # 'new' is the created SQLAlchemy instance\n           pass\n\n       def after_patch(self, req, resp, *args, **kwargs):\n           pass\n\n\n   class AccountResource(CollectionResource):\n       model = Account\n\n       def after_get(self, req, resp, item, *args, **kwargs):\n           # 'item' is the retrieved SQLAlchemy instance\n           pass\n\n       def after_put(self, req, resp, item, *args, **kwargs):\n           # 'item' is the changed SQLAlchemy instance\n           pass\n\n       def after_patch(self, req, resp, item, *args, **kwargs):\n           # 'item' is the patched SQLAlchemy instance\n           pass\n\n       def after_delete(self, req, resp, item, *args, **kwargs):\n           pass\n\nBe careful not to throw an exception in the above methods, as this will\nend up propagating a 500 Internal Server Error.\n\nModifying a patch\n~~~~~~~~~~~~~~~~~\n\nIf you want to modify the patched resource before it is saved (e.g. to\nset default values), you can override the default empty method in\nSingleResource:\n\n::\n\n   class AccountResource(SingleResource):\n       model = Account\n\n       def modify_patch(self, req, resp, resource, *args, **kwargs):\n           \"\"\"\n           Add 'arino' to people's names\n           \"\"\"\n           resource.name = resource.name + 'arino'\n\nIdentification and Authorization\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefine classes that know how to identify and authorize users:\n\n::\n\n   class TestIdentifier(object):\n       def identify(self, req, resp, resource, params):\n           req.context['user'] = req.get_header('Authorization')\n           if req.context['user'] is None:\n               raise HTTPUnauthorized('Authentication Required', 'No credentials supplied')\n\n   class TestAuthorizer(object):\n       def authorize(self, req, resp, resource, params):\n           if 'user' not in req.context or req.context['user'] != 'Jim':\n               raise HTTPForbidden('Permission Denied', 'User does not have access to this resource')\n\nThen declare which class identifies/authorizes what resource or method:\n\n::\n\n   # Authorizes for all methods\n   @identify(TestIdentifier)\n   @authorize(TestAuthorizer)\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n\n   # Or only some methods\n   @identify(TestIdentifier)\n   @authorize(TestAuthorizer, methods=['GET', 'POST'])\n   @authorize(OtherAuthorizer, methods=['PATCH'])\n   class OtherAccountCollectionResource(CollectionResource):\n       model = Account\n\nFilters/Preconditions\n~~~~~~~~~~~~~~~~~~~~~\n\nYou may filter on GET, and set preconditions on single resource PATCH or\nDELETE:\n\n::\n\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           # Only allow getting accounts below id 5\n           return query.filter(Account.id < 5)\n\n   class AccountResource(SingleResource):\n       model = Account\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           # Only allow getting accounts below id 5\n           return query.filter(Account.id < 5)\n\n       def patch_precondition(self, req, resp, query, *args, **kwargs):\n           # Only allow setting owner of non-owned account\n           if 'owner' in req.context['doc'] and req.context['doc']['owner'] is not None:\n               return query.filter(Account.owner == None)\n           else:\n               return query\n\n       def delete_precondition(self, req, resp, query, *args, **kwargs):\n           # Only allow deletes of non-owned accounts\n           return query.filter(Account.owner == None)\n\nNote that there is an opportunity for a race condition here, where\nanother process updates the row AFTER the check triggered by\npatch_precondition is run, but BEFORE the row update. This would leave\ninconsistent data in your application if the other update would make the\nprecondition no longer hold.\n\nTo prevent this, you can simply add a `versioning\ncolumn <http://docs.sqlalchemy.org/en/latest/orm/versioning.html>`__ to\nyour model. When your model contains such a column, then as long as you\nhave a precondition to check for the correct conditions before updating,\nyou will be guaranteed that if another process changes the row in the\nmeantime, you will fail to update, and a 409 response will be returned.\nThis doesn’t necessarily mean the row no longer conforms to the\nprecondition, so you can try the update again, and it will update if the\nprecondition still holds.\n\nThis versioning only helps you on an UPDATE, not a DELETE, so if you\nwant a delete_precondition to be protected, you will need to use\nmark_deleted to update the row (see “not really deleting”, next),\ninstead of doing a true delete.\n\nNot really deleting\n~~~~~~~~~~~~~~~~~~~\n\nIf you want to just mark a resource as deleted in the database, but not\nreally delete the row, define a ‘mark_deleted’ in your SingleResource\nsubclass:\n\n::\n\n   class AccountResource(SingleResource):\n       model = Account\n\n       def mark_deleted(self, req, resp, instance, *args, **kwargs):\n           instance.deleted = datetime.utcnow()\n\nThis will cause the changed instance to be updated in the database\ninstead of doing a DELETE.\n\nOf course, the database row will still be accessible via GET, but you\ncan automatically filter out “deleted” rows like this:\n\n::\n\n   class AccountCollectionResource(CollectionResource):\n       model = Account\n\n       def get_filter(self, req, resp, resources, *args, **kwargs):\n           return resources.filter(Account.deleted == None)\n\n   class AccountResource(SingleResource):\n       model = Account\n\n       def get_filter(self, req, resp, resources, *args, **kwargs):\n           return resources.filter(Account.deleted == None)\n\n       def mark_deleted(self, req, resp, instance, *args, **kwargs):\n           instance.deleted = datetime.utcnow()\n\nYou could also look at the request to only filter out “deleted” rows for\nsome users.\n\nJoins\n~~~~~\n\nIf you want to add query parameters to your collection queries, that do\nnot refer to a resource attribute, but which refer to an attribute in a\nlinked table, you can do this in get_filter, as with the below example.\nEnsure that you remove the extra parameter value from req.params before\nreturning from get_filter, as bionic-falcon will try (and fail) to look\nup the parameter in the main resource class.\n\n::\n\n   class Company(Base):\n       __tablename__ = 'companies'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50), unique=True)\n       employees   = relationship('Employee')\n\n   class Employee(Base):\n       __tablename__ = 'employees'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50), unique=True)\n       company_id  = Column(Integer, ForeignKey('companies.id'), nullable=True)\n       company     = relationship('Company', back_populates='employees')\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           if 'company_name' in req.params:\n               company_name = req.params['company_name']\n               del req.params['company_name']\n               query = query.join(Employee.company).filter(Company.name == company_name)\n           return query\n\nAlternatively, for arguments that are part of the URL you may use\nlookup_attr_map directly (note that attr_map is now deprecated - see\nbelow):\n\n::\n\n   class CompanyEmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       lookup_attr_map = {\n           'company_id':   lambda req, resp, query, *args, **kwargs: query.join(Employee.company).filter(Company.id == kwargs['company_id'])\n       }\n\nThis is useful for the following sort of URL:\n\n::\n\n   GET /companies/{company_id}/employees\n\nMapping\n~~~~~~~\n\nMapping used to be done with attr_map. This is now deprecated in favour\nof lookup_attr_map and inbound_attr_map (since attr_map was used for two\ndifferent purposes before).\n\nTo look up an entry via part of the URL:\n\n::\n\n   GET /companies/{company_id}/employees\n\nUse the name of the column to map to:\n\n::\n\n   class CompanyEmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       lookup_attr_map = {\n           'company_id': 'coy_id'\n       }\n\nOr use a lambda to return a modified query:\n\n::\n\n   class CompanyEmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       lookup_attr_map = {\n           'company_id': lambda req, resp, query, *args, **kwargs: query.join(Employee.company).filter(Company.id == kwargs['company_id'])\n       }\n\nYou may use inbound_attr_map to specify mappings to place the value from\na URL component into another field:\n\n::\n\n   class CompanyEmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       inbound_attr_map = {\n           'company_id': 'coy_id'\n       }\n\nBoth lookup_attr_map and inbound_attr_map may have a mapping value set\nto None, in which case the mapping key in the URL component is ignored.\n\nSorting\n~~~~~~~\n\nYou can specify a default sorting of results from the collection search.\nThe below example sorts firstly by name, then by salary descending:\n\n::\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n       default_sort = ['name', '-salary']\n\nThe caller can specify a sort (which overrides the default if defined):\n\n::\n\n   GET /path/to/collection?__sort=name,-salary\n\nPaging\n~~~~~~\n\nThe caller can specify an offset and/or limit to collection GET to\nprovide paging of search results.\n\n::\n\n   GET /path/to/collection?__offset=10&__limit=10\n\nThis is generally most useful in combination with \\__sort to ensure\nconsistency of sorting.\n\nLimiting response fields\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can limit which fields are returned to the client like this:\n\n::\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n       response_fields = ['id', 'name']\n\nOr you can limit them programmatically like this:\n\n::\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n\n       def response_fields(self, req, resp, resource, *args, **kwargs):\n           # Determine response fields via things such as authenticated user\n           return fields\n\nCreating linked resources\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe collection POST method allows creation of linked resources in the\none POST call. If your model includes a relationship to the linked\nresource, you can include the attributes to use in the new linked\nresource, and the link will be automatically made in the database:\n\n::\n\n   class Company(Base):\n       __tablename__ = 'companies'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50), unique=True)\n       employees   = relationship('Employee')\n\n   class Employee(Base):\n       __tablename__ = 'employees'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50), unique=True)\n       company_id  = Column(Integer, ForeignKey('companies.id'), nullable=True)\n       company     = relationship('Company', back_populates='employees')\n\n   class CompanyCollectionResource(CollectionResource):\n       model = Company\n       allow_subresources = True\n\n::\n\n   cat post.json\n   {\n     name: \"Initech\",\n     employees: [\n       {\n         name: \"Alice\"\n       },\n       {\n         name: \"Bob\"\n       }\n     ]\n   }\n\n   cat post.json | http POST http://localhost/companies\n\nThis will create a company called Initech and two employees, who will be\nlinked to Initech via Employee.company_id. Note the that\nCollectionResource subclass must have the attribute allow_subresources\nand set it to True, for this feature to be enabled.\n\nBulk operations\n~~~~~~~~~~~~~~~\n\nYou can bulk add entities using a PATCH method to a collection. If the\ncollection is defined in the standard way, you are limited to adding to\nonly that model:\n\n::\n\n   class EmployeeCollectionResource(CollectionResource):\n       model = Employee\n\nTo add to the employee collection, each operation’s path must be ‘/’:\n\n::\n\n   echo '{\"patches\": [{\"op\": \"add\", \"path\": \"/\", \"value\": {\"name\": \"Jim\"}}]}' | http PATCH http://localhost/employees\n\nIf you would like to be able to add to multiple types of collection in\none bulk update, define the path and model for each in a special\ncollection:\n\n::\n\n   class RootResource(CollectionResource):\n       patch_paths = {\n         '/employees': Employee,\n         '/accounts':  Account,\n       }\n\n   app.add_route('/', RootResource(db_engine))\n\nTo add to the collections, each operation’s path must be in the defined\npatch_paths:\n\n::\n\n   cat patches.json\n   {\n     \"patches\": [\n       {\"op\": \"add\", \"path\": \"/employees\", \"value\": {\"name\": \"Jim\"}}\n       {\"op\": \"add\", \"path\": \"/accounts\", \"value\": {\"name\": \"Sales\"}}\n     ]\n   }\n   cat patches.json | http PATCH http://localhost/employees\n\nAll the operations done in a single PATCH are performed within a\ntransaction.\n\nNaive datetimes\n~~~~~~~~~~~~~~~\n\nNormally a datetime is assumed to be in UTC, so they are expected to be\nin the format ‘YYYY-mm-ddTHH:MM:SSZ’, and are also output like that.\n\nSometimes (not often!) you need to store a “naive” datetime, where time\nzone is not relevant (e.g. to store the datetime of a nationwide public\nholiday, where the time zone is not relevant, and the “real” date/time\nis simply in the local time zone, whatever that might be - i.e. the\nclient can treat is as being in their own localtime.\n\nFor cases such as this, set the naive_datetimes class variable as a list\nof the column names to be treated as naive datetimes:\n\n::\n\n   class PublicHolidayCollectionResource(CollectionResource):\n       model = PublicHoliday\n       naive_datetimes = ['start', 'end']\n\nThese fields will then be parsed and returned in the format\n‘YYYY-mm-ddTHH:MM:SS’, i.e. without the ‘Z’ suffix.\n\nAdditionally, when a numeric datetime is desired rather than a a\ndatetime string, you can similarly specify that the resource should\ntreat any input and output as a number representing milliseconds since\nthe Unix epoch.\n\n::\n\n   class DeadlineCollectionResource(CollectionResource):\n       model = Deadlines\n       datetime_in_ms = ['started_on', 'due_by']\n\nMeta-information\n~~~~~~~~~~~~~~~~\n\nTo add meta-information to each resource in a collection response,\nassuming your models are:\n\n::\n\n   class Team(Base):\n       __tablename__ = 'teams'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50))\n       characters  = relationship('Character')\n\n   class Character(Base):\n       __tablename__ = 'characters'\n       id          = Column(Integer, primary_key=True)\n       name        = Column(String(50))\n\n       team_id     = Column(Integer, ForeignKey('teams.id'), nullable=True)\n       team        = relationship('Team', back_populates='characters')\n\nThen include the following:\n\n::\n\n   catchphrases = {\n       'Oliver':   'You have failed this city',\n       'Cisco':    \"OK, you don't get to pick the names\",\n   }\n\n   class CharacterCollectionResource(CollectionResource):\n       model = Character\n       resource_meta = {\n           'catchphrase':  lambda resource: catchphrases.get(resource.name, None)\n       }\n\nTo add meta-information to the top level of a single resource response,\ninclude the following:\n\n::\n\n   catchphrases = {\n       'Oliver':   'You have failed this city',\n       'Cisco':    \"OK, you don't get to pick the names\",\n   }\n\n   class CharacterResource(SingleResource):\n       model = Character\n       meta = {\n           'catchphrase':  lambda resource: catchphrases.get(resource.name, None)\n       }\n\nYou can join another table to get the meta information:\n\n::\n\n   class CharacterCollectionResource(CollectionResource):\n       model = Character\n       resource_meta = {\n           'catchphrase':  lambda resource, team_name: catchphrases.get(resource.name, None),\n           'team_name':    lambda resource, team_name: team_name,\n       }\n       extra_select = [Team.name]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Team)\n\n   class CharacterResource(SingleResource):\n       model = Character\n       meta = {\n           'catchphrase':  lambda resource, team_name: catchphrases.get(resource.name, None),\n           'team_name':    lambda resource, team_name: team_name,\n       }\n       extra_select = [Team.name]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Team)\n\nYou can even use SQL functions to calculate the values in the\nmeta-information:\n\n::\n\n   from sqlalchemy import func\n\n   class TeamCollectionResource(CollectionResource):\n       model = Team\n       resource_meta = {\n           'team_size': lambda resource, team_size: team_size,\n       }\n       extra_select = [func.count(Character.id)]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Character).group_by(Team.id)\n\n   class TeamResource(SingleResource):\n       model = Team\n       meta = {\n           'team_size': lambda resource, team_size: team_size,\n       }\n       extra_select = [func.count(Character.id)]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Character).group_by(Team.id)\n\nOr you can determine them entirely programmatically like this:\n\n::\n\n   class TeamCollectionResource(CollectionResource):\n       model = Team\n       def resource_meta(self, req, resp, resource, team_size, *args, **kwargs):\n           return {\n               'team_size': team_size,\n           }\n       extra_select = [func.count(Character.id)]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Character).group_by(Team.id)\n\n   class TeamResource(SingleResource):\n       model = Team\n       def meta(self, req, resp, resource, team_size, *args, **kwargs):\n           return {\n               'team_size': team_size,\n           }\n       extra_select = [func.count(Character.id)]\n\n       def get_filter(self, req, resp, query, *args, **kwargs):\n           return query.join(Character).group_by(Team.id)\n\nThe advantage of using the above method is that the keys can also be\ndetermined at runtime, and may change in difference circumstances\n(e.g. according to query parameters, or the permissions of the caller).\nTo include NO meta at all for the resource, return None from\n``resource_meta`` or ``meta`` functions.\n\nAccess to submitted data\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nNote that the request body can be accessed (e.g. in pre-method\nfunctionality function) either from ``req.context['doc']`` (as JSON), or\nthe original binary body content is available in\n``req.context['request_body']`` if you specify that the HTTP method\nshould retain it:\n\n::\n\n   class TeamResource(CollectionResource):\n     model = Team\n     keep_request_body = ['POST']\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/enodoscore/falcon-autocrud",
    "keywords": "falcon crud rest database",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "bionic-falcon",
    "package_url": "https://pypi.org/project/bionic-falcon/",
    "platform": null,
    "project_url": "https://pypi.org/project/bionic-falcon/",
    "project_urls": {
      "Homepage": "https://github.com/enodoscore/falcon-autocrud"
    },
    "release_url": "https://pypi.org/project/bionic-falcon/1.1.0/",
    "requires_dist": [
      "falcon (>=2.0.0)",
      "jsonschema",
      "sqlalchemy"
    ],
    "requires_python": "",
    "summary": "Automate CRUD actions with a Falcon API",
    "version": "1.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13668698,
  "releases": {
    "1.0.37": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "468a0245a87d9273b05ad870eb79ba46e83a0ca332e04105e7698fca9b19fc85",
          "md5": "d27112ff9c6519c4fcda54219313a34d",
          "sha256": "450c93676a6b978aa9d3d9b67f56c80b2f0aaa1e8ae75a504e94c7cea7ec64c9"
        },
        "downloads": -1,
        "filename": "bionic_falcon-1.0.37-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d27112ff9c6519c4fcda54219313a34d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 45981,
        "upload_time": "2021-05-19T19:22:06",
        "upload_time_iso_8601": "2021-05-19T19:22:06.146100Z",
        "url": "https://files.pythonhosted.org/packages/46/8a/0245a87d9273b05ad870eb79ba46e83a0ca332e04105e7698fca9b19fc85/bionic_falcon-1.0.37-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dcaf9555ed2626d0b4c12becb53c1949885b27abd21bb09f2e7de1e6e346cb43",
          "md5": "ccddfa5e76e5e4cbc4ac64d89d671cf4",
          "sha256": "05ba6d16aa3529506ba7d329efd85a444541ce52caedbee941e5f04d7d3a44e7"
        },
        "downloads": -1,
        "filename": "bionic-falcon-1.0.37.tar.gz",
        "has_sig": false,
        "md5_digest": "ccddfa5e76e5e4cbc4ac64d89d671cf4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 46760,
        "upload_time": "2021-05-19T19:22:13",
        "upload_time_iso_8601": "2021-05-19T19:22:13.842784Z",
        "url": "https://files.pythonhosted.org/packages/dc/af/9555ed2626d0b4c12becb53c1949885b27abd21bb09f2e7de1e6e346cb43/bionic-falcon-1.0.37.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.38": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7f629206dc63f4951286e2d144beb1d57cdc286571e8e9bd5355a5d2b5f3b2ac",
          "md5": "8051138737ed47ce557ab2b2c5cb7282",
          "sha256": "153733e8a6ab01d8808d203b885d13bebaa0badc9aa48876628b8494c3ae5376"
        },
        "downloads": -1,
        "filename": "bionic_falcon-1.0.38-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8051138737ed47ce557ab2b2c5cb7282",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 46039,
        "upload_time": "2021-06-03T18:34:15",
        "upload_time_iso_8601": "2021-06-03T18:34:15.613594Z",
        "url": "https://files.pythonhosted.org/packages/7f/62/9206dc63f4951286e2d144beb1d57cdc286571e8e9bd5355a5d2b5f3b2ac/bionic_falcon-1.0.38-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "79851dad923b8aff11a2193bcf9d67458cb6e22502dd0328c9b7bb790c78c075",
          "md5": "5dbc051a275edc831c19e08ed5654901",
          "sha256": "2d935485a016035236124687374f7694ff84329f23bdac287a682273bb055d7b"
        },
        "downloads": -1,
        "filename": "bionic-falcon-1.0.38.tar.gz",
        "has_sig": false,
        "md5_digest": "5dbc051a275edc831c19e08ed5654901",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 45619,
        "upload_time": "2021-06-03T18:34:16",
        "upload_time_iso_8601": "2021-06-03T18:34:16.746124Z",
        "url": "https://files.pythonhosted.org/packages/79/85/1dad923b8aff11a2193bcf9d67458cb6e22502dd0328c9b7bb790c78c075/bionic-falcon-1.0.38.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.39": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2e9df8df7406479876aceb25263adbd534d65de3d52d35cea6ff20cfc744917b",
          "md5": "9a18a1d1ccb4f0d8cb5af6f44fa9ba46",
          "sha256": "9d8ea5a8eb64c00587065f03c5c81f778f069e9a64c41157ae7865c1a246597e"
        },
        "downloads": -1,
        "filename": "bionic_falcon-1.0.39-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9a18a1d1ccb4f0d8cb5af6f44fa9ba46",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 46115,
        "upload_time": "2022-03-25T21:16:55",
        "upload_time_iso_8601": "2022-03-25T21:16:55.674646Z",
        "url": "https://files.pythonhosted.org/packages/2e/9d/f8df7406479876aceb25263adbd534d65de3d52d35cea6ff20cfc744917b/bionic_falcon-1.0.39-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "734b53e867805faae57dbf3d5d8287f6ad34429b24cc95508b0b0e2288383ecc",
          "md5": "8bc06e2ae02e7be89e7b32ab270dc1a9",
          "sha256": "c63d05edc2296d6422d160e46dfc1a0b437bb4ec6808ac13f2a5483541931cac"
        },
        "downloads": -1,
        "filename": "bionic-falcon-1.0.39.tar.gz",
        "has_sig": false,
        "md5_digest": "8bc06e2ae02e7be89e7b32ab270dc1a9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 45647,
        "upload_time": "2022-03-25T21:16:57",
        "upload_time_iso_8601": "2022-03-25T21:16:57.115098Z",
        "url": "https://files.pythonhosted.org/packages/73/4b/53e867805faae57dbf3d5d8287f6ad34429b24cc95508b0b0e2288383ecc/bionic-falcon-1.0.39.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.40": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2fd805189e96790df38e3b583c334e28cada9d4f2d6f16025344397a898f655c",
          "md5": "606b5385823816c881b15dac6327f13b",
          "sha256": "b19bccbeb236bf377685dcfc2a9029ac0c603c6c23ef5db12be4af3bc2a97cdb"
        },
        "downloads": -1,
        "filename": "bionic_falcon-1.0.40-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "606b5385823816c881b15dac6327f13b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 46219,
        "upload_time": "2022-03-25T21:29:45",
        "upload_time_iso_8601": "2022-03-25T21:29:45.798844Z",
        "url": "https://files.pythonhosted.org/packages/2f/d8/05189e96790df38e3b583c334e28cada9d4f2d6f16025344397a898f655c/bionic_falcon-1.0.40-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "516aa62abc2e5c6e97e22fd41e71f08be9e9083e081870fe3288772fa9fe3c0c",
          "md5": "a93d76a00d86b19bae25dc247a43d077",
          "sha256": "efef63751fc4bd292d8cdd3f1f1b83fd94e99e102ac33fd3d409ded9cf953460"
        },
        "downloads": -1,
        "filename": "bionic-falcon-1.0.40.tar.gz",
        "has_sig": false,
        "md5_digest": "a93d76a00d86b19bae25dc247a43d077",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 45724,
        "upload_time": "2022-03-25T21:29:48",
        "upload_time_iso_8601": "2022-03-25T21:29:48.814326Z",
        "url": "https://files.pythonhosted.org/packages/51/6a/a62abc2e5c6e97e22fd41e71f08be9e9083e081870fe3288772fa9fe3c0c/bionic-falcon-1.0.40.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4c05d073bbfa1b2c5952c4094a444f01bc929632278f094ff9d98a30527b2f46",
          "md5": "0b284ee37f58866b8c3080ec05203c1e",
          "sha256": "adb03707e5fd7919e87b59919161db7072112b52180412be325f17fd89af41e3"
        },
        "downloads": -1,
        "filename": "bionic_falcon-1.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0b284ee37f58866b8c3080ec05203c1e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 47232,
        "upload_time": "2022-04-29T20:22:40",
        "upload_time_iso_8601": "2022-04-29T20:22:40.882722Z",
        "url": "https://files.pythonhosted.org/packages/4c/05/d073bbfa1b2c5952c4094a444f01bc929632278f094ff9d98a30527b2f46/bionic_falcon-1.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "51c200d9ed52822efe0919ac9b01f89254935706775dbe83a43a9b466b0068d9",
          "md5": "06370a28646dfee63c53ff04e0987cc8",
          "sha256": "424686cee4483e5eca6818ecb003ab6bade0b352e7f8eea153f24af19f845f28"
        },
        "downloads": -1,
        "filename": "bionic-falcon-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "06370a28646dfee63c53ff04e0987cc8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47347,
        "upload_time": "2022-04-29T20:22:42",
        "upload_time_iso_8601": "2022-04-29T20:22:42.775942Z",
        "url": "https://files.pythonhosted.org/packages/51/c2/00d9ed52822efe0919ac9b01f89254935706775dbe83a43a9b466b0068d9/bionic-falcon-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4c05d073bbfa1b2c5952c4094a444f01bc929632278f094ff9d98a30527b2f46",
        "md5": "0b284ee37f58866b8c3080ec05203c1e",
        "sha256": "adb03707e5fd7919e87b59919161db7072112b52180412be325f17fd89af41e3"
      },
      "downloads": -1,
      "filename": "bionic_falcon-1.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0b284ee37f58866b8c3080ec05203c1e",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 47232,
      "upload_time": "2022-04-29T20:22:40",
      "upload_time_iso_8601": "2022-04-29T20:22:40.882722Z",
      "url": "https://files.pythonhosted.org/packages/4c/05/d073bbfa1b2c5952c4094a444f01bc929632278f094ff9d98a30527b2f46/bionic_falcon-1.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "51c200d9ed52822efe0919ac9b01f89254935706775dbe83a43a9b466b0068d9",
        "md5": "06370a28646dfee63c53ff04e0987cc8",
        "sha256": "424686cee4483e5eca6818ecb003ab6bade0b352e7f8eea153f24af19f845f28"
      },
      "downloads": -1,
      "filename": "bionic-falcon-1.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "06370a28646dfee63c53ff04e0987cc8",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 47347,
      "upload_time": "2022-04-29T20:22:42",
      "upload_time_iso_8601": "2022-04-29T20:22:42.775942Z",
      "url": "https://files.pythonhosted.org/packages/51/c2/00d9ed52822efe0919ac9b01f89254935706775dbe83a43a9b466b0068d9/bionic-falcon-1.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}