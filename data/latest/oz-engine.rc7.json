{
  "info": {
    "author": "SplatCraft",
    "author_email": "splatcraft.5972@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "\n\n===========================================================================\n                               \n![](logo.png)\n\n===========================================================================\n\n\nOz-Engine is a text based engine made by @menitoon using python.\nIt can be used to make games in terminal and with additional modules in discord or any matrix led based screen\n\n\n#### STARTUP\n\n ``` pip install Oz-Engine ```\n \n ```python \n import OzEngine as oz \n ```\n\n\n## How to use it\n\n```diff \n+ ⚠️ NOTE :  before reading this remind yourself that is still work in progress and unfinished this section  might be changed in the future.Some explanations might be unclear or wrong if so then please report them.\n```\n\n### Creating the canvas\n\nStart by instancing a canvas like so: \n```python \ncanvas = oz.Canvas(\"#\") \n# The  argument is given what the canvas will be filled with.\n```\nand then instancing a camera so that we can render the scene.\n```python\ncamera = oz.Camera(canvas , [10 , 10] , [0 , 0] , \"camera\")\n#First argument is the canvas that it belongs to.\n#Second argument is the size of the camera.\n#Thid argument is the position of the camera.\n#And the last one is the name.\n```\n\n\nNow try rendering it:\n```python\nprint(camera.render())\n```\nYou should see a square filled with \"#\"\n\n## Adding Sprites\n\nIt's cool and all but a little boring to have just an empty canvas.\nLet's add a sprite:\n```python\nsprite = oz.Sprite(canvas , \"S\" , [3 , 3] , \"first_sprite\" ) \n# \"canvas\" is the canvas that is associated with the sprite in question\n# \"S\" is character that the sprite will be represented with.\n# and \"first_sprite\" is the name of the sprite\n```\nfeel free to add multiples sprites :) !\n\n## moving functions\n\nIf you wanted to move them then simply do that:\n```python\n\n# add 1 to x-axis:\nsprite.change_x(1) \n\n# add -1 y-axis:\nsprite.change_y(-1)\n\n#set x-axis\nsprite.set_x(1)\n\n#set y-axis\nsprite.set_y(3)\n\n#set position (x and y)\nsprite.set_position([3 , 5])\n\n#add to x and y axis\nsprite.change_postion(1 , -1)\n#first argument is for \"x\" and the second for \"y\"\n\n```\n\n## Useful sprite methods\n\nThere are a few important function for sprites that needs to be known.\nFor example if you want to delete an object\n```python\nalbert_the_sprite.destroy()\n```\n\nor to rename it\n```python\nalbert_the_sprite.rename(\"albert\")\n```\n\nbut also to handle collisions\n```python\nalbert_the_sprite.get_colliding_objects()\n```\n\"get_colliding_objects\" is a method that returns all sprites names that colliding with the sprite that execute\nthe method (albert_the_sprite here)\n\nwe can check collision like so:\n```python\n\ncanvas = oz.Canvas(\"#\")\n\nalbert_the_sprite = oz.Sprite(canvas , \"a\" , [0 , 0] , \"albert\")\nrobert_the_sprite = oz.Sprite(canvas , \"r\" , [0 , 0] , \"robert\")\nbilly_the_sprite = oz.Sprite(canvas, \"b\" , [2 , 0] , \"billy\")\n\nif \"robert\" in albert_the_sprite.get_colliding_objects():\n  \n  print(\"collides with:\" , albert_the_sprite.get_colliding_objects())\n  print(\"robert collided with albert.\")\n\nelse:\n\n  print(\"robert didn't collide with albert.\")\n```\n\nNow if we wanted to execute a method to robert with could use the \"get_sprite()\"\n``` python\ncanvas.get_sprite(\"robert\").set_position([2 , 0])\n```\nPlease note that you will need to execute this method throught the canvas that is associated with the sprite.\n\n## Groups\n\n\"group\" is an optional argument of the object \"Sprite\" that can be used to call a method to each sprite that belong to this group or check collisions between groups.\n\n### Collision with groups\n\nFirst things first you need to actually define the group that the sprite belongs to:\n```python\nsnake_the_sprite = oz.Sprite(canvas , \"s\" , [0 , 0] , \"albert\" , \"animal\")\ncat_the_sprite = oz.Sprite(canvas , \"c\" , [0 , 0] , \"robert\" , \"animal\")\n\napple_the_sprite = oz.Sprite(canvas , \"a\" , [0 , 0] , \"robert\" , \"fruit\")\n```\n\nnow we can simply check collision:\n```python\nprint(apple_the_sprite.get_colliding_groups())\n#output : [\"fruit\" , \"animal\"]\n\n\nif \"animal\" in apple_the_sprite.get_colliding_groups():\n    print(\"The fruit was eaten by an animal \")\n\nelse:\n    print(\"The fruit is still here :D !\")\n```\n\nthe method \"get_colliding_groups()\" returns a list that contains every groups that collides with the sprite\nthat executes the method.\n\n## calling groups\n\nLet's imagine that we are making a game where if a button is pressed all the doors should open\nwell it would simple just to use the method \"call_group()\".\n\nbut first we need to create our own sprite type : \"Door\"\nwe will do so by creating a New class called you guessed it : \"Door\"\n\n```python\n\n#inherits from class \"Sprite\"\nclass Door(Sprite):\n  #reusing code from Sprite here:\n  #if you want to know what this is for then go to the \"How it works\" section.\n  \n  __slots__ = \"canvas_owner\", \"char\", \"position\", \"name\", \"group\", \"distance\", \n  \"on_function_ready\"\n\n  def __init__(self,\n               canvas_owner: object,\n               char: str,\n               position: list,\n               name: str,\n               group=None,  \n               ):\n\n    \n    self.char = char\n    self.position = position\n    self.name = name\n    self.canvas_owner = canvas_owner\n    self.group = group\n\n    if name in canvas_owner.sprite_names:\n      # change name if already taken\n      self.name = name + f\"@{str(id(self))}\"\n\n    # register infos in \"canvas_owner\" :\n    canvas_owner.sprite_tree.append(self)\n    canvas_owner.sprite_names.append(self.name)\n    canvas_owner.sprite_names_dict[self.name] = self\n    canvas_owner.sprite_position_dict[self] = position\n\n    if not (group in canvas_owner.sprite_group_dict):\n      #if group is new then add to \"group_tree\" and create new key \n      #location for \"sprite_group_dict\".\n      canvas_owner.sprite_group_dict[group] = []\n      canvas_owner.group_tree.append(group)\n\n                 \n    canvas_owner.sprite_group_dict[group].append(self)\n\n\n  #our function to open the door\n  def open_door(self):\n    print(f'door : \"{self.name}\" was opened !' )\n\n```\nand then we can instance the door and call the method\n```python\ncanvas = oz.Canvas(\"#\")\n\ndoor_one = Door(canvas , \"1\" , [-4 , 2] , \"door_one\" , \"door\")\ndoor_two = Door(canvas , \"2\" , [2 , -3] , \"door_two\" , \"door\")\ndoor_three = Door(canvas , \"3\" , [3 , 7] , \"door_three\" , \"door\")\n\ncanvas.call_group(\"door\" , \"open_door\" )\n\n#output : \n#door : \"door_one\" was opened !\n#door : \"door_two\" was opened !\n#door : door_three was opened !\n\n```\n\nbut now let's say we want to give and argument well it's super easy :) \n```python\n#add method to the door class\ndef multiply_x_axis(self , times):\n    self.set_x(self.position[0] * times) #position[0] is the x-axis\n```\n\nthen just call the method:\n```python\ncanvas = oz.Canvas(\"#\")\n\ndoor_one = Door(canvas , \"1\" , [-4 , 2] , \"door_one\" , \"door\")\ndoor_two = Door(canvas , \"2\" , [2 , -3] , \"door_two\" , \"door\")\ndoor_three = Door(canvas , \"3\" , [3 , 7] , \"door_three\" , \"door\")\n\nprint(canvas.sprite_position_dict.values()) #prints all positions\n#output before call : dict_values([[-4, 2], [2, -3], [3, 7]])\n\ncanvas.call_group(\"door\" , \"multiply_x_axis\", 2 )\nprint(canvas.sprite_position_dict.values()) #prints all positions multiplied by 2\n#output after call : dict_values([[-4, 2], [2, -3], [3, 7]])\n```\n\ngiving multiple arguments is possible.\n\n\n# How it works\n\n\n\n\nTo start simple imagine we have a board that is filled with \"0\"\n\n![](grid_zero.png)\n\nthis board can be represented with a 2D-list:\n```python\n[  \n   [0, 0 , 0 , 0, 0],\n   [0, 0 , 0 , 0, 0],\n   [0, 0 , 0 , 0, 0],\n   [0, 0 , 0 , 0, 0],\n                       ]\n```\n\nand that what the method \"clear_canvas\" from the \"Camera\" class makes for you:\n\n``` python\ndef clear_canvas(self):\n    \"\"\"\n    returns a clean canvas, setted\n    in to it's empty state\n    \"\"\"\n\n    SIZE_X = self.size[0]\n    SIZE_Y = self.size[1]\n\n    line = [self.canvas_owner.VOID for _ in range(SIZE_X)] #creates a list containing the \n                                                           #argument \"VOID\" \n                                                           #it would give : '[ 0 , 0 , 0 , 0 , 0]'  if SIZE_X = 5 and VOID = 0)\n\n    clear_canvas = [line.copy() for _ in range(SIZE_Y)]    #appends multiple  copies(so we can edit it) of line \n    return clear_canvas                                    #the amount of copies appended depends on the value \"SIZE_Y\"\n    #and we return \"clear_canvas\".\n```\n\nand we should get what we had at first using this function.\n\n## Editing the canvas\n\nLet's bring some life to this empty canvas by using the method \"edit_element\"\n\n```python\n\n  def edit_element(self, canvas, x, y, char):\n    \"\"\"\n    allows to edit an element of a canvas\n    \"\"\"\n    # \"canvas\" is the canvas we want to edit (you'l see later that we always the same one)\n    # \"y\" is the line we want to edit\n    # \"x\" is the element in the line want to edit.\n    # and \"char\" is the character that we replace by the old one.\n\n    (canvas[y])[x] = char \n\n```\n\n# Classes \n\nThere are 3 Classes In Oz-Engine :\n\n⬤ **Canvas**\n\n⬤ **Sprite**\n\n⬤ **Camera**\n\n## Canvas\n\nCanvas object can be used to store sprite informations\nIt has one parameter \"VOID\" which what empty cells look like.\n\nHere is an example :\n```python\n\ncanvas_fruit = oz.Canvas(\"o\") # \"VOID\" here is \"o\"\n\napple = oz.Sprite(canvas_fruit , \"🍎\" , [0 , 0] , \"apple\")\nbanana = oz.Sprite(canvas_fruit , \"🍌\" , [1 , 0] , \"banana\")\n\n\n\ncanvas_vehicles = oz.Canvas(\"#\")\n\ncar = oz.Sprite(canvas_fruit , \"🚗\" , [0 , 0] , \"car\")\nplane = oz.Sprite(canvas_fruit , \"✈\" , [1 , 0] , \"plane\")\n```\n\nHere \"canvas_fruit\" does only contain information about \"apple\" and \"banana\"\nAnd \"canvas_vehicles\" contain information about \"copybook\" and \"notebook\"\n\n\n# Methods\n\n## \\_\\_init\\_\\_\n\nNothing particular here just setting up\nthe given parameters and instantiating variable that are needed.\n\n```python\n def __init__(self, VOID):\n    ''' Characters that fills the canvas when nothing is rendered on a tile. '''\n    self.VOID = VOID\n    '''List that contains every distance of each sprite '''\n    self.distance_tree = []\n    '''List that contains every reference of each sprite '''\n    self.sprite_tree = []\n    '''List that contains every groups that exists'''\n    self.group_tree = []\n    '''List that contains every name of each sprite '''\n    self.sprite_names = []\n    '''Dictionary that has a sprite reference as a key and the corresponding name as a value'''\n    self.sprite_names_dict = {}\n    '''Dictionary that has a sprite reference as a key and the corresponding position as a value'''\n    self.sprite_position_dict = {}\n    '''Dictionary that has a sprite reference as a key and the corresponding group as a value'''\n    self.sprite_group_dict = {}\n```\n\n\n## get_sprite\n\nThe method \"get_sprite\" allows to get the reference of sprite by it's name.\nIt works with a dictionnary that stores names as keys a reference as values.\n\n```python\n  def get_sprite(self, name):\n    \"\"\"\n    returns reference to sprite that owns the given name\n    \"\"\"\n\n    return self.sprite_names_dict[name]\n```\n\n## call_group\n\nAllows you to call a \"method\" to a group\n```python\n  def call_group(self, group_to_call: str, method_to_call, *args):\n    \"\"\"\n    Call a method  to every sprites that belongs to the group that is\n    given \n\n    like so:\n\n    canvas.call_group(\"group_name_here\" , method_is_going_to_be_called_on_them() )\n    \n    \"\"\"\n\n    #gets every sprite that is in the group given\n    \n    sprite_to_call = self.sprite_group_dict.get(group_to_call)\n    if sprite_to_call == None:\n      #if group given doesn't exist then sumbit error\n      raise Exception(\n        f'''The group \"{group_to_call}\" doesn't exist please specify a valid group to call. '''\n      )\n\n    for todo_sprite in sprite_to_call:\n\n      #get function of sprite\n      func = getattr(todo_sprite, method_to_call)\n      #executes it with the argument given\n      func(*args)\n```\n\n\"sprite_group_dict\" is dictionnary that holds every sprite reference that is in the given group.\n\n# Sprite\n\nSprite objects are used to fill the canvas\nthey have 5 parameters :\n\n⬤ **canvas_owner**\n\n⬤ **char**\n\n⬤ **position**\n\n⬤ **name**\n\n⬤ **group**\n\n\n\n# Methods\n\n## \\_\\_init\\_\\_\n\nHere we just set up the variable that were asked in the parameters\n\n\n\n```python\n\n def __init__(\n    self,\n    canvas_owner: object,\n    char: str,\n    position: list,\n    name: str,\n    group=None,\n  ):\n    '''Character that represents the sprite when rendered.'''\n    self.char = char\n    '''List that has two element \"x\" and \"y\" it tells where to render the sprite.'''\n    self.position = position\n    '''Name of the sprite that can be used to get reference from it using the \"get_sprite\" method throught a \"Canvas\" object.'''\n    self.name = name\n    '''Canvas that the sprite is associated to.'''\n    self.canvas_owner = canvas_owner\n    '''group is a string that be used to call a method on each sprite that has the same method with \n    the method \"call_group\" through the canvas and it can also be used to check collision by seing which sprite of which\n    group is colliding with our sprite with the method \"get_colliding_groups\" that can be executed by a \"Sprite\" object. '''\n    self.group = group\n\n```\n\nand here we register info to the __canvas_owner__.\n\n\n```python\n    \n    if name in canvas_owner.sprite_names:\n      # change name if already taken\n      self.name = name + f\"@{str(id(self))}\"\n\n    # register infos in \"canvas_owner\" :\n    canvas_owner.sprite_tree.append(self) # register reference\n    canvas_owner.sprite_names.append(self.name) # register name\n    canvas_owner.sprite_names_dict[self.name] = self # register name as key and reference as value \n    canvas_owner.sprite_position_dict[self] = position # register reference as key and position as value\n    \n    if not (group in canvas_owner.sprite_group_dict):\n      #if group is new then add to \"group_tree\" and create new key\n      #location for \"sprite_group_dict\".\n      canvas_owner.sprite_group_dict[group] = []\n      canvas_owner.group_tree.append(group)\n\n    canvas_owner.sprite_group_dict[group].append(self) #add group reference to the group dict\n    #it can looks something like that : { \"group\" : [sprite_reference1 , sprite_reference2 , ect] }\n\n```\n\n## destroy\n\n__destroy__ is used to delete sprite\nit just deletes things that we registered earlier in the __\\_\\_init\\_\\___\n\n```python\n  def destroy(self):\n\n    del self.canvas_owner.sprite_names_dict[self.name]\n    del self.canvas_owner.sprite_position_dict[self]\n\n    #remove self from key that contain every sprite in group\n    INDEX = self.canvas_owner.sprite_group_dict[self.group].index(self)\n    del (self.canvas_owner.sprite_group_dict[self.group])[INDEX]\n\n    self.canvas_owner.sprite_names.remove(self.name)\n    self.canvas_owner.sprite_tree.remove(self)\n\n    if len(self.canvas_owner.sprite_group_dict[self.group]) == 0:\n      #delete group if no one is in it.\n      del self.canvas_owner.sprite_group_dict[self.group]\n      self.canvas_owner.group_tree.remove(self.group)\n\n    del self\n```\n\n## rename\n\n__rename__ as it name suggest allows to rename sprites\nit changes every time the __old__ name was used by the __new__ one given.\n```python\n def rename(self, new_name: str):\n    \"\"\"\n    allows to change the name of a sprite, to \"rename\" it.\n    \"\"\"\n\n    del self.canvas_owner.sprite_names_dict[self.name]\n\n    if new_name in self.canvas_owner.sprite_names:\n      # change new_name with object id() if name already taken\n      new_name = new_name + f\"@{str(id(self))}\"\n\n    # change name\n\n    INDEX = self.canvas_owner.sprite_names.index(self.name)\n    self.canvas_owner.sprite_names[INDEX] = new_name\n    self.name = new_name\n    self.canvas_owner.sprite_names_dict[new_name] = self\n```\n\n## get_colliding_objects\n\n__get_colliding_object__ works by getting the reference of each sprite that is located at the\nsame __position__ of the sprite that calls the method.\n\n```python\n  def get_colliding_objects(self):\n    \"\"\"\n    Returns a list of colliding objects(by name)\n    \"\"\"\n\n    object_colliding = [] \n\n    sprite_check_list = list(\n      self.canvas_owner.sprite_position_dict.copy().keys())\n    position_check_list = list(\n      self.canvas_owner.sprite_position_dict.copy().values())\n\n    sprite_check_list.remove(self)           #remove self reference\n    position_check_list.remove(self.position) #remove self position\n\n    for todo_sprite in sprite_check_list:\n\n      POSITION_CHECK = self.canvas_owner.sprite_position_dict[\n        todo_sprite]  # gets the position from key\n\n      if self.position in position_check_list: #checks until the no sprites has the same position\n\n        object_colliding.append(\n          todo_sprite.name) if POSITION_CHECK == self.position else None\n      else:\n        break\n\n    return object_colliding\n```\n\nIt gives back names of the sprite who are colliding with us.\n\n## get_colliding_groups\n\nIt works the same as __get_colliding_objects__ except here it gives the group instead of giving back names.\nWe check if all groups are in __groups_colliding__.\n\n```python\n def get_colliding_groups(self):\n    \"\"\"\n    Returns a list of colliding objects(by groups)\n    \"\"\"\n\n    groups_colliding = []\n\n    sprite_check_list = list(\n      self.canvas_owner.sprite_position_dict.copy().keys())\n    position_check_list = list(\n      self.canvas_owner.sprite_position_dict.copy().values())\n\n    sprite_check_list.remove(self)\n    position_check_list.remove(self.position)\n\n    for todo_sprite in sprite_check_list:\n\n      POSITION_CHECK = self.canvas_owner.sprite_position_dict[\n        todo_sprite]  # gets the position from key\n\n      if self.position in position_check_list and not (set(\n          self.canvas_owner.group_tree) == set(groups_colliding)):\n\n        groups_colliding.append(\n          todo_sprite.group) if POSITION_CHECK == self.position else None\n      else:\n        break\n\n    return groups_colliding\n\n```\n\n## update_distance\n\n__update_distance__ is used to well update distance of your sprite\nit's used in every __moving__ / __position__ functions\n```python\n  def update_distance(self):\n    \"\"\"\n\n        update the dictionary : \"sprite_position_dict\" of \"canvas_owner\"\n        like so :\n\n        sprite_reference :  sprite_position\n\n        \"\"\"\n\n    # update it\n    self.canvas_owner.sprite_position_dict[self] = self.position\n```\n\n## position-based methods\n\nI'm not cover how every position-based method works because they are very similar to each other\nbut here how one of then works:\n\n```python\n  def change_position(self, x_val: int = 0, y_val: int = 0):\n\n    self.position[0] += x_val\n    self.position[1] += y_val\n    self.update_distance()\n```\n\n# Camera\n\n__Camera__ object is used to render __Canvas__ object\nit has 4 parameters:\n\n⬤ **canvas_owner**\n\n⬤ **size**\n\n⬤ **position**\n\n⬤ **name**\n\n\n## \\_\\_init\\_\\_\n\nNothing particular here just setting up variables\n\n```python\ndef __init__(self, canvas_owner: object, size: list, position: list,\n               name: str):\n    '''canvas that is associated with. '''\n    self.canvas_owner = canvas_owner\n    '''size of the camera '''\n    self.size = size\n    ''' position of the camera '''\n    self.position = position\n    ''' name of the camera'''\n    self.name = name\n    ''' define the order of rending sprties '''\n    self.sprite_render_priority = []\n    ''' dictionnary that contain keys \"sprite\" for value \"distance\" '''\n    self.sprite_distance_dict = {}\n\n    if size == [0, 0]:\n\n      warn(\n        f''' size of camera : \"{name}\" isn't defined so it will most likely not work.\\n please define a valid size.'''\n      )\n```\n## update_sprite_distance\n\nThis method is used to update all distances of each sprites\n```python\n\n  def update_sprite_distance_dict(self):\n    \"\"\"\n        update the distance of every sprite\n        \"\"\"\n\n    self.sprite_distance_dict = {} #creates empty dict\n\n    for todo_sprite in self.canvas_owner.sprite_tree: #we interate through every sprite reference\n      sprite_position = [                             #and update the distance for each of them\n        todo_sprite.position[0] - self.position[0],\n        todo_sprite.position[1] - self.position[1]\n      ]\n      self.sprite_distance_dict[todo_sprite] = self.get_square_distance_to(\n        sprite_position)\n```\n\n\n## edit_element\n\nIs used to replace a char by a new one.\n\n```python\n  def edit_element(self, canvas, x, y, char):\n    \"\"\"\n    allows to edit an element of a canvas\n    \"\"\"\n\n    #canvas[y] gets the line\n    # and then with [x] gets the element\n    \n    (canvas[y])[x] = char\n```\n\n## get_square_distance_to\n\nGives back the sum of the distance of the four corner of the render canvas\n```python\n  def get_square_distance_to(self, position: list):\n    \"\"\"\n    returns the sum of the distance between the 4 corners of the square\n    \"\"\"\n\n    SIZE_X = self.size[0] - 1  \n    SIZE_Y = self.size[1] - 1\n\n    corner_top_left = [0, 0]\n    corner_top_right = [SIZE_X, 0]\n    corner_bottom_right = [SIZE_X, SIZE_Y]\n    corner_bottom_left = [0, SIZE_Y]\n\n    return (math.dist(corner_top_left, position) +\n            math.dist(corner_top_right, position) +\n            math.dist(corner_bottom_right, position) +\n            math.dist(corner_bottom_left, position))\n```\n\n## is_renderable\n\nSays whetever a sprite can rendered or not.\n```python\n  def is_renderable(self, distance):\n    \"\"\"\n        returns whether a sprite a renderable from the distance given.\n        \"\"\"\n\n    MAX_DISTANCE = (self.get_square_distance_to([0, 0])) #represents the maximum distance to be rendered\n\n    return not (distance + self.get_square_distance_to(self.position)) > (\n      MAX_DISTANCE + self.get_square_distance_to(self.position))\n```\n\n## render \n\n__render__ is the main method of __Camera__ it returns back a string that represents the canvas if the parameter __is_string__ is True else returns a the canvas as a 2D-list\n```python\n  def render(self, is_string=True):\n    \"\"\"\n    Returns the rendered canvas as a string if \"is_string\" is true else as a          2D-list\n    \"\"\"\n\n    self.update_sprite_distance_dict()\n    canvas = self.clear_canvas()\n\n    MAX_DISTANCE = (self.get_square_distance_to([0, 0]))\n\n    distances = list(self.sprite_distance_dict.copy().values())\n    sprite_list = list(self.sprite_distance_dict.copy().keys())\n\n    for todo in range(len(self.canvas_owner.sprite_tree)):\n\n      min_distance = min(distances)\n      # gets the smallest distance in list \"distances\"\n      is_off_screen = (min_distance + self.get_square_distance_to(\n        self.position)) > (MAX_DISTANCE +\n                           self.get_square_distance_to(self.position))\n\n      if is_off_screen:\n        # if the smallest distance of the sprite(+ camera offset)\n        # is bigger than \"MAX_DISTANCE\"\n        break\n\n      #get corresponding sprite reference\n      index = distances.index(min_distance)\n      sprite = sprite_list[index]\n      position_to_render_sprite = [\n        sprite.position[0] - self.position[0],\n        sprite.position[1] - self.position[1]\n      ]\n\n      #edit canvas\n      self.edit_element(canvas, position_to_render_sprite[0],\n                        position_to_render_sprite[1], sprite.char)\n\n      # remove thoses\n      del sprite_list[index]\n      del distances[index]\n\n    if is_string == True:\n\n      canvas = [\"\".join(canvas[line]) for line in range(len(canvas))]\n\n      for element in range(len(canvas) - 1):\n\n        canvas[0] += \"\\n\" + canvas[element + 1]\n      canvas = canvas[0]\n\n    return canvas\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/menitoon/Oz-Engine-Rebooted",
    "keywords": "",
    "license": "GNU General Public License v3 (GPLv3)",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Oz-Engine",
    "package_url": "https://pypi.org/project/Oz-Engine/",
    "platform": null,
    "project_url": "https://pypi.org/project/Oz-Engine/",
    "project_urls": {
      "Homepage": "https://github.com/menitoon/Oz-Engine-Rebooted"
    },
    "release_url": "https://pypi.org/project/Oz-Engine/1.7.2/",
    "requires_dist": null,
    "requires_python": ">=3.2",
    "summary": "A module for text based games",
    "version": "1.7.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16841373,
  "releases": {
    "1.1.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b48828ec5afc2637f309bceb0d7e7799c53fcccf61c72f505d2c3596a7426b7b",
          "md5": "714e96c6538f8ff5056d333e019316f6",
          "sha256": "01ebb2b8eb747cd5c52d9c16fa778964179176c1b63550a5b514c191f82843f7"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.1.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "714e96c6538f8ff5056d333e019316f6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 4109,
        "upload_time": "2023-01-25T19:02:48",
        "upload_time_iso_8601": "2023-01-25T19:02:48.035701Z",
        "url": "https://files.pythonhosted.org/packages/b4/88/28ec5afc2637f309bceb0d7e7799c53fcccf61c72f505d2c3596a7426b7b/Oz_Engine-1.1.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ff81172a266f1dbfce77cd09e2ebe254933d13555b1d9d8ca1f6708b5bc37d42",
          "md5": "7ce6faae9b0d1b76e6050d9b4149ecfe",
          "sha256": "0145c0c27261a553060d01550006c95650c18012153f67910b62017fb26aada1"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "7ce6faae9b0d1b76e6050d9b4149ecfe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.1",
        "size": 3749,
        "upload_time": "2023-01-25T19:02:50",
        "upload_time_iso_8601": "2023-01-25T19:02:50.041908Z",
        "url": "https://files.pythonhosted.org/packages/ff/81/172a266f1dbfce77cd09e2ebe254933d13555b1d9d8ca1f6708b5bc37d42/Oz_Engine-1.1.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "48d6a64edaae46a5211349a968585d56b9c5a44bcc529c451c0521fb3e0f1cfa",
          "md5": "b97230f5d2d139291c1c34dbcca3724f",
          "sha256": "7dc54441f76c881a792c63e221bdcb760ca291bd9cbd4b0f8a8febc83f944d3f"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b97230f5d2d139291c1c34dbcca3724f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 4114,
        "upload_time": "2023-01-26T17:13:31",
        "upload_time_iso_8601": "2023-01-26T17:13:31.452337Z",
        "url": "https://files.pythonhosted.org/packages/48/d6/a64edaae46a5211349a968585d56b9c5a44bcc529c451c0521fb3e0f1cfa/Oz_Engine-1.5.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "18aa70ace48ce5f179f5b605746c6bb1a66258eba14a60613f59588495a826de",
          "md5": "7eb31d0f04de9dc1d0a0cabc88959607",
          "sha256": "5913a1fa6dfe7e5259aec28b20a7db51fb07e4ba203bf85f30e0a8b1460f88a5"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.7.tar.gz",
        "has_sig": false,
        "md5_digest": "7eb31d0f04de9dc1d0a0cabc88959607",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.1",
        "size": 3743,
        "upload_time": "2023-01-26T17:13:33",
        "upload_time_iso_8601": "2023-01-26T17:13:33.384907Z",
        "url": "https://files.pythonhosted.org/packages/18/aa/70ace48ce5f179f5b605746c6bb1a66258eba14a60613f59588495a826de/Oz_Engine-1.5.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0f4963f74022a1c2c9113059d1253d991ebe10c73df24ad01df3c9b8450f0f0f",
          "md5": "1c099362a80006d39a370c484ffa0cc3",
          "sha256": "9a6c0ba7f4dc064481b0769f2b1519a03cada2cd1b4d50e6d52547193b5a96a9"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1c099362a80006d39a370c484ffa0cc3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 5646,
        "upload_time": "2023-01-28T10:17:48",
        "upload_time_iso_8601": "2023-01-28T10:17:48.367295Z",
        "url": "https://files.pythonhosted.org/packages/0f/49/63f74022a1c2c9113059d1253d991ebe10c73df24ad01df3c9b8450f0f0f/Oz_Engine-1.5.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d617e4ec3cde9d0cc242eaacd4fafbe32a2d9944f3cbebc821b2fb6b103b371b",
          "md5": "0cfbaa298a36cc81b42c195d59b5360a",
          "sha256": "c0b214e34fdee5e8ca0fcb415b7d30a5e5ea1fb365113a4d5d2cd66c8affc4ff"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.8.tar.gz",
        "has_sig": false,
        "md5_digest": "0cfbaa298a36cc81b42c195d59b5360a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.1",
        "size": 5154,
        "upload_time": "2023-01-28T10:17:50",
        "upload_time_iso_8601": "2023-01-28T10:17:50.766300Z",
        "url": "https://files.pythonhosted.org/packages/d6/17/e4ec3cde9d0cc242eaacd4fafbe32a2d9944f3cbebc821b2fb6b103b371b/Oz_Engine-1.5.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.8.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dde3e38bf528b8fe6988867c29df1ef7391911f82de6250ce1d5d1ee02344378",
          "md5": "68d84a93b7453b7a7f0b771cfb8647f3",
          "sha256": "7edee025aa57da26d8ec03aa8e56ce7b20e325cb940dd47a0f3616e5760bf2b2"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.8.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "68d84a93b7453b7a7f0b771cfb8647f3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 5703,
        "upload_time": "2023-01-28T10:26:24",
        "upload_time_iso_8601": "2023-01-28T10:26:24.585852Z",
        "url": "https://files.pythonhosted.org/packages/dd/e3/e38bf528b8fe6988867c29df1ef7391911f82de6250ce1d5d1ee02344378/Oz_Engine-1.5.8.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c2c06ef604ca45ea17ec70ce4a2dbef6fe4a8c4b19d0c6afe58ba46fead7c6f2",
          "md5": "55dd631e531a6993858a2b2a21962538",
          "sha256": "69fe83222da3b74736495a06c64c6444f4f43de99ddc849b81ed4ed596a6c774"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.5.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "55dd631e531a6993858a2b2a21962538",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.1",
        "size": 5167,
        "upload_time": "2023-01-28T10:26:28",
        "upload_time_iso_8601": "2023-01-28T10:26:28.099933Z",
        "url": "https://files.pythonhosted.org/packages/c2/c0/6ef604ca45ea17ec70ce4a2dbef6fe4a8c4b19d0c6afe58ba46fead7c6f2/Oz_Engine-1.5.8.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aece09f7c4978afb63f19cead2349e603fad7beb2a918f1fa65850e3f17857d0",
          "md5": "b96cd5912b74cf3cad5f12c5326dcacc",
          "sha256": "c1a82bf0f5f220993b346b92df8c6d7bded70f88947b3db321a38acfd545f06d"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.6.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b96cd5912b74cf3cad5f12c5326dcacc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 6041,
        "upload_time": "2023-02-02T11:43:40",
        "upload_time_iso_8601": "2023-02-02T11:43:40.488693Z",
        "url": "https://files.pythonhosted.org/packages/ae/ce/09f7c4978afb63f19cead2349e603fad7beb2a918f1fa65850e3f17857d0/Oz_Engine-1.6.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e24889ab9a98a40ea1e8ab71fbc826fac04657b0c94cfacbecb4470b30cdbbf7",
          "md5": "b10662e894152753b20acfcbf3dfbaa9",
          "sha256": "3d1eedd6f6f7c91bc41755a6c47e9b8b7a68661800d6a77e452df843610f7164"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b10662e894152753b20acfcbf3dfbaa9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.1",
        "size": 5526,
        "upload_time": "2023-02-02T11:43:46",
        "upload_time_iso_8601": "2023-02-02T11:43:46.299282Z",
        "url": "https://files.pythonhosted.org/packages/e2/48/89ab9a98a40ea1e8ab71fbc826fac04657b0c94cfacbecb4470b30cdbbf7/Oz_Engine-1.6.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c0283b4b28ad0c0f36d1115431afcc2bacfa8e0c7b8353ffc58ea50f57b871bf",
          "md5": "b3f3a02e440e5f9a071b833df1fe9d0c",
          "sha256": "ea7038f9bfec95db7cff09873a727d2b832ff4e2e3819f73544758904342cc03"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.7.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b3f3a02e440e5f9a071b833df1fe9d0c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.1",
        "size": 11809,
        "upload_time": "2023-02-11T14:07:51",
        "upload_time_iso_8601": "2023-02-11T14:07:51.713526Z",
        "url": "https://files.pythonhosted.org/packages/c0/28/3b4b28ad0c0f36d1115431afcc2bacfa8e0c7b8353ffc58ea50f57b871bf/Oz_Engine-1.7.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.7.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ade003b333231d96a9e4f41a38425e1f87e39d1558d5f5b45c67ee7b9ea587e1",
          "md5": "8e7eb2e52092d825ae1e706ee45115e4",
          "sha256": "16a07f8401592ebad0feadf04a5d0a6a62d0c47f0fde6c07ae2a6cea1bdd64ed"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.7.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8e7eb2e52092d825ae1e706ee45115e4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.2",
        "size": 11859,
        "upload_time": "2023-02-12T14:47:45",
        "upload_time_iso_8601": "2023-02-12T14:47:45.845588Z",
        "url": "https://files.pythonhosted.org/packages/ad/e0/03b333231d96a9e4f41a38425e1f87e39d1558d5f5b45c67ee7b9ea587e1/Oz_Engine-1.7.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a2c73d51d39f92ed95e09865446d972f391050ab8e34c1f57a9b9bee9733d8c2",
          "md5": "42b461c5deefe05f379a9e45c45f1bb2",
          "sha256": "574e1417fada77b1137c5ba714e2e78333c3bf50124be1d35db40dd213c55e68"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.7.1.tar.gz",
        "has_sig": false,
        "md5_digest": "42b461c5deefe05f379a9e45c45f1bb2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.2",
        "size": 15015,
        "upload_time": "2023-02-12T14:47:47",
        "upload_time_iso_8601": "2023-02-12T14:47:47.574052Z",
        "url": "https://files.pythonhosted.org/packages/a2/c7/3d51d39f92ed95e09865446d972f391050ab8e34c1f57a9b9bee9733d8c2/Oz_Engine-1.7.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.7.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0ea48017b3e7b210d301dbb6774b61b300e86441b37a8de690678dd352ba169f",
          "md5": "af2374126c4ad08dafa7fa0684d6e8c1",
          "sha256": "0fe05b5beddc37d383b9110760ca946accb6237634eb81ccef46f1f4f0dc7857"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.7.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "af2374126c4ad08dafa7fa0684d6e8c1",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.2",
        "size": 15625,
        "upload_time": "2023-02-13T16:41:49",
        "upload_time_iso_8601": "2023-02-13T16:41:49.819027Z",
        "url": "https://files.pythonhosted.org/packages/0e/a4/8017b3e7b210d301dbb6774b61b300e86441b37a8de690678dd352ba169f/Oz_Engine-1.7.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ba2ec7e6440b050b4a03faa0b990372285be843cfb6b1141253d290397a341e0",
          "md5": "1b51aa2d0be2daa3232d2a74ea44e426",
          "sha256": "ca86ce68d43c71caf6b3ce6cf3c2aa05def6f019e7d57d23fb8246bf9ffd60ec"
        },
        "downloads": -1,
        "filename": "Oz_Engine-1.7.2.tar.gz",
        "has_sig": false,
        "md5_digest": "1b51aa2d0be2daa3232d2a74ea44e426",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.2",
        "size": 15261,
        "upload_time": "2023-02-13T16:41:53",
        "upload_time_iso_8601": "2023-02-13T16:41:53.722658Z",
        "url": "https://files.pythonhosted.org/packages/ba/2e/c7e6440b050b4a03faa0b990372285be843cfb6b1141253d290397a341e0/Oz_Engine-1.7.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0ea48017b3e7b210d301dbb6774b61b300e86441b37a8de690678dd352ba169f",
        "md5": "af2374126c4ad08dafa7fa0684d6e8c1",
        "sha256": "0fe05b5beddc37d383b9110760ca946accb6237634eb81ccef46f1f4f0dc7857"
      },
      "downloads": -1,
      "filename": "Oz_Engine-1.7.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "af2374126c4ad08dafa7fa0684d6e8c1",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.2",
      "size": 15625,
      "upload_time": "2023-02-13T16:41:49",
      "upload_time_iso_8601": "2023-02-13T16:41:49.819027Z",
      "url": "https://files.pythonhosted.org/packages/0e/a4/8017b3e7b210d301dbb6774b61b300e86441b37a8de690678dd352ba169f/Oz_Engine-1.7.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ba2ec7e6440b050b4a03faa0b990372285be843cfb6b1141253d290397a341e0",
        "md5": "1b51aa2d0be2daa3232d2a74ea44e426",
        "sha256": "ca86ce68d43c71caf6b3ce6cf3c2aa05def6f019e7d57d23fb8246bf9ffd60ec"
      },
      "downloads": -1,
      "filename": "Oz_Engine-1.7.2.tar.gz",
      "has_sig": false,
      "md5_digest": "1b51aa2d0be2daa3232d2a74ea44e426",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.2",
      "size": 15261,
      "upload_time": "2023-02-13T16:41:53",
      "upload_time_iso_8601": "2023-02-13T16:41:53.722658Z",
      "url": "https://files.pythonhosted.org/packages/ba/2e/c7e6440b050b4a03faa0b990372285be843cfb6b1141253d290397a341e0/Oz_Engine-1.7.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}