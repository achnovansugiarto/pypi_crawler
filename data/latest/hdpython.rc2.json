{
  "info": {
    "author": "Richard Peschke",
    "author_email": "rp40@hawaii.edu",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# HD Python\n\n## Introduction\n\n```bash\ngit clone https://github.com/HDPython/HDPython.git\ncd HDPython\npip3 install dist/HDPython-0.0.2.tar.gz\n```\n\n\nHDPython is a library that allows one to write Python code and convert it to VHDL. The Main Goal of this library is to allow the user to write fully object-oriented code.\n\n## Getting Started\n\n\n### Example1\n\nThis Example shows a single entity with two process blocks.\n\n- The First process block (```p1```) is a timed block, which means it gets sequentially executed until it reaches the yield statement and then waits for the appropriate time and then continues the execution. In the context of this example, ```p1``` works as a clock generator.\n- The Second process block (```p2```) is a triggered process block that is executed every time the argument of ```rising_edge``` changes. This Process Block updates a signal (```counter```) and a variable (```v_counter```). Similarly, to VHDL, the variable is changed immediately but is not available for any other process. The signal, in contrast, gets only changed after the process block but can be used in other process blocks.\n\n```Python\nclass tb_entity(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.architecture()\n\n\n    def architecture(self):\n        clk = v_sl()\n\n\n\n        @timed()\n        def p1():\n            clk << 1\n            print(\"set clk to 1\")\n            yield wait_for(10)\n            clk << 1\n            yield wait_for(10)\n            clk << 0\n            yield wait_for(10)\n\n        counter = v_slv(32)\n        v_counter = v_variable(v_slv(32))\n\n        @rising_edge(clk)\n        def p2():\n            v_counter << v_counter +1\n            counter << counter + 1\n            print(\"counter\", counter.value)\n            print(\"v_counter\", v_counter.value)\n```\n\nThe entity can be simulated running the following commands:\n\n```Python\nax = tb_entity()\ngsimulation.run_timed(ax, 1000,\"example1.vcd\")\n```\n\nFirst, one needs to create an instance of the entity and then it has to be given as an argument to the simulator alongside the runtime and the output file name. The output file can then be viewed with programs like ```GTKWave```.\n\n![GTKWave](pictures/example1.png)\n\nIn addition, the program can be converted to ```VHDL``` using the following command:\n\n```Python\nprint(ax._get_definition())\n```\n\nThe output is the following:\n\n```VHDL\n\nentity tb_entity is \nend entity;\n\n\n\narchitecture rtl of tb_entity is\n\nsignal clk : std_logic := '0'; \nsignal counter : std_logic_vector(31 downto 0) := (others => '0'); \n\nbegin\n\n  -----------------------------------\n  p1 : process\n    begin\n      clk <= '1';\n      wait for  10 ns;\n      clk <= '1';\n      wait for  10 ns;\n      clk <= '0';\n      wait for  10 ns;\n    end process;\n\n  -----------------------------------\n  p2 : process(clk) is\n    variable v_counter : std_logic_vector(31 downto 0) := (others => '0');\n    begin\n      if rising_edge(clk) then\n        v_counter := v_counter + 1;\n        counter <= counter + 1;\n      end if;\n    end process;\n\nend architecture;\n```\n\nAs one can see, the Converted can figure out by itself if a given symbol is a signal or a variable. In addition, the print statements are currently not supported. Usually, if the converter encounters an unknown token it would raise an Exception. For ```Print``` there has been written a special module which tells the converter to silently ignore it. \n\n\n### Example2\n\nThis Example shows how multiple entities can interact with each other.\n1. Clock Generation has been moved to its own entity.\n1. A new entity was introduced that allows us to print out data from an axi stream interface. This entity shows the value of the buffer before and after it has been changed. \n1. the communication between the individual entities is done with classes. With this approach, the user does not need to know which signals flow between the different entities. The user can just utilize a library and focus on the actual logic that needs to be implemented. \n\n```Python\nclass axiPrint(v_clk_entity):\n    def __init__(self,clk=None):\n        super().__init__(__file__, clk)\n        self.Axi_in = port_Slave(axisStream(32,v_slv(32)))\n        self.architecture()\n\n\n    def architecture(self):\n        axiSlave = axisStream_slave(self.Axi_in)\n        i_buff = v_variable(v_slv(32))\n        @rising_edge(self.clk)\n        def _process1():\n            print(\"axiPrint\",i_buff.value )\n            if axiSlave :\n                i_buff << axiSlave\n                print(\"axiPrint valid\",i_buff.value )\n\n\n\nclass clk_generator(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.clk = port_out(v_sl())\n        self.architecture()\n\n    def architecture(self):\n\n\n        @timed()\n        def p1():\n            self.clk << 1\n            print(\"======================\")\n            yield wait_for(10)\n            self.clk << 0\n            yield wait_for(10)\n\n\nclass tb_entity(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.architecture()\n\n\n\n    def architecture(self):\n        clkgen = v_create(clk_generator())\n\n        Axi_out = axisStream(32,v_slv(32))\n        counter = v_slv(32)\n        axFil = v_create(axiPrint(clkgen.clk))\n        axFil.Axi_in << Axi_out\n        v_Axi_out = axisStream_master(Axi_out)\n\n\n\n        @rising_edge(clkgen.clk)\n        def p2():\n            if v_Axi_out and counter < 40:\n                print(\"counter\", counter.value)\n                v_Axi_out << counter\n\n                counter << counter + 1\n```\n\nThis example can be simulated with the following command:\n\n```Py\nax = tb_entity()\ngsimulation.run_timed(ax, 1000,\"example2.vcd\")\n```\n\n![example2](pictures/example2.png)\n\nEach entity can be converted to VHDL by using the following command:\n\n\n```Py\nax = tb_entity()\nprint(ax._get_definition())\n```\n\nThe output from this is the following VHDL code:\n\n```VHDL\nentity tb_entity is \nend entity;\n\n\n\narchitecture rtl of tb_entity is\n\nsignal clkgen_clk : std_logic := '0'; \nsignal Axi_out_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal Axi_out_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal counter : std_logic_vector(31 downto 0) := (others => '0'); \nsignal axFil_Axi_in_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal axFil_Axi_in_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\n\nbegin\nclkgen : entity work.clk_generator port map ( \n      clk => clkgen_clk\n  );\n  axFil : entity work.axiPrint port map ( \n      Axi_in_m2s => axFil_Axi_in_m2s, \n      Axi_in_s2m => axFil_Axi_in_s2m,\n      clk => clkgen_clk\n  );\n  ---------------------------------------------------------------------\n  --  axFil_Axi_in << Axi_out\n  axFil_Axi_in_m2s <= Axi_out_m2s;\n  Axi_out_s2m <= axFil_Axi_in_s2m;\n\n  -----------------------------------\n  p2 : process(clkgen_clk) is\n    variable v_Axi_out : axisStream_32_master := axisStream_32_master_null;\n    begin\n      if rising_edge(clkgen_clk) then \n        pull( v_Axi_out, Axi_out_s2m);\n\n        if (( ready_to_send(v_Axi_out)  and counter < 40) ) then \n          send_data( v_Axi_out, counter);\n          counter <= counter + 1;\n\n        end if;\n          push( v_Axi_out, Axi_out_m2s);\n    end if;\n\n    end process;\n\nend architecture;\n```\n\n\n### Example 3\n\nThis example shows how to incorporate the pipe operator. As it is common in many languages objects can have default input/output channels. This allows to concatenate entities with a single operation instead of having to connect each signal individually.   \n\n```Python \n\nclass axiFilter(v_clk_entity):\n    def __init__(self,clk=None):\n        super().__init__(__file__, clk)\n        self.Axi_in = port_Slave(axisStream(32,v_slv(32)))\n        self._StreamIn = self.Axi_in\n        self.Axi_out = port_Master(axisStream(32,v_slv(32)))\n        self._StreamOut = self.Axi_out\n        self.architecture()\n\n\n    def architecture(self):\n\n\n        axMaster = axisStream_master(self.Axi_out) \n        axiSlave = axisStream_slave(self.Axi_in)\n        i_buff =  v_variable(v_slv(32))\n        @rising_edge(self.clk)\n        def _process1():\n            print(\"axiPrint\",i_buff.value )\n            if axiSlave and axMaster:\n                i_buff << axiSlave\n                if i_buff < 10:\n                    axMaster << axiSlave\n                    print(\"axiPrint valid\",i_buff.value )\n\nclass axiPrint(v_clk_entity):\n    def __init__(self,clk=None):\n        super().__init__(__file__, clk)\n        self.Axi_in = port_Slave(axisStream(32,v_slv(32)))\n        self._StreamIn = self.Axi_in\n        self.architecture()\n\n\n    def architecture(self):\n\n        axiSlave = axisStream_slave(self.Axi_in)\n        i_buff = v_slv(32)\n        @rising_edge(self.clk)\n        def process1():\n            print(\"axiPrint\",i_buff.value )\n            if axiSlave :\n                i_buff << axiSlave\n                print(\"axiPrint valid\",i_buff.value )\n\n\n\nclass clk_generator(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.clk = port_out(v_sl())\n        self.architecture()\n\n    def architecture(self):\n\n\n        @timed()\n        def p1():\n            self.clk << 1\n            print(\"======================\")\n            yield wait_for(10)\n            self.clk << 0\n            yield wait_for(10)\n\n\nclass rollingCounter(v_clk_entity):\n    def __init__(self,clk=None,MaxCount=v_slv(32,100)):\n        super().__init__(__file__, clk)\n        self.Axi_out = port_Master( axisStream(32,v_slv(32)))\n        self._StreamOut = self.Axi_out\n        self.MaxCount = port_in(v_slv(32,10))\n        self.MaxCount << MaxCount\n        self.architecture()\n\n    def architecture(self):\n\n        counter = v_slv(32)\n        v_Axi_out = axisStream_master(self.Axi_out)\n\n        @rising_edge(self.clk)\n        def p2():\n\n            if v_Axi_out:\n                print(\"counter\", counter.value)\n                v_Axi_out << counter\n                counter << counter + 1\n\n            if counter > self.MaxCount:\n                counter << 0\n\n\nclass tb_entity(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.architecture()\n\n\n\n    def architecture(self):\n        clkgen = v_create(clk_generator())\n\n        maxCount = v_slv(32,20)\n        axiSource = v_create(rollingCounter(clkgen.clk,maxCount))\n        axP       = v_create(axiPrint(clkgen.clk))\n        axFilter  = v_create(axiFilter(clkgen.clk))\n\n        axiSource | axFilter | axP\n\n        end_architecture()\n```\n\nThis example can be simulated by using the following command:\n\n```Python\nax = tb_entity()\ngsimulation.run_timed(ax, 1000,\"example3.vcd\")\n```\n\n![Example3](pictures/example3.png)\n\n\nThe test bench can be converted to VHDL by using the following command:\n\n```Py\n\nprint(ax._get_definition())\n```\n\n\nWhich results in the following code:\n\n```VHDL\nentity tb_entity is \nend entity;\n\n\n\narchitecture rtl of tb_entity is\n\nsignal clkgen_clk : std_logic := '0'; \nsignal maxCount : std_logic_vector(31 downto 0) := x\"00000014\"; \nsignal axiSource_Axi_out_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal axiSource_Axi_out_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal axP_Axi_in_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal axP_Axi_in_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal axFilter_Axi_out_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal axFilter_Axi_out_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal axFilter_Axi_in_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal axFilter_Axi_in_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\n\nbegin\nclkgen : entity work.clk_generator port map ( \n      clk => clkgen_clk\n  );\n  axiSource : entity work.rollingCounter port map ( \n      clk => clkgen_clk,\n      Axi_out_m2s => axiSource_Axi_out_m2s, \n      Axi_out_s2m => axiSource_Axi_out_s2m,\n      MaxCount => maxCount\n  );\n  axP : entity work.axiPrint port map ( \n      clk => clkgen_clk,\n      Axi_in_m2s => axP_Axi_in_m2s, \n      Axi_in_s2m => axP_Axi_in_s2m\n  );\n  axFilter : entity work.axiFilter port map ( \n      clk => clkgen_clk,\n      Axi_out_m2s => axFilter_Axi_out_m2s, \n      Axi_out_s2m => axFilter_Axi_out_s2m,\n      Axi_in_m2s => axFilter_Axi_in_m2s, \n      Axi_in_s2m => axFilter_Axi_in_s2m\n  );\n  ---------------------------------------------------------------------\n  --  axFilter_Axi_in << axiSource_Axi_out\n  axFilter_Axi_in_m2s <= axiSource_Axi_out_m2s;\n  axiSource_Axi_out_s2m <= axFilter_Axi_in_s2m;\n    ---------------------------------------------------------------------\n  --  axP_Axi_in << axFilter_Axi_out\n  axP_Axi_in_m2s <= axFilter_Axi_out_m2s;\n  axFilter_Axi_out_s2m <= axP_Axi_in_s2m;\n\nend architecture;\n```\n\n### Example 4\n\n```Python\nclass tb_entity(v_entity):\n    def __init__(self):\n        super().__init__(__file__)\n        self.architecture()\n\n    def architecture(self):\n        clkgen = v_create(clk_generator())\n        maxCount = v_slv(32,20)\n        pipe1  = rollingCounter(clkgen.clk,maxCount)  \\\n                    | axiFilter(clkgen.clk) \\\n                    | axiPrint(clkgen.clk)\n\n        end_architecture()\n```\n\n![Example4](pictures/example4.png)\n\n```VHDL\nentity tb_entity is \nend entity;\n\narchitecture rtl of tb_entity is\n\nsignal clkgen_clk : std_logic := '0'; \nsignal maxCount : std_logic_vector(31 downto 0) := x\"00000014\"; \nsignal pipe1_1_rollingCounter_Axi_out_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal pipe1_1_rollingCounter_Axi_out_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal pipe1_2_axiFilter_Axi_in_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal pipe1_2_axiFilter_Axi_in_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal pipe1_2_axiFilter_Axi_out_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal pipe1_2_axiFilter_Axi_out_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\nsignal pipe1_3_axiPrint_Axi_in_m2s : axisStream_32_m2s := axisStream_32_m2s_null;\nsignal pipe1_3_axiPrint_Axi_in_s2m : axisStream_32_s2m := axisStream_32_s2m_null;\n\nbegin\nclkgen : entity work.clk_generator port map ( \n      clk => clkgen_clk\n  );\n  pipe1_1_rollingCounter : entity work.rollingCounter port map ( \n      MaxCount => maxCount,\n      clk => clkgen_clk,\n      Axi_out_m2s => pipe1_1_rollingCounter_Axi_out_m2s, \n      Axi_out_s2m => pipe1_1_rollingCounter_Axi_out_s2m\n  );\n    pipe1_2_axiFilter : entity work.axiFilter port map ( \n      clk => clkgen_clk,\n      Axi_in_m2s => pipe1_2_axiFilter_Axi_in_m2s, \n      Axi_in_s2m => pipe1_2_axiFilter_Axi_in_s2m,\n      Axi_out_m2s => pipe1_2_axiFilter_Axi_out_m2s, \n      Axi_out_s2m => pipe1_2_axiFilter_Axi_out_s2m\n  );\n    pipe1_3_axiPrint : entity work.axiPrint port map ( \n      clk => clkgen_clk,\n      Axi_in_m2s => pipe1_3_axiPrint_Axi_in_m2s, \n      Axi_in_s2m => pipe1_3_axiPrint_Axi_in_s2m\n  );\n    ---------------------------------------------------------------------\n  --  pipe1_2_axiFilter_Axi_in << pipe1_1_rollingCounter_Axi_out\n  pipe1_2_axiFilter_Axi_in_m2s <= pipe1_1_rollingCounter_Axi_out_m2s;\n  pipe1_1_rollingCounter_Axi_out_s2m <= pipe1_2_axiFilter_Axi_in_s2m;\n    ---------------------------------------------------------------------\n  --  pipe1_3_axiPrint_Axi_in << pipe1_2_axiFilter_Axi_out\n  pipe1_3_axiPrint_Axi_in_m2s <= pipe1_2_axiFilter_Axi_out_m2s;\n  pipe1_2_axiFilter_Axi_out_s2m <= pipe1_3_axiPrint_Axi_in_s2m;\n\nend architecture;\n```\n\n\n\n### Axi Stream Interface\n\nThis section shows how an interface can be implemented as a pseudo-class. For this, the Axi Stream Interface is used. This example is used because it is very simple and widely used. The axi stream interface has four signals that are exchanged between master and slave. \n\n| Name | Direction |\n|:--:|:----:|\n| Valid | Master To Slave |\n| Data | Master To Slave |\n| Last | Master To Slave |\n|ready | Slave to Master|\n\n![Axi Stream](pictures/axi.jpg)\n![Axi Stream Truth](pictures/axiStream_truth_table.png)\n\nSince it has four signals and each one can either be set or not set this results in 16 combinations. Only four of these 16 combinations are actual a correct state. All the other ones are undefined behavior. Programming languages usually solve this problem by not allowing users direct access to the underlying data but by providing higher-level APIs that provide a safe way of setting states. These APIs safeguard the user in two ways from entering undefined behavior (UB). First, if functions are used in the intended fashion the program can never reach an UB state. That should be illustrated with the following example (for details see example 3):  \n\n```Python\nif v_Axi_out:\n    v_Axi_out << counter\n```\n\nIn this example, ```v_Axi_out``` is a class that handles the Axi Stream Interface. ```Counter``` is a ```std_logic_vector``` equivalent variable. The program can only ever reach the assignment when the class ```v_Axi_out``` is True. The user has no (and needs no) further information about the actual implementation of ```v_Axi_out```. The actual implementation is the responsibility of the library provider. As long as the user always checks if the class is usable the user will never be able to reach UB. \n\nThe second way how APIs protect the user from entering UB is by providing a possibility to check for UB and then report an error to the user. This does not change that the interface is not working correctly but now the system is in an error state (not UB). This information can be used to protect the system from doing any more harm.\n\nIn Addition using a class that encapsulates the interface into one single object prevents the user from ever getting signals mixed up and vastly improves the readability of the source code. For Example ```HDPython``` allows the user to write the information if a given signal is an input or an output directly into the pseudo class:\n\n```Python\nclass axisStream(v_class):\n    def __init__(self,AxiName,Axitype):\n        super().__init__(\"axisStream_\"+str(AxiName))\n        AddDataType(  Axitype  )\n        self.valid  = port_out( v_sl() )\n        self.last   = port_out( v_sl() )\n        self.data   = port_out( Axitype  )\n        self.ready  = port_in( v_sl() )\n```\n\nThis pseudo class can then be consumed by an entity:\n\n```Python\nclass axiPrint(v_clk_entity):\n    def __init__(self,clk=None):\n        super().__init__(__file__, clk)\n        self.Axi_in = port_Slave(axisStream(32,v_slv(32)))\n```\n\nThis makes it very easy to reason about this code. \n\nIn order to use this model in VHDL the pseudo-class has to be broken up into two parts. One ```Master to Slave``` (m2s) part and one ```Slave to Master``` (s2m) part. When converting the pseudo-class to VHDL the following code will be generated:\n\n\n```VHDL\ntype axisStream_32_m2s is record \n  valid : std_logic; \n  data : std_logic_vector(31 downto 0); \n  last : std_logic; \nend record;\n\nconstant axisStream_32_m2s_null : axisStream_32_m2s:= (\n  valid => '0',\n  data => (others => '0'),\n  last => '0'\n);\n\ntype axisStream_32_s2m is record \n  ready : std_logic; \nend record;\n\nconstant axisStream_32_s2m_null : axisStream_32_s2m:= (\n  ready => '0'\n);\n```\n\nThe consuming entity is translated into the following VHDL:\n\n```VHDL\nentity axiPrint is \nport(\n  clk :  in  std_logic := '0';\n  Axi_in_m2s : in  axisStream_32_m2s := axisStream_32_m2s_null;\n  Axi_in_s2m : out axisStream_32_s2m := axisStream_32_s2m_null\n);\nend entity;\n```\n\n\n\n\n## Object-Oriented Design for HDL\n\n\n\nVirtually all modern programming languages allow the user to write customized objects to build powerful abstraction. The support for this is very limited in typical HDLs. This document is meant to show the limitations of current HDLs and especially how adding an additional layer of abstraction in form of HDPython can overcome this limitation.\n\n![base](pictures/Programming_base.png)\n\nIn this document, it is assumed that every program can be described with three basic building blocks: Responsibility Handler, Data Object and Processor. In programming, all names have already been used, which makes it exceedingly hard to use terminology that is not already used in a different context. For this document, only the definition given here should be used.\n\n### **Processor**\n\nThe Task of **processor** is to take input and transform it. For example, the following function ```f(x) = x^2``` transforms every input by multiplying it by itself. Another example of a **processor** would be a factory function which, depending on the input creates different objects. \n\n```Py\ndef factory(x):\n    if x == \"type_1\":\n        return type_1()\n\n    elif x == \"type_2\":\n        return type_2()\n\n    # ...    \n\n```\n\nAnother example of a **processor** would be a VHDL entity. \n\n### _Data Object_\n\nThe purpose of _Data Objects_ / _Data Structs_ is to store data recognizably. An example would be an object that stores the current time. \n\n```Py\nclass time_object:\n    def __init(self, time):\n        self.time = time\n```\n\nThe first thing this _data object_ communicates is its purpose. It is designed to store time. (Sure, in theory, a careless programmer could use it to store the outside temperature in it.) In addition to communicating its purpose, it also carries a value. Depending on the development of a given codebase the fact that any specific _data object_ is a time object can be communicated with a different mechanism. For example, in C++ a common approach would be to just use a typedef which allows the user the convenience of not having to rewrite all the functions for each new _data object_ while still communicating the purpose of a given object. However, if required, a _data object_ can be a complicated struct with many different members. The important thing is that all these members would belong logically together. For example, the current time can either be stored as UNIX time or as days, months, years, hours, minutes. In a given context, there might be a good reason to store time in days etc. independent of its implementation a _data object_ communicates its value and its purpose to the user. \n\n_Data objects_ are usually designed to be very simple and do not contain (much) functionality. All the functionality it provides is to access its value(s). \n\nWith these two building blocks, we can already create our first program:\n\n```Py\ntomorow = nextDay( today )\n```\nwith:\ntomorow, today... being _data objects_ of the type time\nnextDay...        being a **processor** which takes in time object and returns a new data object for the next day\n\n### Responsibility Handler\n\nThe last building block is the Responsibility Handler (RH). Which is used for example to handles the Responsibility of resource management. Its purpose is for example to allow access to system resources while at the same time protect the system from wrong use. The classical example would be a file handler or a smart pointer. \n\n\n\n\n## Limitations of current HDL\n\n### The strict IN/OUT model\n\nTypical HDLs are build-up of submodules. In the case of VHDL these submodules are called ```entities```. These ```entites``` are connected to each other by ports. A port can be a single bit (```std_logic```), an array of bits (```std_logic_vector```), a data structure (```record```) or an array of data structure. But no matter how complicated the individual port is, it has always to be labeled as either ```IN``` or ```OUT```. This strict separation between ```IN``` and ```OUT``` prohibit the creation of more complex objects. How do other languages solve the problem? Lets write the axi stream interface in C++. This example contains two objects, which exchange data by sharing a pointer to a common data storage. \n\n```C++\nclass axistream;\nclass source{\npublic:\n    source(axistream * ax);\n    void operator()();\nprivate:\n    axistream * ax;\n};\n\nclass destination{\npublic:\n    destination(const axistream * ax);\n    void operator()();\nprivate:\n    const axistream * ax;\n};\n\nclass axistream{\npublic:\n    int data;\n    bool valid;\n    bool last;\n    mutable bool ready;\n};\n\nauto ax = axistream();\nauto my_source = source(ax);\nauto my_destination = destination(ax);\n\n\nwhile(running()){\n    my_source();\n    my_destination();\n}\n```\n\nThis example shows that in C++ the direction of the data flow is directly express in the _axistream_ class. There is no need to tear apart the individual members of _axistream_. Everything is expressed in the type system of C++. The fact that **source** takes an _axistream_ pointer communicates that **source** wants to modify it. **destination** takes the _axistream_ as a const pointer which means it wants to consume the data. The mutable keyword communicates that this member will (most) likely be modified by the destination. In this example ready could be modified by two places, which is not possible in HDL. This could be fixed by using some template Meta programming technics, which are not part of the scope of this document. The important part is that the _object_ itself carries information about the data flow with it. Translating this to VHDL and we would end up with a construct like this (pseudo syntax):\n\n```VHDL\ntype axi_Stream  is record \n  data  :  out Integer; \n  valid :  out std_logic; \n  last  :  out std_logic; \n  ready :  in  std_logic; \nend record;\n\n\nentity source is \nport(\n  clk     :  in     std_logic;\n  Axi_out : master  axi_Stream;\n\n);\nend entity;\n\nentity destination is \nport(\n  clk     :  in    std_logic;\n  Axi_in  : slave  axi_Stream;\n\n);\nend entity;\n```\n\nOn every abstraction level, this code communicates exactly what is needed to know (and not more). On the record level, it shows that it will be used as an interface between two objects. In addition, which of the signals flow in which direction. On the entity level, it communicates only if it is a source or a destination. The internal layout of _axi_stream_ does not matter at this point. With the introduction of these new keywords and the possibility to give records directional qualifiers it is possible to easily create compound objects. For example, a bidirectional axi stream can be written as:\n\n```VHDL\ntype axi_Stream  is record \n  data  :  out Integer; \n  valid :  out std_logic; \n  last  :  out std_logic; \n  ready :  in  std_logic; \nend record;\n\ntype axi_Stream_directional  is record \n  TX : master axi_Stream;\n  RX : slave axi_Stream;\nend record;\n```\n\n### Encapsulation\n\nIn HDL, it is a common approach to modify signals directly without the protection of encapsulation. Depending on the context, this approach has been proven to be problematic, especially when there is an invariance to protect. In these cases, it has shown to be the safer approach to use (member) function to make the modification. A good example for an invariance that needs to be preserved is the number of elements in a C++ vector. In order to add a new element to a vector there are many steps that have to be done correctly to not destroy the invariance. \n\n1. Checking the size of the vector\n1. Allocate memory\n1. Copy elements to new location.\n1. Change pointer to point to the new location\n1. Add the element \n1. Update the end pointer\n1. ...\n\nAll these complicated procedures are completely hidden from the user by the simple ```push_back``` function call. As long as the user does not access the members directly, the user will never reach UB. \n\nWhat makes this approach so difficult to achieve in HDL is that objects are always split up into inputs and outputs. There is no one object that represents an idea there are at least two. In addition, VHDL does not allow the creation of member functions. This limitation can be overcome by using free-function. \n\n### Information Hiding / (Compile time) Polymorphism\n\nAs described it is a common approach in HDLs to modify signals directly. In addition to the already described problem, it violates the principle of information hiding and prohibits any form of polymorphism. Let us take as an example the axi stream interface and the native FIFO interface.\n\n![native fifo](pictures/native_fifo.png)\n\nThese interfaces do the same thing, yet they have three different ways of using them. The only thing a user ever would be interested is:\n\nOn the master side:\n\n- can I write data\n- write data\n\nOn the slave side\n\n- can I read data\n- read data\n\nThis is true for axi stream, native writer and native reader interface. This problem can be solved by providing common interface abstractions. One example from C++ would be the common base class:\n\n```C++\nclass stream_writer{\n    public:\n    virtual bool ready() const = 0;\n    virtual void write(data_t data) = 0;\n};\n\nclass stream_reader{\n    public:\n    virtual bool ready() const = 0;\n    virtual data_t read() = 0;\n};\n\nclass axistream_master : public stream_writer{\npublic:\n    bool ready() const override;\n    void write(data_t data) override;\nprivate:\n    axi_stream_t ax;\n};\n```\n\n(Note: In C++, there are many ways of doing anything)\n\nWith this approach, the details of each interface are hidden from the user. \n\n### Classes / Combination of Data and Functions\n\nThis section will concentrate on entities and signals. In VHDL entities and signals are instantiated at very different parts of the source file and do not share any visible connection. Therefore it is up to the user to come up with good names that exactly describe the relationship of each entity and each signal. The next example shows how in C++ this problem solved:\n\n```C++\nclass axistream{\npublic:\n    int data;\n    bool valid;\n    bool last;\n    mutable bool ready;\n};\n\nclass source{\npublic:\n    source();\n    void operator()();\n    const axistream* get_data() const;\nprivate:\n    axistream  ax;\n};\n\nclass destination{\npublic:\n    destination(const axistream * ax);\n    void operator()();\nprivate:\n    const axistream * ax;\n};\n\nauto my_source = source();\nauto my_destination = destination(my_source.get_data());\n\nwhile(running()){\n    my_source();\n    my_destination();\n}\n```\n\nIn this example **source** owns the _data object_, which makes it much easier to reason about the data flow. Now the line ```auto my_destination = destination(my_source.get_data());``` explains exactly where the data comes from. It does not depend on a smart naming scheme to communicate this information. Also it cannot be done wrong ```my_source.get_data()``` returns a constant pointer. It can only be used in a sink. It cannot accidentally be connected to another source. It will never accidentally return the wrong _data object_. It is correct by design. \n\n## VHDL Pseudo Classes\n\n\n## HDPython Classes\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/HardwareDesignWithPython/HDPython",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "HDPython",
    "package_url": "https://pypi.org/project/HDPython/",
    "platform": "",
    "project_url": "https://pypi.org/project/HDPython/",
    "project_urls": {
      "Homepage": "https://github.com/HardwareDesignWithPython/HDPython"
    },
    "release_url": "https://pypi.org/project/HDPython/0.0.5/",
    "requires_dist": [
      "pyvcd"
    ],
    "requires_python": ">=3.8",
    "summary": "High Level Object Oriented Hardware Description Library",
    "version": "0.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11785799,
  "releases": {
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b78d4efdf72eb3043b194e029dfeb9bacc8abf5c6a62e82acbccc3e453489d3e",
          "md5": "ce43024b7a86dfdb0c2779e2d37d96d5",
          "sha256": "6905a8e33d8904932480c07d773ba81fa45993e93980e0fd304d17add60fc396"
        },
        "downloads": -1,
        "filename": "HDPython-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ce43024b7a86dfdb0c2779e2d37d96d5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 88047,
        "upload_time": "2021-10-20T20:30:33",
        "upload_time_iso_8601": "2021-10-20T20:30:33.196447Z",
        "url": "https://files.pythonhosted.org/packages/b7/8d/4efdf72eb3043b194e029dfeb9bacc8abf5c6a62e82acbccc3e453489d3e/HDPython-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "221cd040fadafbee7a8d417abb6fb388c6de803661b25afbb48549c18b6658d8",
          "md5": "3dadf21252413b1f37e9105ed4d62664",
          "sha256": "f9e28a4ab3364262804af5e3808c2b9dc03bd0e795bbe46d7c08680c1a1169c5"
        },
        "downloads": -1,
        "filename": "HDPython-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "3dadf21252413b1f37e9105ed4d62664",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 77358,
        "upload_time": "2021-10-20T20:30:35",
        "upload_time_iso_8601": "2021-10-20T20:30:35.433905Z",
        "url": "https://files.pythonhosted.org/packages/22/1c/d040fadafbee7a8d417abb6fb388c6de803661b25afbb48549c18b6658d8/HDPython-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9724a319164bb6f8674ea53a35ab6aaf8269be7f27359e48a1f359706570fd5c",
          "md5": "2e19cb317474405d918e34ddd52bd0fe",
          "sha256": "48d32f9793cdbe8d1ddce21d99c0fc3c6d96de57fc968ca73d372566a1f05896"
        },
        "downloads": -1,
        "filename": "HDPython-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2e19cb317474405d918e34ddd52bd0fe",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 160299,
        "upload_time": "2021-10-20T22:06:32",
        "upload_time_iso_8601": "2021-10-20T22:06:32.873033Z",
        "url": "https://files.pythonhosted.org/packages/97/24/a319164bb6f8674ea53a35ab6aaf8269be7f27359e48a1f359706570fd5c/HDPython-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "308d7a65031d1bcd6aefdc9561f132f6caf514cdb5d1b8c353d5baaed1d97e06",
          "md5": "35e42668ad0282f524e8ebc76a4b9931",
          "sha256": "e36f69bfb0c28c12dd9d75ab7f727ed61715ae1d6f62cab93c46bfbaf787eaf0"
        },
        "downloads": -1,
        "filename": "HDPython-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "35e42668ad0282f524e8ebc76a4b9931",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 116318,
        "upload_time": "2021-10-20T22:06:36",
        "upload_time_iso_8601": "2021-10-20T22:06:36.358833Z",
        "url": "https://files.pythonhosted.org/packages/30/8d/7a65031d1bcd6aefdc9561f132f6caf514cdb5d1b8c353d5baaed1d97e06/HDPython-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9724a319164bb6f8674ea53a35ab6aaf8269be7f27359e48a1f359706570fd5c",
        "md5": "2e19cb317474405d918e34ddd52bd0fe",
        "sha256": "48d32f9793cdbe8d1ddce21d99c0fc3c6d96de57fc968ca73d372566a1f05896"
      },
      "downloads": -1,
      "filename": "HDPython-0.0.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2e19cb317474405d918e34ddd52bd0fe",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 160299,
      "upload_time": "2021-10-20T22:06:32",
      "upload_time_iso_8601": "2021-10-20T22:06:32.873033Z",
      "url": "https://files.pythonhosted.org/packages/97/24/a319164bb6f8674ea53a35ab6aaf8269be7f27359e48a1f359706570fd5c/HDPython-0.0.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "308d7a65031d1bcd6aefdc9561f132f6caf514cdb5d1b8c353d5baaed1d97e06",
        "md5": "35e42668ad0282f524e8ebc76a4b9931",
        "sha256": "e36f69bfb0c28c12dd9d75ab7f727ed61715ae1d6f62cab93c46bfbaf787eaf0"
      },
      "downloads": -1,
      "filename": "HDPython-0.0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "35e42668ad0282f524e8ebc76a4b9931",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 116318,
      "upload_time": "2021-10-20T22:06:36",
      "upload_time_iso_8601": "2021-10-20T22:06:36.358833Z",
      "url": "https://files.pythonhosted.org/packages/30/8d/7a65031d1bcd6aefdc9561f132f6caf514cdb5d1b8c353d5baaed1d97e06/HDPython-0.0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}