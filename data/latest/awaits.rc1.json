{
  "info": {
    "author": "Evgeniy Blinov",
    "author_email": "zheni-b@yandex.ru",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "# awaits - делаем работу с асинхронными / многопоточными приложениями проще\n\nДанная библиотека решает 3 проблемы:\n\n- Асинхронное программирование с использованием синтаксиса async / await теряет смысл, если в коде часто встречаются куски с \"тяжелыми\" вычислениями, которые блокируют event-loop. Зато теперь вы можете навесить на такую \"тяжелую\" функцию декоратор [```@awaitable```](#декоратор-awaitable) и она станет корутиной, которая будет исполняться в отдельном потоке, не блокируя event-loop. Во всем остальном это будет совершенно обычная корутина.\n- Многопоточное программирование многословно. Чтобы заставить ваш код исполняться в многопоточном режиме, вам нужно создавать объекты потоков, передавать туда нужные функции и запускать потоки. Теперь же вам достаточно навесить на обычную функцию декоратор и она автоматически будет исполняться в многопоточном режиме.\n- Частое создание потоков в программе требует постоянно отслеживать создание потоков и управление ими. Здесь же минимальным уровнем абстракции для вас становится группа потоков (pool of threads), а не какой-то отдельный поток. Ими становится удобно управлять в рамках т. н. \"комнат\" (rooms) с такими группами, где каждой группе присваивается имя.\n\nПрочитайте документацию ниже, чтобы увидеть, как все это работает.\n\n\n\n## Оглавление\n\n- [**Быстрый старт**](#быстрый-старт)\n- [**Как это все работает?**](#как-это-все-работает)\n- [**Как работает группа потоков?**](#как-работает-группа-потоков)\n- [**Что такое \"комната\"?**](#что-такое-комната)\n- [**Об объекте задачи**](#об-объекте-задачи)\n- [**Декоратор ```@awaitable```**](#декоратор-awaitable)\n- [**Декоратор ```@shoot```**](#декоратор-shoot)\n- [**Настройки**](#настройки)\n\n\n## Быстрый старт\n\nУстановите awaits через [pip](https://pypi.org/project/awaits/):\n\n```\npip install awaits\n```\n\nТеперь просто импортируйте декоратор [```@awaitable```](#декоратор-awaitable) и примените его к вашей функции. Никаких настроек, ничего лишнего - все уже работает:\n\n```python\nimport asyncio\nfrom awaits.awaitable import awaitable\n\n\n@awaitable\ndef sum(a, b):\n  # Какой-то сложный датасаенз. Что-то, что вычисляется долго и мешает вашему event-loop'у жить.\n  return a + b\n\n# Теперь sum - это корутина! Пока она выполняется в отдельном потоке, управление передается в event-loop.\nprint(asyncio.run(sum(2, 2)))\n```\n\nГотово! Мы сделали из обычной функции неблокирующую ваш event-loop корутину, к которой теперь применим синтаксис await.\n\nЕсли ваша функция ничего не возвращает, к ней можно применить другой декоратор, [```@shoot```](#декоратор-shoot):\n\n```python\nfrom awaits.shoot import shoot\n\n\n@shoot\ndef hello():\n  # Тоже что-то тяжелое, но результат чего вам по какой-то причине не нужен.\n  print('Hello world!')\n\n# Функция будет \"отстрелена\" исполняться в отдельный поток, не блокируя основной.\nhello()\n```\n\nВаша функция будет исполняться в другом потоке, в то время как основной может уже заняться чем-то еще.\n\nБолее подробно о возможностях библиотеки awaits читайте ниже.\n\n\n## Как это все работает?\n\nБазовым \"примитивом\" библиотеки является [группа потоков](#как-работает-группа-потоков) (threads pool). \"Сердцем\" группы является очередь (queue) с задачами (объектами класса [```Task```](#об-объекте-задачи)). Когда вы создаете новую группу потоков, внутри себя она порождает сколько-то потоков с \"воркерами\", которые постоянно ждут новых задач из очереди. Как только в очереди появляется новая задача, первый же освободившийся воркер выполняет ее.\n\nЧтобы выполнить в группе произвольную функцию, вам достаточно передать ее туда вместе с необходимыми аргументами. При этом группа вернет вам объект класса [```Task```](#об-объекте-задачи), в котором по значению атрибута ```done``` вы можете отслеживать, выполнена ваша задача или нет. Если она выполнена - можете забрать результат из атрибута ```result```. Более подробно о работе с группами потоков читайте в [соответствующем разделе](#как-работает-группа-потоков).\n\nДля удобства управления несколькими группами, библиотека содержит абстракцию \"комната\". По своей сути это обертка вокруг словаря с группами потоков. Обращаясь к \"комнате\" по ключу, вы либо получаете новую группу потоков, если ранее этой группы не существовало, либо уже имеющуюся группу, если ранее она создавалась. Так вам становится не нужно вручную создавать группы потоков.\n\nДля работы декораторов используется \"комната\", хранящаяся в синглтоне. Обернутые в декораторы [```@awaitable```](#декоратор-awaitable) и [```@shoot```](#декоратор-shoot) функции будут выполняться в группах потоков из одной и той же комнаты (по умолчанию - в одной группе потоков под названием ```\"base\"```).\n\nЗа счет такой компоновки, весь менеджмент потоков происходит \"под капотом\" и вам больше не нужно задумываться над тем, в каком именно потоке выполнится ваша функция. Она выполнится в том, который раньше всех освободится.\n\n\n## Как работает группа потоков?\n\nГруппа потоков - это экземпляр класса ```ThreadsPool```. Импортируем его:\n\n```python\nfrom awaits.threads_pool import ThreadsPool\n```\n\nПри инициализации экземпляра будут созданы потоки. Число потоков в группе вы указываете в конструкторе класса:\n\n```python\nthreads = ThreadsPool(5)\n```\n\nТеперь, когда группа создана, ей можно давать задания, используя метод ```do()```:\n\n```python\ndef function(a, b, c, d=5, e=5):\n  return a + b + c + d + e\n\ntask = threads.do(function, 1, 2, 3, d=10, e=20)\n```\n\nПервым параметром туда передается функция, которую требуется выполнить, а далее все те же параметры и в том же порядке, как при оригинальном вызове этой функции.\n\nЧто тут произошло под капотом? Метод ```do()``` создал объект класса [```Task```](#об-объекте-задачи), передав туда функцию для выполнения и все ее параметры, и положил его в очередь. Объект задачи он вам вернул, чтобы вы могли отслеживать прогресс выполнения и результат. Воркеры из других потоков постоянно ждут появления новых элементов в очереди. Если хоть один из них свободен - он сразу получит вашу задачу и выполнит ее. Если нет, задача будет ждать в очереди освобождения первого воркера.\n\nКак только задача будет выполнена, вы можете получить результат:\n\n```python\n# Флаг task.done в положении True свидетельствует о том, что задача выполнена и вы можете получить результат.\nwhile not task.done:\n    pass\n\nprint(task.result)\n```\n\nЕсли при выполнении функции случилась ошибка, в объекте задачи атрибут ```error``` будет установлен в положение ```True```, а получить экземпляр исключения вы можете из атрибута ```exception```:\n\n```python\ndef error_function(a, b):\n  return a / b\n\ntask = threads.do(error_function, 2, 0)\n\nwhile not task.done:\n    pass\n\nif task.error:\n  raise task.exception\n```\n\n\n## Что такое \"комната\"?\n\nКомната (room) - это абстракция над группами потоков, позволяющая отдавать задания разным группам, называя их по именам. По сути это обертка над словарем.\n\nСоздадим объект комнаты:\n\n```python\nfrom awaits.threads_pools_room import ThreadsPoolsRoom\n\n\nroom = ThreadsPoolsRoom(5)\n```\n\nЧисло, передаваемое в конструктор - количество потоков в каждой из групп данной комнаты.\n\nКонкретную группу потоков можно получить, используя синтаксис словаря:\n\n```python\npool = room['some_key']\n```\n\nПоскольку мы впервые обращаемся к комнате по этому ключу, она создаст новый объект класса [```ThreadsPool```](#как-работает-группа-потоков) и вернет его. При последующих обращениях по этому ключу, она будет возвращать тот же самый объект.\n\n\n## Об объекте задачи\n\nЗадача - это объект класса ```Task```. В конструктор объекта первым аргументом передается функция для выполнения, а последующими - ее аргументы:\n\n```python\nfrom awaits.task import Task\n\n\ndef hello_something(something, sign='!'):\n  hello_string = f'Hello {something}{sign}'\n  print(hello_string)\n  return hello_string\n\ntask = Task(hello_something, 'world')\n```\n\nВ неактивированном состоянии задача просто хранит в себе функцию и ее аргументы. Чтобы выполнить функцию с заданными аргументами, необходимо вызвать у задачи метод ```do()```:\n\n```python\ntask.do()\n```\n\nФлаг ```task.done``` будет установлен в положение ```True```, когда задача будет выполнена. После этого вы можете получить результат выполнения из атрибута ```result```:\n\n```python\nwhile not task.done:\n    pass\n\nprint(task.result)\n```\n\nЕсли при выполнении функции случилась ошибка, в объекте задачи атрибут ```error``` будет установлен в положение ```True```, а получить экземпляр исключения вы можете из атрибута ```exception```:\n\n```python\ndef error_function(a, b):\n  return a / b\n\ntask = threads.do(error_function, 2, 0)\n\nwhile not task.done:\n    pass\n\nif task.error:\n  raise task.exception\n```\n\n\n## Декоратор ```@awaitable```\n\nПрочитав документацию выше, вы уже научились создавать группы потоков и комнаты с ними, а также давать потокам на исполнение различные задания. Однако делать даже это вручную не обязательно.\n\nДекоратор ```@awaitable``` превращает обычную функцию в корутину, т. е. в функцию, с которой можно работать через await-синтаксис Python. Давайте попробуем создать такую функцию:\n\n```python\nfrom awaits.awaitable import awaitable\n\n\n@awaitable\ndef heavy_math_function(x, y):\n  return x * y\n```\n\nПри попытке выполнения функции, она будет вести себя как обычная корутина. Однако фактически ее код будет выполняться в группе потоков. Пока код выполняется, управление будет передано в event-loop.\n\n```python\n# Проверяем, что это действительно корутина.\nprint(asyncio.run(heavy_math_function(5, 5)))\n```\n\n\"Под капотом\" при этом происходит периодический опрос состояния задачи с последующим \"засыпанием\" (вызовом ```asyncio.sleep()```) на некий промежуток времени. Как только задача выполнена, ее результат возвращается. Если выполнение прервано исключением - оно извлекается из [объекта задачи](#об-объекте-задачи) и снова поднимается.\n\nПромежуток, на который функция \"засыпает\" между опросами о готовности, по умолчанию берется из [глобальных настроек](#настройки) библиотеки. При необходимости, вы можете указать его в фабрике декоратора (в секундах):\n\n```python\n@awaitable(delay=0.5)\ndef heavy_math_function(x, y):\n  return x * y\n```\n\nРучное управление вам может быть полезно, к примеру, в случае особо \"тяжелых\" функций, которые нет смысла опрашивать слишком часто.\n\nКроме того, отдельным параметром вы можете указать имя группы потоков, в которой вы хотите чтобы выполнялся код. По умолчанию используется группа ```\"base\"```.\n\n```python\n@awaitable(pool='gravities')\ndef heavy_math_function(x, y):\n  return x * y\n```\n\n## Декоратор ```@shoot```\n\nЭтот декоратор проще, чем [```@awaitable```](#декоратор-awaitable). Обернутая им функция будет просто \"отстрелена\" в группу потоков, без ожидания результата. Возвращен при этом будет объект класса [```Task```](#об-объекте-задачи), что позволяет вручную отслеживать статус выполнения.\n\n```python\nfrom awaits.shoot import shoot\n\n\n@shoot\ndef other_heavy_math_function(x, y):\n  return x * y\n\ntask = other_heavy_math_function(10, 10)\n\nwhile not task.done:\n    pass\n\nprint(task.result)\n```\n\nПри необходимости, вы можете указать название группы потоков, в котором хотите, чтобы выполнялась ваша функция:\n\n```python\n@shoot(pool='gravities')\ndef other_heavy_math_function(x, y):\n  return x * y\n```\n\nПо умолчанию также используется группа ```\"base\"```.\n\n## Настройки\n\nВы можете настроить параметры по умолчанию самостоятельно. Для этого необходимо вызвать метод ```set``` у класса ```config```:\n\n```python\nfrom awaits.config import config\n\n\n# Для примера устанавливаем частоту опроса задачи в декораторе @awaitable на значение 0.5 сек.\nconfig.set(delay=10.5)\n```\n\nДанный метод принимает следующие именованные параметры:\n\n  **pool_size** (int) - количество потоков в группе по умолчанию. Важно, чтобы данная настройка была выставлена до выполнения первой задачи. Если не установить этот параметр, он будет равен 10.\n\n  **delay** (int или float) - значение задержки (в секундах) между итерациями опроса завершенности задачи. Используется по умолчанию в декораторе [```@awaitable```](#декоратор-awaitable). Если не установить это значение вручную, будет использовано число ```0.001```.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/pomponchik/awaits",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "awaits",
    "package_url": "https://pypi.org/project/awaits/",
    "platform": "",
    "project_url": "https://pypi.org/project/awaits/",
    "project_urls": {
      "Homepage": "https://github.com/pomponchik/awaits"
    },
    "release_url": "https://pypi.org/project/awaits/0.0.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "async + threads + decorators = ?",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8493242,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e3460d1d43e53b474d331eb0af163b1b34e6c4cb41efa88fa057f38e194882ba",
          "md5": "3169840c81988bb811f6def7278d1854",
          "sha256": "d6526e5767416404289bce14ce056b61b9ea58722d13d25143d601d1310d5375"
        },
        "downloads": -1,
        "filename": "awaits-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3169840c81988bb811f6def7278d1854",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 12579,
        "upload_time": "2020-10-24T23:46:28",
        "upload_time_iso_8601": "2020-10-24T23:46:28.284677Z",
        "url": "https://files.pythonhosted.org/packages/e3/46/0d1d43e53b474d331eb0af163b1b34e6c4cb41efa88fa057f38e194882ba/awaits-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ecbaa38d8a3cae4daeae462e645c4ebc6d081dfcd031c09b010af0b6dfdfb37c",
          "md5": "051abbb14b8130936e3399c92ac18aa7",
          "sha256": "fa6846c140b76486a87a920ba5aa831353f16de7873750f0969e6d4d5b94f1e0"
        },
        "downloads": -1,
        "filename": "awaits-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "051abbb14b8130936e3399c92ac18aa7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 15191,
        "upload_time": "2020-10-24T23:46:30",
        "upload_time_iso_8601": "2020-10-24T23:46:30.970671Z",
        "url": "https://files.pythonhosted.org/packages/ec/ba/a38d8a3cae4daeae462e645c4ebc6d081dfcd031c09b010af0b6dfdfb37c/awaits-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e3460d1d43e53b474d331eb0af163b1b34e6c4cb41efa88fa057f38e194882ba",
        "md5": "3169840c81988bb811f6def7278d1854",
        "sha256": "d6526e5767416404289bce14ce056b61b9ea58722d13d25143d601d1310d5375"
      },
      "downloads": -1,
      "filename": "awaits-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "3169840c81988bb811f6def7278d1854",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 12579,
      "upload_time": "2020-10-24T23:46:28",
      "upload_time_iso_8601": "2020-10-24T23:46:28.284677Z",
      "url": "https://files.pythonhosted.org/packages/e3/46/0d1d43e53b474d331eb0af163b1b34e6c4cb41efa88fa057f38e194882ba/awaits-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ecbaa38d8a3cae4daeae462e645c4ebc6d081dfcd031c09b010af0b6dfdfb37c",
        "md5": "051abbb14b8130936e3399c92ac18aa7",
        "sha256": "fa6846c140b76486a87a920ba5aa831353f16de7873750f0969e6d4d5b94f1e0"
      },
      "downloads": -1,
      "filename": "awaits-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "051abbb14b8130936e3399c92ac18aa7",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 15191,
      "upload_time": "2020-10-24T23:46:30",
      "upload_time_iso_8601": "2020-10-24T23:46:30.970671Z",
      "url": "https://files.pythonhosted.org/packages/ec/ba/a38d8a3cae4daeae462e645c4ebc6d081dfcd031c09b010af0b6dfdfb37c/awaits-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}