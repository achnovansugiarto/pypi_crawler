{
  "info": {
    "author": "James Saryerwinnie",
    "author_email": "js@jamesls.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Natural Language :: English",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "========================================\nPython Serverless Microframework for AWS\n========================================\n\n.. image:: https://badges.gitter.im/awslabs/chalice.svg\n   :target: https://gitter.im/awslabs/chalice?utm_source=badge&utm_medium=badge\n   :alt: Gitter\n.. image:: https://travis-ci.org/aws/chalice.svg?branch=master\n   :target: https://travis-ci.org/aws/chalice\n   :alt: Travis CI\n.. image:: https://readthedocs.org/projects/chalice/badge/?version=latest\n   :target: http://chalice.readthedocs.io/en/latest/?badge=latest\n   :alt: Documentation Status\n.. image:: https://codecov.io/github/aws/chalice/coverage.svg?branch=master\n   :target: https://codecov.io/github/aws/chalice\n   :alt: codecov.io\n\nChalice is a microframework for writing serverless apps in python. It allows\nyou to quickly create and deploy applications that use AWS Lambda.  It provides:\n\n* A command line tool for creating, deploying, and managing your app\n* A decorator based API for integrating with Amazon API Gateway, Amazon S3,\n  Amazon SNS, Amazon SQS, and other AWS services.\n* Automatic IAM policy generation\n\n\nYou can create Rest APIs:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    @app.route(\"/\")\n    def index():\n        return {\"hello\": \"world\"}\n\nTasks that run on a periodic basis:\n\n.. code-block:: python\n\n    from chalice import Chalice, Rate\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Automatically runs every 5 minutes\n    @app.schedule(Rate(5, unit=Rate.MINUTES))\n    def periodic_task(event):\n        return {\"hello\": \"world\"}\n\n\nYou can connect a lambda function to an S3 event:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Whenever an object is uploaded to 'mybucket'\n    # this lambda function will be invoked.\n\n    @app.on_s3_event(bucket='mybucket')\n    def handler(event):\n        print(\"Object uploaded for bucket: %s, key: %s\"\n              % (event.bucket, event.key))\n\nAs well as an SQS queue:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Invoke this lambda function whenever a message\n    # is sent to the ``my-queue-name`` SQS queue.\n\n    @app.on_sqs_message(queue='my-queue-name')\n    def handler(event):\n        for record in event:\n            print(\"Message body: %s\" % record.body)\n\n\nAnd several other AWS resources.\n\nOnce you've written your code, you just run ``chalice deploy``\nand Chalice takes care of deploying your app.\n\n::\n\n    $ chalice deploy\n    ...\n    https://endpoint/dev\n\n    $ curl https://endpoint/api\n    {\"hello\": \"world\"}\n\nUp and running in less than 30 seconds.\nGive this project a try and share your feedback with us here on Github.\n\nThe documentation is available\n`on readthedocs <http://chalice.readthedocs.io/en/latest/>`__.\n\nQuickstart\n==========\n\n.. quick-start-begin\n\nIn this tutorial, you'll use the ``chalice`` command line utility\nto create and deploy a basic REST API.\nFirst, you'll need to install ``chalice``.  Using a virtualenv\nis recommended::\n\n    $ pip install virtualenv\n    $ virtualenv ~/.virtualenvs/chalice-demo\n    $ source ~/.virtualenvs/chalice-demo/bin/activate\n\nNote: **make sure you are using python2.7, python3.6, or python3.7**.\nThese are the only python versions currently supported by AWS Lambda so they\nare also the only versions supported by the ``chalice`` CLI and ``chalice``\npython package. You can check the version of python in your virtualenv by\nrunning::\n\n    # Double check you have a supported python version in your virtualenv\n    $ python -V\n\nNext, in your virtualenv, install ``chalice``::\n\n    $ pip install chalice\n\nYou can verify you have chalice installed by running::\n\n    $ chalice --help\n    Usage: chalice [OPTIONS] COMMAND [ARGS]...\n    ...\n\n\nCredentials\n-----------\n\nBefore you can deploy an application, be sure you have\ncredentials configured.  If you have previously configured your\nmachine to run boto3 (the AWS SDK for Python) or the AWS CLI then\nyou can skip this section.\n\nIf this is your first time configuring credentials for AWS you\ncan follow these steps to quickly get started::\n\n    $ mkdir ~/.aws\n    $ cat >> ~/.aws/config\n    [default]\n    aws_access_key_id=YOUR_ACCESS_KEY_HERE\n    aws_secret_access_key=YOUR_SECRET_ACCESS_KEY\n    region=YOUR_REGION (such as us-west-2, us-west-1, etc)\n\nIf you want more information on all the supported methods for\nconfiguring credentials, see the\n`boto3 docs\n<http://boto3.readthedocs.io/en/latest/guide/configuration.html>`__.\n\n\nCreating Your Project\n---------------------\n\nThe next thing we'll do is use the ``chalice`` command to create a new\nproject::\n\n    $ chalice new-project helloworld\n\nThis will create a ``helloworld`` directory.  Cd into this\ndirectory.  You'll see several files have been created for you::\n\n    $ cd helloworld\n    $ ls -la\n    drwxr-xr-x   .chalice\n    -rw-r--r--   app.py\n    -rw-r--r--   requirements.txt\n\nYou can ignore the ``.chalice`` directory for now, the two main files\nwe'll focus on is ``app.py`` and ``requirements.txt``.\n\nLet's take a look at the ``app.py`` file:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n\nThe ``new-project`` command created a sample app that defines a\nsingle view, ``/``, that when called will return the JSON body\n``{\"hello\": \"world\"}``.\n\n\nDeploying\n---------\n\nLet's deploy this app.  Make sure you're in the ``helloworld``\ndirectory and run ``chalice deploy``::\n\n    $ chalice deploy\n    ...\n    Initiating first time deployment...\n    https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n\nYou now have an API up and running using API Gateway and Lambda::\n\n    $ curl https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n    {\"hello\": \"world\"}\n\nTry making a change to the returned dictionary from the ``index()``\nfunction.  You can then redeploy your changes by running ``chalice deploy``.\n\n\nFor the rest of these tutorials, we'll be using ``httpie`` instead of ``curl``\n(https://github.com/jakubroztocil/httpie) to test our API.  You can install\n``httpie`` using ``pip install httpie``, or if you're on Mac, you can run\n``brew install httpie``.  The Github link has more information on installation\ninstructions.  Here's an example of using ``httpie`` to request the root\nresource of the API we just created.  Note that the command name is ``http``::\n\n\n    $ http https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n    HTTP/1.1 200 OK\n    Connection: keep-alive\n    Content-Length: 18\n    Content-Type: application/json\n    Date: Mon, 30 May 2016 17:55:50 GMT\n    X-Cache: Miss from cloudfront\n\n    {\n        \"hello\": \"world\"\n    }\n\n\nAdditionally, the API Gateway endpoints will be shortened to\n``https://endpoint/api/`` for brevity.  Be sure to substitute\n``https://endpoint/api/`` for the actual endpoint that the ``chalice``\nCLI displays when you deploy your API (it will look something like\n``https://abcdefg.execute-api.us-west-2.amazonaws.com/api/``.\n\nNext Steps\n----------\n\nYou've now created your first app using ``chalice``.\n\nThe next few sections will build on this quickstart section and introduce\nyou to additional features including: URL parameter capturing,\nerror handling, advanced routing, current request metadata, and automatic\npolicy generation.\n\n\nTutorial: URL Parameters\n========================\n\nNow we're going to make a few changes to our ``app.py`` file that\ndemonstrate additional capabilities provided by the python serverless\nmicroframework for AWS.\n\nOur application so far has a single view that allows you to make\nan HTTP GET request to ``/``.  Now let's suppose we want to capture\nparts of the URI:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n    CITIES_TO_STATE = {\n        'seattle': 'WA',\n        'portland': 'OR',\n    }\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n    @app.route('/cities/{city}')\n    def state_of_city(city):\n        return {'state': CITIES_TO_STATE[city]}\n\n\nIn the example above, we've now added a ``state_of_city`` view that allows\na user to specify a city name.  The view function takes the city\nname and returns name of the state the city is in.  Notice that the\n``@app.route`` decorator has a URL pattern of ``/cities/{city}``.  This\nmeans that the value of ``{city}`` is captured and passed to the view\nfunction.  You can also see that the ``state_of_city`` takes a single\nargument.  This argument is the name of the city provided by the user.\nFor example::\n\n    GET /cities/seattle   --> state_of_city('seattle')\n    GET /cities/portland  --> state_of_city('portland')\n\nNow that we've updated our ``app.py`` file with this new view function,\nlet's redeploy our application.  You can run ``chalice deploy`` from\nthe ``helloworld`` directory and it will deploy your application::\n\n    $ chalice deploy\n\nLet's try it out.  Note the examples below use the ``http`` command\nfrom the ``httpie`` package.  You can install this using ``pip install httpie``::\n\n    $ http https://endpoint/api/cities/seattle\n    HTTP/1.1 200 OK\n\n    {\n        \"state\": \"WA\"\n    }\n\n    $ http https://endpoint/api/cities/portland\n    HTTP/1.1 200 OK\n\n    {\n        \"state\": \"OR\"\n    }\n\n\nNotice what happens if we try to request a city that's not in our\n``CITIES_TO_STATE`` map::\n\n    $ http https://endpoint/api/cities/vancouver\n    HTTP/1.1 500 Internal Server Error\n    Content-Type: application/json\n    X-Cache: Error from cloudfront\n\n    {\n        \"Code\": \"ChaliceViewError\",\n        \"Message\": \"ChaliceViewError: An internal server error occurred.\"\n    }\n\n\nIn the next section, we'll see how to fix this and provide better\nerror messages.\n\n\nTutorial: Error Messages\n========================\n\nIn the example above, you'll notice that when our app raised\nan uncaught exception, a 500 internal server error was returned.\n\nIn this section, we're going to show how you can debug and improve\nthese error messages.\n\nThe first thing we're going to look at is how we can debug this\nissue.  By default, debugging is turned off, but you can\nenable debugging to get more information:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n    app.debug = True\n\n\nThe ``app.debug = True`` enables debugging for your app.\nSave this file and redeploy your changes::\n\n    $ chalice deploy\n    ...\n    https://endpoint/api/\n\nNow, when you request the same URL that returned an internal\nserver error, you'll get back the original stack trace::\n\n    $ http https://endpoint/api/cities/vancouver\n    Traceback (most recent call last):\n      File \"/var/task/chalice/app.py\", line 304, in _get_view_function_response\n        response = view_function(*function_args)\n      File \"/var/task/app.py\", line 18, in state_of_city\n        return {'state': CITIES_TO_STATE[city]}\n    KeyError: u'vancouver'\n\n\nWe can see that the error is caused from an uncaught ``KeyError`` resulting\nfrom trying to access the ``vancouver`` key.\n\nNow that we know the error, we can fix our code.  What we'd like to do is\ncatch this exception and instead return a more helpful error message\nto the user.  Here's the updated code:\n\n.. code-block:: python\n\n    from chalice import BadRequestError\n\n    @app.route('/cities/{city}')\n    def state_of_city(city):\n        try:\n            return {'state': CITIES_TO_STATE[city]}\n        except KeyError:\n            raise BadRequestError(\"Unknown city '%s', valid choices are: %s\" % (\n                city, ', '.join(CITIES_TO_STATE.keys())))\n\n\nSave and deploy these changes::\n\n    $ chalice deploy\n    $ http https://endpoint/api/cities/vancouver\n    HTTP/1.1 400 Bad Request\n\n    {\n        \"Code\": \"BadRequestError\",\n        \"Message\": \"Unknown city 'vancouver', valid choices are: portland, seattle\"\n    }\n\nWe can see now that we have received a ``Code`` and ``Message`` key, with the message\nbeing the value we passed to ``BadRequestError``.  Whenever you raise\na ``BadRequestError`` from your view function, the framework will return an\nHTTP status code of 400 along with a JSON body with a ``Code`` and ``Message``.\nThere are a few additional exceptions you can raise from your python code::\n\n* BadRequestError - return a status code of 400\n* UnauthorizedError - return a status code of 401\n* ForbiddenError - return a status code of 403\n* NotFoundError - return a status code of 404\n* ConflictError - return a status code of 409\n* UnprocessableEntityError - return a status code of 422\n* TooManyRequestsError - return a status code of 429\n* ChaliceViewError - return a status code of 500\n\nYou can import these directly from the ``chalice`` package:\n\n.. code-block:: python\n\n    from chalice import UnauthorizedError\n\n\nTutorial: Additional Routing\n============================\n\nSo far, our examples have only allowed GET requests.\nIt's actually possible to support additional HTTP methods.\nHere's an example of a view function that supports PUT:\n\n.. code-block:: python\n\n    @app.route('/resource/{value}', methods=['PUT'])\n    def put_test(value):\n        return {\"value\": value}\n\nWe can test this method using the ``http`` command::\n\n    $ http PUT https://endpoint/api/resource/foo\n    HTTP/1.1 200 OK\n\n    {\n        \"value\": \"foo\"\n    }\n\nNote that the ``methods`` kwarg accepts a list of methods.  Your view function\nwill be called when any of the HTTP methods you specify are used for the\nspecified resource.  For example:\n\n.. code-block:: python\n\n    @app.route('/myview', methods=['POST', 'PUT'])\n    def myview():\n        pass\n\nThe above view function will be called when either an HTTP POST or\nPUT is sent to ``/myview``.\n\nAlternatively if you do not want to share the same view function across\nmultiple HTTP methods for the same route url, you may define separate view\nfunctions to the same route url but have the view functions differ by\nHTTP method. For example:\n\n.. code-block:: python\n\n    @app.route('/myview', methods=['POST'])\n    def myview_post():\n        pass\n\n    @app.route('/myview', methods=['PUT'])\n    def myview_put():\n        pass\n\nThis setup will route all HTTP POST's to ``/myview`` to the ``myview_post()``\nview function and route all HTTP PUT's to ``/myview`` to the ``myview_put()``\nview function. It is also important to note that the view functions\n**must** have unique names. For example, both view functions cannot be\nnamed ``myview()``.\n\nIn the next section we'll go over how you can introspect the given request\nin order to differentiate between various HTTP methods.\n\n\nTutorial: Request Metadata\n==========================\n\nIn the examples above, you saw how to create a view function that supports\nan HTTP PUT request as well as a view function that supports both POST and\nPUT via the same view function.  However, there's more information we\nmight need about a given request:\n\n* In a PUT/POST, you frequently send a request body.  We need some\n  way of accessing the contents of the request body.\n* For view functions that support multiple HTTP methods, we'd like\n  to detect which HTTP method was used so we can have different\n  code paths for PUTs vs. POSTs.\n\nAll of this and more is handled by the current request object that the\n``chalice`` library makes available to each view function when it's called.\n\nLet's see an example of this.  Suppose we want to create a view function\nthat allowed you to PUT data to an object and retrieve that data\nvia a corresponding GET.  We could accomplish that with the\nfollowing view function:\n\n.. code-block:: python\n\n    from chalice import NotFoundError\n\n    OBJECTS = {\n    }\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def myobject(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            OBJECTS[key] = request.json_body\n        elif request.method == 'GET':\n            try:\n                return {key: OBJECTS[key]}\n            except KeyError:\n                raise NotFoundError(key)\n\n\nSave this in your ``app.py`` file and rerun ``chalice deploy``.\nNow, you can make a PUT request to ``/objects/your-key`` with a request\nbody, and retrieve the value of that body by making a subsequent\n``GET`` request to the same resource.  Here's an example of its usage::\n\n    # First, trying to retrieve the key will return a 404.\n    $ http GET https://endpoint/api/objects/mykey\n    HTTP/1.1 404 Not Found\n\n    {\n        \"Code\": \"NotFoundError\",\n        \"Message\": \"mykey\"\n    }\n\n    # Next, we'll create that key by sending a PUT request.\n    $ echo '{\"foo\": \"bar\"}' | http PUT https://endpoint/api/objects/mykey\n    HTTP/1.1 200 OK\n\n    null\n\n    # And now we no longer get a 404, we instead get the value we previously\n    # put.\n    $ http GET https://endpoint/api/objects/mykey\n    HTTP/1.1 200 OK\n\n    {\n        \"mykey\": {\n            \"foo\": \"bar\"\n        }\n    }\n\nYou might see a problem with storing the objects in a module level\n``OBJECTS`` variable.  We address this in the next section.\n\nThe ``app.current_request`` object also has the following properties.\n\n* ``current_request.query_params`` - A dict of the query params for the request.\n* ``current_request.headers`` - A dict of the request headers.\n* ``current_request.uri_params`` - A dict of the captured URI params.\n* ``current_request.method`` -  The HTTP method (as a string).\n* ``current_request.json_body`` - The parsed JSON body (``json.loads(raw_body)``)\n* ``current_request.raw_body`` - The raw HTTP body as bytes.\n* ``current_request.context`` - A dict of additional context information\n* ``current_request.stage_vars`` - Configuration for the API Gateway stage\n\nDon't worry about the ``context`` and ``stage_vars`` for now.  We haven't\ndiscussed those concepts yet.  The ``current_request`` object also\nhas a ``to_dict`` method, which returns all the information about the\ncurrent request as a dictionary.  Let's use this method to write a view\nfunction that returns everything it knows about the request:\n\n.. code-block:: python\n\n    @app.route('/introspect')\n    def introspect():\n        return app.current_request.to_dict()\n\n\nSave this to your ``app.py`` file and redeploy with ``chalice deploy``.\nHere's an example of hitting the ``/introspect`` URL.  Note how we're\nsending a query string as well as a custom ``X-TestHeader`` header::\n\n\n    $ http 'https://endpoint/api/introspect?query1=value1&query2=value2' 'X-TestHeader: Foo'\n    HTTP/1.1 200 OK\n\n    {\n        \"context\": {\n            \"apiId\": \"apiId\",\n            \"httpMethod\": \"GET\",\n            \"identity\": {\n                \"accessKey\": null,\n                \"accountId\": null,\n                \"apiKey\": null,\n                \"caller\": null,\n                \"cognitoAuthenticationProvider\": null,\n                \"cognitoAuthenticationType\": null,\n                \"cognitoIdentityId\": null,\n                \"cognitoIdentityPoolId\": null,\n                \"sourceIp\": \"1.1.1.1\",\n                \"userAgent\": \"HTTPie/0.9.3\",\n                \"userArn\": null\n            },\n            \"requestId\": \"request-id\",\n            \"resourceId\": \"resourceId\",\n            \"resourcePath\": \"/introspect\",\n            \"stage\": \"dev\"\n        },\n        \"headers\": {\n            \"accept\": \"*/*\",\n            ...\n            \"x-testheader\": \"Foo\"\n        },\n        \"method\": \"GET\",\n        \"query_params\": {\n            \"query1\": \"value1\",\n            \"query2\": \"value2\"\n        },\n        \"raw_body\": null,\n        \"stage_vars\": null,\n        \"uri_params\": null\n    }\n\n\nTutorial: Request Content Types\n===============================\n\nThe default behavior of a view function supports\na request body of ``application/json``.  When a request is\nmade with a ``Content-Type`` of ``application/json``, the\n``app.current_request.json_body`` attribute is automatically\nset for you.  This value is the parsed JSON body.\n\nYou can also configure a view function to support other\ncontent types.  You can do this by specifying the\n``content_types`` parameter value to your ``app.route``\nfunction.  This parameter is a list of acceptable content\ntypes.  Here's an example of this feature:\n\n.. code-block:: python\n\n    import sys\n\n    from chalice import Chalice\n    if sys.version_info[0] == 3:\n        # Python 3 imports.\n        from urllib.parse import urlparse, parse_qs\n    else:\n        # Python 2 imports.\n        from urlparse import urlparse, parse_qs\n\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/', methods=['POST'],\n               content_types=['application/x-www-form-urlencoded'])\n    def index():\n        parsed = parse_qs(app.current_request.raw_body.decode())\n        return {\n            'states': parsed.get('states', [])\n        }\n\nThere's a few things worth noting in this view function.\nFirst, we've specified that we only accept the\n``application/x-www-form-urlencoded`` content type.  If we\ntry to send a request with ``application/json``, we'll now\nget a ``415 Unsupported Media Type`` response::\n\n    $ http POST https://endpoint/api/ states=WA states=CA --debug\n    ...\n    >>> requests.request(**{'allow_redirects': False,\n     'headers': {'Accept': 'application/json',\n                 'Content-Type': 'application/json',\n    ...\n\n\n    HTTP/1.1 415 Unsupported Media Type\n\n    {\n        \"message\": \"Unsupported Media Type\"\n    }\n\nIf we use the ``--form`` argument, we can see the\nexpected behavior of this view function because ``httpie`` sets the\n``Content-Type`` header to ``application/x-www-form-urlencoded``::\n\n    $ http --form POST https://endpoint/api/formtest states=WA states=CA --debug\n    ...\n    >>> requests.request(**{'allow_redirects': False,\n     'headers': {'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',\n    ...\n\n    HTTP/1.1 200 OK\n    {\n        \"states\": [\n            \"WA\",\n            \"CA\"\n        ]\n    }\n\nThe second thing worth noting is that ``app.current_request.json_body``\n**is only available for the application/json content type.**\nIn our example above, we used ``app.current_request.raw_body`` to access\nthe raw body bytes:\n\n.. code-block:: python\n\n    parsed = parse_qs(app.current_request.raw_body)\n\n``app.current_request.json_body`` is set to ``None`` whenever the\n``Content-Type`` is not ``application/json``.  This means that\nyou will need to use ``app.current_request.raw_body`` and parse\nthe request body as needed.\n\n\nTutorial: Customizing the HTTP Response\n=======================================\n\nThe return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.\n\nChalice allows you to control this behavior by returning an instance of\na chalice specific ``Response`` class.  This behavior allows you to:\n\n* Specify the status code to return\n* Specify custom headers to add to the response\n* Specify response bodies that are not ``application/json``\n\nHere's an example of this:\n\n.. code-block:: python\n\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='custom-response')\n\n\n    @app.route('/')\n    def index():\n        return Response(body='hello world!',\n                        status_code=200,\n                        headers={'Content-Type': 'text/plain'})\n\nThis will result in a plain text response body::\n\n    $ http https://endpoint/api/\n    HTTP/1.1 200 OK\n    Content-Length: 12\n    Content-Type: text/plain\n\n    hello world!\n\n\nTutorial: GZIP compression for json\n===================================\nThe return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.\n\nChalice allows you to control this behavior by returning an instance of\na chalice specific ``Response`` class.  This behavior allows you to:\n\n* Add ``application/json`` to binary_types\n* Specify the status code to return\n* Specify custom header ``Content-Type: application/json``\n* Specify custom header ``Content-Encoding: gzip``\n\nHere's an example of this:\n\n.. code-block:: python\n\n    import json\n    import gzip\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='compress-response')\n    app.api.binary_types.append('application/json')\n\n    @app.route('/')\n    def index():\n        blob = json.dumps({'hello': 'world'}).encode('utf-8')\n        payload = gzip.compress(blob)\n        custom_headers = {\n            'Content-Type': 'application/json',\n            'Content-Encoding': 'gzip'\n        }\n        return Response(body=payload,\n                        status_code=200,\n                        headers=custom_headers)\n\n\n\nTutorial: CORS Support\n======================\n\nYou can specify whether a view supports CORS by adding the\n``cors=True`` parameter to your ``@app.route()`` call.  By\ndefault this value is false:\n\n.. code-block:: python\n\n    @app.route('/supports-cors', methods=['PUT'], cors=True)\n    def supports_cors():\n        return {}\n\n\nSettings ``cors=True`` has similar behavior to enabling CORS\nusing the AWS Console.  This includes:\n\n* Injecting the ``Access-Control-Allow-Origin: *`` header to your\n  responses, including all error responses you can return.\n* Automatically adding an ``OPTIONS`` method to support preflighting\n  requests.\n\nThe preflight request will return a response that includes:\n\n* ``Access-Control-Allow-Origin: *``\n* The ``Access-Control-Allow-Methods`` header will return a list of all HTTP\n  methods you've called out in your view function.  In the example above,\n  this will be ``PUT,OPTIONS``.\n* ``Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,\n  X-Api-Key,X-Amz-Security-Token``.\n\nIf more fine grained control of the CORS headers is desired, set the ``cors``\nparameter to an instance of ``CORSConfig`` instead of ``True``. The\n``CORSConfig`` object can be imported from from the ``chalice`` package it's\nconstructor takes the following keyword arguments that map to CORS headers:\n\n================= ==== ================================\nArgument          Type Header\n================= ==== ================================\nallow_origin      str  Access-Control-Allow-Origin\nallow_headers     list Access-Control-Allow-Headers\nexpose_headers    list Access-Control-Expose-Headers\nmax_age           int  Access-Control-Max-Age\nallow_credentials bool Access-Control-Allow-Credentials\n================= ==== ================================\n\nCode sample defining more CORS headers:\n\n.. code-block:: python\n\n    from chalice import CORSConfig\n    cors_config = CORSConfig(\n        allow_origin='https://foo.example.com',\n        allow_headers=['X-Special-Header'],\n        max_age=600,\n        expose_headers=['X-Special-Header'],\n        allow_credentials=True\n    )\n    @app.route('/custom_cors', methods=['GET'], cors=cors_config)\n    def supports_custom_cors():\n        return {'cors': True}\n\n\nThere's a couple of things to keep in mind when enabling cors for a view:\n\n* An ``OPTIONS`` method for preflighting is always injected.  Ensure that\n  you don't have ``OPTIONS`` in the ``methods=[...]`` list of your\n  view function.\n* Even though the ``Access-Control-Allow-Origin`` header can be set to a\n  string that is a space separated list of origins, this behavior does not\n  work on all clients that implement CORS. You should only supply a single\n  origin to the ``CORSConfig`` object. If you need to supply multiple origins\n  you will need to define a custom handler for it that accepts ``OPTIONS``\n  requests and matches the ``Origin`` header against a whitelist of origins.\n  If the match is successful then return just their ``Origin`` back to them\n  in the ``Access-Control-Allow-Origin`` header.\n\n  Example:\n\n.. code-block:: python\n\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='multipleorigincors')\n\n    _ALLOWED_ORIGINS = set([\n\t'http://allowed1.example.com',\n\t'http://allowed2.example.com',\n    ])\n\n\n    @app.route('/cors_multiple_origins', methods=['GET', 'OPTIONS'])\n    def supports_cors_multiple_origins():\n\tmethod = app.current_request.method\n\tif method == 'OPTIONS':\n\t    headers = {\n\t\t'Access-Control-Allow-Method': 'GET,OPTIONS',\n\t\t'Access-Control-Allow-Origin': ','.join(_ALLOWED_ORIGINS),\n\t\t'Access-Control-Allow-Headers': 'X-Some-Header',\n\t    }\n\t    origin = app.current_request.headers.get('origin', '')\n\t    if origin in _ALLOWED_ORIGINS:\n\t\theaders.update({'Access-Control-Allow-Origin': origin})\n\t    return Response(\n\t\tbody=None,\n\t\theaders=headers,\n\t    )\n\telif method == 'GET':\n\t    return 'Foo'\n\n* Every view function must explicitly enable CORS support.\n\nThe last point will change in the future.  See\n`this issue\n<https://github.com/aws/chalice/issues/70#issuecomment-248787037>`_\nfor more information.\n\n\nTutorial: Policy Generation\n===========================\n\nIn the previous section we created a basic rest API that\nallowed you to store JSON objects by sending the JSON\nin the body of an HTTP PUT request to ``/objects/{name}``.\nYou could then retrieve objects by sending a GET request to\n``/objects/{name}``.\n\nHowever, there's a problem with the code we wrote:\n\n.. code-block:: python\n\n    OBJECTS = {\n    }\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def myobject(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            OBJECTS[key] = request.json_body\n        elif request.method == 'GET':\n            try:\n                return {key: OBJECTS[key]}\n            except KeyError:\n                raise NotFoundError(key)\n\n\nWe're storing the key value pairs in a module level ``OBJECTS``\nvariable.  We can't rely on local storage like this persisting\nacross requests.\n\nA better solution would be to store this information in Amazon S3.\nTo do this, we're going to use boto3, the AWS SDK for Python.\nFirst, install boto3::\n\n    $ pip install boto3\n\nNext, add ``boto3`` to your requirements.txt file::\n\n    $ echo 'boto3==1.3.1' >> requirements.txt\n\nThe requirements.txt file should be in the same directory that contains\nyour ``app.py`` file.  Next, let's update our view code to use boto3:\n\n.. code-block:: python\n\n    import json\n    import boto3\n    from botocore.exceptions import ClientError\n\n    from chalice import NotFoundError\n\n\n    S3 = boto3.client('s3', region_name='us-west-2')\n    BUCKET = 'your-bucket-name'\n\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def s3objects(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            S3.put_object(Bucket=BUCKET, Key=key,\n                          Body=json.dumps(request.json_body))\n        elif request.method == 'GET':\n            try:\n                response = S3.get_object(Bucket=BUCKET, Key=key)\n                return json.loads(response['Body'].read())\n            except ClientError as e:\n                raise NotFoundError(key)\n\nMake sure to change ``BUCKET`` with the name of an S3 bucket\nyou own.  Redeploy your changes with ``chalice deploy``.\nNow, whenever we make a ``PUT`` request to ``/objects/keyname``, the\ndata send will be stored in S3.  Any subsequent ``GET`` requests will\nretrieve this data from S3.\n\nManually Providing Policies\n---------------------------\n\n\nIAM permissions can be auto generated, provided manually or can be\npre-created and explicitly configured. To use a\npre-configured IAM role ARN for chalice, add these two keys to your\nchalice configuration. Setting manage_iam_role to false tells\nChalice to not attempt to generate policies and create IAM role.\n\n::\n\n    \"manage_iam_role\":false\n    \"iam_role_arn\":\"arn:aws:iam::<account-id>:role/<role-name>\"\n\nWhenever your application is deployed using ``chalice``, the\nauto generated policy is written to disk at\n``<projectdir>/.chalice/policy.json``.  When you run the\n``chalice deploy`` command, you can also specify the\n``--no-autogen-policy`` option.  Doing so will result in the\n``chalice`` CLI loading the ``<projectdir>/.chalice/policy.json``\nfile and using that file as the policy for the IAM role.\nYou can manually edit this file and specify ``--no-autogen-policy``\nif you'd like to have full control over what IAM policy to associate\nwith the IAM role.\n\nYou can also run the ``chalice gen-policy`` command from your project\ndirectory to print the auto generated policy to stdout.  You can\nthen use this as a starting point for your policy.\n\n::\n\n    $ chalice gen-policy\n    {\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n        {\n          \"Action\": [\n            \"s3:ListAllMyBuckets\"\n          ],\n          \"Resource\": [\n            \"*\"\n          ],\n          \"Effect\": \"Allow\",\n          \"Sid\": \"9155de6ad1d74e4c8b1448255770e60c\"\n        }\n      ]\n    }\n\nExperimental Status\n-------------------\n\nThe automatic policy generation is still in the early stages, it should\nbe considered experimental.  You can always disable policy\ngeneration with ``--no-autogen-policy`` for complete control.\n\nAdditionally, you will be prompted for confirmation whenever the\nauto policy generator detects actions that it would like to add or remove::\n\n\n    $ chalice deploy\n    Updating IAM policy.\n\n    The following action will be added to the execution policy:\n\n    s3:ListBucket\n\n    Would you like to continue?  [Y/n]:\n\n\nTutorial: Using Custom Authentication\n=====================================\n\nAWS API Gateway routes can be authenticated in multiple ways:\n\n- API Key\n- AWS IAM\n- Cognito User Pools\n- Custom Auth Handler\n\nAPI Key\n-------\n\n.. code-block:: python\n\n    @app.route('/authenticated', methods=['GET'], api_key_required=True)\n    def authenticated():\n        return {\"secure\": True}\n\nOnly requests sent with a valid `X-Api-Key` header will be accepted.\n\nUsing AWS IAM\n-------------\n\n.. code-block:: python\n\n    authorizer = IAMAuthorizer()\n\n    @app.route('/iam-role', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nUsing Amazon Cognito User Pools\n-------------------------------\n\nTo integrate with cognito user pools, you can use the\n``CognitoUserPoolAuthorizer`` object:\n\n.. code-block:: python\n\n    authorizer = CognitoUserPoolAuthorizer(\n        'MyPool', header='Authorization',\n        provider_arns=['arn:aws:cognito:...:userpool/name'])\n\n    @app.route('/user-pools', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nNote, earlier versions of chalice also have an ``app.define_authorizer``\nmethod as well as an ``authorizer_name`` argument on the ``@app.route(...)``\nmethod.  This approach is deprecated in favor of ``CognitoUserPoolAuthorizer``\nand the ``authorizer`` argument in the ``@app.route(...)`` method.\n``app.define_authorizer`` will be removed in future versions of chalice.\n\n\nUsing Custom Authorizers\n------------------------\n\nTo integrate with custom authorizers, you can use the ``CustomAuthorizer`` method\non the ``app`` object.  You'll need to set the ``authorizer_uri``\nto the URI of your lambda function.\n\n.. code-block:: python\n\n    authorizer = CustomAuthorizer(\n        'MyCustomAuth', header='Authorization',\n        authorizer_uri=('arn:aws:apigateway:region:lambda:path/2015-03-31'\n                        '/functions/arn:aws:lambda:region:account-id:'\n                        'function:FunctionName/invocations'))\n\n    @app.route('/custom-auth', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nTutorial: Local Mode\n====================\n\nAs you develop your application, you may want to experiment locally  before\ndeploying your changes.  You can use ``chalice local`` to spin up a local\nHTTP server you can use for testing.\n\nFor example, if we have the following ``app.py`` file:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n\nWe can run ``chalice local`` to test this API locally:\n\n\n    $ chalice local\n    Serving on localhost:8000\n\nWe can override the port using:\n\n    $ chalice local --port=8080\n\nWe can now test our API using ``localhost:8000``::\n\n    $ http localhost:8000/\n    HTTP/1.0 200 OK\n    Content-Length: 18\n    Content-Type: application/json\n    Date: Thu, 27 Oct 2016 20:08:43 GMT\n    Server: BaseHTTP/0.3 Python/2.7.11\n\n    {\n        \"hello\": \"world\"\n    }\n\n\nThe ``chalice local`` command *does not* assume the\nrole associated with your lambda function, so you'll\nneed to use an ``AWS_PROFILE`` that has sufficient permissions\nto your AWS resources used in your ``app.py``.\n\n\nDeleting Your App\n=================\n\nYou can use the ``chalice delete`` command to delete your app.\nSimilar to the ``chalice deploy`` command, you can specify which\nchalice stage to delete.  By default it will delete the ``dev`` stage::\n\n    $ chalice delete --stage dev\n    Deleting Rest API: duvw4kwyl3\n    Deleting function aws:arn:lambda:region:123456789:helloworld-dev\n    Deleting IAM Role helloworld-dev\n\n.. quick-start-end\n\nFeedback\n========\n\nWe'also love to hear from you.  Please create any Github issues for\nadditional features you'd like to see over at\nhttps://github.com/aws/chalice/issues.  You can also chat with us\non gitter: https://gitter.im/awslabs/chalice\n\n\nFAQ\n===\n\n\n**Q: How does the Python Serverless Microframework for AWS compare to other\nsimilar frameworks?**\n\nThe biggest difference between this framework and others is that the Python\nServerless Microframework for AWS is singularly focused on using a familiar,\ndecorator-based API to write python applications that run on Amazon API Gateway\nand AWS Lambda.  You can think of it as\n`Flask <http://flask.pocoo.org/>`__/`Bottle <http://bottlepy.org/docs/dev/index.html>`__\nfor serverless APIs.  Its goal is to make writing and deploying these types of\napplications as simple as possible specifically for Python developers.\n\nTo achieve this goal, it has to make certain tradeoffs.  Python will always\nremain the only supported language in this framework.  Not every feature of API\nGateway and Lambda is exposed in the framework.  It makes assumptions about how\napplications will be deployed, and it has restrictions on how an application\ncan be structured.  It does not address the creation and lifecycle of other AWS\nresources your application may need (Amazon S3 buckets, Amazon DynamoDB tables,\netc.).  The feature set is purposefully small.\n\nOther full-stack frameworks offer a lot more features and configurability than\nwhat this framework has and likely will ever have.  Those frameworks are\nexcellent choices for applications that need more than what is offered by this\nmicroframework.  If all you need is to create a simple rest API in Python that\nruns on Amazon API Gateway and AWS Lambda, consider giving the Python\nServerless Microframework for AWS a try.\n\nRelated Projects\n----------------\n\n* `serverless <https://github.com/serverless/serverless>`__ - Build applications\n  comprised of microservices that run in response to events, auto-scale for\n  you, and only charge you when they run.\n* `Zappa <https://github.com/Miserlou/Zappa>`__ - Deploy python WSGI applications\n  on AWS Lambda and API Gateway.\n* `claudia <https://github.com/claudiajs/claudia>`__ - Deploy node.js projects\n  to AWS Lambda and API Gateway.\n* `Domovoi <https://github.com/kislyuk/domovoi>`_ - An extension to Chalice that\n  handles a variety of AWS Lambda event sources such as SNS push notifications,\n  S3 events, and Step Functions state machines.",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/aws/chalice",
    "keywords": "chalice,parfait,aws,lambda,amazon web services",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "parfait",
    "package_url": "https://pypi.org/project/parfait/",
    "platform": "",
    "project_url": "https://pypi.org/project/parfait/",
    "project_urls": {
      "Homepage": "https://github.com/aws/chalice"
    },
    "release_url": "https://pypi.org/project/parfait/0.3/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Microframework",
    "version": "0.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5438085,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "02ba7392f0674fb012da9a52595d3b599f1f15c4e41795bdfe014eeba6dde211",
          "md5": "2e1bda0cd62288dbe51196ee1305139f",
          "sha256": "a8607e322679d806ca29690d1c1abdf90fd5126ab408f712316de56331215748"
        },
        "downloads": -1,
        "filename": "parfait-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2e1bda0cd62288dbe51196ee1305139f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 199454,
        "upload_time": "2019-01-06T04:36:08",
        "upload_time_iso_8601": "2019-01-06T04:36:08.476729Z",
        "url": "https://files.pythonhosted.org/packages/02/ba/7392f0674fb012da9a52595d3b599f1f15c4e41795bdfe014eeba6dde211/parfait-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1a273703f27f7d64ca070b4d15ce092e2feb62adc24be9927d9ad70a55982213",
          "md5": "5bac6776e14040b4e0874926ad762e59",
          "sha256": "5259fe0c0d909e80a5ccd304eb242e49b8d61a2d44756bcb2fd23f16c2a6296f"
        },
        "downloads": -1,
        "filename": "parfait-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "5bac6776e14040b4e0874926ad762e59",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 200399,
        "upload_time": "2019-01-08T07:19:52",
        "upload_time_iso_8601": "2019-01-08T07:19:52.475314Z",
        "url": "https://files.pythonhosted.org/packages/1a/27/3703f27f7d64ca070b4d15ce092e2feb62adc24be9927d9ad70a55982213/parfait-0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3d391b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997",
          "md5": "afb29ad43fdebc396b675f7f7b544bd2",
          "sha256": "de6facf3fd0fbd46e6e785b7868f8f9ce6c26d6b691371d7d9192d0252be3d3c"
        },
        "downloads": -1,
        "filename": "parfait-0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "afb29ad43fdebc396b675f7f7b544bd2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 200012,
        "upload_time": "2019-04-09T12:14:56",
        "upload_time_iso_8601": "2019-04-09T12:14:56.912035Z",
        "url": "https://files.pythonhosted.org/packages/3d/39/1b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997/parfait-0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3d391b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997",
        "md5": "afb29ad43fdebc396b675f7f7b544bd2",
        "sha256": "de6facf3fd0fbd46e6e785b7868f8f9ce6c26d6b691371d7d9192d0252be3d3c"
      },
      "downloads": -1,
      "filename": "parfait-0.3.tar.gz",
      "has_sig": false,
      "md5_digest": "afb29ad43fdebc396b675f7f7b544bd2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 200012,
      "upload_time": "2019-04-09T12:14:56",
      "upload_time_iso_8601": "2019-04-09T12:14:56.912035Z",
      "url": "https://files.pythonhosted.org/packages/3d/39/1b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997/parfait-0.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}