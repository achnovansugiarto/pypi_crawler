{
  "info": {
    "author": "",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# Librería Python para ETLs\n\nEsta librería tiene funciones comunes que pueden ser útiles para uso en las ETLs.\n\nPágina de la libreria en PyPI:https://pypi.org/project/tc-etl-lib/\n\n## Empaquetado de la librería\n\nLa librería permite versionado y se puede acceder a las diferentes versiones en `dist`. En ese directorio se van acumulando el empaquetado de cada versión de la librería.\n\nPara empaquetar se procede de la siguiente manera:\n\n* En el fichero de configuración [setup.py](./setup.py) hay una variable `VERSION` que indica la versión. Se debe incrementar esta versión al empaquetar.\n* Se puede empaquetar la librería en diferentes formatos, dependiendo del sistema operativo desde que se ejecuta, puede ser zip, tar.gz, etc.. Por defecto en linux, si no le indicas un formato concreto, usará el .tar.gz. El empaquetado, creará un archivo en la carpeta /dist/ del tipo  `tc_etl_lib-<version>.tar.gz`, que se puede utilizar en los proyectos que sea necesario. Se empaqueta mediante el siguiente comando:\n\n        python3 setup.py sdist bdist_wheel\n\n* Una vez generada la librería, se puede utilizar desde cualquier proyecto instalándola mediante `pip`\n\n## Subida de la libreria a repositorio público de pip\n\nUna vez construido el paquete de la librería según el procedimiento descrito en la sección anterior, se puede realizar\nsu subida al repositorio público de pip.\n\nEn primer lugar, instalar la herramienta twine si no se dispone previamente de ella:\n\n        pip install twine\n\nPara subir la libreria al repositorio público de pip ejecutar el comando:\n\n        twine upload dist/tc_etl_lib-x.y.z.tar.gz\n\nEs necesario estar registrado previamente en https://pypi.org y con permisos en https://pypi.org/project/tc-etl-lib/, \nya que se solicitará el usuario y password para realizar la subida.\n\n## Instalación de la librería\n\nExisten distintas alternativas\n\n### Desde el repositorio público de pip (recomendada)\n\nPara instalar la última versión:\n\n        pip install tc_etl_lib\n\nPara instalar una versión concreta:\n\n        pip install tc_etl_lib==0.1.0\n\nTambién se puede añadir la depedencia a `requirements.txt`:\n\n        tc_etl_lib==0.7.0\n\nhe instalar (junto con el resto de depedencias) con el habitual:\n\n        pip install -r requirements.txt\n\n### Con el paquete .tar.gz\n\nLa librería de tipo `tc_etl_lib-<version>.tar.gz`, se puede instalar en cualquier entorno python con el siguiente comando:\n\n    pip install ./tc_etl_lib/dist/tc_etl_lib-0.1.0.tar.gz\n\nEn este caso, la librería está disponible en ese directorio. Si estuviera disponible en cualquier otra ruta, se debería de reemplazar por la ruta relativa o absoluta correspondiente. Si se quiere instalar sobre un entorno venv, primero has de activar el entorno venv y luego ejecutar el comando de instalación de la librería.\n\nPueden obtenerlse los .tar.gz correspondientes a cada versión de la libreria en [este enlace](https://github.com/telefonicasc/etl-framework/releases).\n\n### Desde el repositorio git\n\nLa librería se puede instalar usando el repositorio remoto de github, para ello se ha de añadir la siguiente linea en el fichero requirements.txt.\n\nPara instalar una versión concreta\n\n```\ntc_etl_lib @ git+https://github.com/telefonicasc/etl-framework@{tag_version}#package=tc_etl_lib&subdirectory=python-lib/tc_etl_lib\n```\n\nDonde:\n\n    {tag_version} : Acceso a una versión concreta de la librería.\n\nPara instalar la última versión\n\n```\ntc_etl_lib @ git+https://github.com/telefonicasc/etl-framework#package=tc_etl_lib&subdirectory=python-lib/tc_etl_lib\n```\n\nUna vez añadida esa referencia en requeriments.txt, se puede instalar con el comando:\n\n    pip install -r requirements.txt\n\n## Uso de la librería\n\nEl uso de la librería una vez se ha instalado en el venv, es similar al resto de librerías que dispondrías en python. A continuación mostramos un ejemplo de referencia:\n\n```python    \n# import library\nimport tc_etl_lib as tc\nimport json\n\n# create a auth manager and use it\nauth: tc.auth.authManager = tc.auth.authManager(endpoint='http://<auth_endpoint>:<port>', \n                                                service = 'alcobendas', \n                                                user = 'usuario_alcobendas', \n                                                password = 'xxx')\n\nauth.get_auth_token_subservice(subservice = '/energia')\n\n# create a cb manager and use it\ncbm: tc.cb.cbManager = tc.cb.cbManager(endpoint = 'http://<cb_endpoint>:<port>')\nentities = cbm.get_entities_page(subservice='/energia', auth=auth, type='myType')\n\n# have a look to the retrieved entities\nprint (json.dumps(entities))\n```\n\nEjemplo de uso de Recogida de todos los datos de tipo SupplyPoint con y sin paginación:\n\n```python\n# import library\nimport tc_etl_lib as tc\n\n# declare authManager\nauth: tc.auth.authManager = tc.auth.authManager(endpoint='http://<auth_endpoint>:<port>', \n                                                service = 'alcobendas', \n                                                subservice = '/energia',\n                                                user = 'usuario_alcobendas', \n                                                password = 'xxx')\n# get token\ntry:\n    token = auth.get_auth_token_subservice()\n    logger.info(f'token: {token}')\nexcept Exception as err:\n    logger.error('get_auth_token_subservice problems!!')\n    logger.error(err)\n\n# get all SupplyPoint entities with pg\ncbm: tc.cb.cbManager = tc.cb.cbManager(endpoint = 'http://<cb_endpoint>:<port>')\n\npg = 1\nlimit = 5\nentities = None\nwhile entities != []:\n    entities = cbm.get_entities_page(auth = auth, offset = (pg-1)*limit, limit = limit, type='SupplyPoint')\n    for i, item in enumerate(entities):\n        logger.info(f'(pg:{pg})[{i + (pg-1)*limit}]--> {item[\"id\"]} ({item[\"type\"]})')\n    pg += 1\n\n# get all SupplyPoint entities without pg\nentities = cbm.get_entities(auth = auth, type='SupplyPoint')\nfor i, item in enumerate(entities):\n    logger.info(f'[{i}]--> {item[\"id\"]} ({item[\"type\"]})')\n\n```\n\nEjemplo de Envío de datos en ráfaga\n\n```python\n# import library\nimport tc_etl_lib as tc\n\n# declare authManager\nauth: tc.auth.authManager = tc.auth.authManager(endpoint='http://<auth_endpoint>:<port>', \n                                                service = 'alcobendas', \n                                                subservice = '/energia',\n                                                user = 'usuario_alcobendas', \n                                                password = 'xxx')\n\n# get token\ntry:\n    auth.get_auth_token_subservice()\nexcept Exception as err:\n    logger.error('get_auth_token_subservice problems!!')\n    logger.error(err)\n\n# send entities\ncbm: tc.cb.cbManager = tc.cb.cbManager(endpoint = 'http://<cb_endpoint>:<port>')\n\nentities = [\n            {\n                \"id\": \"myEntity1\",\n                \"type\": \"myType\",\n                \"description\": {\n                    \"value\": \"My first happy entity\",\n                    \"type\": \"Text\"\n                },\n                \"online\": {\n                    \"value\": 'true',\n                    \"type\": \"Boolean\"\n                },\n                \"temperature\": {\n                    \"value\": '42.3',\n                    \"type\": \"Number\"\n                }\n            },\n            {\n                \"id\": \"myEntity2\",\n                \"type\": \"myType\",\n                \"description\": {\n                    \"value\": \"My second happy entity\",\n                    \"type\": \"Text\"\n                },\n                \"online\": {\n                    \"value\": 'false',\n                    \"type\": \"Boolean\"\n                },\n                \"temperature\": {\n                    \"value\": '12.3',\n                    \"type\": \"Number\"\n                }\n            }\n\t    ]\n \ncbm.send_batch(auth=auth, subservice='/energia', entities=entities)\n\n# O, usando un store orion\nwith tc.orionStore(cb=cbm, auth=auth, subservice='/energia') as store:\n    store(entities)\n\n# O un store sqlFile\nwith tc.sqlFileStore(path=\"inserts.sql\", subservice=\"/energia\", namespace=\"energy\") as store:\n    store(entities)\n```\n\n## Funciones disponibles en la librería\n\nLa librería está creada con diferentes clases dependiendo de la funcionalidad deseada.\n\n- Clase `authManager`: En esta clase están las funciones relacionadas con la Autenticación (IDM).\n    - `__init()__`: constructor de objetos de la clase\n        - :param obligatorio `endpoint`: define el endpoint de identificación (ejemplo: https://`<service>`:`<port>`). Se debe especificar en el constructor del objeto de tipo authManager, sino avisará con una excepción ValueError.\n        - :param obligatorio `user`: define el usuario para identificarse. Se debe especificar en el constructor del objeto de tipo authManager, sino avisará con una excepción ValueError.\n        - :param obligatorio `password`: define la contraseña para identificarse. Se debe especificar en el constructor del objeto de tipo authManager, sino avisará con una excepción ValueError.\n        - :param obligatorio `service`: define el servicio donde identificarse. Se debe especificar en el constructor del objeto del tipo authManager, sino avisará con una excepción ValueError.\n        - :param opcional `subservice`: define el subservicio donde identificarse. Se puede especificar en el constructor o a posteriori cuando se llamen a las funciones del cbManager.\n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta alguno de los argumentos obligatorios\n    - `get_auth_token_subservice`: Realiza una petición de token al IDM, identificándose con los creenciales de usuario\n      contraseña, servicio y subservicio. El token obtenido se almacena internamente en un caché dentro del propio objeto, de forma\n      que otras funciones de la librería que hagan uso del authManager (pe. las del cbManager) intentará utilizar siempre primero\n      este caché antes que solicitar un nuevo token via API del IDM.\n        - :param opcional `subservice`: se define el subservicio al que identificarse. Este parámetro es opcional. Si no se le indica, cogerá el subservicio inicializado en el objeto de tipo authManager que esté llamando la función. Si no está inicializado en el objeto ni se pasa por parámetro, se lanzará un ValueError.\n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna variable del objeto authManager, para poder realizar la autenticación.\n        - :raises [Exception](https://docs.python.org/3/library/exceptions.html#Exception): Se lanza cuando el servicio de identificación, responde con un error concreto.\n        - :return: El token que te asigna el servicio de identificación, a parte internamente authManager almacena en caché el token que ha recibido de la autenticación para cada servicio, por si lo necesita a postetiori para realizar acciones con ese token.\n    - `get_auth_token_service`: Realiza una petición de token al IDM, identificándose con los creenciales de usuario, contraseña y servicio (obtiene un token de scope **domain**). El token obtenido es un token *privilegiado* que puede usarse para gestión del propio dominio (creación de subservicios, asignación de roles, etc), siempre que el usuario tenga el rol de administrador de dominio. Este token **no se almacena en caché interna**.\n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna variable del objeto authManager, para poder realizar la autenticación.\n        - :raises [Exception](https://docs.python.org/3/library/exceptions.html#Exception): Se lanza cuando el servicio de identificación, responde con un error concreto.\n        - :return: un objeto con tres propiedades: { `token`: ..., `user_id`: ..., `domain_id`: ... }. Como este token se usará principalmente para administración del dominio, es útil obtener los IDs de usuario y dominio asociados.\n    - `set_token`: Establece el token de subservicio en el caché del objeto. En el caso de que ya hubiera un token asociado al subservicio (pe. porque se haya invocado previamente `get_auth_token_subservice`) se sobreescribe. Esta función es útil cuando el token se obtiene por otros mecanismos ajenos a la negociación con el IDM (pe. de una cabecera `x-auth-token`) y se quiere establecer dentro del authManager. Otras funciones de la librería que hagan uso del authManager (pe. las del cbManager) intentará utilizar siempre primero este caché antes que solicitar un nuevo token via API del IDM.\n        - :param `subservice`: subservicio en el que establecer el tokenn.\n        - :param `token`: token a establecer.\n- Clase `cbManager`: En esta clase están funciones para la interacción con el Context Broker.\n   - `__init()__`: constructor de objetos de la clase\n        - :param obligatorio `endpoint`: define el endpoint del context broker (ejemplo: https://`<service>`:`<port>`). Se debe especificar en el constructor del objeto de tipo cbManager, sino avisará con una excepción ValueError.\n        - :param opcional `timeout`: timeout definido en segundos (default: 10).\n        - :param opcional `post_retry_connect`: Número de reintentos a la hora de realizar un envío de datos (default: 3)\n        - :param opcional `post_retry_backoff_factor`: Factor que se usa, para esperar varios segundos tras enviar una ráfaga de datos. (default: 0)\n        - :param opcional `sleep_send_batch`: Pausa en segundos, que se realiza cada vez que se envia una ráfaga de datos. (default: 0). \n        - :param opcional `cb_flowcontrol`: Opción del Context Broker, que permite un mejor rendimiento en caso de envío masivo de datos (batch updates). Este mecanismo, requiere arrancar el Context Broker con un flag concreto y en las peticiones de envío de datos, añadir esa opción. Referencia en [documentación de Orion](https://fiware-orion.readthedocs.io/en/master/admin/perf_tuning/index.html#updates-flow-control-mechanism) (default: False)\n        - :param opcional `block_size`: Cuando se realiza el envío de datos al Context Broker mediante la función de `send_batch`, se realiza envíos en tramos que no excedan el block_size indicado (default: 800000). Se permite modificar el valor de block_size, pero sin superar la limitación de 800000. En caso de indicar un valor que supere ese límite, se lanzará una excepción ValueError indicando que se ha excedido el límite del valor permitido.\n        - :param opcional `batch_size`: Si este parámetro es mayor que 0, cuando se realiza el envío de datos al Context Broker mediante la función de `send_batch`, se realizan envíos en tramos que no excedan el número de entidades indicado (default: 0 - no aplica). En el caso de ser mayor que 0, tanto `block_size` como `batch_size` aplican a la hora de dividir un envío en tramos.\n        \n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta alguno de los argumentos obligatorios\n    - `send_batch`: Función que envía un lote de entidades al Context Broker aplicándoles una acción `actionType` que por defecto es `append`. Se le pasa el authManager, que ya dispone de un listado con todos los tokens por subservicio y usa el correspondiente para realizar la llamada al Context Broker. Si no se dispone de token o ha caducado, se solicita nuevo y luego envía los datos.\n        - :param opcional `auth`: Se le proporciona el authManager, que tiene las credenciales por si ha de solicitar un token y dispone del listado de tokens asociado. Si no se define en la llamada a la función, se asume que no hay IDM asociado al CB y se realizará las operación sin el uso de autenticación.\n        - :param obligatorio `entities`: Listado de entidades a enviar, Si no se define en la llamada a la función, avisará con una excepción ValueError.\n        - :param opcional `service`: Se puede indicar al servicio al que se le quiere enviar los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el servicio.\n        - :param opcional `subservice`: Se puede indicar al subservicio al que se le quiere enviar los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el subservicio.\n        - :param opcional `actionType`: El tipo de acción que se le va aplicar al batch que se envía al Context Broker. Por defecto es `append`. Referencia en [API NGSIv2 de Orion](http://telefonicaid.github.io/fiware-orion/api/v2/stable/)\n        - :param opcional `options`: Lista de opciones separadas que recibe el Context Broker y que permite cierto comportamiento. Se pueden ver las opciones disponibles en [API NGSIv2 de Orion](https://github.com/telefonicaid/fiware-orion/blob/master/doc/manuals/orion-api.md#update-post-v2opupdate). En el caso de que la opcion `flowControl` se especifique dentro de este parámetro, un `cb_flowcontrol` (en la inicializción de cbManager) a `False` se ignora, quedanco como si `cb_flowcontrol` se hubiese establecido a `True`.\n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna varibale del objeto cbManager, para poder realizar la autenticación o envío de datos.\n        - :raises [Exception](https://docs.python.org/3/library/exceptions.html#Exception): Se lanza cuando el servicio de Context Broker, responde con un error concreto.\n        - :return: True si la operación es correcta (i.e. el CB devolió un code http 204).\n    - `get_entities_page`: Función que recoge datos del Context Broker. Se le pasa el authManager, que ya dispone de un listado con todos los tokens por subservicio y usa el correspondiente para realizar la llamada al Context Broker. Si no se dispone de token o ha caducado, se solicita nuevo y luego recoge los datos.\n        - :param opcional `auth`: Se le proporciona el authManager, que tiene las credenciales por si ha de solicitar un token y dispone del listado de tokens asociado. Si no se define en la llamada a la función, se asume que no hay IDM asociado al CB y se realizará las operación sin el uso de autenticación.\n        - :param opcional `service`: Se puede indicar al subservicio del que recoge los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el servicio.\n        - :param opcional `subservice`: Se puede indicar al subservicio del que se recoge los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el subservicio.\n        - :param opcional `offset`: Se establece el offset cuando se recogen los datos. Si no se especifica, enviará la petición al Context Broker sin offset definido. Por lo tanto se aplicará el valor offset por defecto que tiene el Context Broker que es 0.\n        - :param opcional `limit`: Se establece un límite de recogida de datos. Si no se especifica, enviará la petición al Context Broker sin el limit definido, por lo tanto se aplirá el valor de limit por defecto que tiene el Context Broker, que es 20.\n        - :param opcional `type`: Se establece la recogida de un tipo de datos. Si no se especifica, enviará la petición al Context Broker sin el type definido, por lo tanto los datos no serán filtrados por el tipo de entidad.\n        - :param opcional `orderBy`: Se establece un orden en la recogida de datos. Si no se especifica, enviará la petición al Context Broker sin el orderBy definido, por lo tanto aplicará el orden por defecto en el Context Broker (i.e. orden de fecha de creación de la entidades)\n        - :param opcional `q`: Se establece un filtro de datos en función del valor de los atributos especificados. Si no se especifica, enviará la petición al Context Broker sin el q definido, por lo tanto los datos no serán filtrados por estos atributos.\n        - :param opcional `mq`: Se establece un filtro de datos en función de los metadatos definidos en este parámetro. Si no se especifica, enviará la petición al Context Broker sin el mq definido, por lo tanto los datos no serán filtrados por los metadatos.\n        - :param opcional `georel`: Cuando se define un filtro de datos por geolocalización, se ha de especificar en georel la relación espacial que se va a utilizar en el filtrado. Se pueden consultar los diferentes valores de georel en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `geometry`: Cuando se define un filtro de datos por geolocalización, se ha de especificar un tipo de dibujo que se utiliza para resolver el filtrado. Se pueden consultar los diferentes valores de geometry en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `coords`: Cuando se define un filtro de datos por geolocalización, se ha de especificar una lista de coordenadas geograficas separadas por coma. Se pueden consultar los diferentes valores de coords en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `id`: Se establece un filtro por Identificador. Si no se especifica, enviará la petición al Context Broker sin el id definido, por lo tanto los datos no serán filtrados por identificador.\n        - :param opcional `options`: Lista de opciones que recibe el Context Broker y que permite cierto comportamiento. Se pueden ver las opciones disponibles en [API NGSIv2 de Orion](https://github.com/telefonicaid/fiware-orion/blob/master/doc/manuals/orion-api.md#list-entities-get-v2entities)  \n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna varibale del objeto cbManager, para poder realizar la autenticación o envío de datos.\n        - :raises FetchError: Se lanza cuando el servicio de Context Broker, responde con un error concreto.\n        - :return: array de datos cuyos elementos son objeto que representan entidades, según el formato descrito en la sección\n          \"JSON Entity Representation\" de la [NGSIv2 API](https://fiware.github.io/specifications/ngsiv2/stable/)\n    - `get_entities`: Función que recoge datos del Context Broker. Se le pasa el authManager, que ya dispone de un listado con todos los tokens por subservicio y usa el correspondiente para realizar la llamada al Context Broker. Si no se dispone de token o ha caducado, se solicita nuevo y luego recoge los datos. Esta función con diferencia a `get_entities_page` usa un mecanismo de paginación interna para retornar todas las entidades que concuerden con los filtros definidos, para ello va realizando solicitudes necesarias al Context Broker para recoger todos los datos en tramos y retornarlos acumulados en un array.\n        - :param opcional `auth`: Se le proporciona el authManager, que tiene las credenciales por si ha de solicitar un token y dispone del listado de tokens asociado. Si no se define en la llamada a la función, se asume que no hay IDM asociado al CB y se realizará las operación sin el uso de autenticación.\n        - :param opcional `service`: Se puede indicar al servicio del que se recoge los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el servicio.\n        - :param opcional `subservice`: Se puede indicar al subservicio al que se le quiere enviar los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el subservicio.\n        - :param opcional `limit`: Se establece un límite de recogida de datos en cada tramo. Internamente se usa un mecanismo de paginación y se van solicitando al context broker los datos en tramos. Si no se especifica, enviará la petición al Context Broker sin el limit definido, por lo tanto se aplirá el valor de limit por defecto, tiene un valor de 100.\n        - :param opcional `type`: Se establece la recogida de un tipo de datos. Si no se especifica, enviará la petición al Context Broker sin el type definido, por lo tanto los datos no serán filtrados por el tipo de entidad.\n        - :param opcional `orderBy`: Se establece un orden en la recogida de datos. Si no se especifica, enviará la petición al Context Broker sin el orderBy definido, por lo tanto aplicará el orden por defecto en el Context Broker (i.e. orden de fecha de creación de la entidades)\n        - :param opcional `q`: Se establece un filtro de datos en función del valor de los atributos especificados. Si no se especifica, enviará la petición al Context Broker sin el q definido, por lo tanto los datos no serán filtrados por estos atributos.\n        - :param opcional `mq`: Se establece un filtro de datos en función de los metadatos definidos en este parámetro. Si no se especifica, enviará la petición al Context Broker sin el mq definido, por lo tanto los datos no serán filtrados por los metadatos.\n        - :param opcional `georel`: Cuando se define un filtro de datos por geolocalización, se ha de especificar en georel la relación espacial que se va a utilizar en el filtrado. Se pueden consultar los diferentes valores de georel en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `geometry`: Cuando se define un filtro de datos por geolocalización, se ha de especificar un tipo de dibujo que se utiliza para resolver el filtrado. Se pueden consultar los diferentes valores de geometry en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `coords`: Cuando se define un filtro de datos por geolocalización, se ha de especificar una lista de coordenadas geograficas separadas por coma. Se pueden consultar los diferentes valores de coords en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `id`: Se establece un filtro por Identificador. Si no se especifica, enviará la petición al Context Broker sin el id definido, por lo tanto los datos no serán filtrados por identificador.\n        - :param opcional `options`: Lista de opciones que recibe el Context Broker. Se pueden ver las opciones disponibles en [API NGSIv2 de Orion](https://github.com/telefonicaid/fiware-orion/blob/master/doc/manuals/orion-api.md#list-entities-get-v2entities)  \n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna varibale del objeto cbManager, para poder realizar la autenticación o envío de datos.\n        - :raises FetchError: Se lanza cuando el servicio de Context Broker, responde con un error concreto.\n        - :return: array de datos cuyos elementos son objeto que representan entidades, según el formato descrito en la sección\n          \"JSON Entity Representation\" de la [NGSIv2 API](https://fiware.github.io/specifications/ngsiv2/stable/)\n    - `delete_entities`: Función que borra entidades del Context Broker. Se le pasa el authManager, que ya dispone de un listado con todos los tokens por subservicio y usa el correspondiente para realizar la llamada al Context Broker. Si no se dispone de token o ha caducado, se solicita nuevo y luego recoge los datos. Esta función busca en el Context Broker todas las entidades que coincidan con el filtrado que se pasa por parámetro y tras recoger las entidades, se genera un batch update de tipo `delete` por id y tipo de entidad de cada una de las entidades.\n        - :param opcional `auth`: Se le proporciona el authManager, que tiene las credenciales por si ha de solicitar un token y dispone del listado de tokens asociado. Si no se define en la llamada a la función, se asume que no hay IDM asociado al CB y se realizará las operación sin el uso de autenticación.\n        - :param opcional `service`: Se puede indicar al servicio del que se eliminan los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el servicio.\n        - :param opcional `subservice`: Se puede indicar al subservicio del que se eliminan los datos. Sino se indica, usará el que haya inicializado en el objeto authManager. Sino dispone ninguno de los dos definidos, lanzará un ValueError indicando que necesita definirse el subservicio.\n        - :param opcional `limit`: Se establece un límite de recogida de datos en cada tramo. Internamente se usa un mecanismo de paginación y se van solicitando al context broker los datos en tramos. Si no se especifica, enviará la petición al Context Broker sin el limit definido, por lo tanto se aplirá el valor de limit por defecto, tiene un valor de 100.\n        - :param opcional `type`: Se establece la recogida de un tipo de datos. Si no se especifica, enviará la petición al Context Broker sin el type definido, por lo tanto los datos no serán filtrados por el tipo de entidad.\n        - :param opcional `q`: Se establece un filtro de datos en función del valor de los atributos especificados. Si no se especifica, enviará la petición al Context Broker sin el q definido, por lo tanto los datos no serán filtrados por estos atributos.\n        - :param opcional `mq`: Se establece un filtro de datos en función de los metadatos definidos en este parámetro. Si no se especifica, enviará la petición al Context Broker sin el mq definido, por lo tanto los datos no serán filtrados por los metadatos.\n        - :param opcional `georel`: Cuando se define un filtro de datos por geolocalización, se ha de especificar en georel la relación espacial que se va a utilizar en el filtrado. Se pueden consultar los diferentes valores de georel en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `geometry`: Cuando se define un filtro de datos por geolocalización, se ha de especificar un tipo de dibujo que se utiliza para resolver el filtrado. Se pueden consultar los diferentes valores de geometry en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `coords`: Cuando se define un filtro de datos por geolocalización, se ha de especificar una lista de coordenadas geograficas separadas por coma. Se pueden consultar los diferentes valores de coords en [NGSIv2 API](http://telefonicaid.github.io/fiware-orion/api/v2/stable)\n        - :param opcional `id`: Se establece un filtro por Identificador. Si no se especifica, enviará la petición al Context Broker sin el id definido, por lo tanto los datos no serán filtrados por identificador.\n        - :param opcional `options_get`: Cadena de opciones separadas por coma, que recibe el Context Broker cuando va recoger las entidades a eliminar. Se pueden ver las opciones disponibles en [API NGSIv2 de Orion](https://github.com/telefonicaid/fiware-orion/blob/master/doc/manuals/orion-api.md#list-entities-get-v2entities).  \n        - :param opcional `options_send`: Lista de opciones que recibe el Context Broker cuando va a eliminar las entidades. Se pueden ver las opciones disponibles en [API NGSIv2 de Orion](https://github.com/telefonicaid/fiware-orion/blob/master/doc/manuals/orion-api.md#update-post-v2opupdate). En el caso de que la opcion `flowControl` se especifique dentro de este parámetro, un `cb_flowcontrol` (en la inicializción de cbManager) a `False` se ignora, quedanco como si `cb_flowcontrol` se hubiese establecido a `True`.\n        - :raises [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError): Se lanza cuando le falta algún argumento o inicializar alguna varibale del objeto cbManager, para poder realizar la autenticación o envío de datos.\n        - :raises FetchError: Se lanza cuando el servicio de Context Broker, responde con un error concreto.\n\nLa librería además proporciona [context managers](https://docs.python.org/3/reference/datamodel.html#context-managers) para abstraer la escritura de entidades en formato NGSIv2 a distintos backends (`store`s). Estos son:\n\n- `orionStore`: Genera un store asociado a una instancia particular de `cbManager` y `authManager`. Todas las entidades que se envíen a este store, se almacenarán en el cbManager correspondiente.\n    - todos los parámetros son idénticos a los de la función send_batch de la clase cbManager.\n    - :return: un `callable` que recibe una lista de entidades y las envía a la función `send_batch` del `cb` especificado. Como tal, puede lanzar cualquiera de las excepciones que lanza la función `send_batch` de la clase `cbManager`.\n\n- `sqlFileStore`: Genera un store asociado a un fichero local. Todas las entidades que se envíen a este store se almacenarán como órdenes SQL `INSERT` en el fichero local. Además de los atributos de la entidad, cada `INSERT` añadirá las columnas `fiwareservicepath` y `recvtime` para ser consistente con el formato típico de tabla histórica de entidad, y no dar error de inserción (ya que esas columnas suelen ser NOT NULL).\n    - :param: `subservice`: Nombre de subservicio a escribir en la columna `fiwareservicepath`\n    - :param: `schema` opcional: Nombre del schema a utilizar en los INSERT. Por defecto es `\":target_schema\"`, por lo que es al ejecutar el comando `psql` cuando se debe especificar con `-v target_schema=...`. Pero se le puede dar aquí un valor explícito.\n    - :param: `namespace` opcional: Prefijo opcional para los nombres de tabla generados a partir del entityType. Si se especifica, el nombre de tabla se construye como `f\"{namespace}_{entitytType.lower()}\"`\n    - :param: `table_names` opcional: mapeo de nombre de entidad a nombre de tabla. Permite especificar nombres de tabla por entidad distintos a los por defecto.\n        - si `table_name[entityType]` existe y es un string `!= \"\"`, se usa como nombre de tabla para el tipo de entidad.\n        - si `table_name[entityType]` no existe, se usa el nombre de tabla por defecto (`f\"{entitytType.lower()}\"` o `f\"{namespace}_{entitytType.lower()}\"`)\n        - si `table_name[entityType]` existe y es *falsy* (`None`, `\"\"`, etc), las entidades de ese tipo no se escriben al fichero SQL.\n    - :param: `chunk_size` opcional: máximo número de líneas a incluir en un solo `INSERT`. Default=10000\n    - :param: `append` opcional: en caso de que el fichero exista, `append=True` añade los INSERT mientras que `append=False` sobrescribe el fichero. Default False.\n    - :param `replace_id` opcional: diccionario `tipo de entidad` => `lista de atributos replace_id`.\n        Reemplaza el ID de las entidades del tipo o tipos especificados, por un valor construido a partir de la lista de atributos indicados en este parámetro, separados por `_`.\n        Imita el comportamiento del atributo `replaceId` de los FLOW_HISTORIC de URBO DEPLOYER, para poder usar este *store* en ETLs que alimenten *singletons*.\n    - :return: un `callable` que recibe una lista de entidades y las escribe como instrucciones sql `INSERT` en el fichero especificado.\n\nEl modo de uso de cualquiera de los context managers es idéntico:\n\n```python\n# En primer lugar, se selecciona el store en función del criterio que convenga.\n# por ejemplo, en este caso, una variable `use_file_store`\nif use_file_store == True:\n    new_store = lambda: tc.sqlFileStore(\n        path=Path(\"my_file_name.sql\"),\n        subservice=\"/my_subservice\"\n    )\nelse:\n    new_store = lambda: tc.orionStore(\n        cb=my_cb,\n        auth=my_auth,\n        subservice=\"/my_subservice\"\n    )\n\n# A partir de aqui, el código sería independiente del tipo de store usado\nwith new_store() as store:\n    entities = ...\n    store(entities)\n```\n\n## Testing\n\nSe recomienda trabajar en un virtualenv, en el que se instalarán las dependencias\nde la librería:\n\n```\n$ virtualenv venv\n$ source venv/bin/activate\n$ (venv)$ pip install -e python-lib/tc_etl_lib  # directorio en el que está setup.py de la lilbreria\n```\n\nAdicionalmente, instalar las herramientas necesarias para ejecutar los tests:\n\n```\npip install pytest==7.2.0 coverage==7.0.5\n```\n\nPara ejecutar un solo fichero de tests:\n\n```\n$ (venv)$ pytest python-lib/tc_etl_lib/tc_etl_lib/test_store.py\n================================================================ test session starts =================================================================\nplatform linux -- Python 3.9.2, pytest-7.2.0, pluggy-1.0.0\nrootdir: /home/fermin/src/etl-framework/python-lib/tc_etl_lib\ncollected 7 items                                                                                                                                    \n\npython-lib/tc_etl_lib/tc_etl_lib/test_store.py .......                                                                                         [100%]\n\n================================================================= 7 passed in 0.32s ==================================================================\n```\n\nPara ejecutar todos los tests se puede utilizar `pytest` sin parámetros:\n\n```\n$ (venv)$ pytest\n================================================================ test session starts =================================================================\nplatform linux -- Python 3.9.2, pytest-7.2.0, pluggy-1.0.0\nrootdir: /home/fermin/src/etl-framework/python-lib/tc_etl_lib\ncollected 7 items                                                                                                                                    \n\npython-lib/tc_etl_lib/tc_etl_lib/test_store.py .......                                                                                         [100%]\n\n================================================================= 7 passed in 0.32s ==================================================================\n```\n\n(**FIXME [#3](https://github.com/telefonicasc/etl-framework/issues/3)**: ahora mismo solo tenemos un fichero de tests y queda un poco raro la\nejecución con `pytest` a secas, pero cuando se acometa ese issue tendremos ya más).\n\nSe pueden obtener estadísticas de cobertura de código de la siguiente forma:\n\n```\n$ (venv)$ cd python-lib/tc_etl_lib\n$ (venv)$ coverage run -m unittest\n.......\n----------------------------------------------------------------------\nRan 7 tests in 0.041s\n\nOK\n\n$ (venv)$ coverage report\nName                       Stmts   Miss  Cover\n----------------------------------------------\ntc_etl_lib/__init__.py         3      0   100%\ntc_etl_lib/auth.py            95     76    20%\ntc_etl_lib/cb.py             178    141    21%\ntc_etl_lib/store.py           80      4    95%\ntc_etl_lib/test_store.py      47      0   100%\n----------------------------------------------\nTOTAL                        403    221    45%\n```\n\n## Changelog\n\n0.8.0 (March 22nd, 2023)\n\n- Add: new optional parameter called `replace_id` in sqlFileStore context manager ([#58](https://github.com/telefonicasc/etl-framework/pull/58))\n\n0.7.0 (December 23rd, 2022)\n\n- Add: new stores for saving entity batches, `orionStore` and `sqlFileStore` ([#46](https://github.com/telefonicasc/etl-framework/pull/46))\n\n0.6.0 (December 15th, 2022)\n\n- Add: new optional parameter called `batch_size` in cbManager constructor ([#37](https://github.com/telefonicasc/etl-framework/issues/37))\n\n0.5.0 (November 23rd, 2022)\n\n- Add: new optional parameter called `options` in get_entities, get_entities_page and send_batch ([#38](https://github.com/telefonicasc/etl-framework/issues/38))\n- Add: new optionals parameters called `options_send` and `options_get` in delete_entities ([#38](https://github.com/telefonicasc/etl-framework/issues/38))\n- Fix: cleaner logs, avoiding printing warnings in the case of unsecure CB API calls\n\n0.4.0 (August 31st, 2022)\n\n- Add: new optional parameter called `service` in get_entities, get_entities_page, delete_entities and send_batch\n- Add: new function set_token, to set specific token bypassing IDM negotiation\n- Add: new function delete_entities, to remove entities from Context Broker ([#14](https://github.com/telefonicasc/etl-framework/issues/14))\n- Add: new parameter actionType in the function send_batch to define the action (append, appendStrict, update, delete or replace) ([#16](https://github.com/telefonicasc/etl-framework/issues/16))\n- Fix: parameter authManager becomes optional in get_entities, get_entities_page, delete_entities and send_batch\n\n0.3.0 (August 2nd, 2022)\n\n- Add: get_auth_token_service function to get domain tokens from IDM\n\n0.2.0 (July 13th, 2022)\n\n- Add: get_entities function to get entities with internal pagination ([#5](https://github.com/telefonicasc/etl-framework/issues/6))\n- Add: block control to send_batch function to overcome CB limitation (new cbManager constructor optional param block_size) ([#6](https://github.com/telefonicasc/etl-framework/issues/6))\n- Add: more filters (q, mq, georel, geometry, coords, id) to get_entities_page function ([#13](https://github.com/telefonicasc/etl-framework/issues/13))\n\n0.1.0 (April 26th, 2022)\n\n- Initial version",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "tc-etl-lib",
    "package_url": "https://pypi.org/project/tc-etl-lib/",
    "platform": null,
    "project_url": "https://pypi.org/project/tc-etl-lib/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/tc-etl-lib/0.8.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Librería común para uso en ETL",
    "version": "0.8.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17396819,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0824e7f6de0a8add61d05ac4a6b6bb0d735a5b3061fe9383fbc9a7bec5f5612a",
          "md5": "ed9da4eee49473708a49c2543531cfe6",
          "sha256": "5aa999b83fd73f7bbd8f815a615844e638a048216e2fcbe2cc7c0dbba98e06b4"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ed9da4eee49473708a49c2543531cfe6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13095,
        "upload_time": "2022-05-25T11:32:05",
        "upload_time_iso_8601": "2022-05-25T11:32:05.965165Z",
        "url": "https://files.pythonhosted.org/packages/08/24/e7f6de0a8add61d05ac4a6b6bb0d735a5b3061fe9383fbc9a7bec5f5612a/tc_etl_lib-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "caf8de92d3bf0c6bc10a1b5c7e30c233a18a4fb07ce5038ff92580bfb31b78ee",
          "md5": "4fa20c65c066c24caf895ff45e79678f",
          "sha256": "c43aff218832e9547d1fea187317d87c76f72aa42a8d94d4a9b855e2ea27c90f"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "4fa20c65c066c24caf895ff45e79678f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 16710,
        "upload_time": "2022-07-13T08:40:26",
        "upload_time_iso_8601": "2022-07-13T08:40:26.907106Z",
        "url": "https://files.pythonhosted.org/packages/ca/f8/de92d3bf0c6bc10a1b5c7e30c233a18a4fb07ce5038ff92580bfb31b78ee/tc_etl_lib-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c7431c2ae19fd273051cc74c1fddbfe140825733ba979858172a9462b11fd07",
          "md5": "57c842c1483a3101e93cd769f449fa38",
          "sha256": "76ea186135e0b2274b8a62db143275f6f97030b5c23dcc0488845b7405644ba9"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "57c842c1483a3101e93cd769f449fa38",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 17629,
        "upload_time": "2022-08-02T10:01:20",
        "upload_time_iso_8601": "2022-08-02T10:01:20.543279Z",
        "url": "https://files.pythonhosted.org/packages/8c/74/31c2ae19fd273051cc74c1fddbfe140825733ba979858172a9462b11fd07/tc_etl_lib-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "671d57766c8acc01bcb7d48fd7156fb7a1a8099bf8e400cd0539f9bc418cd22d",
          "md5": "475f5da33cba1201ed78ec898a91d21b",
          "sha256": "4b7fe17de8fc3805547eec69e891e020b65191cdc2cba2c3ea515c614d9e561c"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "475f5da33cba1201ed78ec898a91d21b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 22694,
        "upload_time": "2022-08-31T14:43:42",
        "upload_time_iso_8601": "2022-08-31T14:43:42.312109Z",
        "url": "https://files.pythonhosted.org/packages/67/1d/57766c8acc01bcb7d48fd7156fb7a1a8099bf8e400cd0539f9bc418cd22d/tc_etl_lib-0.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "90c2feee851bc8e2b2596af7986eaf03fa74a73c4f2b166bb532a6f14bdeec6c",
          "md5": "ec03073d6777d296b287f5d6fddab0a2",
          "sha256": "b69340b4f7ed4aa6ea86f290a7e112375e5186f01f1aa03dbfefb7cd50275831"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ec03073d6777d296b287f5d6fddab0a2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 24748,
        "upload_time": "2022-11-23T16:40:42",
        "upload_time_iso_8601": "2022-11-23T16:40:42.625659Z",
        "url": "https://files.pythonhosted.org/packages/90/c2/feee851bc8e2b2596af7986eaf03fa74a73c4f2b166bb532a6f14bdeec6c/tc_etl_lib-0.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.6.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4204354b679e368fb8e903939f1b43399cc5732e67ec87104f4b38b0d14140eb",
          "md5": "f58e5df59b65aec7798adb7cf9cca7b0",
          "sha256": "3cc035634991efd9929083c239c7909110d0c209f8f61350c2a879956177af1a"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f58e5df59b65aec7798adb7cf9cca7b0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 25244,
        "upload_time": "2022-12-15T16:25:07",
        "upload_time_iso_8601": "2022-12-15T16:25:07.215533Z",
        "url": "https://files.pythonhosted.org/packages/42/04/354b679e368fb8e903939f1b43399cc5732e67ec87104f4b38b0d14140eb/tc_etl_lib-0.6.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.7.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "04b89b1cc99e87c96bff9d133c1e471e97dc563d12ae91b2ca1f89fc8388e5ff",
          "md5": "e1911fc030e80230e62068f9df54b828",
          "sha256": "c6428e58714fe9fbd2ed674d5d38333d15fd5693fbc13e281d4f44d4738f991b"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.7.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e1911fc030e80230e62068f9df54b828",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 33380,
        "upload_time": "2022-12-23T11:34:43",
        "upload_time_iso_8601": "2022-12-23T11:34:43.694657Z",
        "url": "https://files.pythonhosted.org/packages/04/b8/9b1cc99e87c96bff9d133c1e471e97dc563d12ae91b2ca1f89fc8388e5ff/tc_etl_lib-0.7.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "de79eb853f9f227a9efc7b8f560d8b0fab84d16eadbef2033e6b0e87411ca65f",
          "md5": "195996ca6b614e708c3425330be74514",
          "sha256": "dfb2f71a61bc523109c4d16934901c9d72201e5fcb336725f9fc6a0251010c93"
        },
        "downloads": -1,
        "filename": "tc_etl_lib-0.8.0.tar.gz",
        "has_sig": false,
        "md5_digest": "195996ca6b614e708c3425330be74514",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 37208,
        "upload_time": "2023-03-22T11:32:00",
        "upload_time_iso_8601": "2023-03-22T11:32:00.651807Z",
        "url": "https://files.pythonhosted.org/packages/de/79/eb853f9f227a9efc7b8f560d8b0fab84d16eadbef2033e6b0e87411ca65f/tc_etl_lib-0.8.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "de79eb853f9f227a9efc7b8f560d8b0fab84d16eadbef2033e6b0e87411ca65f",
        "md5": "195996ca6b614e708c3425330be74514",
        "sha256": "dfb2f71a61bc523109c4d16934901c9d72201e5fcb336725f9fc6a0251010c93"
      },
      "downloads": -1,
      "filename": "tc_etl_lib-0.8.0.tar.gz",
      "has_sig": false,
      "md5_digest": "195996ca6b614e708c3425330be74514",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 37208,
      "upload_time": "2023-03-22T11:32:00",
      "upload_time_iso_8601": "2023-03-22T11:32:00.651807Z",
      "url": "https://files.pythonhosted.org/packages/de/79/eb853f9f227a9efc7b8f560d8b0fab84d16eadbef2033e6b0e87411ca65f/tc_etl_lib-0.8.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}