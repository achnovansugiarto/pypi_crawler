{
  "info": {
    "author": "Justin Berthelot Sam Dominguez Daniel Munger Christopher Rice",
    "author_email": "pythoncov3rt@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# Introduction to the cov3rt Framework\n_A capstone project created by Justin Berthelot, Samuel Dominguez, Daniel Munger, and Christopher Rice at Louisiana Tech University for the Cyber Engineering Senior Design Symposium, Spring 2021_\n\n## The Purpose of cov3rt\nDespite the prevalence of covert channels in cyber attacks, no standardized tools exist for creation, management, and deployment of network covert channels. The cov3rt framework seeks to provide developers, red teams, and network administrators with a Python environment to integrate and deploy covert channels into their existing workflows. \n\n## Installation of cov3rt\nThe cov3rt framework is designed for **Python 3** (v3.4.1 or newer.)\nThe framework can be installed from PIP via\n```sh\nsudo pip install cov3rt\n```\nBecause of the nature of sending network packets on reserved ports, cov3rt is required to run with administrator privileges (hence the _sudo_ installation requirement.)\n\nThe framework also uses _**npyscreen** v4.10.0_, _**scapy** v2.4.3_, and _**windows-curses** v2.2.0_ (for Windows installations only.) In normal cases, these dependencies should be automatically installed when cov3rt is installed via PIP. However, if required, these packages can also be installed separately through PIP.\n\n***\n***\n***\n\n# The Cloak Superclass (Cloak.py)\nThe cov3rt framework, as well as all cloak implementations, are built based on Cloak.py. All cloaks written for cov3rt inherit the Cloak superclass. This superclass contains standardized functions for interfacing with the cov3rt framework, such as the ability to ingest data and send/receive packets. Many of these functions are required in each cloak for the framework to function properly, with additional optional functions present as well. These functions are described within this documentation.\nFor more detailed information and implementation examples, please reference our example cloaks.\n\n## Requirements for Cloaks\nEach cloak is classified based on the [classification structure defined by Wendzel et al](http://ih-patterns.blogspot.com/p/test.html). Each of these classifications are offered as variables in the Cloak superclass. Each cloak implementation should specify its classification, such that it can be categorized correctly within the application. This is done through a class variable in a cloak, as shown below.\n```py\nclass CloakExample(Cloak):\n    ...\n    classification = cloak.RANDOM_VALUE # list of valid classes found in Cloak.py\n    ...\n```\n\nEach cloak implementation should also contain a name and description variable, following certain constraints to display correctly in the application. These are implemented via a class variable named 'name' and 'description', as shown below.\n```py\nclass CloakExample(Cloak):\n    ...\n    name = \"Name of My Cloak\" # cannot be longer than 30 characters\n    description = \"This is a cloak with a long description to show how\\\n        \\nline wrapping looks.\" # no longer than 53 characters per new line\n    ...\n```\nEach cloak implementation must also implement the functionality for each required function, stated below in the next section. Below is a barebones example of a Cloak compatible with the cov3rt Framework.\n```py\n# This is a barebone example of a cloak's minimum requirements\nfrom scapy.sendrecv import send,sniff\nfrom cov3rt.Cloaks.Cloak import Cloak\nfrom scapy.utils import wrpcap\n\nclass ExampleCloak(Cloak):\n    # Class vars must meet requirements detailed earlier\n    classification = Cloak.XXXXXXXXXXX\n    name = \"NAME HERE\"\n    description = \"DESCRIPTION HERE\"\n\n    def __init__(self, ..., ...):\n        # variables such as destination IP, sending port, etc should be defined here\n        self.var1 = var1\n        ...\n\n    def ingest(self, data):\n        ...\n\n    def send_packet(self, data, iface=None):\n        ...\n\n    def send_packets(self, iface=None, packetDelay=None, delimitDelay=None, endDelay=None):\n        ...\n\n    def packet_handler(self, pkt):\n        ...\n\n    def recv_packets(self, timeout=None, max_count=None, \\\n        iface=None, in_file=None, out_file=None):\n        ...\n\n    # We also recommend getters/setters for instance variables\n    # var1 Getter\n    @property\n    def var1(self): \n        return self._var1\n    # var1 Setter\n    @var1.setter\n    def var1(self, var1):\n        ...\n        self._var1 = var1\n```\n***\n***\n***\n## Required Functions within Cloak.py\nThese functions are the **minimum** requirements for a Cloak to be compatible with the cov3rt framework. These functions provide base functionality for the framework to use a cloak, such as the ability to ingest data and send/receive packets. Additional optional functions exist as well for ease-of-use improvements such as End-of-Transmission functionalities and delimiters.\n\n#### Ingest (ingest)\n```\ningest(self, data)\n    self | no type          | required argument\n    data | any type desired | can be any type as desired, this is the data to be sent by the Cloak\n```\nThis function takes in a _data_ argument and formats said data to be used in a meaningful way within the cloak. Data can be of any type desired, as it is up to the developer to determine how to format and ingest their data. When data (ie input text, a string, etc.) is passed to a cloak through the cov3rt framework CLI/TUI, the _ingest_ function is called to accomplish this (hence why it is required.) Ingested data is recommended to be written to an instance variable such as _self.data_.\n```py\n# Example ingest function, using a str input converted to a binary string\n# Taken from DNSTiming.py\ndef ingest(self, data):\n    '''Ingests data and formats it as a binary string.'''\n    if isinstance(data, str): # confirming input is a string\n        # for each character, convert to binary and append to self.data\n        self.data = ''.join(format(ord(i), 'b').zfill(8) for i in data)\n    else:\n        raise TypeError(\"'data' must be of type 'str'\") # we recommend errors like this\n```\n\n#### Send Packets (send_packets)\n```\nsend_packets(self, iface=None, packetDelay=None, delimitDelay=None, endDelay=None)\n    self         | no type      | required argument\n    iface        | str          | a valid network interface on the machine to send packets on\n    packetDelay  | int or float | delay between each packet sent\n    delimitDelay | int or float | delay before sending delimiter\n    endDelay     | int or float | delay before sending EOT\n```\nThis function performs the sending functionality of the cloak by calling the _send_packet_ function as desired by the developer. For example, if a cloak sends a character per packet, _send_packets_ may iterate over _self.data_, calling _send_packet_ for each iteration. This function should return _True_ once completed.\n```py\n# Example send_packets function, calling send_packet for each char in items of self.data\n# Taken from IPMorse.py\ndef send_packets(self, iface=None, packetDelay=None, delimitDelay=None, endDelay=None):\n    '''Sends the entire ingested data via the send_packet method.'''\n    for item in self.data:\n        for char in item:\n            self.send_packet(char, iface)\n            if isinstance(packetDelay, int) or isinstance(packetDelay, float):\n                debug(\"Packet delay sleep for {}s\".format(packetDelay))\n                sleep(packetDelay)\n        if isinstance(delimitDelay, int) or isinstance(delimitDelay, float):\n            debug(\"Delimit delay sleep for {}s\".format(delimitDelay))\n            sleep(delimitDelay)\n        self.send_delimiter(iface)\n\n    # End delay\n    if isinstance(endDelay, int) or isinstance(endDelay, float):\n        debug(\"End delay sleep for {}s\".format(endDelay))\n        sleep(endDelay) \n    self.send_EOT(iface)\n    return True\n```\n\n#### Send Packet (send_packet)\n```\nsend_packet(self, data, iface=None)\n    self  | no type  | required argument\n    data  | any type | the data being sent in a packet\n    iface | str      | a valid network interface on the machine to send packets on\n```\nThis function should be defined to take in a portion (or all) of _self.data_ and then craft and send a singular packet as part of the cloak. This can be accomplished by crafting a packet with Scapy and calling Scapy's _send_ function. _send_packet_ should be called within _send_packets_ in order to create and send network traffic.\n```py\n# Example send_packet function, sending data through case modulation of DNS requests\n# Taken from DNSCaseModulation.py\ndef send_packet(self, databit, iface=None):\n    '''Sends packets based on case modulation encoding.'''\n    # Binary zero sends a lowercase domain name\n    if databit == '0':\n        pkt = IP(dst=self.ip_dst) / UDP(dport=53) / DNS(rd=1, qd=DNSQR(qname=self.domain.lower())\n        send(pkt, verbose=False, iface=iface)\n    # Binary one sends as capital domain name\n    else:\n        pkt = IP(dst=self.ip_dst) / UDP(dport=53) / DNS(rd=1, qd=DNSQR(qname=self.domain.upper())\n        send(pkt, verbose=False, iface=iface)\n```\n\n#### Packet Handler for Sniff Function (packet_handler)\n```\npacket_handler(self, pkt)\n    self | no type       | required argument\n    pkt  | Packet object | fed into the packet_handler as part of the sniff in recv_packets\n```\nThis function specifies the packet handler used to filter packets as they are received. The _packet_handler_ function is passed to the _sniff_ function of Scapy in order to receive and process network traffic as part of the _recv_packets_ function. The packet handler's purpose is to analyze each packet to determine if it is part of the covert channel; if a packet is determined to be part of the channel, the packet handler will extract the hidden data from the packet, writing it to a variable (ie _self.read_data_.)\n```py\n# Example packet_handler function, receiving packets and determining important packets\n# Taken from UDPChecksum.py\ndef packet_handler(self, pkt):\n    '''Specifies the packet handler for receiving info via the UDP Checksum Cloak.'''\n    # Check for appropriate layers (all others can immediately be ignored)\n    if pkt.haslayer(UDP) and pkt.haslayer(IP) and pkt.haslayer(Raw):\n        # Check for appropriate options specific to our cloak\n        if pkt[\"IP\"].dst == self.ip_dst and pkt[\"UDP\"].sport == self.send_port \\\n            and pkt[\"UDP\"].dport == self.dest_port:\n            # We want all packets except for those with 0x9999 checksum\n            if pkt[\"UDP\"].chksum != 0x9999:\n                self.read_data += chr(pkt[\"UDP\"].chksum) # ASCII character checksum\n\n# Used as part of recv_packets as shown\ndef recv_packets(...):\n    ...\n    packets = sniff(..., prn = self.packet_handler, ...)\n    ...\n```\n\n#### Receive Packets (recv_packets)\n```\nrecv_packets(self, timeout=None, max_count=None, iface=None, in_file=None, out_file=None)\n    self      | no type      | required argument\n    timeout   | int or float | time before exiting\n    max_count | int          | maximum number of packets received before exiting\n    iface     | str          | a valid network interface on the machine to receive packets on\n    in_file   | str          | path to a .pcap input file for static analysis purposes\n    out_file  | str          | path to a desired output file for saving a .pcap of received traffic\n```\nThis function receives packets in the cloak and then decodes the covert message. Scapy's _sniff_ function should be called within _recv_packets_, with _self.packet_handler_ being passed as the packet handler argument. Once the _sniff_ function returns, the extracted information can be decoded or returned as-is (depending on your implementation.) If the data decode step occurred on-the-fly in the _packet_handler_, you may only need to return _self.read_data_ without any extra steps.\n```py\n# Example recv_packets function, with decoding occurring within\n# Taken from DNSCaseModulation.py\ndef recv_packets(self, timeout=None, max_count=None, iface=None, in_file=None, out_file=None):\n    '''Receives packets for the DNSCaseModulation cloak and decodes message.'''\n    self.read_data = '' # used to store received information\n    if max_count: # for exit after a certain number of packets received\n        packets = sniff(timeout=timeout, count=max_count, iface=iface, offline=in_file, \\\n            stop_filter=self.recv_EOT, prn=self.packet_handler)\n    else: # standard case with no limit, awaits an EOT before exit\n        packets = sniff(timeout=timeout, iface=iface, offline=in_file, \\\n            stop_filter=self.recv_EOT, prn=self.packet_handler)\n    if out_file: # writes received packets to out_file\n        wrpcap(out_file, packets)\n\n    # Decode the read data\n    string = ''\n    # Convert to ASCII characters and add to decoded string\n    for i in range(0, len(self.read_data), 8):\n        char = \"0b{}\".format(self.read_data[i:i+8])\n        string += chr(int(char, 2))\n\n    return string\n```\n***\n## Optional Functions within Cloak.py\nThese functions are provided to give additional flexibility to Cloak implementations, but are not required. These functions are implemented similarly to the required functions above.\n\n#### Send End-of-Transmission Packet (send_EOT)\n```\nsend_EOT(self, iface=None)\n    self  | no type | required argument\n    iface | str     | a valid network interface on the machine to send packets on\n```\nThis function sends an End-of-Transmission packet to signal the end of a covert message stream to a receiver. The _recv_EOT_ function should also be implemented if this function is used. This function should be called at the end of the _send_packets_ function.\n```py\n# Example send_EOT function to send a UDP packet with random data and a 0x9999 checksum\n# Taken from UDPChecksum.py\ndef send_EOT(self, iface=None):\n    '''Sends an EOT packet (checksum 0x9999) to signal the end of transmission.'''\n    packet_string = urandom(randint(25,50))\n    pkt = IP(dst=self.ip_dst) / UDP(sport=self.send_port, dport=self.dest_port, chksum=0x9999)\\\n        / Raw(packet_string)\n    send(pkt, verbose=False, iface=iface)\n```\n\n#### Receive End-of-Transmission Packet (recv_EOT)\n```\nrecv_EOT(self, pkt)\n    self | no type       | required argument\n    pkt  | Packet object | fed into the recv_EOT as part of the sniff in recv_packets\n```\nThis function works alongside the _packet_handler_ in the _sniff_ function to receive an End-of-Transmission packet. The _send_EOT_ function should also be implemented if this function is used. To use this function, it should be called in the _sniff_ function as the _stop_filter_ argument (example shown below.) This function should return _True_ if the EOT packet is received, and _False_ in any other case.\n```py\n# Example recv_EOT function, watching for a UDP packet with a 0x9999 checksum\n# Taken from UDPChecksum.py\ndef recv_EOT(self, pkt):\n    '''Specifies the EOT packet and returns True if packet is received.'''\n    if pkt[\"IP\"].dst == self.ip_dst and pkt[\"UDP\"].sport == self.send_port \\\n        and pkt[\"UDP\"].dport == self.dest_port:\n        if (pkt[\"UDP\"].chksum == 0x9999):\n            return True\n    return False\n\n# Used as part of recv_packets function as shown\ndef recv_packets(...):\n    ...\n    packets = sniff(..., stop_filter = self.recv_EOT, ...)\n    ...\n```\n\n#### Send Delimiter (send_delimiter)\n```\nsend_delimiter(self, iface=None)\n    self  | no type | required argument\n    iface | str     | a valid network interface on the machine to send packets on\n```\nThis function sends a delimiter packet of choice to signal the end of a data stream to a receiver (for example, if you wanted to delimit per line or per character.) There is no corresponding _recv_delimiter_ function built in to Cloak.py -- we found it easier for delimiters to be extracted as part of the _packet_handler_ rather than trying to force in another method of detection. However, if desired, you could create a _recv_delimiter_ function and call it within the _packet_handler_.\nAn example of sending and receiving delimiters is shown below.\n```py\n# Example send_delimiter function (note similarity to send_EOT)\n# Taken from IPMorse.py\ndef send_delimiter(self, iface=None):\n    '''Sends delimiter packet to signify end of a Morse Code Character.'''\n    packet_string = urandom(42)\n    pkt = IP(dst=self.ip_dst) / UDP(sport=self.send_port, dport=self.dest_port) \\\n        / Raw(packet_string)\n    send(pkt, verbose=False, iface=iface)\n\n# Used as part of send_packets function as shown to send delimiter packets\ndef send_packets(...):\n    ...\n    for item in self.data:\n        for char in item:\n            ...\n        ...\n        self.send_delimiter(iface) # corresponds to end of an item\n    ...\n\n# Delimiters are received in packet_handler\ndef packet_handler(...):\n    ...\n    if pkt.haslayer(Raw): # do any filtering to see if packet matches requirements\n        ...\n        if length == 42: # this is what our delimiters have in our case\n            # perform delimiter-specific action\n            self.read_data += \"/\"\n        ...\n    ...\n```\n***\n***\n***\n\n# The cov3rt Command Line Interface\nThe command line application parses through provided arguments to quickly deploy cloaks in the field as one-liner commands. In addition to the traditional message and file input, the command line application can take input from stdin and can therefore be \"piped\" with other shell commands.\n\n## Command Line Options\n\n### Primary Arguments\n| Option | Description |\n| ----- | ----- |\n| -c | Selected covert channel implementation |\n| -s | Send data via the selected cloak |\n| -r | Receive data via the selected cloak |\n\n### Send Options\n| Option | Description |\n| ----- | ----- |\n| -m | Send a string message via the selected cloak |\n| -f | Send file contents via the selected cloak |\n\n### Receive Options\n| Option | Description |\n| ----- | ----- |\n| -t | Timeout (in seconds) for the packet handler |\n| -mc | Max number of packets for the packet handler |\n| -in | Static analysis of a capture file (pcap) |\n| -of | Output the received message to a file |\n| -op | Output the received packets to a capture file (pcap) |\n\n### Delay Options\n| Option | Description |\n| ----- | ----- |\n| -pd | Delay between packets |\n| -dd | Delay before each data delimeter |\n| -ed | Delay before the end-of-transmission |\n\n### Other Options\n| Option | Description |\n| ----- | ----- |\n| -h | Display the help screen |\n| -l | List the available cloaks in the current environment |\n| -i | Launch the interactive TUI |\n| -if | Select the network interface for cloak communication |\n| -d | Use the default parameters for the selected cloak |\n| -v | Increase verbosity of cloak communication |\n| -vv | Further increase verbosity of cloak communication |\n\n***\n***\n***\n\n# The cov3rt Terminal User Interface\nThe cov3rt application includes a Terminal User Interface (TUI) which provides a more robust user experience. This TUI serves the purpose of providing the user with a simpler interface for those that are not as comfortable with a command-line interface.\n\nThe interactive TUI contains all the functionality of the command-line interface with the exception of receiving stdin. The interactive TUI includes extra functionality to list available network interfaces when the user plans to send or receive information with a selected cloak.\n\n***\n***\n***\n\n# Example Cloak Implementations\nEach cloak in this section contains a description of its function and a brief overview of how it accomplishes its function. Specifics of the code are left to the actual Python files.\nThese cloak examples are meant to showcase the functionality of the cov3rt Framework -- not to be used in real use cases (however, some of them possibly could be.) Many of these examples are not very robust and exist to give developers examples of how to implement their own cloaks.\n***\n#### DNS Case Modulation (DNSCaseModulation.py)\n**Classification**: Case Modulation\n\n| Argument | Type | Description | \n| ----- | ----- | ------ |\n| ip_dst | str | Destination IP Address |\n| domain | str | Domain for sending modulated message |\n\n**Description**: This cloak sends data based on the modulation of the case of a specified domain, _self.domain_. This cloak takes an input string (ASCII) and converts it to a binary string, and then sends the data via case modulation. This is accomplished by sending a lowercase domain (ie google.com) for '0' and an uppercase domain (ie GOOGLE.COM) for '1'.\n***\n#### DNS Timing (DNSTiming.py)\n**Classification**: Inter-Packet Timing\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| domaindelim | str | Domain for EOT delimiting |\n| domaincont | str | Domain for sending timing message |\n| zerotiming | int / float | Delay between packets corresponding to '0' |\n| onetiming | int / float | Delay between packets corresponding to '1' |\n\n**Description**: This cloak sends data based on the delay between DNS Requests to a specified domain, _domaincont_. This cloak takes an input string (ASCII) and converts it to a binary string, and then sends the data by sending packets with corresponding delays between (_zerotiming_ / _onetiming_.)\n***\n#### ICMP Echo Full Payload (ICMPEchoFullPayload.py)\n**Classification**: User Data Value Modulation (Reserved/Unused)\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n\n**Description**: This cloak sends data within the payload of an ICMP Echo packet. The entire contents of the covert message are dumped directly into the payload and sent in plaintext.\n***\n#### ICMP Echo Multi Payload (ICMPEchoMultiPayload.py)\n**Classification**: User Data Value Modulation (Reserved/Unused)\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n\n**Description**: This cloak sends data within the payload of ICMP Echo packets. Each packet contains a single character of the covert message in plaintext within the payload of the packet.\n***\n#### IP Identification (IPID.py)\n**Classification**: Random Value\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| EOT_ID | int | Identification Number designated as an EOT flag |\n| ip_dst | str | Destination IP Address |\n\n**Description**: This cloak sends data by modifying the ID field of IP packets. The ID of each packet sent is overridden to correspond to a single ASCII character from the covert message.\n***\n#### IP Morse Code (IPMorse.py)\n**Classification**: Reserved/Unused\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| send_port | int | Outbound port of covert channel on sender's machine |\n| dest_port | int | Destination port of covert channel |\n\n**Description**: This cloak converts a message into Morse Code and modifies the Reserved Bit field of IP packets to send the message covertly. This channel sends a single dot or dash per packet in the Reserved Bit field. After each full character is transmitted, a delimiter packet with a payload length of 42 is sent. A packet with a payload length of 679 designates the end of the transmission.\n***\n#### IP Reserved Bit (IPReservedBit.py)\n**Classification**: Reserved/Unused\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n\n**Description**: This cloak sends data by modulation of the Reserved Bit of IP packets. This cloak takes an input string (ASCII) and converts it to a binary string and sends one binary character per packet.\n***\n#### IPv6 \"Hoppers\" Hop Limit (IPv6Hoppers.py)\n**Classification**: Random Value\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| EOT_hl | int | Designated Hop Limit value for EOT packets |\n| ip_dst | str | Destination IPv6 Address |\n\n**Description**: This cloak sends data by overwriting the value of the Hop Limit field of IPv6 Packets. This cloak takes an input string (ASCII) and converts it to a binary string; A packet is sent for each character, replacing the Hop Limit field with the binary equivalent of the character. \n> Note: In this channel, the EOT is determined by a packet with a Hop Limit matching that of _EOT_hl_. Therefore, it is important that EOT_hl not be equal to a character within the covert message, or else the communication could be cut short.\n***\n#### TCP Patsy Four-Character Sequence Number (TCPFourCharPatsySeqNum.py)\n**Classification**: Random Value\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| ip_patsy | str | Middle-man IP Address for bouncing TCP packets to destination |\n| patsy_port | int | Port on _ip_patsy_ for bouncing TCP packets to destination |\n\n**Description**: This cloak sends data by altering the value of the Sequence Number (SEQ) field of TCP packets and sending them to a \"patsy\" or intermediary machine. To achieve this \"middle-man\" bounce, the sender IP address is spoofed as the destination IP address, _ip_dst_. The patsy receives unsolicited TCP packets and sends a SYN-ACK response to _ip_dst_ (thinking it was the original sender), completing our transmission. The Acknowledgement (ACK) number of of the response will be equal to our original SEQ + 1, allowing us to retrieve the covert message. Each packet sent in this method delivers four ASCII characters per packet in the SEQ field; in a case where less than four characters are left to be transmitted, the SEQ is padded with zeros. The EOT is designated by a packet with no payload (while all other packets contain a randomized payload length.)\n\n> Note: Any random IP address cannot work as a patsy. You must determine if the patsy address (and patsy port) will return packets when sent unsolicited TCP traffic. As a proof of concept, we tested this with a Raspberry Pi with the SSH port open. This setup was able to successfully bounce packets. Please note that in its current iteration, **this patsy only works for SYN-ACK responses**. If a patsy returns SYN-RST packets, you will likely encounter random data instead of the desired message. This is due to SYN-RST packets changing the ACK number based on the length of the payload.\n\n> **Important Note:** This channel is by no means perfected. This type of communication bouncing is prone to packet retransmissions and out-of-order arrival. A list of received packets is kept and matched against to prevent duplicate portions of the message. However, no order preservation has been implemented. This could be implemented somewhat easily (by including some sort of sequencing information in the packets) and is left to future developers if desired.\n***\n#### TCP One-Character Sequence Number (TCPOneCharSeqNum.py)\n**Classification**: Random Value\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| send_port | int | Outbound port of covert channel on sender's machine |\n| dest_port | int | Destination port of covert channel |\n\n**Description**: This cloak sends data by altering the value of the Sequence Number (SEQ) field of TCP packets. This cloak takes an input string (ASCII) and sends one packet per character, overwriting the SEQ number with the binary equivalent of the character. The EOT is designated as a packet with the IP Flags set to 0x06.\n***\n#### UDP Checksum (UDPChecksum.py)\n**Classification**: Value Influencing\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| send_port | int | Outbound port of covert channel on sender's machine |\n| dest_port | int | Destination port of covert channel |\n\n**Description**: This cloak sends data by overwriting the checksum value of UDP packets. This cloak takes an input string (ASCII) and iterates over the string; For each character in the string, a UDP packet is sent with its checksum value set to the binary equivalent of the character. The payload of each packet contains fluff data, with the EOT packet also containing a checksum of 0x0000 rather than a character's value (ie 0x00D3.)\n***\n#### UDP Flood\n**Classification**: Number of Elements\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| send_port | int | Outbound port of covert channel on sender's machine |\n| dest_port | int | Destination port of covert channel |\n\n**Description**: This cloak sends data by 'flooding' a destination with a number of packets corresponding to ASCII character values. Each packet sent has a randomized payload with a length of 1024. The receiver keeps count of the number of packets sent between delimiters in order to determine the character sent. A delimiter is designated as a packet with a payload length of 512. The EOT is designated as a packet with a payload length of 4.\n***\n#### UDP Size Modulation\n**Classification**: User Data Value Modulation (Reserved/Unused)\n\n| Argument | Type | Description |\n| ----- | ----- | ----- |\n| ip_dst | str | Destination IP Address |\n| send_port | int | Outbound port of covert channel on sender's machine |\n| dest_port | int | Destination port of covert channel |\n\n**Description**: This cloak sends data by modulating the size of the payload of UDP packets. This cloak takes an input string (ASCII) and iterates over the data, sending packets whose payload lengths match the decimal ASCII values of each character of the data (ie payload length of 65 for 'A'.)\n***\n***\n***\n# Example Use Case for the cov3rt Framework: Teamserver Communication Application Proof-of-Concept\nThe cov3rt framework goes beyond sending and receiving messages and files directly with the CLI / TUI. The framework itself can be imported and called upon to perform actions for programs, such as a covert channel based team communication server. We have created a proof-of-concept implementation of a two-way teamserver for continuous communication over a selected cloak. The user can find, use, and inspect this tool in the \"Tools\" section of our file structure.\n\n## Importing Cloaks in User-Created Tools\nCloaks can be imported directly from the cov3rt module. An example of importing and setting up a sender in the 'UDP Payload' cloak from the 'teamCommunication.py' tool is shown below.\n```py\nfrom sys import argv\nfrom cov3rt.Cloaks import UDPSizeModulation\n...\n# Instantiate sender\nsendcloak = UDPSizeModulation()\n...\n# Set the sender destination IP addresses\nsendcloak.ip_dst = argv[2]\n# Grab the network interface\nINTERFACE = argv[3]\n...\n# Format and ingest the user's handle (name) and message\nsendcloak.ingest(\"{} > {}\".format(strhandle, strmsg))\n# Send the packets\nsendcloak.send_packets(iface=INTERFACE)\n```\n\nSimilarly, we setup and implement a receiver in the code, but we require threading to constantly listen for packets as we send messages.\n\n```py\nfrom sys import argv\nfrom cov3rt.Cloaks import UDPSizeModulation\n...\n# Receiving function for our thread\ndef recthread():\n    global board, recvcloak, selected_field, screen, INTERFACE\n    # Loop until the the program exits\n    while True:\n        # Limit responses to 95 characters\n        resp = recvcloak.recv_packets(iface=INTERFACE)[:95]\n...\n# Instantiate receiver\nrecvcloak = UDPSizeModulation()\n...\n# Set the receiver destination IP addresses\nrecvcloak.ip_dst = argv[1]\n...\n# Start up our thread as a daemon\nx = Thread(target=recthread, daemon=True)\nx.start()\n```\n```\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/jbert1/Cov3rt/",
    "keywords": "",
    "license": "GPLv2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "cov3rt",
    "package_url": "https://pypi.org/project/cov3rt/",
    "platform": "",
    "project_url": "https://pypi.org/project/cov3rt/",
    "project_urls": {
      "Documentation": "https://github.com/jbert1/Cov3rt/blob/main/cov3rt-documentation.md",
      "Homepage": "https://github.com/jbert1/Cov3rt/",
      "Source Code": "https://github.com/jbert1/Cov3rt/"
    },
    "release_url": "https://pypi.org/project/cov3rt/1.0/",
    "requires_dist": [
      "psutil (>=5.6.0)",
      "scapy (>=2.4.0)",
      "npyscreen (>=4.9)",
      "windows-curses (>=1.0) ; platform_system == \"Windows\""
    ],
    "requires_python": ">=3.6.0",
    "summary": "Covert Channel Management, Integration, and Implementation",
    "version": "1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10204026,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e711b8e447db7f9325cdb052a244e9e7aa0687a4899020adf57525e4008f9076",
          "md5": "f0d9f0df3f4b56ee071af0a5ae578058",
          "sha256": "edc1371d45c3543eca65e56dde7f638d55eafbeff044b57ec559f23c077f21c5"
        },
        "downloads": -1,
        "filename": "cov3rt-1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f0d9f0df3f4b56ee071af0a5ae578058",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 70334,
        "upload_time": "2021-04-29T05:31:42",
        "upload_time_iso_8601": "2021-04-29T05:31:42.290422Z",
        "url": "https://files.pythonhosted.org/packages/e7/11/b8e447db7f9325cdb052a244e9e7aa0687a4899020adf57525e4008f9076/cov3rt-1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "481281fa880a2f3ef529ed433b5149b49e788cda8ed59ccf48383c15dca43391",
          "md5": "b81bdd32cf0d05fa0d930ad40f594500",
          "sha256": "09f7b184ce7fb9ae2f174b1e75c2b3729c60885e2ebcf0c6884fdfb581b5cf4d"
        },
        "downloads": -1,
        "filename": "cov3rt-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b81bdd32cf0d05fa0d930ad40f594500",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.0",
        "size": 61551,
        "upload_time": "2021-04-29T05:31:44",
        "upload_time_iso_8601": "2021-04-29T05:31:44.457487Z",
        "url": "https://files.pythonhosted.org/packages/48/12/81fa880a2f3ef529ed433b5149b49e788cda8ed59ccf48383c15dca43391/cov3rt-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e711b8e447db7f9325cdb052a244e9e7aa0687a4899020adf57525e4008f9076",
        "md5": "f0d9f0df3f4b56ee071af0a5ae578058",
        "sha256": "edc1371d45c3543eca65e56dde7f638d55eafbeff044b57ec559f23c077f21c5"
      },
      "downloads": -1,
      "filename": "cov3rt-1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "f0d9f0df3f4b56ee071af0a5ae578058",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6.0",
      "size": 70334,
      "upload_time": "2021-04-29T05:31:42",
      "upload_time_iso_8601": "2021-04-29T05:31:42.290422Z",
      "url": "https://files.pythonhosted.org/packages/e7/11/b8e447db7f9325cdb052a244e9e7aa0687a4899020adf57525e4008f9076/cov3rt-1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "481281fa880a2f3ef529ed433b5149b49e788cda8ed59ccf48383c15dca43391",
        "md5": "b81bdd32cf0d05fa0d930ad40f594500",
        "sha256": "09f7b184ce7fb9ae2f174b1e75c2b3729c60885e2ebcf0c6884fdfb581b5cf4d"
      },
      "downloads": -1,
      "filename": "cov3rt-1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "b81bdd32cf0d05fa0d930ad40f594500",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6.0",
      "size": 61551,
      "upload_time": "2021-04-29T05:31:44",
      "upload_time_iso_8601": "2021-04-29T05:31:44.457487Z",
      "url": "https://files.pythonhosted.org/packages/48/12/81fa880a2f3ef529ed433b5149b49e788cda8ed59ccf48383c15dca43391/cov3rt-1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}