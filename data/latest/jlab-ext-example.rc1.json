{
  "info": {
    "author": "Project Jupyter Contributors",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Jupyter",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# Server Hello World\n\n> Create a minimal extension with backend (i.e. server) and frontend parts.\n\n![server extension example](./preview.png)\n\nIt is strongly recommended to read the [basic hello-world](../hello-world)\nexample before diving into this one.\n\n- [Server Hello World](#server-hello-world)\n  - [The template folder structure](#the-template-folder-structure)\n  - [Frontend Part](#frontend-part)\n  - [Backend (Server) Part](#backend-server-part)\n  - [Packaging the Extension](#packaging-the-extension)\n    - [Python Package Manager](#python-package-manager)\n    - [JupyterLab Extension Manager](#jupyterlab-extension-manager)\n  - [Installing the Package](#installing-the-package)\n\n## The template folder structure\n\nWriting a JupyterLab extension usually starts from a configurable template. It\ncan be downloaded with the [`cookiecutter`](https://cookiecutter.readthedocs.io/en/latest/) tool and the following command for an extension with a server part:\n\n```bash\ncookiecutter https://github.com/jupyterlab/extension-cookiecutter-ts\n```\n\n`cookiecutter` asks for some basic information that could for example be setup\nlike this (be careful to set _has_server_extension_ to _y_):\n\n```bash\nauthor_name []: tuto\nauthor_email []: tuto@help.you\nlabextension_name [myextension]: jlab-ext-example\npython_name [jlab_ext_example]:\nproject_short_description [A JupyterLab extension.]: A minimal JupyterLab extension with backend and frontend parts.\nhas_settings [n]:\nhas_server_extension [n]: y\nhas_binder [n]: y\nrepository [https://github.com/github_username/jlab-ext-example]:\n```\n\n> The python name should not contain `-`. It is nice for user to test your extension online, so the `has_binder` was set to _yes_.\n\nThe cookiecutter creates the directory `jlab_ext_example` [or your extension name]\nthat looks like this:\n\n```bash\njlab_ext_example/\n│  # Generic Files\n│   .gitignore\n│   install.json                # Information retrieved by JupyterLab to help users know how to manage the extension\n│   LICENSE                     # License of your code\n│   README.md                   # Instructions to install and build\n│\n├───.github\n│   └───workflows\n│           build.yml\n│\n├───binder\n│       environment.yml\n│       postBuild\n│  \n│  # Python Package Files\n│   MANIFEST.in                 # Help Python to list your source files\n│   pyproject.toml              # Define dependencies for building the package\n│   setup.py                    # Information about the package\n│\n│  # Backend (server) Files\n├───jupyter-config\n│       jlab_ext_example.json   # Server extension enabler\n│\n├───jlab_ext_example\n│       handlers.py             # API handler (where things happen)\n│       _version.py             # Server extension version\n│       __init__.py             # Hook the extension in the server\n│  \n│  # Frontend Files\n│   .eslintignore               # Code linter configuration\n│   .eslintrc.js\n│   .prettierignore             # Code formatter configuration\n│   .prettierrc\n│   package.json                # Information about the frontend package\n│   tsconfig.json               # Typescript compilation configuration\n│  \n├───src\n│       index.ts                # Actual code of the extension\n│       handler.ts       # More code used by the extension\n│\n└───style\n        base.css               # CSS styling\n        index.css\n        index.js\n```\n\nThere are two major parts in the extension:\n\n- A Python package for the server extension and the packaging\n- A NPM package for the frontend extension\n\nIn this example, you will see that the template code have been extended\nto demonstrate the use of GET and POST HTTP requests.\n\n## Frontend Part\n\nThe entry point for the frontend extension is `src/index.ts`. The\ncommunication with the server extension is contained in another file\n`src/handler.ts`. So you need to import it:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L12-L12\n\nimport { requestAPI } from './handler';\n```\n<!-- prettier-ignore-end -->\n\nIn the `activate` function, the server extension is first called through\na GET request on the endpoint _/jlab-ext-example/hello_. The response from the server\nis printed in the web browser console:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L36-L42\n\n// GET request\ntry {\n  const data = await requestAPI<any>('hello');\n  console.log(data);\n} catch (reason) {\n  console.error(`Error on GET /jlab-ext-example/hello.\\n${reason}`);\n}\n```\n<!-- prettier-ignore-end -->\n\nAs the server response is not instantaneous, the request is done asynchronously\nusing the `await` keyword:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L38-L38\n\nconst data = await requestAPI<any>('hello');\n```\n<!-- prettier-ignore-end -->\n\nTo use that `await` keyword, the function must be declared as asynchronous\nusing the `async` keyword:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L29-L33\n\nactivate: async (\n  app: JupyterFrontEnd,\n  palette: ICommandPalette,\n  launcher: ILauncher | null\n) => {\n```\n<!-- prettier-ignore-end -->\n\nA GET request cannot carry data from the frontend to the server. To achieve that,\nyou will need to execute a POST request. In this example, a POST request\nis sent to the _/jlab-ext-example/hello_ endpoint with the data `{name: 'George'}`:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L45-L56\n\nconst dataToSend = { name: 'George' };\ntry {\n  const reply = await requestAPI<any>('hello', {\n    body: JSON.stringify(dataToSend),\n    method: 'POST',\n  });\n  console.log(reply);\n} catch (reason) {\n  console.error(\n    `Error on POST /jlab-ext-example/hello ${dataToSend}.\\n${reason}`\n  );\n}\n```\n<!-- prettier-ignore-end -->\n\nThe difference with the GET request is the use of the `body` option to send data\nand the `method` option to set the appropriate HTTP method.\n\nThe data sent from the frontend to the backend can have different types. In\nJupyterLab, the most common format is JSON. But JSON cannot directly be sent to\nthe server, it needs to be stringified to be carried over by the request.\n\nThe communication logic with the server is hidden in the `requestAPI` function.\nIts definition is :\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L12-L37\n\nexport async function requestAPI<T>(\n  endPoint = '',\n  init: RequestInit = {}\n): Promise<T> {\n  // Make request to Jupyter API\n  const settings = ServerConnection.makeSettings();\n  const requestUrl = URLExt.join(\n    settings.baseUrl,\n    'jlab-ext-example',\n    endPoint\n  );\n\n  let response: Response;\n  try {\n    response = await ServerConnection.makeRequest(requestUrl, init, settings);\n  } catch (error) {\n    throw new ServerConnection.NetworkError(error);\n  }\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new ServerConnection.ResponseError(response, data.message);\n  }\n\n  return data;\n```\n<!-- prettier-ignore-end -->\n\nFirst the server settings are obtained from:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L17-L17\n\nconst settings = ServerConnection.makeSettings();\n```\n<!-- prettier-ignore-end -->\n\nThis requires to add `@jupyterlab/services` to the package dependencies:\n\n```bash\njlpm add @jupyterlab/services\n```\n\nThen the class `ServerConnection` can be imported:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L3-L3\n\nimport { ServerConnection } from '@jupyterlab/services';\n```\n<!-- prettier-ignore-end -->\n\nThe next step is to build the full request URL:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L18-L21\n\nconst requestUrl = URLExt.join(\n  settings.baseUrl,\n  'jlab-ext-example',\n  endPoint\n```\n<!-- prettier-ignore-end -->\n\nTo concatenate the various parts, the `URLExt` utility is imported:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L1-L1\n\nimport { URLExt } from '@jupyterlab/coreutils';\n```\n<!-- prettier-ignore-end -->\n\nThis requires to add another dependency to the package:\n\n```bash\njlpm add @jupyterlab/coreutils\n```\n\nYou now have all the elements to make the request:\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L26-L26\n\nresponse = await ServerConnection.makeRequest(requestUrl, init, settings);\n```\n<!-- prettier-ignore-end -->\n\nFinally, once the server response is obtained, its body is interpreted as\nJSON. And the resulting data is returned.\n\n<!-- prettier-ignore-start -->\n```ts\n// src/handler.ts#L31-L37\n\nconst data = await response.json();\n\nif (!response.ok) {\n  throw new ServerConnection.ResponseError(response, data.message);\n}\n\nreturn data;\n```\n<!-- prettier-ignore-end -->\n\nThis example also showcases how you can serve static files from the server extension.\n\n<!-- prettier-ignore-start -->\n```ts\n// src/index.ts#L58-L79\n\nconst { commands, shell } = app;\nconst command = CommandIDs.get;\nconst category = 'Extension Examples';\n\ncommands.addCommand(command, {\n  label: 'Get Server Content in a IFrame Widget',\n  caption: 'Get Server Content in a IFrame Widget',\n  execute: () => {\n    const widget = new IFrameWidget();\n    shell.add(widget, 'main');\n  },\n});\n\npalette.addItem({ command, category: category });\n\nif (launcher) {\n  // Add launcher\n  launcher.add({\n    command: command,\n    category: category,\n  });\n}\n```\n<!-- prettier-ignore-end -->\n\nInvoking the command (via the command palette or the launcher) will open a new tab with\nan `IFrame` that will display static content fetched from the server extension.\n\n**Note**\n\n- If the response is not ok (i.e. status code not in range 200-299),\n  a `ResponseError` is thrown.\n- The response body is interpreted as JSON even in case the response is not\n  ok. In JupyterLab, it is a good practice in case of error on the server\n  side to return a response with a JSON body. It should at least define a\n  `message` key providing nice error message for the user.\n\n## Backend (Server) Part\n\nThe server part of the extension is going to be presented in this section.\n\nJupyterLab server is built on top of the [Tornado](https://www.tornadoweb.org/en/stable/guide.html) Python package. To extend the server,\nyour extension needs to be defined as a proper Python package with some hook functions:\n\n```py\n# jlab_ext_example/__init__.py\n\nimport json\nfrom pathlib import Path\n\nfrom .handlers import setup_handlers\nfrom ._version import __version__\n\nHERE = Path(__file__).parent.resolve()\n\nwith (HERE / \"labextension\" / \"package.json\").open() as fid:\n    data = json.load(fid)\n\n\ndef _jupyter_labextension_paths():\n    return [{\"src\": \"labextension\", \"dest\": data[\"name\"]}]\n\n\ndef _jupyter_server_extension_points():\n    return [{\"module\": \"jlab_ext_example\"}]\n\n\ndef _load_jupyter_server_extension(server_app):\n    \"\"\"Registers the API handler to receive HTTP requests from the frontend extension.\n    Parameters\n    ----------\n    server_app: jupyterlab.labapp.LabApp\n        JupyterLab application instance\n    \"\"\"\n    url_path = \"jlab-ext-example\"\n    setup_handlers(server_app.web_app, url_path)\n    server_app.log.info(\n        f\"Registered jlab_ext_example extension at URL path /{url_path}\"\n    )\n\n# For backward compatibility with the classical notebook\nload_jupyter_server_extension = _load_jupyter_server_extension\n\n```\n\nThe `_jupyter_server_extension_points` provides the Python package name\nto the server. But the most important one is `_load_jupyter_server_extension`\nthat register new handlers.\n\n```py\n# jlab_ext_example/__init__.py#L29-L29\n\nsetup_handlers(server_app.web_app, url_path)\n```\n\nA handler is registered in the web application by linking an url to a class. In this\nexample the url is _base_server_url_`/jlab-ext-example/hello` and the class handler is `RouteHandler`:\n\n```py\n# jlab_ext_example/handlers.py#L28-L34\n\nhost_pattern = \".*$\"\nbase_url = web_app.settings[\"base_url\"]\n\n# Prepend the base_url so that it works in a JupyterHub setting\nroute_pattern = url_path_join(base_url, url_path, \"hello\")\nhandlers = [(route_pattern, RouteHandler)]\nweb_app.add_handlers(host_pattern, handlers)\n```\n\nFor Jupyter server, the handler class must inherit from the `APIHandler` and it should\nimplement the wanted HTTP verbs. For example, here, `/jlab-ext-example/hello` can be requested\nby a _GET_ or a _POST_ request. They will call the `get` or `post` method respectively.\n\n```py\n# jlab_ext_example/handlers.py#L11-L24\n\nclass RouteHandler(APIHandler):\n    # The following decorator should be present on all verb methods (head, get, post,\n    # patch, put, delete, options) to ensure only authorized user can request the\n    # Jupyter server\n    @tornado.web.authenticated\n    def get(self):\n        self.finish(json.dumps({\"data\": \"This is /jlab-ext-example/hello endpoint!\"}))\n\n    @tornado.web.authenticated\n    def post(self):\n        # input_data is a dictionary with a key \"name\"\n        input_data = self.get_json_body()\n        data = {\"greetings\": \"Hello {}, enjoy JupyterLab!\".format(input_data[\"name\"])}\n        self.finish(json.dumps(data))\n```\n\n**Security Note**\n\n> The methods to handle request like `get`, `post`, etc.\n> must be decorated with `tornado.web.authenticated` to ensure only\n> authenticated users can request the Jupyter server.\n\nOnce the server has carried out the appropriate task, the handler should finish the request\nby calling the `finish` method. That method can optionally take an argument that will\nbecome the response body of the request in the frontend.\n\n```py\n# jlab_ext_example/handlers.py#L16-L17\n\ndef get(self):\n    self.finish(json.dumps({\"data\": \"This is /jlab-ext-example/hello endpoint!\"}))\n```\n\nIn Jupyter, it is common to use JSON as format between the frontend and the backend.\nBut it should first be stringified to be a valid response body. This can be done using\n`json.dumps` on a dictionary.\n\nA _POST_ request is similar to a _GET_ request except it may have a body containing data\nsent by the frontend. When using JSON as communication format, you can directly use the\n`get_json_body` helper method to convert the request body into a Python dictionary.\n\n```py\n# jlab_ext_example/handlers.py#L22-L23\n\ninput_data = self.get_json_body()\ndata = {\"greetings\": \"Hello {}, enjoy JupyterLab!\".format(input_data[\"name\"])}\n```\n\nThe part responsible to serve static content with a `StaticFileHandler` handler\nis the following:\n\n```py\n# jlab_ext_example/handlers.py#L37-L43\n\ndoc_url = url_path_join(base_url, url_path, \"public\")\ndoc_dir = os.getenv(\n    \"JLAB_SERVER_EXAMPLE_STATIC_DIR\",\n    os.path.join(os.path.dirname(__file__), \"public\"),\n)\nhandlers = [(\"{}/(.*)\".format(doc_url), StaticFileHandler, {\"path\": doc_dir})]\nweb_app.add_handlers(\".*$\", handlers)\n```\n\n**Security Note**\n\n> The `StaticFileHandler` is not secured.\n> For enhanced security, please consider using `AuthenticatedFileHandler`.\n\n**Note**\n\n> Server extensions can be used for different frontends (like\n> JupyterLab and the classical Jupyter Notebook). Some additional\n> documentation is available in the [Notebook documentation](https://jupyter-notebook.readthedocs.io/en/stable/extending/handlers.html)\n\n## Packaging the Extension\n\n### Python Package Manager\n\nIn the previous sections, the acting code has been described. But there are other files\nwith the sole purpose of packaging the full extension nicely to help its distribution\nthrough package managers like `pip`.\n\n> Note: In particular, [`jupyter-packaging`](https://github.com/jupyter/jupyter-packaging) provides helpers to package and install JS files\n> with a Python package for Jupyter frontends (classical notebook,\n> JupyterLab,...).\n> As this package is a setup requirement, it needs to be specified in the `pyproject.toml` to be installed by `pip`.\n\nThe `setup.py` file is the entry point to describe package metadata:\n\n```py\n# setup.py\n\n\"\"\"\njlab_ext_example setup\n\"\"\"\nimport json\nimport sys\nfrom pathlib import Path\n\nimport setuptools\n\nHERE = Path(__file__).parent.resolve()\n\n# The name of the project\nname = \"jlab_ext_example\"\n\nlab_path = (HERE / name.replace(\"-\", \"_\") / \"labextension\")\n\n# Representative files that should exist after a successful build\nensured_targets = [\n    str(lab_path / \"package.json\"),\n    str(lab_path / \"static/style.js\")\n]\n\nlabext_name = \"@jupyterlab-examples/server-extension\"\n\ndata_files_spec = [\n    (\"share/jupyter/labextensions/%s\" % labext_name, str(lab_path.relative_to(HERE)), \"**\"),\n    (\"share/jupyter/labextensions/%s\" % labext_name, str(\".\"), \"install.json\"),\n    (\"etc/jupyter/jupyter_server_config.d\",\n     \"jupyter-config/server-config\", \"jlab_ext_example.json\"),\n    # For backward compatibility with notebook server\n    (\"etc/jupyter/jupyter_notebook_config.d\",\n     \"jupyter-config/nb-config\", \"jlab_ext_example.json\"),\n]\n\nlong_description = (HERE / \"README.md\").read_text()\n\n# Get the package info from package.json\npkg_json = json.loads((HERE / \"package.json\").read_bytes())\n\nsetup_args = dict(\n    name=name,\n    version=pkg_json[\"version\"],\n    url=pkg_json[\"homepage\"],\n    author=pkg_json[\"author\"][\"name\"],\n    author_email=pkg_json[\"author\"][\"email\"],\n    description=pkg_json[\"description\"],\n    license=pkg_json[\"license\"],\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=setuptools.find_packages(),\n    install_requires=[\n        \"jupyter_server>=1.6,<2\"\n    ],\n    zip_safe=False,\n    include_package_data=True,\n    python_requires=\">=3.6\",\n    platforms=\"Linux, Mac OS X, Windows\",\n    keywords=[\"Jupyter\", \"JupyterLab\", \"JupyterLab3\"],\n    classifiers=[\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Framework :: Jupyter\",\n    ],\n)\n\ntry:\n    from jupyter_packaging import (\n        wrap_installers,\n        npm_builder,\n        get_data_files\n    )\n    post_develop = npm_builder(\n        build_cmd=\"install:extension\", source_dir=\"src\", build_dir=lab_path\n    )\n    setup_args[\"cmdclass\"] = wrap_installers(post_develop=post_develop, ensured_targets=ensured_targets)\n    setup_args[\"data_files\"] = get_data_files(data_files_spec)\nexcept ImportError as e:\n    import logging\n    logging.basicConfig(format=\"%(levelname)s: %(message)s\")\n    logging.warning(\"Build tool `jupyter-packaging` is missing. Install it with pip or conda.\")\n    if not (\"--name\" in sys.argv or \"--version\" in sys.argv):\n        raise e\n\nif __name__ == \"__main__\":\n    setuptools.setup(**setup_args)\n\n```\n\nBut in this case, it is a bit more complicated to build the frontend extension and ship it\ndirectly with the Python package. To deploy simultaneously the frontend and the backend,\nthe frontend NPM package needs to be built and inserted in the Python package. This is\ndone using a special a dedicated builder following [PEP 517](https://www.python.org/dev/peps/pep-0517) from package [jupyter-packaging](https://github.com/jupyter/jupyter-packaging). Its configuration is done in `pyproject.toml`:\n\n```py\n# pyproject.toml\n\n[build-system]\nrequires = [\"jupyter_packaging~=0.10,<2\", \"jupyterlab~=3.1\"]\nbuild-backend = \"jupyter_packaging.build_api\"\n\n[tool.jupyter-packaging.options]\nskip-if-exists = [\"jlab_ext_example/labextension/static/style.js\"]\nensured-targets = [\"jlab_ext_example/labextension/static/style.js\", \"jlab_ext_example/labextension/package.json\"]\n\n[tool.jupyter-packaging.builder]\nfactory = \"jupyter_packaging.npm_builder\"\n\n[tool.jupyter-packaging.build-args]\nbuild_cmd = \"build:prod\"\nnpm = [\"jlpm\"]\n\n[tool.check-manifest]\nignore = [\"jlab_ext_example/labextension/**\", \"yarn.lock\", \".*\", \"package-lock.json\"]\n\n```\n\nIt will build the frontend NPM package through its _factory_:\n\n```py\n# pyproject.toml#L9-L14\n\n[tool.jupyter-packaging.builder]\nfactory = \"jupyter_packaging.npm_builder\"\n\n[tool.jupyter-packaging.build-args]\nbuild_cmd = \"build:prod\"\nnpm = [\"jlpm\"]\n```\n\nIt will ensure one of the generated files is `jlab_ext_example/labextension/package.json`:\n\n```py\n# pyproject.toml#L7-L7\n\nensured-targets = [\"jlab_ext_example/labextension/static/style.js\", \"jlab_ext_example/labextension/package.json\"]\n```\n\nIt will copy the NPM package in the Python package and force it to be copied in a place\nJupyterLab is looking for frontend extensions when the Python package is installed:\n\n```py\n# setup.py#L26-L26\n\n(\"share/jupyter/labextensions/%s\" % labext_name, str(lab_path.relative_to(HERE)), \"**\"),\n```\n\nThe last piece of configuration needed is the enabling of the server extension. This is\ndone by copying the following JSON file:\n\n<!-- prettier-ignore-start -->\n```json5\n// jupyter-config/server-config/jlab_ext_example.json\n\n{\n  \"ServerApp\": {\n    \"jpserver_extensions\": {\n      \"jlab_ext_example\": true\n    }\n  }\n}\n\n```\n<!-- prettier-ignore-end -->\n\nin the appropriate jupyter folder (`etc/jupyter/jupyter_server_config.d`):\n\n```py\n# setup.py#L28-L29\n\n(\"etc/jupyter/jupyter_server_config.d\",\n \"jupyter-config/server-config\", \"jlab_ext_example.json\"),\n```\n\nFor backward compatibility with the classical notebook, the old version of that file is copied in\n(`etc/jupyter/jupyter_notebook_config.d`):\n\n```py\n# setup.py#L31-L32\n\n(\"etc/jupyter/jupyter_notebook_config.d\",\n \"jupyter-config/nb-config\", \"jlab_ext_example.json\"),\n```\n\n### JupyterLab Extension Manager\n\nThe distribution as a Python package has been described in the previous subsection. But\nin JupyterLab, users have an extension manager at their disposal to find extensions. If,\nlike in this example, your extension needs a server extension, you should inform the\nuser about that dependency by adding the `discovery` metadata to your `package.json`\nfile:\n\n```json5\n// package.json#L74-L84\n\n\"jupyterlab\": {\n  \"discovery\": {\n    \"server\": {\n      \"managers\": [\n        \"pip\"\n      ],\n      \"base\": {\n        \"name\": \"jlab_ext_example\"\n      }\n    }\n  },\n```\n\nIn this example, the extension requires a `server` extension:\n\n```json5\n// package.json#L75-L75\n\n\"discovery\": {\n```\n\nAnd that server extension is available through `pip`:\n\n```json5\n// package.json#L76-L78\n\n\"server\": {\n  \"managers\": [\n    \"pip\"\n```\n\nFor more information on the `discovery` metadata, please refer to the [documentation](https://jupyterlab.readthedocs.io/en/stable/extension/extension_dev.html#ext-author-companion-packages).\n\n## Installing the Package\n\nWith the packaging described above, installing the extension is done in one command once the package is published on pypi.org:\n\n```bash\n# Install the server extension and\n# copy the frontend extension where JupyterLab can find it\npip install jlab_ext_example\n```\n\nAs developer, you might want to install the package in local editable mode.\nThis will shunt the installation machinery described above. Therefore the commands\nto get you set are:\n\n```bash\n# Install package in development mode\npip install -e .\n# Link your development version of the extension with JupyterLab\njupyter labextension develop . --overwrite\n# Enable the server extension\njupyter server extension enable jlab_ext_example\n# Rebuild extension Typescript source after making changes\njlpm run build\n```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/jupyterlab/extension-examples",
    "keywords": "Jupyter,JupyterLab,JupyterLab3",
    "license": "BSD-3-Clause",
    "maintainer": "",
    "maintainer_email": "",
    "name": "jlab-ext-example",
    "package_url": "https://pypi.org/project/jlab-ext-example/",
    "platform": "Linux",
    "project_url": "https://pypi.org/project/jlab-ext-example/",
    "project_urls": {
      "Homepage": "https://github.com/jupyterlab/extension-examples"
    },
    "release_url": "https://pypi.org/project/jlab-ext-example/0.1.0/",
    "requires_dist": [
      "jupyter-server (<2,>=1.6)"
    ],
    "requires_python": ">=3.6",
    "summary": "A minimal JupyterLab extension with backend and frontend parts.",
    "version": "0.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15436539,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "781c97e7f06f74dff2f34989fb5513140c4af42bd8d1a311bdcb9ab8411ef336",
          "md5": "579fdb7d68ba8204d76c9400c1bf4237",
          "sha256": "b22d39cb67b570ad13c1112d26bd68ba752fe53e0d8c9613fb3344c566627403"
        },
        "downloads": -1,
        "filename": "jlab_ext_example-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "579fdb7d68ba8204d76c9400c1bf4237",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 78704,
        "upload_time": "2022-10-17T13:19:58",
        "upload_time_iso_8601": "2022-10-17T13:19:58.962480Z",
        "url": "https://files.pythonhosted.org/packages/78/1c/97e7f06f74dff2f34989fb5513140c4af42bd8d1a311bdcb9ab8411ef336/jlab_ext_example-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e05f9433f26a77d4114b12ffdbe771de6ab1c3606979304635eb323a04d80992",
          "md5": "e02b8c4f266c33471ee9b1ecac486cc5",
          "sha256": "a67fd680744ab43d5bd5335acb6b5e5ca69971b5872c2a0ce8a21a9be8de8daa"
        },
        "downloads": -1,
        "filename": "jlab_ext_example-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e02b8c4f266c33471ee9b1ecac486cc5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 44949,
        "upload_time": "2022-10-17T13:20:02",
        "upload_time_iso_8601": "2022-10-17T13:20:02.009649Z",
        "url": "https://files.pythonhosted.org/packages/e0/5f/9433f26a77d4114b12ffdbe771de6ab1c3606979304635eb323a04d80992/jlab_ext_example-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "781c97e7f06f74dff2f34989fb5513140c4af42bd8d1a311bdcb9ab8411ef336",
        "md5": "579fdb7d68ba8204d76c9400c1bf4237",
        "sha256": "b22d39cb67b570ad13c1112d26bd68ba752fe53e0d8c9613fb3344c566627403"
      },
      "downloads": -1,
      "filename": "jlab_ext_example-0.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "579fdb7d68ba8204d76c9400c1bf4237",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 78704,
      "upload_time": "2022-10-17T13:19:58",
      "upload_time_iso_8601": "2022-10-17T13:19:58.962480Z",
      "url": "https://files.pythonhosted.org/packages/78/1c/97e7f06f74dff2f34989fb5513140c4af42bd8d1a311bdcb9ab8411ef336/jlab_ext_example-0.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e05f9433f26a77d4114b12ffdbe771de6ab1c3606979304635eb323a04d80992",
        "md5": "e02b8c4f266c33471ee9b1ecac486cc5",
        "sha256": "a67fd680744ab43d5bd5335acb6b5e5ca69971b5872c2a0ce8a21a9be8de8daa"
      },
      "downloads": -1,
      "filename": "jlab_ext_example-0.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "e02b8c4f266c33471ee9b1ecac486cc5",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 44949,
      "upload_time": "2022-10-17T13:20:02",
      "upload_time_iso_8601": "2022-10-17T13:20:02.009649Z",
      "url": "https://files.pythonhosted.org/packages/e0/5f/9433f26a77d4114b12ffdbe771de6ab1c3606979304635eb323a04d80992/jlab_ext_example-0.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}