{
  "info": {
    "author": "Gaëtan Harter, Leandro Lanzieri, Martine S. Lenders",
    "author_email": "gaetan.harter@fu-berlin.de, leandro.lanzieri@haw-hamburg.de, m.lenders@fu-berlin.de",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Environment :: Console",
      "Intended Audience :: End Users/Desktop",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Utilities"
    ],
    "description": "RIOT Ctrl\n=========\n\nThis provides python object abstraction of a RIOT device.\nThe first goal is to be the starting point for the serial abstraction and\nbuild on top of that to provide higher level abstraction like over the shell.\n\nIt could provide an RPC interface to a device in Python over the serial port\nand maybe also over network.\n\nThe goal is here to be test environment agnostic and be usable in any test\nframework and also without it.\n\n\nTesting\n-------\n\nRun `tox` to run the whole test suite:\n\n::\n\n    tox\n    ...\n    ________________________________ summary ________________________________\n      test: commands succeeded\n      lint: commands succeeded\n      flake8: commands succeeded\n      congratulations :)\n\nUsage\n-----\n\nRIOTCtrl provides a python object abstraction of a RIOT device. It’s\nmeant as a starting point for any serial abstraction on which higher\nlevel abstractions (like a shell) can be built.\n\n.. code:: python\n\n    from riotctrl.ctrl import RIOTCtrl\n\n    env = {'BOARD': 'native'}\n    # if not running from the application directory the a path must be provided\n    ctrl = RIOTCtrl(env=env, application_directory='.')\n    # flash the application\n    ctrl.make_run(['flash'])\n    # run the terminal through a contextmanager\n    with ctrl.run_term():\n        ctrl.term.expect('>')       # wait for shell to start\n        ctrl.term.sendline(\"help\")  # send the help command\n        ctrl.term.expect('>')       # wait for the command result to finnish\n        print(ctrl.term.before)     # print the command result\n    # run without a contextmanager\n    ctrl.start_term()               # start a serial terminal\n    ctrl.term.sendline(\"help\")      # send the help command\n    ctrl.term.expect('>')           # wait for the command result to finnish\n    print(ctrl.term.before)         # print the command result\n    ctrl.stop_term()                # close the terminal\n\nCreating a RIOTCtrl object is done via environments. If empty then all\nconfiguration will come from the target application makefile. But any\nMake environment variable can be overridden, for example setting\n``BOARD`` to a target ``BOARD`` which is not the default for that\napplication.\n\nAny make target used on RIOT devices can be used on the abstraction\nlike: ``make flash`` => ``ctrl.make_run(['flash'])``.\n\n``ctrl.start_term()`` (``make term``\\ ’s alter ego) by default spawns a\n`pexpect <https://pexpect.readthedocs.io/en/stable/overview.html>`__\nchild application. From there interactions with the application\nunder use can be atomized. In the example below the output of the\n``\"help\"`` command is captured:\n\nShellInteractions\n~~~~~~~~~~~~~~~~~\n\nRIOTCtrl provides a minimal extensions by using:\n`pexpect replwrap <https://pexpect.readthedocs.io/en/stable/api/replwrap.html>`__\n“[A] Generic wrapper for read-eval-print-loops, a.k.a. interactive shells”.\nThis implements a nice wrapper for RIOT shell commands since it will wait for a\ncommand to finish before returning its output.\n\nRIOT already provides a ``ShellInteraction`` for the ``\"help\"`` command as well\nas many others. To make importing them as ``from riotctrl_shell.sys import Help``\npossible RIOT's `pythonlibs <https://github.com/RIOT-OS/RIOT/tree/master/dist/pythonlibs>`__\nneeds to be part of the ``PYTHONPATH``, this can be done by setting in the environment\n``PYTHONPATH=$PYTHONPATH:${RIOTBASE}/dist/pythonlibs`` or doing so in the\nscript ``sys.path.append('/path/to/RIOTBASE/dist/pythonlibs')``\n\nThe previous example can be re-written using ``ShellInteraction``:\n\n.. code:: python\n\n    from riotctrl.ctrl import RIOTCtrl\n    from riotctrl.shell import ShellInteraction\n\n    env = {'BOARD': 'native'}\n    # if not running from the application directory the a path must be provided\n    ctrl = RIOTCtrl(env=env, application_directory='.')\n    # flash the application\n    ctrl.flash()                     # alias for ctrl.make_run(['flash'])\n    # shell interaction instance\n    shell = ShellInteraction(ctrl)\n    shell.start_term()               # start a serial terminal\n    print(shell.cmd(\"help\"))         # print the command result\n    shell.stop_term()                # close the terminal\n\nor using the already provided `Help <https://github.com/RIOT-OS/RIOT/blob/master/dist/pythonlibs/riotctrl_shell/sys.py#L16-L21>`__\n``ShellInteraction``:\n\n.. code:: python\n\n    from riotctrl.ctrl import RIOTCtrl\n    from riotctrl_shell.sys import Help\n\n    env = {'BOARD': 'native'}\n    # if not running from the application directory the a path must be provided\n    ctrl = RIOTCtrl(env=env, application_directory='.')\n    # flash the application\n    ctrl.flash()                     # alias for ctrl.make_run(['flash'])\n    # shell interaction instance, Help uses the @ShellInteraction.check_term\n    # decorator, it will start the terminal if its not yet running, and close\n    # it after the command ends\n    shell = Help(ctrl)              # create ShellInteraction\n    print(shell.help())             # print the command result\n\nWriting ShellInteraction\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLets use this simple C shell application as an example:\n\n.. code:: c\n\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include \"shell.h\"\n\n    static unsigned int counter = 0;\n\n    static int _cmd_counter(int argc, char **argv)\n    {\n        if (argc == 1) {\n            printf(\"counter: %d\\n\", counter);\n        }\n        else if (argc == 2) {\n            counter += atoi(argv[1]);\n        }\n        else {\n            puts(\"Usage: counter [value]\");\n            return -1;\n        }\n        return 0;\n    }\n\n    static const shell_command_t shell_commands[] = {\n        { \"counter\", \"prints current counter or adds input\", _cmd_counter },\n        { NULL, NULL, NULL }\n    };\n\n    int main(void)\n    {\n        char line_buf[SHELL_DEFAULT_BUFSIZE];\n\n        shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);\n\n        return 0;\n    }\n\nThis simple command allows to return the current counter value or modifying\nby adding a value to it.\n\n::\n\n    main(): This is RIOT! (Version: 2021.10-devel-645-g2c3266-pr_kconfig_mtd)\n    > boardinfo\n    board: native\n    cpu: native\n    > counter 5\n    > counter -3\n    > counter\n    counter: 2\n\nA ``ShellInteraction`` for this could look as follows:\n\n.. code:: python\n\n    from riotctrl.shell import ShellInteraction\n\n\n    class CounterCmdShell(ShellInteraction):\n        @ShellInteraction.check_term\n        def counter_cmd(self, args=None, timeout=-1, async_=False):\n            cmd = \"counter\"\n            if args is not None:\n                cmd += \" {args}\".format(args=\" \".join(str(a) for a in args))\n            return self.cmd(cmd, timeout=timeout, async_=False)\n\nParsing Interaction Results\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nParsers can be written for the result of ShellInteraction commands,\nthese can then be returned in any format, for this a base class\nShellInteractionParser is provided where the ``parse()`` method needs to\nbe implemented.\n\nAn examples for the ``counter`` command\n\n.. code:: python\n\n    import re\n    from riotctrl.shell import ShellInteractionParser\n\n\n    class CounterCmdShellParser(ShellInteractionParser):\n        pattern = re.compile(r\"counter: (?P<counter>\\d+)$\")\n\n        def parse(self, cmd_output):\n            devices = None\n            for line in cmd_output.splitlines():\n                m = self.pattern.search(line)\n                if m is not None:\n                    return m.group[\"counter\"]\n\n.. code:: python\n\n    env = {'BOARD': 'native'}\n    # if not running from the application directory the a path must be provided\n    ctrl = RIOTCtrl(env=env, application_directory='.')\n    # flash the application\n    ctrl.flash()                     # alias for ctrl.make_run(['flash'])\n    # shell interaction instance\n    shell = CounterCmdShell(ctrl)\n     with ctrl.run_term():\n        parser = CounterCmdShellParser()\n        counter = parse.parse(shell_counter_cmd())\n        shell.counter_cmd(4)\n        assert counter + 4 = parse.parse(shell_counter_cmd())\n\nInteracting with multiple RIOT devices\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRIOTCtrl only wrap’s a single RIOT device, handling multiple devices is\nnot yet handled in RIOTCtrl, but through different environments multiple\nRIOT devices can be created and controlled.\n\nUsers of RIOT and `FIT IoT-LAB <https://www.iot-lab.info/>`__ may have\nalready ran experiments on multiple ctrls of the same type (e.g:\n``iotlab-m3``) using the ``IOTLAB_NODE`` make environment variable. With\nthis one can easily control which device it is targeting.\n\nBut if running this locally, with e.g.: multiple ``samr21-xpro``\nconnected the serial or ``DEBUG_ADAPTER_ID`` must be used to flash the\ncorrect device, and for some ``BOARD``\\ s also the serial port ``PORT``.\nThese variables can be appended to the environment of the spawned\nobject, e.g:\n\n-  `FIT IoT-LAB <https://www.iot-lab.info/>`__:\n\n.. code:: python\n\n    # first device using dwm1001-1 on the saclay site\n    env1 = {'BOARD': 'dwm10001', 'IOTLAB_NODE': 'dwm1001-1.saclay.iot-lab.info'}\n    ctrl1 = RIOTCtrl(env=env1, application_directory='.')\n    # second device using dwm1001-2 on the saclay site\n    env2 = {'BOARD': 'dwm10001', 'IOTLAB_NODE': 'dwm1001-2.saclay.iot-lab.info'}\n    ctrl2 = RIOTCtrl(env=env2, application_directory='.')\n\n-  locally:\n\n.. code:: python\n\n    # first samr21-xpro\n    env1 = {'BOARD': 'samr21-xpro', 'DEBUG_ADAPTER_ID': 'ATML2127031800004957'}\n    ctrl1 = RIOTCtrl(env=env1, application_directory='.')\n    # second samr21-xpro\n    env2 = {'BOARD': 'samr21-xpro', 'DEBUG_ADAPTER_ID': 'ATML2127031800011458'}\n    ctrl2 = RIOTCtrl(env=env2, application_directory='.')\n\nFor the advanced user one could also do as suggested in\n`multiple-boards-udev <https://api.riot-os.org/advanced-build-system-tricks.html#multiple-boards-udev>`__\nand use an easy to remember variable to identify BOARDs (which would\nallow also running the same python code on different setups), if\nfollowing the above guide:\n\n.. code:: python\n\n    # first samr21-xpro\n    env1 = {'BOARD': 'samr21-xpro', 'BOARD_NUM': 0}\n    ctrl1 = RIOTCtrl(env=env1, application_directory='.')\n    # second samr21-xpro\n    env2 = {'BOARD': 'samr21-xpro', 'BOARD_NUM': 1}\n    ctrl2 = RIOTCtrl(env=env2, application_directory='.')\n\nFactories\n~~~~~~~~~\n\nThe same tasks are done multiple times creating the object flashing it,\nstarting the terminal and making sure its clean up. Once experiments\ngrow and take over multiple ctrls this can become tedious, using a\nFactory together with a context manager can help with this.\n\nGoing back to our example lets write a factory inheriting from\n``RIOTCtrlBoardFactoryBase`` (or directly from ``RIOTCtrlFactoryBase``\nbase class).\n\n.. code:: python\n\n    from contextlib import ContextDecorator\n    from riotctrl.ctrl import RIOTCtrl, RIOTCtrlBoardFactory\n    from riotctrl_ctrl import native\n\n    class RIOTCtrlAppFactory(RIOTCtrlBoardFactory, ContextDecorator):\n\n        def __init__(self):\n            super().__init__(board_cls={\n                'native': native.NativeRIOTCtrl,\n            })\n            self.ctrl_list = list()\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, *exc):\n            for ctrl in self.ctrl_list:\n                ctrl.stop_term()\n\n        def get_ctrl(self, application_directory='.', env=None):\n            # retrieve a RIOTCtrl Object\n            ctrl = super().get_ctrl(\n                env=env,\n                application_directory=application_directory\n            )\n            # append ctrl to list\n            self.ctrl_list.append(ctrl)\n            # flash and start terminal\n            ctrl.flash()\n            ctrl.start_term()\n            # return ctrl with started terminal\n            return ctrl\n\nAnd the script itself can be re-written as:\n\n.. code:: python\n\n    with RIOTCtrlAppFactory() as factory:\n        env = {'BOARD': 'native'}\n        ctrl = factory.get_ctrl(env=env)\n        shell = SaulShell(ctrl)\n        parser = SaulShellCmdParser()\n        print(parser.parse(shell.saul_cmd()))\n\nGNRC Networking example native\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLets put all the above into practice and script an experiment verifying\nconnectivity between two ctrls, here multiple ``native`` instance will\nbe used.\n\nFirst create two tap interfaces connected through a bridge interface,\ne.g. on linux:\n\n.. code:: shell\n\n    ip link add name tapbr0 type bridge\n    ip link set tapbr0 up\n    ip tuntap add dev tap0 mode tap user $USER\n    ip tuntap add dev tap1 mode tap user $USER\n    ip link set dev tap0 master tapbr0\n    ip link set dev tap1 master tapbr0\n    ip link set dev tap0 up\n    ip link set dev tap1 up\n\nThen we can ping and parse the results asserting than packet loss is\nunder a threshold or that an mount of responses was received..\n\n.. code:: python\n\n    from riotctrl_shell.gnrc import GNRCICMPv6Echo, GNRCICMPv6EchoParser\n    from riotctrl_shell.netif import Ifconfig\n\n\n    class Shell(ifconfig, GNRCICMPv6Echo):\n      pass\n\n\n    with RIOTCtrlAppFactory() as factory:\n        # Create two native instances, specifying the tap interface\n        native_0 = factory.get_ctrl(env={'BOARD':'native', 'PORT':'tap0'})\n        native_1 = factory.get_ctrl(env={'BOARD':'native', 'PORT':'tap1'})\n        # `NativeRIOTCtrl` allows for `make reset` with `native`\n        native_0.reset()\n        native_1.reset()\n        # Perform a multicast ping and parse results\n        pinger = Shell(native_0)\n        parser = GNRCICMPv6EchoParser()\n        result = parser.parse(pinger.ping6(\"ff02::1\n        # assert packetloss is under 10%\"))\n        assert result['stats']['packet_loss'] < 10\n        # assert at least one responder\n        assert result['stats']['rx'] > 0\n\nA more complex example can be seen in the Release Tests:\n`04-single-hop-6lowpan-icmp <https://github.com/RIOT-OS/Release-Specs/blob/master/04-single-hop-6lowpan-icmp/test_spec04.py>`__\n\nExamples\n~~~~~~~~\n\n-  pytest: `ReleaseSpecs <https://github.com/RIOT-OS/Release-Specs>`__\n-  unittests:\n    `tests/turo <https://github.com/RIOT-OS/RIOT/blob/master/tests/turo/tests/01-run.py>`__,\n    `tests/congure_test <https://github.com/RIOT-OS/RIOT/blob/master/tests/congure_test/tests/01-run.py>`__\n\nDiscussion\n~~~~~~~~~~\n\nRIOTCtrl base class is not tied into having a serial based interaction, its\nthe most common usage so far but a new interface or ``Interaction`` could\nuse different different transports (e.g. COAP), and does not need to provide\na CLI type interface.\n\nTest applications could also use Structured Output, like RIOT's\n`turo <https://doc.riot-os.org/group__test__utils__result__output.html>`__,\nand in this case parsing CBOR/JSON/XML output could be close to a NOP.\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "https://github.com/RIOT-OS/riotctrl",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/RIOT-OS/riotctrl",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "riotctrl",
    "package_url": "https://pypi.org/project/riotctrl/",
    "platform": "",
    "project_url": "https://pypi.org/project/riotctrl/",
    "project_urls": {
      "Download": "https://github.com/RIOT-OS/riotctrl",
      "Homepage": "https://github.com/RIOT-OS/riotctrl"
    },
    "release_url": "https://pypi.org/project/riotctrl/0.5.0/",
    "requires_dist": null,
    "requires_python": ">=3.5",
    "summary": "RIOT Ctrl - A RIOT node python abstraction",
    "version": "0.5.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11505778,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7c92651d743afdd4c08cffa06099683e066884499b9fb3466e774e5eb08862b9",
          "md5": "a539e7d93581870ae712a864761a1ce8",
          "sha256": "29000e55776696398f2612fcc27bebeb63506e91bbf4faa70c9ecc5e5f419258"
        },
        "downloads": -1,
        "filename": "riotctrl-0.1.0.zip",
        "has_sig": false,
        "md5_digest": "a539e7d93581870ae712a864761a1ce8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 11944,
        "upload_time": "2020-07-07T14:18:54",
        "upload_time_iso_8601": "2020-07-07T14:18:54.540368Z",
        "url": "https://files.pythonhosted.org/packages/7c/92/651d743afdd4c08cffa06099683e066884499b9fb3466e774e5eb08862b9/riotctrl-0.1.0.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0343cc997d318f84a0231096969004199273a2e04c952a75848b285875200d46",
          "md5": "1c0db70292d8735d5a72c55acc000140",
          "sha256": "877040b4a4dae6ae217fc17cd212406112230af9051bd8b664e4527696aa12e0"
        },
        "downloads": -1,
        "filename": "riotctrl-0.1.1.zip",
        "has_sig": false,
        "md5_digest": "1c0db70292d8735d5a72c55acc000140",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 12022,
        "upload_time": "2020-08-05T08:33:47",
        "upload_time_iso_8601": "2020-08-05T08:33:47.297253Z",
        "url": "https://files.pythonhosted.org/packages/03/43/cc997d318f84a0231096969004199273a2e04c952a75848b285875200d46/riotctrl-0.1.1.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ac6e4995a958d6d008593e2f213452bf20cc7698978ceb1ce9f16ebcf712d30a",
          "md5": "5316cabffa2b587b6395ce7878e20a9b",
          "sha256": "81b552b754d97118d1844c6578f818ec16d00f0fb36439d9628bd4a1d665f6bc"
        },
        "downloads": -1,
        "filename": "riotctrl-0.2.0.zip",
        "has_sig": false,
        "md5_digest": "5316cabffa2b587b6395ce7878e20a9b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 13788,
        "upload_time": "2021-01-22T10:35:50",
        "upload_time_iso_8601": "2021-01-22T10:35:50.022704Z",
        "url": "https://files.pythonhosted.org/packages/ac/6e/4995a958d6d008593e2f213452bf20cc7698978ceb1ce9f16ebcf712d30a/riotctrl-0.2.0.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "73ae1a0b6fd5e21ff203b4b650992e0e8bcfd1cdfaf29912e356ccbc44488199",
          "md5": "08a4da2d107921a06dca31b7df975c89",
          "sha256": "3de9c1e0079fda5d24b4d557884c28adeee49b7b500e2a9a86b97e09dc196d20"
        },
        "downloads": -1,
        "filename": "riotctrl-0.2.1.zip",
        "has_sig": false,
        "md5_digest": "08a4da2d107921a06dca31b7df975c89",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 13778,
        "upload_time": "2021-01-22T11:13:14",
        "upload_time_iso_8601": "2021-01-22T11:13:14.562886Z",
        "url": "https://files.pythonhosted.org/packages/73/ae/1a0b6fd5e21ff203b4b650992e0e8bcfd1cdfaf29912e356ccbc44488199/riotctrl-0.2.1.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b05207c73d2e0e1035fce8a4e4784f372826cd70d4b0137180d4706351587d88",
          "md5": "f48275bd8f339ba625eaf868baa7776b",
          "sha256": "aa776061bafcc5248599c141ea5e67ea691a3f2cdee1430fa356d928b37470d1"
        },
        "downloads": -1,
        "filename": "riotctrl-0.2.2.zip",
        "has_sig": false,
        "md5_digest": "f48275bd8f339ba625eaf868baa7776b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 13826,
        "upload_time": "2021-01-28T16:04:14",
        "upload_time_iso_8601": "2021-01-28T16:04:14.089991Z",
        "url": "https://files.pythonhosted.org/packages/b0/52/07c73d2e0e1035fce8a4e4784f372826cd70d4b0137180d4706351587d88/riotctrl-0.2.2.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "faa6afab52f8e26f5b3a03793a1fc45627efe74a0df66c8edc44e4b109944978",
          "md5": "1068364b2b8edd8bfdfbca7c5359f72f",
          "sha256": "fb5ff7b33b2023736254c3cb8a6b02e7852e3f35dd7f04b6cf9c376bbea4e345"
        },
        "downloads": -1,
        "filename": "riotctrl-0.3.0.zip",
        "has_sig": false,
        "md5_digest": "1068364b2b8edd8bfdfbca7c5359f72f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 13844,
        "upload_time": "2021-02-12T14:28:09",
        "upload_time_iso_8601": "2021-02-12T14:28:09.138730Z",
        "url": "https://files.pythonhosted.org/packages/fa/a6/afab52f8e26f5b3a03793a1fc45627efe74a0df66c8edc44e4b109944978/riotctrl-0.3.0.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eb2d85b5f35323d62ad07d8387c2e8097d865942b0b09542366ad5414640320d",
          "md5": "a980f146b80382df6791d560a9575eb7",
          "sha256": "44e3341e9c1cf8532a00d1690cf9048ae616704b8ce5e6f4dc8bb3f0bfe0a01c"
        },
        "downloads": -1,
        "filename": "riotctrl-0.3.1.zip",
        "has_sig": false,
        "md5_digest": "a980f146b80382df6791d560a9575eb7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 13855,
        "upload_time": "2021-02-12T15:06:35",
        "upload_time_iso_8601": "2021-02-12T15:06:35.998558Z",
        "url": "https://files.pythonhosted.org/packages/eb/2d/85b5f35323d62ad07d8387c2e8097d865942b0b09542366ad5414640320d/riotctrl-0.3.1.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "592aaf5d16657423f1ee8566f7352367b6ea494b14a00dd3f99d660e54a7eee6",
          "md5": "5fd135c5b560ad732b6cf8f16d2cfb09",
          "sha256": "fc6843c963da154cca1762b2ed9769cc23a5432a65a573bdd8fbe4a527e5f35a"
        },
        "downloads": -1,
        "filename": "riotctrl-0.4.0.zip",
        "has_sig": false,
        "md5_digest": "5fd135c5b560ad732b6cf8f16d2cfb09",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 15102,
        "upload_time": "2021-02-18T10:56:10",
        "upload_time_iso_8601": "2021-02-18T10:56:10.362950Z",
        "url": "https://files.pythonhosted.org/packages/59/2a/af5d16657423f1ee8566f7352367b6ea494b14a00dd3f99d660e54a7eee6/riotctrl-0.4.0.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2733b8184879bc08330d40e79fd983e4be87566e284b209825bb440508421aef",
          "md5": "987a01edf3984dda5abab4c7b1dccf12",
          "sha256": "69e5160739316d05c5b190acadf2e2fa67d0e3917f2343689af8e598deb88c49"
        },
        "downloads": -1,
        "filename": "riotctrl-0.4.1.zip",
        "has_sig": false,
        "md5_digest": "987a01edf3984dda5abab4c7b1dccf12",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 15274,
        "upload_time": "2021-03-03T08:15:38",
        "upload_time_iso_8601": "2021-03-03T08:15:38.090776Z",
        "url": "https://files.pythonhosted.org/packages/27/33/b8184879bc08330d40e79fd983e4be87566e284b209825bb440508421aef/riotctrl-0.4.1.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dee81f1055d759a9b6803b21ec7e626be3dc5840f138df4bc20229a0c756aced",
          "md5": "77dea11935ecaf5cf9ddeb0abb764b98",
          "sha256": "b3746218bd68d7cac02eff3527fe287f2b9c4d6c28ef0799c50923399847195b"
        },
        "downloads": -1,
        "filename": "riotctrl-0.5.0.zip",
        "has_sig": false,
        "md5_digest": "77dea11935ecaf5cf9ddeb0abb764b98",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 29626,
        "upload_time": "2021-09-21T09:48:29",
        "upload_time_iso_8601": "2021-09-21T09:48:29.774008Z",
        "url": "https://files.pythonhosted.org/packages/de/e8/1f1055d759a9b6803b21ec7e626be3dc5840f138df4bc20229a0c756aced/riotctrl-0.5.0.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "dee81f1055d759a9b6803b21ec7e626be3dc5840f138df4bc20229a0c756aced",
        "md5": "77dea11935ecaf5cf9ddeb0abb764b98",
        "sha256": "b3746218bd68d7cac02eff3527fe287f2b9c4d6c28ef0799c50923399847195b"
      },
      "downloads": -1,
      "filename": "riotctrl-0.5.0.zip",
      "has_sig": false,
      "md5_digest": "77dea11935ecaf5cf9ddeb0abb764b98",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.5",
      "size": 29626,
      "upload_time": "2021-09-21T09:48:29",
      "upload_time_iso_8601": "2021-09-21T09:48:29.774008Z",
      "url": "https://files.pythonhosted.org/packages/de/e8/1f1055d759a9b6803b21ec7e626be3dc5840f138df4bc20229a0c756aced/riotctrl-0.5.0.zip",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}