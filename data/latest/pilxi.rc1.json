{
  "info": {
    "author": "",
    "author_email": "Pickering Interfaces <support@pickeringtest.com>",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# Python Pilxi #\r\n\r\nPython Pilxi is a Python wrapper for Pickering ClientBridge driver. It supports both Python 2.x and 3.x.\r\n\r\n----------\r\n# Change Log #\r\n\r\n> - 5.0 - Adds SetAttributeDWORD, SetAttributeDWORDArray, SetAttributeDouble, SetAttributeByte and its getters. Adds DioAllPortData function.\r\n> - 4.9 - Adds ResSetResistance() mode enum and optional parameter to pilxi (brings pilxi version to 2.0.3)\r\n> - 4.8 - Adds calibration functions to pilxi (brings pilxi version to 2.0.2)\r\n> - 4.7 - Adds example code for Precision Resistor cards \r\n> - 4.6 - Fixes issues in pi743lx findInstrumentsRsrc(), wrapper changes to prevent namespace pollution by ctypes.\r\n> - 4.5: \r\n>   - Introduces individual version numbering for all packages\r\n>   - Updated LXI_PXM78xx module -> support Trigger Matrix, Timer/Counter groups\r\n>   - Updates battery simulator functionality, including set-measure-set mode and measurement configuration.\r\n>   - Updates example code, including battery simulator example and adds Example_ListCards.py \r\n> - 4.4 - Imported LXI_PXM78xx module support (VX Instrument's PXM78xx DMM modules)\r\n> - 4.3 - Updates LVDT/resolver functionality and adds Battery Simulator measurement methods \r\n> - 4.2 - Adds example for multiuser access\r\n> - 4.1 - Fixes issue with ReadSub and ViewSub \r\n> - 4.0 - Changes to API to add more object-oriented features, exceptions, adds 41-620 and 41-743 support, current loop simulator, 40-419 DIO card, etc.\r\n> - 3.18 - Updates to use native strings in Python 2.x/3.x, adds `pi_base.ErrorCodeToMessage()` and `pi_comm.ErrorCodeToMessage()`\r\n> - 3.17 - Adds pi_card.SetCrosspointRange\r\n         - Adds Thermocouple Simulator Functions\r\n> - 3.16 - Fixes pi_card.WriteSub\r\n> - 3.15 - Adds new constructor and method for opening cards using aliases\r\n> - 3.14 - Changes to return interger value from calc_dwords(). \r\n> - 3.13 - Fixes pi_base.EchoDirectEx and pi_base.EchoDirectEx pi_base.GetAvailableLXIEntryEx functions (increased description buffer size) \r\n> - 3.12 - Adds version definition for all wrapper modules (plus function call definition to obtain information)\r\n> - 3.11 - Adds Power Sequencer Python 2 support\r\n> - 3.10 - Adds Power Sequencer support\r\n> - 3.9 - Fixes pi_cards.CloseCards, pi_cards.Close (closes connection properly once card is closed)\r\n> - 3.8 - Adds Linux Support\r\n> - 3.7 - Adds Thermocouple Functions and updates calling conventions to match change in ClientBridge\r\n> - 3.6 - Updates Calling Convetions to match recent change in ClientBridge\r\n> - 3.5 - Fixes Resistor ClientBridge Calls\r\n> - 3.4 - Refactor for use with pip installer\r\n        - Fixes Resistor functions\r\n\r\n----------\r\n# Installation Instructions #\r\n\r\nWe provide both a python module that can be installed to the system using `pip` and can be added manually to a project by copying a file into the directory that you are working in. For either installation method please make sure that you have installed ClientBridge. If you intend to use ClientBridge with PXI please make sure you also install Pickering PXI Installer Package. These can be found at the following addresses:\r\n\r\n - [PXI Installer Package](http://pickeringtest.info/downloads/drivers/PXI_Drivers/)\r\n - [ClientBridge Driver](http://pickeringtest.info/downloads/drivers/Sys60/)\r\n\r\nPlease note that there is an additional dependency 'enum34' for Python 2.x and Python 3.x versions < 3.4. This package must be installed prior to using the wrapper with older versions of Python. \r\n\r\n----------\r\n## Install Using `pip` ##\r\n\r\nTo install Python Pilxi using pip open a command line prompt and navigate to the directory the driver has been extracted to. From there enter the following command:\r\n```\r\npip install .\r\n```\r\n\r\n----------\r\n## Install Manually ##\r\n\r\nTo install Python Pilxi manually please copy pilxi directory containing `__init__.py` to your project. \r\n\r\n----------\r\n# Using Pilxi #\r\n\r\nPilxi can be used to control our 40/50/60 series pickering products.\r\n\r\n## Open a session with LXI ## \r\n\r\nIn order to query an LXI unit and open/operate cards, you must first open a session. This can be done by passing an IP address to the `pilxi.Pi_Session` constructor. To use local PXI cards, pass \"PXI\" in place of the IP address.\r\n```python \r\nimport pilxi\r\n\r\nIP_Address = \"192.168.1.1\"\r\n\r\ntry:\r\n    session = pilxi.Pi_Session(IP_Address)\r\n\r\nexcept pilxi.Error as ex:\r\n    print(\"Error occurred opening LXI session:\", ex.message)\r\n```\r\n\r\n## List cards ##\r\n\r\nTo get a list of the available cards IDs use `GetUsableCards()`. This will return a list of card IDs. To list the bus and slot number for all of the cards use `FindFreeCards()`, which takes in the total card count. Please see below for worked examples on how to use both of these functions:\r\n\r\n```python\r\nimport pilxi\r\n\r\n# Connect to chassis\r\nIP_Address = '192.168.1.1'\r\n\r\n# Port, timeout parameters are optional, defaults will be used otherwise.\r\nsession = pilxi.Pi_Session(IP_Address)\r\n# or \r\nsession = pilxi.Pi_Session(IP_Address, port=1024, timeout=5000)\r\n\r\n# Get list of Card IDs for cards in chassis\r\ncardID_array = session.GetUsableCards(0)\r\nprint(\"Card IDs:\", cardID_array)\r\n\r\n\r\n# Get list of Card Bus and Device Numbers\r\ncard_array = session.FindFreeCards()\r\n\r\nfor card in card_array:\r\n    bus, device = card\r\n    print(\"Card at bus {} device {}\".format(bus, device))\r\n```\r\n\r\n## Open Card ##\r\n\r\nThere are three ways to open a card:\r\n - Using the Bus and Device number\r\n - Using the Card ID and Access mode\r\n - Using an alias specified using Resource Manager\r\n\r\nTo open a card at a specific bus and device location, use `Pi_Session.OpenCard(bus, device)`. When opening a card with Bus and Slot number only one program can access the card at a time, which means that you cannot have another program monitor the card. To do that the card needs to be opened with the Card ID and specifying the Access mode to allow multiple programs at once. The Card ID can be obtained from the list of cards show in the earlier example. Please see below for a worked example on how to use `pi_card` in either way:\r\n\r\n```python\r\n# Open a card by bus and device:\r\nimport pilxi\r\n\r\ncard = session.OpenCard(bus, device)\r\n\r\n# accessType parameter is optional, default value is 1 (shared access)\r\n# see pilxi.AccessTypes enum for options\r\ncard = session.OpenCardByID(cardID, accessType=pilxi.AccessTypes.MULTIUSER)\r\n\r\n# Cards can be closed explicitly, garbage collection will close cards and sessions otherwise\r\ncard.Close()\r\n```\r\n\r\nAliases must be specified in the Resource Manager application. From there you can save a copy of the resource file locally which can be copied into your project directory for easy access. You can then open a card by alias using the `pilxi.Pi_Card_ByAlias` class:\r\n\r\n```python\r\nrsrcfile = \"LocalResources.rml\"\r\nalias = \"my_alias\"\r\n\r\n# Resource file, access type and timeout parameters are optional. \r\ncard = pilxi.Pi_Card_ByAlias(alias, rsrcfile, accessType=1, timeout=5000)\r\n\r\ncard.Close()\r\n```\r\n\r\n## Operate Switching cards ##\r\n\r\nThere are three main types of switching cards:\r\n    - Switches\r\n    - Multiplexer\r\n    - Matrix\r\n\r\nTo operate Switches and Multiplexers use `OpBit()` providing subunit, switch point, and switch state. Matrices can be controller using `OpCrosspoint()` which requires the subunit, row, column, and switch state. Please see below for worked examples on using these functions:\r\n\r\n```python\r\n# Control Switches and Multiplexer cards\r\nsubunit = 1\r\nswitchpoint = 1\r\n\r\nstate = True\r\ncard.OpBit(subunit, switchpoint, state)\r\n    \r\nstate = False\r\ncard.OpBit(subunit, switchpoint, state)\r\n\r\n\r\n# Control Matrix cards\r\nrow = 1\r\ncolumn = 1\r\ncard.OpCrosspoint(subunit, row, column, True)\r\n\r\ncard.OpCrosspoint(subunit, row, column, False)\r\n\r\n\r\n# Set a range of crosspoints on a given row \r\nstart = 1\r\nend = 8\r\ncard.SetCrosspointRange(subunit, row, start, end, 1)\r\n```\r\n\r\n### Using Subunit States ### \r\n\r\nThe Python-Pilxi wrapper contains methods to read entire subunit states, e.g. the current switch configuration of a switching or matrix card, manipulate these states and apply the state back to the card in one single operation. This means, for example, multiple crosspoints can be connected at once, or the user may have multiple desired matrix/switch states and alternate between them. \r\n\r\nExample for manipulating matrix card states:\r\n```python\r\n# Get an object representing the current state of the specified matrix subunit:\r\nsubState = card.GetSubState(subunit)\r\n\r\n# Set matrix crosspoints 1, 1 and 2, 2 on the subunit state;\r\n# No actual switching occurs yet.\r\nsubState.PreSetCrosspoint(1, 1, True)\r\nsubState.PreSetCrosspoint(2, 2, True)\r\n\r\n# Apply the subunit state.\r\n# Crosspoints changed will now be applied to the physical card. \r\ncard.WriteSubState(subunit, subState)\r\n```\r\nExample for manipulating switching card states:\r\n```python\r\n# Get an object representing the current state of the specified switch subunit:\r\nsubState = card.GetSubState(subunit)\r\n\r\n# Set switches 1 and 2 on the subunit state;\r\n# No actual switching occurs yet.\r\nsubState.PreSetBit(1, True)\r\nsubState.PreSetBit(2, True)\r\n\r\n# Apply the subunit state.\r\n# Switches changed will now be applied to the physical card. \r\ncard.WriteSubState(subunit, subState)\r\n```\r\nIt is also possible to obtain a subunit state object representing a clear subunit:\r\n```python\r\nblankSubunitState = card.GetBlankSubState(subunit)\r\n```\r\n\r\n## Operate Resistor Cards ##\r\n\r\nResistor cards come in two varieties: Programmable Resitor, and Presision Resistor. Programmable Resistors are controlled like Switch Cards shown above. Presision Resistor Cards have specific resistor functions. To set a resistance `ResSetResistance` is used and to get the current resistance `ResGetResistance` is used as shown below:\r\n\r\n```python\r\n# Set Resistance of given subunit, resistance value in Ohms\r\nmode = 0\r\nresistance = 330.0\r\n\r\ncard.ResSetResistance(subunit, resistance)\r\n\r\n# Retrive current resistance of given subunit\r\nresistance = card.ResGetResistance(subunit)\r\n\r\nprint(\"Resistance:\", resistance)\r\n\r\n# Set Resistance with specific mode:\r\n#    RES_Mode.SET                     # Legacy/Default mode to support existing break before make with settling delay\r\n#    RES_Mode.MBB                     # New mode to suport make before break with settling delay\r\n#    RES_Mode.APPLY_PATTERN_IMMEDIATE # Apply new pattern immediately and wait till settling delay\r\n#    RES_Mode.NO_SETTLING_DELAY       # Disable settling delay,same as DriverMode NO_WAIT, but at sub-unit level\r\n#    RES_Mode.DONT_SET                # Do the calculations but don't set the card\r\n\r\n# Set with make-before-break mode \r\nresistance = card.ResSetResistance(subunit, resistance, mode=pilxi.RES_Mode.MBB)\r\n\r\n\r\n```\r\n\r\n## Operate Attenuator ##\r\n\r\nAttenuators have specific functions for controlling them. To set attenuation use `SetAttenuation()` providing the subunit and attenuation expressed in decibels. To retrieve the current attenuation use `GetAttenuation()` giving the subunit. It returns an error code and the attenuation expressed in decibels. Please see below for worked examples on how to use these functions:\r\n\r\n```python\r\n# Setting Attenuation\r\nattenuation = 1.5     # Attenuation in dB\r\ncard.SetAttenuation(subunit, attenuation)\r\n\r\n# Retrieving Attenuation\r\nattenuation = card.GetAttenuation(subunit)\r\n\r\nprint(\"Attenuation (dB):\", attenuation)\r\n```\r\n\r\n## Operate Power Supply ##\r\n\r\nPower Supplies have specific functions for controlling them. To set voltage use `PsuSetVoltage()` providing the subunit and voltage. To retrieve voltage use `PsuGetVoltage()` giving the subunit. To enable output use `PsuEnable` providing the subunit and the state to be set. Please see below for worked examples on how to use these functions:\r\n\r\n```python\r\n# Set Voltage\r\nvolts = 3.3\r\ncard.PsuSetVoltage(subunit, volts)\r\n\r\n# Enable output\r\ncard.PsuEnable(subunit, 1)\r\n\r\n# Get Voltage\r\nvolts = card.PsuGetVoltage(subunit)\r\n\r\n# Disable output\r\ncard.PsuEnable(subunit, 0)\r\n```\r\n\r\n## Operate Battery Simulator ##\r\n\r\nBattery Simulators have specific methods for controlling them. To set voltage use `BattSetVoltage()` providing the subunit and voltage. To retrieve the voltage set use `BattGetVoltage()` giving the subunit. To set current use `BattSetcurrent()` providing the subunit and current. To retrieve the set current use `BattGetcurrent()` giving the subunit. To enable output use `BattSetEnable()` providing the subunit and the state to be set. To retrieve the present output state use `BattGetEnable()`. On supported Battery Simulator cards, real channel voltage and current can be measured back using `BattMeasureVoltage()` and `BattMeasureCurrentmA()` methods. Please see below for worked examples on how to use these functions:\r\n\r\n```python\r\nvolts = 3.3\r\ncurrent = 0.5\r\n\r\n# Set Voltage\r\ncard.BattSetVoltage(subunit, volts)\r\n\r\n# Set Current\r\ncard.BattSetCurrent(subunit, current)\r\n\r\n# Enable Output\r\ncard.BattSetEnable(subunit, True)\r\n\r\n# Get Voltage\r\nvolts = card.BattGetVoltage(subunit)\r\n\r\n# Set Current\r\ncurrent = card.BattGetCurrent(subunit)\r\n\r\n# Get Output state\r\nstate = card.BattGetEnable(subunit)\r\n```\r\n\r\nIf you attempt to enable the outputs of a battery simulator card without the hardware interlock, `BattSetEnable()` will throw an exception (error code 70, hardware interlock error). Therefore it is important to call functions in a `try` block and handle errors appropriately.\r\n\r\n### 41-752A-01x functionality \r\n\r\nThe 41-752A-01x battery simulator cards have extra capabilities beyond what is supported by other cards. Please consult your manual for information on your product's capabilities. Worked examples on using the extra functionality are below:\r\n\r\n```python\r\n# The following functionality is not supported by all battery simulator\r\n# cards. Please consult your product manual for information on your card's \r\n# functionality. \r\n\r\n# Enable set-measure-set mode (increases measurement accuracy on supported cards)\r\ncard.BattSetMeasureSet(subunit, True)\r\n\r\n# Configure measurement mode to alter device accuracy/sampling: \r\nnumSamples                  = pilxi.BattNumSamples.SAMPLES_128     # Average values after 128 samples\r\nVConversionTimePerSample    = pilxi.BattConversionTime.T_1052us    # 1052 us voltage sample time\r\nIConversionTimePerSample    = pilxi.BattConversionTime.T_540us     # 540 us current sample time\r\ntriggerMode                 = pilxi.BattOperationMode.CONTINUOUS   # Measure continuously (no wait for trigger)\r\n\r\ncard.BattSetMeasureConfig(subunit, numSamples, VConversionTimePerSample, IConversionTimePerSample, triggerMode)\r\n\r\n# The battery simulator (41-752A-01x) has the capability to take into consideration the load\r\n# at which the voltage must be provided. Calculated data for voltage at different loads are\r\n# used to provide this functionality.\r\nload = 100  # units: mA\r\ncard.BattSetLoad(subunit, load)\r\n\r\n# Measure channel voltage\r\nvoltage = card.BattMeasureVoltage(subunit)\r\n\r\n# Measure channel current (in milliamps)\r\ncurrentmA = card.BattMeasureCurrentmA(subunit)\r\n\r\n# Measure channel current (in amps)\r\ncurrent = card.BattMeasureCurrentA(subunit)\r\n\r\n\r\n```\r\n\r\n## Operate Thermocouple Simulator ##\r\n\r\nThermocouple Simulators have specific functions for controlling them. To set the range use `VsourceSetRange()` providing the subunit and the range. To retrieve the range use `VsourceGetRange()` providing the subunit. To set the voltage use `VsourceSetVoltage()` providing the subunit and the voltage in millivolts. To retrieve the voltage use `VsourceGetVoltage()` providing the subunit. It returns the voltage in millivolts. To enable or disable outputs use `OpBit()` providing the subunit, bit number for the channel isolations, and the state that should be set. To retrieve the state of the outputs use `ViewBit()` providing the subunit and bit number for the channel isolations. Please refer to the product manual for more information on what subunit and bits to operate. To retrieve temperature readings from a connected thermocouple compensation block us `VsourceGetTemperatures()` providing either `card.ATTR[\"TS_TEMPERATURES_C\"]` or `card.ATTR[\"TS_TEMPERATURES_F\"]` for temperature unit. It will return a list of four temperatures. Please see below for worked examples on how to use these functions:\r\n\r\n```python\r\nrange = 0.0\r\nmvolts = 0.0\r\nrange = card.TS_RANGE[\"AUTO\"]\r\n\r\n# Set Range\r\ncard.VsourceSetRange(subunit, range)\r\n\r\n# Get Range\r\nrange = card.VsourceGetRange(subunit)\r\n\r\n# Set Voltage\r\ncard.VsourceSetVoltage(subunit, mvolts)\r\n\r\n# Get Voltage\r\nmvolts = card.VsourceGetVoltage(subunit)\r\n\r\n# Set Isolation switches (41-760-001)\r\nisosub = 33\r\ncard.OpBit(isosub, 1, 1) # Turn Vo1 on\r\ncard.OpBit(isosub, 2, 1) # Turn Vcold1 on\r\n\r\ncard.OpBit(isosub, 1, 0) # Turn Vo1 off\r\ncard.OpBit(isosub, 2, 0) # Turn Vcold1 off\r\n\r\n# Get Thermocouple subunit information\r\n# This will return a dictionary containing keys corresponding\r\n# to attributes of the thermocouple subunit and their values. \r\nVsourceInfoDict = card.VsourceInfo(subunit)\r\n\r\nfor key, value in VsourceInfoDict.items():\r\n    print(\"Attribute: {}, Value: {}\".format(key, value))\r\n\r\n# Get Compensation Block Temperatures\r\ntemperatures = card.VsourceGetTemperature(card.ATTR[\"TS_TEMPERATURE_C\"])\r\n\r\nfor temp in temperatures:\r\n    print(temp)\r\n\r\n```\r\n\r\n## Error Codes ##\r\n\r\nMost of the functions in python-pilxi will raise an exception on any errors. The exception is defined in the python module you are using e.g. pilxi, pi620lx, pipslx. \r\n\r\n```python\r\ntry:\r\n    # Call pilxi methods here\r\n    # On error, an exception will be raised \r\n\r\nexcept pilxi.Error as ex:\r\n    # The exception object contains a string description of the error:\r\n    errorMessage = ex.message\r\n    # It is also possible to retrive the error code returned from the driver:\r\n    errorCode = ex.errorCode\r\n```\r\n## Close Card/Session ##\r\n\r\nA card and session can be closed when it is no longer used, or the object's destructor can be called:\r\n\r\n```python\r\n# Closes individual card.\r\ncard.Close()     \r\n\r\n# Closes the session with the LXI.\r\nsession.Close()   \r\n\r\n# Calling the object's destructor or deleting all references will also call\r\n# the driver's Close() method:\r\n\r\ndel card\r\ndel session\r\n```\r\n\r\n# Using Pipslx\r\n\r\nPipslx python module can be used to control Pickering `Power Sequencer`, for\r\nexample [600-200-001](https://www.pickeringtest.com/en-US/product/lxi-remote-ac-power-management-switch). (Remote AC power management switch)\r\n\r\nHere is a code snippet, how to\r\nconnect to `Power Sequencer`, begin the startup and shutdown sequences, as well as\r\ngetting and setting individual channel states:\r\n\r\n```python\r\n# Required imports\r\nimport pilxi\r\nimport pipslx\r\n\r\n# IP address of the LXI Power Management Switch\r\nIP_Address = \"192.168.0.244\"\r\n\r\n# Open a session with the LXI unit and get the session ID\r\nsession = pilxi.Pi_Session(IP_Address)\r\nsessionID = session.GetSessionID()\r\n\r\n# Open the pipslx library using the LXI session\r\npowerSequencer = pipslx.Pipslx(sessionID)\r\n\r\n# Start sequence\r\npowerSequencer.sequence(pipslx.SEQUENCE_START)\r\n\r\n# Get the state of a specified channel\r\nchannel = 2\r\nstate = powerSequencer.get_chan_state(channel)\r\n\r\n# Set the state of a specified channel\r\nstate = 1\r\npowerSequencer.set_chan_state(channel, state)\r\n\r\nemergency = False\r\n\r\nif emergency:\r\n    # In an emergency, call shutdown method to immediately disconnect\r\n    # all channels. No sequence times applied.\r\n    powerSequencer.shutdown()\r\nelse:\r\n    # Otherwise, begin the regular shutdown sequence\r\n    powerSequencer.sequence(pipslx.SEQUENCE_STOP)\r\n\r\n# Close pipslx\r\npowerSequencer.close()\r\n\r\n# Close LXI session\r\nsession.Close()\r\n\r\n```\r\n\r\n# Using Pi620lx\r\n\r\nThe Pi620lx python module can be used to control Pickering 41-620 Function Generator cards installed in an LXI\r\nchassis. The 41-620 3-channel function generator card can be used to generate arbitrarily defined waveforms, as well as standard\r\nwaveforms such as sine, square and triangle with variable attenuation and DC offsets. \r\n\r\nHere is some example code for controlling the 41-620 card using Pi620lx:\r\n```python\r\nimport pilxi\r\nimport pi620lx \r\n\r\nIP_Address = \"192.168.1.1\"\r\n\r\n# Open an LXI session and get the session ID which must be passed to \r\n# the pi620lx module\r\nsession = pilxi.Pi_Session(IP_Address)\r\nsessionID = session.GetSessionID()\r\n\r\n# Open the pi620lx library \r\npi620base = pi620lx.Base(sessionID)\r\n\r\n# Open a card. With no arguments passed, the openCard() method will open the\r\n# first 41-620 card found in the LXI unit. \r\nbus = 4\r\ndevice = 14\r\n\r\ncard = pi620base.openCard(bus, device)\r\n\r\n# Set active channel to use\r\nchannel = 1\r\ncard.setActiveChannel(channel)\r\n\r\n# Switch off channel output before configuring it\r\ncard.outputOff()\r\n\r\n# Set trigger mode to continuous (no trigger)\r\ncard.setTriggerMode(card.triggerSources[\"FRONT\"], card.triggerModes[\"CONT\"])\r\n\r\n# Set DC offset to generated waveform (float value from -5 to 5 volts)\r\n# The first argument specifies the desired offset voltage;\r\n# the second enables or disables DC offset.\r\noffsetVoltage = 4.0\r\nenableDCOffset = True\r\ncard.setOutputOffsetVoltage(offsetVoltage, enableDCOffset)\r\n\r\n# Set attenuation to signal amplitude (float value in dB)\r\nattenuation = 3\r\ncard.setAttenuation(attenuation)\r\n\r\n# Generate a signal\r\n# Signal shape can be defined using constants available with the Pi620_Card class:\r\nshape = card.signalShapes[\"SINE\"]\r\n# shape = card.signalShapes[\"SQUARE\"]\r\n# shape = card.signalShapes[\"TRIANGLE\"]\r\n\r\n# Frequency of signal in kHz:\r\nfrequency = 1\r\n# Symmetry of signal (0 - 100):\r\nsymmetry = 20\r\n\r\ntry:\r\n    # Start generating a signal. By default, this method will start generating immediately without\r\n    # first calling card.outputOn().\r\n    # card.generateSignal(frequency, shape, symmetry)\r\n\r\n    # The card.generateSignal() method can also be used with optional parameters to specify\r\n    # a start phase offset and to enable/disable immediate signal generation.\r\n    # For example, the following call will set the same signal as above, but with a\r\n    # 90 degree phase offset and will disable signal output until card.outputOn() is called:\r\n    card.generateSignal(frequency, shape, symmetry, startPhaseOffset=90, generate=False)\r\n\r\n    # Set output on\r\n    card.outputOn()\r\n\r\nexcept pi620lx.Error as error:\r\n    print(\"Error generating signal:\", error.message)\r\n\r\n# Close card. Note this will not stop the card generating a signal.\r\ncard.close()\r\n```\r\n\r\n# Migrating from old versions of the pilxi Python wrapper \r\n\r\nFrom wrapper version 4.0 onwards, major changes were made to the Python pilxi wrapper API. Most notably, \r\nopening/listing cards and error handling conventions have changed. The new wrapper does not rely on returning \r\nan integer error code from every method, as is conventional in a C program. Instead. Python-style exceptions are \r\nraised, and the exception contains attributes giving the integer error code, and a human-readable description of\r\nthe error. \r\n### Old wrapper example:\r\n\r\n```python\r\nfrom pilxi import *\r\n\r\n# Connect to chassis\r\nip_address = \"192.168.1.1\"\r\nport = 1024\r\ntimeout = 1000\r\n\r\n# Opening a session with LXI device. \r\n# Note that strings must be encoded with str.encode()\r\ncom = pi_comm(0, str.encode(ip_address), port, timeout)\r\n\r\nmode = 0            # Last two parameters treated as Bus and Slot\r\nbus = 19\r\nslot = 1\r\ncard_obj = pi_card(0, str.encode(ip_address), port, timeout, mode, bus, slot)\r\n\r\ncolumn = 1\r\nrow = 1\r\nsubunit = 1\r\nstate = 1\r\n\r\nerr = card_obj.OpCrosspoint(subunit, row, column, state)\r\n\r\n# C-style error checking\r\n# Note that strings must be decoded from byte strings (Python 3.x only)\r\nif err:\r\n    error, err_str = card_obj.ErrorCodeToMessage(err)\r\n    print(err_str.decode())\r\n\r\nerr = card_obj.OpCrosspoint(subunit, column, row, 0)\r\nif err:\r\n    error, err_str = card_obj.ErrorCodeToMessage(err)\r\n    print(err_str.decode())\r\n\r\n# Cards must be closed explicitly or they will not be released\r\ncard_obj.CloseSpecifiedCard()\r\n\r\n# Session must be closed explicitly or they may be orphaned\r\ncom.Disconnect()\r\n```\r\n### New wrapper example:\r\n```python\r\nimport pilxi\r\n\r\n# Connect to chassis and open a card by bus and device IDs.\r\n# Error checking is done using try/except blocks to catch\r\n# exceptions.\r\ntry:\r\n    # Port, timeout parameters are optional, defaults will be used otherwise.\r\n    IP_Address = '192.168.1.5'\r\n    session = pilxi.Pi_Session(IP_Address)\r\n\r\n    bus = 19\r\n    device = 1\r\n    card = session.OpenCard(bus, device)\r\n    \r\nexcept pilxi.Error as ex:\r\n    print(\"Error connecting to chassis/opening card: \", ex.message)\r\n    print(\"Driver error code:\", ex.errorCode)\r\n    exit()\r\n\r\n# Set and unset a matrix crosspoint, with error checking:\r\ntry:    \r\n    row = 1\r\n    column = 1\r\n    subunit = 1\r\n    \r\n    card.OpCrosspoint(subunit, row, column, True)\r\n    \r\n    card.OpCrosspoint(subunit, row, column, False)\r\n    \r\nexcept pilxi.Error as ex:\r\n    print(\"Error operating crosspoint: \", ex.message)\r\n    print(\"Driver error code: \", ex.errorCode)\r\n    \r\n# Close session and card explicitly. This is entirely optional, cards and sessions\r\n# will be closed by Python's garbage collection.\r\n\r\ncard.Close()\r\nsession.Close()\r\n```\r\n\r\nFunction signatures remain largely identical between versions of the wrapper, except error codes are not returned. \r\nTherefore, previously a function returning a value would also return an error code:\r\n```python\r\nerror, resistance = card.ResGetResistance(subunit)\r\n```\r\nWould now become:\r\n```python\r\nresistance = card.ResGetResistance(subunit)\r\n```\r\nErrors would be caught in a try/except block. \r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "Copyright (c) 2017-2023 Pickering Interfaces Ltd.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Pilxi",
    "package_url": "https://pypi.org/project/Pilxi/",
    "platform": null,
    "project_url": "https://pypi.org/project/Pilxi/",
    "project_urls": {
      "homepage": "https://www.pickeringtest.com/"
    },
    "release_url": "https://pypi.org/project/Pilxi/5.0/",
    "requires_dist": [
      "enum34"
    ],
    "requires_python": "",
    "summary": "Python Pilxi is a Python wrapper for Pickering ClientBridge driver.",
    "version": "5.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17361248,
  "releases": {
    "5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "155486b1c7ac445f9a4ef44993d2c910b4e209d44ec34f3cfd3f1d752413cb79",
          "md5": "010c652f3ade5c6045c364464143433a",
          "sha256": "eed7f99d1afa95721a597e08ad48b3f1699e6efd084b5578695569b4c63b20d4"
        },
        "downloads": -1,
        "filename": "Pilxi-5.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "010c652f3ade5c6045c364464143433a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 50819,
        "upload_time": "2023-03-20T09:27:52",
        "upload_time_iso_8601": "2023-03-20T09:27:52.329771Z",
        "url": "https://files.pythonhosted.org/packages/15/54/86b1c7ac445f9a4ef44993d2c910b4e209d44ec34f3cfd3f1d752413cb79/Pilxi-5.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2eaa1f8cee668f88f631dcdf5b9b48bd85cfda9f9716b19b000fd6bd4973c3ac",
          "md5": "be111c6e87b02da58efe6bf74fadc57a",
          "sha256": "d171040f9e3864f3fc66c8873577f0e6a971acf54001d164fd1d5a068623c324"
        },
        "downloads": -1,
        "filename": "Pilxi-5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "be111c6e87b02da58efe6bf74fadc57a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 56371,
        "upload_time": "2023-03-20T09:27:54",
        "upload_time_iso_8601": "2023-03-20T09:27:54.618264Z",
        "url": "https://files.pythonhosted.org/packages/2e/aa/1f8cee668f88f631dcdf5b9b48bd85cfda9f9716b19b000fd6bd4973c3ac/Pilxi-5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "155486b1c7ac445f9a4ef44993d2c910b4e209d44ec34f3cfd3f1d752413cb79",
        "md5": "010c652f3ade5c6045c364464143433a",
        "sha256": "eed7f99d1afa95721a597e08ad48b3f1699e6efd084b5578695569b4c63b20d4"
      },
      "downloads": -1,
      "filename": "Pilxi-5.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "010c652f3ade5c6045c364464143433a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 50819,
      "upload_time": "2023-03-20T09:27:52",
      "upload_time_iso_8601": "2023-03-20T09:27:52.329771Z",
      "url": "https://files.pythonhosted.org/packages/15/54/86b1c7ac445f9a4ef44993d2c910b4e209d44ec34f3cfd3f1d752413cb79/Pilxi-5.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2eaa1f8cee668f88f631dcdf5b9b48bd85cfda9f9716b19b000fd6bd4973c3ac",
        "md5": "be111c6e87b02da58efe6bf74fadc57a",
        "sha256": "d171040f9e3864f3fc66c8873577f0e6a971acf54001d164fd1d5a068623c324"
      },
      "downloads": -1,
      "filename": "Pilxi-5.0.tar.gz",
      "has_sig": false,
      "md5_digest": "be111c6e87b02da58efe6bf74fadc57a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 56371,
      "upload_time": "2023-03-20T09:27:54",
      "upload_time_iso_8601": "2023-03-20T09:27:54.618264Z",
      "url": "https://files.pythonhosted.org/packages/2e/aa/1f8cee668f88f631dcdf5b9b48bd85cfda9f9716b19b000fd6bd4973c3ac/Pilxi-5.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}