{
  "info": {
    "author": "Andrea Zanelli",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "<img src=\"https://github.com/zanellia/prometeo/blob/master/logo/logo.png\" align=\"left\"\n     alt=\"prometeo logo by Andrea Zanelli\" width=\"80\" height=\"120\">\n\n![Travis Status](https://travis-ci.org/zanellia/prometeo.svg?branch=master) [![PyPI version fury.io](https://badge.fury.io/py/prometeo-dsl.svg)](https://pypi.python.org/pypi/ansicolortags/) [![Documentation Status](https://readthedocs.org/projects/prometeo/badge/?version=latest)](https://prometeo.readthedocs.io/en/latest/?badge=latest)\n\n\nThis is prometeo, an experimental modeling tool for embedded high-performance computing. prometeo provides a \ndomain specific language (DSL) based on a subset of the Python language that allows \none to conveniently write scientific computing programs in a high-level language (Python itself) that can be transpiled\nto high-performance self-contained C code easily deployable on embedded devices.\n\n### features\n- __Python compatible syntax__ : prometeo is a DSL embedded into the Python language. \nprometeo programs can be executed from the Python interpreter.\n- __efficient__ : prometeo programs transpile to high-performance C code.\n- __statically typed__ : prometeo uses Python's native type hints to strictly enforce static typing.\n- __deterministic memory usage__ : a specific program structure is required and enforced through static analysis. In this way\nprometeo transpiled programs have a guaranteed maximum heap usage.\n- __fast memory management__ : thanks to its static analysis, prometeo can avoid allocating\nand garbage-collecting memory, resulting in faster and safer execution.\n- __self-contained and embeddable__ : unlike other similar tools and languages, prometeo targets specifically embedded applications and programs \nwritten in prometeo transpile to self-contained C code that does not require linking against \nthe Python run-time library.\n\n### documentation (preliminary)\nprometeo's documentation can be found on Read the Docs at [https://prometeo.readthedocs.io/en/latest/index.html](https://prometeo.readthedocs.io/en/latest/index.html).\n      \n### hello world!\n\nA simple hello world example that shows how to either run a trivial prometeo program from Python or transpile it to C, build it and run it can be found [here](https://github.com/zanellia/prometeo/blob/master/examples/helloworld/helloworld.py). The output shows the outcome of the heap usage analysis and the execution time (in this case there is not much to see :p).\n\n<p align=\"center\">\n<img src=\"https://github.com/zanellia/prometeo/blob/master/gifs/helloworld.gif\" width=\"100%\" >\n</p>\n\n\n### performance\nSince prometeo programs transpile to pure C code that calls the high performance linear algebra library BLASFEO (publication: [https://arxiv.org/abs/1704.02457](https://arxiv.org/abs/1704.02457), code: [https://github.com/giaf/blasfeo](https://github.com/giaf/blasfeo)), execution time can be comparable to hand-written high-performance code. The figure below shows a comparison of the CPU time necessary to carry out a Riccati factorization using highly optimized hand-written C code with calls to BLASFEO and the ones obtained with prometeo transpiled code from [this example](https://github.com/zanellia/prometeo/blob/master/examples/riccati_example/riccati_mass_spring.py). The computation times obtained with NumPy and Julia are added too for comparison - notice however that these last two implementations of the Riccati factorization are **not as easily embeddable** as the C code generated by prometeo and the hand-coded C implementation. All the benchmarks have been run on a Dell XPS-9360 equipped with an i7-7560U CPU running at 2.30 GHz (to avoid frequency fluctuations due to thermal throttling). \n\n<p align=\"center\">\n<img src=\"https://github.com/zanellia/prometeo/blob/master/benchmarks/riccati_benchmark.png\" width=\"100%\" >\n</p>\n\nMoreover, prometeo can largely outperform state-of-the-art Python compilers such as Nuitka. The table below shows the CPU times obtained on a Fibonacci benchmark.\n\n|    parser/compiler   | CPU time [s] |\n|:--------------------:|--------------|\n| Python 3.7 (CPython) |    11.787    |\n|        Nuitka        |    10.039    |\n|\tPyPy           |     1.78     |\n|       prometeo       |     0.657    |\n\n\n### PyPI installation\n\nprometeo can be installed through PyPI with `pip install prometeo-dsl`. Notice that, since prometeo makes extensive use of [type hints](https://docs.python.org/3.6/library/typing.html) to equip Python code with static typing information, the minimum Python version required is 3.6.\n\n### manual installation\nIf you want to install prometeo building the sources on your local machine you can proceed as follows:\n\n- Run `git submodule update --init` to clone the submodules.\n- Run `make install_shared` from `<prometeo_root>/prometeo/cpmt` to compile and install the shared library associated with the C backend. Notice that the default installation path is `<prometeo_root>/prometeo/cpmt/install`.\n- You need Python 3.6. or later.\n- Optional: to keep things clean you can setup a virtual environment with `virtualenv --python=<path_to_python3.6> <path_to_new_virtualenv>`.\n- Run `pip install -e .` from `<prometeo_root>` to install the Python package.\n\nFinally, you can run the examples in `<root>/examples` with `pmt <example_name>.py --cgen=<True/False>`, where the `--cgen` flag determines whether the code is executed by the Python interpreter or C code is generated compiled and run.\n\n### a simple example\n\nThe Python code ([`examples/simple_example/simple_example.py`](https://github.com/zanellia/prometeo/blob/master/examples/simple_example/simple_example.py))\n```python\nfrom prometeo import *\n\nn : dims = 10\n\ndef main() -> int:\n\n    A: pmat = pmat(n, n)\n    for i in range(10):\n        for j in range(10):\n            A[i, j] = 1.0\n\n    B: pmat = pmat(n, n)\n    for i in range(10):\n        B[0, i] = 2.0\n\n    C: pmat = pmat(n, n)\n    C = A * B\n    pmat_print(C)\n    return 0\n```\ncan be run by the standard Python interpreter (version >3.6 required) and it \nwill perform the described linear algebra operations using the command `pmt simple_example.py --cgen=False`. \nAt the same time, the code can be parsed by prometeo and its abstract syntax tree (AST) analyzed in order\nto generate the following high-performance C code:\n```c\n#include \"stdlib.h\"\n#include \"simple_example.h\"\nvoid * ___c_pmt_8_heap;\nvoid * ___c_pmt_64_heap;\nvoid * ___c_pmt_8_heap_head;\nvoid * ___c_pmt_64_heap_head;\n\n#include \"prometeo.h\"\nint main() {\n    ___c_pmt_8_heap = malloc(10000); \n    ___c_pmt_8_heap_head = ___c_pmt_8_heap;\n    char * pmem_ptr = (char *)___c_pmt_8_heap;\n    align_char_to(8, &pmem_ptr);\n    ___c_pmt_8_heap = pmem_ptr;\n    ___c_pmt_64_heap = malloc(1000000);\n    ___c_pmt_64_heap_head = ___c_pmt_64_heap;\n    pmem_ptr = (char *)___c_pmt_64_heap;\n    align_char_to(64, &pmem_ptr);\n    ___c_pmt_64_heap = pmem_ptr;\n\tvoid *callee_pmt_8_heap = ___c_pmt_8_heap;\n\tvoid *callee_pmt_64_heap = ___c_pmt_64_heap;\n\n    struct pmat * A = c_pmt_create_pmat(n, n);\n    for(int i = 0; i < 10; i++) {\n        for(int j = 0; j < 10; j++) {\n            c_pmt_pmat_set_el(A, i, j, 1.0);\n    }\n\n    }\n\n    struct pmat * B = c_pmt_create_pmat(n, n);\n    for(int i = 0; i < 10; i++) {\n        c_pmt_pmat_set_el(B, 0, i, 2.0);\n    }\n\n    struct pmat * C = c_pmt_create_pmat(n, n);\n    c_pmt_pmat_fill(C, 0.0);\n    c_pmt_gemm_nn(A, B, C, C);\n    c_pmt_pmat_print(C);\n\t___c_pmt_8_heap = callee_pmt_8_heap;\n\t___c_pmt_64_heap = callee_pmt_64_heap;\n\n\tfree(___c_pmt_8_heap_head);\n\tfree(___c_pmt_64_heap_head);\n\treturn 0;\n}\n```\nwhich relies on the high-performance linear algebra package BLASFEO. The generated code will be readily compiled and run with when running `pmt simple_example.py --cgen=True`.\n\n### how does it work?\n\nAlthough translating a program written in a language into another with\na comparable level of abstraction can be significantly easier than\ntranslating to one with a very different level of abstraction\n(especially if the target language is of much lower level),\ntranslating Python programs into C programs still involves a\nconsiderable abstraction gap it is not an easy task\nin general. Loosely speaking, the challenge lies in the necessity to\nreimplement features that are natively supported by the source\nlanguage in the target language. In particular, when translating\nPython to C, the difficulty comes both from the different level of\nabstraction of the two languages and from the fact that the source and\ntarget language are of two very different types: Python is an\n*interpreted*, *duck-typed* and\n*garbage-collected* language and C is a\n*compiled* and *statically typed* language.\n\nThe task of transpiling Python to C becomes even more challenging if we add the\nconstraint that the generated C code must be efficient (even for small\nto medium scale computations) and deployable\non embedded hardware. In fact these two requirements directly imply\nthat the generated code cannot make use of: *i)* sophisticated runtime\nlibraries, e.g., the Python runtime library, which are generally not available on\nembedded hardware *ii)* dynamic memory allocation that would make the execution\nslow and unreliable (exception made for memory that is allocated in a\nsetup phase and whose size is known a priori). \n\nSince source-to-source code transformation, or transpilation, and in\nparticular transpilation of Python code into C code is not an\nunexplored realm, in the following, we mention a few existing projects\nthat address it. In doing so, we highlight where and how they do not satisfy one of\nthe two requirements outlined above, namely (small scale) efficiency\nand embeddability. \n\n<p align=\"center\">\n<img src=\"https://github.com/zanellia/prometeo/blob/master/figures/prometeo_crop.png\" width=\"50%\" >\n</p>\n     \n### related work\nSeveral software packages exist that address Python-to-C translation in\nvarious forms. \n\nIn the context of high-performance computing,\n*Numba* is a just-in-time compiler for numerical\nfunctions written in\nPython. As such, its aim is to convert properly annotated Python\nfunctions, not entire programs, into high-performance LLVM code such \nthat their execution can be sped\nup. *Numba* uses an internal representation of the code to be\ntranslated and performs a (potentially partial) type inference on the\nvariables involved in order to generate LLVM code that can be called\neither from Python or from C/C++. In some cases, namely the\nones where a complete type inference can\nbe carried out successfully, code that does not rely on the C API can be\ngenerated (using the *nopython* flag). However, the emitted LLVM code\nwould still rely on *Numpy* for BLAS and LAPACK  operations.  \n\n*Nuitka* is a source-to-source compiler that can translate\nevery Python construct into C code that links against the*libpython* library and it is therefore able to transpile a\nlarge class of Python programs. In order to do so, it relies on the fact\nthat one of the most used implementations of the Python language,\nnamely *CPython*, is written in C. In fact, *Nuitka*\ngenerates C code that contains calls to *CPython* that would\nnormally be carried out by the Python parser. Despite its\nattractive and general transpilation approach, it cannot be easily\ndeployed on embedded hardware due to its intrinsic dependency on\n*libpython*. At the same time, since it maps rather closely\nPython constructs to their *CPython* implementation, a number\nof performance issues can be expected when it comes to small to medium\nscale high-performance computing. This is particularly due to the fact\nthat operations associated with,\nfor example, type checking, memory allocation and garbage collection\nthat can slow down the execution are carried out by the transpiled\nprogram too.\n\n*Cython* is a programming language whose goal is to\nfacilitate writing C extensions for the Python language. In\nparticular, it can translate (optionally) statically typed Python-like\ncode into C code that relies on *CPython*. Similarly to the\nconsiderations made for *Nuitka*, this makes it a powerful tool\nwhenever it is possible to rely on *libpython* (and when its\noverhead is negligible, i.e., when dealing with sufficiently large\nscale computations), but not in the context of interest here.\n\nFinally, although it does not use Python as source language, we should\nmention that *Julia* too is just-in-time (and partially\nahead-of-time) compiled into LLVM\ncode. The emitted LLVM code relies however on the *Julia*\nruntime library such that considerations similar to the one made for\n*Cython* and *Nuitka* apply.\n\n### *prometeo*'s transpiler\nTranspilation of programs written using a restricted subset of the\nPython language into C programs is carried out using *prometeo*'s\ntranspiler. This source-to-source transformation tool analyzes abstract\nsyntax trees (AST) associated with the source files to be transpiled\nin order to emit high-performance and embeddable C code. In order to\ndo so, special rules need to be imposed on the Python code. This makes\nthe otherwise extremely challenging task of transpiling an interpreted high-level\nduck-typed language into a compiled low-level statically typed one\npossible. In doing so, we define what is sometimes referred to as an *embedded* \nDSL in the sense the resulting language uses the syntax of a host language\n(Python itself) and, in *prometeo*'s case, it can also be executed by\nthe standard Python interpreter. \n\n<p align=\"center\">\n<img src=\"https://github.com/zanellia/prometeo/blob/master/figures/simple_ast_annotated.png\" width=\"70%\" >\n</p>\n\n### a more advanced example (Riccati factorization)\n```python\nfrom prometeo import *\n\nnx:  dims = 2\nnu:  dims = 2\nnxu: dims = nx + nu\nN:   dims = 5\n\ndef main() -> int:\n\n    # number of repetitions for timing\n    nrep : int = 10000\n\n    A: pmat = pmat(nx, nx)\n    A[0,0] = 0.8\n    A[0,1] = 0.1\n    A[1,0] = 0.3\n    A[1,1] = 0.8\n\n    B: pmat = pmat(nx, nu)\n    B[0,0] = 1.0  \n    B[1,1] = 1.0\n\n    Q: pmat = pmat(nx, nx)\n    Q[0,0] = 1.0  \n    Q[1,1] = 1.0\n\n    R: pmat = pmat(nu, nu)\n    R[0,0] = 1.0  \n    R[1,1] = 1.0\n\n    A: pmat = pmat(nx, nx)\n    B: pmat = pmat(nx, nu)\n    Q: pmat = pmat(nx, nx)\n    R: pmat = pmat(nu, nu)\n\n    RSQ: pmat = pmat(nxu, nxu)\n    Lxx: pmat = pmat(nx, nx)\n    M: pmat = pmat(nxu, nxu)\n    w_nxu_nx: pmat = pmat(nxu, nx)\n    BAt : pmat = pmat(nxu, nx)\n    BA : pmat = pmat(nx, nxu)\n    pmat_hcat(B, A, BA)\n    pmat_tran(BA, BAt)\n\n    RSQ[0:nu,0:nu] = R\n    RSQ[nu:nu+nx,nu:nu+nx] = Q\n\n    # array-type Riccati factorization\n    for i in range(nrep):\n        pmt_potrf(Q, Lxx)\n        M[nu:nu+nx,nu:nu+nx] = Lxx\n        for i in range(1, N):\n            pmt_trmm_rlnn(Lxx, BAt, w_nxu_nx)\n            pmt_syrk_ln(w_nxu_nx, w_nxu_nx, RSQ, M)\n            pmt_potrf(M, M)\n            Lxx[0:nx,0:nx] = M[nu:nu+nx,nu:nu+nx]\n\n    return 0\n\n```\nSimilarly, the code above ([`example/riccati/riccati_array.py`](https://github.com/zanellia/prometeo/blob/master/examples/riccati_example/riccati_array.py)) can be run by the standard Python interpreter using the command `pmt riccati_array.py --cgen=False` and prometeo can generate, compile and run C code using instead `pmt riccati_array.py --cgen=True`.\n\n### supported Python constructs\nIn order to be able to transpile to C, only a subset of the Python language is supported. However, non C-like features such as function overload and classes are supported by prometeo's transpiler. The adapted Riccati example ([`examples/riccati/riccati_mass_spring_2.py`](https://github.com/zanellia/prometeo/blob/master/examples/riccati_example/riccati_mass_spring_2.py)) below shows how classes can be created and used.\n\n```python\nfrom prometeo import *\n\nnm: dims = 4\nnx: dims  = 2*nm\nsizes: dimv = [[8,8], [8,8], [8,8], [8,8], [8,8]]\nnu: dims  = nm\nnxu: dims = nx + nu\nN:  dims  = 5\n\nclass qp_data:\n    A: List = plist(pmat, sizes)\n    B: List = plist(pmat, sizes)\n    Q: List = plist(pmat, sizes)\n    R: List = plist(pmat, sizes)\n    P: List = plist(pmat, sizes)\n\n    fact: List = plist(pmat, sizes)\n\n    def factorize(self) -> None:\n        M: pmat = pmat(nxu, nxu)\n        Mxx: pmat = pmat(nx, nx)\n        L: pmat = pmat(nxu, nxu)\n        Q: pmat = pmat(nx, nx)\n        R: pmat = pmat(nu, nu)\n        BA: pmat = pmat(nx, nxu)\n        BAtP: pmat = pmat(nxu, nx)\n        pmat_copy(self.Q[N-1], self.P[N-1])\n\n        pmat_hcat(self.B[N-1], self.A[N-1], BA)\n        pmat_copy(self.Q[N-1], Q)\n        pmat_copy(self.R[N-1], R)\n        for i in range(1, N):\n            pmat_fill(BAtP, 0.0)\n            pmt_gemm_tn(BA, self.P[N-i], BAtP, BAtP)\n\n            pmat_fill(M, 0.0)\n            M[0:nu,0:nu] = R\n            M[nu:nu+nx,nu:nu+nx] = Q\n\n            pmt_gemm_nn(BAtP, BA, M, M)\n            pmat_fill(L, 0.0)\n            pmt_potrf(M, L)\n\n            Mxx[0:nx, 0:nx] = L[nu:nu+nx, nu:nu+nx]\n\n            # pmat_fill(self.P[N-i-1], 0.0)\n            pmt_gemm_nt(Mxx, Mxx, self.P[N-i-1], self.P[N-i-1])\n            # pmat_print(self.P[N-i-1])\n\n        return\n\ndef main() -> int:\n\n    A: pmat = pmat(nx, nx)\n    Ac11 : pmat = pmat(nm,nm)\n    Ac12 : pmat = pmat(nm,nm)\n    for i in range(nm):\n        Ac12[i,i] = 1.0\n\n    Ac21 : pmat = pmat(nm,nm)\n    for i in range(nm):\n        Ac21[i,i] = -2.0\n\n    for i in range(nm-1):\n        Ac21[i+1,i] = 1.0\n        Ac21[i,i+1] = 1.0\n\n    Ac22 : pmat = pmat(nm,nm)\n\n    for i in range(nm):\n        for j in range(nm):\n            A[i,j] = Ac11[i,j]\n\n    for i in range(nm):\n        for j in range(nm):\n            A[i,nm+j] = Ac12[i,j]\n\n    for i in range(nm):\n        for j in range(nm):\n            A[nm+i,j] = Ac21[i,j]\n\n    for i in range(nm):\n        for j in range(nm):\n            A[nm+i,nm+j] = Ac22[i,j]\n\n    tmp : float = 0.0\n    for i in range(nx):\n        tmp = A[i,i]\n        tmp = tmp + 1.0\n        A[i,i] = tmp\n\n    B: pmat = pmat(nx, nu)\n\n    for i in range(nu):\n        B[nm+i,i] = 1.0\n\n    Q: pmat = pmat(nx, nx)\n    for i in range(nx):\n        Q[i,i] = 1.0\n\n    R: pmat = pmat(nu, nu)\n    for i in range(nu):\n        R[i,i] = 1.0\n\n    qp : qp_data = qp_data() \n\n    for i in range(N):\n        qp.A[i] = A\n\n    for i in range(N):\n        qp.B[i] = B\n\n    for i in range(N):\n        qp.Q[i] = Q\n\n    for i in range(N):\n        qp.R[i] = R\n\n    qp.factorize()\n    \n    return 0\n```\n\n__Disclaimer: prometeo is still at a very preliminary stage and only a few linear algebra operations and Python constructs are supported for the time being.__\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://github.com/zanellia/prometeo",
    "keywords": "",
    "license": "LGPL",
    "maintainer": "",
    "maintainer_email": "",
    "name": "prometeo-dsl",
    "package_url": "https://pypi.org/project/prometeo-dsl/",
    "platform": null,
    "project_url": "https://pypi.org/project/prometeo-dsl/",
    "project_urls": {
      "Homepage": "http://github.com/zanellia/prometeo"
    },
    "release_url": "https://pypi.org/project/prometeo-dsl/0.0.11/",
    "requires_dist": null,
    "requires_python": ">=3.8, <3.10",
    "summary": "Python-to-C transpiler and domain specific language for embedded high-performance computing",
    "version": "0.0.11",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13867380,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0aeaf7838cad04ffa84c3d4004de653c0478e316282a6710c541f3ce858bb296",
          "md5": "75e04e88490912b3530701e25e2dd8ac",
          "sha256": "ed09e0f7bfedff6668c41f97c3ddd5e6b11ede744216ea77fd66c5005dcb3858"
        },
        "downloads": -1,
        "filename": "prometeo_dsl-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "75e04e88490912b3530701e25e2dd8ac",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6, <=3.9",
        "size": 430207,
        "upload_time": "2020-05-04T11:18:57",
        "upload_time_iso_8601": "2020-05-04T11:18:57.712172Z",
        "url": "https://files.pythonhosted.org/packages/0a/ea/f7838cad04ffa84c3d4004de653c0478e316282a6710c541f3ce858bb296/prometeo_dsl-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "191d2fac9458cd158666a080ab833e6b21db04a48d0285f2943afb88fb238d42",
          "md5": "fbc55ad3b06d4d484f6bec3778023158",
          "sha256": "5a61911041d7e8d10096f5028faa03e385fa8270086767e2ebdad644b073c310"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.10.tar.gz",
        "has_sig": false,
        "md5_digest": "fbc55ad3b06d4d484f6bec3778023158",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 398860,
        "upload_time": "2021-02-18T17:32:06",
        "upload_time_iso_8601": "2021-02-18T17:32:06.363591Z",
        "url": "https://files.pythonhosted.org/packages/19/1d/2fac9458cd158666a080ab833e6b21db04a48d0285f2943afb88fb238d42/prometeo-dsl-0.0.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bfb88fed91b45cbca7503bcaa92286adc85c9c2ef120b2ab0315aa82bf1cdfa4",
          "md5": "0fc32831b79507c3c646f2145d8bacf1",
          "sha256": "508938e0e01f2302698ce965f0dc579a7aed38d47253cd0f165898163b2c7daa"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.11.tar.gz",
        "has_sig": false,
        "md5_digest": "0fc32831b79507c3c646f2145d8bacf1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8, <3.10",
        "size": 406421,
        "upload_time": "2022-05-19T16:34:42",
        "upload_time_iso_8601": "2022-05-19T16:34:42.707866Z",
        "url": "https://files.pythonhosted.org/packages/bf/b8/8fed91b45cbca7503bcaa92286adc85c9c2ef120b2ab0315aa82bf1cdfa4/prometeo-dsl-0.0.11.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d0b1618e85fd6dcfd284fd45a82a83f4d13beaad7d849ac2cd2634670140b5ed",
          "md5": "f7a8202c201e2cf1054ccd9f24f17d59",
          "sha256": "f9ceeb9d302dffe261a5764b6041c80ce2a633aace37d58a98bdc3fe5899bfd2"
        },
        "downloads": -1,
        "filename": "prometeo_dsl-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f7a8202c201e2cf1054ccd9f24f17d59",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6, <=3.9",
        "size": 430288,
        "upload_time": "2020-05-04T11:57:02",
        "upload_time_iso_8601": "2020-05-04T11:57:02.269893Z",
        "url": "https://files.pythonhosted.org/packages/d0/b1/618e85fd6dcfd284fd45a82a83f4d13beaad7d849ac2cd2634670140b5ed/prometeo_dsl-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a8c8562060ef1d58c1d42b5b5f09482ca83fd968b914e1284a9b32f14d7ffab1",
          "md5": "2ed2108581ca971d06a8592b9c10819d",
          "sha256": "dd1e3a3c3838e1fbb2338954a903e87b8599d667c0130c6b646cd77c43cec809"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "2ed2108581ca971d06a8592b9c10819d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 48363,
        "upload_time": "2020-05-06T09:02:05",
        "upload_time_iso_8601": "2020-05-06T09:02:05.111394Z",
        "url": "https://files.pythonhosted.org/packages/a8/c8/562060ef1d58c1d42b5b5f09482ca83fd968b914e1284a9b32f14d7ffab1/prometeo-dsl-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fa980f4da3c76942167f08c6d8fb2ddd1d1dc443bde2d76051158a2324918e0a",
          "md5": "977857f80a21d7f94fbf471c3565bcc4",
          "sha256": "1efc612ea459ac7b546ece62fd846f8c73b8a75420d110fa55bead5285488b0f"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "977857f80a21d7f94fbf471c3565bcc4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 48967,
        "upload_time": "2020-05-12T13:52:49",
        "upload_time_iso_8601": "2020-05-12T13:52:49.595164Z",
        "url": "https://files.pythonhosted.org/packages/fa/98/0f4da3c76942167f08c6d8fb2ddd1d1dc443bde2d76051158a2324918e0a/prometeo-dsl-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "85743bd72e54653a60a273b62b478a8e601be43100d9ff88b21b6f04c8cc405f",
          "md5": "53db3fa5dfbcae133e05f7e86f38a238",
          "sha256": "184757cd6362f7dba2528123e374f650050d51bbb10441344ab67367ca64e93f"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "53db3fa5dfbcae133e05f7e86f38a238",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 54570,
        "upload_time": "2020-06-15T15:21:23",
        "upload_time_iso_8601": "2020-06-15T15:21:23.930784Z",
        "url": "https://files.pythonhosted.org/packages/85/74/3bd72e54653a60a273b62b478a8e601be43100d9ff88b21b6f04c8cc405f/prometeo-dsl-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a2fc01a642ac6244efb1330750c6e94193124cf8924d61649f63867d771831bc",
          "md5": "3ac6d4982dfe8524150d21bf696db441",
          "sha256": "91016c72969af587427b9cc06d09022b57b104cf3e0dada05afdb27558cb62a9"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "3ac6d4982dfe8524150d21bf696db441",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 55716,
        "upload_time": "2020-09-18T15:59:53",
        "upload_time_iso_8601": "2020-09-18T15:59:53.384272Z",
        "url": "https://files.pythonhosted.org/packages/a2/fc/01a642ac6244efb1330750c6e94193124cf8924d61649f63867d771831bc/prometeo-dsl-0.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c55ddb24464398dd8729961511ede976d012474fd5de8633efa6e2ffb7e08ec4",
          "md5": "74b4713c79423f216840cbcebe3bb826",
          "sha256": "4e1beb9b2d07a521facbcfad1f1059c5a88601f5dd0f98ba138b4f0713941c9c"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "74b4713c79423f216840cbcebe3bb826",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 60192,
        "upload_time": "2020-12-04T19:54:27",
        "upload_time_iso_8601": "2020-12-04T19:54:27.438828Z",
        "url": "https://files.pythonhosted.org/packages/c5/5d/db24464398dd8729961511ede976d012474fd5de8633efa6e2ffb7e08ec4/prometeo-dsl-0.0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6df931e1009e0c4d8d1b58b4431ab3dadc2fa6cdfaf88c0bdf19b01abf2e2829",
          "md5": "31eb21df400c2437699b19b8c1e671a3",
          "sha256": "4ddee0627b28b2fa8872c90562dbf10f722deb030303e46bc4b5754bf3e596b2"
        },
        "downloads": -1,
        "filename": "prometeo-dsl-0.0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "31eb21df400c2437699b19b8c1e671a3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6, <=3.9",
        "size": 398874,
        "upload_time": "2021-02-17T11:19:33",
        "upload_time_iso_8601": "2021-02-17T11:19:33.178016Z",
        "url": "https://files.pythonhosted.org/packages/6d/f9/31e1009e0c4d8d1b58b4431ab3dadc2fa6cdfaf88c0bdf19b01abf2e2829/prometeo-dsl-0.0.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bfb88fed91b45cbca7503bcaa92286adc85c9c2ef120b2ab0315aa82bf1cdfa4",
        "md5": "0fc32831b79507c3c646f2145d8bacf1",
        "sha256": "508938e0e01f2302698ce965f0dc579a7aed38d47253cd0f165898163b2c7daa"
      },
      "downloads": -1,
      "filename": "prometeo-dsl-0.0.11.tar.gz",
      "has_sig": false,
      "md5_digest": "0fc32831b79507c3c646f2145d8bacf1",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8, <3.10",
      "size": 406421,
      "upload_time": "2022-05-19T16:34:42",
      "upload_time_iso_8601": "2022-05-19T16:34:42.707866Z",
      "url": "https://files.pythonhosted.org/packages/bf/b8/8fed91b45cbca7503bcaa92286adc85c9c2ef120b2ab0315aa82bf1cdfa4/prometeo-dsl-0.0.11.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}