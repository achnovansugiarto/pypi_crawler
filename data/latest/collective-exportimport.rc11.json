{
  "info": {
    "author": "Philip Bauer (for starzel.de)",
    "author_email": "info@starzel.de",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Plone",
      "Framework :: Plone :: 4.3",
      "Framework :: Plone :: 5.0",
      "Framework :: Plone :: 5.1",
      "Framework :: Plone :: 5.2",
      "Framework :: Plone :: 6.0",
      "Framework :: Plone :: Addon",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": ".. This README is meant for consumption by humans and pypi. Pypi can render rst files so please do not use Sphinx features.\n   If you want to learn more about writing documentation, please check out: http://docs.plone.org/about/documentation_styleguide.html\n   This text does not appear on pypi or github. It is a comment.\n\n.. image:: https://img.shields.io/pypi/v/collective.exportimport.svg\n    :target: https://pypi.python.org/pypi/collective.exportimport/\n    :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/status/collective.exportimport.svg\n    :target: https://pypi.python.org/pypi/collective.exportimport\n    :alt: Egg Status\n\n.. image:: https://img.shields.io/pypi/pyversions/collective.exportimport.svg?style=plastic   :alt: Supported - Python Versions\n\n.. image:: https://img.shields.io/pypi/l/collective.exportimport.svg\n    :target: https://pypi.python.org/pypi/collective.exportimport/\n    :alt: License\n\n\n=======================\ncollective.exportimport\n=======================\n\nExport and import content, members, relations, translations, localroles and much more.\n\nExport and import all kinds of data from and to Plone sites using a intermediate json-format.\nThe main use-case is migrations since it enables you to for example migrate from Plone 4 with Archetypes and Python 2 to Plone 6 with Dexterity and Python 3 in one step.\nMost features use `plone.restapi` to serialize and deserialize data.\n\nSee also the training on migrating with exportimport: https://training.plone.org/migrations/exportimport.html\n\n.. contents:: Contents\n    :local:\n\nFeatures\n========\n\n* Export & Import content\n* Export & Import members and groups with their roles\n* Export & Import relations\n* Export & Import translations\n* Export & Import local roles\n* Export & Import order (position in parent)\n* Export & Import discussions/comments\n* Export & Import versioned content\n* Export & Import redirects\n\nExport supports:\n\n* Plone 4, 5 and 6\n* Archetypes and Dexterity\n* Python 2 and 3\n* plone.app.multilingual, Products.LinguaPlone, raptus.multilanguagefields\n\nImport supports:\n\n* Plone 5.2+, Dexterity, Python 2 and 3, plone.app.multilingual\n\nUsage\n=====\n\nExport\n------\n\nUse the form with the URL ``/@@export_content``, and select what you want to export:\n\n.. image:: ./docs/export.png\n\nYou can export one or more types and a whole site or only a specific path in a site. Since items are exported ordered by path importing them will create the same structure as you had originally.\n\nThe downloaded json-file will have the name of the path you exported from, e.g. ``Plone.json``.\n\nThe exports for members, relations, localroles and relations are linked to in this form but can also be called individually: ``/@@export_members``, ``/@@export_relations``, ``/@@export_localroles``, ``/@@export_translations``, ``/@@export_ordering``, ``/@@export_discussion``.\n\n\nImport\n------\n\nUse the form with the URL ``/@@import_content``, and upload a json-file that you want to import:\n\n.. image:: ./docs/import.png\n\n\nThe imports for members, relations, localroles and relations are linked to in this form but can also be called individually: ``/@@import_members``, ``/@@import_relations``, ``/@@import_localroles``, ``/@@import_translations``, ``/@@import_ordering``, ``/@@import_discussion``.\n\nAs a last step in a migration there is another view ``@@reset_dates`` that resets the modified date on imported content to the date initially contained in the imported json-file. This is necessary since varous changes during a migration will likely result in a updated modified-date. During import the original is stored as ``obj.modification_date_migrated`` on each new object and this view sets this date.\n\n\nUse-cases\n=========\n\nMigrations\n----------\n\nWhen a in-place-migration is not required you can choose this addon to migrate the most important parts of your site to json and then import it into a new Plone instance of your targeted version:\n\n* Export content from a Plone site (it supports Plone 4 and 5, Archetypes and Dexterity, Python 2 and 3).\n* Import the exported content into a new site (Plone 5.2+, Dexterity, Python 3)\n* Export and import relations, users and groups with their roles, translations, local roles, ordering, dedault-pages, comments, portlets and redirects.\n\nHow to migrate additional features like Annotations or Marker Interfaces is discussed in the FAQ section.\n\nOther\n-----\n\nYou can use this addon to\n\n* Archive your content as json\n* Export data to prepare a migration to another system\n* Combine content from mutiple plone-sites into one.\n* Import a plone-site as a subsite into another.\n* Import content from other systems as long as it fits the required format.\n* Update or replace existing data\n* ...\n\nDetails\n=======\n\nExport content\n--------------\n\nExporting content is basically a wrapper for the serializers of plone.restapi:\n\n.. code-block:: python\n\n    from plone.restapi.interfaces import ISerializeToJson\n    from zope.component import getMultiAdapter\n\n    serializer = getMultiAdapter((obj, request), ISerializeToJson)\n    data = serializer(include_items=False)\n\nImport content\n--------------\n\nImporting content is a elaborate wrapper for the deserializers of plone.restapi:\n\n.. code-block:: python\n\n    from plone.restapi.interfaces import IDeserializeFromJson\n    from zope.component import getMultiAdapter\n\n    container.invokeFactory(item['@type'], item['id'])\n    deserializer = getMultiAdapter((new, self.request), IDeserializeFromJson)\n    new = deserializer(validate_all=False, data=item)\n\n\nUse for migrations\n------------------\n\nA main use-case of this package is migration from one Plone-Version to another.\n\nExporting Archetypes content and importing that as Dexterity content works fine but due to changes in field-names some settings would get lost.\nFor example the setting to exclude content from the navigation was renamed from ``excludeFromNav`` to ``exclude_from_nav``.\n\nTo fix this you can check the checkbox \"Modify exported data for migrations\".\nThis will modify the data during export:\n\n* Drop unused data (e.g. `next_item` and `components`)\n* Remove all relationfields\n* Change some fieldnames that changed between AT and DX\n\n  * ``excludeFromNav`` → ``exclude_from_nav``\n  * ``allowDiscussion`` → ``allow_discussion``\n  * ``subject`` → ``subjects``\n  * ``expirationDate`` → ``expires``\n  * ``effectiveDate`` → ``effective``\n  * ``creation_date`` → ``created``\n  * ``modification_date`` → ``modified``\n  * ``startDate`` → ``start``\n  * ``endDate`` → ``end``\n  * ``openEnd`` → ``open_end``\n  * ``wholeDay`` → ``whole_day``\n  * ``contactEmail`` → ``contact_email``\n  * ``contactName`` → ``contact_name``\n  * ``contactPhone`` → ``contact_phone``\n\n* Update view names on Folders and Collection thet changed since Plone 4.\n* Export ATTopic and their criteria to Collections with querystrings.\n* Update Collection-criteria.\n* Links and images in Richtext-Fields of content and portlets have changes since Plone 4.\n  the view ``/@@fix_html`` allows you to fix these.\n\n\nControl creating imported content\n---------------------------------\n\nYou can choose between four options how to deal with content that already exists:\n\n  * Skip: Don't import at all\n  * Replace: Delete item and create new\n  * Update: Reuse and only overwrite imported data\n  * Ignore: Create with a new id\n\nImported content is initially created with ``invokeFactory`` using portal_type and id of the exported item before deserialing the rest of the data.\nYou can set additional values by specifying a dict ``factory_kwargs`` that will be passed to the facory.\nLike this you can set values on the imported object that are expected to be there by subscribers to IObjectAddedEvent.\n\n\nExport versioned content\n------------------------\n\nExporting versions of Archetypes content will not work because of a bug in plone.restapi (https://github.com/plone/plone.restapi/issues/1335).\nFor export to work you need to use a version between 7.7.0 and 8.0.0 (if released) or a source-checkout of the branch 7.x.x.\n\n\nNotes on speed and large migrations\n===================================\n\nExporting and importing large amounts of content can take a while. Export is pretty fast but import is constrained by some features of Plone, most importantly versioning:\n\n* Importing 5000 Folders takes ~5 minutes\n* Importing 5000 Documents takes >25 minutes because of versioning.\n* Importing 5000 Documents without versioning takes ~7 minutes.\n\nDuring import you can commit every x number of items which will free up memory and disk-space in your TMPDIR (where blobs are added before each commit).\n\nWhen exporting large numbers of blobs (binary files and images) you will get huge json-files and may run out of memory.\nYou have various options to deal with this.\nThe best way depends on how you are going to import the blobs:\n\n- Export as download urls: small download, but ``collective.exportimport`` cannot import the blobs, so you will need an own import script to download them.\n- Export as base-64 encoded strings: large download, but ``collective.exportimport`` can handle the import.\n- Export as blob paths: small download and ``collective.exportimport`` can handle the import, but you need to copy ``var/blobstorage`` to the Plone Site where you do the import or set the environment variable ``COLLECTIVE_EXPORTIMPORT_BLOB_HOME`` to the old blobstorage path: ``export COLLECTIVE_EXPORTIMPORT_BLOB_HOME=/path-to-old-instance/var/blobstorage``.\n  To export the blob-path you do not need to have access to the blobs!\n\n\nCustomize export and import\n===========================\n\nThis addon is designed to be adapted to your requirements and has multiple hooks to make that easy.\n\nTo make that easier here are packages you can reuse to override and extend the export and import.\nUse these templates and adapt them to your own projects:\n\n* https://github.com/starzel/contentexport\n* https://github.com/starzel/contentimport\n\nMany examples for customizing the export and import are collected in the chapter \"FAQ, Tips and Tricks\" below.\n\n.. note::\n\n    As a rule of thumb you should make changes to the data during import unless you need access to the original object for the required changes.\n    One reason is that this way the serialized content in the json-file more closely represents the original data.\n    Another reason is that it allows you to fix issues during the process you are currently developing (i.e. without having to redo the export).\n\n\nExport Example\n--------------\n\n.. code-block:: python\n\n    from collective.exportimport.export_content import ExportContent\n\n    class CustomExportContent(ExportContent):\n\n        QUERY = {\n            'Document': {'review_state': ['published', 'pending']},\n        }\n\n        DROP_PATHS = [\n            '/Plone/userportal',\n            '/Plone/en/obsolete_content',\n        ]\n\n        DROP_UIDS = [\n            '71e3e0a6f06942fea36536fbed0f6c42',\n        ]\n\n        def update(self):\n            \"\"\"Use this to override stuff before the export starts\n            (e.g. force a specific language in the request).\"\"\"\n\n        def start(self):\n            \"\"\"Hook to do something before export.\"\"\"\n\n        def finish(self):\n            \"\"\"Hook to do something after export.\"\"\"\n\n        def global_obj_hook(self, obj):\n            \"\"\"Inspect the content item before serialisation data.\n            Bad: Changing the content-item is a horrible idea.\n            Good: Return None if you want to skip this particular object.\n            \"\"\"\n            return obj\n\n        def global_dict_hook(self, item, obj):\n            \"\"\"Use this to modify or skip the serialized data.\n            Return None if you want to skip this particular object.\n            \"\"\"\n            return item\n\n        def dict_hook_document(self, item, obj):\n            \"\"\"Use this to modify or skip the serialized data by type.\n            Return the modified dict (item) or None if you want to skip this particular object.\n            \"\"\"\n            return item\n\n\nRegister it with your own browserlayer to override the default:\n\n.. code-block:: xml\n\n  <browser:page\n      name=\"export_content\"\n      for=\"zope.interface.Interface\"\n      class=\".custom_export.CustomExportContent\"\n      layer=\"My.Custom.IBrowserlayer\"\n      permission=\"cmf.ManagePortal\"\n      />\n\n\nImport Example\n--------------\n\n.. code-block:: python\n\n    from collective.exportimport.import_content import ImportContent\n\n    class CustomImportContent(ImportContent):\n\n        CONTAINER = {'Event': '/imported-events'}\n\n        # These fields will be ignored\n        DROP_FIELDS = ['relatedItems']\n\n        # Items with these uid will be ignored\n        DROP_UIDS = ['04d1477583c74552a7fcd81a9085c620']\n\n        # These paths will be ignored\n        DROP_PATHS = ['/Plone/doormat/', '/Plone/import_files/']\n\n        # Default values for some fields\n        DEFAULTS = {'which_price': 'normal'}\n\n        def start(self):\n            \"\"\"Hook to do something before importing one file.\"\"\"\n\n        def finish(self):\n            \"\"\"Hook to do something after importing one file.\"\"\"\n\n        def global_dict_hook(self, item):\n            if isinstance(item.get('description', None), dict):\n                item['description'] = item['description']['data']\n            if isinstance(item.get('rights', None), dict):\n                item['rights'] = item['rights']['data']\n            return item\n\n        def dict_hook_customtype(self, item):\n            # change the type\n            item['@type'] = 'anothertype'\n            # drop a field\n            item.pop('experiences', None)\n            return item\n\n        def handle_file_container(self, item):\n            \"\"\"Use this to specify the container in which to create the item in.\n            Return the container for this particular object.\n            \"\"\"\n            return return self.portal['imported_files']\n\nRegister it:\n\n.. code-block:: xml\n\n  <browser:page\n      name=\"import_content\"\n      for=\"zope.interface.Interface\"\n      class=\".custom_import.CustomImportContent\"\n      layer=\"My.Custom.IBrowserlayer\"\n      permission=\"cmf.ManagePortal\"\n      />\n\n\nAutomate export and import\n--------------------------\n\nRun all exports and save all data in ``var/instance/``:\n\n.. code-block:: python\n\n    from plone import api\n    from Products.Five import BrowserView\n\n    class ExportAll(BrowserView):\n\n        def __call__(self):\n            export_content = api.content.get_view(\"export_content\", self.context, self.request)\n            self.request.form[\"form.submitted\"] = True\n            export_content(\n                portal_type=[\"Folder\", \"Document\", \"News Item\", \"File\", \"Image\"],  # only export these\n                include_blobs=2,  # Export files and images as blob paths\n                download_to_server=True)\n\n            other_exports = [\n                \"export_relations\",\n                \"export_members\",\n                \"export_translations\",\n                \"export_localroles\",\n                \"export_ordering\",\n                \"export_defaultpages\",\n                \"export_discussion\",\n                \"export_portlets\",\n                \"export_redirects\",\n            ]\n            for name in other_exports:\n                view = api.content.get_view(name, portal, request)\n                # This saves each export in var/instance/export_xxx.json\n                view(download_to_server=True)\n\n            # Important! Redirect to prevent infinite export loop :)\n            return self.request.response.redirect(self.context.absolute_url())\n\nRun all imports using the data exported in the example above:\n\n.. code-block:: python\n\n    from collective.exportimport.fix_html import fix_html_in_content_fields\n    from collective.exportimport.fix_html import fix_html_in_portlets\n    from pathlib import Path\n    from plone import api\n    from Products.Five import BrowserView\n\n\n    class ImportAll(BrowserView):\n\n        def __call__(self):\n            portal = api.portal.get()\n\n            # Import content\n            view = api.content.get_view(\"import_content\", portal, request)\n            request.form[\"form.submitted\"] = True\n            request.form[\"commit\"] = 500\n            view(server_file=\"Plone.json\", return_json=True)\n            transaction.commit()\n\n            # Run all other imports\n            other_imports = [\n                \"relations\",\n                \"members\",\n                \"translations\",\n                \"localroles\",\n                \"ordering\",\n                \"defaultpages\",\n                \"discussion\",\n                \"portlets\",\n                \"redirects\",\n            ]\n            cfg = getConfiguration()\n            directory = Path(cfg.clienthome) / \"import\"\n            for name in other_imports:\n                view = api.content.get_view(f\"import_{name}\", portal, request)\n                path = Path(directory) / f\"export_{name}.json\"\n                results = view(jsonfile=path.read_text(), return_json=True)\n                logger.info(results)\n                transaction.commit()\n\n            # Run cleanup steps\n            results = fix_html_in_content_fields()\n            logger.info(\"Fixed html for %s content items\", results)\n            transaction.commit()\n\n            results = fix_html_in_portlets()\n            logger.info(\"Fixed html for %s portlets\", results)\n            transaction.commit()\n\n            reset_dates = api.content.get_view(\"reset_dates\", portal, request)\n            reset_dates()\n            transaction.commit()\n\n.. note::\n\n    The views ``@@export_all`` and ``@@import_all`` are also contained in the helper-packages https://github.com/starzel/contentexport and https://github.com/starzel/contentimport\n\nFAQ, Tips and Tricks\n====================\n\nThis section covers frequent use-cases and examples for features that are not required for all migrations.\n\nUsing global_obj_hook during export\n-----------------------------------\n\nUsing ``global_obj_hook`` during export to inspect content and decide to skip it.\n\n.. code-block:: python\n\n    def global_obj_hook(self, obj):\n        # Drop subtopics\n        if obj.portal_type == \"Topic\" and obj.__parent__.portal_type == \"Topic\":\n            return\n\n        # Drop files and images from PFG formfolders\n        if obj.__parent__.portal_type == \"FormFolder\":\n            return\n        return obj\n\n\nUsing dict-hooks during export\n------------------------------\n\nUse ``global_dict_hook`` during export to inspect content and modify the serialized json.\nYou can also use ``dict_hook_<somecontenttype>`` to better structure your code for readability.\n\nSometimes you need to handle data that you add in ``global_dict_hook`` during export in corresponding code in ``global_object_hook`` during import.\n\nThe following example about placeful workflow policy is a perfect example for that pattern:\n\n\nExport/Import placeful workflow policy\n--------------------------------------\n\nExport:\n\n.. code-block:: python\n\n    def global_dict_hook(self, item, obj):\n        if obj.isPrincipiaFolderish and \".wf_policy_config\" in obj.keys():\n            wf_policy = obj[\".wf_policy_config\"]\n            item[\"exportimport.workflow_policy\"] = {\n                \"workflow_policy_below\": wf_policy.workflow_policy_below,\n                \"workflow_policy_in\": wf_policy.workflow_policy_in,\n            }\n        return item\n\nImport:\n\n.. code-block:: python\n\n    def global_obj_hook(self, obj, item):\n        wf_policy = item.get(\"exportimport.workflow_policy\")\n        if wf_policy:\n            obj.manage_addProduct[\"CMFPlacefulWorkflow\"].manage_addWorkflowPolicyConfig()\n            wf_policy_config = obj[\".wf_policy_config\"]\n            wf_policy_config.setPolicyIn(wf_policy[\"workflow_policy_in\"], update_security=True)\n            wf_policy_config.setPolicyBelow(wf_policy[\"workflow_policy_below\"], update_security=True)\n\n\nUsing dict-hooks during import\n------------------------------\n\nA lot of fixes can be done during import using the ``global_dict_hook`` or ``dict_hook_<contenttype>``.\n\nHere we prevent the expire-date to be before the effective date since that would lead to validation-errors during deserializing:\n\n.. code-block:: python\n\n    def global_dict_hook(self, item):\n        effective = item.get('effective', None)\n        expires = item.get('expires', None)\n        if effective and expires and expires <= effective:\n            item.pop('expires')\n        return item\n\nHere we drop empty lines from the creators:\n\n.. code-block:: python\n\n    def global_dict_hook(self, item):\n        item[\"creators\"] = [i for i in item.get(\"creators\", []) if i]\n        return item\n\nThis example migrates a PloneHelpCenter to a simple folder/document structure during import.\nThere are a couple more types to handle (as folder or document) but you get the idea, don't you?\n\n.. code-block:: python\n\n    def dict_hook_helpcenter(self, item):\n        item[\"@type\"] = \"Folder\"\n        item[\"layout\"] = \"listing_view\"\n        return item\n\n    def dict_hook_helpcenterglossary(self, item):\n        item[\"@type\"] = \"Folder\"\n        item[\"layout\"] = \"listing_view\"\n        return item\n\n    def dict_hook_helpcenterinstructionalvideo(self, item):\n        item[\"@type\"] = \"File\"\n        if item.get(\"video_file\"):\n            item[\"file\"] = item[\"video_file\"]\n        return item\n\n    def dict_hook_helpcenterlink(self, item):\n        item[\"@type\"] = \"Link\"\n        item[\"remoteUrl\"] = item.get(\"url\", None)\n        return item\n\n    def dict_hook_helpcenterreferencemanualpage(self, item):\n        item[\"@type\"] = \"Document\"\n        return item\n\nIf you change types during import you need to take care of other cases where types are referenced.\\\nExamples are collection-queries (see \"Fixing invalid collection queries\" below) or constrains (see here):\n\n.. code-block:: python\n\n    PORTAL_TYPE_MAPPING = {\n        \"Topic\": \"Collection\",\n        \"FormFolder\": \"EasyForm\",\n        \"HelpCenter\": \"Folder\",\n    }\n\n    def global_dict_hook(self, item):\n        if item.get(\"exportimport.constrains\"):\n            types_fixed = []\n            for portal_type in item[\"exportimport.constrains\"][\"locally_allowed_types\"]:\n                if portal_type in PORTAL_TYPE_MAPPING:\n                    types_fixed.append(PORTAL_TYPE_MAPPING[portal_type])\n                elif portal_type in ALLOWED_TYPES:\n                    types_fixed.append(portal_type)\n            item[\"exportimport.constrains\"][\"locally_allowed_types\"] = list(set(types_fixed))\n\n            types_fixed = []\n            for portal_type in item[\"exportimport.constrains\"][\"immediately_addable_types\"]:\n                if portal_type in PORTAL_TYPE_MAPPING:\n                    types_fixed.append(PORTAL_TYPE_MAPPING[portal_type])\n                elif portal_type in ALLOWED_TYPES:\n                    types_fixed.append(portal_type)\n            item[\"exportimport.constrains\"][\"immediately_addable_types\"] = list(set(types_fixed))\n        return item\n\n\nChange workflow\n---------------\n\n.. code-block:: python\n\n    REVIEW_STATE_MAPPING = {\n        \"internal\": \"published\",\n        \"internally_published\": \"published\",\n        \"obsolete\": \"private\",\n        \"hidden\": \"private\",\n    }\n\n    def global_dict_hook(self, item):\n        if item.get(\"review_state\") in REVIEW_STATE_MAPPING:\n            item[\"review_state\"] = REVIEW_STATE_MAPPING[item[\"review_state\"]]\n        return item\n\n\nExport/Import Annotations\n-------------------------\n\nSome core-features of Plone (e.g. comments) use annotations to store data.\nThe core features are already covered but your custom code or community addons may use annotations as well.\nHere is how you can migrate them.\n\n**Export**: Only export those Annotations that your really need.\n\n.. code-block:: python\n\n    from zope.annotation.interfaces import IAnnotations\n    ANNOTATIONS_TO_EXPORT = [\n        \"syndication_settings\",\n    ]\n    ANNOTATIONS_KEY = 'exportimport.annotations'\n\n    class CustomExportContent(ExportContent):\n\n        def global_dict_hook(self, item, obj):\n            item = self.export_annotations(item, obj)\n            return item\n\n        def export_annotations(self, item, obj):\n            results = {}\n            annotations = IAnnotations(obj)\n            for key in ANNOTATIONS_TO_EXPORT:\n                data = annotations.get(key)\n                if data:\n                    results[key] = IJsonCompatible(data, None)\n            if results:\n                item[ANNOTATIONS_KEY] = results\n            return item\n\n**Import**:\n\n.. code-block:: python\n\n    from zope.annotation.interfaces import IAnnotations\n    ANNOTATIONS_KEY = \"exportimport.annotations\"\n\n    class CustomImportContent(ImportContent):\n\n        def global_obj_hook(self, obj, item):\n            item = self.import_annotations(obj, item)\n            return item\n\n        def import_annotations(self, obj, item):\n            annotations = IAnnotations(obj)\n            for key in item.get(ANNOTATIONS_KEY, []):\n                annotations[key] = item[ANNOTATIONS_KEY][key]\n            return item\n\nSome features also store data in annotations on the portal, e.g. `plone.contentrules.localassignments`, `plone.portlets.categoryblackliststatus`, `plone.portlets.contextassignments`, `syndication_settings`.\nDepending on your requirements you may want to export and import those as well.\n\n\nExport/Import Marker Interfaces\n-------------------------------\n\n**Export**: You may only want to export the marker-interfaces you need.\nIt is a good idea to inspect a list of all used marker interfaces in a portal before deciding what to migrate.\n\n.. code-block:: python\n\n    from zope.interface import directlyProvidedBy\n\n    MARKER_INTERFACES_TO_EXPORT = [\n        \"collective.easyslider.interfaces.ISliderPage\",\n        \"plone.app.layout.navigation.interfaces.INavigationRoot\",\n    ]\n    MARKER_INTERFACES_KEY = \"exportimport.marker_interfaces\"\n\n    class CustomExportContent(ExportContent)\n\n        def global_dict_hook(self, item, obj):\n            item = self.export_marker_interfaces(item, obj)\n            return item\n\n        def export_marker_interfaces(self, item, obj):\n            interfaces = [i.__identifier__ for i in directlyProvidedBy(obj)]\n            interfaces = [i for i in interfaces if i in MARKER_INTERFACES_TO_EXPORT]\n            if interfaces:\n                item[MARKER_INTERFACES_KEY] = interfaces\n            return item\n\n**Import**:\n\n.. code-block:: python\n\n    from plone.dexterity.utils import resolveDottedName\n    from zope.interface import alsoProvides\n\n    MARKER_INTERFACES_KEY = \"exportimport.marker_interfaces\"\n\n    class CustomImportContent(ImportContent):\n\n        def global_obj_hook_before_deserializing(self, obj, item):\n            \"\"\"Apply marker interfaces before deserializing.\"\"\"\n            for iface_name in item.pop(MARKER_INTERFACES_KEY, []):\n                try:\n                    iface = resolveDottedName(iface_name)\n                    if not iface.providedBy(obj):\n                        alsoProvides(obj, iface)\n                        logger.info(\"Applied marker interface %s to %s\", iface_name, obj.absolute_url())\n                except ModuleNotFoundError:\n                    pass\n            return obj, item\n\nSkip versioning during import\n-----------------------------\n\nThe event-handlers of versioning can seriously slow down your imports.\nIt is a good idea to skip it before the import:\n\n.. code-block:: python\n\n    VERSIONED_TYPES = [\n        \"Document\",\n        \"News Item\",\n        \"Event\",\n        \"Link\",\n    ]\n\n    def start(self):\n        self.items_without_parent = []\n        portal_types = api.portal.get_tool(\"portal_types\")\n        for portal_type in VERSIONED_TYPES:\n            fti = portal_types.get(portal_type)\n            behaviors = list(fti.behaviors)\n            if 'plone.versioning' in behaviors:\n                logger.info(f\"Disable versioning for {portal_type}\")\n                behaviors.remove('plone.versioning')\n            fti.behaviors = behaviors\n\nRe-enable versioning and create initial versions after all imports and fixes are done, e.g in the view ``@@import_all``.\n\n.. code-block:: python\n\n    from Products.CMFEditions.interfaces.IModifier import FileTooLargeToVersionError\n\n    VERSIONED_TYPES = [\n        \"Document\",\n        \"News Item\",\n        \"Event\",\n        \"Link\",\n    ]\n\n    class ImportAll(BrowserView):\n\n        # re-enable versioning\n        portal_types = api.portal.get_tool(\"portal_types\")\n        for portal_type in VERSIONED_TYPES:\n            fti = portal_types.get(portal_type)\n            behaviors = list(fti.behaviors)\n            if \"plone.versioning\" not in behaviors:\n                behaviors.append(\"plone.versioning\")\n                logger.info(f\"Enable versioning for {portal_type}\")\n            if \"plone.locking\" not in behaviors:\n                behaviors.append(\"plone.locking\")\n                logger.info(f\"Enable locking for {portal_type}\")\n            fti.behaviors = behaviors\n        transaction.get().note(\"Re-enabled versioning\")\n        transaction.commit()\n\n        # create initial version for all versioned types\n        logger.info(\"Creating initial versions\")\n        portal_repository = api.portal.get_tool(\"portal_repository\")\n        brains = api.content.find(portal_type=VERSIONED_TYPES)\n        total = len(brains)\n        for index, brain in enumerate(brains):\n            obj = brain.getObject()\n            try:\n                portal_repository.save(obj=obj, comment=\"Imported Version\")\n            except FileTooLargeToVersionError:\n                pass\n            if not index % 1000:\n                msg = f\"Created versions for {index} of {total} items.\"\n                logger.info(msg)\n                transaction.get().note(msg)\n                transaction.commit()\n        msg = \"Created initial versions\"\n        transaction.get().note(msg)\n        transaction.commit()\n\n\nDealing with validation errors\n------------------------------\n\nSometimes you get validation-errors during import because the data cannot be validated.\nThat can happen when options in a field are generated from content in the site.\nIn these cases you cannot be sure that all options already exist in the portal while importing the content.\n\nIt may also happen, when you have validators that rely on content or configuration that does not exist on import.\n\n.. note::\n\n    For relationfields this is not necessary since relations are imported after content anyway!\n\nThere are two ways to handle these issues:\n\n* Use a simple setter bypassing the validation used by the restapi\n* Defer the import until all other imports were run\n\n\nUse a simple setter\n*******************\n\nYou need to specify which content-types and fields you want to handle that way.\n\nIt is put in a key, that the normal import will ignore and set using ``setattr()`` before deserializing the rest of the data.\n\n.. code-block:: python\n\n    SIMPLE_SETTER_FIELDS = {\n        \"ALL\": [\"some_shared_field\"],\n        \"CollaborationFolder\": [\"allowedPartnerDocTypes\"],\n        \"DocType\": [\"automaticTransferTargets\"],\n        \"DPDocument\": [\"scenarios\"],\n        \"DPEvent\" : [\"Status\"],\n    }\n\n    class CustomImportContent(ImportContent):\n\n        def global_dict_hook(self, item):\n            simple = {}\n            for fieldname in SIMPLE_SETTER_FIELDS.get(\"ALL\", []):\n                if fieldname in item:\n                    value = item.pop(fieldname)\n                    if value:\n                        simple[fieldname] = value\n            for fieldname in SIMPLE_SETTER_FIELDS.get(item[\"@type\"], []):\n                if fieldname in item:\n                    value = item.pop(fieldname)\n                    if value:\n                        simple[fieldname] = value\n            if simple:\n                item[\"exportimport.simplesetter\"] = simple\n\n        def global_obj_hook_before_deserializing(self, obj, item):\n            \"\"\"Hook to modify the created obj before deserializing the data.\n            \"\"\"\n            # import simplesetter data before the rest\n            for fieldname, value in item.get(\"exportimport.simplesetter\", {}).items():\n                setattr(obj, fieldname, value)\n\n.. note::\n\n    Using ``global_obj_hook_before_deserializing`` makes sure that data is there when the event-handlers are run after import.\n\nDefer import\n************\n\nYou can also wait until all content is imported before setting the values on these fields.\nAgain you need to find out which fields for which types you want to handle that way.\n\nHere the data is stored in an annotation on the imported object from which it is later read.\nThis example also supports setting some data with ``setattr`` without validating it:\n\n.. code-block:: python\n\n    from plone.restapi.interfaces import IDeserializeFromJson\n    from zope.annotation.interfaces import IAnnotations\n    from zope.component import getMultiAdapter\n\n    DEFERRED_KEY = \"exportimport.deferred\"\n    DEFERRED_FIELD_MAPPING = {\n        \"talk\": [\"somefield\"],\n        \"speaker\": [\n            \"custom_field\",\n            \"another_field\",\n        ]\n    }\n    SIMPLE_SETTER_FIELDS = {\"custom_type\": [\"another_field\"]}\n\n    class CustomImportContent(ImportContent):\n\n        def global_dict_hook(self, item):\n            # Move deferred values to a different key to not deserialize.\n            # This could also be done during export.\n            item[DEFERRED_KEY] = {}\n            for fieldname in DEFERRED_FIELD_MAPPING.get(item[\"@type\"], []):\n                if item.get(fieldname):\n                    item[DEFERRED_KEY][fieldname] = item.pop(fieldname)\n            return item\n\n        def global_obj_hook(self, obj, item):\n            # Store deferred data in an annotation.\n            deferred = item.get(DEFERRED_KEY, {})\n            if deferred:\n                annotations = IAnnotations(obj)\n                annotations[DEFERRED_KEY] = {}\n                for key, value in deferred.items():\n                    annotations[DEFERRED_KEY][key] = value\n\nYou then need a new step in the migration to move the deferred values from the annotation to the field:\n\n.. code-block:: python\n\n    class ImportDeferred(BrowserView):\n\n        def __call__(self):\n            # This example reuses the form export_other.pt from collective.exportimport\n            self.title = \"Import deferred data\"\n            if not self.request.form.get(\"form.submitted\", False):\n                return self.index()\n            portal = api.portal.get()\n            self.results = []\n            for brain in api.content.find(DEFERRED_FIELD_MAPPING.keys()):\n                obj = brain.getObject()\n                self.import_deferred(obj)\n            api.portal.show_message(f\"Imported deferred data for {len(self.results)} items!\", self.request)\n\n        def import_deferred(self, obj):\n            annotations = IAnnotations(obj, {})\n            deferred = annotations.get(DEFERRED_KEY, None)\n            if not deferred:\n                return\n            # Shortcut for simple fields (e.g. storing strings, uuids etc.)\n            for fieldname in SIMPLE_SETTER_FIELDS.get(obj.portal_type, []):\n                value = deferred.pop(fieldname, None)\n                if value:\n                    setattr(obj, fieldname, value)\n            if not deferred:\n                return\n            # This approach validates the values and converts more complex data\n            deserializer = getMultiAdapter((obj, self.request), IDeserializeFromJson)\n            try:\n                obj = deserializer(validate_all=False, data=deferred)\n            except Exception as e:\n                logger.info(\"Error while importing deferred data for %s\", obj.absolute_url(), exc_info=True)\n                logger.info(\"Data: %s\", deferred)\n            else:\n                self.results.append(obj.absolute_url())\n            # cleanup\n            del annotations[DEFERRED_KEY]\n\nThis additional view obviously needs to be registered:\n\n.. code-block:: xml\n\n    <browser:page\n        name=\"import_deferred\"\n        for=\"zope.interface.Interface\"\n        class=\".import_content.ImportDeferred\"\n        template=\"export_other.pt\"\n        permission=\"cmf.ManagePortal\"\n        />\n\n\nHandle LinguaPlone content\n--------------------------\n\nExport:\n\n.. code-block:: python\n\n    def global_dict_hook(self, item, obj):\n        # Find language of the nearest parent with a language\n        # Usefull for LinguaPlone sites where some content is languageindependent\n        parent = obj.__parent__\n        for ancestor in parent.aq_chain:\n            if IPloneSiteRoot.providedBy(ancestor):\n                # keep language for root content\n                nearest_ancestor_lang = item[\"language\"]\n                break\n            if getattr(ancestor, \"getLanguage\", None) and ancestor.getLanguage():\n                nearest_ancestor_lang = ancestor.getLanguage()\n                item[\"parent\"][\"language\"] = nearest_ancestor_lang\n                break\n\n        # This forces \"wrong\" languages to the nearest parents language\n        if \"language\" in item and item[\"language\"] != nearest_ancestor_lang:\n            logger.info(u\"Forcing %s (was %s) for %s %s \", nearest_ancestor_lang, item[\"language\"], item[\"@type\"], item[\"@id\"])\n            item[\"language\"] = nearest_ancestor_lang\n\n        # set missing language\n        if not item.get(\"language\"):\n            item[\"language\"] = nearest_ancestor_lang\n\n        # add info on translations to help find the right container\n        # usually this idone by export_translations\n        # but when migrating from LP to pam you sometimes want to check the\n        # tranlation info during import\n        if getattr(obj.aq_base, \"getTranslations\", None) is not None:\n            translations = obj.getTranslations()\n            if translations:\n                item[\"translation\"] = {}\n                for lang in translations:\n                    uuid = IUUID(translations[lang][0], None)\n                    if uuid == item[\"UID\"]:\n                        continue\n                    translation = translations[lang][0]\n                    if not lang:\n                        lang = \"no_language\"\n                    item[\"translation\"][lang] = translation.absolute_url()\n\nImport:\n\n.. code-block:: python\n\n    def global_dict_hook(self, item):\n\n        # Adapt this to your site\n        languages = [\"en\", \"fr\", \"de\"]\n        default_language = \"en\"\n        portal_id = \"Plone\"\n\n        # No language => lang of parent or default\n        if item.get(\"language\") not in languages:\n            if item[\"parent\"].get(\"language\"):\n                item[\"language\"] = item[\"parent\"][\"language\"]\n            else:\n                item[\"language\"] = default_language\n\n        lang = item[\"language\"]\n\n        if item[\"parent\"].get(\"language\") != item[\"language\"]:\n            logger.debug(f\"Inconsistent lang: item is {lang}, parent is {item['parent'].get('language')} for {item['@id']}\")\n\n        # Move item to the correct language-root-folder\n        # This is only relevant for items in the site-root.\n        # Most items containers are usually looked up by the uuid of the old parent\n        url = item[\"@id\"]\n        parent_url = item[\"parent\"][\"@id\"]\n\n        url = url.replace(f\"/{portal_id}/\", f\"/{portal_id}/{lang}/\", 1)\n        parent_url = parent_url.replace(f\"/{portal_id}\", f\"/{portal_id}/{lang}\", 1)\n\n        item[\"@id\"] = url\n        item[\"parent\"][\"@id\"] = parent_url\n\n        return item\n\nAlternative ways to handle items without parent\n-----------------------------------------------\n\nOften it is better to export and log items for which no container could be found instead of re-creating the original structure.\n\n.. code-block:: python\n\n    def update(self):\n        self.items_without_parent = []\n\n    def create_container(self, item):\n        # Override create_container to never create parents\n        self.items_without_parent.append(item)\n\n    def finish(self):\n        # export content without parents\n        if self.items_without_parent:\n            data = json.dumps(self.items_without_parent, sort_keys=True, indent=4)\n            number = len(self.items_without_parent)\n            cfg = getConfiguration()\n            filename = 'content_without_parent.json'\n            filepath = os.path.join(cfg.clienthome, filename)\n            with open(filepath, 'w') as f:\n                f.write(data)\n            msg = u\"Saved {} items without parent to {}\".format(number, filepath)\n            logger.info(msg)\n            api.portal.show_message(msg, self.request)\n\n\nExport/Import Zope Users\n------------------------\n\nBy default only users and groups stores in Plone are exported/imported.\nYou can export/import Zope user like this.\n\n**Export**\n\n.. code-block:: python\n\n    from collective.exportimport.export_other import BaseExport\n    from plone import api\n\n    import six\n\n    class ExportZopeUsers(BaseExport):\n\n        AUTO_ROLES = [\"Authenticated\"]\n\n        def __call__(self, download_to_server=False):\n            self.title = \"Export Zope users\"\n            self.download_to_server = download_to_server\n            portal = api.portal.get()\n            app = portal.__parent__\n            self.acl = app.acl_users\n            self.pms = api.portal.get_tool(\"portal_membership\")\n            data = self.all_zope_users()\n            self.download(data)\n\n        def all_zope_users(self):\n            results = []\n            for user in self.acl.searchUsers():\n                data = self._getUserData(user[\"userid\"])\n                data['title'] = user['title']\n                results.append(data)\n            return results\n\n        def _getUserData(self, userId):\n            member = self.pms.getMemberById(userId)\n            roles = [\n                role\n                for role in member.getRoles()\n                if role not in self.AUTO_ROLES\n            ]\n            # userid, password, roles\n            props = {\n                \"username\": userId,\n                \"password\": json_compatible(self._getUserPassword(userId)),\n                \"roles\": json_compatible(roles),\n            }\n            return props\n\n        def _getUserPassword(self, userId):\n            users = self.acl.users\n            passwords = users._user_passwords\n            password = passwords.get(userId, \"\")\n            return password\n\n**Import**:\n\n.. code-block:: python\n\n    class ImportZopeUsers(BrowserView):\n\n        def __call__(self, jsonfile=None, return_json=False):\n            if jsonfile:\n                self.portal = api.portal.get()\n                status = \"success\"\n                try:\n                    if isinstance(jsonfile, str):\n                        return_json = True\n                        data = json.loads(jsonfile)\n                    elif isinstance(jsonfile, FileUpload):\n                        data = json.loads(jsonfile.read())\n                    else:\n                        raise (\"Data is neither text nor upload.\")\n                except Exception as e:\n                    status = \"error\"\n                    logger.error(e)\n                    api.portal.show_message(\n                        u\"Failure while uploading: {}\".format(e),\n                        request=self.request,\n                    )\n                else:\n                    members = self.import_members(data)\n                    msg = u\"Imported {} members\".format(members)\n                    api.portal.show_message(msg, self.request)\n                if return_json:\n                    msg = {\"state\": status, \"msg\": msg}\n                    return json.dumps(msg)\n\n            return self.index()\n\n        def import_members(self, data):\n            app = self.portal.__parent__\n            acl = app.acl_users\n            counter = 0\n            for item in data:\n                username = item[\"username\"]\n                password = item.pop(\"password\")\n                roles = item.pop(\"roles\", [])\n                if not username or not password or not roles:\n                    continue\n                title = item.pop(\"title\", None)\n                acl.users.addUser(username, title, password)\n                for role in roles:\n                    acl.roles.assignRoleToPrincipal(role, username)\n                counter += 1\n            return counter\n\n\nExport/Import properties, registry-settings and installed addons\n----------------------------------------------------------------\n\nWhen you migrate multiple similar sites that are configured manually it can be useful to export and import configuration that was set by hand.\n\nExport/Import installed settings and add-ons\n********************************************\n\nThis custom export exports and imports some selected settings and addons from a Plone 4.3 site.\n\n**Export:**\n\n.. code-block:: python\n\n    from collective.exportimport.export_other import BaseExport\n    from logging import getLogger\n    from plone import api\n    from plone.restapi.serializer.converters import json_compatible\n\n    logger = getLogger(__name__)\n\n\n    class ExportSettings(BaseExport):\n        \"\"\"Export various settings for haiku sites\n        \"\"\"\n\n        def __call__(self, download_to_server=False):\n            self.title = \"Export installed addons various settings\"\n            self.download_to_server = download_to_server\n            if not self.request.form.get(\"form.submitted\", False):\n                return self.index()\n\n            data = self.export_settings()\n            self.download(data)\n\n        def export_settings(self):\n            results = {}\n            addons = []\n            qi = api.portal.get_tool(\"portal_quickinstaller\")\n            for product in qi.listInstalledProducts():\n                if product[\"id\"].startswith(\"myproject.\"):\n                    addons.append(product[\"id\"])\n            results[\"addons\"] = addons\n\n            portal = api.portal.get()\n            registry = {}\n            registry[\"plone.email_from_name\"] = portal.getProperty('email_from_name', '')\n            registry[\"plone.email_from_address\"] = portal.getProperty('email_from_address', '')\n            registry[\"plone.smtp_host\"] = getattr(portal.MailHost, 'smtp_host', '')\n            registry[\"plone.smtp_port\"] = int(getattr(portal.MailHost, 'smtp_port', 25))\n            registry[\"plone.smtp_userid\"] = portal.MailHost.get('smtp_user_id')\n            registry[\"plone.smtp_pass\"] = portal.MailHost.get('smtp_pass')\n            registry[\"plone.site_title\"] = portal.title\n\n            portal_properties = api.portal.get_tool(\"portal_properties\")\n            iprops = portal_properties.imaging_properties\n            registry[\"plone.allowed_sizes\"] = iprops.getProperty('allowed_sizes')\n            registry[\"plone.quality\"] = iprops.getProperty('quality')\n            site_props = portal_properties.site_properties\n            if site_props.hasProperty(\"webstats_js\"):\n                registry[\"plone.webstats_js\"] = site_props.webstats_js\n            results[\"registry\"] = json_compatible(registry)\n            return results\n\n\n**Import:**\n\nThe import installs the addons and load the settings in the registry.\nSince Plone 5 portal_properties is no longer used.\n\n.. code-block:: python\n\n    from logging import getLogger\n    from plone import api\n    from plone.registry.interfaces import IRegistry\n    from Products.CMFPlone.utils import get_installer\n    from Products.Five import BrowserView\n    from zope.component import getUtility\n    from ZPublisher.HTTPRequest import FileUpload\n\n    import json\n\n    logger = getLogger(__name__)\n\n    class ImportSettings(BrowserView):\n        \"\"\"Import various settings\"\"\"\n\n        def __call__(self, jsonfile=None, return_json=False):\n            if jsonfile:\n                self.portal = api.portal.get()\n                status = \"success\"\n                try:\n                    if isinstance(jsonfile, str):\n                        return_json = True\n                        data = json.loads(jsonfile)\n                    elif isinstance(jsonfile, FileUpload):\n                        data = json.loads(jsonfile.read())\n                    else:\n                        raise (\"Data is neither text nor upload.\")\n                except Exception as e:\n                    status = \"error\"\n                    logger.error(e)\n                    api.portal.show_message(\n                        \"Failure while uploading: {}\".format(e),\n                        request=self.request,\n                    )\n                else:\n                    self.import_settings(data)\n                    msg = \"Imported addons and settings\"\n                    api.portal.show_message(msg, self.request)\n                if return_json:\n                    msg = {\"state\": status, \"msg\": msg}\n                    return json.dumps(msg)\n\n            return self.index()\n\n        def import_settings(self, data):\n            installer = get_installer(self.context)\n            for addon in data[\"addons\"]:\n                if not installer.is_product_installed(addon) and installer.is_product_installable(addon):\n                    installer.install_product(addon)\n                    logger.info(f\"Installed addon {addon}\")\n            registry = getUtility(IRegistry)\n            for key, value in data[\"registry\"].items():\n                registry[key] = value\n                logger.info(f\"Imported record {key}: {value}\")\n\n\nExport/Import registry settings\n*******************************\n\nThe pull-request https://github.com/collective/collective.exportimport/pull/130 has views ``@@export_registry`` and ``@@import_registry``.\nThese views export and import registry records that do not use the default-setting specified in the schema for that registry record.\nThe export alone could also be usefull to figure out which settings were modified for a site.\n\nThat code will probably not be merged but you can use it in your own projects.\n\nMigrate PloneFormGen to Easyform\n--------------------------------\n\nTo be able to export PFG as easyform you should use the branch ``migration_features_1.x`` of ``collective.easyform`` in your old site.\nEasyform does not need to be installed, we only need the methods ``fields_model`` and ``actions_model``.\n\nExport:\n\n.. code-block:: python\n\n    def dict_hook_formfolder(self, item, obj):\n        item[\"@type\"] = \"EasyForm\"\n        item[\"is_folderish\"] = False\n\n        from collective.easyform.migration.fields import fields_model\n        from collective.easyform.migration.actions import actions_model\n\n        # this does most of the heavy lifting...\n        item[\"fields_model\"] = fields_model(obj)\n        item[\"actions_model\"] = actions_model(obj)\n\n        # handle thankspage\n        pfg_thankspage = obj.get(obj.getThanksPage(), None)\n        if pfg_thankspage:\n            item[\"thankstitle\"] = pfg_thankspage.title\n            item[\"thanksdescription\"] = pfg_thankspage.Description()\n            item[\"showAll\"] = pfg_thankspage.showAll\n            item[\"showFields\"] = pfg_thankspage.showFields\n            item[\"includeEmpties\"] = pfg_thankspage.includeEmpties\n            item[\"thanksPrologue\"] = json_compatible(pfg_thankspage.thanksPrologue.raw)\n            item[\"thanksEpilogue\"] = json_compatible(pfg_thankspage.thanksEpilogue.raw)\n\n        # optional\n        item[\"exportimport._inputStorage\"] = self.export_saved_data(obj)\n\n        # Drop some PFG fields no longer needed\n        obsolete_fields = [\n            \"layout\",\n            \"actionAdapter\",\n            \"checkAuthenticator\",\n            \"constrainTypesMode\",\n            \"location\",\n            \"thanksPage\",\n        ]\n        for key in obsolete_fields:\n            item.pop(key, None)\n\n        # optional: disable tabs for imported forms\n        item[\"form_tabbing\"] = False\n\n        # fix some custom validators\n        replace_mapping = {\n            \"request.form['\": \"request.form['form.widgets.\",\n            \"request.form.get('\": \"request.form.get('form.widgets.\",\n            \"member and member.id or ''\": \"member and member.getProperty('id', '') or ''\",\n        }\n\n        # fix overrides in actions and fields to use form.widgets.xyz instead of xyz\n        for schema in [\"actions_model\", \"fields_model\"]:\n            for old, new in replace_mapping.items():\n                if old in item[schema]:\n                    item[schema] = item[schema].replace(old, new)\n\n            # add your own fields if you have these issues...\n            for fieldname in [\n                \"email\",\n                \"replyto\",\n            ]:\n                if \"request/form/{}\".format(fieldname) in item[schema]:\n                    item[schema] = item[schema].replace(\"request/form/{}\".format(fieldname), \"python: request.form.get('form.widgets.{}')\".format(fieldname))\n\n        return item\n\n    def export_saved_data(self, obj):\n        actions = {}\n        for data_adapter in obj.objectValues(\"FormSaveDataAdapter\"):\n            data_adapter_name = data_adapter.getId()\n            actions[data_adapter_name] = {}\n            cols = data_adapter.getColumnNames()\n            column_count_mismatch = False\n            for idx, row in enumerate(data_adapter.getSavedFormInput()):\n                if len(row) != len(cols):\n                    column_count_mismatch = True\n                    logger.debug(\"Column count mismatch at row %s\", idx)\n                    continue\n                data = {}\n                for key, value in zip(cols, row):\n                    data[key] = json_compatible(value)\n                id_ = int(time() * 1000)\n                while id_ in actions[data_adapter_name]:  # avoid collisions during export\n                    id_ += 1\n                data[\"id\"] = id_\n                actions[data_adapter_name][id_] = data\n            if column_count_mismatch:\n                logger.info(\n                    \"Number of columns does not match for all rows. Some data were skipped in \"\n                    \"data adapter %s/%s\",\n                    \"/\".join(obj.getPhysicalPath()),\n                    data_adapter_name,\n                )\n        return actions\n\nImport exported PloneFormGen data into Easyform:\n\n.. code-block:: python\n\n    def obj_hook_easyform(self, obj, item):\n        if not item.get(\"exportimport._inputStorage\"):\n            return\n        from collective.easyform.actions import SavedDataBTree\n        from persistent.mapping import PersistentMapping\n        if not hasattr(obj, '_inputStorage'):\n            obj._inputStorage = PersistentMapping()\n        for name, data in item[\"exportimport._inputStorage\"].items():\n            obj._inputStorage[name] = SavedDataBTree()\n            for key, row in data.items():\n                 obj._inputStorage[name][int(key)] = row\n\n\nExport and import collective.cover content\n------------------------------------------\n\nExport:\n\n.. code-block:: python\n\n    from collective.exportimport.serializer import get_dx_blob_path\n    from plone.app.textfield.value import RichTextValue\n    from plone.namedfile.file import NamedBlobImage\n    from plone.restapi.interfaces import IJsonCompatible\n    from z3c.relationfield import RelationValue\n    from zope.annotation.interfaces import IAnnotations\n\n    def global_dict_hook(self, item, obj):\n        item = self.handle_cover(item, obj)\n        return item\n\n    def handle_cover(self, item, obj):\n        if ICover.providedBy(obj):\n            item['tiles'] = {}\n            annotations = IAnnotations(obj)\n            for tile in obj.get_tiles():\n                annotation_key = 'plone.tiles.data.{}'.format(tile['id'])\n                annotation = annotations.get(annotation_key, None)\n                if annotation is None:\n                    continue\n                tile_data = self.serialize_tile(annotation)\n                tile_data['type'] = tile['type']\n                item['tiles'][tile['id']] = tile_data\n        return item\n\n    def serialize_tile(self, annotation):\n        data = {}\n        for key, value in annotation.items():\n            if isinstance(value, RichTextValue):\n                value = value.raw\n            elif isinstance(value, RelationValue):\n                value = value.to_object.UID()\n            elif isinstance(value, NamedBlobImage):\n                blobfilepath = get_dx_blob_path(value)\n                if not blobfilepath:\n                    continue\n                value = {\n                    \"filename\": value.filename,\n                    \"content-type\": value.contentType,\n                    \"size\": value.getSize(),\n                    \"blob_path\": blobfilepath,\n                }\n            data[key] = IJsonCompatible(value, None)\n        return data\n\nImport:\n\n.. code-block:: python\n\n    from collections import defaultdict\n    from collective.exportimport.import_content import get_absolute_blob_path\n    from plone.app.textfield.interfaces import IRichText\n    from plone.app.textfield.interfaces import IRichTextValue\n    from plone.namedfile.file import NamedBlobImage\n    from plone.namedfile.interfaces import INamedBlobImageField\n    from plone.tiles.interfaces import ITileType\n    from zope.annotation.interfaces import IAnnotations\n    from zope.component import getUtilitiesFor\n    from zope.schema import getFieldsInOrder\n\n    COVER_CONTENT = [\n        \"collective.cover.content\",\n    ]\n\n    def global_obj_hook(self, obj, item):\n        if item[\"@type\"] in COVER_CONTENT and \"tiles\" in item:\n            item = self.import_tiles(obj, item)\n\n    def import_tiles(self, obj, item):\n        RICHTEXT_TILES = defaultdict(list)\n        IMAGE_TILES = defaultdict(list)\n        for tile_name, tile_type in getUtilitiesFor(ITileType):\n            for fieldname, field in getFieldsInOrder(tile_type.schema):\n                if IRichText.providedBy(field):\n                    RICHTEXT_TILES[tile_name].append(fieldname)\n                if INamedBlobImageField.providedBy(field):\n                    IMAGE_TILES[tile_name].append(fieldname)\n\n        annotations = IAnnotations(obj)\n        prefix = \"plone.tiles.data.\"\n        for uid, tile in item[\"tiles\"].items():\n            # TODO: Maybe create all tiles that do not need to be defferred?\n            key = prefix + uid\n            tile_name = tile.pop(\"type\", None)\n            # first set raw data\n            annotations[key] = item[\"tiles\"][uid]\n            for fieldname in RICHTEXT_TILES.get(tile_name, []):\n                raw = annotations[key][fieldname]\n                if raw is not None and not IRichTextValue.providedBy(raw):\n                    annotations[key][fieldname] = RichTextValue(raw, \"text/html\", \"text/x-html-safe\")\n            for fieldname in IMAGE_TILES.get(tile_name, []):\n                data = annotations[key][fieldname]\n                if data is not None:\n                    blob_path = data.get(\"blob_path\")\n                    if not blob_path:\n                        continue\n\n                    abs_blob_path = get_absolute_blob_path(obj, blob_path)\n                    if not abs_blob_path:\n                        logger.info(\"Blob path %s for tile %s of %s %s does not exist!\", blob_path, tile, obj.portal_type, obj.absolute_url())\n                        continue\n                    # Determine the class to use: file or image.\n                    filename = data[\"filename\"]\n                    content_type = data[\"content-type\"]\n\n                    # Write the field.\n                    with open(abs_blob_path, \"rb\") as myfile:\n                        blobdata = myfile.read()\n                    image = NamedBlobImage(\n                        data=blobdata,\n                        contentType=content_type,\n                        filename=filename,\n                    )\n                    annotations[key][fieldname] = image\n        return item\n\n\nFixing invalid collection queries\n---------------------------------\n\nSome queries changes between Plone 4 and 5.\nThis fixes the issues.\n\nThe actual migration of topics to collections in ``collective.exportimport.serializer.SerializeTopicToJson`` does not (yet) take care of that.\n\n.. code-block:: python\n\n    class CustomImportContent(ImportContent):\n\n        def global_dict_hook(self, item):\n            if item[\"@type\"] in [\"Collection\", \"Topic\"]:\n                item = self.fix_query(item)\n\n        def fix_query(self, item):\n            item[\"@type\"] = \"Collection\"\n            query = item.pop(\"query\", [])\n            if not query:\n                logger.info(\"Drop item without query: %s\", item[\"@id\"])\n                return\n\n            fixed_query = []\n            indexes_to_fix = [\n                \"portal_type\",\n                \"review_state\",\n                \"Creator\",\n                \"Subject\",\n            ]\n            operator_mapping = {\n                # old -> new\n                \"plone.app.querystring.operation.selection.is\":\n                    \"plone.app.querystring.operation.selection.any\",\n                \"plone.app.querystring.operation.string.is\":\n                    \"plone.app.querystring.operation.selection.any\",\n            }\n\n            for crit in query:\n                if crit[\"i\"] == \"portal_type\" and len(crit[\"v\"]) > 30:\n                    # Criterion is all types\n                    continue\n\n                if crit[\"o\"].endswith(\"relativePath\") and crit[\"v\"] == \"..\":\n                    # relativePath no longer accepts ..\n                    crit[\"v\"] = \"..::1\"\n\n                if crit[\"i\"] in indexes_to_fix:\n                    for old_operator, new_operator in operator_mapping.items():\n                        if crit[\"o\"] == old_operator:\n                            crit[\"o\"] = new_operator\n\n                if crit[\"i\"] == \"portal_type\":\n                    # Some types may have changed their names\n                    fixed_types = []\n                    for portal_type in crit[\"v\"]:\n                        fixed_type = PORTAL_TYPE_MAPPING.get(portal_type, portal_type)\n                        fixed_types.append(fixed_type)\n                    crit[\"v\"] = list(set(fixed_types))\n\n                if crit[\"i\"] == \"review_state\":\n                    # Review states may have changed their names\n                    fixed_states = []\n                    for review_state in crit[\"v\"]:\n                        fixed_state = REVIEW_STATE_MAPPING.get(review_state, review_state)\n                        fixed_states.append(fixed_state)\n                    crit[\"v\"] = list(set(fixed_states))\n\n                if crit[\"o\"] == \"plone.app.querystring.operation.string.currentUser\":\n                    crit[\"v\"] = \"\"\n\n                fixed_query.append(crit)\n            item[\"query\"] = fixed_query\n\n            if not item[\"query\"]:\n                logger.info(\"Drop collection without query: %s\", item[\"@id\"])\n                return\n            return item\n\n\nMigrate to Volto\n----------------\n\nYou can reuse the migration-code provided by ``@@migrate_to_volto`` in ``plone.volto`` in a migration.\nThe following example (used for migrating https://plone.org to Volto) can be used to migrate a site from any older version to Plone 6 with Volto.\n\nYou need to have the Blocks Conversion Tool (https://github.com/plone/blocks-conversion-tool) running that takes care of migrating richtext-values to Volto-blocks.\n\nSee https://6.docs.plone.org/backend/upgrading/version-specific-migration/migrate-to-volto.html for more details on the changes the migration to Volto does.\n\n\n.. code-block:: python\n\n    from App.config import getConfiguration\n    from bs4 import BeautifulSoup\n    from collective.exportimport.fix_html import fix_html_in_content_fields\n    from collective.exportimport.fix_html import fix_html_in_portlets\n    from contentimport.interfaces import IContentimportLayer\n    from logging import getLogger\n    from pathlib import Path\n    from plone import api\n    from plone.volto.browser.migrate_to_volto import migrate_richtext_to_blocks\n    from plone.volto.setuphandlers import add_behavior\n    from plone.volto.setuphandlers import remove_behavior\n    from Products.CMFPlone.utils import get_installer\n    from Products.Five import BrowserView\n    from zope.interface import alsoProvides\n\n    import requests\n    import transaction\n\n    logger = getLogger(__name__)\n\n    DEFAULT_ADDONS = []\n\n\n    class ImportAll(BrowserView):\n\n        def __call__(self):\n\n            request = self.request\n\n            # Check if Blocks-conversion-tool is running\n            headers = {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\",\n            }\n            r = requests.post(\n                \"http://localhost:5000/html\", headers=headers, json={\"html\": \"<p>text</p>\"}\n            )\n            r.raise_for_status()\n\n            # Submit a simple form template to trigger the import\n            if not request.form.get(\"form.submitted\", False):\n                return self.index()\n\n            portal = api.portal.get()\n            alsoProvides(request, IContentimportLayer)\n\n            installer = get_installer(portal)\n            if not installer.is_product_installed(\"contentimport\"):\n                installer.install_product(\"contentimport\")\n\n            # install required addons\n            for addon in DEFAULT_ADDONS:\n                if not installer.is_product_installed(addon):\n                    installer.install_product(addon)\n\n            # Fake the target being a classic site even though plone.volto is installed...\n            # 1. Allow Folders and Collections (they are disabled in Volto by default)\n            portal_types = api.portal.get_tool(\"portal_types\")\n            portal_types[\"Collection\"].global_allow = True\n            portal_types[\"Folder\"].global_allow = True\n            # 2. Enable richtext behavior (otherwise no text will be imported)\n            for type_ in [\"Document\", \"News Item\", \"Event\"]:\n                add_behavior(type_, \"plone.richtext\")\n\n            transaction.commit()\n            cfg = getConfiguration()\n            directory = Path(cfg.clienthome) / \"import\"\n\n            # Import content\n            view = api.content.get_view(\"import_content\", portal, request)\n            request.form[\"form.submitted\"] = True\n            request.form[\"commit\"] = 500\n            view(server_file=\"Plone.json\", return_json=True)\n            transaction.commit()\n\n            # Run all other imports\n            other_imports = [\n                \"relations\",\n                \"members\",\n                \"translations\",\n                \"localroles\",\n                \"ordering\",\n                \"defaultpages\",\n                \"discussion\",\n                \"portlets\",  # not really useful in Volto\n                \"redirects\",\n            ]\n            for name in other_imports:\n                view = api.content.get_view(f\"import_{name}\", portal, request)\n                path = Path(directory) / f\"export_{name}.json\"\n                if path.exists():\n                    results = view(jsonfile=path.read_text(), return_json=True)\n                    logger.info(results)\n                    transaction.get().note(f\"Finished import_{name}\")\n                    transaction.commit()\n                else:\n                    logger.info(f\"Missing file: {path}\")\n\n            # Optional: Run html-fixers on richtext\n            fixers = [anchor_fixer]\n            results = fix_html_in_content_fields(fixers=fixers)\n            msg = \"Fixed html for {} content items\".format(results)\n            logger.info(msg)\n            transaction.get().note(msg)\n            transaction.commit()\n\n            results = fix_html_in_portlets()\n            msg = \"Fixed html for {} portlets\".format(results)\n            logger.info(msg)\n            transaction.get().note(msg)\n            transaction.commit()\n\n            view = api.content.get_view(\"updateLinkIntegrityInformation\", portal, request)\n            results = view.update()\n            msg = f\"Updated linkintegrity for {results} items\"\n            logger.info(msg)\n            transaction.get().note(msg)\n            transaction.commit()\n\n            # Rebuilding the catalog is necessary to prevent issues later on\n            catalog = api.portal.get_tool(\"portal_catalog\")\n            logger.info(\"Rebuilding catalog...\")\n            catalog.clearFindAndRebuild()\n            msg = \"Finished rebuilding catalog!\"\n            logger.info(msg)\n            transaction.get().note(msg)\n            transaction.commit()\n\n            # This uses the blocks-conversion-tool to migrate to blocks\n            logger.info(\"Start migrating richtext to blocks...\")\n            migrate_richtext_to_blocks()\n            msg = \"Finished migrating richtext to blocks\"\n            transaction.get().note(msg)\n            transaction.commit()\n\n            # Reuse the migration-form from plon.volto to do some more tasks\n            view = api.content.get_view(\"migrate_to_volto\", portal, request)\n            # Yes, wen want to migrate default pages\n            view.migrate_default_pages = True\n            view.slate = True\n            logger.info(\"Start migrating Folders to Documents...\")\n            view.do_migrate_folders()\n            msg = \"Finished migrating Folders to Documents!\"\n            transaction.get().note(msg)\n            transaction.commit()\n\n            logger.info(\"Start migrating Collections to Documents...\")\n            view.migrate_collections()\n            msg = \"Finished migrating Collections to Documents!\"\n            transaction.get().note(msg)\n            transaction.commit()\n\n            reset_dates = api.content.get_view(\"reset_dates\", portal, request)\n            reset_dates()\n            transaction.commit()\n\n            # Disallow folders and collections again\n            portal_types[\"Collection\"].global_allow = False\n            portal_types[\"Folder\"].global_allow = False\n\n            # Disable richtext behavior again\n            for type_ in [\"Document\", \"News Item\", \"Event\"]:\n                remove_behavior(type_, \"plone.richtext\")\n\n            return request.response.redirect(portal.absolute_url())\n\n\n    def anchor_fixer(text, obj=None):\n        \"\"\"Remove anchors since they are not supported by Volto yet\"\"\"\n        soup = BeautifulSoup(text, \"html.parser\")\n        for link in soup.find_all(\"a\"):\n            if not link.get(\"href\") and not link.text:\n                # drop empty links (e.g. anchors)\n                link.decompose()\n            elif not link.get(\"href\") and link.text:\n                # drop links without a href but keep the text\n                link.unwrap()\n        return soup.decode()\n\n\nWritten by\n==========\n\n.. image:: ./docs/starzel.png\n    :target: https://www.starzel.de\n    :alt: Starzel.de\n\n\n\nInstallation\n============\n\nInstall collective.exportimport by adding it to your buildout::\n\n    [buildout]\n\n    ...\n\n    eggs =\n        collective.exportimport\n\n\nand then running ``bin/buildout``\n\nYou don't need to activate the add-on in the Site Setup Add-ons control panel to be able to use the forms @@export_content and @@import_content in your site.\n\nYou do need to add it to your buildout configuration and run buildout to make these features available at all. See https://docs.plone.org/manage/installing/installing_addons.html for details.\n\nInstalling in Plone 4\n---------------------\n\ncollective.exportimport depends on plone.restapi . For Plone 4, you need to pin plone.restapi to 7.x . When installing plone.restapi version 7.x.x in Plone 4 you may need to add the following version pins to your buildout::\n\n    [versions]\n    PyJWT = 1.7.1\n\n    six = 1.11.0\n    attrs = 21.2.0\n    plone.rest = 1.6.2\n    plone.schema = 1.3.0\n    # Last pyrsistent version that is python 2 compatible:\n    pyrsistent = 0.15.7\n\n    # Required by:\n    # jsonschema==3.2.0\n    functools32 = 3.2.3.post2\n\n    # Required by:\n    # plone.schema==1.3.0\n    jsonschema = 3.2.0\n\n    # Required by:\n    # importlib-metadata==1.3.0\n    pathlib2 = 2.3.5\n\n    # Required by:\n    # pathlib2==2.3.5\n    scandir = 1.10.0\n\n    # plone.app.contenttypes > 1.0\n    plone.app.contenttypes = 1.1.9\n\n    importlib-metadata = 2.1.3\n    zipp = 1.2.0\n    configparser = 4.0.2\n    contextlib2 = 0.6.0.post1\n\n\nThese versions are taken from the plone.restapi 7.x README: https://pypi.org/project/plone.restapi/7.8.1/\n\n\n\nContribute\n==========\n\n- Issue Tracker: https://github.com/collective/collective.exportimport/issues\n- Source Code: https://github.com/collective/collective.exportimport\n\n\nSupport\n-------\n\nIf you are having issues, please let us know.\n\n\nLicense\n-------\n\nThe project is licensed under the GPLv2.\n\n\nContributors\n============\n\n- Philip Bauer, bauer@starzel.de\n\n- Maurits van Rees, m.van.rees@zestsoftware.nl\n\n- Fred van Dijk, f.van.dijk@zestsoftware.nl\n\nChangelog\n=========\n\n\n1.7 (2023-01-20)\n----------------\n\n- Filter out 'Discussion Item' in content type export list. Comments have their own export and\n  import views. A normal content type export for comments will raise a KeyError when trying to find\n  the parent. (#112)\n  [fredvd]\n\n- Be more specific in the import_translation endpoint condition to install in a site with p.a.multilingual 1.x\n  [erral]\n\n- Fix importing hidden portlets as visible. (#152)\n  [pbauer]\n\n- Use ``Language=all`` when querying TranslationGroup items\n  [erral]\n\n- Fix members import, by handling members that already exist.\n  [sunew]\n\n- Don't use new_id because a hook can change ``item[\"id\"]``\n  [pbauer]\n\n- Support exporting the blob-path without having access to the blobs.\n  [pbauer]\n\n- Set image-variants in html-fields when running @@fix_html targeting in Plone 6.\n  [pbauer]\n\n\n1.6 (2022-10-07)\n----------------\n\n- Export and import all group-members (including ldap-users and -groups).\n  Previously it only exported users and groups created in Plone.\n  [pbauer]\n\n- Support importing content without a UUID (e.g. for importing from an external source).\n  The minimal required data is @id, @type, id, and @parent[\"@id\"].\n  [pbauer]\n\n- Export only value when serializing vocabulary-based fields instead of token/title.\n  [pbauer]\n\n- Improve logging of errors during import.\n  [pbauer]\n\n- Add INCLUDE_PATHS to specify which paths only should be imported.\n  [pbauer]\n\n- Add import_review_state to allow overriding setting the review_state during import.\n  [pbauer]\n\n- Export parent UID and use it to find the container to import.\n  [pbauer]\n\n- Move the various export-hooks into update_export_data for readability.\n  [pbauer]\n\n- Support export to server by passing ``download_to_server=True`` for all exports (#115).\n  [pbauer]\n\n- Add support for adding custom html-fixers to fix_html_in_content_fields.\n  [pbauer]\n\n\n1.5 (2022-04-26)\n----------------\n\n- Fix AttributeError for getPhysicalPath when checking parent, issue 123.\n  [maurits]\n\n- Export and import redirection tool data.\n  [gotcha, Michael Penninck]\n\n- Serialize Products.TALESField fields as raw instead of evaluated expression.\n  (useful to export PFG overrides)\n  [sauzher]\n\n- Make sure we never change a acquired modification_date or creation_date.\n  [pbauer]\n\n- Export and import workflow_history.\n  [pbauer]\n\n- Fail gracefully on errors during importing portlets.\n  [pbauer]\n\n- Ignore containers where content should be imported to that are non-folderish.\n  [pbauer]\n\n- Use catalog instead of ZopeFindAndApply and better logging for export_discussion.\n  [pbauer]\n\n- Add converter for long ints (py2 only).\n  [pbauer]\n\n- By default no not export linkintegrity relations.\n  [pbauer]\n\n- Log detailed exception when exporting content fails.\n  [pbauer]\n\n- Add start and finish hooks for export of content.\n  [pbauer]\n\n- Rewrite export/import of default pages: Use uuid of default-page instead of id.\n  Rewrite getting default_page to fix various issues with translated content.\n  [pbauer]\n\n- Add export and import of versions/revisions of content (#105).\n  [pbauer]\n\n\n1.4 (2022-01-07)\n----------------\n\n- Fix ``debug`` flag in ``ExportRelations``\n  [petschki]\n\n- Deserialize portlet-data using restapi to fix importing RichText.\n  [pbauer]\n\n- Fix importing richtext with html-entities. Fixes #99\n  [pbauer]\n\n- Preserve links to browser-views by using a custom find_object. Fixes #97\n  [pbauer]\n\n- Ignore linkintegrity when importing items with replace-strategy.\n  [pbauer]\n\n- Add tests for fix_html.\n  [pbauer]\n\n\n1.3 (2021-12-08)\n----------------\n\n- Handle default page of the site root object.\n  [fulv]\n\n- Optionally (checkbox) skip existing content on import instead of generating it new with a randomized id.\n  [petschki]\n\n- Fix `UnboundLocalError` when calling `import_content` with `return_json` and `server_file`.\n  [petschki]\n\n- Add option to make a commit every x items.\n  [pbauer]\n\n- Improve logging during import in vairous cases.\n  [pbauer]\n\n- Work around case where api.content.get(path=parent_path) raises NotFound instead of returning None.\n  [pbauer]\n\n- Keep value of import_to_current_folder.\n  [pbauer]\n\n- Fix html unescape in py3.\n  [pbauer]\n\n- Fix serializing ATNewsItem image field content.\n  [gotcha]\n\n- Migrate eventUrl to event_url (AT to DX).\n  [ThibautBorn]\n\n- Log items that cannot be serialized instead of aborting the export.\n  [ThibautBorn]\n\n- Add a item_hook to export_localroles.\n  [ThibautBorn]\n\n- Fix handling of checkboxes for skip_existing_content and import_to_current_folder.\n  [pbauer]\n\n- Move intermediary commit code into commit_hook method to allow overriding.\n  [pbauer]\n\n- Add hook global_obj_hook_before_deserializing to modify the created obj before deserializing the data.\n  [pbauer]\n\n- Add support to update and to replace existing content during import (#76)\n  [pbauer]\n\n- Reindex permissions after importing local roles.\n  [pbauer]\n\n- Add export/import for constrains but import content without checking constrains or permissions (#71).\n  [pbauer]\n\n\n1.2 (2021-10-11)\n----------------\n\n- Prevent creating content in a different Plone Site in the same database (#52).\n  In general, cleanup parent paths when in development on localhost.\n  [maurits]\n\n- Read environment variable ``COLLECTIVE_EXPORTIMPORT_CENTRAL_DIRECTORY`` (#51).\n  When set, this is used for storing an export file and getting an import file.\n  This is useful for sharing content between multiple Plone Sites on the same server.\n  [maurits]\n\n- Unescape html entities and line-breaks when importing comments (#43).\n  [pbauer]\n\n- Export and import complete sites or content trees with configurable types, depth and path (#40).\n  [pbauer]\n\n- Added option to export blobs as blob paths (#50).\n  [pbauer, maurits]\n\n- Fixed creating missing folder structure (#45).\n  [maurits]\n\n- Export and import portlets (#39).\n  [pbauer]\n\n- Export content and write to file using a generator/yield. This avoids memory ballooning to the size of the exported file (#41).\n  [fredvd]\n\n\n1.1 (2021-08-02)\n----------------\n\n- Add option to import file from server.\n  [maurits]\n\n- Missing ``</form>`` closing tag in ``export_content.pt``\n  [petschki]\n\n- Support disabled aquisition of local roles during export/import of local roles.\n  [pbauer]\n\n- Use unrestrictedSearchResults to actually export all content.\n  [pbauer]\n\n- Add commit message after importing one type.\n  [pbauer]\n\n- Fix getting container for some cases.\n  [pbauer]\n\n- Fix use in Plone 4.3 without dexterity, zc.relation or plone.app.contenttypes.\n  [pbauer]\n\n- Fix @id of collections and parents of subcollections. Fix #30\n  [pbauer]\n\n- Fix use in Plone 4.3 with dexterity but without z3c.relationfield.\n  [maurits]\n\n- Add export and import for discussions/comments.\n  [pbauer]\n\n- Add option to fix collection queries after import.\n  [thomasmassmann]\n\n- Reset Creation Date. Fix #29\n  [pbauer]\n\n- Remove custom serializer for relations beacuse of ConfigurationConflictError with restapi.\n  Relations are dropped anyway in update_data_for_migration when using the default setting.\n  [pbauer]\n\n- Migrate batch size for topics.\n  [pbauer]\n\n- Fix issue of reusing the previous container when no container for a item could be found.\n  [pbauer]\n\n- Add hook self.finish() to do things after importing one file.\n  [pbauer]\n\n- Fix installation with older versions of setuptools (#35)\n  [pbauer]\n\n- Fix installation using pip (#36)\n  [ericof]\n\n- Do not constrain exportable FTIs to allow export of types as CalendarXFolder or ATTopic Criteria.\n  [pbauer]\n\n- Add hook self.start() to do things after importing one file.\n  [pbauer]\n\n\n1.0 (2021-04-27)\n----------------\n\n- Support setting values with ``factory_kwargs`` when creating instances during import.\n  This can be used to set values that need to be there during subscribers to IObjectAddedEvent.\n  [pbauer]\n\n\n1.0b1 (2021-03-26)\n------------------\n\n- Add option to save export on server.\n  [pbauer]\n\n- Fix issues in import_relations and import_ordering.\n  [pbauer]\n\n- Use links to other exports in export_content for easier override.\n  [pbauer]\n\n- Add support for exporting LinguaPlone translations.\n  [pbauer]\n\n\n1.0a2 (2021-03-11)\n------------------\n\n- Simplify package structure and remove all unneeded files\n  [pbauer]\n\n- Add export/import for position in parent\n  [pbauer]\n\n\n1.0a1 (2021-03-10)\n------------------\n\n- Initial release.\n  [pbauer]\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/collective/collective.exportimport",
    "keywords": "Python Plone CMS",
    "license": "GPL version 2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "collective.exportimport",
    "package_url": "https://pypi.org/project/collective.exportimport/",
    "platform": null,
    "project_url": "https://pypi.org/project/collective.exportimport/",
    "project_urls": {
      "Documentation": "https://github.com/collective/collective.exportimport#readme",
      "Homepage": "https://github.com/collective/collective.exportimport",
      "PyPI": "https://pypi.python.org/pypi/collective.exportimport",
      "Source": "https://github.com/collective/collective.exportimport",
      "Tracker": "https://github.com/collective/collective.exportimport/issues"
    },
    "release_url": "https://pypi.org/project/collective.exportimport/1.7/",
    "requires_dist": [
      "setuptools",
      "plone.api (>=1.8.4)",
      "hurry.filesize",
      "ijson",
      "six",
      "plone.restapi",
      "beautifulsoup4",
      "plone.app.testing ; extra == 'test'",
      "plone.app.robotframework ; extra == 'test'",
      "plone.app.contenttypes ; extra == 'test'"
    ],
    "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
    "summary": "An add-on for Plone to Export and import content, members, relations, translations and localroles.",
    "version": "1.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16502760,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "10510e75c122f659b8bc91b1fb81abaf84e3423056e1a0775509cb17cb367761",
          "md5": "6be24ca1ba9869f2b99afbcc9bfb132e",
          "sha256": "60ed506bf629102ce73237361924605ca4e13ad9b3699e8834359d4645e86a88"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6be24ca1ba9869f2b99afbcc9bfb132e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "==2.7, >=3.6",
        "size": 167965,
        "upload_time": "2021-04-27T18:06:20",
        "upload_time_iso_8601": "2021-04-27T18:06:20.903575Z",
        "url": "https://files.pythonhosted.org/packages/10/51/0e75c122f659b8bc91b1fb81abaf84e3423056e1a0775509cb17cb367761/collective.exportimport-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0a1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "833bb5611707f5f7a7d124019c9a99c8d3457a95d9b2e339b11caa78d1926c3f",
          "md5": "32476f794f18e2cdd4104e3a3c6fdc1b",
          "sha256": "4ff652ef14d6f13f09e24b039aab5ca8d450b5ae7abe5a6f45da72984a6c7840"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.0a1.tar.gz",
        "has_sig": false,
        "md5_digest": "32476f794f18e2cdd4104e3a3c6fdc1b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "==2.7, >=3.6",
        "size": 621675,
        "upload_time": "2021-03-10T10:12:34",
        "upload_time_iso_8601": "2021-03-10T10:12:34.224087Z",
        "url": "https://files.pythonhosted.org/packages/83/3b/b5611707f5f7a7d124019c9a99c8d3457a95d9b2e339b11caa78d1926c3f/collective.exportimport-1.0a1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0a2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5f1fb5feab0323e6826c165f7aff1f9468c8fc9d0f75d842bcaf705894ec23e3",
          "md5": "e3e81f1a33796d4fc323253cb0fa0076",
          "sha256": "d9ef29724fb5e8459f99e283730483793c0130b9b6f4587257c0476a592ae5da"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.0a2.tar.gz",
        "has_sig": false,
        "md5_digest": "e3e81f1a33796d4fc323253cb0fa0076",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "==2.7, >=3.6",
        "size": 618525,
        "upload_time": "2021-03-11T16:09:08",
        "upload_time_iso_8601": "2021-03-11T16:09:08.654008Z",
        "url": "https://files.pythonhosted.org/packages/5f/1f/b5feab0323e6826c165f7aff1f9468c8fc9d0f75d842bcaf705894ec23e3/collective.exportimport-1.0a2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0b1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e00a025a06fd7141f6a132aa1c74af44bd51e4a13a8fe914c230908d8e5164a3",
          "md5": "12d9c78ddfcad82ff43bcf910860283f",
          "sha256": "0435d44128eb1e92e0b1079f677c05b91006ba5c88424d6b4e9b8e855b33402f"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.0b1.tar.gz",
        "has_sig": false,
        "md5_digest": "12d9c78ddfcad82ff43bcf910860283f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": "==2.7, >=3.6",
        "size": 620713,
        "upload_time": "2021-03-26T17:45:49",
        "upload_time_iso_8601": "2021-03-26T17:45:49.991872Z",
        "url": "https://files.pythonhosted.org/packages/e0/0a/025a06fd7141f6a132aa1c74af44bd51e4a13a8fe914c230908d8e5164a3/collective.exportimport-1.0b1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dab2077d8c4aed0b004d324cfddfd106e66843a73fc28bf3823216a9db7db4ba",
          "md5": "0897062ed8a5dc3674c40f334bf04900",
          "sha256": "a2d89f89064b79b012521c9399459497bfe3f1d3629ebd56da387a278ff82827"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0897062ed8a5dc3674c40f334bf04900",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 248173,
        "upload_time": "2021-08-02T10:37:16",
        "upload_time_iso_8601": "2021-08-02T10:37:16.132589Z",
        "url": "https://files.pythonhosted.org/packages/da/b2/077d8c4aed0b004d324cfddfd106e66843a73fc28bf3823216a9db7db4ba/collective.exportimport-1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9cf67b88cb0e8b649e2fa5d8d97b9abf2cdbbcb680790eaa1402b4072e786910",
          "md5": "aceb6089495211be0f6ef63de69b3904",
          "sha256": "7722b6a3c43f4ef88ae4702b357162e1f3badf0d28644207227e133808795572"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "aceb6089495211be0f6ef63de69b3904",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 66573,
        "upload_time": "2021-10-11T08:09:16",
        "upload_time_iso_8601": "2021-10-11T08:09:16.237853Z",
        "url": "https://files.pythonhosted.org/packages/9c/f6/7b88cb0e8b649e2fa5d8d97b9abf2cdbbcb680790eaa1402b4072e786910/collective.exportimport-1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7f406654fcd2bdba131126ebf607a4d7a22f6735bb9da5b669e9d81efce601ed",
          "md5": "ac995ab238df96a9b0d7e305f785a2a0",
          "sha256": "63e82d02f6a83ccf4bcb613abb52508733d05d7f71057cfeed5a5212ca5721bf"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ac995ab238df96a9b0d7e305f785a2a0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 292296,
        "upload_time": "2021-10-11T08:09:18",
        "upload_time_iso_8601": "2021-10-11T08:09:18.450113Z",
        "url": "https://files.pythonhosted.org/packages/7f/40/6654fcd2bdba131126ebf607a4d7a22f6735bb9da5b669e9d81efce601ed/collective.exportimport-1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c8897050ccf61ff1333149bdfb2a5f0d35344aac1501c6bbfcc0e9159180b640",
          "md5": "f47c37f6b46ad976e86eb7854051edea",
          "sha256": "f2829eedf650bf5d1d8c030fb99e21d9be1dfe6583ddf70cbf552fc6a334c34e"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f47c37f6b46ad976e86eb7854051edea",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 74657,
        "upload_time": "2021-12-08T11:13:08",
        "upload_time_iso_8601": "2021-12-08T11:13:08.804875Z",
        "url": "https://files.pythonhosted.org/packages/c8/89/7050ccf61ff1333149bdfb2a5f0d35344aac1501c6bbfcc0e9159180b640/collective.exportimport-1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "12619d7b55f0af31e8682ce69073a4d6fd0f5628c39d9dcfefd4cc6dccfe371d",
          "md5": "b72d6b051842edda4b3ea64d2fe2b78b",
          "sha256": "aef5fd1a13e9ea181a90bfcbe63fdeeeb387d27e5542ba8ea5021afc426a82d3"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "b72d6b051842edda4b3ea64d2fe2b78b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 300840,
        "upload_time": "2021-12-08T11:13:11",
        "upload_time_iso_8601": "2021-12-08T11:13:11.344880Z",
        "url": "https://files.pythonhosted.org/packages/12/61/9d7b55f0af31e8682ce69073a4d6fd0f5628c39d9dcfefd4cc6dccfe371d/collective.exportimport-1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0722b7f6ec0bf27687de8a4864a70238575a4ebfb392bbb7a5e16459af08e43e",
          "md5": "914b7f7d9eaa36f6f72297867491f17c",
          "sha256": "39e0811801a93270db3b3da146581e05d312d09a4f3822613fa107df1589fa29"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.4-py2-none-any.whl",
        "has_sig": false,
        "md5_digest": "914b7f7d9eaa36f6f72297867491f17c",
        "packagetype": "bdist_wheel",
        "python_version": "py2",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 77983,
        "upload_time": "2022-01-07T11:09:35",
        "upload_time_iso_8601": "2022-01-07T11:09:35.465863Z",
        "url": "https://files.pythonhosted.org/packages/07/22/b7f6ec0bf27687de8a4864a70238575a4ebfb392bbb7a5e16459af08e43e/collective.exportimport-1.4-py2-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2d50867871f62f760af83818db82fabe7a3fac25d18eb85d9f026d76f3d11e9d",
          "md5": "92f39a199bfa917f26f1dc9a140c7a17",
          "sha256": "c40bcea6427eba5749912fe8a16d58bf34807a8ef67880d5176f788e8bf7ae5d"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "92f39a199bfa917f26f1dc9a140c7a17",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 308075,
        "upload_time": "2022-01-07T11:09:37",
        "upload_time_iso_8601": "2022-01-07T11:09:37.851921Z",
        "url": "https://files.pythonhosted.org/packages/2d/50/867871f62f760af83818db82fabe7a3fac25d18eb85d9f026d76f3d11e9d/collective.exportimport-1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "772f3c772f7eef7a9f41d316068335348a526ae46fe8a0936d62ddb43ebd8405",
          "md5": "25af72df5301d8ea6fa1dc7f1005c983",
          "sha256": "32417426d07ec1c4df022bea32cd76929b792d0573299d8b516fe538ae359693"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "25af72df5301d8ea6fa1dc7f1005c983",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 86369,
        "upload_time": "2022-04-26T15:33:29",
        "upload_time_iso_8601": "2022-04-26T15:33:29.388715Z",
        "url": "https://files.pythonhosted.org/packages/77/2f/3c772f7eef7a9f41d316068335348a526ae46fe8a0936d62ddb43ebd8405/collective.exportimport-1.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "24653e57fae47009f38d7689770521595278928840b98e36ed3aaf8de7868e26",
          "md5": "5d670e7c6e987c8e3690f3db7a9c1a12",
          "sha256": "735272b290c2d9997202e0e811eec29b89903e17fa7ca59ce6183ef4fb199c0e"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5d670e7c6e987c8e3690f3db7a9c1a12",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 311111,
        "upload_time": "2022-04-26T15:33:32",
        "upload_time_iso_8601": "2022-04-26T15:33:32.476708Z",
        "url": "https://files.pythonhosted.org/packages/24/65/3e57fae47009f38d7689770521595278928840b98e36ed3aaf8de7868e26/collective.exportimport-1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "07b44463e29bbc06d7ef008cefd747f134bdcf08830e734c876b2fe43caa4f98",
          "md5": "d800785e1785ba89bb53d26d0d24a439",
          "sha256": "ebd1fcc872ebb448e436c27d194db13fc57d919fa3d2e10d7a2c95e0674cc673"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d800785e1785ba89bb53d26d0d24a439",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 101586,
        "upload_time": "2022-10-07T13:33:03",
        "upload_time_iso_8601": "2022-10-07T13:33:03.044160Z",
        "url": "https://files.pythonhosted.org/packages/07/b4/4463e29bbc06d7ef008cefd747f134bdcf08830e734c876b2fe43caa4f98/collective.exportimport-1.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ca99c196eed2421e66b9e0d4d3c02462652674a83448600bf8bb6bad2e243368",
          "md5": "e4e540d4e4d07c86c49a306771a8a565",
          "sha256": "9451a367a90c2dc6ddc23c8ef26e33da02a9c15389c198139c352b6e0d052ebd"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "e4e540d4e4d07c86c49a306771a8a565",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 355559,
        "upload_time": "2022-10-07T13:33:09",
        "upload_time_iso_8601": "2022-10-07T13:33:09.305201Z",
        "url": "https://files.pythonhosted.org/packages/ca/99/c196eed2421e66b9e0d4d3c02462652674a83448600bf8bb6bad2e243368/collective.exportimport-1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e6b876dd610660707cd2740806aca26b4b102780f23698a56cbc6008e8c6838b",
          "md5": "2b97e4b9a488a54a8de7acd668002403",
          "sha256": "1a31415ad86c9b8d75d9ee7748d5546634c3064326c18049d1fe1ffc970d9972"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2b97e4b9a488a54a8de7acd668002403",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 113915,
        "upload_time": "2023-01-20T15:53:55",
        "upload_time_iso_8601": "2023-01-20T15:53:55.863919Z",
        "url": "https://files.pythonhosted.org/packages/e6/b8/76dd610660707cd2740806aca26b4b102780f23698a56cbc6008e8c6838b/collective.exportimport-1.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3c63dd441e9cbad7b8a217d29f9e94bd3d151aa4cae70641cebe5c502a161e99",
          "md5": "a0f1031b5df3acc4d2635c6ddabcbc82",
          "sha256": "f0da4da9dcebbad02eabff65d76f0d10873213efaf9f20b14524931fb7d81d64"
        },
        "downloads": -1,
        "filename": "collective.exportimport-1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "a0f1031b5df3acc4d2635c6ddabcbc82",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
        "size": 370285,
        "upload_time": "2023-01-20T15:54:02",
        "upload_time_iso_8601": "2023-01-20T15:54:02.146802Z",
        "url": "https://files.pythonhosted.org/packages/3c/63/dd441e9cbad7b8a217d29f9e94bd3d151aa4cae70641cebe5c502a161e99/collective.exportimport-1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e6b876dd610660707cd2740806aca26b4b102780f23698a56cbc6008e8c6838b",
        "md5": "2b97e4b9a488a54a8de7acd668002403",
        "sha256": "1a31415ad86c9b8d75d9ee7748d5546634c3064326c18049d1fe1ffc970d9972"
      },
      "downloads": -1,
      "filename": "collective.exportimport-1.7-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2b97e4b9a488a54a8de7acd668002403",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
      "size": 113915,
      "upload_time": "2023-01-20T15:53:55",
      "upload_time_iso_8601": "2023-01-20T15:53:55.863919Z",
      "url": "https://files.pythonhosted.org/packages/e6/b8/76dd610660707cd2740806aca26b4b102780f23698a56cbc6008e8c6838b/collective.exportimport-1.7-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3c63dd441e9cbad7b8a217d29f9e94bd3d151aa4cae70641cebe5c502a161e99",
        "md5": "a0f1031b5df3acc4d2635c6ddabcbc82",
        "sha256": "f0da4da9dcebbad02eabff65d76f0d10873213efaf9f20b14524931fb7d81d64"
      },
      "downloads": -1,
      "filename": "collective.exportimport-1.7.tar.gz",
      "has_sig": false,
      "md5_digest": "a0f1031b5df3acc4d2635c6ddabcbc82",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*",
      "size": 370285,
      "upload_time": "2023-01-20T15:54:02",
      "upload_time_iso_8601": "2023-01-20T15:54:02.146802Z",
      "url": "https://files.pythonhosted.org/packages/3c/63/dd441e9cbad7b8a217d29f9e94bd3d151aa4cae70641cebe5c502a161e99/collective.exportimport-1.7.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}