{
  "info": {
    "author": "Jakob Seidl",
    "author_email": "jakob.seidl91@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# pyneMeas documentation (v0.0.4)\n\nA package for simple electrical measurements using the National Instruments (NI) VISA standard.\nDeveloped by Jakob Seidl and coworkers at the Nanoelectronics group at the University of New South Wales, Sydney.\nIt was originally written in Python 2.7 and later adapted for modern Python 3.\n\nThe package is divided into two sub-units: Instruments and utility functions that help carry out a electronic measurement.\nIt allows you to connect to various electronic measurement equipment in few lines of code.\n\nCurrently implemented instruments include:\n\n1. Keithley 2400 series source measure units (SMUs)\n2. Keithley 2000 series digital multimeters\n3. Keithley 6517 'Electrometer'\n4. Stanford Instruments SRS830 Lock-in amplifier\n5. National Instruments USB6216 data acquisition card (NiDAQ)\n6. Yokogawa GS200 source measure unit\n\nIt is easy to write you own instrument classes by using existing intrument classes and replacing the \nrequired GPIB SCPI commands commonly supplied in the intrument's handbook.\n\nIn addition, this code was also used to control Oxford Instruments superconducting magnet power supplies and\nread out the status of Oxford instruments Heliox cryostats. This code is available from the author upon request.\n## A: Quickstart guide\n### A.1 Installing pyneMeas:\nCase A: from the online repository PyPi:\n\n`$ pip install pyneMeas` \n\nCase B: from a local pyneMeas folder on your PC:\n\n`$ pip install -e local/Path/pyneMeas/.`   the `-e` flag allows to make changes to the original files in the folder,\nuseful if you want to tweak the code while working. Enclose you path like this if it contains whitespace: \"local Path/with whitespace/SourceDirectory\".\\\nYou can download the sourcecode (.zip) from github under\nhttps://github.com/JakobSeidl/pyneMeas\n\nInstall the package in a virtual environment (see e.g. [this guide](https://realpython.com/python-virtual-environments-a-primer/)) or in your\nglobal Python 3 installation, whatever works best for your use-case.\n\nCheck if the installation was successful:\\\n`$ pip list` returns a list of packages that should contain\n```$ pip  20.3\npyneMeas           0.0.4    \n```\nif you installed it from the internet (Case A) or \n```$ pip  20.3\npyneMeas           /Path/To/Local/SourceDirectory    \n```\nif you installed pyneMeas from a local folder, e.g., after downloading the source code from gitHub (Case B).\\\nYou can then try loading the package as described in the following section.\n\n### A.2 Non-python drivers and hardware you'll need\n\nIMPORTANT: In order to use commercial GPIB-controlled instruments such as Keithely source-measure units,\nyou need to install the proprietary National Instruments VISA/USB-H bundle driver \n[here](https://www.ni.com/en-au/support/downloads/drivers/download.ni-488-2.html#306147). Possibly, this could be\nreplaced by a fully open-source\nlibrary such as [pyvisa-py](https://pyvisa-py.readthedocs.io/en/latest/) that supplies the back-end.\nFor using the National Instruments Data Acquisition cards (NIDaQ), you need the corresponding [NIDaQ driver](https://www.ni.com/en-au/support/downloads/drivers/download.ni-daqmx.html#288239). \n\n For both we recommend not chossing the latest version but simpler, earlier versions.\n\n\n### A.3 Loading and testing pyneMeas:\nIn your python console type:\n```python:\n>>> import pyneMeas.Instruments as I\n>>> import pyneMeas.utility as U\n```\nIf this works, you can run a test measurement using 'virtual' instruments to check weather \nplotting and data storage works fine:\n```\n>>> U.runTest()\n```\nshould open a plot window with simulated linear and sinusoidal noise signals measured over time. \nA progress bar should indicated the status of the measurement.\nIn the console, you should see a notification that a folder has been created where the data will be stored.\n```\nOut: Created data storage directory: TempDat/\n/>>>>>> Finished measurement A1 | Duration: 9.4 seconds = 0.2 min  <<<<<<<\n```\n\nSetting up any basic measurement requires three steps: \n1. Setting up all required instruments and configuring them (see A.4)\n2. Defining the sweep-array and designating which instrument should sweep a variable and which instrument(s)\n should just read/measure (see A.5).\n3. Call the sweep function 'sweep()' from pyneMeas.utility using the Instrument parameters defined in 2, see A.5.\n\n### A.4 Initializing instruments:\nWe reccommend using an IDE such as PyCharm that supports code completion. E.g., type 'I.' \n(or any other alias you imported pyneMeas.Instruments as) and all implemented Instruments will appear in a drop-down list. Use TAB-completion when typing in the console. Let's use a Keithley 2401 source-measure unit:\n```\n>>> myKeithley = I.Keithley2401(10)  #  Initializes a Keithely2401 instrument at GPIB port 10\nKEITHLEY INSTRUMENTS INC., MODEL nnnn, xxxxxxx, yyyyy/zzzzz /a/d  #  Parameters on the right depend on exact model/firmware\n```\nThe `'KEITHLEY INSTRUMENTS INC.'` message is the instrument's response to the typical '*IDN?' query and indicates that the instrument has been successfully initiated.\nMost instruments have internal options that can be set before the measurement. E.g., the Keithley source-measure\nunit can be set to source voltage (and measure its output current) or to source a current instead. Every instrument has a set() and  setOptions() method:\nE.g. \n```\n>>> myKeithley.set('name','myKeithleyInstrumentName) # Every instrument can have a unique 'name'\n>>> myKeithley.setOptions({'sourceMode':'voltage, # sourcing voltage\n                      'sourceRange':20})      # Using high source range of up to 20 Volts\n```\nFor a list of all instrument options and possible values, see [XX].\n### A.5 Using the sweep() function \n\n\nIn this example we define a simple current vs. voltage sweep with a single Keithley instrument. \nWe define a empty dictionary that holds all relevant data. After defining `'basePath'` and `'fileName'`\nunder which the data will be stored, we define the `'setter'` and `'getters'` fields. They determine,\nwhich instrument actively set (outputs) a value, e.g. a gate voltage, and which instruments measure the\nresulting variables, e.g., input voltages, currents. Here we use the same Keithley instrument to do both.\nThe values we want to sweep over, in this case source-drain voltages, are defined in the `'sweepArray` field.\nHere we use the `targetArray()` function, but standard lists or numpy.arrays can be used as well. \nIn the last step, we call the `sweep()` function with the required `Dct` parameter and two optional parameters, `delay` and `plotVars`. \nNote that the name `Dct` of the dictionary may be changed but the keywords such as `'setter'` and `'sweepArray'` need to be exactly used as displayed here.\n```\nmyScript.py\n-----------\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" # Relative to your current working directory\nDct['fileName'] = 'SampleA' # Sets the file name under which data will be saved and logged.\n\nDct['setters'] = {myKeithley:    'V_SD'} # Set the variable called 'V_SD' with our 'myKeithley' object\nDct['readers'] = {myKeithley:    'I_SD'} # Measure the variable called 'I_SD' with our 'myKeithley' object\n\nDct['sweepArray'] = U.targetArray([0,1,0],stepsize=0.1) # Define values from 0V -> 1V -> 0V in 0.1V steps\n                                                        # targetArray is a utility function provided\n\ndf = U.sweep(Dct,                          # call sweep function and provide the Dct dictionary defined\n             delay=0.2,                    # seconds wait time in between points\n             plotVars = [('V_SD','I_SD')]) # plot 'I_SD' (y-axis) over 'V_SD (x-axis)'      \n\n```\nThis should open a live-plot that shows `'I_SD'` vs. `'V_SD'`. The data is saved under \"Data/\"\n (folder is created if it doesn't exist, see console output). Per measurement, four files are saved:\n  The data is saved in .tsv format (blank text), in .mat matlab data format. In addition, a log.tsv file is created that logs \n  important information of the measurement run, such as instruments used etc. When plotting is enabled, the plot is also saved as .png.\n  Note that each measurement has unique measurement ID consisting of a letter prefix and a running number. \n  This is e.g., displayed in the plot title and each saved data file is preceded by it. This also prevents data \n  from being overwritten even when the user uses the same `fileName` repeatedly. The `sweep()` function \n  returns a `pandas.DataFrame`, here assigned to `df`, that holds the acquired data with column labels corresponding to the variable names provided.\n  This can be useful if the user wants to use the acquired data immediately during the measurement routine.\n```\n>>> df\nOut:\n      V_SD      I_SD     \n0        .         .    \n1        .         .  \n2        .         .   \n..     ...       ... \n\n>>> df.plot(x = 'V_SD', y ='I_SD') # A simple way of plotting the data                                                        \n```\n### A.5 finding help\n1 Remember that in Python, you can call the help() function on any method or object. E.g., if you want\nto find out about the `sweep()` function, try calling\n```\n>>> help(U.sweep) # No brackets here as we don't want to call the function\n```\nNote: Doc-strings are currently being implemented, so help() might not yet work for all methods/classes.\n\n2 If you can't remember, which attributes you can set with the myInstrument.set(), just call \nthose methods with a clearly wrong argument:\n```\n>>> noiseGenerator = I.LinearNoiseGenerator()\n\n>>> noiseGenerator.set('wrong',1)\nValueError: \n\"wrong is not a valid option. dict_keys(['sourceLevel', 'name'])\n are available\"\n```\n,which means only the keys `'sourceLevel` and `'name` can be set for this instrument.\n\n3 If you remember the key attribute but not the possible numerical ranges, you can call set() \nwith a clearly wrong numerical argument\n```\n>>> keithley = I.Keithley2401(10)\n\n>>> keithley.set('sourceRange',3000)\nValueError: \n\"3000 is not a valid voltage source range for the Keithley2401.\nValid voltage ranges are: 20, 10, 1, 0.1, 0.01 and 0.001 Volts and\nequivalent exponential representations.\"\n```\n\n## B   Example scripts/ Tutorials\n### B.1 Two variables: A gate-sweep measurement\n```\ngateSweepScript.py\n------------------\n\nVgate_Keithley = I.Keithley2401(10)\nVBias_Keithley = I.Keithley2401(11)\n\n[Set options either manually or with .setOptions({'key':argument}) method]\n\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" \n\n\nDct['setters'] = {Vgate_Keithley:    'V_G'} \n\nDct['readers'] = {  VBias_Keithley:    'I_SD',\n                    Vgate_Keithley:    'I_LeakGate'} \n\n\ngateLow = -1; gateHigh = 1.5\nDct['sweepArray'] = U.targetArray([0, gateLow, gateHigh, 0], stepsize = 0.05) \n\nsourceDrainBiases = [0.05, 0.1, 0.5] #  volt\n\nfor bias in sourceDrainBiases:\n\n    Dct['fileName'] = f'SampleA_{bias}_volt' # data for each bias will have the bias in the filename for convenience, e.g. SampleA_0.5_volt'\n\n    VBias_Keithley.goTo(bias,0.01,0.2) # Go to the desired bias, then execute gate sweep.  \n    U.sweep(Dct, delay=0.2, plotVars = [('V_G','I_SD'), ('V_G','I_LeakGate')])\n\n\n```\n### B.2 Measure instruments over time\n```\ntimeMeasScript.py\n-----------------\n\nmyKeith = I.Keithley2401(11)\nmyTimeInst = I.TimeMeas()  # virtual instrument\n\n[Set myKeith options if desired ...]\n\nDct['basePath'] = \"Data/\" \nDct['fileName'] = 'SampleB_currOverTime'\n\nDct['setters'] = {myTimeInst:    'dummyPoints'} \n\nDct['readers'] = {  myKeith:    'I_d',\n                    myTimeInst:    'time'}    \n\nDct['sweepArray'] = range(100) # measure over 100 datapoints\n\ndf = U.sweep(Dct, delay=0.2, # The delay here determines roughly how often we measure per unit time.\n        plotVars = [('time','I_d')],\n        breakCondition = ('time','>',50)) # optionally we can terminate the measurement after a certain time period if desired.\n\n\n```\n### B.3 Simple I-V measurements with the NIDaq\n```\nsimpleNiDaQ.py\n--------------\n\nDaqIn = USB6216In(2,usbPort = 'Dev1') # Using Analog Input AI2. usbPort depends on the usb port windows assigns to the nidaq\nDaqOut = USB6216Out(1,usbPort = 'Dev1') # Using Analog Output AO1\n\nDaqOut.setOptions({\n    \"feedBack\":\"Int\",\n    \"extPort\":6, # Can be any number 0-7 if in 'Int'\n    \"scaleFactor\":1\n})\n\nDaqIn.set(\"scaleFactor\",1) # If we don't use an amplifier, gain =1)\n\nmyTime = TimeMeas()\n\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" \nDct['fileName'] = 'SampleC_IV'\n\n\nDct['setters'] = {DaqOut:    'V_SD'} \n\nDct['readers'] = {  DaqIn:    'I_SD',\n                    myTime:    'time'} \n\ntargetLow = 0; targetHigh = 1.5\nDct['sweepArray'] = U.targetArray([targetLow, targetHigh, targetLow], stepsize = 0.01) \n\ndf = U.sweep(Dct, # No plotting and 'delay' here to speed up the nidaq aquisition.\nsaveCounter = 100) # Only save data every 100th read to increase speed.\n\n```\n### B.4 Example using lock-in amplifiers\n```\nlockIn_HallScript.py\n--------------------\nlockIn_ISD = I.SRS830(8)\nlockIn_VSD = I.SRS830(10)\nlockIn_VHall = I.SRS830(11)  \nkeith_Vg = I.Keithley2401(13)\n\n\n# You could set all these manually on the instrument,\n# except 'scaleFactor' and 'autoSensitivity'\n\nlockIn_ISD.setOptions({\n      'frequency':77, \n      'amplitude':0.004,\n      'input':'I1',\n      'scaleFactor':1,\n      'phase':180,\n      'autoSensitivity':False })\n\n\n[.. set other options as desired...]\n\n\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" \nDct['fileName'] = 'SampleC_IV'\n\nmyComments = \"\"\"\n        Hall bar measurement at B = +2 T @ 4K\n        We measure the current through device with lockIn_ISD\n        and the voltage across the device with lockIn_VSD. The third lock in,\n        lockIn_VHall, measures the Hall voltage. We sweep the gate-voltage with \n        a Keithley2400 (keith_Vg). \"\"\"\n\nDct['setters'] = {keith_Vg:    'V_g'} \n\nDct['readers'] = {  lockIn_ISD:    ['Isd_X','Isd_Y'],  # The lock-in puts out TWO read-values\n                    lockIn_VSD:    ['Vsd_X','Vsd_Y'],  # We put them together in brackets \n                    lockIn_VH:    ['VHall_X','VHall_Y'],\n                    keith_Vg:    'I_gateLeak'          # Instruments that only yield single values\n            }                                          # don't need brackets.\n\n\ntargetLow = 0; targetHigh = 1.5\nDct['sweepArray'] = U.targetArray([targetLow, targetHigh, targetLow], stepsize = 0.01) \n\nlockIn_ISD.goTo(2,0.2,0.2) # got to a excitation amplitude of 2 V (usually into a voltage divider)                                                             \n\ndata = U.sweep(Dct,\n               plotVars = [('V_g','I_sd_X),\n                            ('V_g','V_Hall_X),\n                            ('V_g','VHall_Y)]),\n               plotParams = [('b-','linear-log'), # Sets the plot appearance and lin-log x-y scale\n                              ('go','linear-linear')  #linear-linear scale (default)\n                              ('ro--','linear-linear')],\n               comments = myComments\n               )\n```     \n### B.5 Abruptly changing signals - sourcing step functions with SMU's\n```\nsquare_transients.py\n--------------------\nVgate_Keithley = I.Keithley2401(10)\nVBias_Keithley = I.Keithley2401(11)\nmyTime = TimeMeas()\n\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" \nDct['fileName'] = 'SampleD_GateTransient'\n\nVgHigh = 0.5  # volt\nVgLow = -0.1 \n# Creates a Low-HIgh-Low-High square wave gate potential:  \nDct['sweepArray'] = [VgLow]*50 + [VgHigh]*150 + [VgLow]*50 + [VgHigh]*150\n\n\nDct['setters'] = {Vgate_Keithley:      'V_G'} \n\nDct['readers'] = {  VBias_Keithley:    'I_SD',\n                    Vgate_Keithley:    'I_LeakGate'\n                    myTime:            'time'} \n\ndf = U.sweep(Dct,\n        plotVars = [('time','I_SD'),\n                    ('time','V_G')]\n            )                                                      \n```\n### B.6 Reading current instrument setter status to dynamically define next sweeps\n```\nbreakGateSweep.py\n------------------\nimport pandas as pd # Required later for dataframe operations\n\nVgate_Keithley = I.Keithley2401(10)\nVBias_Keithley = I.Keithley2401(11)\n\n[Set options either manually or with .setOptions({'key':argument}) method]\n\nDct = {} # Define empty dictionary as container\nDct['basePath'] = \"Data/\" \n\nDct['setters'] = {Vgate_Keithley:    'V_G'} \n\nDct['readers'] = {  VBias_Keithley:    'I_SD',\n                    Vgate_Keithley:    'I_LeakGate'} \n\ngateLow = -1; gateHigh = 1.5\nDct['sweepArray'] = U.targetArray([0, gateLow, gateHigh, 0], stepsize = 0.05) \n\nsourceDrainBiase = 0.1 #  volt\n\nDct['fileName'] = 'gateSweep_01V'\n\nVBias_Keithley.goTo(bias,0.01,0.2) # Go to the desired bias, then execute gate sweep.  \n\n# This gatesweep breaks if the gate leakge current ever surpasses 10 nA.\ndf = U.sweep(Dct, delay=0.2,\n        plotVars = [('V_G','I_SD'), ('V_G','I_LeakGate')],\n        breakCondition=('I_LeakGate','>',10E-9))\n\n\n#Check if the measurement was broken by the breakCondition:\n# If measurement was stopped, measure from the current gate voltage back to 0.\n\nif len(df) < len(Dct['sweepArray']):\n    currentVg = Vgate_Keithley.get('sourceLevel') # At what VG did the gate leakage exceed out limit?\n    Dct['sweepArray'] = U.targetArray([currentVg,0], stepsize = 0.05) # overwrite previous array\n\n    # Finally carry out measurement\n    dfBack = U.sweep(Dct, delay=0.2,\n                     plotVars = [('V_G','I_SD'), ('V_G','I_LeakGate')]) \n\n# It can be useful to concatenate the data from both measurements into one dataframe .\nThis can be more convenient than the separate saved data files, which were created for each measurement.\n\n\ndataFull = pd.concat([df,dfBack],ignore_index=True)\ndataFull.plot(x='V_G',y='I_SD')\n\n```\n\n\n---\n## C   Documentation of instrument parameters\nUpon creation, these Instruments need to be prefixed by the pyneMeas.Instrument alias (`I.` in the example scripts.)\n##### Most if the following properties can be set, as well as queried with the get/set methods.\n#### C.1 Keithley 2400 series\nSource/measure unit supplying either voltage or current.\n\n`'outputEnable'`: Boolean, Turns instrument output on (True or 1) or off (False or 0). \n`outputEnable = True` is required for instrument operation.\nExample: `>>> myKeithley.set('outputEnable',False)` \n\n`'sourceMode'`, String, can be `'voltage'` or `'current'` for sourcing a voltage or current respectively.\nThe instrument will also measure the flowing current (when sourcing `'voltage'`) or the resulting voltage (when sourcing a `'current'`).\nWhen a Keithley2400 instrument is created, it will internally check the current source mode of the instrument, so `'sourceMode'` can be set in hardware or software.\n\n`'sourceRange': ` Float, sets overall source range of instrument. Highest value you want to put out need to be below this limit.\nWhen sourcing `'voltage'`, possible limits are: ` (20,10,1,0.1,0.01,0.001)` (in volts). When sourcing \n`'current'`, possible limits are: `(1,0.1,0.01,0.001,1E-4,1E-5,1E-6)`(in amperes). \n\n`'name''` String, Optional unique name of the instrument to distinguish between various instruments of the same type.\n\n`'sourceLevel'`, Float, set or get method. Directly sets the output (voltage or current) to the set value. We do not recommend using this directly, especially not for sensitive nanoscale samples.\nUse `myInstrument.goTo(target,stepSize,delay)` instead to slowly approach the desired setpoint.\n\n`'senseLevel'` Returns float, get method only. Returns the current voltage/current reading.\n\n`'senseRange'`, when sourcing `'voltage': (1.05E-4,1.05E-5,1.05E-6)` amperes.\n OR when sourcing `'current': (21.0,2.1,0.21)` volts\n\n`compliance`, Float, Hard limit of highest current the instrument supplies when sourcing `'voltage'`\nor highest voltage when sourcing `'current'`. Must lie below the highest value the instrument can measure, see `'senseRange'`.\n\n`'scaleFactor'` Float, scales the measured values form the instrument. Defaults to 1 and does not usually have to be set. \n\n---\n#### C.2 Keithley 2000 series\nVersatile amp/voltmeter.\n\n`'senseMode'`, String, determines whether the instrument reads current or voltage as input. Can be `'voltage'` or `'current'`.\n\n`'senseRange'` Float, sets the input range. Allowed voltage ranges are: `(100E-3,1,10,100,1000) #  volts.`\nAllowed current ranges are: `(10E-3,100E-3,1,3) #  amps.`\n\n`'senseLevel'`, Returns float, get method only. Returns reading of input voltage/current.\n\n`'scaleFactor'` Float, scales the measured values form the instrument. Useful when current or voltage preamps are used and the output is read by the Keithley 2000. \n\n---\n\n#### C.3 Keithley 6517A Electrometer\nVery sensitive amp/voltmeter.\n\n`'zeroCheck'` Boolean, `True` enables zerocheck mode, which protects the instrument when not in use.\n Needs to be disabled (`False`) before a measurement.\n\n`senseMode'`, String, determines whether the instrument reads current or voltage as input. Can be `'voltage'` or `'current'`.\n\n`'senseLevel'`, Returns float, get method only. Returns reading of input voltage/current.\n\n`'senseRange'` Float, when measuring current: `[20E-12,200E-12,2E-9,20E-9,200E-9,2E-6,20E-6,200E-6,2E-3,20E-3] # amperes.`\nWhen measuring voltage: `[2,20,200] #  volts.`\n\n\n`'autoRange'`, Boolean. When `True`, the instrument will try to adjust its `'senseLevel'` according to its input readings.\n\n`'NPLC'`, Float between 0.1 & 10. Sets the integration time during a measurement in 'power line cycles'. Default is 1. \nReduce this if your overall sweep velocity is too fast for the instrument to catch up, increase `'NPLC'` if you need slow, high precision readings of low currents. \n\n---\n\n\n#### C.4 SRS830 lock-in amplifier\n\nFor a detailed look at the lock-in specific parameters, please refer to the excellent [manual of the SRS830](https://www.thinksrs.com/downloads/pdfs/manuals/SR830m.pdf).\n\n`'frequency':` Float between 0.1 Hz & 100 kHz. Sets the operation frequency.\n\n`'amplitude':` Float between 0.004 V & 5 V. Sets the root-mean-square amplitude of the sinusoidal\noutput voltage of the amplifier.\n\n`'input'` String, can be `\"A\",\"A-B\",\"I1\" or \"I2\"` corresponding to a simple voltage measurement `\"A\"`, \na differential voltage measurement `\"A-B\"` or a current measurement with two different gains `\"I1\"/\"I2\"\"` \n\n`'timeConst' :` Float or int. Sets the time constant of the lock-in amplifier. Allowed inputs are: `[10E-6,30E-6,100E-6,300E-6,1E-3,3E-3,10E-3,30E-3,100E-3,300E-3,1,3,10,30,100,300] #  seconds`\n\n`'phase'` Float, sets the phase-parameter of the lock-in amplifier in degrees. Can range from 0 to 360 degrees. \n\n`'sweepParameter'` String, can be `\"frequency\" or \"amplitude\"`. When the lock-in is used as a setter in the sweep() function, \nyou can choose whether you want to sweep the RMS amplitude (default) or output frequency. Sweeping the frequency can e.g. be used to\ndetermine which drive frequency generates low noise background\n\n`'sourceLevel'`, Float, set method only. Directly sets the output amplitude (or frequency) to the set value. We do not recommend using this directly.\nUse `myInstrument.goTo(target,stepSize,delay)` instead to slowly approach the desired setpoint.\n\n`'senseLevel'` Tuple of floats `(Xreading, Yreading)`, get method only. Returns the X- and Y-component of the voltage/current reading.\n\n`'senseRange'` Float, `[1E-9,2E-9,5E-9,10E-9,20E-9,50E-9,100E-9,200E-9,500E-9,1E-6,2E-6,5E-6,10E-6,20E-6,50E-6,100E-6,200E-6,500E-6,1E-3,2E-3,5E-3,10E-3,20E-3,50E-3,100E-3,200E-3,500E-3,1] # volts`\nThese voltage ranges directly correspond to current ranges, as written on the amplifier front panel.\n\n`'autoSensitivity'` Boolean. When `True`, the instrument will try to adjust its `'senseLevel'` according to its input readings. Note\nthat this is not fully mature at the moment and should be properly tested prior to use in a real experiment. Defaults to `False.` \n\n`'name'` String, Optional unique name of the instrument to distinguish between various instruments of the same type.\n\n#### C.5 YokogawaGS200\nVoltage/current source unit.\n\n`outputEnable`, Boolean, `True` is required for instrument operation.\n\n`'sourceMode'`, String, can be `'voltage'` or `'current'` for sourcing a voltage or current, respectively.\n\n`'sourceRange': ` Float, sets overall source range of instrument. Highest value you want to put out needs to be below this limit.\nWhen sourcing `'voltage'`, possible limits are: ` (30,10,1,0.1,0.01)` (in volts). When sourcing \n`'current'`, possible limits are: `(0.2,0.1,0.01,0.001)`(in amperes). \n\n`'sourceLevel'`, Float, set or get method. Directly sets the output amplitude to the set value. We do not recommend using this directly.\nUse `myInstrument.goTo(target,stepSize,delay)` instead to slowly approach the desired setpoint.\n\n`'name'` String, optional. Unique name of the instrument to distinguish between various instruments of the same type.\n\n`compliance`, Float, Hard limit of highest current the instrument supplies when sourcing `'voltage'`\nor highest voltage when sourcing `'current'`. \n\n#### C.6 National Instruments NiDaQ (USB6216) \nData acquisition device that can carry out fast (up to 200kHz) transient measurements. \nConsists of a arbitrary function generator part (Out) and various Analog-to-digital converter inputs (IN).\nThese are realized by the `USB6216Out()` and `USB6216In()` classes, respectively.\n\n1. `USB6216Out(outputPort,usbPort)`\n\n`outputPort` int, required upon initialization. Can be 0: (port AO0) or 1: (port AO1)  \n\n`usbPort` int, required upon initialization. Internal device port of the NiDaQ. Is usually 1 (Dev1) or 2 (Dev).\n                Will throw an error when outputting a voltage. Device number can be found e.g. using NI MAX.  \n\n`feedback` int, optional. Default: `'Int'` (internal). External feedback (`'Ext'`) not tested yet.\n\n`extPort` int, optional. If `feedback` is set to `'Int'`, it can be any number from 0-7, without any effect. \nTesting required when `feedback` is set to `'Ext'`.\n\n2. `USB6216In(inputPort,usbPort)`\n\n`inputPort` int, required upon initialization. Can range from 0: (port AI0) to 7: (port AI7)  \n\n`usbPort` int, required upon initialization. Internal device port of the NiDaQ. Is usually 1 (Dev1) or 2 (Dev).\n                Will throw an error when outputting a voltage. Device number can be found e.g. using NI MAX.  \n\n`scaleFactor` float, optional. Scales the measured voltages by this factor. Used when the measured \nvoltages are amplified by an amplifier of known gain. \n\n\n## D   Documentation of utility functions\nTo access these functions, use the pyneMeas.utility alias (`U.` in the example scripts.)\n#### D.1 The `sweep()` function\nCommon usage: See example script above.\n\n\nParameters:\n\n`delay` Float, wait time in seconds after a value has been set and before instruments are read out. Default=0.0\n\n`comments` String, Comments on experiment, sample etc. Is stored in the .log file together with\n the saved data. Useful for data not measured by instruments. Example: `\"SampleA, I-V, T= 77K\"`\n\n`plotVars` list of `('xVar','yVar')` tuples to be plotted. Example: `[ ('V_SD', 'I_SD') ]` from above.\n\n`plotParams` list of `('plotString','XAxisScale-YAxisScale')` tuples. `'plotString'` contains color, line and marker info. \nSee the [Matplotlib documentation](https://matplotlib.org/3.3.3/api/_as_gen/matplotlib.pyplot.plot.html) under Notes. \n'XAxisScale-YAxisScale' can be e.g. `'linear-linear'` or `'linear-log'` or any combination.\n Example: `[ ('go-', 'linear-linear') ]`\n\n`plotAlpha` Float, Transparency of markers: 1= no transparency, 0 = fully transparent. Default = 0.8\n\n`plotCounter` Integer, After how many datapoints do you want to update the plot.  plotCounter > 1 helps speed up plotting. Default = 1\n\n`plotSize` Tuple of two floats `(xSize,ySize)`, size of plot window in cm. Default = (10,10)\n\n`saveCounter` Integer, After how many datapoints do you want to save data to disc. \nCan help speed up the measurement slightly. Default = 10\n\n`breakCondition` Tuple, `('Variable','comparisonOperator',Value)`. Allows to stop a measurement when a certain condition is met.\n `'Variable'` is compared against `Value` using `'comparisonOperator'`. \n`'comparisonOperator'` can be `'<'` or `'>'` at the moment. Example: `breakCondition = ('I_SD','>',1E-6)` will end the\n measurement when `'I_SD'` reaches a value above 1 microampere.\n\n`extraInstruments` List of instrument objects, used to keep track of instruments that are not directly used as setter or reader but you still want to see logged in the .log file.\n\n`saveEnable` Boolean, Defines whether saving the data is desired. Default = True. In the current version, `saveEnable = False` also disables plotting.\n\n#### D.2 The `targetArray([targetList],stepSize)` function\nConvenient way of creating a linearly-spaced array of floats of type np.arange(). Easier than concatenating np.arange() or np.linspace().\n\nE.g. `targetArray([0.0,1.0,-1.3,0.0],0.2)` creates an array from 0.0 -> 1.0 -> -1.3 -> 0.0 in 0.2 steps.\n\n`targetList` list of floats. E.g. `[0.0,1.0,-1.3,0.0]`\n\n`stepSize` float. E.g. 0.2. IMPORTANT: If the targets can't be reached with the specified stepsize, e.g., a\ntarget of 0.3 with a stepsize of 0.2, the last datapoint will overshoot the setpoint.\n `>>> targetArray([0,0.3],0.2)` returns `array([0.,0.2,0.4])` NOT containing 0.3! If possible, choose stepsizes\n that match the desired setpoints to avoid this.\n#### D.3 Managing the unique measurement identifiers\nEvery measurement performed with the sweep() identifier displayed as\nthe plot title that is also part of all saved file names. It consist of a unique prefix + running ID number (int). \nThis assures that no measurement will eve rbe overwritten and that you have a unique reference to each measurement, useful for\nlogging data in a database.\n\nHow do I access and manipulate this identifier?\n\nYou can list all currently defined identifiers using (assuming you imported pyneMeas.utility as U)\n```\n>>> U.listIDs()\nCurrently used Prefix/Setup: A  --> ID = 1\n-------------------------------------------- \nOther available Setups/Prefixes are: #none at the moment\n```\nCurrently only one prefix ('A') is defined. It's running ID is 1, which would increment when running a measurement.\n\n'A' is the standard prefix out of the box. You can create more meaningful prefixes like so:\n```\n>>> U.addPrefix('test')\n```\nChecking the identifier with `listIDs()` now shows the new prefix with a ID of 0. However 'A' is still the active prefix.\nThis means, when carrying out a measurement, only the ID of 'A' is increased. This can be useful, if more than\none scientist works on the same setup but wants to get their data indexed separately, e.g., prefixed by initials.\n```\n>>> U.listIDs()\nCurrently used Prefix/Setup: A  --> ID = 1\n-------------------------------------------- \nOther available Setups/Prefixes are: \nPrefix/Setup: test  --> ID = 0\n```\nWe can make 'test' the active setup by typing:\n```\n>>> setCurrentSetup('test')\nSuccesfully changed preFix/Setup from: A ---> test\n\n>>> U.listIDs()\nCurrently used Prefix/Setup: test  --> ID = 0\n--------------------------------------------- \nOther available Setups/Prefixes are: \nPrefix/Setup: A  --> ID = 1\n```\n\nWe can directly access the current prefix (string) and ID by with:\n```\n>>> U.readCurrentSetup()\n'test'\n>>> U.readCurrentID()\n0\n```\nThis is useful if you want to log the measurement ID together with the dataframe\noutput of the sweep function, i.e., if you're not using the data files saved by sweep().\n\nLastly, you can clear all current identifiers and start with the default values\n```\nU.initID()\n``` \nhowever, be aware that this removes all user information and should only be used as a last resort.\n### Beyond the sweep() function: Using instruments in a custom for-loop\nThe sweep() function is a convenient way of carrying out many standard electronic measurements, while facilitating live plotting.\nHowever, in its current form, it cannot cater for more complex measurements, such as multi-parameter sweeps. By accessing instruments directly, you can\ncreate custom procedures that are more versatile. The fundamental methods to set an instrument's output (e.g. output voltage) \nor access its current reading (e.g. input current) are `myInstr.set('sourceLevel',outputLevel)` and `myInstrument.read()` methods, respectively.\n\nIn the following example, we will replicate a simple (virtual) noise over time measurement, but this should work accordingly \nfor any instrument.\n\n``` \nimport time\nimport pyneMeas.Instruments as I\nimport pyneMeas.utility as U\nimport matplotlib.pyplot as plt\n\nT = I.TimeMeas()\nNoi = I.LinearNoiseGenerator()\n\npoints = range(50)\n\ndata= {}\ndata['noise'] = []\ndata['time'] = []\n\ndelay = 0.2 # in seconds\n\nfor point in points:\n\n    Noi.set('sourceLevel', point) # This does not do anything with this virtual instrument.\n    # Using this on a real instrument would output e.g. a voltage.\n\n    time.sleep(delay) # wait between measurements\n\n    data['time'].append(T.read()) # Read the current time and write to list\n    data['noise'].append(Noi.read()) # Reads current (virtual) noise level and write to list\n\nplt.plot(data['time'],data['noise'],'-o')\nplt.xlabel('time');\nplt.ylabel('Noise')\nplt.show()\n\n``` \nIn principle, this for-loop can be a lot more complex and behave differently, \ndepending on readings from various instruments or user input.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/JakobSeidl/pyneMeas",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pyneMeas",
    "package_url": "https://pypi.org/project/pyneMeas/",
    "platform": "",
    "project_url": "https://pypi.org/project/pyneMeas/",
    "project_urls": {
      "Homepage": "https://github.com/JakobSeidl/pyneMeas"
    },
    "release_url": "https://pypi.org/project/pyneMeas/0.0.4/",
    "requires_dist": [
      "numpy",
      "matplotlib",
      "nidaqmx",
      "pandas",
      "scipy",
      "pyvisa"
    ],
    "requires_python": ">=3.6",
    "summary": "A simple Python 3 interface for controlling electronic measurement instruments and scripting measurement sweeps.",
    "version": "0.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10209683,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c94bdc6f08c59297b67e63f5ae61a2db35b52bd255b5bae8e38b9e281ddb83a0",
          "md5": "abfaf1eb606c5b8471ed862a9003dc03",
          "sha256": "a3dbd1ab9a6b88dddc2a73be0e60d0314b9dae63511e4d77221a4dab52040ef9"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "abfaf1eb606c5b8471ed862a9003dc03",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 18211,
        "upload_time": "2020-12-03T04:08:30",
        "upload_time_iso_8601": "2020-12-03T04:08:30.931434Z",
        "url": "https://files.pythonhosted.org/packages/c9/4b/dc6f08c59297b67e63f5ae61a2db35b52bd255b5bae8e38b9e281ddb83a0/pyneMeas-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "55c3c2262744f18945e14da65451750e9f95bd2e45e5cd403cd8365c8c2b484b",
          "md5": "51a4eda6b32faf1069d63c87f52dfa52",
          "sha256": "5279f0b5f6a287fb18e3ded3849faa24cc54a7a1645591557f0ccd695da1335d"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "51a4eda6b32faf1069d63c87f52dfa52",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 14600,
        "upload_time": "2020-12-03T04:08:32",
        "upload_time_iso_8601": "2020-12-03T04:08:32.669659Z",
        "url": "https://files.pythonhosted.org/packages/55/c3/c2262744f18945e14da65451750e9f95bd2e45e5cd403cd8365c8c2b484b/pyneMeas-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "edf30686d0eaf114ef83ea1e06bd6571e569d8e89b03c733d8cfaa567e00de02",
          "md5": "a75f49cf124e1d48bd8c1e406bee928c",
          "sha256": "f08fd17e8763052c2caf89e90489f4ad2650922eb056220fcad940bf30c6b69f"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a75f49cf124e1d48bd8c1e406bee928c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 41868,
        "upload_time": "2021-01-31T06:53:25",
        "upload_time_iso_8601": "2021-01-31T06:53:25.488396Z",
        "url": "https://files.pythonhosted.org/packages/ed/f3/0686d0eaf114ef83ea1e06bd6571e569d8e89b03c733d8cfaa567e00de02/pyneMeas-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b8d686c11efeece7505cc6af8f0488e50b6d7a47a1d2a3ade57f8cf72c7167db",
          "md5": "3126231e4352a7293094e4313d371411",
          "sha256": "e19f257f95bae73758a9869035cb780478790344829beaf70cf1a4b39f6935b8"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "3126231e4352a7293094e4313d371411",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 41993,
        "upload_time": "2021-01-31T06:53:27",
        "upload_time_iso_8601": "2021-01-31T06:53:27.298359Z",
        "url": "https://files.pythonhosted.org/packages/b8/d6/86c11efeece7505cc6af8f0488e50b6d7a47a1d2a3ade57f8cf72c7167db/pyneMeas-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b8292025bbabf0691dd1f7744ec9eb490a4d48ade9f3e9ba57915f5f41227b5a",
          "md5": "af81b76eb3a2d8bca2a30e0992d4d113",
          "sha256": "4c9a90dfa1e21dde837ead8fe1c7b3597b1f03f13679f2e0b4ccfc6ee256205d"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "af81b76eb3a2d8bca2a30e0992d4d113",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 41932,
        "upload_time": "2021-03-07T23:03:21",
        "upload_time_iso_8601": "2021-03-07T23:03:21.468920Z",
        "url": "https://files.pythonhosted.org/packages/b8/29/2025bbabf0691dd1f7744ec9eb490a4d48ade9f3e9ba57915f5f41227b5a/pyneMeas-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "41e5fa1af02daef42f16ef3804330e1d11ebe2c45c4bdd75960c2fb4803d4239",
          "md5": "262f8a3663ddbfadcd0fec6aebe01fe6",
          "sha256": "80e97a73fe047bdf8c3f9742ccdd7599b39eb74d4c401b6619302d7ca7f3ffa0"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "262f8a3663ddbfadcd0fec6aebe01fe6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 42205,
        "upload_time": "2021-03-07T23:03:23",
        "upload_time_iso_8601": "2021-03-07T23:03:23.037665Z",
        "url": "https://files.pythonhosted.org/packages/41/e5/fa1af02daef42f16ef3804330e1d11ebe2c45c4bdd75960c2fb4803d4239/pyneMeas-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b5ceee3f3b9d93a2a734d4145536b4f16a5dbc0ac5dbd844ff2d178017b86162",
          "md5": "41c11e3295fbc104f63746c72586fa0f",
          "sha256": "97decf268654e1ff9592af2967f402d54cf6673942174dd41811680240a0dc8e"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "41c11e3295fbc104f63746c72586fa0f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 46618,
        "upload_time": "2021-04-29T16:35:34",
        "upload_time_iso_8601": "2021-04-29T16:35:34.691610Z",
        "url": "https://files.pythonhosted.org/packages/b5/ce/ee3f3b9d93a2a734d4145536b4f16a5dbc0ac5dbd844ff2d178017b86162/pyneMeas-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "255fe3b3d8b03606262f0b392d2d5c2559b16c1c2db01b34f3988ca89d1b04ea",
          "md5": "446e570f077f00274342781922e92871",
          "sha256": "2539122e8f6bfad854f6459b6d27f42c37d2811f8dd1bc04460400c896394b62"
        },
        "downloads": -1,
        "filename": "pyneMeas-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "446e570f077f00274342781922e92871",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 59714,
        "upload_time": "2021-04-29T16:35:36",
        "upload_time_iso_8601": "2021-04-29T16:35:36.149825Z",
        "url": "https://files.pythonhosted.org/packages/25/5f/e3b3d8b03606262f0b392d2d5c2559b16c1c2db01b34f3988ca89d1b04ea/pyneMeas-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "b5ceee3f3b9d93a2a734d4145536b4f16a5dbc0ac5dbd844ff2d178017b86162",
        "md5": "41c11e3295fbc104f63746c72586fa0f",
        "sha256": "97decf268654e1ff9592af2967f402d54cf6673942174dd41811680240a0dc8e"
      },
      "downloads": -1,
      "filename": "pyneMeas-0.0.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "41c11e3295fbc104f63746c72586fa0f",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 46618,
      "upload_time": "2021-04-29T16:35:34",
      "upload_time_iso_8601": "2021-04-29T16:35:34.691610Z",
      "url": "https://files.pythonhosted.org/packages/b5/ce/ee3f3b9d93a2a734d4145536b4f16a5dbc0ac5dbd844ff2d178017b86162/pyneMeas-0.0.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "255fe3b3d8b03606262f0b392d2d5c2559b16c1c2db01b34f3988ca89d1b04ea",
        "md5": "446e570f077f00274342781922e92871",
        "sha256": "2539122e8f6bfad854f6459b6d27f42c37d2811f8dd1bc04460400c896394b62"
      },
      "downloads": -1,
      "filename": "pyneMeas-0.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "446e570f077f00274342781922e92871",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 59714,
      "upload_time": "2021-04-29T16:35:36",
      "upload_time_iso_8601": "2021-04-29T16:35:36.149825Z",
      "url": "https://files.pythonhosted.org/packages/25/5f/e3b3d8b03606262f0b392d2d5c2559b16c1c2db01b34f3988ca89d1b04ea/pyneMeas-0.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}