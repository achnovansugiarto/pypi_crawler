{
  "info": {
    "author": "Bishwa K. Giri",
    "author_email": "kirannbishwa01@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "\n# phASE-Extender\n\n**Extender** for the readbackphased haplotype blocks.\n***A python program to extend the ReadBackPhased haplotype blocks using markov first order transition probabilities and likelihood test.***\n\nDeveloped by [Bishwa K. Giri](mailto:kirannbishwa01@gmail.com) in the [Remington Lab](https://biology.uncg.edu/people/david-remington/) at the University of North Carolina at Greensboro, Biology department.\n\n## Citation\n\nGiri, B. K., Remington D. L. PhaseIT - A haplotype phasing too for heterogenous and hybrid genomes and for emerging genomic models using phase-Extender and phase-Stitcher. biorxiv (2018) [not uploaded yet].\n\n## AUTHOR/SUPPORT\n\nBishwa K. Giri (bkgiri@uncg.edu; kirannbishwa01@gmail.com) \\\nSupport @ <https://groups.google.com/d/forum/phase-extender>\n\n- [phASE-Extender](#phase-extender)\n  - [Citation](#citation)\n  - [AUTHOR/SUPPORT](#authorsupport)\n  - [Intro to ReadBackPhasing](#intro-to-readbackphasing)\n- [BACKGROUND](#background)\n  - [Summary](#summary)\n  - [Algorithm](#algorithm)\n  - [Benefits of using phaseExtender](#benefits-of-using-phaseextender)\n  - [!#f03c15 Data Requirements](#f03c15-data-requirements)\n- [Tutorial](#tutorial)\n  - [Prerequisites](#prerequisites)\n  - [Installation and setup](#installation-and-setup)\n  - [Usage:](#usage)\n\n## Intro to ReadBackPhasing\n\nTwo heterozygote genotypes in a diploid organism genome are called to be readback phased if they are supported by aligned reads sequence. Depending upon the size and type (single end vs. paried end) of read sequence library, type of read sequence (DNAseq vs. RNAseq) readbackphased haplotype can range from the size of 2 genotypes to multiple genotypes.\n\n**Check these links for more details on readbackphasing**\n\n- <https://software.broadinstitute.org/gatk/documentation/tooldocs/3.8-0/org_broadinstitute_gatk_tools_walkers_phasing_ReadBackedPhasing.php>\n- <https://github.com/secastel/phaser/tree/master/phaser>\n\n# BACKGROUND\n\nHaplotype phasing is a second \"go to\" problem in bioinformatics after read alignment. The importance of haplotype phasing applies directly to the analyses of ASE (allele specific expression), preparation of extended haplotype for EHH (extended haplotype homozygosity) test, and preparation of dipolid genome which will soon be a new standard in bioinformatics in coming years, etc. The necessity for haplotype phasing (and eventually diploid genome) increases with the increase in heterozygosity in the genome because higher hetetogeneity leads to larger alignment bias and complicates the reliability of the variants that are called using that alignment data (SAM, BAM files).\n\nThe classical approach to haplotype phasing involves application of LD (linkage disequilibrium) test between two heterozygous markers, that began with the preparation of genetic map by Alfred Sturtevant. Any existing population based haplotype phasing tool therefore uses the LD test with varying degree of complexity based on available sample size, markers, types of the marker and relationship between samples. For haplotype phasing tools like [Beagle](https://faculty.washington.edu/browning/beagle/beagle.html), [ShapeIT](http://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html), [impute2](http://mathgen.stats.ox.ac.uk/impute/impute_v2.html), etc are used dominantly. These tools make use of the variants (SNPs, InDels) along the length of the genome by treating chain of variants along genomic positions singly and independently. So, for a diploid organism that contains chain of variants with \"n\" heterozygote sites there exists **\"2<sup>n</sup>\"** possible haplotypes. To certain extent this **\"2<sup>n</sup>\"** problem is approached and eased by sampling genotype data in short genomic intervals from several samples and applying identity by descent (IBD), most common haplotype method, etc. on the sampled genotypes to infer the possible haplotype in that region. However, application of these methods may not be optimal in solving phase states in organisms that have highly heterogenous genome, are hybrids and/or have very few or no reference panels and abundant genotype data.\n\n**The main issues of the tools that deal with haplotype phasing in**\"2<sup>n</sup>\"**way can be summarized as:**\n\n- Increased computation burden due to **\"2<sup>n</sup>\"** problem.\n- Problem in phasing rare variants.\n- Is mostly applicable to human and organisms with reference haplotype panel and abundant genomic data.\n- Not optimal for organisms that have heterogenous genome, or are outbreds, or are hybrids, or belong to the group of organisms that have small sample of genomic resources and reference genome prepared.  \n  \nTherefore, using LD between two adjacent SNPs using small population of samples isn't able to provide enough resolution to solve GW (genome wide) haplotype preparation, which could result in excessive switch errors. Additionally, in heterogenous and hybrid genome, the problems arising due to switch errors in downstream analyses could be manifold.\n\nReadBackphasing is emerging as a new and more reliable method for preparation of short range haplotypes by joining heterozygous variants that are covered by sequence reads. These short haplotypes can be further elongated by adding sequence reads of longer length (PacBio reads) or by adding more genomic and RNAseq reads from the same individual; see tools [WhatsHap](https://whatshap.readthedocs.io/en/latest/), [hapCut](https://github.com/vibansal/hapcut), [phaser](https://github.com/secastel/phaser/blob/master/phaser/README.md) etc.  \n\n**But, issues with existing RBphase method and tools still remain and can be summmarized as:**\n\n   1. are mainly aimed at preparing long range haplotypes but not necessarily genome wide.\n   2. existing RBphase methods are only targeted at individual or family level, i.e they require multiple inputs of \"BAM\" and \"VCF\" files for the same individual and/or trios. The increase in the size of phased haplotype blocks only depends upon multiple BAM files, or multiple sets of longer reads from the same individual, which still means additional sequencing and cost is involved.\n   3. Referring to point 2 -> integration of RBPhased data with population based phasing is still missing i.e they are not able to solve phase state of two haplotype blocks in same sample by using information of the phase state of the haplotype from other samples.\n\nWith increase in the size of PE (paired end) reads from illumina and availability of longer sequences from [PacBio](https://www.pacb.com/smrt-science/smrt-sequencing/read-lengths/), it is now possible to increase the size of RBphased haplotypes considerably. Inspite of the the longer reads in the future there will always be coverage issues due ro random coverage gaps. This gaps and will break genome wide haploltype into multiple haplotype segments, thus complete RBphasing is also not an optimal solution.\n\n## Summary\n\n**Combination of RBphasing with population based phase extenstion reduces problem of**\n\n- \"2<sup>n</sup>\" computation burden.\n- requirement of large genotype samples and reference panels.\n\nby :\n\n  1. First preparing RBphased haplotype blocks within a sample using aligned sequence reads (BAM, SAM files).\n  2. Next, the two consecutive haplotypes blocks at a break point in a sample are joined by computing the likelihood estimates of the LD (linkage disequilibrium) observed in other samples at that break point.\n\nSince, the size of RBphased blocks increases with the increase in heterozygosity in the genome, **phaseExtender** is a tools highly suitable for the organisms with heterogenous genome and/or which have limited amount of genotype data sequenced. RBphased haplotype always has more information compared to a single SNP or InDel thereby overcoming the issues with switcherrors when preparing the long range haplotype in heterozygous population.\nSo, readbackphasing combined with population based phasing is able to yield higher variants per haplotype block, making **phaseExtender** a better method and tool when working with organisms with higher heterozygosity (out crossing population and hybrids).\n\n## Algorithm\n\n- **phASE-Extender** uses RBphased haplotype data of several individuals that belong to same family, population or species. The readbackphased VCF for a single sample can be prepared using applications like [phaser](https://github.com/secastel/phaser/tree/master/phaser), [hapcut2](https://github.com/vibansal/HapCUT2), [GATK readbackphasing](https://software.broadinstitute.org/gatk/documentation/tooldocs/3.8-0/org_broadinstitute_gatk_tools_walkers_phasing_ReadBackedPhasing.php). Several single sample RBphased VCFs are then merged to create multisample VCF.\n- The RBphased haplotype data from multisample VCF is then converted to simple tabular format (HAPLOTYPE file). The genotype in this tabular format is represented as IUPAC base and haplotype blocks using unique block index.\n- Next, the two consecutive RBphased blocks in a single sample can be joined either in parallel or alternate configuration, see figure **??**.\n- To join the two consecutive RBphased blocks in a single sample we use haplotype state information of other samples in the pool. The likelihood of a posssible configuration (parallel vs. alternate) is estimated as LD observed between the consecutive blocks in the other samples.\n- Likelihood estimates are computed by establishing a first order markov chain between the nucleotides of two consecutive blocks. Markov chains are represented as first order transition matrix from all the nucleotides of former haplotype block to all the nucelotides in the later haplotype block and then vice versa (for the reverse chain). The observed nucleotide emission probablity and transition probablity are cumulated into maxed-sum or maxed-product value to form a meaningful likelyhood estimates for both the configuration (parallel vs. alternate).\n- The phase state of two consecutive haplotype blocks is then extended if the `computed log2 (likelihood)` of either configuration is above the `threshold log2(likelihood) cutoff`.\n\nFor the **mcve** regarding the algorithm see this issue on [**stackoverflow**](https://codereview.stackexchange.com/questions/186396/solve-the-phase-state-between-two-haplotype-blocks-using-markov-transition-proba) and/or [**my blog**](https://everestialblog.wordpress.com/2018/03/27/extension-of-the-readbackphased-haplotypes-using-phase-extender/).\n\n## Benefits of using phaseExtender\n\n- Combination of RBphased data with populaiton based phasing therefore allows us to use small sample size to accurately predict the proper haplotype state.\n- PhaseExtender provides flexibility to adjust the number of phased genotype used for building markov chains between consecutive blocks.\n- PhaseExtender provide flexibility of limiting phase extension to certain bed regions.\n- Ability to adjust LOD cutoff along with above discussed customization provides a means to recursively improve haplotype phasing.\n\n## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) Data Requirements\n\n**phASE-Extender** can be used with the multi-sample vcf files produced by GATK pipeline or other tools that generate readbackphased haplotype blocks in the output VCF. A haplotype file is created using the RBphased VCF and then piped into **phase-Extender**. See, this example for data structure of input haplotype file [sample input haplotype file01](https://github.com/everestial/phase-Extender/blob/master/example01/input_haplotype_small.txt) - a tab separated text file with `PI` and `PG_al` value for each samples.\n\nIn several tutorial examples (test files below) I have used hapotype file prepared from RBphased VCF generated by `phaser` (<https://github.com/secastel/phaser> , <https://github.com/secastel/phaser/tree/master/phaser>). However, **phase-Extender** can be used with input haplotype file prepared from any RBphased VCF given it meets the appropriate data structure. Readbackphased VCF can be converted into `haplotype file` using an add-on tool `vcf_to_table-v3.py`.\\\nVCF from `phaser` consists of `Phased Genotype i.e PG` and `Phase Block Index i.e PI` values in `FORMAT` field; **PI** represents the `unique haplotype block index` and **PG** represents the `phased genotypes within that PI block`.  After converting the `RBphased VCF` to `haplotype file` **phase-Extender** uses the `Phased Genotype i.e PG` and `Phase Block Index i.e PI` values in the `haplotype file` to prepare the transition matrix probabilities and proceed with phase extension.\n\n# Tutorial\n\n### Prerequisites\n\n**phase-Extender** is written in python3, so you need to have python3 installed on your system to run this code locally. If you don't have python installed then, you can install from [here](https://www.python.org/downloads/). For linux; you can get latest python3 by:\n\n`sudo apt-get install python3`\n\n### Installation from pypi:\nPhase Extender is hosted on pypi. So, you can install it using pip as:\n```bash\npip install phase-extender\n```\n\n### Installation  and setup from source\n\n1. Clone this repo.\n\n```\ngit clone https://github.com/everestial/phase-Extender\ncd phase-Extender\n```\n\n2. Make virtual env for python and install requirements.\n\n```\npython3 -m venv myenv\nsource myenv/bin/activate   # for linux\nmyenv\\Scripts\\activate      # for windows\npip install -r requirements.txt\n```\n\nOR, you can install latest versions individually by:\n\n```\npip install pandas numpy matplotlib\n\n```\n\n3. To run tests locally:\n\n  ``` pip install pytest\n      pytest . \n   ```\n\n4. Run help on phase extender\n\n```\n   python3 phase_extender.py -h  \n```\n\n<pre>\nChecking and importing required modules:\n\n#######################################################################\n        Welcome to phase-extender version 1\n  Author: kiranNbishwa (bkgiri@uncg.edu, kirannbishwa01@gmail.com)\n#######################################################################\n\nLoading the argument variables ....\nusage: phase_extender.py [-h] [--nt NT] --input INPUT --SOI SOI\n                         [--output OUTPUT] [--refHap REFHAP]\n                         [--useSample USESAMPLE] [--bed BED] [--snpTh SNPTH]\n                         [--numHets NUMHETS] [--lods LODS] [--culLH CULLH]\n                         [--writeLOD WRITELOD] [--hapStats HAPSTATS]\n                         [--addMissingSites ADDMISSINGSITES]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --nt NT               number of process to run -> the maximum number of\n                        processes that can be run at once is the number of\n                        different chromosomes (contigs) in the input haplotype\n                        file.\n  --input INPUT         name of the input haplotype file -> This haplotype\n                        file should contain unique index represented by 'PI'\n                        and phased genotype represented by 'PG_al' for several\n                        samples.\n  --SOI SOI             sample of interest -> Name of the sample intended for\n                        haplotype extension.\n  --output OUTPUT       Name of the output directory. default: 'SOI_extended'\n  --refHap REFHAP       reference haplotype panel -> This file should also\n                        contain 'PI' and 'PG_al' values for each sample in\n                        that haplotype reference panel.default: empty\n  --useSample USESAMPLE\n                        list of samples -> Use phase state information only\n                        from these samples while running. This is intended to\n                        provide control over phase-extension by allowing\n                        select samples from the pool of samples (refHap and/or\n                        input). This is useful for comparing the results when\n                        different individuals, populations are used in phase\n                        extension process.Options:\n                        'all','refHap','input','comma separated name of\n                        samples'. default: 'all' - i.e all the samples in\n                        (refHap + input) will be used, if refHap is given else\n                        all samples only from input file is used.\n  --bed BED             bed file -> Process the haplotype extension only in\n                        this bed regions. This is useful to limit haplotype\n                        extension only within certain regions, like - within\n                        genes, exons, introns, QTL, etc. default: empty\n  --snpTh SNPTH         snp threshold -> Minimum number of SNPs required in\n                        both haplotype blocks before starting phase extension.\n                        Option: an integer value. Default: snpTh = 3\n  --numHets NUMHETS     number of heterozygote SNPs -> Maximum number of\n                        heterozygote SNPs used in consecutive haplotype blocks\n                        for computing likelyhood of the phase states. Option:\n                        an integer value. Default: numHets = 40\n  --lods LODS           log2 of Odds cut off -> Cutoff threshold to assign the\n                        phase states between consecutive haplotype blocks.\n                        Option: an integer value Default: 5 for parallel\n                        configuration (i.e 2^5 = 32 times more likely).\n  --culLH CULLH         Cumulative likelhood estimates -> The likelhoods for\n                        two possible configuration can either be max-sum vs.\n                        max-product. Default: maxPd i.e max-product. Options:\n                        'maxPd' or 'maxSum'.\n  --writeLOD WRITELOD   write log2 of Odds to the output file-> writes the\n                        calculated LODs between two consecutive haplotype\n                        blocks in the output file. Option: 'yes', 'no'.\n                        Default: no. **Note: the 'lods-score' are printed\n                        regardless if the consecutive blocks are joined or\n                        not.\n  --hapStats HAPSTATS   Computes the descriptive statistics and plots\n                        histogram of the haplotype for input and extended\n                        haplotype. Default: 'no'.Option: 'yes', 'no' .\n  --addMissingSites ADDMISSINGSITES\n                        write the lines that have data missing for SOI on the\n                        output file. Option: yes, no\n   </pre>\n\n## Usage\n\n1. First example:\n\n`\npython3 phase_extender.py --input tests/inputs/eg1/input_haplotype_file.txt --SOI ms02g --lods 10`\n<pre>\nChecking and importing required modules:\n\n#######################################################################\n        Welcome to phase-extender version 1\n  Author: kiranNbishwa (bkgiri@uncg.edu, kirannbishwa01@gmail.com)\n#######################################################################\n\nLoading the argument variables ....\nAssigning values to the global variables ....\n  - sample of interest: \"ms02g\"\n  - using \"1\" processes\n  - using haplotype file \"tests/inputs/eg1/input_haplotype_file.txt\"\n  - using log2 odds cut off of \"10.0\"\n  - each consecutive haplotype block should have minimum of \"3\" SNPs\n  - using maximum of \"40\" heterozygote sites in each consecutive blocks to compute transition probabilities\n  - using \"max product\" to estimate the cumulative maximum likelyhood of each haplotype configuration between two consecutive blocks\n  - no bed file is given.\n  - no reference haplotype panel is provided\n  - statistics of the haplotype before and after extension will not be prepared for the sample of interest i.e \"ms02g\".     Only extendent haplotype block will be prepared.\n  - LOD (log 2 of odds) for consecutive block will not be written to the output file\n\n# Reading the input haplotype file \"tests/inputs/eg1/input_haplotype_file.txt\"\n  - Lines that have data missing for sample \"ms02g\" is written in the file \"ms02g_extended/missingdata_ms02g.txt\"\n\n# Genomic bed file is not provided ...\n  - So, phase extension will run throughout the genome.\n\n# Haplotype reference panel is not provided ...\n  So, phase extension will run using the samples available in the input haplotype file.\n\n# Filtered the lines that have data missing for sample \"ms02g\"; check the file \"ms02g_extended/missingdata_ms02g.txt\"\n  - Loaded read-backphased variants onto the memory\n\n# Haplotype reference panel is not provided....\n  - Only using the samples in the input (\"tests/inputs/eg1/input_haplotype_file.txt\") data.\n\n# No bed file is given ...\n  - So, grouping the haplotype file only by chromosome (contig)\n\n# Writing initial haplotype for sample \"ms02g\" in the file \"initial_haplotype_ms02g.txt\"\n  - Proceeding to phase-extension without preparing descriptive statistics of initial haplotype state.\n\n# Starting multiprocessing using \"1\" processes\n\n## Extending haplotype blocks in chromosome (contig) 2\n  - Grouping the dataframe using unique \"PI - phased index\" values.\n  - Starting MarkovChains for contig 2\n  - Phase-extension completed for contig \"2\" in 0.017184734344482422 seconds\n  - Worker maximum memory usage: 58.57 (mb)\n\nCompleted haplotype extension for all the chromosomes.time elapsed: '0.11295127868652344'\nGlobal maximum memory usage: 79.88 (mb)\nMerging dataframes together .....\n\nExtended haplotype data for sample \"ms02g\" is written in the file \"extended_haplotype_ms02g.txt\".\nSkipping the preparation of descriptive statistics of extended haplotype.\n\nRun is complete for all the chromosomes (contigs)\n\nwriting singletons and missing sites to extended haplotype\nEnd :)\n</pre>\n\n## Usage and Inputs\n\n- Requires a multisample readbackphased `haplotype file` as input and returns a single sample extended haplotype file. Other results files containing statistics on the initial vs. extended haplotype are also produced.\n- Optionally, haplotype reference panel (with same data structure as input haplotype) and bed file can be included to limit or improve the process of phase extension.\n\n?? needs improvement.  \nCheck this detailed [step by step tutorial](https://github.com/everestial/phase-Extender/wiki/phase-Extender-Tutorial) for preparation of `input files` and know-how about running `phase-Extender`.\n??\n\n## Inputs\n\n***haplotype file (required):*** Input haplotype file. Should contain `PI` and `PG_al` values for each sample.\\\nTo convert the vcf file to haplotype file (from VCF to tabular format) use ??**Step 01 (a)** in the tutorial. \\\nThe sample name should not contain \"`_`\" character.\n\n***haplotype reference panel (optional):*** Unlike \"haplotype reference panel\" used in other phasing tools, phaseExtender requires reference panel in the same structure as a HAPLOTYPE file.\nTo convert the haplotype reference panel (from VCF to proper text format) use **Step 01 (b)** in the tutorial. ??\n  \n***bed file (optional):*** If you goal is to limit phase extension to certain genomic regions (for eg. gene, exon or QTL boundries), we suggest that you provide appropriate bed file. **phase-Extender** then exclusively limits phasing within internal boundries of the input bed regions.\n\n    # structure of the bed file\n    contig    start    end       # this header is not included    \n    2         1258     199897\n    2         397765   412569\n\n    #To convert the GTF,GFF to bed file use:\n    python3 gffToBed.py  --input myGTF.gtf  --output myBed.bed\n\n**the required python file for bed file preparation is at:**\n<https://github.com/everestial/SmallTools/tree/master/GtfToTable>\n<https://github.com/melissacline/TCGA-GAF-source/blob/master/scripts/gffToBed.py>\n\nContinue .............\n\n## Arguments\n\n### Required\n\n- **--input** - input haplotype file. `PI` and `PG_al` should be present in header for each sample.\n\n- **--SOI** - sample of interest. It should refer to a single sample in the haplotype the file. The sample name should not contain \"`_`\" character.\n\n### Performance Related\n\n- **--nt** *(1)* - maximum number of processes to run at once. The maximum number of processes is limited to number of chromosomes (contigs) in the input haplotype file.\n\n### Optional\n\n- **--python_string** *(python3)* - Calls `python 3` interpreter to run the program.\n\n- **--output** *(SOI_extended)* - Output directory.\n- **--snpTh** *(3)* - snp threshold. Minimum number of SNPs required in each consecutive haplotype block to run phase extension between two blocks.\n- **--numHets** *(40)* - num of heterozygotes. Maximum number of heterozygote SNPs used from each consecutive block to compute maximum likelihood estimate of each configuration between two blocks.\n- **--culLH** *(maxPd)* - cumulation of the likelihood estimates. The likelhoods for two possible configuration can either be \"maxed as sum\" or \"maxed as product\". ***Default*** is \"max-product\". ***Options:*** 'maxPd' or 'maxSum'.\n- **--lods** *(5)* - log2 of Odds cut off threshold. The cutoff threshold used to extend consecutive haplotype blocks. **`**Note: Default value is set at (2^5 = 32 times likely). So, two consecutive blocks will be joined in parallel configuration if computed log2(likelihood) > lods threshold **\n- **--useSample** *(all)* - Samples to use in the given input haplotype file (plus reference haplotype) to compute transition matrix. Options: 'all','refHap','input','comma separated name of samples'. Default: all the samples in (refHap + input) will be used.\n- **--bed** - Process the haplotype extension only within this bed regions. ***This is useful if you want to limit haplotype extension only within certain regions, like - within genes, exons, introns, QTL boundries, etc.***\n- **--writeLOD** *(no)* - writes the calculate LODs between two consecutive haplotype blocks when processing phase extension to the output file. **Options:** 'yes', 'no'. **`**Note: the 'lods-score' are printed regardless if the \"\n\"consecutive blocks are joined or not.**\n- **--hapStats** *(no)* - Prepare descriptive statistics, and histogram of the haplotype size distribution of the input haplotype file vs. extended haplotype for the sample of interest. **Options:** 'yes', 'no'\n- **--addMissingSites** *(no)* - include the non-phased and missing genotype data from input haplotype file to the final phase extended output file. **Option:** 'yes', 'no'.\n\n## Output Files\n\n### initial_haplotype_*SOI*.txt & extended_haplotype_*SOI*.txt\n\nContains all RBphased haplotype data for the sample of interest before and after phase extension.\n\n- 1 - **contig** - Contig name (or number).\n- 2 - **pos** - Start position of haplotype (1 based).\n- 3 - **ref** - Reference allele at that site.\n- 4 - **all-alleles** - All the alleles represented by all the samples at that site.\n- 5 - **SOI_PI** - Unique `PI` index of the haplotype blocks for sample of interest.\n- 6 - **SOI_PG_al** - Phased GT (genotype) alleles at the genomic position that belong to unique `PI` indexes.\n- 7 - **log2Odds** (only in **extended_haplotype_SOI.txt**) - log2Odds computed between the former and later block.\n\n### initial_haplotype_stats_*SOI*.txt & final_haplotype_stats_*SOI*.txt\n\nDescriptive haplotype statistics of the input haplotype file for the sample of interest.\n\n- 1 - **contig** - Contig name (or number).\n- 2 - **SOI_PI** - Comma separated list of unique `PI` index of the haplotype blocks for the sample of interest. The total number of `PI` index represents the total number of haplotype fragments that are present in the given contig in that sample.\n- 3 - **num_Vars_by_PI** - Number of variants sites within each `PI` block for the sample of interest.\n- 4 - **range_of_PI** - Genomic range of the each `PI` block for the sample of interest.\n- 5 - **total_haplotypes** - Total number of haplotype (i.e `PI`) in the given coting for the sample of interest.\n- 6 - **total_Vars** - Total number of variant sites in the given contig for the sample of interest. **Note:** The sum of (num_Vars_by_PI) = total_Vars.\n\n**Note:** - The `SOI_PI`, and it's associated statistics are in order.\n\n### missingdata_*SOI*.txt\n\nContains data from the sites that have unphased or missing GT (genotype) for the sample of interest in the input haplotype file.\n**Note:** This data is merged with `extended_haplotype_SOI.txt` if `--addMissingSites` is set to \"yes\".\n\n### extended_haplotype_\"SOI_\"allsites.txt\n\nThis file contains ReadBackPhased haplotype after phase extension concated with the missing data. This file contain equal number of row as input haplotype file and data only for sample of interest.\n\n## Plots\n\nFor plotting statistics from initial and files files in each iteration; you can use [merged stats haps data](Merge haplotypes stats.ipynb) & [plot data notebook notebook](./plot stacked data.ipynb).\n\n\n**Note:** - These plots are based on the descriptive statistics generated for haplotypes before and after phase extension. It is possible to take these statistics (initial_haplotype_stats_*SOI*.txt & final_haplotype_stats_*SOI*.txt) and make custom plots in **R** or by using other methods.\n\n### total_haps_\"SOI_\"initial.png  & total_haps_\"SOI_\"final.png\n\nNumber of haplotypes for given contig before and after phase extension.\n\n### total_vars_\"SOI_\"initial.png  & total_vars_\"SOI_\"final.png\n\nNumber of variants for given contig before and after phase extension.\n\n### hap_size_byVar_\"SOI_\"initial.png & hap_size_byVar_\"SOI_\"final.png\n\nHistogram of the distribution of the haplotype size (by number of variants in the haplotype) in given contig before and after phase extension.\n\n### hap_size_byGenomicRange_\"SOI_\"initial.png & hap_size_byGenomicRange_\"SOI_\"final.png\n\nHistogram of the distribution of the haplotype size (by genomic range of the haplotype) in given contig before and after phase extension.\n\n## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+)Some Q/A on phase-extender\n\n  ***1) What kind of algorithm does phase-extender use ?***  \n  phase-extender uses first-order-transition probabilities from each level of genotypes from former haplotype block to each level of genotypes to later haplotype block. This version (v1) uses **forward-1stOrder-markov chains** and **backward-1stOrder-markov chains** transition probabilities. Future versions will follow improvements by adding markov-chains of higher order.\n\n  ***2) What is the advantage of using phase-extender ?***  \n  We generally need accurate phase state with in a gene/transcript level while doing ASE, dissecting maternal-paternal effects. Long haplotypes are mostly important while preparing diploid genome, testing selective sweeps within a QTL regions etc. For emerging organism systems where genotype data are sparse CW (chromosome wide), GW (genome wide) haplotypes are more difficult to solve. Also, haplotype phasing may be more complicated in out crossing individuals and hybrids due to heterogenity.\\ RBphasing actually provides an advantage with heterogenous genome because frequency of RBphased blocks increases with heterogenity in the genome. These short haplotype fragments have multiple heterozygous variants on a short haplotype block. With increase in the size of `PE` (paired end) reads the size of RBphase blocks are also increases. phase-extender comes handy at this stage; that it tries to solve phase state of two consecutive blocks from one sample at a time by using data from haplotype blocks of other samples that bridge that breakpoint. So, we can solve haplotype configuration for SOI (sample of interest) with more confidence because:\n     - we have more variants within each blocks contributing to more information.\n     - we only need to solve two possible phase state at one time compared to 2^n haplotype when reading one SNP at a time.\n    phase-Extender also provides a more flexible and manipulative control over how to proceed with phase extension. It is also possible to control several parameters like `lods`, `snpTh`, `numHets`, `culLH`, `bed`, `useSample` to observe and compare how phase extension changes.\n\n  ***3) Does phase-extender phase InDels ?***  \n    Yes, but it is conditional. The InDels should already be reliably readbackphased to a haplotype block. That way when the haplotype is being extended for those SNPs, InDels hitchhike with it and get extended too.\n\n  ***4) What is the minimal size of the haplotype block that is required?***  \n    The bigger the two haplotypes are, the better is the likelyhood test of which haplotype is phased with which. By, default I have kept this number to 3 variants (SNPs exclusive) per haplotype block that needs extension.\n\n  ***5) Does phase-extender do GW (genome wide) or CW (chromosome wide) haplotype phasing***?  \n  There are certain situation when phase-extender is able to do GW or CW haplotype phasing.\n    A) If you have lots of samples where the haplotypes breakpoint in one sample is bridged by other samples, such that breakpoint gets solved with each recursive application of `phase-Extender` then it is possible to obtain CW and GW haplotype.\n    In this case we can run phase-extender for each sample there by extending the haplotype to certain extent. After this phase-extender can be applied recursively on the updated data each time, there by extending the haplotypes for each sample to full chromosome length and possibly to to full genome wide length. There is greater likelyhood of obtaining GW phase if samples are sequenced at higher coverage, increase in paired-end sequence length, availability of large sequence reads like pac-bio reads.\n    B) Another situation when GW, CW phase extension might be possible is when you have at least few samples which have haplotype resolved at GW/CW level. These can include fully phased data like genome matrix file, fully phased VCF data, fully phased haplotype reference panel. For this the fully phased sample should be provided as one single blocks in the group of sample that is piped to `phase-extender`.\n\n  ***6) Does phase-extender phase non readbackphase SNPs***?  \n    No, it does not. It is a possible future update.\n\n  ***7) Does phase-extender impute missing genotypes***?  \n    No, it does not. It is a possible future update.\n\n  ***8) Does phase-extender use haplotype reference panel***?  \n    Yes, it does. Thought, the VCF (haplotype reference panel) should be convert to appropriate haplotype file.\n\n  ***9) Does phase-extender use recombination into account***?  \n    No and possibly these feature will be of least importance in phase-extender. Main objective of `Phase-Extender` is to join already phased short consecutive haplotype blocks with in a sample by using the relationship of the variants at those sites in several other samples. These haplotypes which are phased in other samples but has breakpoint in SOI are used to build transition probabilities. There is an assumption that recombination is less likely to occur exactly at that breakpoint or near it. So, most of the variation in haplotype among samples around the break point are not the result of recent recombination but only mutation.\n\n  ***10) Does phase-extender phase rare genotypes***?  \n    Yes, it does. But, the rare genotype should be the readbackphased to the short haplotype blocks. This is one of the advantage of `phase-extender` compared to other tools when it come to phasing rare genotype. When a single SNPs is used singly to phase into a haplotype, rare genotypes are really hard to phase accurately - the reason being the statistical significance of the rare genotype belonging to either two phase state is highly ambigous. But, if the rare genotype is attached to a haplotye block supported by several read-back phased genotypes, this makes phasing of rare genotypes most accurate, since likelyhoods are provided by other SNPs that are not rare.\n\n  ***11) How fast is phase-extender***?  \n    phase-extender is written in python-3, so it is comparatively slower than other tools that are built on the top of C, C++ or java.\n   Coming from a pure biology background, learning python was one of the most enduring task I have taken and then building this tool was a big part of my PhD. I have optimized the part of calling VCF file using cyvcf2 (which is on average 4 times faster than old pyVCF module). phase-extender is also optimized for being able to run on multiple threads/process. But, if you are running phase-extender on big genome data and have very large number of samples, and running on laptop I suggest running on one thread, which may be time consuming but will reduce memory burden.\n\n  ***12) Does phase-extender do trio based phase extension***?  \n    No, it does not. It is a possible future update.\n\n  ***13) What should be the relatedness of my samples***?  \n    Within population, or within species level data are good.\n\n  ***14) What is differece between phase extender and phase stitcher***?  \n    `phase-Extender` is a general puprpose haplotype phasing tools. `phase-Stitcher` is specifically for F1 hybrids.\n\n  **_15) Should I prepare my haplotype block file only using `phaser`_**?  \n    `phase-Extender`, `phase-Stitcher` can be use with data generated by any RBphasing tool.\n\n## Acknowledgement\n\n   I have not been very fortunate to surround myself or at least get face to face help from savvy computer programmers. But, my heart is very thankful to people behind the web who have made me capable of working this problem out. **Thanks to many people on biostars, stackoverflow, seqanswer and google web searches who provided feedback on small question that were the part of `phase-Extender` project.**\n\n   Should anyone be interested in futher improving this project via improvments on alrorithm and programming, I would be more than happy to.  \n\n## Expected capabilities in the future (coming soon)\n\n- Phase SNPs that are not assigned to ReadBackPhased blocks\n- Genotype imputation\n- Trio based phasing, Family based phasing\n- Higher order markov chain capabilities\n- Multiprocessing within chromosome\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/everestial/phase-Extender",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "phase-extender",
    "package_url": "https://pypi.org/project/phase-extender/",
    "platform": null,
    "project_url": "https://pypi.org/project/phase-extender/",
    "project_urls": {
      "Bug Tracker": "https://github.com/everestial/phase-Extender",
      "Homepage": "https://github.com/everestial/phase-Extender"
    },
    "release_url": "https://pypi.org/project/phase-extender/0.1.8/",
    "requires_dist": [
      "numpy (>=1.22)",
      "matplotlib (>=3)",
      "pandas (>=1)",
      "seaborn"
    ],
    "requires_python": ">=3.7",
    "summary": "A python program that uses ReadBack phased haplotypes in population of samples and returns extended haplotype blocks.",
    "version": "0.1.8",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13231213,
  "releases": {
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "864fa8a018ddf4b97332c51b791d867372a2752e8f0366a14b0de6768e417109",
          "md5": "03967a69017ecf51d57452585946a7bd",
          "sha256": "3c5a882cfe8606f0d2db2c466f37b1e2721b108d6639760be662a27be10bbbc5"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "03967a69017ecf51d57452585946a7bd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 39677,
        "upload_time": "2022-02-15T17:09:09",
        "upload_time_iso_8601": "2022-02-15T17:09:09.922383Z",
        "url": "https://files.pythonhosted.org/packages/86/4f/a8a018ddf4b97332c51b791d867372a2752e8f0366a14b0de6768e417109/phase_extender-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b9a88b1d34bee7fccd06955d8d0b4bdce3e94da609808119d304dfc791419b03",
          "md5": "2e0668ec11cd4a1ec0f7c2ab77f9dd3e",
          "sha256": "8cb7eda13503a7d9f327173b3846b38bd7574802dd8671d89b3ffec34c31fdbf"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2e0668ec11cd4a1ec0f7c2ab77f9dd3e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59081,
        "upload_time": "2022-02-15T17:09:12",
        "upload_time_iso_8601": "2022-02-15T17:09:12.290257Z",
        "url": "https://files.pythonhosted.org/packages/b9/a8/8b1d34bee7fccd06955d8d0b4bdce3e94da609808119d304dfc791419b03/phase_extender-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5fae9ad25e1cd225ad8c2003dfb1380d86ac03c66fcc4ff3e33a31221ab781f0",
          "md5": "9019bb97550fd8e5692453db28b13029",
          "sha256": "f9abe37d9f7fb55a32ad2613fad7fe914cafb277cd505a4f2b32feb8ff83c125"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9019bb97550fd8e5692453db28b13029",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 39691,
        "upload_time": "2022-02-15T17:12:09",
        "upload_time_iso_8601": "2022-02-15T17:12:09.433372Z",
        "url": "https://files.pythonhosted.org/packages/5f/ae/9ad25e1cd225ad8c2003dfb1380d86ac03c66fcc4ff3e33a31221ab781f0/phase_extender-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b3ab77b4a9d732c1590626f8a48a32959d02457720826e997eca917fa73cfb45",
          "md5": "068fdf76297112b6b246130134b7e4c6",
          "sha256": "6a45b2deae8645f37796627bd1cc627b74acd2f369de09a2025e7a32e3a18381"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "068fdf76297112b6b246130134b7e4c6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59102,
        "upload_time": "2022-02-15T17:12:11",
        "upload_time_iso_8601": "2022-02-15T17:12:11.509759Z",
        "url": "https://files.pythonhosted.org/packages/b3/ab/77b4a9d732c1590626f8a48a32959d02457720826e997eca917fa73cfb45/phase_extender-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a95b63f69916fcd34b986c7ac9a4265f54b32b08e123302b539fc45af913b3f8",
          "md5": "3a108c77113cfecbaf3b135227e83f5d",
          "sha256": "ce1f7300bf16edec4749dff4709ebc82a91bd9d94506dba760ed0ea163703680"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3a108c77113cfecbaf3b135227e83f5d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 39792,
        "upload_time": "2022-02-17T14:41:28",
        "upload_time_iso_8601": "2022-02-17T14:41:28.688593Z",
        "url": "https://files.pythonhosted.org/packages/a9/5b/63f69916fcd34b986c7ac9a4265f54b32b08e123302b539fc45af913b3f8/phase_extender-0.1.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2699dc23adbba625588a2ca188fb6faeb1a13095605de2791541725d646fe7f3",
          "md5": "97c5e828535b1c11fef6548e5d027e8a",
          "sha256": "da8d048b73b5c7cc11c4891f31eeca71cf955a450524b5f4cefea5452184418b"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "97c5e828535b1c11fef6548e5d027e8a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59233,
        "upload_time": "2022-02-17T14:41:30",
        "upload_time_iso_8601": "2022-02-17T14:41:30.721545Z",
        "url": "https://files.pythonhosted.org/packages/26/99/dc23adbba625588a2ca188fb6faeb1a13095605de2791541725d646fe7f3/phase_extender-0.1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "73386ad9dd6326711b499a6a47270bb30b0905ea30090e6175bb444838f9a18e",
          "md5": "4340c2ae4fd540d42a42592f768347d7",
          "sha256": "dac8d8e3f3d3e68b9c6afcea4806f1b69affab4c403aa6a9c071847e15218c79"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4340c2ae4fd540d42a42592f768347d7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 39848,
        "upload_time": "2022-02-19T03:25:26",
        "upload_time_iso_8601": "2022-02-19T03:25:26.802230Z",
        "url": "https://files.pythonhosted.org/packages/73/38/6ad9dd6326711b499a6a47270bb30b0905ea30090e6175bb444838f9a18e/phase_extender-0.1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6b06ac13d799f3ed0df702eae77a713a36cdf15fd69a0fec99d74f3785af93b1",
          "md5": "4b2f920f88c016e827ddbb921a13733f",
          "sha256": "a7c0993a580f6b9d5e27e6b580bde4596ace59ededf4529bca52b25c113ade90"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "4b2f920f88c016e827ddbb921a13733f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59274,
        "upload_time": "2022-02-19T03:25:28",
        "upload_time_iso_8601": "2022-02-19T03:25:28.760964Z",
        "url": "https://files.pythonhosted.org/packages/6b/06/ac13d799f3ed0df702eae77a713a36cdf15fd69a0fec99d74f3785af93b1/phase_extender-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "35d51a804b743433c3f28bfa8fd875330428bf1b21efbec0b27a80d636e055b4",
          "md5": "296fab6265c41e7f7b83760f1c989ba5",
          "sha256": "a8b306eafac2e32678772225ffca986dada6b2be854c063fd8010ff9baeedf26"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "296fab6265c41e7f7b83760f1c989ba5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 40045,
        "upload_time": "2022-03-05T04:12:56",
        "upload_time_iso_8601": "2022-03-05T04:12:56.084070Z",
        "url": "https://files.pythonhosted.org/packages/35/d5/1a804b743433c3f28bfa8fd875330428bf1b21efbec0b27a80d636e055b4/phase_extender-0.1.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "582d1d6153a186ffb68e19e4017f1a2069c4b44d97a7e2631f637a8f61f76e1f",
          "md5": "6f7972abe60069bab093f31172af0926",
          "sha256": "fcdd2791bad0d62c2eb95c9857089a62547349b99938c63cc09c648d3e2326f0"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "6f7972abe60069bab093f31172af0926",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 59492,
        "upload_time": "2022-03-05T04:12:58",
        "upload_time_iso_8601": "2022-03-05T04:12:58.744791Z",
        "url": "https://files.pythonhosted.org/packages/58/2d/1d6153a186ffb68e19e4017f1a2069c4b44d97a7e2631f637a8f61f76e1f/phase_extender-0.1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cf6ad6eb469812c4de1b8df0f1f9c9c401636cad30b8e17f1a4d7d179974abfc",
          "md5": "845add423100792cf8307654107dd969",
          "sha256": "b46261b53666da8e0c3a55b11df01757d6ec5edf5507df3c480f95bd0f33d5c6"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "845add423100792cf8307654107dd969",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 40853,
        "upload_time": "2022-03-15T14:16:40",
        "upload_time_iso_8601": "2022-03-15T14:16:40.366497Z",
        "url": "https://files.pythonhosted.org/packages/cf/6a/d6eb469812c4de1b8df0f1f9c9c401636cad30b8e17f1a4d7d179974abfc/phase_extender-0.1.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9f5010e7e50097aa6b8d273282555cfd123f478eb1fcdc76c18878de049c2de9",
          "md5": "d9bd60616217d3a7612acfa7184972c8",
          "sha256": "1728dd8977bf353884b1f947d6b131f608477256ebe73f394fbf83041964d293"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "d9bd60616217d3a7612acfa7184972c8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60366,
        "upload_time": "2022-03-15T14:16:43",
        "upload_time_iso_8601": "2022-03-15T14:16:43.134452Z",
        "url": "https://files.pythonhosted.org/packages/9f/50/10e7e50097aa6b8d273282555cfd123f478eb1fcdc76c18878de049c2de9/phase_extender-0.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0c0d4ea037f0d97b522531aea4b411b7f38ae6908633f1f6dab3de61ff846d6b",
          "md5": "66777dc422db836ba79847e708a402e5",
          "sha256": "9594ced35b8a9c8d0f532f1902bb92bc5be6db25fd8c85c6dfd4df0ec14f74ec"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "66777dc422db836ba79847e708a402e5",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 40943,
        "upload_time": "2022-03-20T17:23:26",
        "upload_time_iso_8601": "2022-03-20T17:23:26.502581Z",
        "url": "https://files.pythonhosted.org/packages/0c/0d/4ea037f0d97b522531aea4b411b7f38ae6908633f1f6dab3de61ff846d6b/phase_extender-0.1.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7df159c2af858cef01f1455344fd4613821f15be78e88f890c524e5e48ff8bf4",
          "md5": "8d93575fdf9465da1eb48fb4ef3346aa",
          "sha256": "4ac9cfaa75a7c58f81742a9d434945d233c9f6bdd9d2002c2f1c36ff42915e9e"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "8d93575fdf9465da1eb48fb4ef3346aa",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60625,
        "upload_time": "2022-03-20T17:23:28",
        "upload_time_iso_8601": "2022-03-20T17:23:28.550641Z",
        "url": "https://files.pythonhosted.org/packages/7d/f1/59c2af858cef01f1455344fd4613821f15be78e88f890c524e5e48ff8bf4/phase_extender-0.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5ffa6200ac73f2aff163cc7ae599cdea13e0b6fafecba60a0ec7e3c3c00cac7c",
          "md5": "e58fac427e7731feb96b67f04d164109",
          "sha256": "d338f25e58159d68fc4210519fe2a382b534a15b3b3e79a5080ebce69cd4bd4c"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e58fac427e7731feb96b67f04d164109",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 40997,
        "upload_time": "2022-03-20T17:30:12",
        "upload_time_iso_8601": "2022-03-20T17:30:12.999623Z",
        "url": "https://files.pythonhosted.org/packages/5f/fa/6200ac73f2aff163cc7ae599cdea13e0b6fafecba60a0ec7e3c3c00cac7c/phase_extender-0.1.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eaaf2d54975f7e3f1b55a274a4a13942b2bb71b92a212819dd74a126f28b9bbd",
          "md5": "0b5dd9afd2d6b38a90f56ec3bf5eaba5",
          "sha256": "6277053755b450a91e6e7337a659047ad52ff12ca4fb9dc75969df87a83aa64d"
        },
        "downloads": -1,
        "filename": "phase_extender-0.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "0b5dd9afd2d6b38a90f56ec3bf5eaba5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60802,
        "upload_time": "2022-03-20T17:30:15",
        "upload_time_iso_8601": "2022-03-20T17:30:15.218924Z",
        "url": "https://files.pythonhosted.org/packages/ea/af/2d54975f7e3f1b55a274a4a13942b2bb71b92a212819dd74a126f28b9bbd/phase_extender-0.1.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5ffa6200ac73f2aff163cc7ae599cdea13e0b6fafecba60a0ec7e3c3c00cac7c",
        "md5": "e58fac427e7731feb96b67f04d164109",
        "sha256": "d338f25e58159d68fc4210519fe2a382b534a15b3b3e79a5080ebce69cd4bd4c"
      },
      "downloads": -1,
      "filename": "phase_extender-0.1.8-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "e58fac427e7731feb96b67f04d164109",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 40997,
      "upload_time": "2022-03-20T17:30:12",
      "upload_time_iso_8601": "2022-03-20T17:30:12.999623Z",
      "url": "https://files.pythonhosted.org/packages/5f/fa/6200ac73f2aff163cc7ae599cdea13e0b6fafecba60a0ec7e3c3c00cac7c/phase_extender-0.1.8-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "eaaf2d54975f7e3f1b55a274a4a13942b2bb71b92a212819dd74a126f28b9bbd",
        "md5": "0b5dd9afd2d6b38a90f56ec3bf5eaba5",
        "sha256": "6277053755b450a91e6e7337a659047ad52ff12ca4fb9dc75969df87a83aa64d"
      },
      "downloads": -1,
      "filename": "phase_extender-0.1.8.tar.gz",
      "has_sig": false,
      "md5_digest": "0b5dd9afd2d6b38a90f56ec3bf5eaba5",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 60802,
      "upload_time": "2022-03-20T17:30:15",
      "upload_time_iso_8601": "2022-03-20T17:30:15.218924Z",
      "url": "https://files.pythonhosted.org/packages/ea/af/2d54975f7e3f1b55a274a4a13942b2bb71b92a212819dd74a126f28b9bbd/phase_extender-0.1.8.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}