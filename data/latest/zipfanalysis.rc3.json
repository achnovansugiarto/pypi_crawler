{
  "info": {
    "author": "Charlie Pilgrim",
    "author_email": "pilgrimcharlie2@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Text Processing :: Linguistic"
    ],
    "description": "============\nzipfanalysis\n============\n\nTools in python for analysing Zipf's law from text samples. \n\nThis can be installed as a package from the python3 package library using the terminal command:\n::\n\n\t>>> pip3 install zipfanalysis\n\n-----\nUsage\n-----\n\nThe package can be used from within python scripts to estimate Zipf exponents, assuming a simple power law model for \nword frequencies and ranks. To use the pacakge import it using\n::\n\n\timport zipfanalysis\n\n-------------\nSimple Method\n-------------\n\nThe easiest way to carry out an analysis on a book or text file, using different estimators, is:\n::\n\n\talpha_clauset = zipfanalysis.clauset(\"path_to_book.txt\")\n\n\talpha_pdf = zipfanalysis.ols_pdf(\"path_to_book.txt\", min_frequency=3)\n\n\talpha_cdf = zipfanalysis.ols_cdf(\"path_to_book.txt\", min_frequency=3)\n\n\talpha_abc = zipfanalysis.abc(\"path_to_book.txt\")\n\n---------------\nIn Depth Method\n---------------\n\nConvert a book or text file to the frequency of words, ranked from highest to lowest: \n::\n\n\tword_counts = zipfanalysis.preprocessing.preprocessing.get_rank_frequency_from_text(\"path_to_book.txt\")\n\t\n\nCarry out different types of analysis to fit a power law to the data:\n::\n\n\t# Clauset et al estimator\n\talpha_clauset = zipfanalysis.estimators.clauset.clauset_estimator(word_counts)\n\n\t# Ordinary Least Squares regression on log(rank) ~ log(frequency) \n\t# Optional low frequency cut-off\n\talpha_pdf = zipfanalysis.estimators.ols_regression_pdf.ols_regression_pdf_estimator(word_counts, min_frequency=2)\n\n\t# Ordinary least squares regression on the complemantary cumulative distribution function of ranks\n\t# OLS on log(P(R>rank)) ~ log(rank) \n\t# Optional low frequency cut-off \n\talpha_cdf = zipfanalysis.estimators.ols_regression_cdf.ols_regression_cdf_estimator(word_counts)\n\n\t# Approximate Bayesian computation (regression method)\n\t# Assumes model of p(rank) = C prob_rank^(-alpha)\n\t# prob_rank is a word's rank in an underlying probability distribution\n\talpha_abc = zipfanalysis.estimators.approximate_bayesian_computation.abc_estimator(word_counts)\n\n------------------------\nDevelopment - Next Steps\n------------------------\n\n1. Speed up abc. Current bottleneck is sampling from infinite power law. Could be sped up by considering we only need the frequency vector of ranks, not the whole sample. So for example could sample from unoform distribution then drop values into interger ranked buckets based on inverse CDF.\n\n2. Build in frequency rank analysis. Convert to frequency counts representation, then carry out fit on that. \n\n3. Add significance testing\n\n4. Add ability to calcaulte x_min and truncated power laws. \n\n5. Speed up OLS on the cdf",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/chasmani/zipfanalysis",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "zipfanalysis",
    "package_url": "https://pypi.org/project/zipfanalysis/",
    "platform": "",
    "project_url": "https://pypi.org/project/zipfanalysis/",
    "project_urls": {
      "Homepage": "https://github.com/chasmani/zipfanalysis"
    },
    "release_url": "https://pypi.org/project/zipfanalysis/0.5/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Tools for analysing Zipf's law from text samples",
    "version": "0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7944327,
  "releases": {
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0376709a5c8722b2465fce00d569342be05ed10ed809b608bac7294de0f4131c",
          "md5": "2b7a3e1983402b57582edc3bfaaad73d",
          "sha256": "bc08879be0cbac6f5990e4a796fd2b05bb3f1ab9f1a50df9b25823cb8ac1b914"
        },
        "downloads": -1,
        "filename": "zipfanalysis-0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2b7a3e1983402b57582edc3bfaaad73d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.9",
        "size": 17085,
        "upload_time": "2020-08-04T08:41:49",
        "upload_time_iso_8601": "2020-08-04T08:41:49.839480Z",
        "url": "https://files.pythonhosted.org/packages/03/76/709a5c8722b2465fce00d569342be05ed10ed809b608bac7294de0f4131c/zipfanalysis-0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fb3b627e36189b561bb1393c0603695f2b478f18cbb8f1b33eefe081ea1065e2",
          "md5": "e7dd0e70c2a9452f5eb99b7c81c9b3c6",
          "sha256": "35c60ec70059db26f71f334846653bcc0b040103eae64045251b7affae57a40c"
        },
        "downloads": -1,
        "filename": "zipfanalysis-0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "e7dd0e70c2a9452f5eb99b7c81c9b3c6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.9",
        "size": 8850,
        "upload_time": "2020-08-04T08:56:33",
        "upload_time_iso_8601": "2020-08-04T08:56:33.847973Z",
        "url": "https://files.pythonhosted.org/packages/fb/3b/627e36189b561bb1393c0603695f2b478f18cbb8f1b33eefe081ea1065e2/zipfanalysis-0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "608f793fe0b3ff2cc62684d58ac8fa32dba2e24a0ca7509a09988773b7f4656c",
          "md5": "60d3ad42687f886fb1480b21b20d4f51",
          "sha256": "632d7ee817a0730a4f4566dde60296dc15fc9fd56070e19be2bf8f253b846742"
        },
        "downloads": -1,
        "filename": "zipfanalysis-0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "60d3ad42687f886fb1480b21b20d4f51",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 9177,
        "upload_time": "2020-08-12T13:14:28",
        "upload_time_iso_8601": "2020-08-12T13:14:28.407147Z",
        "url": "https://files.pythonhosted.org/packages/60/8f/793fe0b3ff2cc62684d58ac8fa32dba2e24a0ca7509a09988773b7f4656c/zipfanalysis-0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "608f793fe0b3ff2cc62684d58ac8fa32dba2e24a0ca7509a09988773b7f4656c",
        "md5": "60d3ad42687f886fb1480b21b20d4f51",
        "sha256": "632d7ee817a0730a4f4566dde60296dc15fc9fd56070e19be2bf8f253b846742"
      },
      "downloads": -1,
      "filename": "zipfanalysis-0.5.tar.gz",
      "has_sig": false,
      "md5_digest": "60d3ad42687f886fb1480b21b20d4f51",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 9177,
      "upload_time": "2020-08-12T13:14:28",
      "upload_time_iso_8601": "2020-08-12T13:14:28.407147Z",
      "url": "https://files.pythonhosted.org/packages/60/8f/793fe0b3ff2cc62684d58ac8fa32dba2e24a0ca7509a09988773b7f4656c/zipfanalysis-0.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}