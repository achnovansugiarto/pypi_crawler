{
  "info": {
    "author": "T. Zoerner",
    "author_email": "tomzo@users.sourceforge.net",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",
      "Operating System :: POSIX :: BSD",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: C",
      "Programming Language :: Python :: 3",
      "Topic :: Multimedia :: Video :: Capture"
    ],
    "description": "=============================\nZVBI library interface module\n=============================\n\nThe Python \"ZVBI\" module provides an object-oriented interface to the\n`ZVBI library`_. The ZVBI library allows accessing television broadcast\ndata services such as teletext or closed captions via analog or DVB\nvideo capture devices.\n\nOfficial ZVBI library description:\n\n  The ZVBI library provides routines to access raw VBI sampling devices\n  (currently the Linux DVB & V4L2 API and the FreeBSD, OpenBSD,\n  NetBSD and BSDi bktr driver API are supported), a versatile raw VBI\n  bit slicer, decoders for various data services and basic search, render\n  and export functions for text pages. The library was written for the\n  Zapping TV viewer and Zapzilla Teletext browser.\n\nThe Python ZVBI module covers all exported libzvbi functions.\n\nThe Python interface module is largely based on objects which encapsulate\nthe native C structures of libzvbi. Only when a Python script actually\nwants to manipulate captured or decoded data directly (i.e. not via\nlibrary functions), the structures' data is converted into Python data\ntypes. Even then, Python methods such as the \"buffer protocol\" are used to\navoid unnecessary copying. This approach allows for a pretty snappy\nperformance despite the additional interface layer.\n\nBest starting point to get familiar with the module is having a look at\nthe `Class Hierarchy`_, description of the main classes, and the example\nscripts provided in the \"examples/\" sub-directory, which demonstrate use\nof all the main classes. (The examples are a more or less direct C to\nPython ports of the respective programs in the `test/` sub-directory of\nthe libzvbi source tree, plus a few additions, such as a teletext level\n2.5 browser implemented in apx.  300 lines of `TkInter`_.) A description of\nall example scripts can be found below in section `Examples`_.\nAdditionally you can look at the `ZVBI library home`_ and the ZVBI library\ndocumentation (unfortunately not available online; built via doxygen when\ncompiling the library).\n\nFinally note there is an equivalent\n`Video::ZVBI module for Perl`_ (also at `CPAN`_)\n\n.. _CPAN: https://metacpan.org/pod/Video::ZVBI\n.. _`Video::ZVBI module for Perl`: https://metacpan.org/pod/Video::ZVBI\n.. _ZVBI library home: http://zapping.sourceforge.net/ZVBI/index.html\n\nInstallation\n------------\n\nThe Python module works on all platforms supported by the ZVBI library,\nwhich are:\n\n* Linux\n* FreeBSD\n* NetBSD\n* OpenBSD\n\nPre-requisite to installation is a C compiler and (obviously) the\n`ZVBI library`_ (oldest supported version is 0.2.26) which in turn\nrequires the pthreads and PNG libraries.  Note there are no\ndependencies on other Python modules by the module itself. Some of\nthe provided example scripts however depend on `Tkinter`_.\n\n.. _ZVBI library: http://zapping.sourceforge.net/ZVBI/index.html\n.. _Tkinter: https://docs.python.org/3/library/tk.html\n\nThe following is a copy of the API documentation in file doc/ZVBI.rst\n\n\nSYNOPSIS\n========\n\n::\n\n  import Zvbi\n\n  cap = Zvbi.Capture(\"/dev/dvb/adapter0/demux0\", dvb_pid=104)\n\n  vtdec = Zvbi.ServiceDec()\n  vtdec.event_handler_register(Zvbi.VBI_EVENT_TTX_PAGE, pg_handler)\n\n  while True:\n      sliced_buffer = cap.pull_sliced(2000)\n      vtdec.decode(sliced_buffer)\n\n  def pg_handler(pgtype, ev, user_data=None):\n      with vtdec.fetch_vt_page(ev.pgno) as pg:\n          pg.get_page_text()\n          #...\n\n\nDESCRIPTION\n===========\n\nThis module provides a Python interface to **libzvbi**.\nThe ZVBI library allows accessing television broadcast data services such\nas teletext or closed captions via analog or DVB video capture devices.\n\nOfficial library description:\n\"The ZVBI library provides routines to access raw VBI sampling devices\n(currently the Linux DVB & V4L2 APIs and the FreeBSD, OpenBSD,\nNetBSD and BSDi bktr driver API are supported), a versatile raw VBI\nbit slicer, decoders for various data services and basic search, render\nand export functions for text pages. The library was written for the\nZapping TV viewer and Zapzilla Teletext browser.\"\n\nThe *Zvbi* Python module covers all exported libzvbi functions. Most of\nthe libary functions and parameters are exposed equivalently, with\nadaptions to render the interface *Pythonic*.\n\nNote: This manual page does not reproduce the full documentation provided\nby libzvbi by means of doxygen: While method and parameter descriptions\nare fully included, some data structures may not be not fully documented\nhere.  Hence when additional details are needed, it's recommended to look\nat libzvbi documentation, or directly at its source code.\n\nClass Hierarchy\n===============\n\nThe following is an overview how functionality provided by *libzvbi* is\nstructured into classes, and how the classes are connected:\n\n`Zvbi.Capture`_\n    This class allows receiving data through a video device. For\n    digital television transmissions (DVB) this mostly involves demultiplexing\n    of the data service sub-stream from the overall transmission stream.\n    For analog television transmission this involves capturing selected\n    lines within the Vertical Blanking Interval (VBI) and \"demodulating\"\n    the digitized wave form to raw data.\n`Zvbi.CaptureRawBuf`_ and `Zvbi.CaptureSlicedBuf`_\n    These are container classes, used for efficiently transferring data\n    generated by the *read* and *pull* methods of the *Capture* class,\n    usually to *decode* methods of classes *RawDec* or *ServiceDec*\n    respectively. Alternatively one can extract data from the buffers\n    for direct processing within a Python script.\n`Zvbi.RawDec`_\n    This class can optionally be used for manually processing raw data\n    (i.e.  direct output of the analog-to-digital conversion of the video\n    signal) optionally returned by the *Capture* class via *pull_raw()*\n    methods et.al. For most use-cases the processing (so-called \"slicing\")\n    done under control of the *Capture* class using *pull_sliced()* should\n    be sufficient, so this class is usually not needed. This class is not\n    applicable for DVB.\n`Zvbi.Proxy`_\n    This class allows accessing VBI devices via a proxy daemon. An\n    instance of this class would be provided to the *Capture* class\n    constructor.  Using the proxy instead of capturing directly from a VBI\n    device allows multiple applications to capture concurrently (e.g. for\n    decoding multiple data services). Not applicable to DVB, as the proxy\n    does not support DVB.  (Also at least the Linux DVB driver allows\n    multiple applications reading the same stream concurrently.)\n`Zvbi.ServiceDec`_\n    Class performing high level decoding of all supported services and\n    storing the data in an internal cache. The class takes input (\"sliced\n    data\") from the *Capture* class. The class supports callback functions\n    for notifications about received data; various interfaces allow\n    extracting the data in form of instances of the *Page* class, or as an\n    image in PPM or XPM formats.\n`Zvbi.Search`_\n    This class allows searching the cache maintained by *ServiceDec* for\n    pages with text matching a pattern. The search returns instances of\n    class *Page*.\n`Zvbi.Page`_\n    Instances of this class are produced by the *ServiceDec* query\n    functions or *Search*. Each instance represents a teletext (sub-)page\n    or Closed Caption page. The class has various interfaces for\n    extracting the text and properties of the page content.\n`Zvbi.Export`_\n    This class allows rendering an instance of *Page* in specific formats,\n    for example as plain-text or image in various formats such as PNG or\n    PPM. The result can be returned within a Python string or a *bytes*\n    object respectively, or written directly to a file.\n\nIn summary: For receiving live data, you'll need at least an instance of\nthe *Capture* class. Your application is responsible for calling the\ncapture interface at 25 or 30 Hz intervals (ideally using a separate\nthread that blocks on the capture function, or else using async I/O via\nselect/poll or polling via a timer). For standard services such as\nTeletext, Closed Caption, WSS or network identification you'll need to\nfeed the captured data into an instance of the *ServiceDec* class, which\nthen drives further processing via callback notifications.  For other\nservices you may use the de-multiplexers listed below, or process the data\nwithin your application directly. After that it depends on your\napplication which interfaces/classes you want to use for further\nprocessing of decoded data.\n\nSpecial-purpose classes for DVB:\n\n`Zvbi.DvbDemux`_\n    Class performing de-multiplexing of a transport stream received from a\n    DVB driver, i.e. separating \"VBI\" data from a DVB PES stream (EN 301\n    472, EN 301 775). Note this class is used internally by the\n    *Zvbi.Capture* class for de-multiplexing. You should only use this\n    class directly when the data does not originate from a local device.\n`Zvbi.DvbMux`_\n    This class converts sliced and optionally raw VBI data to a DVB\n    Packetized Elementary Stream or Transport Stream as defined in EN 300\n    472 \"Digital Video Broadcasting (DVB); Specification for conveying\n    ITU-R System B Teletext in DVB bit-streams\" and EN 301 775 \"Digital\n    Video Broadcasting (DVB); Specification for the carriage of Vertical\n    Blanking Information (VBI) data in DVB bit-streams\".\n\nThe following classes are for de-multiplexing data services transmitted\nwithin teletext packets. For PFC and IDL, libzvbi only supports the\nprotocol, but the application has to decode and store payload data. XDS is\nsupported by `Zvbi.ServiceDec`_ (decoding and event notifications). Most\nlikely none of these protocols are used anymore, as they were intended for\nuse via analog television broadcast:\n\n`Zvbi.IdlDemux`_\n    This class allows decoding data transmissions within a Teletext\n    packet stream using *Independent Data Line* protocol (EN 300 708 section 6),\n    i.e. data transmissions based on packet 8/30.\n`Zvbi.PfcDemux`_\n    Class for separating data transmitted in *Page Function Clear* teletext\n    packets (ETS 300 708 section 4), i.e. using regular packets on a dedicated\n    teletext page. Historically this protocol was used for *Nextview EPG*,\n    (i.e. an Electronic Programming Guide for analog television).\n`Zvbi.XdsDemux`_\n    Class for separating *Extended Data Service* from a Closed Caption stream\n    (EIA 608). This service allows to transmit \"now & next\" EPG data in\n    addition to sub-titles.\n\n.. _Zvbi.Capture:\n\nClass Zvbi.Capture\n==================\n\nThis class is used for opening a DVB or analog \"VBI\" device and start\nreceiving data from it.  The class does not support tuning of a channel.\n\nSince parameters for capturing from DVB have little overlap with tose for\nanalog devices, there isn't a single constructor. Instead there are two\nstatic methods which construct an instance. The class cannot be\ninstantiated directly. Nevertheless, the capture instances created by the\nfactory functions can be used equivalently for all other class methods.\n\nAfter creating an instance, one of the *read* or *pull* methods (see below\nfor hints which one to use) have to be called periodically for retrieving\nthe data.  Usually this is done within a quasi-infinite \"while\" loop\n(possibly in a separate thread), but most devices will support \"select()\"\nand thus allow asynchronous I/O via event handlers. If everything else\nfails, you can also use polling in fixed intervals slightly lower than the\n(interlaced) video frame rate (e.g. 2*30 Hz for NTSC, 2*25 Hz for PAL)\n\nUpon failure, the constructor and all member functions raise exception\n*Zvbi.CaptureError*, containing a string describing the cause. (Additional\nexception types may be used for specific error cases.)\n\nThe capture device is automatically closed when the *Zvbi.Capture* object\nis destroyed.\n\nThere are two different types of capture functions: The functions named\n*read* copy captured data into a bytes object (where the copying is\nusually done at device driver level). In contrast the functions named\n*pull* leave the data in internal buffers inside the capture context\nand just return a reference to this buffer. Usually this allows the device\ndriver to avoid any copying, however not all devices support this (e.g.\nthe Linux DVB driver does not support, i.e. there is no difference in\nperformance between *read* and *pull*). Therefore you generally should\nprefer use of the *pull* functions; only when capturing raw data for\nprocessing by Python directly, prefer *read_raw()* as the data needs\nto be copied into a permanent buffer anyway.\n\nIf you do not need \"raw\" data (i.e. if you do not use the `Zvbi.RawDec`_\nclass, you should use *pull_sliced()* or *read_sliced()* instead of\n*pull()* or *read()* to avoid the overhead of returning raw data (which\nhas high bandwidth). DVB devices will not return raw data regardless of\nthe chosen interface.\n\n**Multithreading**: The `Zvbi.Capture`_, `Zvbi.RawDec`_,\n`Zvbi.ServiceDec`_ and `Zvbi.Search`_ classes are thread-safe insofar as\nthey allow running the capture loop (including raw decoder) and service\ndecoder in one thread, and further event processing or a user-interface in\nanother thread. The latter may interact with the capture/decoder thread\nvia configuration and query interfaces.\nSee `examples/search-ttx.py` for an example using multi-threading.\n\n\nZvbi.Capture.Dvb()\n------------------\n\nThis *static* method creates and returns an instance of *Zvbi.Capture* for\nDVB devices. ::\n\n   cap = Zvbi.Capture.Dvb(dev, dvb_pid=0, trace=False)\n\nInput parameters:\n\n:dev:\n    Path of the device to open (for Linux usually\n    `/dev/dvb/adapter0/demux0`)\n:dvb_pid:\n    Specifies the number (PID) of a stream which contains VBI data, when\n    the device is a DVB capture card. Else the parameter has no effect.\n    If you omit this value, you need to configure it afterwards using\n    `Zvbi.Capture.dvb_filter()`_, otherwise there will be no reception.\n:trace:\n    If this option is present and *True*, output of progress messages on\n    `sys.stderr` is enabled.\n\nNote the VBI PID value can often be derived from the PID for video in\n`channels.conf` by adding offsets in range 3 to 30. Alternatively you can\nlook up the PID via Internet services such as <https://www.satindex.de/>.\n\nZvbi.Capture.Analog()\n---------------------\n\nThis *static* method creates and returns an instance of *Zvbi.Capture* for\nanalog VBI devices (i.e. non-DVB devices).  The method \"auto-detects\" the\ntype of the given device by sequentially trying to access the device as\n\"V4l2\" (i.e. analog Linux video capture device) and \"bktr\" (i.e.  FreeBSD\nanalog BSD video capture device), in this order.\n\n::\n\n   cap = Zvbi.Capture.Analog(dev, services, proxy=None,\n                             strict=0, buffers=5, scanning=0, trace=False)\n\nThe device and service parameters are mandatory, all others are optional and\nkeyword-only. The parameters have the following meaning:\n\n:dev:\n    Path of the device to open (for Linux usually `/dev/vbi0`)\n:services:\n    Is a bit-wise OR of `VBI_SLICED_*` symbols describing the data\n    services to be decoded.  See `Zvbi.RawDec.add_services()`_ for\n    details.  If you want to capture raw data only, set to\n    `VBI_SLICED_VBI_525`, `VBI_SLICED_VBI_625` or both.  If this parameter\n    is omitted, no services will be installed (this is not supported for\n    BSD \"bktr\" drivers).  You can do so later with\n    *Zvbi.Capture.update_services()* (Note in this case the *reset*\n    parameter to that function will have to be set to True.).\n:proxy:\n    When present, this has to be a reference to an instance of class\n    `Zvbi.Proxy`_. The constructor will request start of capturing via the\n    VBI proxy daemon instead of accessing the device directly. The\n    following parameters are still applicable, but are passed to the\n    daemon. The proxy does not support DVB devices. If the connection\n    fails, the constructor will not attempt direct device access; this\n    means the call shuld be repeated without the proxy parameter.\n:buffers:\n    Number of device buffers for raw VBI data if the driver supports\n    streaming. Use higher values if you cannot guarantee there is no\n    latency on reading capture data (e.g. if your GUI runs in the same\n    thread). Otherwise one bounce buffer is allocated for\n    *Zvbi.Capture.pull()*.\n:scanning:\n    Indicates the current norm: 625 for PAL and 525 for NTSC; set to 0 if\n    you don't know (you should not attempt to query the device for the\n    norm, as this parameter is only used for the ancient BSD \"bktr\" driver\n    which don't support video standard query ioctls.)\n:strict:\n    The value can be 0, 1, or 2 for determining which services to allow\n    for raw decoding. For details see `Zvbi.RawDec.add_services()`_.\n:trace:\n    If True, enables output of progress messages on `sys.stderr`.\n\nWhenever possible, the proxy should be used instead of opening analog\ndevices directly, since it allows the user to start multiple VBI clients\nconcurrently. When this function fails (usually because the user hasn't\nstarted the proxy daemon) applications should automatically fall back to\nopening the device directly.\n\nExample for using an analog source with auto-detection of a proxy: ::\n\n    opt_device = \"/dev/vbi0\"\n    opt_services = Zvbi.VBI_SLICED_TELETEXT_B\n    opt_strict = 0\n    opt_buf_count = 5\n    opt_verbose = False\n    try:\n        proxy = Zvbi.Proxy(opt_device, appname=\"...\", appflags=0, trace=opt_verbose)\n\n        cap = Zvbi.Capture.Analog(opt_device, proxy=proxy,\n                                  services=opt_services, strict=opt_strict,\n                                  buffers=opt_buf_count, trace=opt_verbose)\n    except Zvbi.ProxyError, Zvbi.CaptureError:\n        # try again without proxy\n        cap = Zvbi.Capture.Analog(opt_device,\n                                  services=opt_services, strict=opt_strict,\n                                  buffers=opt_buf_count, trace=opt_verbose)\n\nThe first call of Zvbi.Capture() in the example establishes a new\nconnection to a VBI proxy to open a VBI or DVB device for capturing.  On\nside of the proxy daemon, the given device is opened and initialized,\nequivalently as it would be done locally.  If the creation succeeds, and\nany of the requested services are available, capturing is started and all\ncaptured data is forwarded transparently to the client. See\n`Zvbi.Proxy`_ for details.\n\nThe second call of Zvbi.Capture.Analog() in the example creates a local\ncapture context.\n\nZvbi.Capture.read_raw()\n-----------------------\n\n::\n\n    raw_buffer = cap.read_raw(timeout_ms)\n\nRead a raw VBI frame from the capture device and return it within an\nobject of type `Zvbi.CaptureRawBuf`_. Please refer to the descripion of\nthat class for details.\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.  Note the function may fail\nif the device does not support reading data in raw format.\n\nNote: it's generally more efficient to use *pull_raw()* instead, as\nthat may avoid having copying data into the new buffer allocated\nfor each call of *read_raw()*. See also the description of *read()* below.\n\nZvbi.Capture.read_sliced()\n--------------------------\n\n::\n\n    sliced_buffer = cap.read_sliced(timeout_ms)\n\nCaptures VBI data from one video frame, \"slices\" the captured data samples\nfor VBI lines of previously configured services, and returns the sliced data\nwithin an object of type `Zvbi.CaptureSlicedBuf`_. Please refer to the\ndescripion of that class for details.\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.\n\nZvbi.Capture.read()\n-------------------\n\n::\n\n    raw_buffer, sliced_buffer = cap.read(timeout_ms)\n\nThis function is a combination of *read_raw()* and *read_sliced()*, i.e.\nreads a VBI frame from the capture context and returns both the raw data\nand the results of \"slicing\" the raw data. The results are returned in\nform of a tuple which contains firstly `Zvbi.CaptureRawBuf`_ and secondly\nan object of type `Zvbi.CaptureSlicedBuf`_. Please refer to the descripion\nof these classes for details.\n\nSome devices, such as DVB, may not support capturing raw VBI data. In such\na case the first element of the result tuple is set to *None*.\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.\n\n**Note**: Depending on the driver, captured raw data may have to be copied\nfrom the capture buffer into the given buffer (e.g. for V4L2 streams which\nuse memory-mapped buffers.)  It's generally more efficient using one of\nthe following *pull* interfaces. Also, unless you require raw data, it is\neven more efficient using *pull_sliced()* or *read_sliced()*.\n\nZvbi.Capture.pull_raw()\n-----------------------\n\n::\n\n    raw_buffer = cap.pull_raw(timeout_ms)\n\nRead a raw VBI frame from the capture context and return it within an\nobject of type `Zvbi.CaptureRawBuf`_. Please refer to the descripion of\nthat class for details.  **Note**: The content of the returned object\nremains valid only until the next call to this or any other *pull*\nfunction. Access to an invalidated buffer will raise exception\n*ValueError*\n\nThe returned *raw_buffer* can be passed to `Zvbi.RawDec.decode()`_.  If you\nneed to process the data by Python code, use `Zvbi.Capture.read_raw()`_\ninstead.\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.  Note the function may fail\nif the device does not support reading data in raw format.\n\n\nZvbi.Capture.pull_sliced()\n--------------------------\n\n::\n\n    sliced_buffer = cap.pull_sliced(timeout_ms)\n\nCaptures VBI data from one video frame, \"slices\" the captured data samples\nfor VBI lines of previously configured services, and returns the sliced data\nwithin an object of type `Zvbi.CaptureSlicedBuf`_. Please refer to the\ndescripion of that class for details.  **Note**: The content of the\nreturned object remains valid only until the next call to this or any\nother capture function.  Access to an invalidated buffer will raise\nexception *ValueError*\n\nUsually the returned *sliced_buffer* is passed immediately\n`Zvbi.ServiceDec.decode()`_.\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.\n\nZvbi.Capture.pull()\n-------------------\n\n::\n\n    raw_buffer, sliced_buffer = cap.pull(timeout_ms)\n\nThis function is a combination of *pull_raw()* and *pull_sliced()*, i.e.\nreads a VBI frame from the capture context and returns both the raw data\nand the results of \"slicing\" the raw data.  The results are returned in\nform of a tuple which contains firstly `Zvbi.CaptureRawBuf`_ and secondly\nan object of type `Zvbi.CaptureSlicedBuf`_. Please refer to the descripion\nof these classes for details.\n\nSome devices, such as DVB, may not support capturing raw VBI data. In such\na case the first element of the result tuple is set to *None*.\n\n**Note**: The content of the returned objects remains valid only until the\nnext call to this or any other *pull* function. Access to an invalidated\nbuffer will raise exception *ValueError*\n\nParameter *timeout_ms* gives the limit for waiting for data in\nmilliseconds; if no data arrives within the given time, the function\nraises exception *Zvbi.CaptureTimeout*.  Exception *Zvbi.CaptureError* is\nraised upon error indications from the device.\n\nZvbi.Capture.parameters()\n-------------------------\n\n::\n\n    params = cap.parameters()\n\nReturns an instance of class `Zvbi.RawParams`_ describing the physical\nparameters of the VBI source. See the description of that class for a\ndescription of attributes.\n\nModifying the attributes of the returned object has no effect on the\n`Zvbi.Capture`_ instance. To control raw decoding, pass the returned (and\npossibly modified) parameters when instantiating class `Zvbi.RawDec`_ and\nthen use that class for decoding instead of the *sliced_buffer* output of\nthe `Zvbi.Capture`_ member functions.\n\n**Note**: For DVB devices this function only returns dummy parameters, as\nno \"raw decoding\" is performed in this case. In particular the sampling\nformat will be zero, which is an invalid value, so this can be used for\ndetecting this case.\n\n\nZvbi.Capture.update_services()\n------------------------------\n\n::\n\n    services = cap.update_services(services, reset=True, commit=True, strict=0)\n\nNot applicable to DVB:\nAdds and/or removes one or more services to an already initialized capture\ncontext.  Can be used to dynamically change the set of active services.\n\nInternally the function will restart parameter negotiation with the\nVBI device driver and then call *add_services()* on the internal raw\ndecoder context.  You may set *reset* to rebuild your service mask from\nscratch.  Note that the number of VBI lines may change with this call\neven if the function fails and raises an exception.\n\nResult: The function returns a bit-mask of supported services among those\nrequested (not including previously added services), 0 upon errors.\n\n:services:\n    An integer consisting of a bit-wise OR of one or more `VBI_SLICED_*`\n    constants describing the data services to be decoded.\n\n:reset:\n    When this optional parameter is set *True*, the method clears all\n    previous services before adding new ones (by invoking\n    `Zvbi.RawDec.reset()`_ at the appropriate time.) When *False*, new\n    services are in addition to previously configured services.\n\n:commit:\n    When this optional parameter is set True, the method applies all\n    previously added services to the device. Set this to *False* when\n    doing multiple consecutive calls of this function; then commit should\n    be set only for the last call.\n    Reading data cannot continue before changes were committed (because\n    capturing has to be suspended to allow resizing the VBI image.)  Note\n    this flag is ignored when using the VBI proxy.\n\n:strict:\n    The meaning of this optional parameter is as described for\n    `Zvbi.RawDec.add_services()`_, as that function is used internally by\n    libzvbi. The parameter defaults to 0.\n\nThe function returns an integer value with bit-wise OR of `VBI_SLICED_*`\nservices actually decodable.\n\nZvbi.Capture.fd()\n-----------------\n\n::\n\n    cap.fd()\n\nThis function returns the file descriptor used to read from the\ncapture context's device.  Note when using the proxy this will not\nbe the actual device, but a socket instead.  Some devices may also\nreturn -1 if they don't have anything similar, or upon internal errors.\n\nThis function is equivalent to `fileno()` for Pythone file objects.\n\nThe descriptor is intended be used in a *select(2)* syscall. The\napplication especially must not read or write from it and must never\nclose the handle (instead destroy the capture context to free the\ndevice.) In other words, the file handle is intended to allow capturing\nasynchronously in the background; The handle will become readable\nwhen new data is available.\n\nZvbi.Capture.get_scanning()\n---------------------------\n\n::\n\n    scanning = cap.get_scanning()\n\nThis function is intended to allow the application to check for\nasynchronous norm changes, i.e. by a different application using the\nsame device.  The function queries the capture device for the current\nnorm and returns value 625 for PAL/SECAM norms, 525 for NTSC;\n0 if unknown, -1 on error.\n\nZvbi.Capture.flush()\n--------------------\n\n::\n\n    cap.flush()\n\nAfter a channel change this function should be used to discard all\nVBI data in intermediate buffers which may still originate from the\nprevious TV channel. The function returns `None`.\n\nZvbi.Capture.get_fd_flags()\n---------------------------\n\n::\n\n    flags = cap.get_fd_flags()\n\nReturns properties of the capture context's device. The result is an\ninteger value containing a bit-wise OR of one or more of the following\nconstants:\n\nVBI_FD_HAS_SELECT:\n    Is set when *select(2)* can be used on the file handle returned by\n    *cap.fd()* to wait for new data on the capture device file handle.\n\nVBI_FD_HAS_MMAP:\n    Is set when the capture device supports \"user-space DMA\".  In this case\n    it's more efficient to use one of the \"pull\" functions to read raw data\n    because otherwise the data has to be copied once more into the passed buffer.\n\nVBI_FD_IS_DEVICE:\n    Is not set when the capture device file handle is not the actual device.\n    In this case it can only be used for select(2) and not for ioctl(2)\n\nZvbi.Capture.dvb_filter()\n-------------------------\n\n::\n\n    cap.dvb_filter(pid)\n\nPrograms the DVB device transport stream demultiplexer to filter\nout PES packets with the given *pid*. The meaning of the parameter is\nequivalent to the *pid* parameter to the constructor.\n\nZvbi.Capture.dvb_last_pts()\n---------------------------\n\n::\n\n    cap.dvb_last_pts()\n\nReturns the presentation time stamp (33 bits) associated with the data\nlast read from the capture context. The PTS refers to the first sliced\nVBI line, not the last packet containing data of that frame.\n\nNote timestamps returned by VBI capture read functions contain\nthe sampling time of the data, that is the time at which the\npacket containing the first sliced line arrived.\n\n.. _Zvbi.CaptureRawBuf:\n\nClass Zvbi.CaptureRawBuf\n========================\n\nFor reasons of efficiency, captured data is not immediately converted into\nPython structures. Instead class `Zvbi.Capture`_ returns an instance of this\nclass for raw data, which encapsulates both the data and related\nattributes.\n\nUsually this object is simply forwarded to `Zvbi.RawDec.decode()`_; in\nthis case there is very little overhead for managing the object by Python.\nIf you want to process the data directly within Python, you can access it\nin the following ways:\n\n1. Subscripting the object allows retrieving the data byte-by-byte. The\n   standard *len* operator indicates the number of bytes in the buffer.\n   Example: ::\n\n    raw_buf = cap.read_raw(2000)\n    for x in range(0, par.bytes_per_line):\n        y = raw_buf[x]\n\n2. In any context that expects a bytes-like object, the data content is\n   accessed efficiently via direct access at C level. Example: ::\n\n    raw_buf = cap.read_raw(2000)\n    arr = bytes(raw_buf)\n\n3. The timestamp can be retrieved via attribute *timestamp*. The value\n   indicates when the data was captured in form of the number of seconds\n   and fractions since 1970-01-01 00:00; the value is of type *float*.\n\nNote the raw buffer contains all captured VBI lines consecutively in a\none-dimensional array. Length of a line can be queried from the capture\ncontext using `Zvbi.Capture.parameters()`_: attribute *bytes_per_line*.\n\nNote class *Zvbi.CaptureRawBuf* internally uses different memory\nmanagement depending on use of *read* or *pull* capturing methods. This\ndifference is not visible at the interface. **However** data retrieved by\n*pull* interfaces is valid only until the next call of a capture function\non the same object.\n\n\n.. _Zvbi.CaptureSlicedBuf:\n\nClass Zvbi.CaptureSlicedBuf\n===========================\n\nFor reasons of efficiency, captured data is not immediately converted into\nPython structures. Instead class `Zvbi.Capture`_ returns an instance of this\nclass for sliced data, which encapsulates data of all sliced lines and\nrelated attributes.\n\nUsually this object is simply forwarded to `Zvbi.ServiceDec.decode()`_; in\nthis case there is very little overhead for managing the object by Python.\nIf you want to process the data directly within Python, you can access it\nin the following ways:\n\n1. Subscripting the object allows retrieving sliced lines one-by-one.\n   The standard *len* operator indicates the number of bytes in the buffer.\n\n2. In any context that expects an iterator, the function delivered sliced\n   lines consecutively.\n\n3. The timestamp can be retrieved via attribute *timestamp*. The value\n   indicates when the data was captured in form of the number of seconds\n   and fractions since 1970-01-01 00:00; the value is of type *float*.\n\nExample:\n\n::\n\n    sliced_buffer = cap.pull(2000)\n    for data, ident, line_no in sliced_buffer:\n        ...\n\nIteration returns for each sliced line a named tuple of type\n*Zvbi.CaptureSlicedLine*, holding the following three elements:\n\n0. *data*: Sliced data from the respective line in the sliced buffer. The\n   structure of the contained data depends on the kind of data in the VBI\n   line as identified by the following attribute. (For example, for\n   *VBI_SLICED_TELETEXT_B* 42 bytes are used; first two bytes contain\n   Hamming-8/4 encoded magazine and packet number, which determine the\n   encoding and semantics of the rest of the data.)\n\n1. *ident*: One or more 'VBI_SLICED_*' symbols (bit-wise OR), identifying\n   the type of data service. Multiple identifiers may occur e.g. for\n   *VBI_SLICED_TELETEXT_B*.\n\n2. *line_no*: Source line number according to the ITU-R line numbering\n   scheme, or 0 if the exact line number is unknown. This number is\n   required by the service decoder.\n\nNote class *Zvbi.CaptureSlicedBuf* internally uses different memory\nmanagement depending on use of *read* or *pull* capturing methods. This\ndifference is not visible at the interface. **However** data retrieved by\n*pull* interfaces is valid only until the next call of a capture function\non the same object.\n\n\n.. _Zvbi.RawDec:\n\nClass Zvbi.RawDec\n=================\n\nThe functions in this section allow converting raw VBI samples (i.e. a\ndigitized image of the transmitted analog waveform) to payload data bytes.\nThis class is not applicable to DVB.\n\nThese functions are used internally by libzvbi if you use the slicer\nfunctions of the capture object (e.g. *pull_sliced()*). This class\nis useful only when capturing raw data only (e.g. *pull_raw()*),\nallowing your application to take full control of slicing raw data.\n\nAfter instantiating and configuring the class, the actual work is done by\n`Zvbi.RawDec.decode()`_, which you'd call on the data of each captured VBI\nframe.\n\nExample control flow: ::\n\n    cap = Zvbi.Capture(\"/dev/vbi0\", services=VBI_SLICED_CAPTION_525)\n\n    vtdec = Zvbi.ServiceDec()\n    vtdec.event_handler_register(Zvbi.VBI_EVENT_TTX_PAGE, pg_handler)\n\n    raw_dec = Zvbi.RawDec(cap)\n    raw_dec.add_services(opt_services, opt_strict)\n\n    while True:\n        raw_buffer = cap.pull_raw(opt_timeout)\n\n        sliced_buffer = raw_dec.decode(raw_buffer)\n\n        vtdec.decode(sliced_buffer)\n\n\nConstructor Zvbi.RawDec()\n-------------------------\n\n::\n\n    raw_dec = Zvbi.RawDec(ref)\n\nCreates and initializes a new raw decoder context. Parameter *ref*\nspecifies the physical parameters of the raw VBI image, such as the\nsampling rate, number of VBI lines etc.  The parameter can be either\na reference to a capture context (`Zvbi.Capture`_)\nor raw capture parameters of type `Zvbi.RawParams`_.\n\nA properly initialized instance of *Zvbi.RawParams* can be obtained either\nvia method `Zvbi.Capture.parameters()`_ or `Zvbi.RawDec.parameters()`_.\nIn case an instance of `Zvbi.Capture`_ is used as parameter to the\nconstructor, decoder parameters are retrieved internally using\n`Zvbi.Capture.parameters()` for convenience.\n\nSee description of class `Zvbi.RawParams`_ for a list of sampling\nparameters.\n\nZvbi.RawDec.parameters()\n------------------------\n\n::\n\n    services, max_rate, par = Zvbi.RawDec.parameters(services, scanning)\n\nThis is a **static** member function. The function calculates the sampling\nparameters required to receive and decode the requested data services.\nThis function can be used to initialize hardware parameters prior to\ncalling `Zvbi.RawDec.add_services()`_.  The returned sampling format is fixed to\n`VBI_PIXFMT_YUV420`, and attribute *bytes_per_line* is set to a reasonable\nminimum.\n\nInput parameters:\n\n:services:\n    This integer value contains a bit-wise OR of `VBI_SLICED_*` constants.\n    Here (and only here) you can add `VBI_SLICED_VBI_625` or\n    `VBI_SLICED_VBI_525` to include all VBI scan lines in the calculated\n    sampling parameters.\n:scanning:\n    If *scanning* is set to 525 only NTSC services are accepted; if set to\n    625 only PAL/SECAM services are accepted. When scanning is 0, the norm\n    is determined from the requested services; an ambiguous set will\n    result in undefined behavior.\n\nThe function returns a tuple containing the following three results:\n\n0. An integer value containing a bit-wise OR of a sub-set of\n   `VBI_SLICED_*` constants describing the data services covered by the\n   calculated sampling parameters returned in *href*. This excludes services\n   the libzvbi raw decoder cannot decode assuming the specified physical\n   parameters.\n\n1. Calculated maximum rate, which is to the highest data bit rate\n   in **Hz** of all services requested (The sampling rate should be at least\n   twice as high; attribute `sampling_rate` will be set by libzvbi to a more\n   reasonable value of 27 MHz derived from ITU-R Rec. 601.)\n\n2. An instance of class `Zvbi.RawParams`_ which contains the calculated\n   sampling parameters. The content is described as for function\n   `Zvbi.Capture.parameters()`_\n\nZvbi.RawDec.reset()\n-------------------\n\n::\n\n    raw_dec.reset()\n\nResets the raw decoder context. This removes all previously added services\nto be decoded (if any) but does not touch the sampling parameters. You\nare free to change the sampling parameters after calling this.\n\nZvbi.RawDec.add_services()\n--------------------------\n\n::\n\n    services = raw_dec.add_services(services, strict)\n\nAfter you initialized the sampling parameters in raw decoder context\n(according to the abilities of your VBI device), this function adds one\nor more data services to be decoded. The libzvbi raw VBI decoder can\ndecode up to eight data services in parallel. You can call this function\nwhile already decoding, it does not change sampling parameters and you\nmust not change them either after calling this.\n\nInput parameters:\n\n:services:\n    This integer value contains a bit-wise OR of `VBI_SLICED_*` constants.\n    (see also description of the *parameters* function above.)\n\n:strict:\n    The parameter can be set to 0, 1 or 2 for requesting requests loose,\n    reliable or strict matching of sampling parameters respectively. For\n    example if the data service requires knowledge of line numbers while\n    they are not known, value 0 will accept the service (which may work if\n    the scan lines are populated in a non-confusing way) but values 1 or 2\n    will not. If the data service may use more lines than are sampled,\n    value 1 will still accept but value 2 will not. If unsure, set to 1.\n\nThe function returns an integer value containing a bit-wise OR of\n`VBI_SLICED_*` constants describing the data services that actually can be\ndecoded. This excludes those services not decodable given sampling\nparameters of the raw decoder context.\n\nZvbi.RawDec.check_services()\n----------------------------\n\n::\n\n    services = raw_dec.check_services(services, strict=0)\n\nCheck and return which of the given services can be decoded with\ncurrent physical parameters at a given strictness level.\n\nSee `Zvbi.RawDec.add_services()`_ for details on parameter semantics.\n\nZvbi.RawDec.remove_services()\n-----------------------------\n\n::\n\n    services = raw_dec.remove_services(services)\n\nRemoves one or more data services given in input parameter *services*\nto be decoded from the raw decoder context.  This function can be called\nat any time and does not touch sampling parameters stored in the context.\n\nReturns a set of `VBI_SLICED_*` constants describing the remaining\ndata services that will be decoded.\n\nZvbi.RawDec.resize()\n--------------------\n\n::\n\n    raw_dec.resize(start_a, count_a, start_b, count_b)\n\nGrows or shrinks the internal state arrays for VBI geometry changes.\nReturns `None`.\n\nZvbi.RawDec.decode()\n--------------------\n\n::\n\n    sliced_buffer = raw_dec.decode(raw_buffer)\n\nThis is the main service offered by the raw decoder: Decodes a raw VBI\nimage given in *raw_buffer*, consisting of several scan lines of raw VBI\ndata. The output is sorted by line number.\n\nThe input parameter *raw_buffer* can by any bytes-like object that\ncontains at least the number of bytes required by the capture geometry\n(which is `par.bytes_per_line * (par.count_a + par.count_b)`, where *par*\nis the used instance of *Zvbi.RawParams*). Usually the parameter is\nan object of type `Zvbi.CaptureRawBuf`_ as returned by the *pull* kind of\n`Zvbi.Capture`_ methods (e.g.  `Zvbi.Capture.pull_raw()`_).\n\nReturn value is a buffer of type `Zvbi.CaptureSlicedBuf`_, containing the\nsliced output data. (Please refer to the descripion of that class for\ndetails.) Upon errors the function raises exception *Zvbi.RawDecError*.\n\nUsually the sliced buffer result is forwarded to `Zvbi.ServiceDec.decode()`_.\n(See general description `Zvbi.RawDec`_ for an example control flow.)\nNote in that case the buffer needs to be forwarded even if zero lines were\nsliced; refer to description of the method for details.\n\nNote this function attempts to learn which lines carry which data service,\nor none, to speed up decoding. Hence you must use different raw decoder\ncontexts for different devices.\n\n\n.. _Zvbi.RawParams:\n\nClass Zvbi.RawParams\n====================\n\nThis is a simple parameter container, encapsulating parameters of raw\ncaptured data (i.e. *raw_buffer* result produced by methods\n*Zvbi.Capture.read_raw()* et.al.), or for instantiating a raw decoder\nof class `Zvbi.RawDec`_.\n\nThe class has the following attributes:\n\nscanning:\n    Either 525 (M/NTSC, M/PAL) or 625 (PAL, SECAM), describing the scan\n    line system all line numbers refer to.\n\nsampling_format:\n    Format of the raw VBI data (one of the `VBI_PIXFMT_*` constants,\n    e.g. `VBI_PIXFMT_YUV420`; see enum *vbi_pixfmt*)\n\nsampling_rate:\n    Sampling rate in Hz (i.e. the number of samples or pixels captured\n    per second.)\n\nbytes_per_line:\n    Number of samples or pixels captured per scan line, in bytes. This\n    determines the raw VBI image width and you want it large enough to\n    cover all data transmitted in the line (with headroom).\n\noffset:\n    The distance from 0H (leading edge hsync, half amplitude point) to\n    the first sample (pixel) captured, in samples (pixels). You want an\n    offset small enough not to miss the start of the data transmitted.\n\nstart_a, start_b:\n    First scan line to be captured in the first and second half-frame\n    respectively. Numbering is according to the ITU-R line numbering\n    scheme (see *vbi_sliced*). Set to zero if the exact line number isn't\n    known.\n\ncount_a, count_b:\n    Number of scan lines captured in the first and second half-frame\n    respectively.  This can be zero if only data from one field is\n    required. The sum `count_a + count_b` determines the raw VBI image\n    height.\n\ninterlaced:\n    In the raw vbi image, normally all lines of the second field are\n    supposed to follow all lines of the first field. When this flag is\n    set, the scan lines of first and second field will be interleaved in\n    memory. This implies count_a and count_b are equal.\n\nsynchronous:\n    Fields must be stored in temporal order, i. e. as the lines have been\n    captured. It is assumed that the first field is also stored first in\n    memory, however if the hardware cannot reliable distinguish fields this\n    flag shall be cleared, which disables decoding of data services\n    depending on the field number.\n\n\n\n.. _Zvbi.Proxy:\n\nClass Zvbi.Proxy\n================\n\nThis class is used for receiving sliced or raw data from a VBI proxy daemon.\nUsing the daemon instead of capturing directly from a VBI device allows\nmultiple applications to capture concurrently, e.g. to decode multiple data\nservices.\n\nNote the proxy is only useful if all VBI applications use it. For\napplications that do not support the proxy directly, there is a library\nthat can overload calls to C library, so that access to the VBI device is\nredirected transparently through the daemon. Details are described in the\nmanual *zvbi-chains(1)*. In principle it's as easy as as prepending\n`zvbi-chains -dev /dev/vbi0` to the application command line.\n\nSee `examples/proxy-test.py` for examples how to use these functions.\n\nConstructor Zvbi.Proxy\n----------------------\n\n::\n\n    proxy = Zvbi.Proxy(dev, appname, appflags=0, trace=False)\n\n    cap = Zvbi.Capture( ..., proxy=proxy )\n\nCreates and returns a new proxy context, or raises exception *Zvbi.ProxyError*\nupon error.  (Note in reality this call will always succeed, since a connection\nto the proxy daemon isn't established until you actually open a capture context\nwhen instantiating `Zvbi.Capture`_ with a reference to `Zvbi.Proxy`_.)\n\nParameters:\n\n:dev:\n    Specifies the name of the device to open, usually one of `/dev/vbi0` and up.\n    The device name has to match that used by the deamon, else the daemon will\n    refuse the connection, so that `Zvbi.Capture`_ calls back to direct access\n    to the device.\n\n:client_name:\n    Names the client application, typically identical to ``sys.argv[0]``\n    (without the path though). Can be used by the proxy daemon for fine-tuning\n    scheduling, or for presenting the user with a list of currently connected\n    applications.\n\n:flags:\n    Contains zero or a bit-wise OR of `VBI_PROXY_CLIENT_*` flags.\n\n:trace:\n    If True, enables output of progress messages on ``sys.stderr``.\n\nProxy.set_callback()\n--------------------\n\n::\n\n    proxy.set_callback(callback=None, user_data=None)\n\nInstalls or removes a callback function for asynchronous messages (e.g.\nchannel change notifications.) Input parameters are a callable object\n*callback* and an optional object *user_data* which is passed through to\nthe callback function unchanged.  Call without any arguments to remove the\ncallback again.\n\nThe callback function will receive the event mask (i.e. one of the\nconstants `VBI_PROXY_EV_*` in the following list) and, if provided,\n*user_data* as parameters.\n\n* *VBI_PROXY_EV_CHN_GRANTED*:\n  The channel control token was granted, so that the client may now\n  change the channel.  Note: the client should return the token after\n  the channel change was completed (the channel will still remain\n  reserved for the requested time.)\n\n* *VBI_PROXY_EV_CHN_CHANGED*:\n  The channel (e.g. TV tuner frequency) was changed by another proxy\n  client.\n\n* *VBI_PROXY_EV_NORM_CHANGED*:\n  The TV norm was changed by another client (in a way which affects VBI,\n  e.g. changes between PAL/SECAM are ignored.)  The client must update\n  its services, else no data will be forwarded by the proxy until the\n  norm is changed back.\n\n* *VBI_PROXY_EV_CHN_RECLAIMED*:\n  The proxy daemon requests to return the channel control token.  The\n  client is no longer allowed to switch the channel and must immediately\n  reply with a channel notification with flag `VBI_PROXY_CHN_TOKEN`\n\n* *VBI_PROXY_EV_NONE*:\n  No news.\n\nSince the proxy client has no \"life\" on it's own (i.e.  it's not using an\ninternal thread or process) callbacks will only occur from inside other\nproxy client or capture function calls.  The client's capture device file\ndescriptor will become readable when an asynchronous message has arrived\nfrom the daemon.  Typically the application then will call read to obtain\nsliced data and the callback will be invoked from inside the read\nfunction.  Usually in this case the read call will return zero, i.e.\nindicate an timeout since no actual sliced data has arrived.\n\nNote for channel requests the callback to grant channel control may be\ninvoked before the request function returns.  Note you can call any\ninterface function from inside the callback, including the destroy\noperator.\n\nProxy.get_driver_api()\n----------------------\n\n::\n\n    api = proxy.get_driver_api()\n\nThis method can be used for querying which driver is behind the\ndevice which is currently opened by the VBI proxy daemon.\nApplications which only use libzvbi's capture API need not\ncare about this.  The information is relevant to applications\nwhich need to switch TV channels or norms.\n\nReturns an identifier describing which API is used on server side,\ni.e. one of the symbols\n`VBI_API_V4L1`,\n`VBI_API_V4L2`,\n`VBI_API_BKTR` or\n`VBI_API_UNKNOWN` upon error.\nThe function will fail if the client is currently not connected to\nthe proxy daemon, i.e. VBI capture has to be started first.\n\nProxy.channel_request()\n-----------------------\n\n::\n\n    Proxy.channel_request(chn_prio, request_chn=False, allow_suspend=FALSE,\n                          sub_prio=-1, min_duration=-1, exp_duration=-1)\n\nThis method is used to request permission to switch channels or norm.\nSince the VBI device can be shared with other proxy clients, clients should\nwait for permission, so that the proxy daemon can fairly schedule channel\nrequests.\n\nScheduling differs at the 3 priority levels. For available priority levels\nfor *chn_prio* see constants `VBI_CHN_PRIO_*`.  At background level channel\nchanges are coordinated by introduction of a virtual token: only the\none client which holds the token is allowed to switch channels. The daemon\nwill wait for the token to be returned before it's granted to another\nclient.  This way conflicting channel changes are avoided.  At the upper\nlevels the latest request always wins.  To avoid interference, the\napplication still might wait until it gets indicated that the token\nhas been returned to the daemon.\n\nThe token may be granted right away or at a later time, e.g. when it has\nto be reclaimed from another client first, or if there are other clients\nwith higher priority.  If a callback has been registered, the respective\nfunction will be invoked when the token arrives; otherwise\n*proxy.has_channel_control()* can be used to poll for it.\n\nInput parameters:\n\n:chn_prio:\n    This mandatory parameter sets the priority. The priority should always\n    be set if default *VBI_CHN_PRIO_INTERACTIVE* is not needed, to avoid\n    blocking other applications.\n\n:request_chn:\n    Set this parameter to *True* if your application needs to switch\n    channels.  Inversely, for only setting the *chn_prio* level to\n    *VBI_CHN_PRIO_BACKGROUND* without requesting a channel, set this\n    parameter to *False*.\n\n    **Note** the following parameters have no effect when this parameter\n    is set to *False*.  Inversely, when this parameter is set, the\n    following parameters are mandatory.\n\n:allow_suspend:\n    Set to FALSE if your capture client needs an atomic time slice (i.e.\n    would need to restart capturing from the beginning it it was\n    interrupted.)\n\n:sub_prio:\n    Sub-priority for channel scheduling at \"background\" priority. You can\n    use aribtrary values in the range 0 ... 256, but as this value is only\n    meaningful in relation to priorities used by other clients, you should\n    stick to the scale defined by VBI_CHN_SUBPRIO.\n\n:min_duration:\n    Minimum time slice your capture client requires. This value is used\n    when multiple clients have the same sub-priority to give all clients\n    channel control in a round-robin manner.\n\n:exp_duration:\n    Expected duration of use of that channel.\n\nZvbi.Proxy.channel_notify()\n---------------------------\n\n::\n\n    proxy.channel_notify(notify_flags [, scanning])\n\nSends channel control request to proxy daemon. Parameter\n*notify_flags* is an OR of one or more of the following constants:\n\n* *VBI_PROXY_CHN_RELEASE*:\n  Revoke a previous channel request and return the channel switch\n  token to the daemon.\n\n* *VBI_PROXY_CHN_TOKEN*:\n  Return the channel token to the daemon without releasing the\n  channel; This should always be done when the channel switch has\n  been completed to allow faster scheduling in the daemon (i.e. the\n  daemon can grant the token to a different client without having\n  to reclaim it first.)\n\n* *VBI_PROXY_CHN_FLUSH*:\n  Indicate that the channel was changed and VBI buffer queue\n  must be flushed; Should be called as fast as possible after\n  the channel and/or norm was changed.  Note this affects other\n  clients' capturing too, so use with care.  Other clients will\n  be informed about this change by a channel change indication.\n\n* *VBI_PROXY_CHN_NORM*:\n  Indicate a norm change.  The new norm should be supplied in\n  the scanning parameter in case the daemon is not able to\n  determine it from the device directly.\n\n* *VBI_PROXY_CHN_FAIL*:\n  Indicate that the client failed to switch the channel because\n  the device was busy. Used to notify the channel scheduler that\n  the current time slice cannot be used by the client.  If the\n  client isn't able to schedule periodic re-attempts it should\n  also return the token.\n\nProxy.channel_suspend()\n-----------------------\n\n::\n\n    proxy.channel_suspend(cmd)\n\nRequest to temporarily suspend capturing (if *cmd* is\n`VBI_PROXY_SUSPEND_START`) or revoke a suspension (if *cmd*\nequals `VBI_PROXY_SUSPEND_STOP`.)\n\nZvbi.Proxy.device_ioctl()\n-------------------------\n\n::\n\n    proxy.device_ioctl(request, arg)\n\nThis method allows manipulating parameters of the underlying\nVBI device.  Not all ioctls are allowed here.  It's mainly intended\nto be used for channel enumeration and channel/norm changes.\nThe request codes and parameters are the same as for the actual device.\nThe caller has to query the driver API via *proxy.get_driver_api()*\nfirst and use the respective ioctl codes, same as if the device would\nbe used directly.\n\nParameters and results are as documented for the **ioctl(2)** system\ninterface (see the respective UNIX manual page for details). Therefore\nparameter *request* is the first parameter to *ioctl()* and the *arg*\nbyte buffer contains the data structure that the second parameter to\n*ioctl* points to. Use *struct.pack* to build the argument buffer.\nExample: ::\n\n    # get current config of the selected channel\n    vchan = struct.pack(\"=i32xiLhh\", channel, 0, 0, 0, norm);\n    vchan_result = proxy.device_ioctl(VIDIOCGCHAN, vchan);\n\nAfter the call, the data passed in *arg* may be modified by *ioctl*\noperations which return data. Therefore the the proxy returns an updated\ncopy of the input buffer, which is returned by the function in form of a\nbytes object.\n\nUpon failure of the I/O operation, the function raises exception *OSError*\nand includes the *errno* error code and string as usual. The same\nexception is also used for non-device related failures, as the proxy\nresponse currently does not allow distinguishing them. In particular error\ncode *EBUSY* may indicate that the application is currently not allowed to\ncontrol the device.\n\nProxy.get_channel_desc()\n------------------------\n\n::\n\n    scanning, granted = proxy.get_channel_desc()\n\nRetrieve info sent by the proxy daemon in a channel change indication.\nThe function returns a tuple with two elements: scanning value (625\nindicating PAL, or 525 indicating NTSC, or 0 if unknown) and a boolean\nindicator if the change request was granted.\n\nProxy.has_channel_control()\n---------------------------\n\nReturns True if client is currently allowed to switch channels, else False.\n\n\n.. _Zvbi.ServiceDec:\n\nClass Zvbi.ServiceDec\n=====================\n\nThis class is used for high level decoding of sliced data received from\nan instance of the `Zvbi.Capture`_ class or the raw decoder (`Zvbi.RawDec`_).\nDecoded data is stored in caches for each service. The application can\nbe notified via callbacks about various events. Various interfaces allow\nextracting decoded data from the caches.\n\nConstructor Zvbi.ServiceDec()\n-----------------------------\n\n::\n\n  vt = Zvbi.ServiceDec()\n  vt.event_handler_register(Zvbi.VBI_EVENT_TTX_PAGE, pg_handler)\n\nCreates and returns a new data service decoder instance. The constructor\ndoes not take any parameters. **However**: The type of data services to\nbe decoded is determined by the type of installed callbacks. Hence for\nthe class to do any actual decoding, you must install at least one\ncallback using `Zvbi.ServiceDec.event_handler_register()`_ after\nconstruction.\n\nZvbi.ServiceDec.decode()\n------------------------\n\n::\n\n  while True:\n    sliced_buffer = cap.pull_sliced(2000)\n\n    vt.decode(sliced_buffer)\n\nThis is the main service offered by the data service decoder: The method\ndecodes sliced VBI data from a video frame, updates the decoder state and\ninvokes callback functions for registered events. Note this function has\nto be called for each received frame, even if it did not contain any\nsliced data, because the decoder otherwise assumes a frame was lost and\nmay reset decoding state.\n\nInput parameter *sliced_buffer* has to be an instance of class\n`Zvbi.CaptureSlicedBuf`_ returned by *read* and *pull* methods of the\n`Zvbi.Capture`_ class. The function always returns *None*. As a\nside-effect, registered callbacks are invoked.\n\nZvbi.ServiceDec.decode_bytes()\n------------------------------\n\n::\n\n  vt.decode_bytes(data, n_lines, timestamp)\n\nThis method is an alternate interface to *decode()*, allowing to insert\ndata from external sources, such as sliced data stored in a file.  Thus\nthe discrete method parameters replace attributes otherwise stored in\n`Zvbi.CaptureSlicedBuf`_:\n\n:data:\n    Is a bytes-like object containing concatenated sliced data lines. Each\n    line is a binary packed format \"=LL56c\", containing the service ID\n    `VBI_SLICED_*`, the number of the (analog) line from where the line\n    was captured, followed by 56 bytes slicer output data.\n\n:n_lines:\n    Gives the number of valid lines in the sliced data buffer. The value\n    must be between 0 and len(data) / (2*4+56) (i.e. the maximum number of\n    records in the given data buffer)\n\n:timestamp:\n    This should be a copy of the *timestamp* value returned by the *read*\n    and *pull* capture functions within `Zvbi.CaptureSlicedBuf`_ and\n    `Zvbi.CaptureRawBuf`_ class.\n\n    The timestamps are expected to advance by 1/30 to 1/25 seconds for\n    each call to this function. Different steps will be interpreted as\n    dropped frames, which starts a re-synchronization cycle, eventually a\n    channel switch may be assumed which resets even more decoder state. So\n    this function must be called even if a frame did not contain any\n    useful data (i.e. with parameter *n_lines* equal 0)\n\nZvbi.ServiceDec.channel_switched()\n----------------------------------\n\n::\n\n    vt.channel_switched( [nuid] )\n\nCall this after switching away from the channel (RF channel, video input\nline, ... - i.e. after switching the network) from which this context\nused to receive VBI data, to reset the decoding context accordingly.\nThis includes deletion of all cached Teletext and Closed Caption pages\nfrom the cache.  Optional parameter *nuid* is currently unused by\nlibzvbi and defaults to zero.\n\nThe decoder attempts to detect channel switches automatically, but this\ndoes not work reliably, especially when not receiving and decoding Teletext\nor VPS (since only these usually transmit network identifiers frequently\nenough.)\n\nNote the reset is not executed until the next frame is about to be\ndecoded, so you may still receive \"old\" events after calling this. You\nmay also receive blank events (e. g. unknown network, unknown aspect\nratio) revoking a previously sent event, until new information becomes\navailable.\n\nZvbi.ServiceDec.classify_page()\n-------------------------------\n\n::\n\n    (type, subno, lang) = vt.classify_page(pgno)\n\nThis function queries information about the named page. The return value\nis a tuple consisting of three scalars: page number, sub-page number,\nand language  Their meaning depends on the data service to which the\ngiven page belongs:\n\nFor Closed Caption pages (*pgno* value in range 1 ... 8) *subno* will\nalways be zero, *language* set or an empty string. *type* will be\n`VBI_SUBTITLE_PAGE` for page 1 ... 4 (Closed Caption channel 1 ... 4),\n`VBI_NORMAL_PAGE` for page 5 ... 8 (Text channel 1 ... 4), or\n`VBI_NO_PAGE` if no data is currently transmitted on the channel.\n\nFor Teletext pages (*pgno* in range hex 0x100 ... 0x8FF) *subno*\nreturns the highest sub-page number used. Note this number can be larger\n(but not smaller) than the number of sub-pages actually received and\ncached. Still there is no guarantee the advertised sub-pages will ever\nappear or stay in cache. Special value 0 means the given page is a\n\"single page\" without alternate sub-pages. (Hence value 1 will never\nbe used.) *language* currently returns the language of subtitle pages,\nor an empty string if unknown or the page is not classified as\n`VBI_SUBTITLE_PAGE`.\n\nNote: The information returned by this function is volatile: When more\ninformation becomes available, or when pages are modified (e. g. activation\nof subtitles, news updates, program related pages) sub-page numbers can\nincrease or page types and languages can change.\n\nZvbi.ServiceDec.set_brightness()\n--------------------------------\n\n::\n\n    vt.set_brightness(brightness)\n\nChange brightness of text pages, this affects the color palette of pages\nfetched with *fetch_vt_page()* and *fetch_cc_page()*.\nParameter *brightness* is in range 0 ... 255, where 0 is darkest,\n255 brightest. Brightness value 128 is default.\n\nZvbi.ServiceDec.set_contrast()\n------------------------------\n\n::\n\n    vt.set_contrast(contrast)\n\nChange contrast of text pages, this affects the color palette of pages\nfetched with *vt.fetch_vt_page()* and *vt.fetch_cc_page()*.\nParameter *contrast* is in range -128 to 127, where -128 is inverse,\n127 maximum. Contrast value 64 is default.\n\nZvbi.ServiceDec.teletext_set_default_region()\n---------------------------------------------\n\n::\n\n    vt.teletext_set_default_region(default_region)\n\nThe original Teletext specification distinguished between\neight national character sets. When more countries started\nto broadcast Teletext the three bit character set id was\nlocally redefined and later extended to seven bits grouping\nthe regional variants. Since some stations still transmit\nonly the legacy three bit id and we don't ship regional variants\nof this decoder as TV manufacturers do, this function can be used to\nset a default for the extended bits. The \"factory default\" is 16.\n\nParameter *default_region* is a value between 0 ... 80, index into\nthe Teletext character set table according to ETS 300 706,\nSection 15 (or libzvbi source file lang.c). The three last\nsignificant bits will be replaced.\n\nZvbi.ServiceDec.fetch_vt_page()\n-------------------------------\n\n::\n\n    with vt.fetch_vt_page(pgno, [subno],\n                          max_level=Zvbi.VBI_WST_LEVEL_3p5,\n                          display_rows=25,\n                          navigation=True) as pg:\n        # ... process page object 'pg'\n\nFetches a Teletext page designated by parameters *pgno* and optionally *subno*\nfrom the cache, formats and returns it as an instance of `Zvbi.Page`_.  The\nobject can then be used to extract page content, or be passed to the\nvarious libzvbi methods working on page objects, such as the export\nfunctions.\n\nThe function raises exception *ServiceDecError* if the page is not cached\nor could not be formatted for other reasons, for instance is a data page\nnot intended for display. Level 2.5/3.5 pages which could not be formatted\ne. g.  due to referencing data pages not in cache are formatted at a lower\nlevel.\n\nInput parameters:\n\n:page:\n    Teletext page number. Not the number is hexadecimal, which means to\n    retrieve text page \"100\", pass number 0x100. Teletext also allows\n    hexadecimal page numbers (sometimes used for transmitting hidden\n    data), so allowed is the full range of 0x100 to 0x8FF.\n\n:subno:\n    Defaults to `VBI_ANY_SUBNO`, which means the newest sub-page of the\n    given page is returned. Else this is a sub-page number in range\n    0 to 0x3F7E.\n\n:max_level:\n    Is one of the `VBI_WST_LEVEL_*` constants and specifies\n    the Teletext implementation level to use for formatting.\n\n:display_rows:\n    Limits rendering to the given number of rows\n    (i.e. row 0 ... *display_rows* - 1)  In practice, useful\n    values are 1 (format the page header row only) or 25 (complete page).\n\n:navigation:\n    This boolean parameter can be used to skip parsing the page\n    for navigation links to save formatting time.\n\nAlthough safe to do, this function is not supposed to be called from\nan event handler since rendering may block decoding for extended\nperiods of time.\n\n**Note**: The returned object must be deleted to release resources which\nare locked internally in the library during the fetch. Page objects\nsupport Python's \"Context Manager\" protocol to allow doing this easily\nusing the \"with\" statement. See also the description of `Zvbi.Page`_.\n\n\nZvbi.ServiceDec.fetch_cc_page()\n-------------------------------\n\n::\n\n    pg = vt.fetch_cc_page(pgno, reset=False)\n\nFetches a Closed Caption page designated by *pgno* from the cache,\nformats and returns it and as an object of type `Zvbi.Page`_.\nThe function raises exception *ServiceDecError* upon errors.\n\nClosed Caption pages are transmitted basically in two modes: at once\nand character by character (\"roll-up\" mode).  Either way you get a\nsnapshot of the page as it should appear on screen at the present time.\n\nWith `Zvbi.ServiceDec.event_handler_register()`_ you can request a\n`VBI_EVENT_CAPTION` event to be notified about pending changes (in case of\n\"roll-up\" mode that is with each new word received) and the \"dirty\"\nattribute provided by `Zvbi.Page.get_page_dirty_range()`_ will mark the\nlines actually in need of updates, for speeding-up rendering.\n\nIf the *reset* parameter is omitted or set to *True*, the page dirty flags\nin the cached paged are reset after fetching. Pass *False* only if you\nplan to call this function again to update other displays.\n\nAlthough safe to do, this function is not supposed to be called from an\nevent handler, since rendering may block decoding for extended periods of\ntime.\n\n**Note**: The returned object must be deleted to release resources which\nare locked internally in the library during the fetch. Page objects\nsupport Python's \"Context Manager\" protocol to allow doing this easily\nusing the \"with\" statement. See the description of `Zvbi.Page`_ for an\nexample.\n\nZvbi.ServiceDec.page_title()\n----------------------------\n\n::\n\n    title = vt.page_title(pgno, [subno])\n\nThe function makes an effort to deduce a page title to be used in\nbookmarks or similar purposes for the page specified by parameters\n*pgno* and *subno*.  The title is mainly derived from navigation data\non the given page.\n\nAs usual, parameter *subno* defaults to `VBI_ANY_SUBNO`, which means the\nnewest sub-page of the given page is used.  The function raises exception\n*ServiceDecError* upon errors.\n\n.. _Zvbi.ServiceDec event handling:\n\nEvent handling\n--------------\n\nTypically the transmission of VBI data elements like a Teletext or Closed Caption\npage spans several VBI lines or even video frames. So internally the data\nservice decoder maintains caches accumulating data. When a page or other\nobject is complete it calls the respective event handler to notify the\napplication.\n\nClients can register any number of handlers needed, also different handlers\nfor the same event. They will be called by the `Zvbi.ServiceDec.decode()`_\nfunction in the order in which they were registered.  Since decoding is\nstopped while in the callback, the handlers should return as soon as\npossible.\n\nThe handler function receives two parameters: First is the event type\n(i.e. one of the `VBI_EVENT_*` constants kisted below), second a named\ntuple describing the event. The type and contents of the second parameter\ndepends on the event type. The following event types are defined:\n\n*VBI_EVENT_NONE*:\n    No event. Second callback parameter is *None*.\n\n*VBI_EVENT_CLOSE*:\n    The vbi decoding context is about to be closed. This event is\n    sent when the decoder object is destroyed and can be used to\n    clean up event handlers. Second callback parameter is *None*.\n\n*VBI_EVENT_TTX_PAGE*:\n    The vbi decoder received and cached another Teletext page. For this\n    type the second callback function parameter has type\n    *Zvbi.EventTtx* with the following elements:\n\n    The received page is designated by *ev.pgno* and *ev.subno*.\n\n    *ev.roll_header* flags the page header as suitable for rolling page\n    numbers, e. g. excluding pages transmitted out of order.  The\n    *ev.header_update* flag is set when the header, excluding the page\n    number and real time clock, changed since the last\n    `VBI_EVENT_TTX_PAGE` evemt. Note this may happen at midnight when the\n    date string changes. The *ev.clock_update* flag is set when the real\n    time clock changed since the last `VBI_EVENT_TTX_PAGE` (that is at\n    most once per second). They are both set at the first\n    `VBI_EVENT_TTX_PAGE` sent and unset while the received header or clock\n    field is corrupted.\n\n    If any of the roll_header, header_update or clock_update flags\n    are set, *ev.raw_header* contains the raw header data (40 bytes).\n    *ev.pn_offset* will be the offset (0 ... 37) of the three-digit page\n    number in the raw or formatted header. Always call\n    *vt.fetch_vt_page()* for proper translation of national characters and\n    character attributes; the raw header is only provided here as a means\n    to quickly detect changes.\n\n*VBI_EVENT_CAPTION*:\n    A Closed Caption page has changed and needs visual update.\n    For this type the second callback function parameter has type\n    *Zvbi.EventCaption* with a single element *ev.pgno*, which\n    indicates the \"CC channel\" of the received page.\n\n    When the client is monitoring this page, the expected action is\n    to call *vt.fetch_cc_page()*. To speed up rendering, more detailed\n    update information can be queried via\n    `Zvbi.Page.get_page_dirty_range()`_.\n    (Note when the page is fetched afterward, the contents will be a\n    snapshot of the status at fetch time and not event time, i.e. the\n    \"dirty\" flags accumulate all changes since the last fetch.)\n\n*VBI_EVENT_NETWORK*:\n    Some station/network identifier has been received or is no longer\n    transmitted (in the latter case all values are zero, e.g. after a\n    channel switch).  The event will not repeat until a different identifier\n    has been received and confirmed.  (Note: VPS/TTX and XDS will not combine\n    in real life, feeding the decoder with artificial data can confuse\n    the logic.)\n\n    For this type the second callback function parameter has type\n    *Zvbi.EventNetwork* with the following elements:\n\n    0. *nuid*: Network identifier\n    1. *name*: Name of the network from XDS or from a table lookup of CNIs in Teletext packet 8/30 or VPS\n    2. *call*: Network call letters, from XDS (i.e. closed-caption, US only), else empty\n    3. *tape_delay*: Tape delay in minutes, from XDS; 0 outside of US\n    4. *cni_vps*: Network ID received from VPS, or zero if unknown\n    5. *cni_8301*: Network ID received from teletext packet 8/30/1, or zero if unknown\n    6. *cni_8302*: Network ID received from teletext packet 8/30/2, or zero if unknown\n\n    Minimum times for identifying a network, when data service is\n    transmitted: VPS (DE/AT/CH only): 0.08 seconds; Teletext PDC or 8/30:\n    2 seconds; XDS (US only): unknown, between 0.1x to 10x seconds.\n\n*VBI_EVENT_NETWORK_ID*:\n    Like *VBI_EVENT_NETWORK*, but this event will also be sent when the\n    decoder cannot determine a network name.  For this type the second\n    callback function parameter has type *Zvbi.EventNetwork* with same\n    contents as described above.\n\n*VBI_EVENT_TRIGGER*:\n    Triggers are sent by broadcasters to start some action on the\n    user interface of modern TVs. Until libzvbi implements all of\n    WebTV and SuperTeletext the information available are program\n    related (or unrelated) URLs, short messages and Teletext\n    page links.\n\n    This event is sent when a trigger has fired. The second callback\n    function parameter is of type *Zvbi.PageLink* and has the following\n    elements:\n\n    0. *type*: Link type: One of VBI_LINK* constants\n    1. *eacem*: Link received via EACEM or ATVEF transport method\n    2. *name*: Some descriptive text or empty\n    3. *url*: URL\n    4. *script*: A piece of ECMA script (Javascript), this may be used on\n       WebTV or SuperTeletext pages to trigger some action. Usually empty.\n    5. *nuid*: Network ID for linking to pages on other channels\n    6. *pgno*: Teletext page number\n    7. *subno*: Teletext sub-page number\n    8. *expires*: The time in seconds and fractions since 1970-01-01 00:00\n       when the link should no longer be offered to the user, similar to a\n       HTTP cache expiration date\n    9. *itv_type*: One of VBI_WEBLINK_* constants; only applicable to ATVEF triggers; else UNKNOWN\n    10. *priority*: Trigger priority (0=EMERGENCY, should never be\n        blocked, 1..2=HIGH, 3..5=MEDIUM, 6..9=LOW) for ordering and filtering\n    11. *autoload*: Open the target without user confirmation\n\n*VBI_EVENT_ASPECT*:\n    The vbi decoder received new information (potentially from PAL WSS,\n    NTSC XDS or EIA-J CPR-1204) about the program aspect ratio.\n\n    The second callback function parameter is of type *Zvbi.AspectRatio*\n    and has the following elements:\n\n    0. *first_line*: Describe start of active video (inclusive), i.e.\n       without the black bars in letterbox mode\n    1. *last_line*: Describes enf of active video (inclusive)\n    2. *ratio*: The picture aspect ratio in anamorphic mode, 16/9 for\n       example. Normal or letterboxed video has aspect ratio 1/1\n    3. *film_mode*: TRUE when the source is known to be film transferred\n       to video, as opposed to interlaced video from a video camera.\n    4. *open_subtitles*: Describes how subtitles are inserted into the\n       picture: None, or overlay in picture, or in letterbox bars, or\n       unknown.\n\n*VBI_EVENT_PROG_INFO*:\n    We have new information about the current or next program.\n\n    The second callback function parameter is of type *Zvbi.ProgInfo*\n    and has the following elements:\n\n    0. *current_or_next*: Indicates if entry refers to the current or next program\n    1. *start_month*: Month of the start date\n    2. *start_day*: Day-of-month of the start date\n    3. *start_hour*: Hour of the start time\n    4. *start_min*: Minute of the start time\n    5. *tape_delayed*: Indicates if a program is routinely tape delayed for\n       Western US time zones.\n    6. *length_hour*: Duration in hours\n    7. *length_min*: Duration remainder in minutes\n    8. *elapsed_hour*: Already elapsed duration\n    9. *elapsed_min*: Already elapsed duration\n    10. *elapsed_sec*: Already elapsed duration\n    11. *title*: Program title text (ASCII)\n    12. *type_classf*: Scheme used for program type classification:\n        One of the *VBI_PROG_CLASSF* constants. Use\n        `Zvbi.prog_type_string()`_ for obtaining a string from this\n        value and each of the following type identifiers.\n    13. *type_id_0*: Program type classifier #1 according to scheme\n    14. *type_id_1*: Program type classifier #2\n    15. *type_id_2*: Program type classifier #3\n    16. *type_id_3*: Program type classifier #4\n    17. *rating_auth*: Scheme used for rating: One of VBI_RATING_AUTH*\n        constants. Use `Zvbi.rating_string()`_ for obtaining a string from\n        this value and the following *rating_id*.\n    18. *rating_id*: Rating classification\n    19. *rating_dlsv*: Additional rating for scheme in case of\n        scheme *VBI_RATING_TV_US*\n    20. *audio_mode_a*: Audio mode: One of VBI_AUDIO_MODE* constants\n    21. *audio_language_a*: Audio language (audio channel A)\n    22. *audio_mode_b*: Audio mode (channel B)\n    23. *audio_language_b*: Audio language (audio channel B)\n    24. *caption_services*: Active caption pages: bits 0-7 correspond to caption pages 1-8\n    25. *caption_languages*: Tuple with caption language on all 8 CC pages\n    26. *aspect_ratio*: Aspect ratio description, an instance of class *Zvbi.AspectRatio*\n    27. *description*: Program content description text: Up to 8 lines\n        of ASCII text spearated by newline character.\n\n**Multithreading**: The `Zvbi.Capture`_, `Zvbi.RawDec`_,\n`Zvbi.ServiceDec`_ and `Zvbi.Search`_ classes are thread-safe insofar as\nthey allow running the capture loop (including raw decoder) and service\ndecoder in one thread, and further event processing or a user-interface in\nanother thread. The latter may interact with the capture/decoder thread\nvia configuration and query interfaces.\n\nHowever note that callbacks registered with the service decoder will occur\nwithin the capture thread (i.e. where you call\n`Zvbi.ServiceDec.decode()`_ on captured sliced data buffers). Take care\nto call only thread-safe functions of the user thread in that context.\nUsually one will filter and then forward the notifications to the main\nthread using some IPC mechanism (e.g. via a queued signal when using Qt).\nSee `examples/search-ttx.py` for an example using multi-threading.\n\n\nZvbi.ServiceDec.event_handler_register()\n----------------------------------------\n\n::\n\n    vt.event_handler_register(event_mask, function, [user_data])\n\nRegisters a new event handler. *event_mask* can be a but-wise 'OR' of\n`VBI_EVENT_*` constants. When the handler *function* with same *user_data*\nis already registered, its event_mask will be changed. Any number of\nhandlers can be registered, also different handlers for the same event\nwhich will be called in registration order.\n\nThe registered handler function will be invoked from within\n`Zvbi.ServiceDec.decode()`_.  The function is called either with two or\nthree parameters, depending on the presence of parameter *user_data*\nduring registration:\n\n1. Event type (i.e. one of the `VBI_EVENT_*` constants).\n2. A named tuple type describing the event. The class type depends on the\n   type of event indicated as first parameter.\n3. A copy of the *user_data* object specified during registration. The\n   parameter is omitted here when omitted during registration.\n\nSee section `Zvbi.ServiceDec event handling`_ above for a detailed\ndescripion of the callback parameters and information types.\n\nApart of adding handlers, this function also enables and disables decoding\nof data services depending on the presence of at least one handler for the\nrespective data. A `VBI_EVENT_TTX_PAGE` handler for example enables\nTeletext decoding.\n\nThis function can be safely called at any time, even from inside of a handler.\nNote only 10 event callback functions can be registered in a script at the\nsame time.  Callbacks are automatically unregistered when the decoder object\nis destroyed.\n\nZvbi.ServiceDec.event_handler_unregister()\n------------------------------------------\n\n::\n\n    vt.event_handler_unregister(function, [user_data])\n\nDe-registers the event handler *handler* with optional parameter\n*user_data*, if such a handler was previously registered with the same\nuser data parameter.\n\nApart from removing a handler, this function also disables decoding of\nassociated data services when no handler is registered to consume the\nrespective data. For example, removing the last handler for event type\n`VBI_EVENT_TTX_PAGE` disables Teletext decoding.\n\nThis function can be safely called at any time, even from inside of a\nhandler removing itself or another handler, and regardless if the handler\nhas been successfully registered.\n\n\n.. _Zvbi.Search:\n\nClass Zvbi.Search\n=================\n\nThe functions in this section allow searching across one or more\nTeletext pages in the cache for a given sub-string or a regular\nexpression.\n\nConstructor Zvbi.Search()\n-------------------------\n\n::\n\n    search = Zvbi.Search(decoder=vt, pattern=\"\",\n                         page=0x100, subno=Zvbi.VBI_ANY_SUBNO,\n                         casefold=False, regexp=False, direction=1,\n                         progress=None, user_data=None)\n\nCreate a search context and prepare for searching the Teletext page\ncache with the given sub-string or regular expression.\n\nInput Parameters:\n\n:decoder:\n    Reference to an instance of `Zvbi.ServiceDec`_ that contains the page\n    cache which is to be searched.\n\n:pattern:\n    Contains the search pattern (libzvbi expects the string in UTF-8\n    encoding; the conversion from Unicode used by Python strings is done\n    automatically).\n\n:page:\n    Page number of the first (forward) or last (backward) page to visit.\n    Note the number is hexadecimal, which means to retrieve text page\n    \"100\", pass number 0x100. Teletext also allows hexadecimal page\n    numbers (sometimes used for transmitting hidden data), so allowed is\n    the full range of 0x100 to 0x8FF.\n\n:subno:\n    Defaults to `Zvbi.VBI_ANY_SUBNO`, which means the newest sub-page of\n    the given page is returned. Else this is a sub-page number in range 0\n    to 0x3F7E.\n\n:direction:\n    Specifies the direction of search (from the given start page):\n    1 for forward, or -1 for backward search. The search does not\n    wrap-around when reaching the last or first page respectively.\n\n:regexp:\n    This boolean must be set to True when the search pattern is a regular\n    expression; default is False, which means sub-string search. (Note\n    libzvbi internally converts the sub-string to regular expression\n    simply be escaping all special characters - so there is no performance\n    gain by using sub-string search.)\n\n:casefold:\n    This boolean can be set to True to make the search case insensitive;\n    default is False.\n\n:progress:\n    If present, the parameter has to be callable. The function will be\n    called for each scanned page. When the function returns False, the\n    search is aborted.\n\n    The callback function receives as first parameter a reference to the\n    search page (i.e. an instance of `Zvbi.Page`_), plus optionally the\n    object specified as *user_data*. Note due to internal limitations only\n    10 search callback functions can be registered in a script at the same\n    time.  Callbacks are automatically unregistered when the search object\n    is destroyed.\n\n:user_data:\n    If present, the parameter is passed through as second parameter to each\n    call of the function specified by *progress*. When not specified, the\n    callback is invoked with a single parameter.\n\n**Note:** The page object is only valid while inside of the callback\nfunction (i.e. you must not assign the object to a variable outside of the\nscope of the handler function.) An exception of type *ValueError* will be\nraised upon later access to an invalidated page.\n\n**Note:**\nIn a multi-threaded application the data service decoder may receive\nand cache new pages during a search session. When these page numbers\nhave been visited already the pages are not searched. At a channel\nswitch (and in future at any time) pages can be removed from cache.\nAll this has yet to be addressed.\n\nRegular expression searching supports the standard set of operators and\nconstants, with these extensions:\n\n`\\\\x....` or `\\\\X....`\n    Hexadecimal number of up to 4 digits\n\n`\\\\u....` or `\\\\U....`\n    Hexadecimal number of up to 4 digits\n\n`:title:`\n    Unicode specific character class\n\n`:gfx:`\n    Teletext G1 or G3 graphic\n\n`:drcs:`\n    Teletext DRCS\n\n`\\\\pN1,N2,...,Nn`\n    Character properties class\n\n`\\\\PN1,N2,...,Nn`\n    Negated character properties class\n\nProperty definitions:\n\n1.  alphanumeric\n2.  alpha\n3.  control\n4.  digit\n5.  graphical\n6.  lowercase\n7.  printable\n8.  punctuation\n9.  space\n10. uppercase\n11. hex digit\n12. title\n13. defined\n14. wide\n15. nonspacing\n16. Teletext G1 or G3 graphics\n17. Teletext DRCS\n\nCharacter classes can contain literals, constants, and character\nproperty classes. Example: `[abc\\U10A\\p1,3,4]`. Note double height\nand size characters will match twice, on the upper and lower row,\nand double width and size characters count as one (reducing the\nline width) so one can find combinations of normal and enlarged\ncharacters.\n\nZvbi.Search.__iternext__()\n--------------------------\n\nAfter creating an instance of *Zvbi.Search*, iteration is used to execute\nthe search:\n\n::\n\n    search = Zvbi.Search(decoder, pattern)\n    for pg in search:\n        # ... process pg object\n\nAs long as matching pages are found, iteration returns a reference to the\nnext match in form of an instance of `Zvbi.Page`_. The matching range of\ntext is highlighted in the page.\n\n**Note**: The returned page object refers to temporary memory within the C\nlibrary; therefore the page content is no longer valid after continuation\nof the search or start of a new search. An exception of type *ValueError*\nwill be raised upon access to an invalidated page.\n\nIf no matching page is found, iteration raises exception *StopIteration*\nas usual. The same exception is raised when the callback returned *False*.\nIf iteration is continued after reaching its end, the search will restart\nfrom the starting point given in the constructor. After cancellation\nsearch will continue from the last visited page.\n\nUpon other errors the function raises exception *Zvbi.SearchError*\nwhich contains a string describing the cause, which can be because the\ncache is completely empty, or internal errors.\n\n\n.. _Zvbi.Page:\n\nClass Zvbi.Page\n===============\n\nThese are functions to render Teletext and Closed Caption pages directly\ninto memory, essentially a more direct interface to the functions of some\nimportant export modules described in `Zvbi.Export`_.\n\nAll of the functions in this section work on page objects as returned\nby the page cache's \"fetch\" functions (see `Zvbi.ServiceDec`_)\nor the page search function (see `Zvbi.Search`_)\n\nPage objects returned by `Zvbi.ServiceDec`_'s \"fetch\" interfaces must be\ndeleted for releasing resources which are locked internally in the library\nduring the fetch. `Zvbi.Page`_ supports the Python's \"Context Manager\"\nprotocol (i.e.  methods \"__enter__\" and \"__exit__\") to allow doing this\neasily using the \"with\" statement: ::\n\n    with vtdec.fetch_vt_page(pgno, subno) as pg:\n        # process object \"pg\"\n\nAny access to the page after the block defined by \"with\" would raise\nexception *ValueError*.\n\nPage objects returned by `Zvbi.Search`_ (or referenced as parameter to the\nprogress callback function) have an implicitly limited life-time as they\nrefer to internal static storage within the C library.  These objects are\nreleased invalidated automatically. Any access outside of their lifetime\nraises exception *ValueError*. In particular this means you must not\nassign such page objects to global variables. Instead just store the page\nnumber and fetch the page again from the cache via `Zvbi.ServiceDec`_ when\nneeded.\n\n\nZvbi.Page.draw_vt_page()\n------------------------\n\n::\n\n    canvas = pg.draw_vt_page(column, row, width, height,\n                             fmt=Zvbi.VBI_PIXFMT_RGBA32_LE,\n                             reveal=False, flash_on=False,\n                             img_pix_width, col_pix_off, row_pix_off)\n\nDraws a complete Teletext page or a sub-section thereof into a raw image\ncanvas and returns it in form of a bytes object. Each teletext character\noccupies 12 x 10 pixels (i.e. a character is 12 pixels wide and each line\nis 10 pixels high. Note that this aspect ratio is not optimal for display,\nso pixel lines should be doubled. This is done automatically by the PPM\nand XPM conversion functions.)\n\nThe image is returned in form of a bytes object.  When\nusing format `Zvbi.VBI_PIXFMT_RGBA32_LE`, each pixel consists of 4 subsequent\nbytes (RGBA). Hence the bytes array is\n`4 * 12 * pg_columns * 10 * pg_rows` bytes long, where\n`pg_columns` and `pg_rows` are the page width and height in\nteletext characters respectively.  When using format `Zvbi.VBI_PIXFMT_PAL8`\neach pixel uses one byte. In this case each pixel value is an index into\nthe color palette as delivered by `Zvbi.Page.get_page_color_map()`_.\n\nInput parameters:\n\n:column:\n    Start column in the page to render at the first pixel column, defaults\n    to 0.  Note this and the following three values are given as numbers\n    of teletext characters (not pixels.)\n\n:row:\n    Start row in the page to render at the first pixel column, defaults to 0.\n\n:width:\n    Number of columns to render. The sum of parameters *column* plus\n    *width* shall be less or equal the page width. When omitted, the\n    value defaults to the page width minus the start row offset.\n\n:height:\n    Number of rows to render. The sum of parameters *row* plus\n    *height* shall be less or equal the page height. When omitted, the\n    value defaults to the page height minus the start column offset.\n\n:fmt:\n    Specifies the output format. Supported is `Zvbi.VBI_PIXFMT_RGBA32_LE`\n    (i.e. each pixel uses 4 subsequent bytes for R,G,B,A) and\n    `Zvbi.VBI_PIXFMT_PAL8` (i.e. each pixel uses one byte, which is an\n    index into the color palette)\n\n:img_pix_width:\n    Is the distance between canvas pixel lines in pixels.  When omitted or\n    set to 0, the image width is automatically set to the width of the\n    selected region (i.e. the number of columns times 12) plus\n    *col_pix_off*, if present. If specified, the value has to be equal\n    or larger than the default; extraneous pixels are left zero in the\n    returned image.\n\n:col_pix_off:\n    Offset to the left in pixels defining where in the canvas to draw\n    the page section. By using this value combined with *img_pix_width*\n    you can achieve a black border around the image.\n\n:row_pix_off:\n    Offset to the top in pixels defining where in the canvas to draw\n    the page section.\n\n:reveal:\n    When omitted or set to False, characters flagged as \"concealed\" are\n    rendered space (U+0020). When set to True the characters are rendered.\n\n:flash_on:\n    Set to True to draw characters flagged \"blink\" (properties) as space\n    (U+0020). To implement blinking you'll have to draw the page\n    repeatedly with this parameter alternating between 0 and 1.\n\nZvbi.Page.draw_cc_page()\n------------------------\n\n::\n\n    canvas = pg.draw_cc_page(column, row, width, height,\n                             fmt=Zvbi.VBI_PIXFMT_RGBA32_LE,\n                             img_pix_width, col_pix_off, row_pix_off)\n\nDraw a complete or sub-section of a Closed Caption page. Each character\noccupies 16 x 26 pixels (i.e. a character is 16 pixels wide and each line\nis 26 pixels high.)\n\nThe image is returned in a byte object.  Each\npixel uses 4 subsequent bytes (RGBA). Hence the bytes array\nis `4 * 16 * pg_columns * 26 * pg_rows` bytes long, where\n`pg_columns` and `pg_rows` are the page width and height in\nClosed Caption characters respectively.\n\nFor details on parameters please see the previous function.\n\nZvbi.Page.canvas_to_ppm()\n-------------------------\n\n::\n\n    ppm = pg.canvas_to_ppm(canvas, fmt=Zvbi.VBI_PIXFMT_RGBA32_LE,\n                           aspect=True, img_pix_width=0)\n\nThis is a helper function which converts the image given in *canvas* from\na raw bytes object generated by *draw_vt_page()* or *draw_cc_page()* into\nPPM format (specifically \"P6\" with 256 colors per dimensions, which means\nthere is a small ASCII header, followed by the image bitmap consisting of\n3 bytes (RGB) per pixel.)\n\n:fmt:\n    The is the format of the input canvas. If must be the same value as\n    passed to *draw_vt_page()* or *draw_cc_page()*.\n\n:aspect:\n    This optional boolean parameter when set to False, disables the aspect\n    ratio correction (i.e. on teletext pages all lines are doubled by\n    default; closed caption output ration is already correct.) Default is\n    True.\n\n:img_pix_width:\n    The is the pixel width of the input canvas. It must be the same\n    value as passed to *draw_vt_page()* or *draw_cc_page()*. When omitted\n    or zero, the value is calculated in the same way as described for these\n    methods.\n\nZvbi.Page.canvas_to_xpm()\n-------------------------\n\n::\n\n    xpm = pg.canvas_to_xpm(canvas, fmt=Zvbi.VBI_PIXFMT_RGBA32_LE,\n                           aspect=True, img_pix_width=0)\n\nThis is a helper function which converts the image given in *canvas* from\na raw bytes object generated by *draw_vt_page()* or *draw_cc_page()* into\nXPM format. Due to the way XPM is specified, the output is an ASCII text\nstring (suitable for including in C source code), however returned within\na bytes object.\n\n:fmt:\n    The is the format of the input canvas. If must be the same value as\n    passed to *draw_vt_page()* or *draw_cc_page()*.\n\n:aspect:\n    This optional boolean parameter when set to False, disables the aspect\n    ratio correction (i.e. on teletext pages all lines are doubled by\n    default; closed caption output ration is already correct.) Default is\n    True.\n\n:img_pix_width:\n    The is the pixel width of the input canvas. It must be the same\n    value as passed to *draw_vt_page()* or *draw_cc_page()*. When omitted\n    or zero, the value is calculated in the same way as described for these\n    methods.\n\nZvbi.Page.print_page()\n----------------------\n\n::\n\n    txt = pg.print_page(column, row, width, height,\n                        fmt='UTF-8', table=True)\n\nPrint and return the referenced Teletext or Closed Caption page\nin form of a bytes object. Rows are separated by line-feed characters (\"\\n\").\nAll character attributes and colors will be lost. Graphics characters,\nDRCS and all characters not representable in UTF-8 will be replaced by\nspaces.\n\n:column:\n    Start column in the page to render at the first output column.\n    Defaults to 0.\n\n:row:\n    Start row in the page to render at the first output row.\n    Defaults to 0.\n\n:width:\n    Number of columns to render. The sum of parameters *column* plus\n    *width* shall be less or equal the page width (use\n    *pg.get_page_size()* to determine the dimensions.) When omitted, the\n    value defaults to the page width minus the start row offset.\n\n:height:\n    Number of rows to render. The sum of parameters *row* plus\n    *height* shall be less or equal the page height. When omitted, the\n    value defaults to the page height minus the start column offset.\n\n:format:\n    Encoding to be used in the output. Default is 'UTF-8'. Use the\n    equivalent format specification when decoding the bytes into a Python\n    string.\n\n:table:\n    When optional parameter *table* is set to 1, the page is scanned in\n    table mode, printing all characters within the source rectangle\n    including runs of spaces at the start and end of rows. This is the\n    default. When set to False, sequences of spaces at the start and end\n    of rows are collapsed into single spaces and blank lines are\n    suppressed.\n\n\nZvbi.Page.get_page_no()\n-----------------------\n\n::\n\n    (pgno, subno) = pg.get_page_no()\n\nThis function returns a tuple containing the page and sub-page number of\nthe page instance.\n\nTeletext page numbers are hexadecimal numbers in the range 0x100 .. 0x8FF,\nClosed Caption page numbers are in the range 1 .. 8.  Sub-page numbers\nare used for teletext only. These are hexadecimal numbers in range\n0x0001 .. 0x3F7F, i.e. the 2nd and 4th digit count from 0..F, the\n1st and 3rd only from 0..3 and 0..7 respectively. A sub-page number\nzero means the page has no sub-pages.\n\nZvbi.Page.get_page_size()\n-------------------------\n\n::\n\n    (rows, columns) = pg.get_page_size()\n\nThis function returns a tuple containing the dimensions (i.e. row and\ncolumn count) of the page instance.\n\nZvbi.Page.get_page_dirty_range()\n--------------------------------\n\n::\n\n    (y0, y1, roll) = pg.get_page_dirty_range()\n\nTo speed up rendering these variables mark the rows\nwhich actually changed since the page has been last fetched\nfrom cache. *y0* ... *y1* are the first to last row changed,\ninclusive. *roll* indicates the\npage has been vertically scrolled this number of rows,\nnegative numbers up (towards lower row numbers), positive\nnumbers down. For example -1 means row `y0 + 1 ... y1`\nmoved to `y0 ... y1 - 1`, erasing row *y1* to all spaces.\n\nPractically this is only used in Closed Caption roll-up\nmode, otherwise all rows are always marked dirty. Clients\nare free to ignore this information.\n\nZvbi.Page.get_page_color_map()\n------------------------------\n\n::\n\n    map = pg.get_page_color_map()\n\nThe function returns a tuple of length 40 which\ncontains the page's color palette. Each entry is a 24-bit RGB value\n(i.e. three 8-bit values for red, green, blue, with red in the\nlowest bits)  To convert this into the usual \"`#RRGGBB`\" syntax use:\n\n::\n\n    print(\"#%02X%02X%02X\" %\n             (rgb&0xFF, (rgb>>8)&0xFF, (rgb>>16)&0xFF))\n\nZvbi.Page.get_page_text_properties()\n------------------------------------\n\n::\n\n    av = pg.get_page_text_properties()\n\nThe function returns tuple which contains the properties of all characters\non the given page, starting with those of the first row left to right,\ndirectly followed by the next row etc. (use *pg.get_page_size()* for\nunpacking). Each entry is a bit-field. The members are (in\nascending order, width in bits given behind the colon):\n\n* foreground color:8:\n  Index into the color map returned by `Zvbi.Page.get_page_color_map()`_\n* background color:8:\n  Index into the color map returned by `Zvbi.Page.get_page_color_map()`_\n* opacity:4:\n  Character opacity, as one of constants:\n\n  + `VBI_TRANSPARENT_SPACE` (replace char with video),\n  + `VBI_TRANSPARENT_FULL` (replace background with video),\n  + `VBI_SEMI_TRANSPARENT` (mix video into background), or\n  + `VBI_OPAQUE` (no transparency).\n\n  Both *foreground* and *background* colors are valid\n  independent of this flag.\n* size:4:\n  One of the constants:\n\n  + `VBI_NORMAL_SIZE`,\n  + `VBI_DOUBLE_WIDTH`,\n  + `VBI_DOUBLE_HEIGHT`,\n  + `VBI_DOUBLE_SIZE`,\n  + `VBI_OVER_TOP`\n    (i.e. this is to the right of `VBI_DOUBLE_WIDTH` or `VBI_DOUBLE_SIZE`),\n  + `VBI_OVER_BOTTOM`\n    (i.e. this is below `VBI_OVER_TOP`, thus lower right of `VBI_DOUBLE_SIZE`),\n  + `VBI_DOUBLE_HEIGHT2`\n    (i.e. this is lower half of a `VBI_DOUBLE_HEIGHT` character in the row above), or\n  + `VBI_DOUBLE_SIZE2`\n    (i.e. this is lower half of a `VBI_DOUBLE_SIZE` character in the row above).\n\n  Note characters marked `VBI_DOUBLE_HEIGHT2`, `VBI_DOUBLE_SIZE2`,\n  `VBI_OVER_TOP`, `VBI_OVER_BOTTOM` have the same character unicode and\n  attributes as the top/left anchor. Partial characters (like a single\n  `VBI_DOUBLE_HEIGHT2`) will not appear, so characters with these\n  attributes can be safely ignored when scanning the page content.\n* underline:1:\n  Boolean *True* for underlined, else *False*.\n* bold:1:\n  Boolean *True* for bold, else *False*.\n* italic:1:\n  Boolean *True* for displaying the character slanted right, else *False*.\n* flash:1:\n  Boolean *True* for characters that should flash (i.e. blink), else\n  *False*. Note the GUI is responsible for rendering the page periodically\n  with such characters present, or omitted. See\n  `Zvbi.Page.draw_vt_page()`_.\n* conceal:1:\n  Boolean *True* for characters that should be concealed (i.e. replaced by\n  space character), else *False*.\n  See also option *reveal* for `Zvbi.Page.draw_vt_page()`_.\n* proportional:1:\n  Currently always *False*, i.e. use fixed-width fonts for rendering.\n* link:1:\n  Boolean *True* if the character is part of a hyperlink, else *False*.\n  Call `Zvbi.Page.resolve_link()`_ to get more information.\n\nZvbi.Page.get_page_text()\n-------------------------\n\n::\n\n    txt = pg.get_page_text( replace_chr='' )\n\nThe function returns the complete page text in form of a string (i.e.\nUnicode).  This function is very similar to *pg.print_page()*,\nbut does not insert or remove any characters so that it's guaranteed\nthat characters in the returned string correlate exactly with the\narray returned by `Zvbi.Page.get_page_text_properties()`_.\n\nThe optional parameter can be set to a single-character string for\nreplacing \"private-use\" Unicode code points in range [0xE000, 0xF8FF] with\nthat character.  Note these code points are used for representing\ngraphical characters. When not replacing them, there will be errors when\npassing the string to transcoder functions (such as Pythons's *decode()*.)\n\nZvbi.Page.resolve_link()\n----------------------------\n\n::\n\n    href = pg.resolve_link(column, row)\n\nThe page instance *pg* (in practice only Teletext pages) may contain\nhyperlinks such as HTTP URLs, e-mail addresses or links to other\npages. Characters being part of a hyperlink have their \"link\" flag\nset in the character properties (see\n`Zvbi.Page.get_page_text_properties()`_),\nthis function returns a dict with a more verbose description of the link.\n\nThe function returns an object of type *Zvbi.PageLink*. See chapter\n`Event handling`_, item *VBI_EVENT_TRIGGER* for a description of the\ncontents.\n\nZvbi.Page.resolve_home()\n----------------------------\n\n::\n\n    href = pg.resolve_home()\n\nAll Teletext pages have a built-in home link, by default\npage 100, but can also be the magazine intro page or another\npage selected by the editor.\n\nThe function returns an object of type *Zvbi.PageLink*. See chapter\n`Event handling`_, item *VBI_EVENT_TRIGGER* for a description of the\ncontents.\n\n\n.. _Zvbi.Export:\n\nClass Zvbi.Export\n=================\n\nOnce libzvbi received, decoded and formatted a Teletext or Closed Caption\npage you will want to render it on screen, print it as text or store it\nin various formats.  libzvbi provides export modules converting a page\nobject into the desired format or rendering directly into an image.\n\nCurrently the following export formats are supported:\n\n* Text\n* HTML\n* PNG (image with lossless compression)\n* PPM (image without compression)\n* XPM (image without compression)\n\nAll the formats support boolean option \"reveal\"; all the image formats\nsupport boolean option \"aspect\". The meaning of the options is the same as\nfor `Zvbi.Page.draw_vt_page()`_.\n\nConstructor Zvbi.Export()\n-------------------------\n\n::\n\n    exp = Zvbi.Export(keyword)\n\nCreates a new object for exporting a `Zvbi.Page`_ object in\nthe format implied by parameter *keyword*. As a special service you can\ninitialize options by appending to the *keyword* parameter like this:\n`keyword = \"keyword; quality=75.5, comment=\\\"example text\\\"\";`\n\nNote: A quick overview of all export formats and options can be\nobtained by running the demo script `examples/explist.py` in the\nZVBI package.\n\nZvbi.Export.info_enum()\n-----------------------\n\n::\n\n    href = Zvbi.Export.info_enum(index)\n\nThis is a **static** member function.\nThe function enumerates all available export modules. You should start\nwith *index* 0, incrementing until the function raises exception\n*StopIteration*.\nSome modules may depend on machine features or the presence of certain\nlibraries, thus the list can vary from session to session.\n\nThe function returns a dict with the following elements:\n\n* \"keyword\"\n* \"label\"\n* \"tooltip\"\n* \"mime_type\"\n* \"extension\"\n\nZvbi.Export.info_keyword(keyword)\n---------------------------------\n\n::\n\n    href = Zvbi.Export.info_keyword(keyword)\n\nThis is a **static** member function.\nSimilar to the above function *info_enum()*, this function returns info\nabout available modules, although this one searches for an export module\nwhich matches the given *keyword*. If no match is found the function\nraises exception *Zvbi.ExportError*, else a dict as described above.\n\nZvbi.Export.info_export()\n-------------------------\n\n::\n\n    href = exp.info_export()\n\nReturns the export module info for the export instance in form of a dict.\nThe contents are as described for the previous two functions.\n\nZvbi.Export.option_info_enum()\n------------------------------\n\n::\n\n    href = exp.option_info_enum(index)\n\nThis member function enumerates the options available for the given\nexport instance.\nYou should start at *index* 0, incrementing until the function\nraises exception *StopIteration*.  On success, the function returns a\ndict with the following elements:\n\n* \"type\"\n* \"keyword\"\n* \"label\"\n* \"min\"\n* \"max\"\n* \"step\"\n* \"def\"\n* \"menu\"\n* \"tooltip\"\n\nThe content format of min, max, step and def depends on the type,\ni.e. it may be an integer, double or string.\n\nIf present, the value of \"menu\" is a tuple.  Elements in the tuple are of\nthe same type as min, max, etc.  If no label or tooltip are available for\nthe option, these elements are undefined.\n\nZvbi.Export.option_info_keyword()\n---------------------------------\n\n::\n\n    href = exp.option_info_keyword(keyword)\n\nSimilar to the above function *exp.option_info_enum()* this\nfunction returns info about available options, although this one\nidentifies options based on the given *keyword*.\n\nZvbi.Export.option_set()\n------------------------\n\n::\n\n    exp.option_set(keyword, opt)\n\nSets the value of the option named by *keword* to *opt*.\nRaises exception *Zvbi.ExportError* on failure.  Example: ::\n\n    exp.option_set('quality', 75.5);\n\nNote the expected type of the option value depends on the keyword.\nThe ZVBI interface module automatically converts the option into\ntype expected by the libzvbi library.\n\nMind that options of type `VBI_OPTION_MENU` must be set by menu\nentry number (integer), all other options by value. If necessary\nit will be replaced by the closest value possible. Use function\n*exp.option_menu_set()* to set options with menu by menu entry.\n\nZvbi.Export.option_get()\n------------------------\n\n::\n\n    opt = exp.option_get(keyword)\n\nThis function queries and returns the current value of the option\nnamed by *keyword*.\n\nZvbi.Export.option_menu_set()\n-----------------------------\n\n::\n\n    exp.option_menu_set(keyword, entry)\n\nSimilar to *exp.option_set()* this function sets the value of\nthe option named by *keyword* to *entry*, however it does so\nby number of the corresponding menu entry. Naturally this must\nbe an option with menu.\n\nZvbi.Export.option_menu_get()\n-----------------------------\n\n::\n\n    entry = exp.option_menu_get(keyword)\n\nSimilar to *exp.option_get()* this function queries the current\nvalue of the option named by *keyword*, but returns this value as\nnumber of the corresponding menu entry. Naturally this must be an\noption with menu.\n\nZvbi.Export.to_stdio()\n----------------------\n\n::\n\n    exp.to_stdio(pg, fd)\n\nThis function writes contents of the `Zvbi.Page`_ instance given in *pg*,\nconverted to the respective export module format, to a stream created from\n*fd* using fdopen(3). This means *fd* has to be a value as returned by\n*fileno()* on a file-like object.\n\nThe function raises exception *Zvbi.ExportError* upon errors.\nNote this function may write incomplete files when an error occurs.\n\nYou can call this function as many times as you want, it does not\nchange state of the export or page objects.\n\nZvbi.Export.to_file()\n---------------------\n\n::\n\n    exp.to_file(pg, file_name)\n\nThis function writes contents of the `Zvbi.Page`_ instance given in *pg*,\nconverted to the respective export module format, into a new file specified\nby *file_name*. When an error occurs the file will be deleted.\nThe function raises exception *Zvbi.ExportError* upon errors.\n\nYou can call this function as many times as you want, it does not\nchange state of the export or page objects.\n\nZvbi.Export.to_memory()\n-----------------------\n\n::\n\n    data = exp.to_memory(pg)\n\nThis function writes contents of the `Zvbi.Page`_ instance given in *pg*,\nconverted to the respective export module format, into a bytes object.\n\nThe function raises exception *Zvbi.ExportError* upon errors.\n\n\n.. _Zvbi.DvbMux:\n\nClass Zvbi.DvbMux\n=================\n\nThese functions convert raw and/or sliced VBI data to a DVB Packetized\nElementary Stream or Transport Stream as defined in EN 300 472 \"Digital\nVideo Broadcasting (DVB); Specification for conveying ITU-R System B\nTeletext in DVB bit-streams\" and EN 301 775 \"Digital Video Broadcasting\n(DVB); Specification for the carriage of Vertical Blanking Information\n(VBI) data in DVB bit-streams\".\n\nNote EN 300 468 \"Digital Video Broadcasting (DVB); Specification for\nService Information (SI) in DVB systems\" defines another method to\ntransmit VPS data in DVB streams. Libzvbi does not provide functions\nto generate SI tables but the *encode_dvb_pdc_descriptor()* function\nis available to convert a VPS PIL to a PDC descriptor (since version 0.3.0)\n\nConstructor Zvbi.DvbMux()\n-------------------------\n\n::\n\n    mx = Zvbi.DvbMux( {pes=True | ts_pid=pid}\n                      [,callback [,user_data]]\n                      [,raw_par] )\n\nThere are two separate semantics:\n\n* When option *pes* is present and *True*, a DVB VBI multiplexer instance is\n  created for converting raw and/or sliced VBI data to MPEG-2 Packetized\n  Elementary Stream (PES) packets as defined in the standards EN 300 472 and\n  EN 301 775.\n\n* When option *ts_pid* is present and non-zero, a DVB VBI multiplexer\n  instance is created for converting raw and/or sliced VBI data to MPEG-2\n  Transport Stream (TS) packets as defined in the standards EN 300 472 and\n  EN 301 775.\n\nThe following keyword-only parameters are available:\n\n:pes:\n    When this option is set, a PES stream will be encoded.\n    This option must not be combined with option *ts_pid*.\n\n:ts_pid:\n    When this option is present and non-zero, a TS stream will be encoded.\n    The PID value is a program identifier that will be stored in the\n    header of generated TS packets. The value must be in range 0x0010 to\n    0x1FFE inclusive. This option must not be combined with option *pes*.\n\n:callback:\n    Specifies a handler function which is called by method *feed()* when a\n    new TS or PES packet is available. When the callback parameter is\n    omitted, packets have to be extracted via iteration. See method\n    *feed()* for additional details.\n\n:user_data:\n    The given object is passed through transparently as extra parameter to\n    the specified *callback* when invoked from within the *feed()* method.\n\n:raw_par:\n    This optional parameter of type `Zvbi.RawParams`_ describes attributes\n    of raw data optionally provided to method `Zvbi.DvbMux.feed()`_. The\n    parameters have to match the capture source (i.e. usually one would\n    obtain them via `Zvbi.Capture.parameters()`_ called on your capture\n    instance). The parameter need not be specified when no raw data is to\n    be encoded.\n\nWen raw decoder parameters are provided, they have to meet the following\nconstraints:\n\n* videostd_set must contain one or more bits from the\n  `VBI_VIDEOSTD_SET_625_50`.\n* scanning must be 625 (libzvbi 0.2.x only)\n* sampling_format must be `VBI_PIXFMT_Y8` or `VBI_PIXFMT_YUV420`.\n  Chrominance samples are ignored.\n* sampling_rate must be 13500000.\n* offset must be >= 132.\n* bytes_per_line must be >= 1.\n* offset + bytes_per_line must be <= 132 + 720.\n* synchronous must be *True*.\n\n\nZvbi.DvbMux.feed()\n------------------\n\nThis method provides the main service of class *Zvbi.DvbMux*: ::\n\n    mx.feed(service_mask, sliced_buffer, raw_buf=None, pts=0)\n\nThis function converts raw and/or sliced VBI data to one DVB VBI PES\npacket or one or more TS packets as defined in EN 300 472 and EN 301 775.\n\n**Usage with a callback function:**\n\nWhen the DVB multiplexer was intiantiated with a callback function\nparameter, the *feed()* function invokes the callback for each generated\nPES or TS packet before it returns. Example for use of the callback: ::\n\n    # callback function, invoked out of DvbMux.feed()\n    def feed_cb(pkg, outfile):\n        bwritten = outfile.write(pkg)\n        return (bwritten == len(pkg))\n\n    outfile = open(SOME_FILE, \"wb\")\n    mx = Zvbi.DvbMux(pes=True, callback=feed_cb, user_data=outfile)\n\n    sliced_buffer = cap.pull_sliced(1000)\n    mx.feed(service_mask, sliced_buffer)\n\nThe packet parameter is a *Bytes* object containing a copy of the\ngenerated packet. Parameter *user_data* loops back the object passed to\nthe constructor; it is omitted here if not present in the constructor\nparameters.  The handler function has to return *True* on success and\n*False* on failure. In case of the latter, the *feed()* function\nterminates with exception *Zvbi.DvbMuxError*.\n\n**Usage without a callback function:**\n\nWhen the DVB multiplexer was intiantiated without a callback function\nparameter, generated packets have to be retrieved using iteration on the\n*DvbMux* object. Example usage for this mode: ::\n\n    outfile = open(SOME_FILE, \"wb\")\n    mx = Zvbi.DvbMux(pes=True)\n\n    sliced_buffer = cap.pull_sliced(1000)\n    mx.feed(service_mask, sliced_buffer)\n\n    for pes_pkg in mx:\n        outfile.write(pes_pkg)\n\nNote each iteration pre-allocates a packet buffer of size\n`Zvbi.DvbMux.get_max_pes_packet_size()`_, which defaults to theoretical\nmaximum 65504. For compatibility with decoders compliant to the Teletext\nbuffer model defined in EN 300 472 the maximum should not exceed 1472\nbytes. For this reason and for efficiency, is is recommended to limit the\nmaximum to a value such as 2048 using `Zvbi.DvbMux.set_pes_packet_size()`_.\n\nInput parameters:\n\n:service_mask:\n    Only data services in this set will be encoded. Other data services in\n    the sliced buffer will be discarded without further checks. Create a\n    set by ORing `VBI_SLICED_*` constants. Only the following data\n    services can be encoded:\n\n    1. `VBI_SLICED_TELETEXT_B` on lines 7 to 22 and 320 to 335\n       inclusive, or with line number 0 (undefined). All Teletext\n       lines will be encoded with data_unit_id 0x02 (\"EBU Teletext\n       non-subtitle data\").\n    2. `VBI_SLICED_VPS` on line 16.\n    3. `VBI_SLICED_CAPTION_625` on line 22.\n    4. `VBI_SLICED_WSS_625` on line 23.\n\n:sliced_buffer:\n    This mandatory parameter of type `Zvbi.CaptureSlicedBuf`_ contains the\n    sliced VBI data to be converted. All data must belong to the same\n    video frame.\n\n:raw_buf:\n    This optional parameter may pass an object of type\n    `Zvbi.CaptureRawBuf`_ that contains raw VBI data to be converted.  The\n    object shall contain sample data of size (*rdp.count_a* +\n    *rdp.count_b*) lines times *rdp.bytes_per_line* (where *rdp* is the\n    raw decoder parameter set passed during instantiation).  The function\n    encodes only those lines which have been selected by sliced lines in\n    the *sliced_buffer* object with id `VBI_SLICED_VBI_625` The data field of\n    these structures is ignored. When the sliced input buffer does not\n    contain such structures, *raw_buf* can be omitted.\n\n    Raw VBI data with id `VBI_SLICED_VBI_625` can be encoded on lines 7 to\n    23 and 320 to 336 inclusive. Note for compliance with the Teletext\n    buffer model defined in EN 300 472, EN 301 775 recommends to encode at\n    most one raw and one sliced, or two raw VBI lines per frame.\n\n:pts:\n    This Presentation Time Stamp will be encoded into the PES packet. Bits\n    33 ... 63 are discarded. Resolution is 90 kHz. Note the value can be\n    derived from the timestamp in *sliced_buffer* as\n    `sliced_buffer.timestamp * 90000.0`.\n\nThe function may raise exception *Zvbi.DvbMuxError* upon failures, which\nmay occur under the following circumstances:\n\n* The maximum PES packet size, or the value selected with\n  `Zvbi.DvbMux.set_pes_packet_size()`_, is too small to contain all\n  the sliced and raw VBI data.\n* The sliced array is not sorted by ascending line number,\n  except for elements with line number 0 (undefined).\n* An unsupported service was requested for encoding of sliced data.\n* A selected raw data line is not in the allowed ranges listed above.\n* A sliced line within *sliced_buffer* contains a physical line number\n  outside the valid range specified above.\n* Parameter *raw_dec* was not specified during instantiation although\n  the *sliced_buffer* contains a structure with id `VBI_SLICED_VBI_625`.\n* One or more members of the raw decoder parameters are invalid.\n* A sliced line within *sliced_buffer* with id `VBI_SLICED_VBI_625`\n  contains a physical line number outside the ranges defined by *raw_dec*\n  parameters.\n\n\nZvbi.DvbMux.mux_reset()\n-----------------------\n\n::\n\n    mx.mux_reset()\n\nThis function clears the internal buffers of the DVB VBI multiplexer.\n\nAfter a reset call the *feed()* function will encode a new PES packet,\ndiscarding any data of the previous packet which has not been consumed by\nthe application.\n\nZvbi.DvbMux.get_data_identifier()\n---------------------------------\n\n::\n\n    id = mx.get_data_identifier()\n\nReturns the data_identifier the multiplexer encodes into PES packets.\n\nZvbi.DvbMux.set_data_identifier()\n---------------------------------\n\n::\n\n    mx.set_data_identifier(data_identifier)\n\nThis function can be used to specify the *data_identifier* byte\nto be stored in PES packets.\n\nFor compatibility with decoders compliant to EN 300 472 this should be a\nvalue in the range 0x10 to 0x1F inclusive. The values 0x99 to 0x9B\ninclusive as defined in EN 301 775 are also permitted.  The default\ndata_identifier is 0x10.\n\nThe method raises exception *Zvbi.DvbMuxError* if the given identifier is\noutside the valid range.\n\nZvbi.DvbMux.get_min_pes_packet_size()\n-------------------------------------\n\n::\n\n    size = mx.get_min_pes_packet_size()\n\nReturns the minimum size of PES packets the multiplexer generates.\n\nZvbi.DvbMux.get_max_pes_packet_size()\n-------------------------------------\n\n::\n\n    size = mx.get_max_pes_packet_size()\n\nReturns the maximum size of PES packets the multiplexer generates.\n\nZvbi.DvbMux.set_pes_packet_size()\n---------------------------------\n\n::\n\n    mx.set_pes_packet_size(min_size, max_size)\n\nDetermines the minimum and maximum total size of PES packets generated by\nthe multiplexer, including all header bytes. When the data to be stored in\na packet is smaller than the minimum size, the multiplexer will fill the\npacket up with stuffing bytes. When the data is larger than the maximum\nsize the *feed()* function will fail.\n\nThe PES packet size must be a multiple of 184 bytes, in the range 184\nto 65504 bytes inclusive, and this function will round *min_size* up\nand *max_size* down accordingly. If after rounding the maximum size is\nlower than the minimum, it will be set to the same value as the\nminimum size.\n\nThe default minimum size is 184, the default maximum 65504 bytes. For\ncompatibility with decoders compliant to the Teletext buffer model\ndefined in EN 300 472 the maximum should not exceed 1472 bytes.\n\nThe method raises exception *Zvbi.DvbMuxError* upon failure (out of\nmemory).\n\nZvbi.DvbMux.dvb_multiplex_sliced()\n----------------------------------\n\nThis **static method** converts the sliced VBI data in the *sliced* buffer to\nVBI data units as defined in EN 300 472 and EN 301 775 and stores them in\n*packet* as output buffer.  Thus this function provides a fraction of the\nfunctionality of the *feed()* method.\n\n::\n\n    packet_left, sliced_left =\n        Zvbi.DvbMux.dvb_multiplex_sliced(packet, packet_left,\n                                         sliced, sliced_left,\n                                         service_mask,\n                                         data_identifier=0x10, stuffing= False)\n\nInput parameters:\n\n:packet:\n    This parameter has to be a *bytearray* that is to be filled with the\n    generated packet. The size of the *bytearray* needs to be\n    pre-initialized to the initial value of *packet_left*.\n\n:packet_left:\n    Contains the number of bytes available in the *packet* object. It will\n    be decremented by the cumulative size of the successfully stored data\n    units.\n\n:sliced:\n    This has to be an object of type `Zvbi.CaptureSlicedBuf`_. It contains\n    the sliced VBI data to be converted.\n\n:sliced_left:\n    Indicates initially the number of sliced lines in the *sliced* buffer,\n    or it can be zero.\n\n:service_mask:\n    Only data services in this set will be encoded. Other data services in\n    the *sliced* buffer will be discarded without further checks. Create a\n    set by bit-wise ORing *VBI_SLICED_* values.  The parameter defauls to\n    the set of all allowed services, which are:\n\n    * VBI_SLICED_TELETEXT_B on lines 7 to 22 and 320 to 335 inclusive\n    * VBI_SLICED_VPS on line 16\n    * VBI_SLICED_CAPTION_625 on line 22\n    * VBI_SLICED_WSS_625 on line 23\n\n:data_identifier:\n    When the given value lies in range 0x10 to 0x1F inclusive, the encoded\n    data units will be padded to data_unit_length 0x2C for compatibility\n    with EN 300 472 compliant decoders. The *data_identifier* itself will\n    **not** be stored in the output buffer.\n\n:stuffing:\n    If this optional parameter is specified and set *True*, and space\n    remains in the output buffer after all data has been successfully\n    converted, or *sliced_left* is zero, the function fills the buffer up\n    with stuffing data units.\n\nThe function returns a tuple of two values:\n\n0. Returns the value of parameter *packet_left*, decremented by\n   the cumulative size of the successfully stored data units.\n1. Returns the value of parameter *sliced_left* decremented by the number\n   of successfully converted VBI lines in *sliced*\n\nThe method raises exception *Zvbi.DvbMuxError* upon failure. The method\nmay fail for the following causes:\n\n* *packet_left* is less than 2 (the minimum data unit size is two bytes).\n  The output buffer remains unchanged in this case.\n* The *data_identifier* is in range 0x10 to 0x1F inclusive and\n  *packet_left* is not a multiple of 46. The output buffer remains\n  unchanged in this case.\n* The lines in the *sliced* buffer are not sorted by ascending line\n  number, except for elements with line number 0 (undefined).\n* The service mask contains a serive type that is not one of the allowed\n  types listed above.\n* A sliced line selected by *service_mask* contains a line number outside\n  the valid range specified above.\n\nAll errors are recoverable. Just call the function again, possibly after\nskipping the offending sliced line (by reducing the value of\n*sliced_left*), to continue where it left off. Note *packet_left* must be\nat least 2 (or a multiple of 46) in each call.\n\nSimplified example without error checking: ::\n\n    sliced_buffer = cap.pull_sliced(1000)\n\n    pkg = bytearray(2024) # multiple of 46\n    pkg_left = len(pkg)\n    sliced_left = len(sliced_buffer)\n    pkg_left, sliced_left = \\\n        Zvbi.DvbMux.multiplex_sliced(pkg, pkg_left, sliced_buffer, sliced_left)\n    del pkg[pkg_left :]\n\n**Note:**\nAccording to EN 301 775 all lines stored in one PES packet must belong to\nthe same video frame (but the data of one frame may be transmitted in\nseveral successive PES packets). They must be encoded in the same order as\nthey would be transmitted in the VBI, no line more than once. Samples may\nhave to be split into multiple segments and they must be contiguously\nencoded into adjacent data units. The function cannot enforce this if\nmultiple calls are necessary to encode all samples.\n\nZvbi.DvbMux.dvb_multiplex_raw()\n-------------------------------\n\nThis **static method**  converts one line of raw VBI samples in *raw* to one or\nmore \"monochrome 4:2:2 samples\" data units as defined in EN 301 775, and stores\nthem in the *buf* output buffer. Thus this function provides a fraction of the\nfunctionality of the feed() method.\n\n::\n\n    packet_left, raw_left =\n        Zvbi.DvbMux.dvb_multiplex_raw(packet, packet_left,\n                                      raw, raw_left,\n                                      data_identifier, videostd_set, line,\n                                      first_pixel_position, n_pixels_total,\n                                      stuffing=False)\n\nInput parameters:\n\n:data_identifier:\n    When the given value lies in range 0x10 to 0x1F inclusive, the encoded\n    data units will be padded to data_unit_length 0x2C for compatibility\n    with EN 300 472 compliant decoders. The *data_identifier* itself will\n    **not** be stored in the output buffer.\n\n:videostd_set:\n   The *line* parameter will be interpreted according to this set of video\n   standards. It must not change until all samples have been encoded. Only\n   one of two values are permitted: *Zvbi.VBI_VIDEOSTD_SET_625_50* or\n   *Zvbi.VBI_VIDEOSTD_SET_525_60*.\n\n:line:\n    The ITU-R line number to be encoded in the data units.\n    It must not change until all samples have been encoded.\n\n:first_pixel_position:\n    The horizontal offset where decoders shall insert the first sample in\n    the VBI, counting samples from the start of the digital active line as\n    defined in ITU-R BT.601.  Usually this value is zero and\n    *n_pixels_total* is 720.  *first_pixel_position* + *n_pixels_total*\n    must not be greater than 720. This parameter must not change until all\n    samples have been encoded.\n\n:n_pixels_total:\n    Total size of the raw input buffer in bytes, and the total number of\n    samples to be encoded. Initially this value must be equal to\n    *raw_left*, and it must not change until all samples have been\n    encoded.\n\n:stuffing:\n    If this optional parameter is specified and set *True*, and space\n    remains in the output buffer after all data has been successfully\n    converted, or *sliced_left* is zero, the function fills the buffer up\n    with stuffing data units.\n\nThe function returns a tuple of two values:\n\n0. Returns the value of parameter *packet_left*, decremented by\n   the cumulative size of the successfully stored data units.\n1. Returns the value of parameter *raw_left* decremented by the number of\n   successfully converted samples.\n\nThe method raises exception *Zvbi.DvbMuxError* upon failure. The method\nmay fail for the following causes:\n\n* *packet_left* is less than two (the minimum data unit size is two bytes).\n* *raw_left* is zero.\n* The *data_identifier* is in range 0x10 to 0x1F inclusive and\n  *packet_left* is not a multiple of 46.\n* The *videostd_set* is ambiguous.\n* The *line* parameter is outside the valid range, that is 7 to\n  23 and 270 to 286 for 525 line standards, 7 to 23 and 320 to 336\n  for 625 line standards. All numbers inclusive.\n* *raw_left* is greater than *n_pixels_total*\n* *first_pixel_position* + *n_pixels_total* is greater than 720.\n\nThe output buffer remains unchanged on all errors.\n\n.. _Zvbi.DvbDemux:\n\nClass Zvbi.DvbDemux\n===================\n\nThis class extracts sliced VBI data from a DVB Packetized Elementary\nStream (PES) or Transport Stream (TS) as defined in EN 300 472 \"Digital\nVideo Broadcasting (DVB); Specification for conveying ITU-R System B\nTeletext in DVB bitstreams\" and EN 301 775 \"Digital Video Broadcasting\n(DVB); Specification for the carriage of Vertical Blanking Information\n(VBI) data in DVB bitstreams\".\n\nConstructor Zvbi.DvbDemux\n-------------------------\n\n::\n\n    dvb = Zvbi.DvbDemux( [callback [, user_data]] [,max_sliced=64] )\n\nCreates and returns a new DVB VBI demultiplexer context taking a PES\nstream as input.\n\nThe constructor takes the following optional keyword-only parameters:\n\n:callback:\n    When this parameter is present, it must be a function object. The\n    function will be called from inside of method *feed* whenever a\n    complete sliced data of a VBI frame is available during\n    de-multiplexing the provided stream data.\n\n    When the callback parameter is omitted, VBI data has to be extracted\n    via iteration.  See *dvb.feed()* for additional details.\n\n:user_data:\n    If present, the passed object is appended to the callback's parameter\n    list. IF omitted, one parameter less is passed to the callback.\n\n:max_sliced:\n    This optional parameter indicates the size of the buffer to allocate\n    for the sliced buffer to be returned by iteration (i.e. when no\n    callback is defined). The default is 64 lines per frame.\n\nZvbi.DvbDemux.feed()\n--------------------\n\n::\n\n    dvb.feed(buf)\n\nThis function takes an arbitrary number of DVB PES data bytes in *buf*,\nfilters out *PRIVATE_STREAM_1* packets, filters out valid VBI data units,\nand stores them in objects of type `Zvbi.CaptureSlicedBuf`_ function may\nraise exception *Zvbi.DvbDemuxError* if the data contained errors. When a\ncallback is configured, the exception is also raised if the callback\nfunction returned value *False*.\n\nNote the timestamp included in the generated `Zvbi.CaptureSlicedBuf`_\ninstantes is derived from the presentation timestamp (PTS) of the DVB\nstream, converted from 1/90000 Hz to a second resolution (as *Float* type\nto allow fractions). The value does not represent seconds since\n1970-Jan-01, but can nevertheless be used equivalently to timestampts\ngenerated by class `Zvbi.Capture`_.\n\nNote: Demultiplexing of raw VBI data is not supported;\nany raw data present in the stream will be discarded.\n\n**Usage with a callback function:**\n\nWhen the de-multiplexer was intiantiated with a callback function\nparameter, the *feed* function invokes the callback for each completed VBI\nframe before it returns. The callback is invoked with the following\nsignature: ::\n\n    ok = callback(sliced_buffer, user_data)\n\nThe handler function has to return *True* on success and *False* on failure.\nParameters to the callback have the following meaning:\n\n* *sliced_buffer* is an object of type `Zvbi.CaptureSlicedBuf`_,\n  containing the sliced data and attributes (i.e. this is the same\n  type as returned by `Zvbi.Capture`_ methods). The *timestamp* attribute\n  is derived from the PTS value in the stream, converted from 90 kHz to\n  one second (with fraction) resolution.\n\n  **Note**: The sliced buffer instance passed here is valid only for the\n  duration of the callback execution. (When assigned to a global variable\n  and accessed after the callback returns, exception *ValueError* will be\n  raised.)\n\n* *user_data* loops back the object passed via *user_data* parameter\n  to the constructor. If not specified there, this parameter is omitted\n  here.\n\n**Usage without a callback function:**\n\nWhen the de-multiplexer was intiantiated without a callback function\nparameter, the *feed()* function only stores a reference to the given\ninput buffer. Actual de-multiplexing is done when the object is used as an\niterator.  The iteration has to be completed before feeding new data, else\nexception *ZvbiDvbDemuxError* is raised.\n\nEach iteration returns an object of type `Zvbi.CaptureSlicedBuf`_,\ncontaining the sliced data and attributes (i.e.  this is the same type as\nreturned by `Zvbi.Capture`_ methods). The *timestamp* attribute is derived\nfrom the PTS value in the stream, converted from 90 kHz to one second\n(with fraction) resolution.\n\nExample usage for this mode: ::\n\n    dvb.feed(buf)\n    for sliced_buffer in dvb:\n        # process sliced_buffer...\n\nSee also `examples/dvb-mux.py` for a working example.\n\nAt most the maximum number of sliced lines indicated via parameter\n*max_sliced* (or default value 64) to the constructor is returned. If the\nframe contains more lines, they are discarded sliently. To detect this,\nyou can set *max_sliced* to plus one of the expected maximum and treat\nreaching this value as overflow error. (The number of sliced lines in the\nreturned buffer can be queried via `len(sliced_buffer)`.)\n\nNote in contrary to callback mode, the life-time of returned\n*sliced_buffer* objects is not limited by the library, as a separate\nbuffer, owned by the instance, is allocated for each iteration.\n\nZvbi.DvbDemux.set_log_fn()\n--------------------------\n\n::\n\n    dvb.set_log_fn(mask, log_fn=None, user_data=None)\n\nThe DVB demultiplexer supports the logging of errors in the PES stream and\ninformation useful to debug the demultiplexer.\nWith this function you can redirect log messages generated by this module\nfrom general log function `Zvbi.set_log_fn()`_ to a\ndifferent function or enable logging only in the DVB demultiplexer.\n\nThe callback can be removed by calling the function with a zero mask value\nor without a handler parameter.\n\nInput parameters:\n\n:mask:\n    An integer value specifying which kind of information to log.\n    If zero, logging is disabled (and parameter *log_fn* is ignored).\n    Else this is a bit-wise OR of one or more of the constants\n    `VBI_LOG_ERROR`,\n    `VBI_LOG_WARNING`,\n    `VBI_LOG_NOTICE`,\n    `VBI_LOG_INFO`,\n    `VBI_LOG_DEBUG`,\n    `VBI_LOG_DRIVER`,\n    `VBI_LOG_DEBUG2`,\n    `VBI_LOG_DEBUG3`.\n:log_fn:\n    If present, has to be a callable object that is invoked for each\n    message with the parameters listed below. If omitted, logging is\n    disabled.\n:user_data:\n    If present, this object is passed through to the handler function as\n    last parameter.\n\nThe handler function is called with the following parameters: *level*,\n*context*, *message* and, if given, *user_data*. Meaning of the parameters\nis the same as described for `Zvbi.set_log_fn()`_.\n\nNote: Kind and contents of log messages may change in the future.\n\n\nZvbi.DvbDemux.reset()\n---------------------\n\n::\n\n    dvb.reset()\n\nResets the DVB demux to the initial state as after creation.\nIntended to be used after channel changes.\n\n.. _Zvbi.IdlDemux:\n\nClass Zvbi.IdlDemux\n===================\n\nThe functions in this section decode data transmissions in Teletext\n**Independent Data Line** packets (EN 300 708 section 6), i.e. data\ntransmissions based on teletext packet 8/30.\n\nThe decoder only supports format A.\n\nConstructor Zvbi.IdlDemux()\n---------------------------\n\n::\n\n    idl = Zvbi.IdlDemux(channel, address, callback, [user_data] )\n\nCreates and returns a new Independent Data Line format A\n(EN 300 708 section 6.5) demultiplexer.\n\nInput parameters:\n\n:channel:\n    Process packets of this channel.\n:address:\n    Process packets with this service data address.\n:callback:\n    Parameters *callback* and optional *user_data* specify a handler and\n    passed-through parameter which is called when a new packet is available.\n    Passing the callback is mandatory as the data is otherwise discarded.\n:user_data:\n    This optional parameter is passed through to the callback function,\n    if specified. Else the *user_data* parameter to the callback is\n    omitted.\n\nThe callback function is invoked with the following parameters for each\nreceived data packet:\n\n0. *buffer*: A bytes object containing the data received in the packet\n   (i.e. payload data after stripping teletext packet header)\n1. *flags*: A bit-wise OR of *VBI_IDL_DATA_* constants.\n2. Optionally the *user_data* object specified as constructor parameter;\n   if the parameter was specified to the constructor, it is omitted here.\n\n\nZvbi.IdlDemux.feed()\n--------------------\n\n::\n\n    idl.feed(buf)\n\nThis function takes 42 bytes of a Teletext packet, detects packets\nbelonging to the configured data channel and address and calls the\ncallback function given during context creation when new payload data is\navailable.\n\nParameter *buf* is a scalar containing a teletext packet's data\n(at least 42 bytes, i. e. without clock run-in and framing code),\nas returned by the slicer functions.\n\nThe function returns *None*. Exception *Zvbi.IdlDemuxError* is raised if\nthe buffer contained incorrectible errors.\n\nZvbi.IdlDemux.feed_frame()\n--------------------------\n\nThis function works like *idl.feed()* but takes a complete sliced buffer\n(i.e. a full frame's worth of sliced data as returned by\n`Zvbi.Capture.pull_sliced()`_) and automatically filters out all unrelated\nteletext packets.  This can be used to \"short-circuit\" the capture output\nwith the demultiplexer. Example: ::\n\n    sliced_buffer = cap.pull_sliced(1000)\n    idl.feed_frame(sliced_buffer)\n\nThe callback function given during context creation is called when new\npayload data is available.  The function returns *None*.  Exception\n*Zvbi.IdlDemuxError* is raised if any of the teletext packets in the buffer\ncontained incorrectible errors.\n\n.. _Zvbi.PfcDemux:\n\nZvbi.IdlDemux.reset()\n---------------------\n\n::\n\n    idl.reset(dx)\n\nResets the IDL demux context, useful for example after a channel change.\n\nClass Zvbi.PfcDemux\n===================\n\nSeparating data transmitted in Page Function Clear Teletext packets\n(ETS 300 708 section 4), i.e. using regular packets on a dedicated\nteletext page.\n\nConstructor Zvbi.PfcDemux()\n---------------------------\n\n::\n\n    pfc = Zvbi.PfcDemux(pgno, stream, callback, [user_data] )\n\nCreates and returns a new demultiplexer context.\n\nInput parameters:\n\n:page:\n    Number of the teletext page on which the data is transmitted.\n    (Usually data is transmitted on a \"non-decimal looking\" page\n    number such as `1DF`.)\n:stream:\n    Number of the stream to be de-multiplexed.\n:callback:\n    Parameters *callback* and optional *user_data* specify a handler and\n    passed-through parameter which is called when a new packet is available.\n    Passing the callback is mandatory as the data is otherwise discarded.\n:user_data:\n    This optional parameter is passed through to the callback function,\n    if specified. Else the *user_data* parameter to the callback is\n    omitted.\n\nThe callback function is invoked with the following parameters for each\ncorrectly assembled data block.\n\n0. *page*: Teletext page number given in constructor.\n1. *stream*: Stream identifier given in constructor.\n2. *application_id*: Application ID received in the AI block.\n3. *block*: A bytes object containing the data received in the block.\n4. Optionally the *user_data* object specified as constructor parameter;\n   if the parameter was specified to the constructor, it is omitted here.\n\nNote multiple small blocks may fit within a teletext packet; inversely\nlarger blocks may span multiple teletext packets. Therefore the callback\nmay be called 0, 1, or more times per received teletext packet.\n\nZvbi.PfcDemux.feed()\n--------------------\n\n::\n\n    pfc.feed(buf)\n\nThis function takes a raw stream of Teletext packets, detects if they\nbelong to the requested page and stream and assembles the data transmitted\nin this packet in an internal buffer. When a data block is complete it\ncalls the handler given during creation.\n\nZvbi.PfcDemux.feed_frame()\n--------------------------\n\nThis function works like *pfc.feed()* but takes a complete sliced buffer\n(i.e. a full frame's worth of sliced data as returned by\n`Zvbi.Capture.pull_sliced()`_) and automatically filters out all unrelated\nteletext packets.  This can be used to \"short-circuit\" the capture output\nwith the demultiplexer. Example: ::\n\n    sliced_buffer = cap.pull_sliced(1000)\n    pfc.feed_frame(sliced_buffer)\n\nThe callback function given during context creation is called when a new\ndata block is complete.  The function returns *None*.  Exception\n*Zvbi.PfcDemuxError* is raised if any of the teletext packets in the buffer\ncontained incorrectible errors.\n\nZvbi.PfcDemux.reset()\n---------------------\n\n::\n\n    pfc.reset()\n\nResets the PFC demux context, useful for example after a channel change.\n\n\n.. _Zvbi.XdsDemux:\n\nClass Zvbi.XdsDemux\n===================\n\nSeparating \"Extended Data Service\" (XDS) from a Closed Caption stream (EIA\n608).\n\nConstructor Zvbi.XdsDemux()\n---------------------------\n\n::\n\n    xds = Zvbi.XdsDemux(callback, user_data)\n\nCreates and returns a new Extended Data Service (EIA 608) demultiplexer.\n\nParameters *callback* and optionally *user_data* specify a handler and\npassed-through parameter which is called when a new packet is available.\nPassing the callback is mandatory as the data is otherwise discarded.\n\nThe callback function is invoked with the following parameters:\n\n0. *xds_class* is the XDS packet class, i.e. one of the `VBI_XDS_CLASS_*`\n   constants.\n1. *xds_subclass* holds the subclass; meaning depends on the main class.\n2. *buffer* is a bytes object holding the packet data (already parity decoded.)\n3. Optionally *user_data*, if specified as constructor parameter; else the\n   parameter is omitted.\n\nZvbi.XdsDemux.feed()\n--------------------\n\n::\n\n    xds.feed(buf)\n\nThis function takes two successive bytes of a raw Closed Caption stream,\nfilters out XDS data and calls the handler function given during context\ncreation when a new packet is complete.\n\nParameter *buf* is a bytes-like object holding data from NTSC line 284 (as\nreturned by the slicer functions.)  Only the first two bytes in the buffer\nare used.\n\nThe function returns *None*. Exception *Zvbi.XdsDemuxError* is raised if\nthe buffer contained parity errors.\n\nZvbi.XdsDemux.feed_frame()\n--------------------------\n\nThis function works like *xds.feed()* but takes a complete sliced buffer\n(i.e. a full frame's worth of sliced data as returned by\n`Zvbi.Capture.pull_sliced()`_) and automatically filters out all\nnon-closed caption lines.  This can be used to \"short-circuit\" the capture\noutput with the demultiplexer. Example: ::\n\n    sliced_buffer = cap.pull_sliced(1000)\n    xds.feed_frame(sliced_buffer)\n\nThe callback function given during context creation is called when a new\npacket is complete.  The function returns *None*.  Exception\n*Zvbi.XdsDemuxError* is raised if any of the CC lines in the buffer\ncontained parity errors.\n\nZvbi.XdsDemux.reset()\n---------------------\n\n::\n\n    xds.reset()\n\nResets the XDS demux context, useful for example after a channel change.\n\n\nMiscellaneous (Zvbi)\n====================\n\nZvbi.lib_version()\n------------------\n\n::\n\n    major, minor, micro = Zvbi.lib_version()\n\nReturns the major, minor and micro versions of the ZVBI library in\nform of a tuple.\n\nZvbi.check_lib_version()\n------------------------\n\n::\n\n    Zvbi.check_lib_version(major, minor, micro)\n\nReturns True if the library version is at least the given version.\nThe last two parameters are optional and default to zero. Example: ::\n\n    if not Zvbi.check_lib_version(0, 2, 35):\n        print(\"Library version is outdated\")\n\n\nZvbi.set_log_fn()\n-----------------\n\n::\n\n    Zvbi.set_log_fn(mask, log_fn=None, user_data=None)\n\nVarious functions within the *libzvbi* library can print warnings, errors\nand information useful for debugging the library or application. By\ndefault such messages are disabled. This function allows enabling these\nmessages by specifying a function for printing them. (Note: The kind and\ncontents of messages logged by particular functions may change in the\nfuture.)\n\nInput parameters:\n\n:mask:\n    An integer value specifying which kind of information to log.\n    If zero, logging is disabled (and parameter *log_fn* is ignored).\n    Else this is a bit-wise OR of one or more of the constants\n    `VBI_LOG_ERROR`,\n    `VBI_LOG_WARNING`,\n    `VBI_LOG_NOTICE`,\n    `VBI_LOG_INFO`,\n    `VBI_LOG_DEBUG`,\n    `VBI_LOG_DRIVER`,\n    `VBI_LOG_DEBUG2`,\n    `VBI_LOG_DEBUG3`.\n\n:log_fn:\n    Callable object to be called for log messages. Omit this parameter to\n    disable logging.\n\n:user_data:\n    If present, the parameter is passed through as last parameter to each\n    call of the function specified by *log_fn*. When not specified, the\n    callback is invoked with one less parameter.\n\nThe handler function is called with the following parameters:\n\n1. *level*: Is an integer with the value of one of the `VBI_LOG_*`\n   constants enumerated above.\n2. *context*: Is a text string describing the module where the event\n   occurred.\n3. *message*: String with the actual message text.\n4. *user_data*: The object passed as *user_data* parameter to *set_log_fn()*.\n   The parameter is omitted from the call when omitted as parameter to\n   *set_log_fn()*.\n\nNote if you simply want to have the messages printed to *sys.stderr*, you\ncan use `Zvbi.set_log_on_stderr()`_ instead. Also note you can register\nonly one log handler; further registrations will override the previous\none.\n\nZvbi.set_log_on_stderr()\n------------------------\n\n::\n\n    Zvbi.set_log_on_stderr(mask)\n\nThis function enables error logging just like `Zvbi.set_log_fn()`_,\nbut uses the library's internal log function which prints\nall messages to *stderr*, i.e. on the terminal.\n\n*mask* is a bit-wise OR of zero or more of the `VBI_LOG_*`\nconstants. The mask specifies which kind of information to log.\nTo disable logging, pass a zero mask value.\n\nZvbi.par8()\n-----------\n\n::\n\n    par_val = par8(val)\n\nThis function encodes the given 7-bit value with Parity. The\nresult is an 8-bit value in the range 0..255.\nException *ValueError* is raised when the input is out of range.\n\nZvbi.unpar8()\n-------------\n\n::\n\n    val = Zvbi.unpar8(par_val)\n\nThis function decodes the given Parity encoded 8-bit value. The result\nis a 7-bit value in the range 0...127 or a negative value when a\nparity error is detected.  (Note: to decode parity while ignoring\nerrors, simply mask out the highest bit, i.e. val &= 0x7F)\nException *ValueError* is raised when the input is out of range.\n\nZvbi.par_str()\n--------------\n\n::\n\n    byte_str = Zvbi.par_str(data)\n\nThis function encodes a string in an Unicode or bytes-like object with\nparity and returns the result within a bytes object.\n\nZvbi.unpar_str()\n----------------\n\n::\n\n    byte_str = Zvbi.unpar_str(data)\n\nThis function decodes a Parity encoded string and returns the result\nwithin a bytes object. (Note despite the name the characters cannot\nby returned as Python Unicode string, as the encoding is not known.)\n\nZvbi.rev8()\n-----------\n\n::\n\n    val = Zvbi.rev8(val)\n\nThis function reverses the order of all bits of the given 8-bit integer\nvalue and returns the result. This conversion is required for decoding\ncertain teletext elements which are transmitted MSB first instead of the\nusual LSB first (the teletext VBI slicer already inverts the bit order so\nthat LSB are in bit #0)\n\nZvbi.rev16()\n------------\n\n::\n\n    val = Zvbi.rev16(val)\n\nThis function reverses the order of all bits of the given 16-bit integer\nvalue and returns the result.\n\nZvbi.rev16p()\n-------------\n\n::\n\n    val = Zvbi.rev16p(data, offset=0)\n\nThis function reverses all bits of two consecutive bytes in the given\nbytes-like object starting at the given offset and returns them as a\n16-bit integer value.\n\nZvbi.ham8()\n-----------\n\n::\n\n    ham_val = Zvbi.ham8(val)\n\nThis function encodes the given 4-bit integer value (i.e. range 0..15)\nwith Hamming-8/4.  The result is an 8-bit value in the range 0..255.\n\nZvbi.unham8()\n-------------\n\n::\n\n    val = Zvbi.unham8(ham_val)\n\nThis function decodes the given Hamming-8/4 encoded integer value. The\nresult is a 4-bit value, or -1 upon incorrectable errors.\n\nZvbi.unham16p()\n---------------\n\n::\n\n    val = Zvbi.unham16p(data, offset=0)\n\nThis function decodes two Hamming-8/4 encoded bytes (taken from the\nbytes-like object *data* at the given *offset*). The result is an 8-bit\ninteger value, or -1 upon incorrectable errors.\n\nZvbi.unham24p()\n---------------\n\n::\n\n    val = Zvbi.unham24p(data, offset=0)\n\nThis function decodes three Hamming-24/18 encoded bytes (taken from the\nbytes-like object *data* at the given *offset*). The result is a 12-bit\ninteger value, or -1 upon incorrectable errors.\n\nZvbi.dec2bcd()\n--------------\n\n::\n\n    bcd = Zvbi.dec2bcd(dec)\n\nConverts an integer value (i.e. a regular two's complement encoded binary\nvalue) in range 0 ... 999 into a packed BCD number (binary coded decimal)\nin range  0x000 ... 0x999, where each hex nibble is in range 0..9.\nException *ValueError* is raised when the input is out of range.\n\nZvbi.bcd2dec()\n--------------\n\n::\n\n    dec = Zvbi.bcd2dec(bcd)\n\nConverts a packed BCD number in range 0x000 ... 0xFFF into a regular\ninteger value (i.e. two's complement binary) in range 0 ... 999.\nException *ValueError* is raised when the input is out of range or\ninvalid BCD.\n\nZvbi.add_bcd()\n--------------\n\n::\n\n    bcd_sum = Zvbi.add_bcd(bcd1, bcd2)\n\nAdds two packed BCD numbers, returning a packed BCD sum. Arguments\nand result are in range 0xF0000000 ... 0x09999999, that\nis -10**7 ... +10**7 - 1 in decimal notation. To subtract you can\nadd the 10's complement, e. g. -1 = 0xF9999999.\n\nThe return value is a packed BCD number.  Exception *ValueError* is raised\nwhen the input values are out of range or invalid BCD.\n\nZvbi.is_bcd()\n-------------\n\n::\n\n    yes_no = Zvbi.is_bcd(bcd)\n\nTests if *bcd* forms a valid BCD number. The argument must be\nin range 0x00000000 ... 0x09999999. Return value is 0 if *bcd*\ncontains hex digits 0xA ... 0xF.\n\nZvbi.decode_vps_cni()\n-------------------------\n\n::\n\n    cni = Zvbi.decode_vps_cni(data)\n\nThis function takes a sliced VPS line in form of a bytes-like object\nholding at least 13 bytes. The function decodes the network identifier and\nreturns it as a 16-bit CNI value. The function raises exception\n*ZvbiError* in case of errors.\n\nZvbi.encode_vps_cni()\n-------------------------\n\n::\n\n    byte_str = Zvbi.encode_vps_cni(cni)\n\nThis function receives a 16-bit CNI value and returns a VPS line,\nor raises exception *ZvbiError* in case of an invalid CNI value that\ncannot be encoded (e.g. out of range)\n\nZvbi.rating_string()\n--------------------\n\n::\n\n    rating = Zvbi.rating_string(auth, id)\n\nTranslate a program rating code given by *auth* and *id* into a\nstring, native language.  Raises exception *Zvbi.Error* if this\ncode is undefined. The input parameters will usually originate from\nelements *ev.rating_auth* and *ev.rating_id*, provided within an instance\nof type *Zvbi.ProgInfo* for an event of type `VBI_EVENT_PROG_INFO` raised\nby `Zvbi.ServiceDec event handling`_.\n\nZvbi.prog_type_string()\n-----------------------\n\n::\n\n    prog_type = Zvbi.prog_type_string(classf, id)\n\nTranslate a *vbi_program_info* program type code into string, currently\nEnglish only. Raises exception *Zvbi.Error* if this code is undefined.\n\nThe input parameters will usually originate from elements *ev.type_classf*\nand *ev.type_id_0* et.al., provided within an instance of type\n*Zvbi.ProgInfo* for an event of type `VBI_EVENT_PROG_INFO` raised by\n`Zvbi.ServiceDec event handling`_.\n\nZvbi.iconv_caption()\n--------------------\n\n::\n\n    str = Zvbi.iconv_caption(src, repl_char=None)\n\nConverts a string of EIA 608 Closed Caption characters into a Unicode\nstring.  The function ignores parity bits and the bytes 0x00 ... 0x1F,\nexcept for two-byte special and extended characters (e.g. music note 0x11\n0x37)  See also *caption_unicode()*.\n\nThe optional second parameter *repl_char* specifies an UCS-2 replacement\nfor characters that are not representable with standard Unicode code\npoints.  The parameter is expected in form of a string containing a single\ncharacter. When omitted, the function will raise exception *Zvbi.Error* if\nthe source buffer contains unrepresentable characters.\n\nReturns the converted string as an Unicode object. The function raises\nexception *Zvbi.Error* when the source buffer contains non-representable\ncode points, or when the conversion fails, or when it runs out of memory.\n\nZvbi.caption_unicode()\n----------------------\n\n::\n\n    str = Zvbi.caption_unicode(c, to_upper=False)\n\nConverts a single Closed Caption character code into a Unicode string.\nCodes in range 0x1130 to 0x1B3F are special and extended characters\n(e.g. caption command 11 37).\n\nInput character codes in *c* are in ranges:\n\n* 0x0020 ... 0x007F\n* 0x1130 ... 0x113F\n* 0x1930 ... 0x193F\n* 0x1220 ... 0x123F\n* 0x1A20 ... 0x1A3F\n* 0x1320 ... 0x133F\n* 0x1B20 ... 0x1B3F\n\nWhen True is passed as optional second parameter, the character is converted\ninto upper case. (Often programs are captioned in all upper case, but\nexcept for one character the basic and special CC character sets contain\nonly lower case accented characters.)\n\n\nExamples\n========\n\nThe `examples` sub-directory in the *Zvbi* package contains a number of\nscripts used to test the various interface functions. You can also use\nthem as examples for your code.\n\n**Note**: Example command lines for scripts capturing directly from a\nDVB/VBI device shown below do not include options required for configuring\nthe device. Generally, you'll need either\n`--device /dev/dvb/adapter0/demux0 --pid PID` for DVB, or\n`--device /dev/vbi0` for analog capture devices.\nThe VBI PID value can often be derived from the PID for video in\n`channels.conf` by adding offsets in range 3 to 30. Alternatively you can\nlook up the PID via Internet services such as <https://www.satindex.de/>.\n\n:capture.py:\n    Example for the use of class `Zvbi.Capture`_.\n    The script captures VBI data from a device and slices it. The result\n    can be dumped for the various data services in form of hex-string plus\n    roughly decoded text (where applicable) for inspection of incoming\n    data. Altnernatively, output can be written to STDOUT in binary format\n    for further processing (decoding) by piping the data into one of the\n    following example scripts.  Call with option `--help` for a list\n    of options.\n    (This is a translation of `test/capture.c` in the libzvbi package.)\n\n:decode.py:\n    Example for the use of class `Zvbi.ServiceDec`_.\n    Decodes sliced VBI data on STDIN, e.g. ::\n\n      ./capture.py --sliced | ./decode.py --ttx\n\n    Call with option `--help` for a list of options.\n    (This is a direct translation of `test/decode.c` in the libzvbi package.)\n\n:caption.py:\n    Example for the use of class `Zvbi.ServiceDec`_, type\n    *Zvbi.VBI_EVENT_CAPTION*.  When called without an input stream, the\n    application opens a GUI displaying a demo messages sequente (character\n    sets etc.) for debugging the decoder. For displaying live CC streams\n    you can use the following: ::\n\n      ./capture.py --sliced | ./caption.py\n\n    The buttons on top of the GUI switch between Closed Caption channels\n    1-4 and Text channels 1-4.\n    (This is a translation of `test/caption.c` in the libzvbi package,\n    albeit based on TkInter here.)\n\n:export.py:\n    Example for the use of export actions in class `Zvbi.Export`_. The\n    script captures from a device until the specified Teletext page (range\n    100-8FF) or Closed Caption page (range 1-8) is found and then exports\n    the page content in the requested format. The format is specified as\n    first parameter and the page number as second parameter on the command\n    line. Alternatively, the script can be used to continuously export a\n    single or all received pages. Examples: ::\n\n      ./export.py text 100       # teletext page 100 as text\n      ./export.py text all       # continuously all teletext pages\n      ./export.py --loop text 1  # continuously closed caption\n      ./export.py \"png;reveal=1\" 100 > page_100.png\n\n    Use ./explist.py for listing supported export formats (aka \"modules\")\n    and possible options. Note options are appended to the module name,\n    separated by semicolon as shown in the second example.\n    (This is a translation of `test/export.c` in the libzvbi package, plus\n    support for Closed Caption)\n\n:explist.py:\n    Example for the use of export option management in class `Zvbi.Export`_.\n    Test of page export options and menu interfaces.  The script lists\n    all available export modules (i.e. formats) and options.\n    (This is a direct translation of `test/explist.c` in the libzvbi package.)\n\n:hamm.py:\n    Automated test of the odd parity and Hamming encoder and decoder functions.\n    Note this test runs for a long time.\n    (This is a direct translation of `test/hamm.c` in the libzvbi package.)\n\n:network.py:\n    Example for the use of class `Zvbi.ServiceDec`_, type *Zvbi.VBI_EVENT_NETWORK*.\n    This script shows how to identify a network from data transmitted in\n    XDS packets, Teletext packet 8/30 format 1 and 2, and VPS packets.\n    The script captures directly from a device until the currently tuned\n    channel is identified by means of VPS, PDC et.al.\n    (This is a direct translation of `examples/network.c` in the libzvbi package.)\n\n:proxy-test.py:\n    Example for the use of class `Zvbi.Proxy`_.\n    The script can capture either from a proxy daemon or a local device and\n    dumps captured data on the terminal. Also allows changing services and\n    channels during capturing (e.g. by entering \"+ttx\" or \"-ttx\" on stdin.)\n    Start with option `-help` for a list of supported command line options.\n    (This is a direct translation of `test/proxy-test.c` in the libzvbi package.)\n\n:test-vps.py:\n    This script contains tests for encoding and decoding the VPS data service on\n    randomly generated data.\n    (This is a direct translation of `test/test-vps.c` in the libzvbi package.)\n\n:search-ttx.py:\n    Example for the use of class `Zvbi.Search`_ and for multi-threading.\n    The script captures and caches teletext pages in a separate thread.\n    The main thread displays the progress of captured pages until the\n    RETURN key is pressed, then prompts for a search string.  A search\n    across cached teletext pages is started, and the content of matching\n    pages is printed on the terminal.\n\n:browse-ttx.py:\n    Example for the use of classes `Zvbi.Page`_ and `Zvbi.Export`_ for\n    rendering teletext pages. The script captures teletext from a given\n    device and renders selected teletext pages in a simple GUI using\n    TkInter.\n\n:osc.py:\n    Example for the use of class `Zvbi.RawDec`_.\n    The script continuously captures raw VBI data and displays the data as\n    an animated gray-scale image. Below this, the analog wave line of one\n    selected video line is plotted (i.e. essentially simulating an\n    oscilloscope). For the selected line, the resulting data from slicing\n    is also shown if decoding is successful.\n    (This script is loosely based on `test/osc.c` in the libzvbi package.)\n\n:dvb-mux.py:\n    Example for the use of class `Zvbi.DvbMux`_.\n    This script excercises the DVB multiplexer functions: The script first\n    opens a capture device (normally this will be an analog device, as the\n    goal is forwarding VBI services from analog to digital domain), then\n    continuously captures VBI data, encodes it in a DVB packet stream and\n    wites the result to STDOUT. The output stream can be decoded\n    equivalently to that of capture.py, which is:\n\n        ./dvb-mux.py | ./decode.py --pes --all\n\n:dvb-demux.py:\n    Example for the use of class `Zvbi.DvbDemux`_.  This script excercises\n    the DVB de-multiplexer functions: The script directly opens a DVB\n    capture device, and reads the incoming packets. The de-multiplexer is\n    used to extract VBI packets, which are then forwarded to STDOUT.  The\n    output stream can be decoded equivalently to that of capture.py, which\n    is: ::\n\n      ./dvb-demux.py --sliced | ./decode.py --ttx\n\n    **Note**: Instead of reading from the device directly (and performing\n    device ioctl with hard-coded constants, which is prone to breakage)\n    you should normally use the `Zvbi.Capture`_ class which does that work\n    for you.  Using the `Zvbi.DvbDemux`_ class directly only is useful\n    when receiving a stream from other sources (e.g. via socket from\n    proxy on a remote host).\n\nAuthors\n=======\n\nThe ZVBI Perl interface module (https://metacpan.org/pod/Video::ZVBI)\nwas written by T. Zoerner <tomzo@sourceforge.net> starting March 2006\nfor the Teletext EPG grabber accompanying nxtvepg\n(http://nxtvepg.sourceforge.net/). The Perl module was ported to Python\nin April 2020. Its official home is at https://pypi.org/project/Zvbi/\n\nThe module is based on the libzvbi library, mainly written and maintained\nby Michael H. Schimek (2000-2007) and Inaki Garcia Etxebarria (2000-2001),\nwhich in turn is based on AleVT 1.5.1 by Edgar Toernig (1998-1999).\nSee also http://zapping.sourceforge.net/\n\nLicense\n=======\n\nCopyright (C) 2006-2020 T. Zoerner.\n\nParts of the descriptions in this man page are copied from the\n\"libzvbi\" documentation, licensed under the GNU General Public\nLicense version 2 or later. The respective copyright is by the following:\n\n* Copyright (C) 2000-2007 Michael H. Schimek,\n* Copyright (C) 2000-2001 Inaki Garcia Etxebarria,\n* Copyright (C) 2003-2004 Tom Zoerner.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut **without any warranty**; without even the implied warranty of\n**merchantability** or **fitness for a particular purpose**.  See the\n*GNU General Public License* for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/tomzox/Python-ZVBI",
    "keywords": "teletext,videotext,closed-caption,VPS,WSS,VBI,DVB,video,capture,decoder,libzvbi,ETSI",
    "license": "GNU GPLv2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Zvbi",
    "package_url": "https://pypi.org/project/Zvbi/",
    "platform": "posix",
    "project_url": "https://pypi.org/project/Zvbi/",
    "project_urls": {
      "Homepage": "https://github.com/tomzox/Python-ZVBI"
    },
    "release_url": "https://pypi.org/project/Zvbi/0.1.1/",
    "requires_dist": null,
    "requires_python": ">=3.2",
    "summary": "Interface to the Zapping VBI decoder library",
    "version": "0.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 7357830,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "866b99f671180f617e6c5870d394043940b87d580d76b1c072f92be362ecc42e",
          "md5": "8ae3c76ffad94887b00bde9ce3e0d370",
          "sha256": "bda4053e8879152926618bb6b5c53d640cacbedf78d19b879f0f5e6db4473e19"
        },
        "downloads": -1,
        "filename": "Zvbi-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "8ae3c76ffad94887b00bde9ce3e0d370",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.2",
        "size": 235362,
        "upload_time": "2020-05-22T19:39:28",
        "upload_time_iso_8601": "2020-05-22T19:39:28.927564Z",
        "url": "https://files.pythonhosted.org/packages/86/6b/99f671180f617e6c5870d394043940b87d580d76b1c072f92be362ecc42e/Zvbi-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0ecada8b85dffc8dd2f72ccaec3640100d6582ecd3227affa814f66bd4f75683",
          "md5": "c200d25b65ce3ac6e73f4bc673079717",
          "sha256": "ecac56f440a4297442fcd07db3d55f49786a702b6ed61339c0696050e61ab314"
        },
        "downloads": -1,
        "filename": "Zvbi-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "c200d25b65ce3ac6e73f4bc673079717",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.2",
        "size": 245218,
        "upload_time": "2020-05-30T07:28:03",
        "upload_time_iso_8601": "2020-05-30T07:28:03.659276Z",
        "url": "https://files.pythonhosted.org/packages/0e/ca/da8b85dffc8dd2f72ccaec3640100d6582ecd3227affa814f66bd4f75683/Zvbi-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0ecada8b85dffc8dd2f72ccaec3640100d6582ecd3227affa814f66bd4f75683",
        "md5": "c200d25b65ce3ac6e73f4bc673079717",
        "sha256": "ecac56f440a4297442fcd07db3d55f49786a702b6ed61339c0696050e61ab314"
      },
      "downloads": -1,
      "filename": "Zvbi-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "c200d25b65ce3ac6e73f4bc673079717",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.2",
      "size": 245218,
      "upload_time": "2020-05-30T07:28:03",
      "upload_time_iso_8601": "2020-05-30T07:28:03.659276Z",
      "url": "https://files.pythonhosted.org/packages/0e/ca/da8b85dffc8dd2f72ccaec3640100d6582ecd3227affa814f66bd4f75683/Zvbi-0.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}