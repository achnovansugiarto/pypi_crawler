{
  "info": {
    "author": "Nickolai Beloguzov",
    "author_email": "nickolai.beloguzov@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# Robust JSON\n\nThe robust-json package is a lightweight, but capable library for working with JSON files and objects in Python.\n\n## Installation\n\n<!--- TODO Add link to PyPI --->\n\nYou can install this package directly from [PyPI](https://pypi.org/project/robust-json/):\n\n    pip install robust-json\n\nThis library is supported on python 3.x only.\n\n## Contributing\n\nIf you want to improve this project, first discuss your idea by opening a new issue. After that fork this repository and implement this awesome feature or fix this annoying bug. Then create a new PR and wait for approval.\n\n_Note: please read [contributing.md](https://github.com/NickolaiBeloguzov/robust-json/blob/master/CONTRIBUTING.md) file first. There you can find code of conduct and useful information regarding contribution process._\n\n## Modules\n\nThis library includes 4 modules:\n\n-   [**file**](#file-mod): This module provides functionality for working with JSON files.\n-   [**object**](#obj-mod): This module provides functionality for working with JSON objects (Python dictionaries)\n    _Note: the difference between file and object modules is that during initialization 'file' module expects path to JSON file while 'object' module expects a Python dictionary. For more information please read corresponding sections._\n-   [**errors**](#err-mod): This module contains all exceptions that may be raised during package runtime.\n-   [**ext**](#ext-mod): This module provides some extra functions that can be helpful while working with JSON.\n\n## File module overview\n\n<div id='file-mod'><div>\n\nThis module provides various methods for working with JSON files through _JsonFileParser_ class. It automatically parses and loads valid JSON from specified file and also checks if file is ready for processing. To access it, simply import _JsonFileParser_ from file module:\n\n    from robust_json.file import JsonFileParser\n\nand initialize it:\n\n    op = JsonFileParser(path_to_json_file)\n\n_Note: JsonFileParser now supports autosaving. If enabled, module will save active object after every change made to it and write it to specified file._\n\nTo enable autosaving simply initialize this module with `autosave` parameter set to `True`:\n```\n  op = JsonFileParser(path_to_json_file, autosave=True)\n```\n_Note: you can also specify file for autosaver. Just pass `autosave_path` parameter with path to your file during initialization, like this:_\n```\n  op = JsonFileParser(path*to_json_file, autosave=True, autosave_path=path_to_autosave_file)\n```\n\n_If file does not exist, module will create one. If file does exist, it will be truncated and filled with serialized active object._\n\nDuring initialization a _JSONFileError_ exception may be raised. This means that parser could not process contents of specified file or file has an unsupported extension. Also during this phase a _FileNotFoundError_ may be raised marking that specified file doesn't exist. An _IncorrectFunctionParameterTypeError_ eception will be raised if one or more of parameters have incorrect types.\n\n### File module methods and properties\n\n-   **Properties**:\n\n    -   **JsonFileParser.file_formats**\n        This property lists all file extensions supported by this module in form of an array. At the moment only _.json_ and _.txt_ files are supported. This is used during class initialization to determine if file can pe processed.\n    -   **JsonFileParser.path**\n        This property returns source file path\n    -   **JsonFileParser.active_json**\n        This property returns JSON object with all the recent changes.\n    -   **JsonFileParser.backup**\n        This property returns the initial JSON object, ignoring all the recent changes.\n        These two last properties may be confusing, so here is an example\n        (_Note: see corresponding documentation section for JsonFileParser.append() function_):\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test1.json') #Class initialization\n        # Contents of 'test1.json' file: {'test_key': 'test_value'}\n\n        op.append('$', {'append_key': 'append_value'})\n        print(op.active_json)\n        # Output: {'test_key': 'test_value', 'append_key': 'append_value'}\n\n        print(op.backup)\n        # Output: {'test_key': 'test_value'}\n\n        # As you can see, JsonFileParser.backup property is equal to initial contents of 'test1.json' file.\n        # This is useful when there is a need to discard all changes to JSON object.\n        ```\n\n-   **Methods**:\n\n    -   **JsonFileParser.get_json_from_file()**\n        This method retrieves all JSON from file and returns it as a Python dictionary. It's called automatically when specified file is processed for the first time.\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test1.json') # JsonFileParser.get_json_from_file() function is called here\n        ```\n\n    -   **JsonFileParser.get_key_value(json_path: str)**\n        This method accesses a value from specific key:value pair in JSON object and returns it.\n        _json_path:str_ parameter specifies a path to key:value pair (e.g. field0.field1.[...].fieldn).\n        Example:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test2.json')\n        # Contents of 'test2.json' file: {'test_key': 'test_value', 'test_arr': [1, 2, 3]}\n\n        val = op.get_key_value('test_key')\n        print(val)\n        # Output: 'test_value'\n\n        # You can use this method to retrieve an element from JSON array\n        val = op.get_key_value('test_arr[1]')\n        print(val)\n        # Output: 2\n        ```\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ if its parameter has an incorrect type. This function will also raise a _JSONPathError_ if specified JSON path is not valid (does not exist or could not be accessed).\n\n    -   **JsonFileParser.append(json_path: str, append_value: any, append_at_end: bool = False)**\n        This method appends value to existing JSON object and returns a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path where new value will be added. To append value to the root of JSON object, _json_path_ needs to be equal to '$'. _append_value:any_ parameter specifies a value that will be appended. _append_at_end:bool_ controls the behaviour of this function regarding JSON arrays of objects (structures like this: [{}, {}, {}, ...]) and general arrays (structures like this: [a, b, c, ...]). It has no influence on other structures. If set to False, function will try to add given value to each object of an array. If set to True, function will try to append given value at the end of an array. (see examples below). This function will return a Python dictionary with updated JSON.\n\n        This function will raise a _IncorrectFunctionParameterTypeEroor_ exception if its parameter(-s) has(-ve) an incorrect type. This function will also raise a _ValueError_ exception if 'append*value' is empty (is equal to empty string, empty array, empty dictionary, etc.). This function will raise a \\_JSONPathError* if provided path is not valid (does not exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Adding a simple key:value pair to the root of an object\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test3.json')\n        # Contents of 'test3.json' file: {'test_key': 'test_value'}\n\n        op.append('$', {'add_key': 'add_var'})\n        print(op.active_json)\n        # Output: {'test_key': 'test_value', 'add_key': 'add_var'}\n        ```\n\n        Adding new object to the array of objects\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('users.json')\n        # Contents of 'users.json' file: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        op.append('users', {'id': 3, 'name': 'Liza'})\n        print(op.active_json)\n        # Output: {'users': [{'id': 3, 'name': 'Lisa'}, {'id': 3, 'name': 'Lisa'}]}\n\n        # This is not good!\n        # This happened because 'append_at_end' parameter is set to False.\n\n        # Function appended new object to each of the objects in the array and new values have overwritten the old\n        # ones.\n\n        # Note: we can discard these unwanted/malicious changes using JsonFileParser.reset() function with\n        # its parameter set to True. (please refer to corresponding section in docs)\n\n        op.reset(True)\n        print(op.active_json)\n        # Output: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        # We need to set 'append_at_end' parameter to True to avoid this.\n\n        op.append('users', {'id': 3, 'name': 'Liza'}, True)\n        print(op.active_json)\n        # Output: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}, {'id': 3, 'name': 'Lisa'}]}\n        ```\n\n        Adding a key:value pair to each object of an array\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('users.json')\n        # Contents of 'users.json' file: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        op.append('users', {'role': 'guest'})\n        print(op.active_json)\n        # Output: {'users':[{'id':1, 'name':'Ken', 'role':'guest'}, {'id':2, 'name':'Alec', 'role':'guest'}]}\n        ```\n\n        Adding new element to an array of elements:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test4.json')\n        # Contents of 'test4.json' file: {'colors': ['cyan', 'magenta']}\n\n        op.append('colors', 'yellow')\n        print(op.active_json)\n        # Output: {'colors': ['cyan', 'magenta']}\n\n        # Nothing happened.\n        # That's because 'append_at_end' parameter is set to False.\n        # Function tried to append new string to each string and failed.\n        # To fix this, we need to set 'append_at_end' parameter to True.\n\n        op.append('colors', 'yellow', True)\n        print(op.active_json)\n        # Output: {'colors': ['cyan', 'magenta', 'yellow']}\n        ```\n\n    -   **JsonFileParser.update_value(json_path: str, key_or_index: Union[str, int], new_value: any, strict_mode: bool = False)**\n        <div id='file-upd'></div>\n\n        This function will update value in key:value pair and return a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path to key:value pair/array/etc. parent that needs to be updated. (To update value in the root of JSON object, _json_path_ needs to be equal to '$') while _key_or_index:Union[str, int]_ parameter specifies key (if it's an object) or array index (if it's an array). This implies that if we need to update key with path 'field0.field1.upd*key', then \\_json_path* will be equal to 'field0.field1' and _key_or_index_ parameter will be equal to 'upd*key'. \\_Note: if you use an array index while 'json_path' parameter is pointing to JSON object, or if you use a property name while 'json_path' is pointing to JSON array, an exception will be raised* (See examples below). _new_value:any_ specifies value that will overwrite the old one and _strict_mode:bool_ enables Strict Mode. By default this mode is turned off. If turned on, this method will ensure that new value has the same type as the old one (if old value is a string, then the new one also needs to be a string, etc.). If types are not matching, an exception will be raised.\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ exception is its parameter(-s) has(-ve) an incorrect type. This function will also raise a _JSONStrictModeError_ in case of mismatched types if Strict Mode is enabled and a _JSONPathError_ exception if JSON path is not valid (doesn't exist or could not be accessed). This function will raise any additional exceptions if occured.\n\n        Examples:\n\n        Updating key:value pair in root of the object:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test5.json')\n        # Contents of 'test5.json' file: {'app_name': 'HomeCare', 'version', '1.0.0'}\n\n        op.update_value('$', 'version': '1.0.5')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'version': '1.0.5'}\n        ```\n\n        Updating item in an array:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test6.json')\n        # Contents of 'test6.json' file: {'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        op.update_value('authors', 1, 'Nick Rogerson')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogerson']}\n        ```\n\n        ```\n        # Note: if you don't know the index of an item, you can use\n        # 'get_item_index()' function from 'robust_json.ext' module to get it.\n        # (See corresponding section in the docs)\n\n        from robust_json.file import JsonFileParser\n        import robust_json.ext as ext\n\n        op = JsonFileParser('test6.json')\n        # Contents of 'test6.json' file: {'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        # Getting an array for future use\n        authors_array = op.get_key_value('authors')\n        print(authors_array)\n        # Output: ['Alec Hammer', 'Nick Rogers']\n\n        # Finding the index\n        index = ext.get_item_index('Alec Hammer', authors_array, False)\n        print(index)\n        # Output: 0\n\n        #Updating value\n        op.update_value('authors', index, 'Alain Hammer')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Alain Hammer', 'Nick Rogers']}\n        ```\n\n        Updating value with Strict Mode:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test6.json')\n        # Contents of 'test6.json' file: {'app_name': 'HomeCare', 'app_id': 1077}\n\n        op.update_value('$', 'app_id', 'this is a string', True)\n        # A 'StrictModeError' exception was raised.\n        # This happened because new value has a different type.\n        # Let's try again, but with integer.\n\n        op.update_value('$', 'app_id', 1080, True)\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'app_id': 1080}\n        ```\n\n    -   **JsonFileParser.delete(json_path: str, key_or_index: Union[str, int])**\n        This function will delete an element from JSON and return a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path to key:value pair/array/etc. parent that needs to be deleted. (To delete value in the root of JSON object, _json_path_ needs to be equal to '$') while _key_or_index:Union[str, int]_ parameter specifies key (if it's an object) or array index (if it's an array). This implies that if we need to delete key with path 'field0.field1.del*key', then \\_json_path* will be equal to 'field0.field1' and _key_or_index_ parameter will be equal to 'del*key'. \\_Note: if you use an array index while 'json_path' parameter is pointing to JSON object, or if you use a property name while 'json_path' is pointing to JSON array, an exception will be raised* (See examples below).\n        This function will raise an _IncorrectFunctionParameterTypeError_ exception is its parameter(-s) has(-ve) an incorrect type. This function will also raise a _JSONPathError_ exception if JSON path is not valid (doesn't exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Deleting key:value pair in root of the object:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test7.json')\n        # Contents of 'test5.json' file: {'test_key': 'test_val', 'del_key': 'del_val'}\n\n        op.delete('$', 'del_key')\n        print(op.active_json)\n        # Output: {'test_key': 'test_val'}\n        ```\n\n        Deleting item in an array:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test8.json')\n        # Contents of 'test6.json' file: {'app_name': 'PetShopify', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        op.delete('authors', 1)\n        print(op.active_json)\n        # Output: {'app_name': 'PetShopify', 'authors': ['Alec Hammer']}\n        ```\n\n        ```\n        # Note: if you don't know the index of an item, you can use 'get_item_index()'\n        # function from 'robust_json.ext' module to get it. (See corresponding section in the docs)\n\n        from robust_json.file import JsonFileParser\n        import robust_json.ext as ext\n\n        op = JsonFileParser('test9.json')\n        # Contents of 'test6.json' file: {'app_name': 'PetShopify', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        # Getting an array for future use\n        authors_array = op.get_key_value('authors')\n        print(authors_array)\n        # Output: ['Alec Hammer', 'Nick Rogers']\n\n        # Finding the index\n        index = ext.get_item_index('Alec Hammer', authors_array, False)\n        print(index)\n        # Output: 0\n\n        #Updating value\n        op.delete('authors', index)\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Nick Rogers']}\n        ```\n\n    -   **JsonFileParser.minify()**\n        This function will remove all indentations in JSON file. Basically it will compress all JSON into one line.\n\n        This function does not return any value.\n\n    -   **JsonFileParser.prettify(indent: int = 4)**\n        This function will add indentations to JSON in source file to improve its readability. _indent:int_ parameter specifies the number of spaces. By default it is equal to 4. This function is a complete opposite to _JsonFileParser.minify()_\n\n        This function does not return any value.\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ if its parameter has an incorrect type.\n\n    -   **JsonFileParser.reset(discard_active_object: bool = False)**\n        This function will reset active JSON object, removing any changes made to it.\n        _discard_active_object:bool_ parameter controls the behaviour of this function regarding the active JSON object (JsonFileParser.active_json property). If set to False, this method will simply return an initial object and keep all the changes to the actove JSON. If set to True, this function will still return the initial object, but will also reset the active one, and all changes will be gone for good.\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ if its parameter has an incorrect type.\n\n        Examples:\n\n        Getting an intial object and storing it in a variable:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test10.json')\n        # Contents of `test10.json` file: { \"simple_key\": \"simple_value\" }\n\n        op.append('$', { \"test_arr\": [1, 2, 3] })\n        # We appended key:value pair to distinguish objects among each other.\n\n        initial = op.reset()\n        print(initial)\n        # initial = { \"simple_key\": \"simple_value\" }\n\n        print(op.active_json)\n        # Output: { \"simple_key\": \"simple_value\", \"test_arr\": [1, 2, 3] }\n        # Calling this method without parameters simply makes it return initial\n        # object, saving the active one for future use.\n        ```\n\n        Getting an initial object and resetting an active one:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('test10.json')\n        # Contents of `test10.json` file: { \"simple_key\": \"simple_value\" }\n\n        op.append('$', { \"test_arr\": [1, 2, 3] })\n        # We appended key:value pair to distinguish objects among each other.\n\n        initial = op.reset(True)\n        print(initial)\n        # Output: { \"simple_key\": \"simple_value\" }\n\n        print(op.active_json)\n        # Output: { \"simple_key\": \"simple_value\" }\n\n        # Calling this method with 'discard_active_object' set to True.\n        # makes it completely revert all changes to active object, making it\n        # equal to the initial one.\n\n        # Warning!\n        # Note: if called with 'discard_active_object' set to True, there\n        # is no way of going back. All changes will be gone for good.\n        # Please use this with extreme caution!\n        ```\n\n    -   **JsonFileParser.save_to_file(path: str = None, prettify: bool = True, create_file: bool = False)**\n        This function will save active JSON object into file.\n        _path:str_ parameter specifies path to the file. If left empty, active object will be saved into source file. _prettify:bool_ parameter enables indentations. By default it is set to True. If set to False, JSON will be compressed into one line. _create_file:bool_ parameter enables file creation. If set to True, this function will create a new file and save active object there, but obly if _path_ parameter is pointing to non-existing file. _Note: if create_file is set to True ans path is pointing to an existing file, an exception will be raised._\n\n        This function will raise a _JSONFileError_ if end file is not supporting JSON (has an unsupported extension). This function will raise a _FileExistsError_ if _create_file_ is set to True and file already exists under specified path.\n        This function will raise a _FileNotFoundError_ if _create_file_ is set to False and file could not be located under specified path. This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Saving active object to the source file:\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('data.json')\n        # Contents of 'data.json' file: {'name': 'Helen Anderson', 'employee_id': 107756}\n\n        op.update_value('$', 'employee_id', 107744)\n        print(op.active_json)\n        # Output: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        op.save_to_file()\n        # Contents of 'data.json' file: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        # Calling 'save_to_file' method without any arguments makes it\n        # overwrite an object in source file ('data.json' in this case)\n        # with the value of JsonFileParser.active_json property.\n        ```\n\n        Saving active object to a different file (existing):\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('data.json')\n        # Contents of 'data.json' file: {'name': 'Helen Anderson', 'employee_id': 107756}\n\n        op.update_value('$', 'employee_id', 107744)\n        print(op.active_json)\n        # Output: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        op.save_to_file(path='new_data.json')\n        # Contents of 'new_data.json' file: {'name': 'Helen Anderson', 'employee_id': 107744}\n        # Calling this function with different 'path' parameter will\n        # make this function save the value of JsonFileParser.active_json property into\n        # existing file ('new_data.json' in this case). But if file cannot be found, a 'FileNotFoundError'\n        # exception will be raised.\n        ```\n\n        Saving active object to a different file (non-existing):\n\n        ```\n        from robust_json.file import JsonFileParser\n\n        op = JsonFileParser('data.json')\n        # Contents of 'data.json' file: {'name': 'Helen Anderson', 'employee_id': 107756}\n\n        op.update_value('$', 'employee_id', 107744)\n        print(op.active_json)\n        # Output: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        op.save_to_file(path='new_data.json')\n        # A 'FileNotFoundError' exception has been raised.\n        # It happened because this file does not exist.\n        # To fix this we need to set 'create_file' parameter to True.\n\n        op.save_to_file(path='new_data.json', create_file=True)\n        # Contents of 'new_data.json' file: {'name': 'Helen Anderson', 'employee_id': 107744}\n        # Calling the function with 'create_file' set to True and different path makes it create\n        # a new file and save the value of JsonFileParser.active_json property there.\n        # But if file already exists, a 'FileExistsError' will be raised.\n        ```\n\n## Object module overview\n\n<div id='obj-mod'>(robust_json.object)</div>\n\nThis module provides various methods for working with JSON object directly through _JsonObjectParser_ class. This class is specifically designed to work with JSON received from API calls or to be used in APIs. To access it, simply import _JsonObjectParser_ from file module:\n\n    from robust_json.object import JsonObjectParser\n\nand initialize it:\n\n    op = JsonObjectParser(json_obj)\n\n_Note: JsonObjectParser now supports autosaving. If enabled, module will save active object after every change made to it and write it to specified file._\n\nTo enable autosaving simply initialize this module with `autosave` parameter set to `True`:\n```\n  op = JsonObjectParser(json_object, autosave=True)\n```\n_Note: you can also specify file for autosaver. Just pass `autosave_path` parameter with path to your file during initialization, like this:_\n```\n  op = JsonObjectParser(json_object, autosave=True, autosave_path=path_to_autosave_file)\n```\n\n_If file does not exist, module will create one. If file does exist, it will be truncated and filled with serialized active object._\n\nDuring initialization a _IncorrectFunctionParameterTypeError_ exception may be raised. This means that _json_ parameter has an incorrect type.\n\n### Object module methods and properties\n\n-   **Properties**:\n\n    -   **JsonObjectParser.active_json**\n        This property returns JSON object with all the recent changes.\n    -   **JsonObjectParser.backup**\n        This property returns the initial JSON object, ignoring all the recent changes.\n        These two last properties may be confusing, so here is an example\n        (_Note: see corresponding documentation section for JsonObjectParser.append() function_):\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'test_key': 'test_value'}\n\n        op = JsonObjectParser(obj) #Class initialization\n\n\n        op.append('$', {'append_key': 'append_value'})\n        print(op.active_json)\n        # Output: {'test_key': 'test_value', 'append_key': 'append_value'}\n\n        print(op.backup)\n        # Output: {'test_key': 'test_value'}\n\n        # As you can see, JsonObjectParser.backup property is equal to initial object.\n        # This is useful when there is a need to discard all changes to JSON object.\n        ```\n\n-   **Methods**:\n\n    -   **JsonObjectParser.get_key_value(json_path: str)**\n        This method accesses a value from specific key:value pair in JSON object and returns it.\n        _json_path:str_ parameter specifies a path to key:value pair (e.g. field0.field1.[...].fieldn).\n        Example:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'test_key': 'test_value', 'test_arr': [1, 2, 3]}\n\n        op = JsonObjectParser(obj)\n\n\n        val = op.get_key_value('test_key')\n        print(val)\n        # Output: 'test_value'\n\n        # You can use this method to retrieve an element from JSON array\n        val = op.get_key_value('test_arr[1]')\n        print(val)\n        # Output: 2\n        ```\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ is its parameter has an incorrect type. This function will also raise a _JSONPathError_ if specified JSON path is not valid (does not exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n    -   **JsonObjectParser.append(json_path: str, append_value: any, append_at_end: bool = False)**\n        This method appends value to existing JSON object and returns a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path where new value will be added. To append value to the root of JSON object, _json_path_ needs to be equal to '$'. _append_value:any_ parameter specifies a value that will be appended. _append_at_end:bool_ controls the behaviour of this function regarding JSON arrays of objects (structures like this: [{}, {}, {}, ...]) and general arrays (structures like this: [a, b, c, ...]). It has no influence on other structures. If set to False, function will try to add given value in each object of an array. If set to True, function will try to append given value at the end of an array. (see examples below). This function will return a Python dictionary with updated JSON.\n\n        This function will raise a _IncorrectFunctionParameterTypeEroor_ exception if its parameter(-s) has(-ve) an incorrect type. This function will also raise a _ValueError_ exception if 'append*value' is empty (empty string, empty array, empty dictionary). This function will raise a \\_JSONPathError* if provided path is not valid (does not exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Adding a simple key:value pair to the root of an object\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'test_key': 'test_value'}\n\n        op = JsonObjectParser(obj)\n\n        op.append('$', {'add_key': 'add_var'})\n        print(op.active_json)\n        # Output: {'test_key': 'test_value', 'add_key': 'add_var'}\n        ```\n\n        Adding new object to the array of objects\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        op = JsonObjectParser(obj)\n\n        op.append('users', {'id': 3, 'name': 'Liza'})\n        print(op.active_json)\n        # Output: {'users': [{'id': 3, 'name': 'Lisa'}, {'id': 3, 'name': 'Lisa'}]}\n\n        # This is not good!\n        # This happened because 'append_at_end' parameter is set to False.\n\n        # Function appended new object to each of the objects in the array and new values overwrote the old\n        # ones.\n\n        # Note: we can discard these unwanted/malicious changes using JsonObjectParser.reset() function with\n        # its parameter set to True. (please refer to corresponding section in docs)\n\n        op.reset(True)\n        print(op.active_json)\n        # Output: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        # We need to set 'append_at_end' parameter to True to avoid this.\n\n        op.append('users', {'id': 3, 'name': 'Liza'}, True)\n        print(op.active_json)\n        # Output: {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}, {'id': 3, 'name': 'Lisa'}]}\n        ```\n\n        Adding a key:value pair to each object of an array\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'users': [{'id': 1, 'name': 'Ken'}, {'id': 2, 'name': 'Alec'}]}\n\n        op = JsonObjectParser(obj)\n\n        op.append('users', {'role': 'guest'})\n        print(op.active_json)\n        # Output: {'users':[{'id':1, 'name':'Ken', 'role':'guest'}, {'id':2, 'name':'Alec', 'role':'guest'}]}\n        ```\n\n        Adding new element to an array of elements:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'colors': ['cyan', 'magenta']}\n\n        op = JsonObjectParser(obj)\n\n        op.append('colors', 'yellow')\n        print(op.active_json)\n        # Output: {'colors': ['cyan', 'magenta']}\n\n        # Nothing happened\n        # That's because 'append_at_end' parameter is set to False\n        # Function tried to append new string to each string and failed\n        # To fix this, we need to set 'append_at_end' parameter to True\n\n        op.append('colors', 'yellow', True)\n        print(op.active_json)\n        # Output: {'colors': ['cyan', 'magenta', 'yellow']}\n        ```\n\n    -   **JsonObjectParser.update_value(json_path: str, key_or_index: Union[str, int], new_value: any, strict_mode: bool = False)**\n        <div id='obj-upd'></div>\n\n        This function will updaate value in key:value pair and return a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path to key:value pair/array/etc. parent that needs to be updated. (To update value in the root of JSON object, _json_path_ needs to be equal to '$') while _key_or_index:Union[str, int]_ parameter specifies key (if it's an object) or array index (if it's an array). This implies that if we need to update key with path 'field0.field1.upd*key', then \\_json_path* will be equal to 'field0.field1' and _key_or_index_ parameter will be equal to 'upd*key'. \\_Note: if you use an array index while 'json_path' parameter is pointing to JSON object, or if you use a property name while 'json_path' is pointing to JSON array, an exception will be raised* (See examples below). _new_value:any_ specifies value that will overwrite the old one and _strict_mode:bool_ enables Strict Mode. By default this mode is turned off. If turned on, this method will ensure that new value has the same type as the old one (if old value is a string, then the new one also needs to be a string, etc.). If types are not matching, an exception will be raised.\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ exception is its parameter(-s) has(-ve) an incorrect type. This function will also raise a _JSONStrictModeError_ in case of mismatched types if Strict Mode is enabled and a _JSONPathError_ exception if JSON path is not valid (doesn't exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Updating key:value pair in root of the object:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        op = JsonObjectParser({'app_name': 'HomeCare', 'version', '1.0.0'})\n\n        op.update_value('$', 'version': '1.0.5')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'version': '1.0.5'}\n        ```\n\n        Updating item in an array:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        op = JsonObjectParser({'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogers']})\n\n        op.update_value('authors', 1, 'Nick Rogerson')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogerson']}\n        ```\n\n        ```\n        # Note: if you don't know the index of an item, you can use 'get_item_index()'\n        # function from 'robust_json.ext' module to get it. (See corresponding section in the docs)\n\n        from robust_json.object import JsonObjectParser\n        import robust_json.ext as ext\n\n        op = JsonObjectParser({'app_name': 'HomeCare', 'authors': ['Alec Hammer', 'Nick Rogers']})\n\n        # Getting an array for future use\n        authors_array = op.get_key_value('authors')\n        print(authors_array)\n        # Output: ['Alec Hammer', 'Nick Rogers']\n\n        # Finding the index\n        index = ext.get_item_index('Alec Hammer', authors_array, False)\n        print(index)\n        # Output: 0\n\n        #Updating value\n        op.update_value('authors', index, 'Alain Hammer')\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Alain Hammer', 'Nick Rogers']}\n        ```\n\n        Updating value with Strict Mode:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        op = JsonObjectParser({'app_name': 'HomeCare', 'app_id': 1077})\n\n        op.update_value('$', 'app_id', 'this is a string', True)\n        # An 'StrictModeError' was raised\n        # This happened because new value has a different type\n        # Let's try again, but with integer\n\n        op.update_value('$', 'app_id', 1080, True)\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'app_id': 1080}\n        ```\n\n    -   **JsonObjectParser.delete(json_path: str, key_or_index: Union[str, int])**\n        This function will delete an element from JSON and return a Python dictionary with updated contents.\n        _json_path:str_ parameter specifies a path to key:value pair/array/etc. parent that needs to be deleted. (To delete value in the root of JSON object, _json_path_ needs to be equal to '$') while _key_or_index:Union[str, int]_ parameter specifies key (if it's an object) or array index (if it's an array). This implies that if we need to delete key with path 'field0.field1.del*key', then \\_json_path* will be equal to 'field0.field1' and _key_or_index_ parameter will be equal to 'del*key'. \\_Note: if you use an array index while 'json_path' parameter is pointing to JSON object, or if you use a property name while 'json_path' is pointing to JSON array, an exception will be raised* (See examples below).\n        This function will raise an _IncorrectFunctionParameterTypeError_ exception is its parameter(-s) has(-ve) an incorrect type. This function will also raise a _JSONPathError_ exception if JSON path is not valid (doesn't exist or could not be accessed). This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Deleting key:value pair in root of the object:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'test_key': 'test_val', 'del_key': 'del_val'}\n\n        op = JsonObjectParser(obj)\n\n\n        op.delete('$', 'del_key')\n        print(op.active_json)\n        # Output: {'test_key': 'test_val'}\n        ```\n\n        Deleting item in an array:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        op = JsonObjectParser('test8.json')\n        # Contents of 'test6.json' file: {'app_name': 'PetShopify', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        op.delete('authors', 1)\n        print(op.active_json)\n        # Output: {'app_name': 'PetShopify', 'authors': ['Alec Hammer']}\n        ```\n\n        ```\n        # Note: if you don't know the index of an item, you can use 'get_item_index()'\n        # function from 'robust_json.ext' module to get it. (See corresponding section in the docs)\n\n        from robust_json.object import JsonObjectParser\n        import robust_json.ext as ext\n\n        obj = {'app_name': 'PetShopify', 'authors': ['Alec Hammer', 'Nick Rogers']}\n\n        op = JsonObjectParser(obj)\n\n\n        # Getting an array for future use\n        authors_array = op.get_key_value('authors')\n        print(authors_array)\n        # Output: ['Alec Hammer', 'Nick Rogers']\n\n        # Finding the index\n        index = ext.get_item_index('Alec Hammer', authors_array, False)\n        print(index)\n        # Output: 0\n\n        #Updating value\n        op.delete('authors', index)\n        print(op.active_json)\n        # Output: {'app_name': 'HomeCare', 'authors': ['Nick Rogers']}\n        ```\n\n    -   **JsonObjectParser.reset(discard_active_object: bool = False)**\n        This function will reset active JSON object, removing any changes made to it.\n        _discard_active_object:bool_ parameter controls the behaviour of this function regarding the active JSON object (JsonObjectParser.active_json property). If set to False, this method will simply return an initial object and keep all the changes to the actove JSON. If set to True, this function will still return the initial object, but will also reset the active one, and all changes will be gone for good.\n\n        This function will raise an _IncorrectFunctionParameterTypeError_ if its parameter has an incorrect type. This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Getting an intial object and storing it in a variable:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = { \"simple_key\": \"simple_value\" }\n\n        op = JsonObjectParser(obj)\n\n        op.append('$', { \"test_arr\": [1, 2, 3] })\n        # We appended key:value pair to distinguish objects among each other\n\n        initial = op.reset()\n        print(initial)\n        # initial = { \"simple_key\": \"simple_value\" }\n\n        print(op.active_json)\n        # Output: { \"simple_key\": \"simple_value\", \"test_arr\": [1, 2, 3] }\n        # Calling this method without parameters simply makes it return initial\n        # object, saving the active one for future use\n        ```\n\n        Getting an initial object and resetting an active one:\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = { \"simple_key\": \"simple_value\" }\n\n        op = JsonObjectParser(obj)\n\n        op.append('$', { \"test_arr\": [1, 2, 3] })\n        # We appended key:value pair to distinguish objects among each other\n\n        initial = op.reset(True)\n        print(initial)\n        # Output: { \"simple_key\": \"simple_value\" }\n\n        print(op.active_json)\n        # Output: { \"simple_key\": \"simple_value\" }\n\n        # Calling this method with 'discard_active_object' set to True\n        # makes it completely revert all changes to active object, making it\n        # equal to the initial one.\n\n        # Warning!\n        # Note: if called with 'discard_active_object' set to True, there\n        # is no way of going back. All changes will be gone for good.\n        # Please use this with extreme caution!\n        ```\n\n    -   **JsonObjectParser.save_to_file(path: str, prettify: bool = True, create_file: bool = False)**\n        This function will save active JSON object into file.\n        _path:str_ parameter specifies path to the file. _prettify:bool_ parameter enables indentations. By default it is set to True. If set to False, JSON will be compressed into one line. _create_file:bool_ parameter enables file creation. If set to True, this function will create a new file and save active object there, but obly if _path_ parameter is pointing to non-existing file. _Note: if create_file is set to True ans path is pointing to an existing file, an exception will be raised._\n\n        This function will raise a _JSONFileError_ if end file is not supporting JSON (has an unsupported extension). This function will raise a _FileExistsError_ if _cheate_file_ is set to True and file already exists under specified path.\n        This function will raise a _FileNotFoundError_ if _create_file_ is set to False and file could not be located under specified path. This function will raise any additional exceptions if occurred.\n\n        Examples:\n\n        Saving active object to a file (existing):\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'name': 'Helen Anderson', 'employee_id': 107756}\n\n        op = JsonObjectParser(obj)\n\n        op.update_value('$', 'employee_id', 107744)\n        print(op.active_json)\n        # Output: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        op.save_to_file(path='new_data.json')\n        # Contents of 'new_data.json' file: {'name': 'Helen Anderson', 'employee_id': 107744}\n        # Calling this function with different 'path' parameter will\n        # make this function save the value of JsonObjectParser.active_json property into\n        # existing file ('new_data.json' in this case). But if file cannot be found, a 'FileNotFoundError'\n        # exception will be raised.\n        ```\n\n        Saving active object to a file (non-existing):\n\n        ```\n        from robust_json.object import JsonObjectParser\n\n        obj = {'name': 'Helen Anderson', 'employee_id': 107756}\n\n        op = JsonObjectParser(obj)\n\n\n        op.update_value('$', 'employee_id', 107744)\n        print(op.active_json)\n        # Output: {'name': 'Helen Anderson', 'employee_id': 107744}\n\n        op.save_to_file(path='new_data.json')\n        # A 'FileNotFoundError' exception has been raised.\n        # It happened because this file does not exist.\n        # To fix this we need to set 'create_file' parameter to True.\n\n        op.save_to_file(path='new_data.json', create_file=True)\n        # Contents of 'new_data.json' file: {'name': 'Helen Anderson', 'employee_id': 107744}\n        # Calling the function with 'create_file' set to True and different path makes it create\n        # a new file and save the value of JsonObjectParser.active_json property there.\n        # But if file already exists, a 'FileExistsError' will be raised.\n        ```\n\n## Errors module overview\n\n<div id='err-mod'></div>\n\nThis module contains all custom exceptions that can be raised during package runtime. There are a total of 5: _JSONFileError_, _JSONPathError_, _JSONStrictModeError_, _JSONObjectError_, _IncorrectFunctionParameterTypeError_. If you need to import them, it can be done like this:\n\n```\nimport robust_json.errors as json_err\n```\n\n### **Exceptions**\n\n-   **JSONFileError**\n    This exception indicates that there is an error with JSON file (it has an unsupported extension, cannot be processed, etc.)\n-   **JSONPathError**\n    This exception indicates that JSON path (field0.field1.[...].fieldn) is not valid (cannot be accessed or doesn't exist in the object)\n-   **JSONStrictModeError**\n    This exception can be raised only by [_JsonFileParser.update_value()_](#file-upd) and [_JsonObjectParser.update_value()_](#obj-upd) methods because only these function support Strict Mode at the moment. This exception indicates that there is a type mismatch during update. For further information, you can see the examples of the above mentionned functions in their corresponding sections to see how this works.\n-   **JSONObjectError**\n    This exception indicates that JSON object is not valid (has incorrect format, syntax errors, etc.)\n-   **IncorrectFunctionParameterTypeError**\n    This exception indicates that one or more of function's parameters has incorrect type.\n\n## Extension module overview\n\n<div id='ext-mod'></div>\nThis module provides some useful methods that can reduce development time.\n\n### **Methods**\n\n-   **filter_json_array(json_array: list, field: string, value: any)**\n    This function will filter given array of JSON objects and return it.\n    _json_array:list_ parameter specifies the list that neesd to be filtered, _field:str_ specifies the key and _value:any_ specifies the value. Two last parameters form a key:value pair which takes a role of a filter.\n\n    This function will return a list with filtered content.\n\n    This function will raise an _IncorrectFunctionParameterTypeError_ exception if one or more of its parameter has an incorrect type. This function will raise a _JSONObjectError_ if _json_arr_ is not an array of objects ([{}, {}, {}, ...]). This function will raise any additional exceptions if occurred.\n\n    Example:\n    Filtering an array of objects by a specific key:value pair\n\n    ```\n    from robust_json.ext import filter_json_array\n\n    orders = [{\"order_id\":1648,\"country\":\"USA\" },{\"order_id\":1830,\"country\":\"Liberia\"},\n    {\"order_id\":6703,\"country\":\"USA\"},{\"order_id\":2995,\"country\":\"Russia\"}]\n\n    usa_orders = filter_json_array(orders, 'country', 'USA')\n    print(usa_orders)\n    # Output: [{\"order_id\":1648,\"country\":\"USA\" }, {\"order_id\":6703,\"country\":\"USA\"}]\n    ```\n\n-   **get_item_index(item: any, array: list, always_array: bool = False)**\n    This function will find an intem in given array and return its index(-es).\n    _item:any_ specifies item which index needs to be found. _array:list_ specifies array where this item needs to be present and _always_array:bool_ controls the return type of this function. If set to False, this function will return an array if there is multiple matches, but will return an integer if there is only one match. If set to True, this function will always return an array (see examples below).\n\n    Examples:\n\n    ```\n    from robust_json.ext import get_item_index\n\n    arr1 = [1, 2, 3, 4]\n    index = get_item_index(2, arr1, False)\n    print(index)\n    # Output: 1\n    # Note: we set 'always_array' parameter to False, therefore function returned an integer\n\n    arr2 = [5, 9, 10, 45, 555]\n    index = get_item_index(10, arr2, True)\n    print(index)\n    # Output: [2]\n    # Note: we set 'always_array' parameter to True, therefore function returned an array even if there\n    # is only one match. This is useful when this array will be iterated later on.\n\n    arr3 = [1, 6, 'string', 8, 5, 4, 'string', 0, 22]\n    index = get_item_index('string', arr3, False)\n    # Note: even if 'alway_array' parameter set to False, this function will return an array of\n    # integers because there are multiple matches\n    print(index)\n    # Output: [2, 6]\n\n    arr4 = [1, 2, 3]\n    index = get_item_index(6, arr4, False)\n    # Note: if item is not present in the array and 'always_array' parameter set to False,\n    # None will be returned.\n    print(index)\n    # Output: None\n\n    arr5 = [5, 6, 7]\n    index = get_item_index(10, arr5, True)\n    # Note: if item is not present in the array and 'always_array' parameter set to True,\n    # an empty array will be returned.\n    print(index)\n    # Output: []\n    ```\n\n-   **reverse_array(array: list)**\n    This function will reverse an array and return it.\n\n    This function will raise an _IncorrectFunctionParameterTypeError_ if its parameter has an incorrect type. This function will raise any additional exceptions if occurred.\n\n    Example:\n\n    ```\n    from robust_json.ext import reverse_array\n\n    arr = ['a', 'b', 'c']\n    rev_arr = reverse_array(arr)\n    print(rev_arr)\n    # Output: ['c', 'b', 'a']\n    ```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/NickolaiBeloguzov/robust-json",
    "keywords": "",
    "license": "Apache 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "robust-json",
    "package_url": "https://pypi.org/project/robust-json/",
    "platform": "",
    "project_url": "https://pypi.org/project/robust-json/",
    "project_urls": {
      "Homepage": "https://github.com/NickolaiBeloguzov/robust-json"
    },
    "release_url": "https://pypi.org/project/robust-json/1.2.7/",
    "requires_dist": [
      "jsonpath-ng",
      "pathlib2"
    ],
    "requires_python": ">=3.8",
    "summary": "Robust and easy-to-use framework for working with JSON",
    "version": "1.2.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 8732145,
  "releases": {
    "1.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9544a8a5f9417cbe89028b3d39e6d0cf40e2d563a4abb3e1d4b7e4b0612e1c34",
          "md5": "add04ede4009ea3c5e677b3840137e4f",
          "sha256": "ef106069df342e420f5088f7a82e5e536d9b2dec09792748dcf02a6e263e8d04"
        },
        "downloads": -1,
        "filename": "robust_json-1.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "add04ede4009ea3c5e677b3840137e4f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 29690,
        "upload_time": "2020-11-02T10:15:14",
        "upload_time_iso_8601": "2020-11-02T10:15:14.438781Z",
        "url": "https://files.pythonhosted.org/packages/95/44/a8a5f9417cbe89028b3d39e6d0cf40e2d563a4abb3e1d4b7e4b0612e1c34/robust_json-1.1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "abbe0d7c419662553ca33da7ffa25f505de30d0530d44cb1a20bef2ac0cad68d",
          "md5": "8f50c010cb3c5e1a453c60e79127463a",
          "sha256": "f8109404cc4a0ca7d9289b0c6f0f7680a35e18215587ad2ec355d86004e4cabb"
        },
        "downloads": -1,
        "filename": "robust-json-1.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "8f50c010cb3c5e1a453c60e79127463a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 27969,
        "upload_time": "2020-11-02T10:15:17",
        "upload_time_iso_8601": "2020-11-02T10:15:17.946972Z",
        "url": "https://files.pythonhosted.org/packages/ab/be/0d7c419662553ca33da7ffa25f505de30d0530d44cb1a20bef2ac0cad68d/robust-json-1.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8a91a24674a04086b86d207681baf010ad22b464be8cadf91b2cbe301f36c006",
          "md5": "6444c8c4b199719df2ab1c5d601b5381",
          "sha256": "246c1fb760eb27057b9c80cf29d24df9860210024fc70b790353bf580abb43bf"
        },
        "downloads": -1,
        "filename": "robust_json-1.1.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6444c8c4b199719df2ab1c5d601b5381",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 29806,
        "upload_time": "2020-11-08T23:15:59",
        "upload_time_iso_8601": "2020-11-08T23:15:59.026959Z",
        "url": "https://files.pythonhosted.org/packages/8a/91/a24674a04086b86d207681baf010ad22b464be8cadf91b2cbe301f36c006/robust_json-1.1.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f6232a90ebf08dfddb5608ab13014b151bb185ac4d0ad15a644d775bb41bef2a",
          "md5": "998444183ed73744627ea7144bd22933",
          "sha256": "0ff689a74fac4064ee13437df382e9b6ad769e9276855d9a0f328c3ea5d75dac"
        },
        "downloads": -1,
        "filename": "robust-json-1.1.5.tar.gz",
        "has_sig": false,
        "md5_digest": "998444183ed73744627ea7144bd22933",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 28293,
        "upload_time": "2020-11-08T23:16:00",
        "upload_time_iso_8601": "2020-11-08T23:16:00.350628Z",
        "url": "https://files.pythonhosted.org/packages/f6/23/2a90ebf08dfddb5608ab13014b151bb185ac4d0ad15a644d775bb41bef2a/robust-json-1.1.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ef1428d4fbf2d9dbd99b73a6095fde1b8bca29997b1427a9ac33b110422b0ce1",
          "md5": "e82253d1d42ac4a297d3f9bdf302cc23",
          "sha256": "388f369646f34469b9d3ef469502f9c565095ee77e55e565397f0347ead851b0"
        },
        "downloads": -1,
        "filename": "robust_json-1.1.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e82253d1d42ac4a297d3f9bdf302cc23",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 30041,
        "upload_time": "2020-11-10T18:44:51",
        "upload_time_iso_8601": "2020-11-10T18:44:51.251786Z",
        "url": "https://files.pythonhosted.org/packages/ef/14/28d4fbf2d9dbd99b73a6095fde1b8bca29997b1427a9ac33b110422b0ce1/robust_json-1.1.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "74f2e7d6f33f7049cadfe2643ab96e8d1166f70164dd2360ac31ca0166ea82a3",
          "md5": "043ae0e3a6114eb904c21054ed862192",
          "sha256": "c1994aaec8838d6074f3409cbf0adb8a37b2881e2675f85469ba717d8095a58d"
        },
        "downloads": -1,
        "filename": "robust-json-1.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "043ae0e3a6114eb904c21054ed862192",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 30425,
        "upload_time": "2020-11-10T18:44:52",
        "upload_time_iso_8601": "2020-11-10T18:44:52.996974Z",
        "url": "https://files.pythonhosted.org/packages/74/f2/e7d6f33f7049cadfe2643ab96e8d1166f70164dd2360ac31ca0166ea82a3/robust-json-1.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f26c971cc91b80236bce1710d3e08d6607df2d4259bdc2863fc902e7352d1fc0",
          "md5": "35a77d737a11f7b5da48c351891f22b4",
          "sha256": "7f58b92cdc4b8c1a71847b4f7a603ce69106df48e0c952ea618acfb1bcac3aa0"
        },
        "downloads": -1,
        "filename": "robust_json-1.1.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "35a77d737a11f7b5da48c351891f22b4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 31014,
        "upload_time": "2020-11-11T12:03:52",
        "upload_time_iso_8601": "2020-11-11T12:03:52.239868Z",
        "url": "https://files.pythonhosted.org/packages/f2/6c/971cc91b80236bce1710d3e08d6607df2d4259bdc2863fc902e7352d1fc0/robust_json-1.1.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c2335883c8e18e5c6563dc8ae93c2936c349ee1a99c0602af40d0f80f6a39dcd",
          "md5": "d29cdd8dbb9163020c443eb36c673191",
          "sha256": "b204a2a2f510a20de80957a6d798f937078881a68d072c45a8e358b1ccdc53a5"
        },
        "downloads": -1,
        "filename": "robust-json-1.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "d29cdd8dbb9163020c443eb36c673191",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 30997,
        "upload_time": "2020-11-11T12:03:53",
        "upload_time_iso_8601": "2020-11-11T12:03:53.559823Z",
        "url": "https://files.pythonhosted.org/packages/c2/33/5883c8e18e5c6563dc8ae93c2936c349ee1a99c0602af40d0f80f6a39dcd/robust-json-1.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5248dd8bd54532680c3984b5b773d45856e376e732273779654a088f3d82f495",
          "md5": "7bf101808761ab82d89ed473e96ba0ec",
          "sha256": "77f03f91c4d36db9d7d42499c86603741b32f180be9b3fd2f64a8e940187a103"
        },
        "downloads": -1,
        "filename": "robust_json-1.2.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7bf101808761ab82d89ed473e96ba0ec",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 31886,
        "upload_time": "2020-11-23T22:20:43",
        "upload_time_iso_8601": "2020-11-23T22:20:43.734200Z",
        "url": "https://files.pythonhosted.org/packages/52/48/dd8bd54532680c3984b5b773d45856e376e732273779654a088f3d82f495/robust_json-1.2.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0a240ffe9cde75f118d138fa54f22145e8cb5bd0a3a53dc8aae3eaae99a3f9b2",
          "md5": "049aabdb8fb042a9dc09ebec045b75ae",
          "sha256": "d4006125364c454c339fd366ac3e0dea0a5117babc534b60ea035009dacc4335"
        },
        "downloads": -1,
        "filename": "robust-json-1.2.7.tar.gz",
        "has_sig": false,
        "md5_digest": "049aabdb8fb042a9dc09ebec045b75ae",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 34825,
        "upload_time": "2020-11-23T22:20:45",
        "upload_time_iso_8601": "2020-11-23T22:20:45.259825Z",
        "url": "https://files.pythonhosted.org/packages/0a/24/0ffe9cde75f118d138fa54f22145e8cb5bd0a3a53dc8aae3eaae99a3f9b2/robust-json-1.2.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5248dd8bd54532680c3984b5b773d45856e376e732273779654a088f3d82f495",
        "md5": "7bf101808761ab82d89ed473e96ba0ec",
        "sha256": "77f03f91c4d36db9d7d42499c86603741b32f180be9b3fd2f64a8e940187a103"
      },
      "downloads": -1,
      "filename": "robust_json-1.2.7-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7bf101808761ab82d89ed473e96ba0ec",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 31886,
      "upload_time": "2020-11-23T22:20:43",
      "upload_time_iso_8601": "2020-11-23T22:20:43.734200Z",
      "url": "https://files.pythonhosted.org/packages/52/48/dd8bd54532680c3984b5b773d45856e376e732273779654a088f3d82f495/robust_json-1.2.7-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "0a240ffe9cde75f118d138fa54f22145e8cb5bd0a3a53dc8aae3eaae99a3f9b2",
        "md5": "049aabdb8fb042a9dc09ebec045b75ae",
        "sha256": "d4006125364c454c339fd366ac3e0dea0a5117babc534b60ea035009dacc4335"
      },
      "downloads": -1,
      "filename": "robust-json-1.2.7.tar.gz",
      "has_sig": false,
      "md5_digest": "049aabdb8fb042a9dc09ebec045b75ae",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 34825,
      "upload_time": "2020-11-23T22:20:45",
      "upload_time_iso_8601": "2020-11-23T22:20:45.259825Z",
      "url": "https://files.pythonhosted.org/packages/0a/24/0ffe9cde75f118d138fa54f22145e8cb5bd0a3a53dc8aae3eaae99a3f9b2/robust-json-1.2.7.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}