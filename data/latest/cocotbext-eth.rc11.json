{
  "info": {
    "author": "Alex Forencich",
    "author_email": "alex@alexforencich.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Framework :: cocotb",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)"
    ],
    "description": "# Ethernet interface modules for Cocotb\n\n[![Build Status](https://github.com/alexforencich/cocotbext-eth/workflows/Regression%20Tests/badge.svg?branch=master)](https://github.com/alexforencich/cocotbext-eth/actions/)\n[![codecov](https://codecov.io/gh/alexforencich/cocotbext-eth/branch/master/graph/badge.svg)](https://codecov.io/gh/alexforencich/cocotbext-eth)\n[![PyPI version](https://badge.fury.io/py/cocotbext-eth.svg)](https://pypi.org/project/cocotbext-eth)\n[![Downloads](https://pepy.tech/badge/cocotbext-eth)](https://pepy.tech/project/cocotbext-eth)\n\nGitHub repository: https://github.com/alexforencich/cocotbext-eth\n\n## Introduction\n\nEthernet interface models for [cocotb](https://github.com/cocotb/cocotb).\n\nIncludes PHY-attach interface models for MII, GMII, RGMII, and XGMII; PHY chip interface models for MII, GMII, and RGMII; PTP clock simulation models; and a generic Ethernet MAC model that supports rate enforcement and PTP timestamping.\n\n## Installation\n\nInstallation from pip (release version, stable):\n\n    $ pip install cocotbext-eth\n\nInstallation from git (latest development version, potentially unstable):\n\n    $ pip install https://github.com/alexforencich/cocotbext-eth/archive/master.zip\n\nInstallation for active development:\n\n    $ git clone https://github.com/alexforencich/cocotbext-eth\n    $ pip install -e cocotbext-eth\n\n## Documentation and usage examples\n\nSee the `tests` directory, [verilog-ethernet](https://github.com/alexforencich/verilog-ethernet), and [corundum](https://github.com/corundum/corundum) for complete testbenches using these modules.\n\n### GMII\n\nThe `GmiiSource` and `GmiiSink` classes can be used to drive, receive, and monitor GMII traffic.  The `GmiiSource` drives GMII traffic into a design.  The `GmiiSink` receives GMII traffic, including monitoring internal interfaces.  The `GmiiPhy` class is a wrapper around `GmiiSource` and `GmiiSink` that also provides clocking and rate-switching to emulate a GMII PHY chip.\n\nTo use these modules, import the one you need and connect it to the DUT:\n\n    from cocotbext.eth import GmiiSource, GmiiSink\n\n    gmii_source = GmiiSource(dut.rxd, dut.rx_er, dut.rx_en, dut.clk, dut.rst)\n    gmii_sink = GmiiSink(dut.txd, dut.tx_er, dut.tx_en, dut.clk, dut.rst)\n\nTo send data into a design with a `GmiiSource`, call `send()` or `send_nowait()`.  Accepted data types are iterables that can be converted to bytearray or `GmiiFrame` objects.  Optionally, call `wait()` to wait for the transmit operation to complete.  Example:\n\n    await gmii_source.send(GmiiFrame.from_payload(b'test data'))\n    # wait for operation to complete (optional)\n    await gmii_source.wait()\n\nIt is also possible to wait for the transmission of a specific frame to complete by passing an event in the tx_complete field of the `GmiiFrame` object, and then awaiting the event.  The frame, with simulation time fields set, will be returned in the event data.  Example:\n\n    frame = GmiiFrame.from_payload(b'test data', tx_complete=Event())\n    await gmii_source.send(frame)\n    await frame.tx_complete.wait()\n    print(frame.tx_complete.data.sim_time_sfd)\n\nTo receive data with a `GmiiSink`, call `recv()` or `recv_nowait()`.  Optionally call `wait()` to wait for new receive data.\n\n    data = await gmii_sink.recv()\n\nThe `GmiiPhy` class provides a model of a GMII PHY chip.  It wraps instances of `GmiiSource` (`rx`) and `GmiiSink` (`tx`), provides the necessary clocking components, and provides the `set_speed()` method to change the link speed.  `set_speed()` changes the `tx_clk` and `rx_clk` frequencies, switches between `gtx_clk` and `tx_clk`, and selects the appropriate mode (MII or GMII) on the source and sink instances.  In general, the `GmiiPhy` class is intended to be used for integration tests where the design expects to be directly connected to an external GMII PHY chip and contains all of the necessary IO and clocking logic.  Example:\n\n    from cocotbext.eth import GmiiFrame, GmiiPhy\n\n    gmii_phy = GmiiPhy(dut.txd, dut.tx_er, dut.tx_en, dut.tx_clk, dut.gtx_clk,\n        dut.rxd, dut.rx_er, dut.rx_en, dut.rx_clk, dut.rst, speed=1000e6)\n\n    gmii_phy.set_speed(100e6)\n\n    await gmii_phy.rx.send(GmiiFrame.from_payload(b'test RX data'))\n    tx_data = await gmii_phy.tx.recv()\n\n#### Signals\n\n* `txd`, `rxd`: data\n* `tx_er`, `rx_er`: error (when asserted with `tx_en` or `rx_dv`)\n* `tx_en`, `rx_dv`: data valid\n\n#### Constructor parameters:\n\n* _data_: data signal (txd, rxd, etc.)\n* _er_: error signal (tx_er, rx_er, etc.) (optional)\n* _dv_: data valid signal (tx_en, rx_dv, etc.)\n* _clock_: clock signal\n* _reset_: reset signal (optional)\n* _enable_: clock enable (optional)\n* _mii_select_: MII mode select (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n\n#### Attributes:\n\n* _queue_occupancy_bytes_: number of bytes in queue\n* _queue_occupancy_frames_: number of frames in queue\n* _queue_occupancy_limit_bytes_: max number of bytes in queue allowed before backpressure is applied (source only)\n* _queue_occupancy_limit_frames_: max number of frames in queue allowed before backpressure is applied (source only)\n* _mii_mode_: control MII mode when _mii_select_ signal is not connected\n\n#### Methods\n\n* `send(frame)`: send _frame_ (blocking) (source)\n* `send_nowait(frame)`: send _frame_ (non-blocking) (source)\n* `recv()`: receive a frame as a `GmiiFrame` (blocking) (sink)\n* `recv_nowait()`: receive a frame as a `GmiiFrame` (non-blocking) (sink)\n* `count()`: returns the number of items in the queue (all)\n* `empty()`: returns _True_ if the queue is empty (all)\n* `full()`: returns _True_ if the queue occupancy limits are met (source)\n* `idle()`: returns _True_ if no transfer is in progress (all) or if the queue is not empty (source)\n* `clear()`: drop all data in queue (all)\n* `wait()`: wait for idle (source)\n* `wait(timeout=0, timeout_unit='ns')`: wait for frame received (sink)\n\n#### GMII timing diagram\n\nExample transfer via GMII at 1 Gbps:\n\n                  __    __    __    __    _       __    __    __    __\n    tx_clk     __/  \\__/  \\__/  \\__/  \\__/  ... _/  \\__/  \\__/  \\__/  \\__\n                        _____ _____ _____ _     _ _____ _____\n    tx_d[7:0]  XXXXXXXXX_55__X_55__X_55__X_ ... _X_72__X_fb__XXXXXXXXXXXX\n\n    tx_er      ____________________________ ... _________________________\n                        ___________________     _____________\n    tx_en      ________/                    ...              \\___________\n\n\n#### GmiiFrame object\n\nThe `GmiiFrame` object is a container for a frame to be transferred via GMII.  The `data` field contains the packet data in the form of a list of bytes.  `error` contains the `er` signal level state associated with each byte as a list of ints.\n\nAttributes:\n\n* `data`: bytearray\n* `error`: error field, optional; list, each entry qualifies the corresponding entry in `data`.\n* `sim_time_start`: simulation time of first transfer cycle of frame.\n* `sim_time_sfd`: simulation time at which the SFD was transferred.\n* `sim_time_end`: simulation time of last transfer cycle of frame.\n* `start_lane`: byte lane in which the start control character was transferred.\n* `tx_complete`: event or callable triggered when frame is transmitted.\n\nMethods:\n\n* `from_payload(payload, min_len=60)`: create `GmiiFrame` from payload data, inserts preamble, zero-pads frame to minimum length and computes and inserts FCS (class method)\n* `from_raw_payload(payload)`: create `GmiiFrame` from payload data, inserts preamble only (class method)\n* `get_preamble_len()`: locate SFD and return preamble length\n* `get_preamble()`: return preamble\n* `get_payload(strip_fcs=True)`: return payload, optionally strip FCS\n* `get_fcs()`: return FCS\n* `check_fcs()`: returns _True_ if FCS is correct\n* `normalize()`: pack `error` to the same length as `data`, replicating last element if necessary, initialize to list of `0` if not specified.\n* `compact()`: remove `error` if all zero\n\n### MII\n\nThe `MiiSource` and `MiiSink` classes can be used to drive, receive, and monitor MII traffic.  The `MiiSource` drives MII traffic into a design.  The `MiiSink` receives MII traffic, including monitoring internal interfaces.  The `MiiPhy` class is a wrapper around `MiiSource` and `MiiSink` that also provides clocking and rate-switching to emulate an MII PHY chip.\n\nTo use these modules, import the one you need and connect it to the DUT:\n\n    from cocotbext.eth import MiiSource, MiiSink\n\n    mii_source = MiiSource(dut.rxd, dut.rx_er, dut.rx_en, dut.clk, dut.rst)\n    mii_sink = MiiSink(dut.txd, dut.tx_er, dut.tx_en, dut.clk, dut.rst)\n\nAll signals must be passed separately into these classes.\n\nTo send data into a design with an `MiiSource`, call `send()` or `send_nowait()`.  Accepted data types are iterables that can be converted to bytearray or `GmiiFrame` objects.  Optionally, call `wait()` to wait for the transmit operation to complete.  Example:\n\n    await mii_source.send(GmiiFrame.from_payload(b'test data'))\n    # wait for operation to complete (optional)\n    await mii_source.wait()\n\nIt is also possible to wait for the transmission of a specific frame to complete by passing an event in the tx_complete field of the `GmiiFrame` object, and then awaiting the event.  The frame, with simulation time fields set, will be returned in the event data.  Example:\n\n    frame = GmiiFrame.from_payload(b'test data', tx_complete=Event())\n    await mii_source.send(frame)\n    await frame.tx_complete.wait()\n    print(frame.tx_complete.data.sim_time_sfd)\n\nTo receive data with an `MiiSink`, call `recv()` or `recv_nowait()`.  Optionally call `wait()` to wait for new receive data.\n\n    data = await mii_sink.recv()\n\nThe `MiiPhy` class provides a model of an MII PHY chip.  It wraps instances of `MiiSource` (`rx`) and `MiiSink` (`tx`), provides the necessary clocking components, and provides the `set_speed()` method to change the link speed.  `set_speed()` changes the `tx_clk` and `rx_clk` frequencies.  In general, the `MiiPhy` class is intended to be used for integration tests where the design expects to be directly connected to an external MII PHY chip and contains all of the necessary IO and clocking logic.  Example:\n\n    from cocotbext.eth import GmiiFrame, MiiPhy\n\n    mii_phy = MiiPhy(dut.txd, dut.tx_er, dut.tx_en, dut.tx_clk,\n        dut.rxd, dut.rx_er, dut.rx_en, dut.rx_clk, dut.rst, speed=100e6)\n\n    mii_phy.set_speed(10e6)\n\n    await mii_phy.rx.send(GmiiFrame.from_payload(b'test RX data'))\n    tx_data = await mii_phy.tx.recv()\n\n#### Signals\n\n* `txd`, `rxd`: data\n* `tx_er`, `rx_er`: error (when asserted with `tx_en` or `rx_dv`)\n* `tx_en`, `rx_dv`: data valid\n\n#### Constructor parameters:\n\n* _data_: data signal (txd, rxd, etc.)\n* _er_: error signal (tx_er, rx_er, etc.) (optional)\n* _dv_: data valid signal (tx_en, rx_dv, etc.)\n* _clock_: clock signal\n* _reset_: reset signal (optional)\n* _enable_: clock enable (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n\n#### Attributes:\n\n* _queue_occupancy_bytes_: number of bytes in queue\n* _queue_occupancy_frames_: number of frames in queue\n* _queue_occupancy_limit_bytes_: max number of bytes in queue allowed before backpressure is applied (source only)\n* _queue_occupancy_limit_frames_: max number of frames in queue allowed before backpressure is applied (source only)\n\n#### Methods\n\n* `send(frame)`: send _frame_ (blocking) (source)\n* `send_nowait(frame)`: send _frame_ (non-blocking) (source)\n* `recv()`: receive a frame as a `GmiiFrame` (blocking) (sink)\n* `recv_nowait()`: receive a frame as a `GmiiFrame` (non-blocking) (sink)\n* `count()`: returns the number of items in the queue (all)\n* `empty()`: returns _True_ if the queue is empty (all)\n* `full()`: returns _True_ if the queue occupancy limits are met (source)\n* `idle()`: returns _True_ if no transfer is in progress (all) or if the queue is not empty (source)\n* `clear()`: drop all data in queue (all)\n* `wait()`: wait for idle (source)\n* `wait(timeout=0, timeout_unit='ns')`: wait for frame received (sink)\n\n#### MII timing diagram\n\nExample transfer via MII at 100 Mbps:\n\n                 _   _   _   _   _   _       _   _   _   _\n    tx_clk     _/ \\_/ \\_/ \\_/ \\_/ \\_/  ... _/ \\_/ \\_/ \\_/ \\_\n                     ___ ___ ___ ___ _     _ ___ ___\n    tx_d[3:0]  XXXXXX_5_X_5_X_5_X_5_X_ ... _X_f_X_b_XXXXXXXX\n\n    tx_er      _______________________ ... _________________\n                     _________________     _________\n    tx_en      _____/                  ...          \\_______\n\n\n### RGMII\n\nThe `RgmiiSource` and `RgmiiSink` classes can be used to drive, receive, and monitor RGMII traffic.  The `RgmiiSource` drives RGMII traffic into a design.  The `RgmiiSink` receives RGMII traffic, including monitoring internal interfaces.  The `RgmiiPhy` class is a wrapper around `RgmiiSource` and `RgmiiSink` that also provides clocking and rate-switching to emulate an RGMII PHY chip.\n\nTo use these modules, import the one you need and connect it to the DUT:\n\n    from cocotbext.eth import RgmiiSource, RgmiiSink\n\n    rgmii_source = RgmiiSource(dut.rxd, dut.rx_ctl, dut.clk, dut.rst)\n    rgmii_sink = RgmiiSink(dut.txd, dut.tx_ctl, dut.clk, dut.rst)\n\nAll signals must be passed separately into these classes.\n\nTo send data into a design with an `RgmiiSource`, call `send()` or `send_nowait()`.  Accepted data types are iterables that can be converted to bytearray or `GmiiFrame` objects.  Optionally, call `wait()` to wait for the transmit operation to complete.  Example:\n\n    await rgmii_source.send(GmiiFrame.from_payload(b'test data'))\n    # wait for operation to complete (optional)\n    await rgmii_source.wait()\n\nIt is also possible to wait for the transmission of a specific frame to complete by passing an event in the tx_complete field of the `GmiiFrame` object, and then awaiting the event.  The frame, with simulation time fields set, will be returned in the event data.  Example:\n\n    frame = GmiiFrame.from_payload(b'test data', tx_complete=Event())\n    await rgmii_source.send(frame)\n    await frame.tx_complete.wait()\n    print(frame.tx_complete.data.sim_time_sfd)\n\nTo receive data with an `RgmiiSink`, call `recv()` or `recv_nowait()`.  Optionally call `wait()` to wait for new receive data.\n\n    data = await rgmii_sink.recv()\n\nThe `RgmiiPhy` class provides a model of an RGMII PHY chip.  It wraps instances of `RgmiiSource` (`rx`) and `RgmiiSink` (`tx`), provides the necessary clocking components, and provides the `set_speed()` method to change the link speed.  `set_speed()` changes the `rx_clk` frequency and selects the appropriate mode (SDR or DDR) on the source and sink instances.  In general, the `RgmiiPhy` class is intended to be used for integration tests where the design expects to be directly connected to an external RGMII PHY chip and contains all of the necessary IO and clocking logic.  Example:\n\n    from cocotbext.eth import GmiiFrame, RgmiiPhy\n\n    rgmii_phy = RgmiiPhy(dut.txd, dut.tx_ctl, dut.tx_clk,\n        dut.rxd, dut.rx_ctl, dut.rx_clk, dut.rst, speed=1000e6)\n\n    rgmii_phy.set_speed(100e6)\n\n    await rgmii_phy.rx.send(GmiiFrame.from_payload(b'test RX data'))\n    tx_data = await rgmii_phy.tx.recv()\n\n#### Signals\n\n* `txd`, `rxd`: data (DDR)\n* `tx_ctl`, `rx_ctl`: control (DDR, combination of valid and error)\n\n#### Constructor parameters:\n\n* _data_: data signal (txd, rxd, etc.)\n* _ctrl_: control\n* _clock_: clock signal\n* _reset_: reset signal (optional)\n* _enable_: clock enable (optional)\n* _mii_select_: MII mode select (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n\n#### Attributes:\n\n* _queue_occupancy_bytes_: number of bytes in queue\n* _queue_occupancy_frames_: number of frames in queue\n* _queue_occupancy_limit_bytes_: max number of bytes in queue allowed before backpressure is applied (source only)\n* _queue_occupancy_limit_frames_: max number of frames in queue allowed before backpressure is applied (source only)\n* _mii_mode_: control MII mode when _mii_select_ signal is not connected\n\n#### Methods\n\n* `send(frame)`: send _frame_ (blocking) (source)\n* `send_nowait(frame)`: send _frame_ (non-blocking) (source)\n* `recv()`: receive a frame as a `GmiiFrame` (blocking) (sink)\n* `recv_nowait()`: receive a frame as a `GmiiFrame` (non-blocking) (sink)\n* `count()`: returns the number of items in the queue (all)\n* `empty()`: returns _True_ if the queue is empty (all)\n* `full()`: returns _True_ if the queue occupancy limits are met (source)\n* `idle()`: returns _True_ if no transfer is in progress (all) or if the queue is not empty (source)\n* `clear()`: drop all data in queue (all)\n* `wait()`: wait for idle (source)\n* `wait(timeout=0, timeout_unit='ns')`: wait for frame received (sink)\n\n#### RGMII timing diagram\n\nExample transfer via RGMII at 1 Gbps:\n\n                 ___     ___     ___     _       ___     ___\n    tx_clk     _/   \\___/   \\___/   \\___/  ... _/   \\___/   \\___\n                       ___ ___ ___ ___ ___     ___ ___\n    tx_d[3:0]  XXXXXXXX_5_X_5_X_5_X_5_X_5_ ... _f_X_b_XXXXXXXXXX\n                       ___________________     _______\n    tx_ctl     _______/                    ...        \\_________\n\n\n### XGMII\n\nThe `XgmiiSource` and `XgmiiSink` classes can be used to drive, receive, and monitor XGMII traffic.  The `XgmiiSource` drives XGMII traffic into a design.  The `XgmiiSink` receives XGMII traffic, including monitoring internal interfaces.  The modules are capable of operating with XGMII interface widths of 32 or 64 bits.\n\nTo use these modules, import the one you need and connect it to the DUT:\n\n    from cocotbext.eth import XgmiiSource, XgmiiSink\n\n    xgmii_source = XgmiiSource(dut.rxd, dut.rxc, dut.clk, dut.rst)\n    xgmii_sink = XgmiiSink(dut.txd, dut.txc, dut.clk, dut.rst)\n\nAll signals must be passed separately into these classes.\n\nTo send data into a design with an `XgmiiSource`, call `send()` or `send_nowait()`.  Accepted data types are iterables that can be converted to bytearray or `XgmiiFrame` objects.  Optionally, call `wait()` to wait for the transmit operation to complete.  Example:\n\n    await xgmii_source.send(XgmiiFrame.from_payload(b'test data'))\n    # wait for operation to complete (optional)\n    await xgmii_source.wait()\n\nIt is also possible to wait for the transmission of a specific frame to complete by passing an event in the tx_complete field of the `XgmiiFrame` object, and then awaiting the event.  The frame, with simulation time fields set, will be returned in the event data.  Example:\n\n    frame = XgmiiFrame.from_payload(b'test data', tx_complete=Event())\n    await xgmii_source.send(frame)\n    await frame.tx_complete.wait()\n    print(frame.tx_complete.data.sim_time_sfd)\n\nTo receive data with an `XgmiiSink`, call `recv()` or `recv_nowait()`.  Optionally call `wait()` to wait for new receive data.\n\n    data = await xgmii_sink.recv()\n\n#### Signals\n\n* `txd`, `rxd`: data\n* `txc`, `rxc`: control\n\n#### Constructor parameters:\n\n* _data_: data signal (txd, rxd, etc.)\n* _ctrl_: control signal (txc, rxc, etc.)\n* _clock_: clock signal\n* _reset_: reset signal (optional)\n* _enable_: clock enable (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n\n#### Attributes:\n\n* _queue_occupancy_bytes_: number of bytes in queue\n* _queue_occupancy_frames_: number of frames in queue\n* _queue_occupancy_limit_bytes_: max number of bytes in queue allowed before backpressure is applied (source only)\n* _queue_occupancy_limit_frames_: max number of frames in queue allowed before backpressure is applied (source only)\n\n#### Methods\n\n* `send(frame)`: send _frame_ (blocking) (source)\n* `send_nowait(frame)`: send _frame_ (non-blocking) (source)\n* `recv()`: receive a frame as an `XgmiiFrame` (blocking) (sink)\n* `recv_nowait()`: receive a frame as an `XgmiiFrame` (non-blocking) (sink)\n* `count()`: returns the number of items in the queue (all)\n* `empty()`: returns _True_ if the queue is empty (all)\n* `full()`: returns _True_ if the queue occupancy limits are met (source)\n* `idle()`: returns _True_ if no transfer is in progress (all) or if the queue is not empty (source)\n* `clear()`: drop all data in queue (all)\n* `wait()`: wait for idle (source)\n* `wait(timeout=0, timeout_unit='ns')`: wait for frame received (sink)\n\n#### XGMII timing diagram\n\nExample transfer via 64-bit XGMII:\n\n                  __    __    __    __    __    _       __    __\n    tx_clk     __/  \\__/  \\__/  \\__/  \\__/  \\__/  ... _/  \\__/  \\__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[63:56] __X_07__X_d5__X_51__X_01__X_09__X_ ... _X_fb__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[55:48] __X_07__X_55__X_5a__X_00__X_08__X_ ... _X_72__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[47:40] __X_07__X_55__X_d5__X_00__X_07__X_ ... _X_0d__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[39:32] __X_07__X_55__X_d4__X_80__X_06__X_ ... _X_37__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[31:24] __X_07__X_55__X_d3__X_55__X_05__X_ ... _X_2d__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[23:16] __X_07__X_55__X_d2__X_54__X_04__X_ ... _X_2c__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[15:8]  __X_07__X_55__X_d1__X_53__X_03__X_ ... _X_2b__X_07__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txd[7:0]   __X_07__X_fb__X_da__X_52__X_02__X_ ... _X_2a__X_fd__\n               __ _____ _____ _____ _____ _____ _     _ _____ _____\n    txc[7:0]   __X_ff__X_01__X_00__X_00__X_00__X_ ... _X_00__X_ff__\n\n\n#### XgmiiFrame object\n\nThe `XgmiiFrame` object is a container for a frame to be transferred via XGMII.  The `data` field contains the packet data in the form of a list of bytes.  `ctrl` contains the control signal level state associated with each byte as a list of ints.  When `ctrl` is high, the corresponding `data` byte is interpreted as an XGMII control character.\n\nAttributes:\n\n* `data`: bytearray\n* `ctrl`: control field, optional; list, each entry qualifies the corresponding entry in `data` as an XGMII control character.\n* `sim_time_start`: simulation time of first transfer cycle of frame.\n* `sim_time_sfd`: simulation time at which the SFD was transferred.\n* `sim_time_end`: simulation time of last transfer cycle of frame.\n* `start_lane`: byte lane in which the start control character was transferred.\n* `tx_complete`: event or callable triggered when frame is transmitted.\n\nMethods:\n\n* `from_payload(payload, min_len=60)`: create `XgmiiFrame` from payload data, inserts preamble, zero-pads frame to minimum length and computes and inserts FCS (class method)\n* `from_raw_payload(payload)`: create `XgmiiFrame` from payload data, inserts preamble only (class method)\n* `get_preamble_len()`: locate SFD and return preamble length\n* `get_preamble()`: return preamble\n* `get_payload(strip_fcs=True)`: return payload, optionally strip FCS\n* `get_fcs()`: return FCS\n* `check_fcs()`: returns _True_ if FCS is correct\n* `normalize()`: pack `ctrl` to the same length as `data`, replicating last element if necessary, initialize to list of `0` if not specified.\n* `compact()`: remove `ctrl` if all zero\n\n### Ethernet MAC model\n\nThe `EthMac`, `EthMacTx` and `EthMacRx` modules are models of an Ethernet MAC with an AXI stream interface.  The `EthMacRx` module drives Ethernet frames in the form of AXI stream traffic into a design.  The `EthMacTx` module accepts Ethernet frames in the form of AXI stream traffic from a design.  `EthMac` is a wrapper module containing `EthMacRx` (`rx`) and `EthMacTx` (`tx`).  The modules are capable of operating with any interface width.  The MAC models enforce the correct data rates and timings in both the receive and transmit direction, and can also collect PTP timestamps from a PTP hardware clock.\n\nTo use these modules, import the one you need and connect it to the DUT:\n\n    from cocotbext.axi import AxiStreamBus\n    from cocotbext.eth import EthMac\n\n    mac = EthMac(\n        tx_clk=dut.tx_clk,\n        tx_rst=dut.tx_rst,\n        tx_bus=AxiStreamBus.from_prefix(dut, \"tx_axis\"),\n        tx_ptp_time=dut.tx_ptp_time,\n        tx_ptp_ts=dut.tx_ptp_ts,\n        tx_ptp_ts_tag=dut.tx_ptp_ts_tag,\n        tx_ptp_ts_valid=dut.tx_ptp_ts_valid,\n        rx_clk=dut.rx_clk,\n        rx_rst=dut.rx_rst,\n        rx_bus=AxiStreamBus.from_prefix(dut, \"rx_axis\"),\n        rx_ptp_time=dut.rx_ptp_time,\n        ifg=12, speed=speed\n    )\n\nTo send data into a design, call `send()` or `send_nowait()`.  Accepted data types are iterables that can be converted to bytearray or `EthMacFrame` objects.  Optionally, call `wait()` to wait for the transmit operation to complete.  Example:\n\n    await mac.tx.send(EthMacFrame.from_payload(b'test data'))\n    # wait for operation to complete (optional)\n    await mac.tx.wait()\n\nIt is also possible to wait for the transmission of a specific frame to complete by passing an event in the tx_complete field of the `EthMacFrame` object, and then awaiting the event.  The frame, with simulation time fields set, will be returned in the event data.  Example:\n\n    frame = EthMacFrame.from_payload(b'test data', tx_complete=Event())\n    await mac.tx.send(frame)\n    await frame.tx_complete.wait()\n    print(frame.tx_complete.data.sim_time_sfd)\n\nTo receive data, call `recv()` or `recv_nowait()`.  Optionally call `wait()` to wait for new receive data.\n\n    data = await mac.tx.recv()\n\nPTP timestamping requires free-running PTP clocks driving the PTP time inputs, synchronous with the corresponding MAC clocks.  The values of these fields are then captured when the frame SFD is transferred and returned either on tuser (for received frames) or on a separate streaming interface (for transmitted frames).  Additionally, on the transmit path, a tag value from tuser is returned along with the timestamp.\n\n#### Signals\n\n* `tdata`: payload data, must be a multiple of 8 bits\n* `tvalid`: qualifies all other signals\n* `tready`: indicates sink is ready for data (tx only)\n* `tlast`: marks the last cycle of a frame\n* `tkeep`: qualifies data byte, data bus width must be evenly divisible by `tkeep` signal width\n* `tuser`: user data, carries frame error mark and captured receive PTP timestamp (RX) or PTP timestamp tag (TX)\n* `ptp_time`: PTP time input from PHC, captured into `ptp_timestamp` field coincident with transfer of frame SFD and output on `ptp_ts` (TX) or `tuser` (RX)\n* `ptp_ts`: captured transmit PTP timestamp\n* `ptp_ts_tag`: captured transmit PTP timestamp tag\n* `ptp_ts_valid`: qualifies captured transmit PTP timestamp\n\n#### Constructor parameters (`EthMacRx` and `EthMacTx`):\n\n* _bus_: `AxiStreamBus` object containing AXI stream interface signals\n* _clock_: clock signal\n* _reset_: reset signal (optional)\n* _ptp_time_: PTP time input from PHC (optional)\n* _ptp_ts_: PTP timestamp (optional) (tx)\n* _ptp_ts_tag_: PTP timestamp tag (optional) (tx)\n* _ptp_ts_valid_: PTP timestamp valid (optional) (tx)\n* _reset_active_level_: reset active level (optional, default `True`)\n* _ifg_: IFG size in byte times (optional, default `12`)\n* _speed_: link speed in bits per second (optional, default `1000e6`)\n\n#### Constructor parameters (`EthMac`):\n\n* _tx_bus_: `AxiStreamBus` object containing transmit AXI stream interface signals\n* _tx_clk_: transmit clock\n* _tx_rst_: transmit reset (optional)\n* _tx_ptp_time_: transmit PTP time input from PHC (optional)\n* _tx_ptp_ts_: transmit PTP timestamp (optional)\n* _tx_ptp_ts_tag_: transmit PTP timestamp tag (optional)\n* _tx_ptp_ts_valid_: transmit PTP timestamp valid (optional)\n* _rx_bus_: `AxiStreamBus` object containing receive AXI stream interface signals\n* _rx_clk_: receive clock\n* _rx_rst_: receive reset (optional)\n* _rx_ptp_time_: receive PTP time input from PHC (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n* _ifg_: IFG size in byte times (optional, default `12`)\n* _speed_: link speed in bits per second (optional, default `1000e6`)\n\n#### Attributes:\n\n* _queue_occupancy_bytes_: number of bytes in queue\n* _queue_occupancy_frames_: number of frames in queue\n* _queue_occupancy_limit_bytes_: max number of bytes in queue allowed before backpressure is applied (RX only)\n* _queue_occupancy_limit_frames_: max number of frames in queue allowed before backpressure is applied (RX only)\n* _ifg_: IFG size in byte times\n* _speed_: link speed in bits per second\n\n#### Methods\n\n* `send(frame)`: send _frame_ (blocking) (rx)\n* `send_nowait(frame)`: send _frame_ (non-blocking) (rx)\n* `recv()`: receive a frame as an `EthMacFrame` (blocking) (tx)\n* `recv_nowait()`: receive a frame as an `EthMacFrame` (non-blocking) (tx)\n* `count()`: returns the number of items in the queue (all)\n* `empty()`: returns _True_ if the queue is empty (all)\n* `full()`: returns _True_ if the queue occupancy limits are met (rx)\n* `idle()`: returns _True_ if no transfer is in progress (all) or if the queue is not empty (rx)\n* `clear()`: drop all data in queue (all)\n* `wait()`: wait for idle (rx)\n* `wait(timeout=0, timeout_unit='ns')`: wait for frame received (tx)\n\n#### EthMacFrame object\n\nThe `EthMacFrame` object is a container for a frame to be transferred via XGMII.  The `data` field contains the packet data in the form of a list of bytes.\n\nAttributes:\n\n* `data`: bytearray\n* `sim_time_start`: simulation time of first transfer cycle of frame.\n* `sim_time_sfd`: simulation time at which the SFD was transferred.\n* `sim_time_end`: simulation time of last transfer cycle of frame.\n* `ptp_tag`: PTP timestamp tag for transmitted frames.\n* `ptp_timestamp`: captured value of `ptp_time` at frame SFD\n* `tx_complete`: event or callable triggered when frame is transmitted.\n\nMethods:\n\n* `from_payload(payload, min_len=60)`: create `EthMacFrame` from payload data, zero-pads frame to minimum length and computes and inserts FCS (class method)\n* `from_raw_payload(payload)`: create `EthMacFrame` from payload data (class method)\n* `get_payload(strip_fcs=True)`: return payload, optionally strip FCS\n* `get_fcs()`: return FCS\n* `check_fcs()`: returns _True_ if FCS is correct\n\n### PTP clock\n\nThe `PtpClock` class implements a PTP hardware clock that produces IEEE 1588 format 96 and 64 bit PTP timestamps.\n\nTo use this module, import it and connect it to the DUT:\n\n    from cocotbext.eth import PtpClock\n\n    ptp_clock = PtpClock(\n        ts_96=dut.ts_96,\n        ts_64=dut.ts_64,\n        ts_step=dut.ts_step,\n        pps=dut.pps,\n        clock=dut.clk,\n        reset=dut.reset,\n        period_ns=6.4\n    )\n\nOnce the clock is instantiated, it will generate a continuous stream of monotonically increasing PTP timestamps on every clock edge.\n\n#### Signals\n\n* `ts_96`: 96-bit timestamp (48 bit seconds, 32 bit ns, 16 bit fractional ns)\n* `ts_64`: 64-bit timestamp (48 bit ns, 16 bit fractional ns)\n* `ts_step`: step output, pulsed when non-monotonic step occurs\n* `pps`: pulse-per-second output, pulsed when ts_96 seconds field increments\n\n#### Constructor parameters:\n\n* _ts_96_: 96-bit timestamp signal (optional)\n* _ts_64_: 64-bit timestamp signal (optional)\n* _ts_step_: timestamp step signal (optional)\n* _pps_: pulse-per-second signal (optional)\n* _clock_: clock\n* _reset_: reset (optional)\n* _reset_active_level_: reset active level (optional, default `True`)\n* _period_ns_: clock period (nanoseconds, default `6.4`)\n\n#### Attributes:\n\n* _ts_96_s_: current 96-bit timestamp seconds field\n* _ts_96_ns_: current 96-bit timestamp ns field\n* _ts_96_fns_: current 96-bit timestamp fractional ns field\n* _ts_64_ns_: current 64-bit timestamp ns field\n* _ts_64_fns_: current 64-bit timestamp fractional ns field\n\n#### Methods\n\n* `set_period(ns, fns)`: set clock period from separate fields\n* `set_drift(ns, fns, rate)`: set clock drift from separate fields\n* `set_period_ns(t)`: set clock period in ns (float)\n* `get_period_ns()`: return current clock period in ns (float)\n* `set_ts_96(ts_s, ts_ns=None, ts_fns=None)`: set 96-bit timestamp from integer or from separate fields\n* `set_ts_96_ns(t)`: set 96-bit timestamp from ns (float)\n* `set_ts_96_s(t)`: set 96-bit timestamp from seconds (float)\n* `get_ts_96()`: return current 96-bit timestamp as an integer\n* `get_ts_96_ns()`: return current 96-bit timestamp in ns (float)\n* `get_ts_96_s()`: return current 96-bit timestamp in seconds (float)\n* `set_ts_64(ts_ns, ts_fns=None)`: set 64-bit timestamp from integer or from separate fields\n* `set_ts_64_ns(t)`: set 64-bit timestamp from ns (float)\n* `set_ts_64_s(t)`: set 64-bit timestamp from seconds (float)\n* `get_ts_64()`: return current 64-bit timestamp as an integer\n* `get_ts_64_ns()`: return current 64-bit timestamp in ns (float)\n* `get_ts_64_s()`: return current 64-bit timestamp in seconds (float)\n\n### PTP clock (sim time)\n\nThe `PtpClockSimTime` class implements a PTP hardware clock that produces IEEE 1588 format 96 and 64 bit PTP timestamps, derived from the current simulation time.  This module can be used in place of `PtpClock` so that captured PTP timestamps can be easily compared to captured simulation time.\n\nTo use this module, import it and connect it to the DUT:\n\n    from cocotbext.eth import PtpClockSimTime\n\n    ptp_clock = PtpClockSimTime(\n        ts_96=dut.ts_96,\n        ts_64=dut.ts_64,\n        pps=dut.pps,\n        clock=dut.clk\n    )\n\nOnce the clock is instantiated, it will generate a continuous stream of monotonically increasing PTP timestamps on every clock edge.\n\n#### Signals\n\n* `ts_96`: 96-bit timestamp (48 bit seconds, 32 bit ns, 16 bit fractional ns)\n* `ts_64`: 64-bit timestamp (48 bit ns, 16 bit fractional ns)\n* `pps`: pulse-per-second output, pulsed when ts_96 seconds field increments\n\n#### Constructor parameters:\n\n* _ts_96_: 96-bit timestamp signal (optional)\n* _ts_64_: 64-bit timestamp signal (optional)\n* _pps_: pulse-per-second signal (optional)\n* _clock_: clock\n\n#### Attributes:\n\n* _ts_96_s_: current 96-bit timestamp seconds field\n* _ts_96_ns_: current 96-bit timestamp ns field\n* _ts_96_fns_: current 96-bit timestamp fractional ns field\n* _ts_64_ns_: current 64-bit timestamp ns field\n* _ts_64_fns_: current 64-bit timestamp fractional ns field\n\n#### Methods\n\n* `get_ts_96()`: return current 96-bit timestamp as an integer\n* `get_ts_96_ns()`: return current 96-bit timestamp in ns (float)\n* `get_ts_96_s()`: return current 96-bit timestamp in seconds (float)\n* `get_ts_64()`: return current 64-bit timestamp as an integer\n* `get_ts_64_ns()`: return current 64-bit timestamp in ns (float)\n* `get_ts_64_s()`: return current 64-bit timestamp in seconds (float)\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/alexforencich/cocotbext-eth/tarball/master",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/alexforencich/cocotbext-eth",
    "keywords": "ethernet,cocotb",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "cocotbext-eth",
    "package_url": "https://pypi.org/project/cocotbext-eth/",
    "platform": "any",
    "project_url": "https://pypi.org/project/cocotbext-eth/",
    "project_urls": {
      "Bug Tracker": "https://github.com/alexforencich/cocotbext-eth/issues",
      "Download": "https://github.com/alexforencich/cocotbext-eth/tarball/master",
      "Homepage": "https://github.com/alexforencich/cocotbext-eth",
      "Source Code": "https://github.com/alexforencich/cocotbext-eth"
    },
    "release_url": "https://pypi.org/project/cocotbext-eth/0.1.20/",
    "requires_dist": [
      "cocotb (>=1.6.0)",
      "cocotbext-axi (>=0.1.16)",
      "pytest ; extra == 'test'",
      "cocotb-test ; extra == 'test'"
    ],
    "requires_python": ">=3.6",
    "summary": "Ethernet interface modules for cocotb",
    "version": "0.1.20",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16571531,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0b90066ea354b0602a4407a12c216122bb4313307e03dc4c756fc9485e00860a",
          "md5": "716b75d581b5db1fe1791ba1a204c557",
          "sha256": "57afe028b79214838879af269cbf1202c9af911e81491793977874699b62c66e"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "716b75d581b5db1fe1791ba1a204c557",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 18050,
        "upload_time": "2020-12-06T09:15:46",
        "upload_time_iso_8601": "2020-12-06T09:15:46.468467Z",
        "url": "https://files.pythonhosted.org/packages/0b/90/066ea354b0602a4407a12c216122bb4313307e03dc4c756fc9485e00860a/cocotbext_eth-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f89036911bfd1f0c1e95ee3d8bb31d8bdc8ab066d07f97d839d158dca073c8b6",
          "md5": "dfab05440e60d1c52740e016de756c7c",
          "sha256": "92b17c854737d7558b634cc363d7182ac1c34f146717564d99e94b710a612e07"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "dfab05440e60d1c52740e016de756c7c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 21852,
        "upload_time": "2020-12-06T09:15:47",
        "upload_time_iso_8601": "2020-12-06T09:15:47.733287Z",
        "url": "https://files.pythonhosted.org/packages/f8/90/36911bfd1f0c1e95ee3d8bb31d8bdc8ab066d07f97d839d158dca073c8b6/cocotbext-eth-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2db73eff492b13f7652b5bded4cc287d74f574718ebc8b526be1c56ef8a31e97",
          "md5": "df4705b23e20d40abb23eb466352aea2",
          "sha256": "3d1aa3c887571caec73f1aba577ab2a90a01e0beadcd41c1fcc07289070cefbb"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.10-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "df4705b23e20d40abb23eb466352aea2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 26428,
        "upload_time": "2021-03-25T04:39:14",
        "upload_time_iso_8601": "2021-03-25T04:39:14.982929Z",
        "url": "https://files.pythonhosted.org/packages/2d/b7/3eff492b13f7652b5bded4cc287d74f574718ebc8b526be1c56ef8a31e97/cocotbext_eth-0.1.10-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "80eedc5202c1015d2656ce2c786a94a454cd27ffca6d0e170138746bd3cc5a27",
          "md5": "a7ff62a15645e5618a324e8e0f281c1b",
          "sha256": "2e13258a441ee9631521976928cffe24baac4f6b9d7245c152a5d30a61ea6685"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.10.tar.gz",
        "has_sig": false,
        "md5_digest": "a7ff62a15645e5618a324e8e0f281c1b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29656,
        "upload_time": "2021-03-25T04:39:16",
        "upload_time_iso_8601": "2021-03-25T04:39:16.226867Z",
        "url": "https://files.pythonhosted.org/packages/80/ee/dc5202c1015d2656ce2c786a94a454cd27ffca6d0e170138746bd3cc5a27/cocotbext-eth-0.1.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.12": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4f70d0bb787560300f3d7d76e65e9210ece7f5a0e04ab103504e2f51be136a8a",
          "md5": "629d21ade7feba4cb16a9e2d55aefe47",
          "sha256": "a5254dbb2badce96aba906dc1cb22c723e66d5b514c16443b5b3902d349cd417"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.12-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "629d21ade7feba4cb16a9e2d55aefe47",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 31748,
        "upload_time": "2021-04-01T22:26:25",
        "upload_time_iso_8601": "2021-04-01T22:26:25.155108Z",
        "url": "https://files.pythonhosted.org/packages/4f/70/d0bb787560300f3d7d76e65e9210ece7f5a0e04ab103504e2f51be136a8a/cocotbext_eth-0.1.12-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7630d11646b2030e63e5a724768fa0765ed0dfa0f2c7b01053d7eb4725d7e276",
          "md5": "e0ba082d879ac43111663697db44b22f",
          "sha256": "fd36db5d37137e9a89f7e7f1eecc529a6c192db80a8d46d63458598de39fb574"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.12.tar.gz",
        "has_sig": false,
        "md5_digest": "e0ba082d879ac43111663697db44b22f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 38238,
        "upload_time": "2021-04-01T22:26:26",
        "upload_time_iso_8601": "2021-04-01T22:26:26.730781Z",
        "url": "https://files.pythonhosted.org/packages/76/30/d11646b2030e63e5a724768fa0765ed0dfa0f2c7b01053d7eb4725d7e276/cocotbext-eth-0.1.12.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.14": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e921813c789a90054ddc6a383cdd78c3f6bcd3c1c8d7f143365cc8731e416b5d",
          "md5": "a23cd5e4b15c41c8549a553cb2f6aa5e",
          "sha256": "1f51d7aabf8e9defbe802c89ce2a80c076a44db99f7fc4fe4f9899aafea3329d"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.14-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a23cd5e4b15c41c8549a553cb2f6aa5e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 32009,
        "upload_time": "2021-04-13T01:38:55",
        "upload_time_iso_8601": "2021-04-13T01:38:55.671068Z",
        "url": "https://files.pythonhosted.org/packages/e9/21/813c789a90054ddc6a383cdd78c3f6bcd3c1c8d7f143365cc8731e416b5d/cocotbext_eth-0.1.14-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f03807c13959257f1569b8e1f619f787490681e73ff4057660f786bef30606b8",
          "md5": "3e4d6ecf7c51c741c1dfd22ea494d08c",
          "sha256": "d46867496107e8c0701a37b04a6f14c26e935c0ba8ba8bdd5be70bbc3c152ad3"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.14.tar.gz",
        "has_sig": false,
        "md5_digest": "3e4d6ecf7c51c741c1dfd22ea494d08c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 38416,
        "upload_time": "2021-04-13T01:38:57",
        "upload_time_iso_8601": "2021-04-13T01:38:57.234555Z",
        "url": "https://files.pythonhosted.org/packages/f0/38/07c13959257f1569b8e1f619f787490681e73ff4057660f786bef30606b8/cocotbext-eth-0.1.14.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.16": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8242e3d9e328cf56ca14ca5e2c023c86769a1e4562c31bcaa1f1299db6c3bf6a",
          "md5": "c6a2f80b9c381cf00c627de2ea51b3c7",
          "sha256": "15448a02812d18da8aebbd35f314d4a7e187d244370af34387fbc6d9c1ee3381"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.16-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c6a2f80b9c381cf00c627de2ea51b3c7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 32316,
        "upload_time": "2021-08-31T08:02:12",
        "upload_time_iso_8601": "2021-08-31T08:02:12.199502Z",
        "url": "https://files.pythonhosted.org/packages/82/42/e3d9e328cf56ca14ca5e2c023c86769a1e4562c31bcaa1f1299db6c3bf6a/cocotbext_eth-0.1.16-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9cfdb0fefd97067b53e5eca0f8831f44f00706d9fc931c875d6a6a8e669b40af",
          "md5": "acecc8260241de504c3cc3e480acd854",
          "sha256": "8c66ded9acd08c11777dbbec66bd0c894427a7b02bc14f03641dc8e976e1123d"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.16.tar.gz",
        "has_sig": false,
        "md5_digest": "acecc8260241de504c3cc3e480acd854",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 39236,
        "upload_time": "2021-08-31T08:02:13",
        "upload_time_iso_8601": "2021-08-31T08:02:13.845094Z",
        "url": "https://files.pythonhosted.org/packages/9c/fd/b0fefd97067b53e5eca0f8831f44f00706d9fc931c875d6a6a8e669b40af/cocotbext-eth-0.1.16.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.18": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8f1d1c4b58ff1a31619965b2c1da6b82a5e0b7eaaf61e387ce5a406b419a7847",
          "md5": "d3098f9a695f6eba54e48a045f31f2fb",
          "sha256": "8ebddd6476c7063279e2634cfe4d6b6d8fe4d73b7ef1457c4fb9c530ae93a0de"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.18-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d3098f9a695f6eba54e48a045f31f2fb",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 32575,
        "upload_time": "2021-11-07T21:17:00",
        "upload_time_iso_8601": "2021-11-07T21:17:00.088124Z",
        "url": "https://files.pythonhosted.org/packages/8f/1d/1c4b58ff1a31619965b2c1da6b82a5e0b7eaaf61e387ce5a406b419a7847/cocotbext_eth-0.1.18-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dfc813466a7dfbe2f5cd9cd34c3576971df67827482f5fce4e6b370a3bcb252d",
          "md5": "2ac655c233f5f7f7abecd2313f6fb0ff",
          "sha256": "e62187d2a8f9c6844838e36e0431544ab909e828e37b8b97d488ff31b3d569e5"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.18.tar.gz",
        "has_sig": false,
        "md5_digest": "2ac655c233f5f7f7abecd2313f6fb0ff",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 38979,
        "upload_time": "2021-11-07T21:17:01",
        "upload_time_iso_8601": "2021-11-07T21:17:01.409343Z",
        "url": "https://files.pythonhosted.org/packages/df/c8/13466a7dfbe2f5cd9cd34c3576971df67827482f5fce4e6b370a3bcb252d/cocotbext-eth-0.1.18.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "409ab1c42b326cf988e27cdfb3cad4a41b419ec4d587c51bf7b6a51d47b19f9b",
          "md5": "2e4fa6df900787b3b1e0c1ede06aff90",
          "sha256": "30734584544ffa375b9b89fe1c21783dac1baa5a43e65c9dfd1b51847b829cdc"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2e4fa6df900787b3b1e0c1ede06aff90",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 18279,
        "upload_time": "2020-12-19T00:23:39",
        "upload_time_iso_8601": "2020-12-19T00:23:39.026060Z",
        "url": "https://files.pythonhosted.org/packages/40/9a/b1c42b326cf988e27cdfb3cad4a41b419ec4d587c51bf7b6a51d47b19f9b/cocotbext_eth-0.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a4622d8197adc44731d2ca5f4330942d89f8e407b19addf928cbe3aa9fa91e97",
          "md5": "50f8840c7f23fb0f9f45dcdfdcaffb6c",
          "sha256": "78315b1ca3b40fc762002b9b04a1f0a92e61a12c39fb6902fc509b17fb11b6a7"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "50f8840c7f23fb0f9f45dcdfdcaffb6c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 21863,
        "upload_time": "2020-12-19T00:23:40",
        "upload_time_iso_8601": "2020-12-19T00:23:40.966330Z",
        "url": "https://files.pythonhosted.org/packages/a4/62/2d8197adc44731d2ca5f4330942d89f8e407b19addf928cbe3aa9fa91e97/cocotbext-eth-0.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.20": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2d93675b01d91dd2b91ad5c64c90b1d624e2ae4388d09279f0a2c1f0170f7511",
          "md5": "c4f278806ede5171b0175e00a5147efc",
          "sha256": "076dac5b8e244dd7eb5a04c829f20d88d2bf0ab4e078ffda6afdfe26bc21fc68"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.20-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c4f278806ede5171b0175e00a5147efc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 33171,
        "upload_time": "2023-01-26T02:55:44",
        "upload_time_iso_8601": "2023-01-26T02:55:44.015829Z",
        "url": "https://files.pythonhosted.org/packages/2d/93/675b01d91dd2b91ad5c64c90b1d624e2ae4388d09279f0a2c1f0170f7511/cocotbext_eth-0.1.20-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5e965086cb68fc962a66b9f232bd11aa6a67cecd1e516149f01d130f61d494c3",
          "md5": "af355a6c16df75c22f0fd74e49e4427b",
          "sha256": "0a70c28855a95c391d9db872fdb3b1fd5736c5b06507146d3cdd8d673406c39d"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.20.tar.gz",
        "has_sig": false,
        "md5_digest": "af355a6c16df75c22f0fd74e49e4427b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 40506,
        "upload_time": "2023-01-26T02:55:46",
        "upload_time_iso_8601": "2023-01-26T02:55:46.290579Z",
        "url": "https://files.pythonhosted.org/packages/5e/96/5086cb68fc962a66b9f232bd11aa6a67cecd1e516149f01d130f61d494c3/cocotbext-eth-0.1.20.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "74147217fc22ed1cbd7bfc391c801b1e9301789ec14591396568e0ffbde9080d",
          "md5": "54bc78471e3b093a50e3b336a78d4f73",
          "sha256": "e3f1d14084606186a818a0038731efab0a9b868ae0cfddf80c9b3f199935a9c6"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "54bc78471e3b093a50e3b336a78d4f73",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 24188,
        "upload_time": "2020-12-28T07:42:31",
        "upload_time_iso_8601": "2020-12-28T07:42:31.398988Z",
        "url": "https://files.pythonhosted.org/packages/74/14/7217fc22ed1cbd7bfc391c801b1e9301789ec14591396568e0ffbde9080d/cocotbext_eth-0.1.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4fbd5347c589495a5dcd976816a930e5c78fe1f6025469e458c22e8e8e3a3d8c",
          "md5": "965ee1f61c0c3cfb8b63cdf631c8e06b",
          "sha256": "85c3eee6c5ad73cec9822956c8bcd616a3808b578b4c96e3fee6ddfbae36ba27"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "965ee1f61c0c3cfb8b63cdf631c8e06b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 28046,
        "upload_time": "2020-12-28T07:42:33",
        "upload_time_iso_8601": "2020-12-28T07:42:33.240395Z",
        "url": "https://files.pythonhosted.org/packages/4f/bd/5347c589495a5dcd976816a930e5c78fe1f6025469e458c22e8e8e3a3d8c/cocotbext-eth-0.1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f8395db81b425e402d6f0de4ac6eadaec049bb1dcde6b2f3862cde8f3ce9bffd",
          "md5": "e05b10f1cbd8424f209d365bc36f8249",
          "sha256": "e417f16be3b7fd3d8a0b1cbda53a06a2025893858c11b7fcb16609a155194339"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e05b10f1cbd8424f209d365bc36f8249",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 25223,
        "upload_time": "2021-03-07T02:58:18",
        "upload_time_iso_8601": "2021-03-07T02:58:18.851933Z",
        "url": "https://files.pythonhosted.org/packages/f8/39/5db81b425e402d6f0de4ac6eadaec049bb1dcde6b2f3862cde8f3ce9bffd/cocotbext_eth-0.1.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5bfd74a1a230822e9b1924a2cae8188ed8e8d175bb039758cf12feba388883a8",
          "md5": "79b783f2db6b4de0be936dc8eadc5484",
          "sha256": "42028096628eeae921c2f4298b4985612315a5a45554504439f9ba186aef04fb"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.6.tar.gz",
        "has_sig": false,
        "md5_digest": "79b783f2db6b4de0be936dc8eadc5484",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29197,
        "upload_time": "2021-03-07T02:58:20",
        "upload_time_iso_8601": "2021-03-07T02:58:20.374784Z",
        "url": "https://files.pythonhosted.org/packages/5b/fd/74a1a230822e9b1924a2cae8188ed8e8d175bb039758cf12feba388883a8/cocotbext-eth-0.1.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3b811626f650265e347fbf3f168161ac816610936667515d7726730d002d2499",
          "md5": "a7cc6d8a77c31a610f38d4c82d1287bf",
          "sha256": "c4c84bd461828a24619688208aee0ab5d48a29c98f5b3a545c2ecc4154ca7d8c"
        },
        "downloads": -1,
        "filename": "cocotbext_eth-0.1.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a7cc6d8a77c31a610f38d4c82d1287bf",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 25409,
        "upload_time": "2021-03-18T02:15:39",
        "upload_time_iso_8601": "2021-03-18T02:15:39.022188Z",
        "url": "https://files.pythonhosted.org/packages/3b/81/1626f650265e347fbf3f168161ac816610936667515d7726730d002d2499/cocotbext_eth-0.1.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ad1ff1f6e606c5f54ae34721e25f3faec250a0cea2ec92b441e097c2fedf9027",
          "md5": "e2cbfa4e9749a61866d88225c4ad02ed",
          "sha256": "adedce5bb74f03a7455e55cc0264b4af2c7dbd4b92bb12a4f4b823e2b5b7f71b"
        },
        "downloads": -1,
        "filename": "cocotbext-eth-0.1.8.tar.gz",
        "has_sig": false,
        "md5_digest": "e2cbfa4e9749a61866d88225c4ad02ed",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29267,
        "upload_time": "2021-03-18T02:15:40",
        "upload_time_iso_8601": "2021-03-18T02:15:40.685555Z",
        "url": "https://files.pythonhosted.org/packages/ad/1f/f1f6e606c5f54ae34721e25f3faec250a0cea2ec92b441e097c2fedf9027/cocotbext-eth-0.1.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2d93675b01d91dd2b91ad5c64c90b1d624e2ae4388d09279f0a2c1f0170f7511",
        "md5": "c4f278806ede5171b0175e00a5147efc",
        "sha256": "076dac5b8e244dd7eb5a04c829f20d88d2bf0ab4e078ffda6afdfe26bc21fc68"
      },
      "downloads": -1,
      "filename": "cocotbext_eth-0.1.20-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "c4f278806ede5171b0175e00a5147efc",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 33171,
      "upload_time": "2023-01-26T02:55:44",
      "upload_time_iso_8601": "2023-01-26T02:55:44.015829Z",
      "url": "https://files.pythonhosted.org/packages/2d/93/675b01d91dd2b91ad5c64c90b1d624e2ae4388d09279f0a2c1f0170f7511/cocotbext_eth-0.1.20-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5e965086cb68fc962a66b9f232bd11aa6a67cecd1e516149f01d130f61d494c3",
        "md5": "af355a6c16df75c22f0fd74e49e4427b",
        "sha256": "0a70c28855a95c391d9db872fdb3b1fd5736c5b06507146d3cdd8d673406c39d"
      },
      "downloads": -1,
      "filename": "cocotbext-eth-0.1.20.tar.gz",
      "has_sig": false,
      "md5_digest": "af355a6c16df75c22f0fd74e49e4427b",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 40506,
      "upload_time": "2023-01-26T02:55:46",
      "upload_time_iso_8601": "2023-01-26T02:55:46.290579Z",
      "url": "https://files.pythonhosted.org/packages/5e/96/5086cb68fc962a66b9f232bd11aa6a67cecd1e516149f01d130f61d494c3/cocotbext-eth-0.1.20.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}