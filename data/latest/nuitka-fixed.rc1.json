{
  "info": {
    "author": "Kay Hayen",
    "author_email": "Kay.Hayen@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: POSIX :: BSD :: FreeBSD",
      "Operating System :: POSIX :: BSD :: NetBSD",
      "Operating System :: POSIX :: BSD :: OpenBSD",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: C",
      "Programming Language :: Python :: 2.6",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Compilers",
      "Topic :: Software Development :: Quality Assurance",
      "Topic :: System :: Software Distribution"
    ],
    "description": "####################\n Nuitka User Manual\n####################\n\n**********\n Overview\n**********\n\nThis document is the recommended first read if you are interested in\nusing Nuitka, understand its use cases, check what you can expect,\nlicense, requirements, credits, etc.\n\nNuitka is **the** Python compiler. It is written in Python. It is a\nseamless replacement or extension to the Python interpreter and compiles\n**every** construct that CPython 2.6, 2.7, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8,\n3.9, 3.10 have, when itself run with that Python version.\n\nIt then executes uncompiled code and compiled code together in an\nextremely compatible manner.\n\nYou can use all Python library modules and all extension modules freely.\n\nNuitka translates the Python modules into a C level program that then\nuses ``libpython`` and static C files of its own to execute in the same\nway as CPython does.\n\nAll optimization is aimed at avoiding overhead, where it's unnecessary.\nNone is aimed at removing compatibility, although slight improvements\nwill occasionally be done, where not every bug of standard Python is\nemulated, e.g. more complete error messages are given, but there is a\nfull compatibility mode to disable even that.\n\n*******\n Usage\n*******\n\nRequirements\n============\n\n-  C Compiler: You need a compiler with support for C11 or alternatively\n   for C++03 [#]_\n\n   Currently this means, you need to use one of these compilers:\n\n   -  The MinGW64 C11 compiler on Windows, must be based on gcc 11.2 or\n      higher. It will be *automatically* downloaded if no usable C\n      compiler is found, which is the recommended way of installing it,\n      as Nuitka will also upgrade it for you.\n\n   -  Visual Studio 2022 or higher on Windows [#]_, older versions will\n      work but only supported for commercial users. Configure to use the\n      English language pack for best results (Nuitka filters away\n      garbage outputs, but only for English language). It will be used\n      by default if installed.\n\n   -  On all other platforms, the ``gcc`` compiler of at least version\n      5.1, and below that the ``g++`` compiler of at least version 4.4\n      as an alternative.\n\n   -  The ``clang`` compiler on macOS X and most FreeBSD architectures.\n\n   -  On Windows the ``clang-cl`` compiler on Windows can be used if\n      provided by the Visual Studio installer.\n\n-  Python: Version 2.6, 2.7 or 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10\n\n   .. important::\n\n      For Python 3.3/3.4 and *only* those, we need other Python version\n      as a *compile time* dependency.\n\n      Nuitka itself is fully compatible with all listed versions, but\n      Scons as an internally used tool is not.\n\n      For these versions, you *need* a Python2 or Python 3.5 or higher\n      installed as well, but only during the compile time only. That is\n      for use with Scons (which orchestrates the C compilation), which\n      does not support the same Python versions as Nuitka.\n\n      In addition, on Windows, Python2 cannot be used because\n      ``clcache`` does not work with it, there a Python 3.5 or higher\n      needs to be installed.\n\n      Nuitka finds these needed Python versions (e.g. on Windows via\n      registry) and you shouldn't notice it as long as they are\n      installed.\n\n      Increasingly, other functionality is available when another Python\n      has a certain package installed. For example, onefile compression\n      will work for a Python 2.x when another Python is found that has\n      the ``zstandard`` package installed.\n\n   .. admonition:: Moving binaries to other machines\n\n      The created binaries can be made executable independent of the\n      Python installation, with ``--standalone`` and ``--onefile``\n      options.\n\n   .. admonition:: Binary filename suffix\n\n      The created binaries have an ``.exe`` suffix on Windows. On other\n      platforms they have no suffix for standalone mode, or ``.bin``\n      suffix, that you are free to remove or change, or specify with the\n      ``-o`` option.\n\n      The suffix for acceleration mode is added just to be sure that the\n      original script name and the binary name do not ever collide, so\n      we can safely do an overwrite without destroying the original\n      source file.\n\n   .. admonition:: It **has to** be CPython, Anaconda Python.\n\n      You need the standard Python implementation, called \"CPython\", to\n      execute Nuitka, because it is closely tied to implementation\n      details of it.\n\n   .. admonition:: It **cannot be** from Windows app store\n\n      It is known that Windows app store Python definitely does not\n      work, it's checked against. And on macOS \"pyenv\" likely does\n      **not** work.\n\n-  Operating System: Linux, FreeBSD, NetBSD, macOS X, and Windows (32/64\n   bits).\n\n   Others may work as well. The portability is expected to be generally\n   good, but the e.g. Scons usage may have to be adapted. Make sure to\n   match Windows Python and C compiler architecture, or else you will\n   get cryptic error messages.\n\n-  Architectures: x86, x86_64 (amd64), and arm, likely many more\n\n   Other architectures are expected to also work, out of the box, as\n   Nuitka is generally not using any hardware specifics. These are just\n   the ones tested and known to be good. Feedback is welcome. Generally,\n   the architectures that Debian supports can be considered good and\n   tested too.\n\n.. [#]\n\n   Support for this C11 is a given with gcc 5.x or higher or any clang\n   version.\n\n   The MSVC compiler doesn't do it yet. But as a workaround, as the C++03\n   language standard is very overlapping with C11, it is then used instead\n   where the C compiler is too old. Nuitka used to require a C++ compiler\n   in the past, but it changed.\n\n.. [#]\n\n   Download for free from\n   https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx\n   (the community editions work just fine).\n\n   The latest version is recommended but not required. On the other hand,\n   there is no need to except pre-Windows 10 support, and they might work\n   for you, but support of these configurations is only available to\n   commercial users.\n\nCommand Line\n============\n\nThe recommended way of executing Nuitka is ``<the_right_python> -m\nnuitka`` to be absolutely certain which Python interpreter you are\nusing, so it is easier to match with what Nuitka has.\n\nThe next best way of executing Nuitka bare that is from a source\ncheckout or archive, with no environment variable changes, most\nnoteworthy, you do not have to mess with ``PYTHONPATH`` at all for\nNuitka. You just execute the ``nuitka`` and ``nuitka-run`` scripts\ndirectly without any changes to the environment. You may want to add the\n``bin`` directory to your ``PATH`` for your convenience, but that step\nis optional.\n\nMoreover, if you want to execute with the right interpreter, in that\ncase, be sure to execute ``<the_right_python> bin/nuitka`` and be good.\n\n.. admonition:: Pick the right Interpreter\n\n   If you encounter a ``SyntaxError`` you absolutely most certainly have\n   picked the wrong interpreter for the program you are compiling.\n\nNuitka has a ``--help`` option to output what it can do:\n\n.. code:: bash\n\n   nuitka --help\n\nThe ``nuitka-run`` command is the same as ``nuitka``, but with a\ndifferent default. It tries to compile *and* directly execute a Python\nscript:\n\n.. code:: bash\n\n   nuitka-run --help\n\nThis option that is different is ``--run``, and passing on arguments\nafter the first non-option to the created binary, so it is somewhat more\nsimilar to what plain ``python`` will do.\n\nInstallation\n============\n\nFor most systems, there will be packages on the `download page\n<https://nuitka.net/doc/download.html>`__ of Nuitka. But you can also\ninstall it from source code as described above, but also like any other\nPython program it can be installed via the normal ``python setup.py\ninstall`` routine.\n\nLicense\n=======\n\nNuitka is licensed under the Apache License, Version 2.0; you may not\nuse it except in compliance with the License.\n\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*************************************\n Tutorial Setup and build on Windows\n*************************************\n\nThis is basic steps if you have nothing installed, of course if you have\nany of the parts, just skip it.\n\nSetup\n=====\n\nInstall Python\n--------------\n\n-  Download and install Python from\n   https://www.python.org/downloads/windows\n\n-  Select one of ``Windows x86-64 web-based installer`` (64 bits Python,\n   recommended) or ``x86 executable`` (32 bits Python) installer.\n\n-  Verify it's working using command ``python --version``.\n\nInstall Nuitka\n--------------\n\n-  ``python -m pip install nuitka``\n\n-  Verify using command ``python -m nuitka --version``\n\nWrite some code and test\n========================\n\nCreate a folder for the Python code\n-----------------------------------\n\n-  ``mkdir`` HelloWorld\n\n-  make a python file named **hello.py**\n\n.. code:: python\n\n   def talk(message):\n       return \"Talk \" + message\n\n\n   def main():\n       print(talk(\"Hello World\"))\n\n\n   if __name__ == \"__main__\":\n       main()\n\nTest your program\n-----------------\n\nDo as you normally would. Running Nuitka on code that works incorrectly\nis not easier to debug.\n\n.. code:: bash\n\n   python hello.py\n\n----\n\nBuild it using\n--------------\n\n.. code:: bash\n\n   python -m nuitka hello.py\n\n.. note::\n\n   This will prompt you to download a C caching tool (to speed up\n   repeated compilation of generated C code) and a MinGW64 based C\n   compiler unless you have a suitable MSVC installed. Say ``yes`` to\n   both those questions.\n\nRun it\n------\n\nExecute the ``hello.exe`` created near ``hello.py``.\n\nDistribute\n----------\n\nTo distribute, build with ``--standalone`` option, which will not output\na single executable, but a whole folder. Copy the resulting\n``hello.dist`` folder to the other machine and run it.\n\nYou may also try ``--onefile`` which does create a single file, but make\nsure that the mere standalone is working, before turning to it, as it\nwill make the debugging only harder, e.g. in case of missing data files.\n\n***********\n Use Cases\n***********\n\nUse Case 1 - Program compilation with all modules embedded\n==========================================================\n\nIf you want to compile a whole program recursively, and not only the\nsingle file that is the main program, do it like this:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports program.py\n\n.. note::\n\n   There are more fine grained controls than ``--follow-imports``\n   available. Consider the output of ``nuitka --help``. Including less\n   modules into the compilation, but instead using normal Python for it\n   will make it faster to compile.\n\nIn case you have a source directory with dynamically loaded files, i.e.\none which cannot be found by recursing after normal import statements\nvia the ``PYTHONPATH`` (which would be the recommended way), you can\nalways require that a given directory shall also be included in the\nexecutable:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports --include-plugin-directory=plugin_dir program.py\n\n.. note::\n\n   If you don't do any dynamic imports, simply setting your\n   ``PYTHONPATH`` at compilation time is what you should do.\n\n   Use ``--include-plugin-directory`` only if you make ``__import__()``\n   calls that Nuitka cannot predict, because they e.g. depend on command\n   line parameters. Nuitka also warns about these, and point to the\n   option.\n\n.. note::\n\n   The resulting filename will be ``program.exe`` on Windows,\n   ``program.bin`` on other platforms.\n\n.. note::\n\n   The resulting binary still depend on CPython and used C extension\n   modules being installed.\n\n   If you want to be able to copy it to another machine, use\n   ``--standalone`` and copy the created ``program.dist`` directory and\n   execute the ``program.exe`` (Windows) or ``program`` (other\n   platforms) put inside.\n\nUse Case 2 - Extension Module compilation\n=========================================\n\nIf you want to compile a single extension module, all you have to do is\nthis:\n\n.. code:: bash\n\n   python -m nuitka --module some_module.py\n\nThe resulting file ``some_module.so`` can then be used instead of\n``some_module.py``.\n\n.. note::\n\n   It's left as an exercise to the reader, to find out what happens if\n   both are present.\n\n.. note::\n\n   The option ``--follow-imports`` and other variants work as well, but\n   the included modules will only become importable *after* you imported\n   the ``some_module`` name.\n\n.. note::\n\n   The resulting extension module can only be loaded into a CPython of\n   the same version and doesn't include other extension modules.\n\nUse Case 3 - Package compilation\n================================\n\nIf you need to compile a whole package and embed all modules, that is\nalso feasible, use Nuitka like this:\n\n.. code:: bash\n\n   python -m nuitka --module some_package --include-package=some_package\n\n.. note::\n\n   The inclusion of the package contents needs to be provided manually,\n   otherwise, the package is empty. You can be more specific if you\n   want, and only include part of it. Data files located inside the\n   package will not be embedded by this process, you need to copy them\n   yourself with this approach.\n\nUse Case 4 - Program Distribution\n=================================\n\nFor distribution to other systems, there is the standalone mode which\nproduces a folder for which you can specify ``--standalone``.\n\n.. code:: bash\n\n   python -m nuitka --standalone program.py\n\nFollow all imports is default in this mode. You can selectively exclude\nmodules by specifically saying ``--nofollow-import-to``, but then an\n``ImportError`` will be raised when import of it is attempted at program\nruntime.\n\nFor data files to be included, use the option\n``--include-data-files=<source>=<target>`` where the source is a file\nsystem path, but target has to be specified relative. For standalone you\ncan also copy them manually, but this can do extra checks, and for\nonefile mode, there is no manual copying possible.\n\nTo copy some or all file in a directory, use the option\n``--include-data-files=/etc/*.txt=etc/`` where you get to specify shell\npatterns for the files, and a subdirectory where to put them, indicated\nby the trailing slash.\n\nTo copy a whole folder with all files, you can use\n``--include-data-dir=/path/to/images=images`` which will copy all files\nincluding a potential subdirectory structure. You cannot filter here,\ni.e. if you want only a partial copy, remove the files beforehand.\n\nFor package data, there is a better way, using\n``--include-package-data`` which detects data files of packages\nautomatically and copies them over. It even accepts patterns in shell\nstyle.\n\nWith data files, you are largely on your own. Nuitka keeps track of ones\nthat are needed by popular packages, but it might be incomplete. Raise\nissues if you encounter something in these.\n\nWhen that is working, you can use the onefile mode if you so desire.\n\n.. code:: bash\n\n   python -m nuitka --onefile program.py\n\nThis will create a single binary, which on Linux will not even unpack\nitself, but instead loop back mount its contents as a filesystem and use\nthat.\n\n.. code:: bash\n\n   # Create a binary that unpacks into a temporary folder\n   python -m nuitka --onefile program.py\n\n.. note::\n\n   There are more platform specific options, e.g. related to icons,\n   splash screen, and version information, consider the ``--help``\n   output for the details of these and check the section \"Good Looks\".\n\nAgain, on Windows, for the temporary file directory, by default the user\none is used, however this can be overridden with a path specification\ngiven in ``--windows-onefile-tempdir-spec=%TEMP%\\\\onefile_%PID%_%TIME%``\nwhich is the default and asserts that the temporary directories created\ncannot collide.\n\nCurrently these expanded tokens are available:\n\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| Token       | What this Expands to                                                      | Example                          |\n+=============+===========================================================================+==================================+\n| %TEMP%      | User temporary file directory                                             | C:\\Users\\...\\AppData\\Locals\\Temp |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %PID%       | Process ID                                                                | 2772                             |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %TIME%      | Time in seconds since the epoch.                                          | 1299852985                       |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %PROGRAM%   | Full program run-time filename of executable.                             | C:\\SomeWhere\\YourOnefile.exe     |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %CACHE_DIR% | Cache directory for the user.                                             | C:\\Users\\SomeBody\\AppData\\Local  |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %COMPANY%   | Value given as ``--windows-company-name``                                 | YourCompanyName                  |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %PRODUCT%   | Value given as ``--windows-product-name``                                 | YourProductName                  |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %VERSION%   | Combination of ``--windows-file-version`` & ``--windows-product-version`` | 3.0.0.0-1.0.0.0                  |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n| %HOME%      | Home directory for the user.                                              | /home/somebody                   |\n+-------------+---------------------------------------------------------------------------+----------------------------------+\n\n.. note::\n\n   It is your responsibility to make the path provided unique, on\n   Windows a running program will be locked, and while using a fixed\n   folder name is possible, it can cause locking issues in that case,\n   where the program gets restarted.\n\n   Usually you need to use ``%TIME%`` or at least ``%PID%`` to make a\n   path unique, and this is mainly intended for use cases, where e.g.\n   you want things to reside in a place you choose or abide your naming\n   conventions.\n\nUse Case 5 - Setuptools Wheels\n==============================\n\nIf you have a ``setup.py``, ``setup.cfg`` or ``pyproject.toml`` driven\ncreation of wheels for your software in place, putting Nuitka to use is\nextremely easy.\n\nLets start with the most common ``setuptools`` approach, you can -\nhaving Nuitka installed of course, simply execute the target\n``bdist_nuitka`` rather than the ``bdist_wheel``. It takes all the\noptions and allows you to specify some more, that are specific to\nNuitka.\n\n.. code:: python\n\n   # For setup.py if not you't use other build systems:\n   setup(\n      ...,\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': True,\n            # options without value, e.g. enforce using Clang\n            '--clang': None,\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': \"pyside2\",\n            # options with several values, e.g. avoiding including modules\n            '--nofollow-import-to' : [\"*.tests\", \"*.distutils\"],\n         }\n      },\n   )\n\n   # For setup.py with other build systems:\n   # The tuple nature of the arguments is required by the dark nature of\n   # \"setuptools\" and plugins to it, that insist on full compatibility,\n   # e.g. \"setuptools_rust\"\n\n   setup(\n      ...,\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': (\"setup.py\", True),\n            # options without value, e.g. enforce using Clang\n            '--clang': (\"setup.py\", None),\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': (\"setup.py\", \"pyside2\"),\n            # options with several values, e.g. avoiding including modules\n            '--nofollow-import-to' : (\"setup.py\", [\"*.tests\", \"*.distutils\"]),\n         }\n      },\n   )\n\nIf for some reason, you cannot or do not what to change the target, you\ncan add this to your ``setup.py``.\n\n.. code:: python\n\n   # For setup.py\n   setup(\n      ...,\n      build_with_nuitka=True\n   )\n\n.. note::\n\n   To temporarily disable the compilation, you could remove above line,\n   or edit the value to ``False`` by or take its value from an\n   environment variable if you so choose, e.g.\n   ``bool(os.environ.get(\"USE_NUITKA\", \"True\"))``. This is up to you.\n\nOr you could put it in your ``setup.cfg``\n\n.. code:: toml\n\n   [metadata]\n   build_with_nuitka = True\n\nAnd last, but not least, Nuitka also supports the new ``build`` meta, so\nwhen you have a ``pyproject.toml`` already, simple replace or add this\nvalue:\n\n.. code:: toml\n\n   [build-system]\n   requires = [\"setuptools>=42\", \"wheel\", \"nuitka\", \"toml\"]\n   build-backend = \"nuitka.distutils.Build\"\n\n   [nuitka]\n   # These are not recommended, but they make it obvious to have effect.\n\n   # boolean option, e.g. if you cared for C compilation commands, leading\n   # dashes are omitted\n   show-scons = true\n\n   # options with single values, e.g. enable a plugin of Nuitka\n   enable-plugin = pyside2\n\n   # options with several values, e.g. avoiding including modules, accepts\n   # list argument.\n   nofollow-import-to = [\"*.tests\", \"*.distutils\"]\n\n.. note::\n\n   For the ``nuitka`` requirement above absolute paths like\n   ``C:\\Users\\...\\Nuitka`` will also work on Linux, use an absolute path\n   with *two* leading slashes, e.g. ``//home/.../Nuitka``.\n\n********\n Tweaks\n********\n\nIcons\n=====\n\nFor good looks, you may specify icons. On Windows, you can provide an\nicon file, a template executable, or a PNG file. All of these will work\nand may even be combined:\n\n.. code:: bash\n\n   # These create binaries with icons:\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.png program.py\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.ico program.py\n   python -m nuitka --onefile --windows-icon-template-exe=your-icon.ico program.py\n\nSplash screen\n=============\n\nSplash screens are useful when program startup is slow. Onefile startup\nitself is not slow, but your program may be, and you cannot really know\nhow fast the computer used will be, so it might be a good idea to have\nthem. Luckily with Nuitka, they are easy to add for Windows.\n\nFor splash screen, you need to specify it as an PNG file, and then make\nsure to disable the splash screen when your program is ready, e.g. has\ncomplete the imports, prepared the window, connected to the database,\nand wants the splash screen to go away. Here we are using the project\nsyntax to combine the code with the creation, compile this:\n\n.. code:: python\n\n   # nuitka-project: --onefile\n   # nuitka-project: --onefile-windows-splash-screen-image={MAIN_DIRECTORY}/Splash-Screen.png\n\n   # Whatever this is obviously\n   print(\"Delaying startup by 10s...\")\n   import time\n   time.sleep(10)\n\n   # Use this code to signal the splash screen removal.\n   if \"NUITKA_ONEFILE_PARENT\" in os.environ:\n      splash_filename = os.path.join(\n         tempfile.gettempdir(),\n         \"onefile_%d_splash_feedback.tmp\" % int(os.environ[\"NUITKA_ONEFILE_PARENT\"]),\n      )\n\n      if os.path.exists(splash_filename):\n         os.unlink(splash_filename)\n\n   print(\"Done... splash should be gone.\")\n   ...\n\n   # Rest of your program goes here.\n\n******************\n Typical Problems\n******************\n\nMemory issues and compiler bugs\n===============================\n\nSometimes the C compilers will crash saying they cannot allocate memory\nor that some input was truncated, or similar error messages, clearly\nfrom it. There are several options you can explore here:\n\nAsk Nuitka to use less memory\n-----------------------------\n\nThere is a dedicated option ``--low-memory`` which influences decisions\nof Nuitka, such that it avoids high usage of memory during compilation\nat the cost of increased compile time.\n\nAvoid 32 bit C compiler/assembler memory limits\n-----------------------------------------------\n\nDo not use a 32 bits compiler, but a 64 bit one. If you are using Python\nwith 32 bits on Windows, you most definitely ought to use MSVC as the C\ncompiler, and not MinGW64. The MSVC is a cross compiler, and can use\nmore memory than gcc on that platform. If you are not on Windows, that\nis not an option of course. Also using the 64 bits Python will work.\n\nUse a minimal virtualenv\n------------------------\n\nWhen you compile from a living installation, that may well have many\noptional dependencies of your software installed. Some software, will\nthen have imports on these, and Nuitka will compile them as well. Not\nonly may these be just the trouble makers, they also require more\nmemory, so get rid of that. Of course you do have to check that your\nprogram has all needed dependencies before you attempt to compile, or\nelse the compiled program will equally not run.\n\nUse LTO compilation or not\n--------------------------\n\nWith ``--lto=yes`` or ``--lto=no`` you can switch the C compilation to\nonly produce bytecode, and not assembler code and machine code directly,\nbut make a whole program optimization at the end. This will change the\nmemory usage pretty dramatically, and if you error is coming from the\nassembler, using LTO will most definitely avoid that.\n\nSwitch the C compiler to clang\n------------------------------\n\nPeople have reported that programs that fail to compile with gcc due to\nits bugs or memory usage work fine with clang on Linux. On Windows, this\ncould still be an option, but it needs to be implemented first for the\nautomatic downloaded gcc, that would contain it. Since MSVC is known to\nbe more memory effective anyway, you should go there, and if you want to\nuse Clang, there is support for the one contained in MSVC.\n\nAdd a larger swap file to your embedded Linux\n---------------------------------------------\n\nOn systems with not enough RAM, you need to use swap space. Running out\nof it is possibly a cause, and adding more swap space, or one at all,\nmight solve the issue, but beware that it will make things extremely\nslow when the compilers swap back and forth, so consider the next tip\nfirst or on top of it.\n\nLimit the amount of compilation jobs\n------------------------------------\n\nWith the ``--jobs`` option of Nuitka, it will not start many C compiler\ninstances at once, each competing for the scarce resource of RAM. By\npicking a value of one, only one C compiler instance will be running,\nand on a 8 core system, that reduces the amount of memory by factor 8,\nso that's a natural choice right there.\n\nDynamic ``sys.path``\n====================\n\nIf your script modifies ``sys.path`` to e.g. insert directories with\nsource code relative to it, Nuitka will not be able to see those.\nHowever, if you set the ``PYTHONPATH`` to the resulting value, it will\nbe able to compile it and find the used modules from these paths as\nwell.\n\nManual Python File Loading\n--------------------------\n\nA very frequent pattern with private code is that it scans plugin\ndirectories of some kind, and uses ``os.listdir``, checks filenames, and\nthen opens a file and does ``exec`` on them. This approach is working\nfor Python code, but for compiled code, you should use this much cleaner\napproach, that works for pure Python code and is a lot less vulnerable.\n\n.. code:: python\n\n   # Using a package name, to locate the plugins, but this can actually\n   # be also a directory.\n   scan_path = scan_package.__path__\n\n   for item in pkgutil.iter_modules(scan_path):\n      # You may want to do it recursively, but we don't do this here in\n      # this example.\n      if item.ispkg:\n         continue\n\n      # The loader object knows how to do it.\n      module_loader = item.module_finder.find_module(item.name)\n\n      # Ignore bytecode only left overs. Deleted files can cause\n      # these things, so we just ignore it. Not every load has a\n      # filename, so we need to catch that error.\n      try:\n         if module_loader.get_filename().endswith(\".pyc\"):\n            continue\n      except AttributeError:\n         # Not a bytecode loader, but e.g. extension module, which is OK in case\n         # it was compiled with Nuitka.\n         pass\n\n      plugin_module = module_loader.load_module(item.name)\n\n      # At least for Python2, this is not set properly, but we use it for package\n      # data loading, so this manual patching up allows these to use proper methods\n      # for loading their stuff as well.\n      plugin_module.__package__ = scan_package.__name__\n\nMissing data files in standalone\n================================\n\nIf your program fails to file data, it can cause all kinds of different\nbehaviors, e.g. a package might complain it is not the right version,\nbecause a ``VERSION`` file check defaulted to unknown. The absence of\nicon files or help texts, may raise strange errors.\n\nOften the error paths for files not being present are even buggy and\nwill reveal programming errors like unbound local variables. Please look\ncarefully at these exceptions keeping in mind that this can be the\ncause. If you program works without standalone, chances are data files\nmight be cause.\n\nMissing DLLs in standalone\n==========================\n\nNuitka has plugins that deal with copying DLLs. For NumPy, SciPy,\nTkinter, etc.\n\nThese need special treatment to be able to run on other systems.\nManually copying them is not enough and will given strange errors.\nSometimes newer version of packages, esp. NumPy can be unsupported. In\nthis case you will have to raise an issue, and use the older one.\n\nDependency creep in standalone\n==============================\n\nSome packages are a single import, but to Nuitka mean that more than a\nthousand packages (literally) are to be included. The prime example of\nPandas, which does want to plug and use just about everything you can\nimagine. Multiple frameworks for syntax highlighting everything\nimaginable take time.\n\nNuitka will have to learn effective caching to deal with this in the\nfuture. Right now, you will have to deal with huge compilation times for\nthese.\n\nA major weapon in fighting dependency creep should be applied, namely\nthe ``anti-bloat`` plugin, which offers interesting abilities, that can\nbe put to use and block unneeded imports, giving an error for where they\noccur. Use it e.g. like this ``--noinclude-pytest-mode=nofollow\n--noinclude-setuptools-mode=nofollow`` and e.g. also\n``--noinclude-custom-mode=setuptools:error`` to get the compiler to\nerror out for a specific package. Make sure to check its help output. It\ncan take for each module of your choice, e.g. forcing also that e.g.\n``PyQt5`` is considered uninstalled for standalone mode.\n\nIt's also driven by a configuration file, ``anti-bloat.yml`` that you\ncan contribute to, removing typical bloat from packages. Feel free to\nenhance it and make PRs towards Nuitka with it.\n\nOnefile: Finding files\n======================\n\nThere is a difference between ``sys.argv[0]`` and ``__file__`` of the\nmain module for onefile more, that is caused by using a bootstrap to a\ntemporary location. The first one will be the original executable path,\nwhere as the second one will be the temporary or permanent path the\nbootstrap executable unpacks to. Data files will be in the later\nlocation, your original environment files will be in the former\nlocation.\n\nGiven 2 files, one which you expect to be near your executable, and one\nwhich you expect to be inside the onefile binary, access them like this.\n\n.. code:: python\n\n   # This will find a file *near* your onefile.exe\n   open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n   # This will find a file *inside* your onefile.exe\n   open(os.path.join(os.path.dirname(__file__), \"user-provided-file.txt\"))\n\nStandalone: Finding files\n-------------------------\n\nThe standard code that normally works, also works, you should refer to\n``os.path.dirname(__file__)`` or use all the packages like ``pkgutil``,\n``pkg_resources``, ``importlib.resources`` to locate data files near the\nstandalone binary.\n\n.. important::\n\n   What you should **not** do, is use the current directory\n   ``os.getcwd``, assuming that this is the script directory, that is\n   not generally true, and was never good code. Links, to a program,\n   etc. will all fail in bad ways.\n\nWindows Programs without console give no errors\n===============================================\n\nFor debugging purposes, remove ``--windows-disable-console`` or use the\noptions ``--windows-force-stdout-spec`` and\n``--windows-force-stderr-spec`` with paths as documented for\n``--windows-onefile-tempdir-spec`` above.\n\nDeep copying uncompiled functions\n=================================\n\nSometimes people use this kind of code, which for packages on PyPI, we\ndeal with by doing source code patches on the fly. If this is in your\nown code, here is what you can do:\n\n.. code:: python\n\n   def binder(func, name):\n      result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n      result = functools.update_wrapper(result, func)\n      result.__kwdefaults__ = func.__kwdefaults__\n      result.__name__ = name\n      return result\n\nCompiled functions cannot be used to create uncompiled ones from, so the\nabove code, will not work. However, there is a dedicated ``clone``\nmethod, that is specific to them, so use this instead.\n\n.. code:: python\n\n   def binder(func, name):\n      try:\n         result = func.clone()\n      except AttributeError:\n         result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n         result = functools.update_wrapper(result, func)\n         result.__kwdefaults__ = func.__kwdefaults__\n\n      result.__name__ = name\n      return result\n\n******\n Tips\n******\n\nNuitka Options in the code\n==========================\n\nThere is support for conditional options, and options using pre-defined\nvariables, this is an example:\n\n.. code:: python\n\n   # Compilation mode, support OS specific.\n   # nuitka-project-if: {OS} in (\"Windows\", \"Linux\", \"Darwin\", \"FreeBSD\"):\n   #    nuitka-project: --onefile\n   # nuitka-project-if: {OS} not in (\"Windows\", \"Linux\", \"Darwin\", \"FreeBSD\"):\n   #    nuitka-project: --standalone\n\n   # The PySide2 plugin covers qt-plugins\n   # nuitka-project: --enable-plugin=pyside2\n   # nuitka-project: --include-qt-plugins=sensible,qml\n\nThe comments must be a start of line, and indentation is to be used, to\nend a conditional block, much like in Python. There are currently no\nother keywords than the used ones demonstrated above.\n\nYou can put arbitrary Python expressions there, and if you wanted to\ne.g. access a version information of a package, you could simply use\n``__import__(\"module_name\").__version__`` if that would be required to\ne.g. enable or disable certain Nuitka settings. The only thing Nuitka\ndoes that makes this not Python expressions, is expanding ``{variable}``\nfor a pre-defined set of variables:\n\nTable with supported variables:\n\n+------------------+--------------------------------+------------------------------------------+\n| Variable         | What this Expands to           | Example                                  |\n+==================+================================+==========================================+\n| {OS}             | Name of the OS used            | Linux, Windows, Darwin, FreeBSD, OpenBSD |\n+------------------+--------------------------------+------------------------------------------+\n| {Version}        | Version of Nuitka              | e.g. (0, 6, 16)                          |\n+------------------+--------------------------------+------------------------------------------+\n| {Commercial}     | Version of Nuitka Commercial   | e.g. (0, 9, 4)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {Arch}           | Architecture used              | x86_64, arm64, etc.                      |\n+------------------+--------------------------------+------------------------------------------+\n| {MAIN_DIRECTORY} | Directory of the compiled file | some_dir/maybe_relative                  |\n+------------------+--------------------------------+------------------------------------------+\n| {Flavor}         | Variant of Python              | e.g. Debian Python, Anaconda Python      |\n+------------------+--------------------------------+------------------------------------------+\n\nThe use of ``{MAIN_DIRECTORY}`` is recommended when you want to specify\na filename relative to the main script, e.g. for use in data file\noptions or user package configuration yaml files,\n\n.. code:: python\n\n   # nuitka-project: --include-data-files={MAIN_DIRECTORY}/my_icon.png=my_icon.png\n   # nuitka-project: --user-package-configuration-file={MAIN_DIRECTORY}/user.nuitka-package.config.yml\n\nPython command line flags\n=========================\n\nFor passing things like ``-O`` or ``-S`` to Python, to your compiled\nprogram, there is a command line option name ``--python-flag=`` which\nmakes Nuitka emulate these options.\n\nThe most important ones are supported, more can certainly be added.\n\nCaching compilation results\n===========================\n\nThe C compiler, when invoked with the same input files, will take a long\ntime and much CPU to compile over and over. Make sure you are having\n``ccache`` installed and configured when using gcc (even on Windows). It\nwill make repeated compilations much faster, even if things are not yet\nnot perfect, i.e. changes to the program can cause many C files to\nchange, requiring a new compilation instead of using the cached result.\n\nOn Windows, with gcc Nuitka supports using ``ccache.exe`` which it will\noffer to download from an official source and it automatically. This is\nthe recommended way of using it on Windows, as other versions can e.g.\nhang.\n\nNuitka will pick up ``ccache`` if it's in found in system ``PATH``, and\nit will also be possible to provide if by setting\n``NUITKA_CCACHE_BINARY`` to the full path of the binary, this is for use\nin CI systems where things might be non-standard.\n\nFor the MSVC compilers and ClangCL setups, using the ``clcache`` is\nautomatic and included in Nuitka.\n\nControl where Caches live\n=========================\n\nThe storage for cache results of all kinds, downloads, cached\ncompilation results from C and Nuitka, is done in a platform dependent\ndirectory as determined by the ``appdirs`` package. However, you can\noverride it with setting the environment variable ``NUITKA_CACHE_DIR``\nto a base directory. This is for use in environments where the home\ndirectory is not persisted, but other paths are.\n\nRunners\n=======\n\nAvoid running the ``nuitka`` binary, doing ``python -m nuitka`` will\nmake a 100% sure you are using what you think you are. Using the wrong\nPython will make it give you ``SyntaxError`` for good code or\n``ImportError`` for installed modules. That is happening, when you run\nNuitka with Python2 on Python3 code and vice versa. By explicitly\ncalling the same Python interpreter binary, you avoid that issue\nentirely.\n\nFastest C Compilers\n===================\n\nThe fastest binaries of ``pystone.exe`` on Windows with 64 bits Python\nproved to be significantly faster with MinGW64, roughly 20% better\nscore. So it is recommended for use over MSVC. Using ``clang-cl.exe`` of\nClang7 was faster than MSVC, but still significantly slower than\nMinGW64, and it will be harder to use, so it is not recommended.\n\nOn Linux for ``pystone.bin`` the binary produced by ``clang6`` was\nfaster than ``gcc-6.3``, but not by a significant margin. Since gcc is\nmore often already installed, that is recommended to use for now.\n\nDifferences in C compilation times have not yet been examined.\n\nUnexpected Slowdowns\n====================\n\nUsing the Python DLL, like standard CPython does can lead to unexpected\nslowdowns, e.g. in uncompiled code that works with Unicode strings. This\nis because calling to the DLL rather than residing in the DLL causes\noverhead, and this even happens to the DLL with itself, being slower,\nthan a Python all contained in one binary.\n\nSo if feasible, aim at static linking, which is currently only possible\nwith Anaconda Python on non-Windows, Debian Python2, self compiled\nPythons (do not activate ``--enable-shared``, not needed), and installs\ncreated with ``pyenv``.\n\n.. note::\n\n   On Anaconda, you may need to execute ``conda install\n   libpython-static``\n\nStandalone executables and dependencies\n=======================================\n\nThe process of making standalone executables for Windows traditionally\ninvolves using an external dependency walker in order to copy necessary\nlibraries along with the compiled executables to the distribution\nfolder.\n\nThere is plenty of ways to find that something is missing. Do not\nmanually copy things into the folder, esp. not DLLs, as that's not going\nto work. Instead make bug reports to get these handled by Nuitka\nproperly.\n\nWindows errors with resources\n=============================\n\nOn Windows, the Windows Defender tool and the Windows Indexing Service\nboth scan the freshly created binaries, while Nuitka wants to work with\nit, e.g. adding more resources, and then preventing operations randomly\ndue to holding locks. Make sure to exclude your compilation stage from\nthese services.\n\nWindows standalone program redistribution\n=========================================\n\nWhether compiling with MingW or MSVC, the standalone programs have\nexternal dependencies to Visual C Runtime libraries. Nuitka tries to\nship those dependent DLLs by copying them from your system.\n\nBeginning with Microsoft Windows 10, Microsoft ships ``ucrt.dll``\n(Universal C Runtime libraries) which handles calls to\n``api-ms-crt-*.dll``.\n\nWith earlier Windows platforms (and wine/ReactOS), you should consider\ninstalling Visual C Runtime libraries before executing a Nuitka\nstandalone compiled program.\n\nDepending on the used C compiler, you'll need the following redist\nversions:\n\n+------------------+-------------+-------------------------------+\n| Visual C version | Redist Year | CPython                       |\n+==================+=============+===============================+\n| 14.2             | 2019        | 3.5, 3.6, 3.7, 3.8, 3.9, 3.10 |\n+------------------+-------------+-------------------------------+\n| 14.1             | 2017        | 3.5, 3.6, 3.7, 3.8            |\n+------------------+-------------+-------------------------------+\n| 14.0             | 2015        | 3.5, 3.6, 3.7, 3.8            |\n+------------------+-------------+-------------------------------+\n| 10.0             | 2010        | 3.3, 3.4                      |\n+------------------+-------------+-------------------------------+\n| 9.0              | 2008        | 2.6, 2.7                      |\n+------------------+-------------+-------------------------------+\n\nWhen using MingGW64, you'll need the following redist versions:\n\n+------------------+-------------+-------------------------------+\n| MingGW64 version | Redist Year | CPython                       |\n+==================+=============+===============================+\n| 8.1.0            | 2015        | 3.5, 3.6, 3.7, 3.8, 3.9, 3.10 |\n+------------------+-------------+-------------------------------+\n\nOnce the corresponding runtime libraries are installed on the target\nsystem, you may remove all ``api-ms-crt-*.dll`` files from your Nuitka\ncompiled dist folder.\n\nDetecting Nuitka at run time\n============================\n\nIt doesn't set ``sys.frozen`` unlike other tools. For Nuitka, we have\nthe module attribute ``__compiled__`` to test if a specific module was\ncompiled.\n\nProviding extra Options to Nuitka C compilation\n===============================================\n\nNuitka will apply values from the environment variables ``CCFLAGS``,\n``LDFLAGS`` during the compilation on top of what it determines to be\nnecessary. Beware of course, that is this is only useful if you know\nwhat you are doing, so should this pose an issues, raise them only with\nperfect information.\n\n*************\n Performance\n*************\n\nThis chapter gives an overview, of what to currently expect in terms of\nperformance from Nuitka. It's a work in progress and is updated as we\ngo. The current focus for performance measurements is Python 2.7, but\n3.x is going to follow later.\n\npystone results\n===============\n\nThe results are the top value from this kind of output, running pystone\n1000 times and taking the minimal value. The idea is that the fastest\nrun is most meaningful, and eliminates usage spikes.\n\n.. code:: bash\n\n   echo \"Uncompiled Python2\"\n   for i in {1..100}; do BENCH=1 python2 tests/benchmarks/pystone.py ; done | sort -n -r | head -n 1\n   python2 -m nuitka --lto=yes --pgo=yes tests/benchmarks/pystone.py\n   echo \"Compiled Python2\"\n   for i in {1..100}; do BENCH=1 ./pystone.bin ; done | sort -n -r | head -n 1\n\n   echo \"Uncompiled Python3\"\n   for i in {1..100}; do BENCH=1 python3 tests/benchmarks/pystone3.py ; done | sort -n -r | head -n 1\n   python3 -m nuitka --lto=yes --pgo=yes tests/benchmarks/pystone3.py\n   echo \"Compiled Python3\"\n   for i in {1..100}; do BENCH=1 ./pystone3.bin ; done | sort -n -r | head -n 1\n\n+-------------------+-------------------+----------------------+---------------------+\n| Python            | Uncompiled        | Compiled LTO         | Compiled PGO        |\n+===================+===================+======================+=====================+\n| Debian Python 2.7 | 137497.87 (1.000) | 460995.20 (3.353)    | 503681.91 (3.663)   |\n+-------------------+-------------------+----------------------+---------------------+\n| Nuitka Python 2.7 | 144074.78 (1.048) | 479271.51 (3.486)    | 511247.44 (3.718)   |\n+-------------------+-------------------+----------------------+---------------------+\n\n******************\n Where to go next\n******************\n\nRemember, this project needs constant work. Although the Python\ncompatibility is insanely high, and test suite works near perfectly,\nthere is still more work needed, esp. to make it do more optimization.\nTry it out, and when popular packages do not work, please make reports\non GitHub.\n\nFollow me on Twitter\n====================\n\nNuitka announcements and interesting stuff is pointed to on the Twitter\naccount, but obviously with not too many details. `@KayHayen\n<https://twitter.com/KayHayen>`_.\n\nReport issues or bugs\n=====================\n\nShould you encounter any issues, bugs, or ideas, please visit the\n`Nuitka bug tracker <https://github.com/kayhayen/Nuitka/issues>`__ and\nreport them.\n\nBest practices for reporting bugs:\n\n-  Please always include the following information in your report, for\n   the underlying Python version. You can easily copy&paste this into\n   your report.\n\n   .. code:: bash\n\n      python -m nuitka --version\n\n-  Try to make your example minimal. That is, try to remove code that\n   does not contribute to the issue as much as possible. Ideally come up\n   with a small reproducing program that illustrates the issue, using\n   ``print`` with different results when that programs runs compiled or\n   native.\n\n-  If the problem occurs spuriously (i.e. not each time), try to set the\n   environment variable ``PYTHONHASHSEED`` to ``0``, disabling hash\n   randomization. If that makes the problem go away, try increasing in\n   steps of 1 to a hash seed value that makes it happen every time,\n   include it in your report.\n\n-  Do not include the created code in your report. Given proper input,\n   it's redundant, and it's not likely that I will look at it without\n   the ability to change the Python or Nuitka source and re-run it.\n\n-  Do not send screenshots of text, that is bad and lazy. Instead,\n   capture text outputs from the console.\n\nWord of Warning\n===============\n\nConsider using this software with caution. Even though many tests are\napplied before releases, things are potentially breaking. Your feedback\nand patches to Nuitka are very welcome.\n\n*************\n Join Nuitka\n*************\n\nYou are more than welcome to join Nuitka development and help to\ncomplete the project in all minor and major ways.\n\nThe development of Nuitka occurs in git. We currently have these 3\nbranches:\n\n-  ``main``\n\n   This branch contains the stable release to which only hotfixes for\n   bugs will be done. It is supposed to work at all times and is\n   supported.\n\n-  ``develop``\n\n   This branch contains the ongoing development. It may at times contain\n   little regressions, but also new features. On this branch, the\n   integration work is done, whereas new features might be developed on\n   feature branches.\n\n-  ``factory``\n\n   This branch contains unfinished and incomplete work. It is very\n   frequently subject to ``git rebase`` and the public staging ground,\n   where my work for develop branch lives first. It is intended for\n   testing only and recommended to base any of your own development on.\n   When updating it, you very often will get merge conflicts. Simply\n   resolve those by doing ``git fetch && git reset --hard\n   origin/factory`` and switch to the latest version.\n\n.. note::\n\n   The `Developer Manual\n   <https://nuitka.net/doc/developer-manual.html>`__ explains the coding\n   rules, branching model used, with feature branches and hotfix\n   releases, the Nuitka design and much more. Consider reading it to\n   become a contributor. This document is intended for Nuitka users.\n\n***********\n Donations\n***********\n\nShould you feel that you cannot help Nuitka directly, but still want to\nsupport, please consider `making a donation\n<https://nuitka.net/pages/donations.html>`__ and help this way.\n\n***************************\n Unsupported functionality\n***************************\n\nThe ``co_code`` attribute of code objects\n=========================================\n\nThe code objects are empty for native compiled functions. There is no\nbytecode with Nuitka's compiled function objects, so there is no way to\nprovide it.\n\nPDB\n===\n\nThere is no tracing of compiled functions to attach a debugger to.\n\n**************\n Optimization\n**************\n\nConstant Folding\n================\n\nThe most important form of optimization is the constant folding. This is\nwhen an operation can be fully predicted at compile time. Currently,\nNuitka does these for some built-ins (but not all yet, somebody to look\nat this more closely will be very welcome!), and it does it e.g. for\nbinary/unary operations and comparisons.\n\nConstants currently recognized:\n\n.. code:: python\n\n   5 + 6  # binary operations\n   not 7  # unary operations\n   5 < 6  # comparisons\n   range(3)  # built-ins\n\nLiterals are the one obvious source of constants, but also most likely\nother optimization steps like constant propagation or function inlining\nwill be. So this one should not be underestimated and a very important\nstep of successful optimizations. Every option to produce a constant may\nimpact the generated code quality a lot.\n\n.. admonition:: Status\n\n   The folding of constants is considered implemented, but it might be\n   incomplete in that not all possible cases are caught. Please report\n   it as a bug when you find an operation in Nuitka that has only\n   constants as input and is not folded.\n\nConstant Propagation\n====================\n\nAt the core of optimizations, there is an attempt to determine the\nvalues of variables at run time and predictions of assignments. It\ndetermines if their inputs are constants or of similar values. An\nexpression, e.g. a module variable access, an expensive operation, may\nbe constant across the module of the function scope and then there needs\nto be none or no repeated module variable look-up.\n\nConsider e.g. the module attribute ``__name__`` which likely is only\never read, so its value could be predicted to a constant string known at\ncompile time. This can then be used as input to the constant folding.\n\n.. code:: python\n\n   if __name__ == \"__main__\":\n       # Your test code might be here\n       use_something_not_use_by_program()\n\n.. admonition:: Status\n\n   From modules attributes, only ``__name__`` is currently actually\n   optimized. Also possible would be at least ``__doc__``. In the\n   future, this may improve as SSA is expanded to module variables.\n\nBuilt-in Name Lookups\n=====================\n\nAlso, built-in exception name references are optimized if they are used\nas a module level read-only variables:\n\n.. code:: python\n\n   try:\n       something()\n   except ValueError:  # The ValueError is a slow global name lookup normally.\n       pass\n\n.. admonition:: Status\n\n   This works for all built-in names. When an assignment is done to such\n   a name, or it's even local, then, of course, it is not done.\n\nBuilt-in Call Prediction\n========================\n\nFor built-in calls like ``type``, ``len``, or ``range`` it is often\npossible to predict the result at compile time, esp. for constant inputs\nthe resulting value often can be precomputed by Nuitka. It can simply\ndetermine the result or the raised exception and replace the built-in\ncall with that value, allowing for more constant folding or code path\nreduction.\n\n.. code:: python\n\n   type(\"string\")  # predictable result, builtin type str.\n   len([1, 2])  # predictable result\n   range(3, 9, 2)  # predictable result\n   range(3, 9, 0)  # predictable exception, range raises due to 0.\n\n.. admonition:: Status\n\n   The built-in call prediction is considered implemented. We can simply\n   during compile time emulate the call and use its result or raised\n   exception. But we may not cover all the built-ins there are yet.\n\nSometimes the result of a built-in should not be predicted when the\nresult is big. A ``range()`` call e.g. may give too big values to\ninclude the result in the binary. Then it is not done.\n\n.. code:: python\n\n   range(100000)  # We do not want this one to be expanded\n\n.. admonition:: Status\n\n   This is considered mostly implemented. Please file bugs for built-ins\n   that are pre-computed, but should not be computed by Nuitka at\n   compile time with specific values.\n\nConditional Statement Prediction\n================================\n\nFor conditional statements, some branches may not ever be taken, because\nof the conditions being possible to predict. In these cases, the branch\nnot taken and the condition check is removed.\n\nThis can typically predict code like this:\n\n.. code:: python\n\n   if __name__ == \"__main__\":\n       # Your test code might be here\n       use_something_not_use_by_program()\n\nor\n\n.. code:: python\n\n   if False:\n       # Your deactivated code might be here\n       use_something_not_use_by_program()\n\nIt will also benefit from constant propagations, or enable them because\nonce some branches have been removed, other things may become more\npredictable, so this can trigger other optimization to become possible.\n\nEvery branch removed makes optimization more likely. With some code\nbranches removed, access patterns may be more friendly. Imagine e.g.\nthat a function is only called in a removed branch. It may be possible\nto remove it entirely, and that may have other consequences too.\n\n.. admonition:: Status\n\n   This is considered implemented, but for the maximum benefit, more\n   constants need to be determined at compile time.\n\nException Propagation\n=====================\n\nFor exceptions that are determined at compile time, there is an\nexpression that will simply do raise the exception. These can be\npropagated upwards, collecting potentially \"side effects\", i.e. parts of\nexpressions that were executed before it occurred, and still have to be\nexecuted.\n\nConsider the following code:\n\n.. code:: python\n\n   print(side_effect_having() + (1 / 0))\n   print(something_else())\n\nThe ``(1 / 0)`` can be predicted to raise a ``ZeroDivisionError``\nexception, which will be propagated through the ``+`` operation. That\npart is just Constant Propagation as normal.\n\nThe call ``side_effect_having()`` will have to be retained though, but\nthe ``print`` does not and can be turned into an explicit raise. The\nstatement sequence can then be aborted and as such the\n``something_else`` call needs no code generation or consideration\nanymore.\n\nTo that end, Nuitka works with a special node that raises an exception\nand is wrapped with a so-called \"side_effects\" expression, but yet can\nbe used in the code as an expression having a value.\n\n.. admonition:: Status\n\n   The propagation of exceptions is mostly implemented but needs\n   handling in every kind of operations, and not all of them might do it\n   already. As work progresses or examples arise, the coverage will be\n   extended. Feel free to generate bug reports with non-working\n   examples.\n\nException Scope Reduction\n=========================\n\nConsider the following code:\n\n.. code:: python\n\n   try:\n       b = 8\n       print(range(3, b, 0))\n       print(\"Will not be executed\")\n   except ValueError as e:\n       print(e)\n\nThe ``try`` block is bigger than it needs to be. The statement ``b = 8``\ncannot cause a ``ValueError`` to be raised. As such it can be moved to\noutside the try without any risk.\n\n.. code:: python\n\n   b = 8\n   try:\n       print(range(3, b, 0))\n       print(\"Will not be executed\")\n   except ValueError as e:\n       print(e)\n\n.. admonition:: Status\n\n   This is considered done. For every kind of operation, we trace if it\n   may raise an exception. We do however *not* track properly yet, what\n   can do a ``ValueError`` and what cannot.\n\nException Block Inlining\n========================\n\nWith the exception propagation, it then becomes possible to transform\nthis code:\n\n.. code:: python\n\n   try:\n       b = 8\n       print(range(3, b, 0))\n       print(\"Will not be executed!\")\n   except ValueError as e:\n       print(e)\n\n.. code:: python\n\n   try:\n       raise ValueError(\"range() step argument must not be zero\")\n   except ValueError as e:\n       print(e)\n\nWhich then can be lowered in complexity by avoiding the raise and catch\nof the exception, making it:\n\n.. code:: python\n\n   e = ValueError(\"range() step argument must not be zero\")\n   print(e)\n\n.. admonition:: Status\n\n   This is not implemented yet.\n\nEmpty Branch Removal\n====================\n\nFor loops and conditional statements that contain only code without\neffect, it should be possible to remove the whole construct:\n\n.. code:: python\n\n   for i in range(1000):\n       pass\n\nThe loop could be removed, at maximum, it should be considered an\nassignment of variable ``i`` to ``999`` and no more.\n\n.. admonition:: Status\n\n   This is not implemented yet, as it requires us to track iterators,\n   and their side effects, as well as loop values, and exit conditions.\n   Too much yet, but we will get there.\n\nAnother example:\n\n.. code:: python\n\n   if side_effect_free:\n       pass\n\nThe condition check should be removed in this case, as its evaluation is\nnot needed. It may be difficult to predict that ``side_effect_free`` has\nno side effects, but many times this might be possible.\n\n.. admonition:: Status\n\n   This is considered implemented. The conditional statement nature is\n   removed if both branches are empty, only the condition is evaluated\n   and checked for truth (in cases that could raise an exception).\n\nUnpacking Prediction\n====================\n\nWhen the length of the right-hand side of an assignment to a sequence\ncan be predicted, the unpacking can be replaced with multiple\nassignments.\n\n.. code:: python\n\n   a, b, c = 1, side_effect_free(), 3\n\n.. code:: python\n\n   a = 1\n   b = side_effect_free()\n   c = 3\n\nThis is of course only really safe if the left-hand side cannot raise an\nexception while building the assignment targets.\n\nWe do this now, but only for constants, because we currently have no\nability to predict if an expression can raise an exception or not.\n\n.. admonition:: Status\n\n   Not implemented yet. Will need us to see through the unpacking of\n   what is an iteration over a tuple, we created ourselves. We are not\n   there yet, but we will get there.\n\nBuilt-in Type Inference\n=======================\n\nWhen a construct like ``in xrange()`` or ``in range()`` is used, it is\npossible to know what the iteration does and represent that so that\niterator users can use that instead.\n\nI consider that:\n\n.. code:: python\n\n   for i in xrange(1000):\n       something(i)\n\ncould translate ``xrange(1000)`` into an object of a special class that\ndoes the integer looping more efficiently. In case ``i`` is only\nassigned from there, this could be a nice case for a dedicated class.\n\n.. admonition:: Status\n\n   Future work, not even started.\n\nQuicker Function Calls\n======================\n\nFunctions are structured so that their parameter parsing and ``tp_call``\ninterface is separate from the actual function code. This way the call\ncan be optimized away. One problem is that the evaluation order can\ndiffer.\n\n.. code:: python\n\n   def f(a, b, c):\n       return a, b, c\n\n\n   f(c=get1(), b=get2(), a=get3())\n\nThis will have to evaluate first ``get1()``, then ``get2()`` and only\nthen ``get3()`` and then make the function call with these values.\n\nTherefore it will be necessary to have a staging of the parameters\nbefore making the actual call, to avoid a re-ordering of the calls to\n``get1()``, ``get2()``, and ``get3()``.\n\n.. admonition:: Status\n\n   Not even started. A re-formulation that avoids the dictionary to call\n   the function, and instead uses temporary variables appears to be\n   relatively straight forward once we do that kind of parameter\n   analysis.\n\nLowering of iterated Container Types\n====================================\n\nIn some cases, accesses to ``list`` constants can become ``tuple``\nconstants instead.\n\nConsider that:\n\n.. code:: python\n\n   for x in [a, b, c]:\n       something(x)\n\nCan be optimized into this:\n\n.. code:: python\n\n   for x in (a, b, c):\n       something(x)\n\nThis allows for simpler, faster code to be generated, and fewer checks\nneeded, because e.g. the ``tuple`` is clearly immutable, whereas the\n``list`` needs a check to assert that. This is also possible for sets.\n\n.. admonition:: Status\n\n   Implemented, even works for non-constants. Needs other optimization\n   to become generally useful, and will itself help other optimization\n   to become possible. This allows us to e.g. only treat iteration over\n   tuples, and not care about sets.\n\nIn theory, something similar is also possible for ``dict``. For the\nlater, it will be non-trivial though to maintain the order of execution\nwithout temporary values introduced. The same thing is done for pure\nconstants of these types, they change to ``tuple`` values when iterated.\n\n*************************\n Updates for this Manual\n*************************\n\nThis document is written in REST. That is an ASCII format which is\nreadable to human, but easily used to generate PDF or HTML documents.\n\nYou will find the current version at:\nhttps://nuitka.net/doc/user-manual.html\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://nuitka.net",
    "keywords": "compiler,python,nuitka",
    "license": "Apache License, Version 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "Nuitka-fixed",
    "package_url": "https://pypi.org/project/Nuitka-fixed/",
    "platform": null,
    "project_url": "https://pypi.org/project/Nuitka-fixed/",
    "project_urls": {
      "Commercial": "https://nuitka.net/doc/commercial.html",
      "Documentation": "https://nuitka.net/doc/user-manual.html",
      "Donations": "https://nuitka.net/pages/donations.html",
      "Homepage": "https://nuitka.net",
      "Source": "https://github.com/Nuitka/Nuitka",
      "Support": "https://nuitka.net/pages/support.html",
      "Twitter": "https://twitter.com/KayHayen"
    },
    "release_url": "https://pypi.org/project/Nuitka-fixed/1.1.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Python compiler with full language support and CPython compatibility",
    "version": "1.1.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15340286,
  "releases": {
    "1.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bb03e1d6002fdb9692635320b96462574282f11eeeb826f8b5a890e75ed4975c",
          "md5": "933a3a45038291c2f3c9721d458b570d",
          "sha256": "335c874c3461709f1ae9991813331db524aac78c2994cef0762d0da22bd4f10f"
        },
        "downloads": -1,
        "filename": "Nuitka_fixed-1.1.2-cp310-cp310-win_amd64.whl",
        "has_sig": false,
        "md5_digest": "933a3a45038291c2f3c9721d458b570d",
        "packagetype": "bdist_wheel",
        "python_version": "cp310",
        "requires_python": null,
        "size": 4702777,
        "upload_time": "2022-10-07T22:44:11",
        "upload_time_iso_8601": "2022-10-07T22:44:11.027744Z",
        "url": "https://files.pythonhosted.org/packages/bb/03/e1d6002fdb9692635320b96462574282f11eeeb826f8b5a890e75ed4975c/Nuitka_fixed-1.1.2-cp310-cp310-win_amd64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c4a5850b0cb289ad37156ba0bd18abe9aa9ea116a4dd542f556af75943933051",
          "md5": "6699b01f26240aa4b1882ec74615e6c6",
          "sha256": "7610fc318bcc1a6e3cdf6e7b7003b047461e5329e29107ed9c95991ec30b07c5"
        },
        "downloads": -1,
        "filename": "Nuitka_fixed-1.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "6699b01f26240aa4b1882ec74615e6c6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 3911676,
        "upload_time": "2022-10-07T22:44:16",
        "upload_time_iso_8601": "2022-10-07T22:44:16.491351Z",
        "url": "https://files.pythonhosted.org/packages/c4/a5/850b0cb289ad37156ba0bd18abe9aa9ea116a4dd542f556af75943933051/Nuitka_fixed-1.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "bb03e1d6002fdb9692635320b96462574282f11eeeb826f8b5a890e75ed4975c",
        "md5": "933a3a45038291c2f3c9721d458b570d",
        "sha256": "335c874c3461709f1ae9991813331db524aac78c2994cef0762d0da22bd4f10f"
      },
      "downloads": -1,
      "filename": "Nuitka_fixed-1.1.2-cp310-cp310-win_amd64.whl",
      "has_sig": false,
      "md5_digest": "933a3a45038291c2f3c9721d458b570d",
      "packagetype": "bdist_wheel",
      "python_version": "cp310",
      "requires_python": null,
      "size": 4702777,
      "upload_time": "2022-10-07T22:44:11",
      "upload_time_iso_8601": "2022-10-07T22:44:11.027744Z",
      "url": "https://files.pythonhosted.org/packages/bb/03/e1d6002fdb9692635320b96462574282f11eeeb826f8b5a890e75ed4975c/Nuitka_fixed-1.1.2-cp310-cp310-win_amd64.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c4a5850b0cb289ad37156ba0bd18abe9aa9ea116a4dd542f556af75943933051",
        "md5": "6699b01f26240aa4b1882ec74615e6c6",
        "sha256": "7610fc318bcc1a6e3cdf6e7b7003b047461e5329e29107ed9c95991ec30b07c5"
      },
      "downloads": -1,
      "filename": "Nuitka_fixed-1.1.2.tar.gz",
      "has_sig": false,
      "md5_digest": "6699b01f26240aa4b1882ec74615e6c6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 3911676,
      "upload_time": "2022-10-07T22:44:16",
      "upload_time_iso_8601": "2022-10-07T22:44:16.491351Z",
      "url": "https://files.pythonhosted.org/packages/c4/a5/850b0cb289ad37156ba0bd18abe9aa9ea116a4dd542f556af75943933051/Nuitka_fixed-1.1.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}