{
  "info": {
    "author": "Caleb Hattingh",
    "author_email": "caleb.hattingh@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy"
    ],
    "description": "\n\n.. image:: https://github.com/cjrh/excitertools/workflows/Python%20application/badge.svg\n    :target: https://github.com/cjrh/excitertools/actions\n\n.. image:: https://coveralls.io/repos/github/cjrh/excitertools/badge.svg?branch=master\n    :target: https://coveralls.io/github/cjrh/excitertools?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/excitertools.svg\n    :target: https://pypi.python.org/pypi/excitertools\n\n.. image:: https://img.shields.io/github/tag/cjrh/excitertools.svg\n    :target: https://github.com/cjrh/excitertools\n\n.. image:: https://img.shields.io/badge/install-pip%20install%20excitertools-ff69b4.svg\n    :target: https://img.shields.io/badge/install-pip%20install%20excitertools-ff69b4.svg\n\n.. image:: https://img.shields.io/badge/dependencies-more--itertools-4488ff.svg\n    :target: https://more-itertools.readthedocs.io/en/stable/\n\n.. image:: https://img.shields.io/pypi/v/excitertools.svg\n    :target: https://img.shields.io/pypi/v/excitertools.svg\n\n.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\n    :target: http://calver.org/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/ambv/black\n\n\n.. _more-itertools: https://more-itertools.readthedocs.io/en/stable/index.html\n\n.. _excitertools:\n\nexcitertools\n############\n\n``itertools`` reimagined as a `fluent interface <https://en.wikipedia.org/wiki/Fluent_interface>`_.\n\n    In software engineering, a fluent interface is an object-oriented API whose design\n    relies extensively on method chaining. Its goal is to increase code legibility by\n    creating a domain-specific language (DSL). The term was coined in 2005 by Eric\n    Evans and Martin Fowler.\n\n    `*Wikipedia - Fluent Interface* <https://en.wikipedia.org/wiki/Fluent_interface>`_\n\nNote that nearly all of the ``more-itertools`` extension library is included.\n\nDemo\n****\n\n.. code-block:: python\n\n    >>> range(10).map(lambda x: x*7).filter(lambda x: x % 3 == 0).collect()\n    [0, 21, 42, 63]\n    >>> range(10).map(lambda x: x*7).filter(lambda x: x > 0 and x % 3 == 0).collect()\n    [21, 42, 63]\n\nWhen the lines get long, parens can be used to split up each instruction:\n\n.. code-block:: python\n\n    >>> (\n    ...     range(10)\n    ...         .map(lambda x: x*7)\n    ...         .filter(lambda x: x % 3 == 0)\n    ...         .collect()\n    ... )\n    [0, 21, 42, 63]\n\nWhat's also interesting about that is how lambda's can easily contain these\nprocessing chains, since an entire chain is a single expression. For\nexample:\n\n.. code-block:: python\n\n    >>> names = ['caleb', 'james', 'gina']\n    >>> Iter(names).map(\n    ...     lambda name: (\n    ...         Iter(name)\n    ...             .map(lambda c: c.upper() if c in 'aeiouy' else c)\n    ...             .collect(str)\n    ...     )\n    ... ).collect()\n    ['cAlEb', 'jAmEs', 'gInA']\n\nSomething I've noticed is that ``reduce`` seems easier to use and reason\nabout with this fluent interface, as compared to the conventional usage\nas a standalone function; also, the operator module makes ``reduce`` quite\nuseful for simple cases:\n\n.. code-block:: python\n\n    >>> from operator import add, mul\n    >>> (\n    ...     range(10)\n    ...     .map(lambda x: x*7)\n    ...     .filter(lambda x: x > 0 and x % 3 == 0)\n    ...     .reduce(add)\n    ... )\n    126\n    >>> (\n    ...     range(10)\n    ...     .map(lambda x: x*7)\n    ...     .filter(lambda x: x > 0 and x % 3 == 0)\n    ...     .reduce(mul)\n    ... )\n    55566\n\n.. contents::\n    :depth: 1\n\n\n.. |warning| unicode:: U+26A0\n.. |cool| unicode:: U+2728\n.. |flux| unicode:: U+1F6E0\n.. |source| unicode:: U+1F3A4\n.. |sink| unicode:: U+1F3A7\n.. |inf| unicode:: U+267E\n\n\nHow to Understand the API Documentation\n#######################################\n\nSeveral symbols are used to indicate things about parts of the API:\n\n- |source| This function is a *source*, meaning that it produces data\n  that will be processed in an iterator chain.\n- |sink| This function is a *sink*, meaning that it consumes data that\n  was processed in an iterator chain.\n- |inf| This function returns an infinite iterable\n- |warning| Warning - pay attention\n- |flux| This API is still in flux, and might be changed or\n  removed in the future\n- |cool| Noteworthy; could be especially useful in many situations.\n\nThe API is arranged roughly with the module-level functions first, and\nthereafter the Iter_ class itself. It is the Iter_ class that does\nthe work to allow these iterators to be chained together. However, the\nmodule-level functions are more likely to be used directly and that's\nwhy they're presented first.\n\nThe API includes wrappers for the stdlib *itertools* module, including\nthe \"recipes\" given in the *itertools* docs, as well as wrappers for\nthe iterators from the more-itertools_ 3rd-party package.\n\nModule-level Replacements for Builtins\n######################################\n\nThe following module-level functions, like range_, zip_ and so on, are\nintended to be used as replacements for their homonymous builtins. The\nonly difference between these and the builtin versions is that these\nreturn instances of the Iter_ class. Note that because Iter_ is itself\niterable, it means that the functions here can be used as drop-in\nreplacements.\n\nOnce you have an Iter_ instance, all of its methods become available\nvia function call chaining, so these toplevel functions are really only\na convenience to \"get started\" using the chaining syntax with minimal\nupfront cost in your own code.\n\n.. contents::\n    :local:\n\n\n\n.. _range:\n\n\n|source| ``range(*args) -> \"Iter[int]\"``\n****************************************\n\n\nReplacement for the builtin ``range`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\nAll the same calling variations work because this function merely wraps\nthe original function.\n\n.. code-block:: python\n\n    >>> range(3).collect()\n    [0, 1, 2]\n    >>> range(1, 4).collect()\n    [1, 2, 3]\n    >>> range(1, 6, 2).collect()\n    [1, 3, 5]\n    >>> range(1, 101, 3).filter(lambda x: x % 7 == 0).collect()\n    [7, 28, 49, 70, 91]\n\nThis example multiples, element by element, the series ``[0:5]`` with the\nseries ``[1:6]``. Two things to note: Firstly, Iter.zip_ is used to emit\nthe tuples from each series. Secondly, Iter.starmap_ is used to receive\nthose tuples into separate arguments in the ``lambda``.\n\n.. code-block:: python\n\n    >>> range(5).zip(range(1, 6)).starmap(lambda x, y: x * y).collect()\n    [0, 2, 6, 12, 20]\n\nWhen written in a single line as above, it can get difficult to follow\nthe chain of logic if there are many processing steps. Parentheses in\nPython allow grouping such that expressions can be spread over multiple\nlines.\n\nThis is the same example as the prior one, but formatted to be spread\nover several lines. This is much clearer:\n\n.. code-block:: python\n\n    >>> # Written out differently\n    >>> (\n    ...     range(5)\n    ...         .zip(range(1, 6))\n    ...         .starmap(lambda x, y: x * y)\n    ...         .collect()\n    ... )\n    [0, 2, 6, 12, 20]\n\nIf you wanted the sum instead, it isn't necessary to do the collection\nat all:\n\n.. code-block:: python\n\n    >>> (\n    ...     range(5)\n    ...         .zip(range(1, 6))\n    ...         .starmap(lambda x, y: x * y)\n    ...         .sum()\n    ... )\n    40\n\n\n\n.. _zip:\n\n\n``zip(*iterables: Any) -> \"Iter[Tuple[T, ...]]\"``\n*************************************************\nReplacement for the builtin ``zip`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. _enumerate:\n\n\n``enumerate(iterable) -> \"Iter[Tuple[int, T]]\"``\n************************************************\nReplacement for the builtin ``enumerate`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> enumerate(string.ascii_lowercase).take(3).collect()\n    [(0, 'a'), (1, 'b'), (2, 'c')]\n\n\n\n\n.. _map:\n\n\n``map(func: Union[Callable[..., C], str], iterable) -> \"Iter[C]\"``\n******************************************************************\nReplacement for the builtin ``map`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> result = map(lambda x: (x, ord(x)), 'caleb').dict()\n    >>> assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}\n\n    >>> result = map('x, ord(x)', 'caleb').dict()\n    >>> assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}\n\n\n.. _filter:\n\n\n``filter(function: \"Callable[[Any], bool]\", iterable: \"Iterable[T]\") -> \"Iter[T]\"``\n***********************************************************************************\nReplacement for the builtin ``filter`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> filter(lambda x: x % 3 == 0, range(10)).collect()\n    [0, 3, 6, 9]\n\n\n\n\n.. _count:\n\n\n|source| ``count(start=0, step: int = 1) -> \"Iter[int]\"``\n*********************************************************\n\n\nReplacement for the itertools ``count`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> count().take(5).collect()\n    [0, 1, 2, 3, 4]\n    >>> count(0).take(0).collect()\n    []\n    >>> count(10).take(0).collect()\n    []\n    >>> count(10).take(5).collect()\n    [10, 11, 12, 13, 14]\n    >>> count(1).filter(lambda x: x > 10).take(5).collect()\n    [11, 12, 13, 14, 15]\n\n\n\n.. _cycle:\n\n\n``cycle(iterable) -> \"Iter[T]\"``\n********************************\nReplacement for the itertools ``count`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> cycle(range(3)).take(6).collect()\n    [0, 1, 2, 0, 1, 2]\n    >>> cycle([]).take(6).collect()\n    []\n    >>> cycle(range(3)).take(0).collect()\n    []\n\n\n\n.. _repeat:\n\n\n|source| ``repeat(object: C, times=None) -> \"Iter[C]\"``\n*******************************************************\n\n\nReplacement for the itertools ``count`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> repeat('a').take(3).collect()\n    ['a', 'a', 'a']\n    >>> repeat([1, 2]).take(3).collect()\n    [[1, 2], [1, 2], [1, 2]]\n    >>> repeat([1, 2]).take(3).collapse().collect()\n    [1, 2, 1, 2, 1, 2]\n    >>> repeat([1, 2]).collapse().take(3).collect()\n    [1, 2, 1]\n    >>> repeat('a', times=3).collect()\n    ['a', 'a', 'a']\n\n\n\n\nThis next set of functions return iterators that terminate on the shortest \ninput sequence.\n\n\n\n.. _accumulate:\n\n\n``accumulate(iterable, func=None, *, initial=None)``\n****************************************************\nReplacement for the itertools ``accumulate`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> accumulate([1, 2, 3, 4, 5]).collect()\n    [1, 3, 6, 10, 15]\n    >>> if sys.version_info >= (3, 8):\n    ...     output = accumulate([1, 2, 3, 4, 5], initial=100).collect()\n    ...     assert output == [100, 101, 103, 106, 110, 115]\n    >>> accumulate([1, 2, 3, 4, 5], operator.mul).collect()\n    [1, 2, 6, 24, 120]\n    >>> accumulate([]).collect()\n    []\n    >>> accumulate('abc').collect()\n    ['a', 'ab', 'abc']\n    >>> accumulate(b'abc').collect()\n    [97, 195, 294]\n    >>> accumulate(bytearray(b'abc')).collect()\n    [97, 195, 294]\n\n\n\n.. _chain:\n\n\n``chain(*iterables: Iterable[T]) -> \"Iter[T]\"``\n***********************************************\nReplacement for the itertools ``chain`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> chain('ABC', 'DEF').collect()\n    ['A', 'B', 'C', 'D', 'E', 'F']\n    >>> chain().collect()\n    []\n\n\n\n.. _chain_from_iterable:\n\n\n``chain_from_iterable(iterable) -> \"Iter[T]\"``\n**********************************************\nReplacement for the itertools ``chain.from_iterable`` method.\nThis version returns an instance of Iter_ to allow\nfurther iterable chaining.\n\n.. code-block:: python\n\n    >>> chain_from_iterable(['ABC', 'DEF']).collect()\n    ['A', 'B', 'C', 'D', 'E', 'F']\n    >>> chain_from_iterable([]).collect()\n    []\n\n\n\n.. _compress:\n\n\n``compress(data, selectors)``\n*****************************\nReplacement for the itertools ``compress`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> compress('ABCDEF', [1, 0, 1, 0, 1, 1]).collect()\n    ['A', 'C', 'E', 'F']\n\n\n\n\n.. _dropwhile:\n\n\n``dropwhile(pred, iterable)``\n*****************************\nReplacement for the itertools ``dropwhile`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> dropwhile(lambda x: x < 4, range(6)).collect()\n    [4, 5]\n\n\n\n.. _filterfalse:\n\n\n``filterfalse(pred, iterable)``\n*******************************\nReplacement for the itertools ``filterfalse`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> filterfalse(None, [2, 0, 3, None, 4, 0]).collect()\n    [0, None, 0]\n\n\n\n.. _groupby:\n\n\n``groupby(iterable, key=None)``\n*******************************\nReplacement for the itertools ``groupby`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\ngroupby_ returns an iterator of a key and \"grouper\" iterable. In the\nexample below, we use Iter.starmap_ to collect each grouper iterable\ninto a list, as this makes it neater for display here in the docstring.\n\n.. code-block:: python\n\n    >>> (\n    ...     groupby(['john', 'jill', 'anne', 'jack'], key=lambda x: x[0])\n    ...         .starmap(lambda k, g: (k, list(g)))\n    ...         .collect()\n    ... )\n    [('j', ['john', 'jill']), ('a', ['anne']), ('j', ['jack'])]\n\n\n\n\n.. _islice:\n\n\n``islice(iterable, *args) -> \"Iter\"``\n*************************************\nReplacement for the itertools ``islice`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> islice('ABCDEFG', 2).collect()\n    ['A', 'B']\n    >>> islice('ABCDEFG', 2, 4).collect()\n    ['C', 'D']\n    >>> islice('ABCDEFG', 2, None).collect()\n    ['C', 'D', 'E', 'F', 'G']\n    >>> islice('ABCDEFG', 0, None, 2).collect()\n    ['A', 'C', 'E', 'G']\n\n\n\n.. _starmap:\n\n\n``starmap(func, iterable)``\n***************************\nReplacement for the itertools ``starmap`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> starmap(pow, [(2, 5), (3, 2), (10, 3)]).collect()\n    [32, 9, 1000]\n\n\n\n.. _takewhile:\n\n\n``takewhile(pred, iterable)``\n*****************************\nReplacement for the itertools ``takewhile`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> takewhile(lambda x: x < 5, [1, 4, 6, 4, 1]).collect()\n    [1, 4]\n\n\n\n.. _tee:\n\n\n``tee(iterable, n=2)``\n**********************\nReplacement for the itertools ``tee`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> a, b = tee(range(5))\n    >>> a.collect()\n    [0, 1, 2, 3, 4]\n    >>> b.sum()\n    10\n\nIt is also possible to operate on the returned iterators in the chain\nbut it gets quite difficult to understand:\n\n.. code-block:: python\n\n    >>> tee(range(5)).map(lambda it: it.sum()).collect()\n    [10, 10]\n\nIn the example above we passed in range_, but with excitertools_\nit's usually more natural to push data sources further left:\n\n.. code-block:: python\n\n    >>> range(5).tee().map(lambda it: it.sum()).collect()\n    [10, 10]\n\nPay close attention to the above. The map_ is acting on each of the\ncopied iterators.\n\n\n\n.. _zip_longest:\n\n\n``zip_longest(*iterables, fillvalue=None)``\n*******************************************\nReplacement for the itertools ``zip_longest`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> zip_longest('ABCD', 'xy', fillvalue='-').collect()\n    [('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')]\n    >>> (\n    ...     zip_longest('ABCD', 'xy', fillvalue='-')\n    ...         .map(lambda tup: concat(tup, ''))\n    ...         .collect()\n    ... )\n    ['Ax', 'By', 'C-', 'D-']\n    >>> (\n    ...     zip_longest('ABCD', 'xy', fillvalue='-')\n    ...         .starmap(operator.add)\n    ...         .collect()\n    ... )\n    ['Ax', 'By', 'C-', 'D-']\n\n\n\n.. _finditer_regex:\n\n\n``finditer_regex(pat: \"re.Pattern[AnyStr]\", s: AnyStr, flags: Union[int, re.RegexFlag] = 0) -> \"Iter[AnyStr]\"``\n***************************************************************************************************************\n\nWrapper for ``re.finditer``. Returns an instance of Iter_ to allow\nchaining.\n\n.. code-block:: python\n\n    >>> pat = r\"\\w+\"\n    >>> text = \"Well hello there! How ya doin!\"\n    >>> finditer_regex(pat, text).map(str.lower).filter(lambda w: 'o' in w).collect()\n    ['hello', 'how', 'doin']\n    >>> finditer_regex(r\"[A-Za-z']+\", \"A programmer's RegEx test.\").collect()\n    ['A', \"programmer's\", 'RegEx', 'test']\n    >>> finditer_regex(r\"[A-Za-z']+\", \"\").collect()\n    []\n    >>> finditer_regex(\"\", \"\").collect()\n    ['']\n    >>> finditer_regex(\"\", \"\").filter(None).collect()\n    []\n\n\n\n.. _splititer_regex:\n\n\n``splititer_regex(pat: \"re.Pattern[AnyStr]\", s: AnyStr, flags: Union[int, re.RegexFlag] = 0) -> \"Iter[AnyStr]\"``\n****************************************************************************************************************\n\nLazy string splitting using regular expressions.\n\nMost of the time you want ``str.split``. Really! That will almost\nalways be fastest. You might think that ``str.split`` is inefficient\nbecause it always has to build a list, but it can do this very, very\nquickly.\n\nThe lazy splitting shown here is more about supporting a particular\nkind of programming model, rather than performance.\n\nSee more discussion `here <https://stackoverflow.com/questions/3862010/is-there-a-generator-version-of-string-split-in-python>`_.\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\\s\", \"A programmer's RegEx test.\").collect()\n    ['A', \"programmer's\", 'RegEx', 'test.']\n\nNote that splitting at a single whitespace character will return blanks\nfor each found. This is different to how ``str.split()`` works.\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\\s\", \"aaa     bbb  \\n  ccc\\nddd\\teee\").collect()\n    ['aaa', '', '', '', '', 'bbb', '', '', '', '', 'ccc', 'ddd', 'eee']\n\nTo match ``str.split()``, specify a sequence of whitespace as the\nregex pattern.\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\\s+\", \"aaa     bbb  \\n  ccc\\nddd\\teee\").collect()\n    ['aaa', 'bbb', 'ccc', 'ddd', 'eee']\n\nCounting the whitespace\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\\s\", \"aaa     bbb  \\n  ccc\\nddd\\teee\").collect(Counter)\n    Counter({'': 8, 'aaa': 1, 'bbb': 1, 'ccc': 1, 'ddd': 1, 'eee': 1})\n\nLazy splitting at newlines\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\\n\", \"aaa     bbb  \\n  ccc\\nddd\\teee\").collect()\n    ['aaa     bbb  ', '  ccc', 'ddd\\teee']\n\nA few more examples:\n\n.. code-block:: python\n\n    >>> splititer_regex(r\"\", \"aaa\").collect()\n    ['', 'a', 'a', 'a', '']\n    >>> splititer_regex(r\"\", \"\").collect()\n    ['', '']\n    >>> splititer_regex(r\"\\s\", \"\").collect()\n    ['']\n    >>> splititer_regex(r\"a\", \"\").collect()\n    ['']\n    >>> splititer_regex(r\"\\s\", \"aaa\").collect()\n    ['aaa']\n\n\n\n.. _concat:\n\n\n``concat(iterable: Iterable[AnyStr], glue: AnyStr) -> \"AnyStr\"``\n****************************************************************\nConcatenate strings, bytes and bytearrays. It is careful to avoid the\nproblem with single bytes becoming integers, and it looks at the value\nof `glue` to know whether to handle bytes or strings.\n\nThis function can raise ``ValueError`` if called with something\nother than ``bytes``, ``bytearray`` or ``str``.\n\n.. _from_queue:\n\n\n|cool| |source| ``from_queue(q: queue.Queue, timeout=None, sentinel=None) -> \"Iter\"``\n*************************************************************************************\n\n\n\n\nWrap a queue with an iterator interface. This allows it to participate\nin chaining operations. The iterator will block while waiting for\nnew values to appear on the queue. This is useful: it allows you\nto easily and safely pass data between threads or processes, and\nfeed the incoming data into a pipeline.\n\nThe sentinel value, default ``None``, will terminate the iterator.\n\n.. code-block:: python\n\n    >>> q = queue.Queue()\n    >>> # This line puts stuff onto a queue\n    >>> range(10).chain([None]).map(q.put).consume()\n    >>> from_queue(q).filter(lambda x: 2 < x < 9).collect()\n    [3, 4, 5, 6, 7, 8]\n\nThis can be used in the same way you would normally use a queue, in\nthat it will block while waiting for future input. This makes it\nconvenient to run in a thread and wait for work. Below is a rough\nsketch of how one might cobble together a thread pool using this\nfeature. Note the use of Iter.side_effect_ to call ``task_done()``\non the queue.\n\n.. code-block:: python\n\n    import queue\n    from threading import Thread\n    import logging\n    from excitertools import from_queue\n\n    logger = logging.getLogger(__name__)\n\n    def process_job(job):\n        result = ...\n        return result\n\n    def worker(inputs: Queue, results: Queue):\n        (\n            from_queue(inputs)\n            .side_effect(lambda job: logger.info(f\"Received job {job}\")\n            .map(process_job)\n            .side_effect(lambda result: logger.info(f\"Got result {job}\")\n            .into_queue(results)\n            # Note that we only mark the task as done after the result\n            # is added to the results queue.\n            .side_effect(lambda _: inputs.task_done()\n        )\n\n    def create_job_pool(n: int) -> Tuple[Queue, Queue, Callable]:\n        \"\"\"Returns two queues, and a pool shutdown method. The\n        shutdown function can be called to shut down the pool and\n        the ``inputs`` queue. Caller is responsible for draining\n        the ``results`` queue.\"\"\"\n\n        # Independent control of the sizes of the input and output\n        # queues is interesting: it lets you decide how to bias\n        # backpressure depending on the details of your workload.\n        inputs, results = Queue(maxsize=100), Queue(maxsize=3)\n\n        kwargs = dict(target=worker, args=(inputs, results), daemon=True)\n        threads = repeat(Thread).map(lambda T: T(**kwargs)).take(n).collect()\n\n        def shutdown():\n            # Shut down each thread\n            repeat(None).map(inputs.put).take(n).consume()\n            inputs.join()\n            Iter(threads).map(lambda t: t.join()).consume()\n\n        return inputs, results, shutdown\n\nNow the two queues ``inputs`` and ``results`` can be used in various\nother threads to supply and consume data.\n\n\n\n\nThe ``Iter`` Class\n##################\n\n.. contents::\n    :backlinks: entry\n    :local:\n\n\n\n.. _Iter:\n\n\n|cool| ``class Iter(Generic[T])``\n*********************************\n\n\nThis class is what allows chaining. Many of the methods in this class\nreturn an instance of Iter_, which allows further chaining. There\nare two exceptions to this: *sources* and *sinks*.\n\nA \"source\" is usually a ``classmethod`` which can be used as an\ninitializer to produce data via an iterable. For example, the Iter.range_\nclassmethod can be used to get a sequence of numbers:\n\n.. code-block:: python\n\n    >>> Iter.range(1_000_000).take(3).collect()\n    [0, 1, 2]\n\nEven though our range was a million elements, the iterator chaining\ntook only 3 of those elements before collecting.\n\nA \"sink\" is a method that is usually the last component of a processing\nchain and often (but not always!) consumes the entire iterator. In the\nexample above, the call to Iter.collect_ was a sink. Note that we still\ncall it a sink even though it did not consume the entire iterator.\n\nWe're using the term \"source\" to refer to a classmethod of Iter_ that\nproduces data; but, the most typical source is going to be data that\nyou provide. Iter_ can be called with anything that is iterable, including\nsequences, iterators, mappings, sets, generators and so on.\n\nExamples:\n\n.. code-block:: python\n\n    List\n    >>> Iter([1, 2, 3]).map(lambda x: x * 2).sum()\n    12\n\n    Generator\n    >>> Iter((1, 2, 3)).map(lambda x: x * 2).sum()\n    12\n    >>> def g():\n    ...     for i in [1, 2, 3]:\n    ...         yield i\n    >>> Iter(g()).map(lambda x: x * 2).sum()\n    12\n\n    Iterator\n    >>> Iter(iter([1, 2, 3])).map(lambda x: x * 2).sum()\n    12\n\n    Dict\n    >>> Iter(dict(a=1, b=2)).map(lambda x: x.upper()).collect()\n    ['A', 'B']\n    >>> d = dict(a=1, b=2, c=3)\n    >>> Iter(d.items()).starmap(lambda k, v: v).map(lambda x: x * 2).sum()\n    12\n\nA common error with generators is forgetting to actually evaluate, i.e.,\ncall a generator function. If you do this there's a friendly error\npointing out the mistake:\n\n.. code-block:: python\n\n    >>> def mygen(): yield 123\n    >>> Iter(mygen).collect()\n    Traceback (most recent call last):\n        ...\n    TypeError: It seems you passed a generator function, but you\n    probably intended to pass a generator. Remember to evaluate the\n    function to obtain a generator instance:\n\n    def mygen():\n        yield 123\n\n    Iter(mygen)    # ERROR - a generator function object is not iterable\n    Iter(mygen())  # CORRECT - a generator instance is iterable.\n    >>> Iter(mygen()).collect()\n    [123]\n\nInstance of Iter_ are resumable. Once an instance it created, it can\nbe partially iterated in successive calls, like the following example\nshows:\n\n.. code-block:: python\n\n    >>> it = Iter.range(1_000_000)\n    >>> it.take(3).collect()\n    [0, 1, 2]\n    >>> it.take(4).collect()\n    [3, 4, 5, 6]\n    >>> # Consume most of the stream, collect the last few\n    >>> it.consume(999_990).collect()\n    [999997, 999998, 999999]\n\nThis class implements the chaining. However, the module-level functions\nin excitertools_, such as range_, zip_ and so on, also return\ninstances of Iter_, so they allow the chaining to continue. These are\nequivalent:\n\n.. code-block:: python\n\n    >>> Iter.range(10).filter(lambda x: x > 7).collect()\n    [8, 9]\n    >>> range(10).filter(lambda x: x > 7).collect()\n    [8, 9]\n\nIt is intended that the module-level functions can act as drop-in\nreplacements for the builtins they wrap:\n\n>>> import builtins\n>>> list(builtins.range(3))\n[0, 1, 2]\n>>> list(range(3))  # This is excitertools.range!\n[0, 1, 2]\n>>> list(Iter.range(3))\n[0, 1, 2]\n\nIn your own code where you might like to use the excitertools_ version of\nrange_ and the other functions, you can just import it and use it to access all the other\ncool stuff:\n\n.. code-block:: python\n\n    # mymodule.py\n    from excitertools import (\n        range,\n        map,\n        filter,\n        reduce,\n        repeat,\n        count,\n        enumerate,\n        zip,\n        ...\n    )\n\n    def func(inputs):\n        data = (\n            map(lambda x: x + 2, inputs)\n                .enumerate()\n                .filter(lambda x: x[1] > 10)\n                ...\n                .collect()\n\n        )\n\nAlternatively, if you don't want to hide the builtins you can do just\nfine with importing this class only, or even importing the module only:\n\n.. code-block:: python\n\n    # mymodule.py - same example as before\n    import excitertools\n\n    def func(inputs):\n        data = (\n            excitertools.Iter(inputs)\n                .map(lambda x: x + 2, inputs)\n                .enumerate()\n                .filter(lambda x: x[1] > 10)\n                ...\n                .collect()\n        )\n\n        # Do something with data\n\nThere are several valuable additions to the standard *itertools* and\nmore-itertools_ functions. These usually involve sources and sinks,\nwhich are ways of getting data into an iterator pipeline, and then\ngetting results out again. In the majority of documentation examples\nshown here, the Iter.collect_ method is used to collect all the\nremaining data on a stream into a list; but in practice this is not\nuseful because large lists consume memory.\n\nIn practice it is more useful to send iterator data to one of these\ncommon sinks:\n\n- files\n- sockets\n- queues\n- HTTP APIs\n- Cloud storage buckets\n- (Ideas for more to add here?)\n\nIter_ has support for these use-cases, both for reading and for writing.\n\n\n\n.. _Iter.register:\n\n\n``@classmethod Iter.register(cls, *func)``\n==========================================\n\nAdd a new method to Iter_. Sure, you could subclass Iter_ to get\nnew chaining features, but it would be neat to let all existing\nIter_ instance just immediately have the new registered function\navailable.\n\nThe new function must take ``iterable`` as the first parameter.\n\n.. code-block:: python\n\n    >>> def up(iterable):\n    ...     for v in iterable:\n    ...         yield v.upper()\n    >>> Iter.register(up)\n    >>> Iter('abc').up().collect()\n    ['A', 'B', 'C']\n    >>> def poly(iterable, a, b, c):\n    ...     # Polynomials a.x^2 + b.x + c\n    ...     for x in iterable:\n    ...         yield a*x**2 + b*x + c\n    >>> Iter.register(poly)\n    >>> Iter(range(-5, 5, 1)).poly(1, -5, 6).collect()\n    [56, 42, 30, 20, 12, 6, 2, 0, 0, 2]\n\nHere's a math round-trip rollercoaster.\n\n.. code-block:: python\n\n    >>> import math\n    >>> def log(iterable):\n    ...     for x in iterable:\n    ...         yield math.log(x)\n    >>> def exp(iterable):\n    ...     for x in iterable:\n    ...         yield math.exp(x)\n    >>> def rnd(iterable):\n    ...     for x in iterable:\n    ...         yield round(x)\n    >>> Iter.register(log, exp, rnd)\n    >>> Iter(range(5)).exp().log().rnd().collect()\n    [0, 1, 2, 3, 4]\n\nThese are silly examples, but hopefully you get the idea.\n\n\n\n.. _Iter.collect:\n\n\n|sink| ``Iter.collect(self, container=list) -> \"List[T]\"``\n==========================================================\n\n\n\nThis is the most common way of \"realizing\" an interable chain\ninto a concrete data structure. It should be the case that this\nis where most of the memory allocation occurs.\n\nThe default container is a list and you'll see throughout this\ndocumentation that most examples produce lists. However,\nany container, and indeed any function, can be used as the sink.\n\nThe basic example:\n\n.. code-block:: python\n\n    >>> Iter(range(3)).collect()\n    [0, 1, 2]\n    >>> Iter(range(3)).collect(tuple)\n    (0, 1, 2)\n\nYou must pay attention to some things. For example, if your\niterable is a string, the characters of the string are what\nget iterated over, and when you collect you'll get a collection\nof those atoms. You can however use ``str`` as your \"container\nfunction\" and that will give you back a string. It's like a join\nwith blank joiner.\n\n.. code-block:: python\n\n    >>> Iter('abc').collect()\n    ['a', 'b', 'c']\n    >>> Iter('abc').collect(str)\n    'abc'\n\nWith some types, things get a little more tricky. Take ``bytes``\nfor example:\n\n.. code-block:: python\n\n    >>> Iter(b'abc').collect()\n    [97, 98, 99]\n\nYou probably didn't expect to get the integers back right? Anyhow,\nyou can use ``bytes`` as the \"collection container\", just like\nwe did with strings and that will work:\n\n.. code-block:: python\n\n    >>> Iter(b'abc').collect(bytes)\n    b'abc'\n    >>> Iter(b'abc').collect(bytearray)\n    bytearray(b'abc')\n\nThe other standard collections also work, here's a set for\ncompleteness.\n\n.. code-block:: python\n\n    >>> Iter('abcaaaabbbbccc').collect(set) == {'a', 'b', 'c'}\n    True\n\n\n\n.. _Iter.open:\n\n\n|cool| |source| ``@classmethod Iter.open(cls, file, mode=\"r\", buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, ) -> \"Iter\"``\n==============================================================================================================================================================\n\n\n\n\nWrap the ``open()`` builtin precisely, but return an ``Iter``\ninstance to allow function chaining on the result.\n\nI know you're thinking that we should always use a context\nmanager for files. Don't worry, there is one being used\ninternally. When the iterator chain is terminated the underlying\nfile will be closed.\n\n>>> import tempfile\n>>> with tempfile.TemporaryDirectory() as td:\n...     # Put some random text into a temporary file\n...     with open(td + 'text.txt', 'w') as f:\n...         f.writelines(['abc\\n', 'def\\n', 'ghi\\n'])\n...\n...     # Open the file, filter some lines, collect the result\n...     Iter.open(td + 'text.txt').filter(lambda line: 'def' in line).collect()\n['def\\n']\n\nNote that this is a convenience method for *reading* from a file,\nnot for writing. The function signature includes the ``mode``\nparameter for parity with the builtin ``open()`` function, but\nonly reading is supported.\n\n\n\n.. _Iter.read_lines:\n\n\n|source| ``@classmethod Iter.read_lines(cls, stream: IO[str], rewind=True)``\n============================================================================\n\n\n\nRead lines from a file-like object.\n\nFirst, let's put some data in a file. We'll be using that\nfile in the examples that follow.\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> td = tempfile.TemporaryDirectory()\n    ... # Put some random text into a temporary file\n    >>> with open(td.name + 'text.txt', 'w') as f:\n    ...     f.writelines(['abc\\n', 'def\\n', 'ghi\\n'])\n    ...\n\nUse read_lines to process the file data\n\n.. code-block:: python\n\n    >>> with open(td.name + 'text.txt') as f:\n    ...     Iter.read_lines(f).filter(lambda line: 'def' in line).collect()\n    ['def\\n']\n\nThe ``rewind`` parameter can be used to read sections of a file.\n\n.. code-block:: python\n\n    >>> with open(td.name + 'text.txt') as f:\n    ...     part1 = Iter.read_lines(f).take(1).collect()\n    ...     part2 = Iter.read_lines(f, rewind=False).collect()\n    >>> part1\n    ['abc\\n']\n    >>> part2\n    ['def\\n', 'ghi\\n']\n    >>> td.cleanup()\n\n\n\n.. _Iter.read_bytes:\n\n\n|source| ``@classmethod Iter.read_bytes(cls, stream: IO[bytes], size: Union[Callable[[], int], int] = -1, rewind=True)``\n========================================================================================================================\n\n\n\nThe ``size`` parameter can be used to control how many bytes are\nread for each advancement of the iterator chain. Here we set ``size=1``\nwhich means we'll get back one byte at a time.\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> td = tempfile.TemporaryDirectory()\n    >>> filename = td.name + 'bytes.bin'\n\nPut some random text into a temporary file:\n\n.. code-block:: python\n\n    >>> with open(filename, 'wb') as f:\n    ...     x = f.write(b'\\x00' * 100)\n    ...\n    >>> with open(filename, 'rb') as f:\n    ...     data = Iter.read_bytes(f, size=1).collect()\n    ...     len(data)\n    100\n    >>> with open(filename, 'rb') as f:\n    ...     data = Iter.read_bytes(f).collect()\n    ...     len(data)\n    1\n\nA little more ambitious. Because ``size`` is a callable, we can use\na ``deque`` and a ``side_effect`` to pass information back into\nthe reader to control how many bytes are read in each chunk.\n\nIn this example we're reading 1 byte at a time. In a real example\nyou might have a sequence of headers and bodies, where headers\ngive size information about how many bytes are in the body\ncorresponding to that header. Then you can precisely read \neach body in sequence.\n\n.. code-block:: python\n\n    >>> read_sizes = deque([1])\n    >>> with open(filename, 'rb') as f:\n    ...     data = (\n    ...         Iter\n    ...             .read_bytes(f, size=lambda: read_sizes.popleft())\n    ...             .side_effect(lambda bytes: read_sizes.append(1))\n    ...             .collect()\n    ...     )\n    ...     len(data)\n    100\n\nThe ``rewind`` parameter can be used to read sections of a file.\n\n.. code-block:: python\n\n    >>> with open(filename, 'rb') as f:\n    ...     part1 = Iter.read_bytes(f, size=10).take(1).collect()\n    ...     part2 = Iter.read_bytes(f, rewind=False).collect()\n    >>> part1\n    [b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00']\n    >>> len(part2[0])\n    90\n    >>> td.cleanup()\n\n\n\n.. _Iter.write_text_to_stream:\n\n\n|sink| ``Iter.write_text_to_stream(self, stream: IO[str], insert_newlines=True, flush=True)``\n=============================================================================================\n\n\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> td = tempfile.TemporaryDirectory()\n    >>> filename = td.name + 'text.txt'\n\n    >>> data = ['a', 'b', 'c']\n    >>> with open(filename, 'w') as f:\n    ...     Iter(data).map(str.upper).write_text_to_stream(f)\n    ...     with open(filename) as f2:\n    ...         Iter.read_lines(f2).concat()\n    'A\\nB\\nC'\n\nIf some prior step adds newlines, or more commonly, newlines\noriginate with a data source and are simply carried through the\nprocessing chain unaltered, disable the insertion of newlines:\n\n.. code-block:: python\n\n    >>> with open(filename, 'w') as f:\n    ...     Iter(data).map(str.upper).write_text_to_stream(f, insert_newlines=False)\n    ...     with open(filename) as f2:\n    ...         Iter.read_lines(f2).concat()\n    'ABC'\n\nMultiple successive writes may be slowed down by the default\n``flush=True`` parameter. In this case you can delay flushing until\neverything has been written.\n\n.. code-block:: python\n\n    >>> with open(filename, 'w') as f:\n    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=False)\n    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=False)\n    ...     Iter(data).map(str.upper).write_text_to_stream(f, flush=True)\n    ...     with open(filename) as f2:\n    ...         Iter.read_lines(f2).concat()\n    'A\\nB\\nCA\\nB\\nCA\\nB\\nC'\n    >>> td.cleanup()\n\n\n\n.. _Iter.write_bytes_to_stream:\n\n\n|sink| ``Iter.write_bytes_to_stream(self, stream: IO[bytes], flush=True)``\n==========================================================================\n\n\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> td = tempfile.TemporaryDirectory()\n    >>> filename = td.name + 'bytes.bin'\n    >>> data = [b'a', b'b', b'c']\n    >>> with open(filename, 'wb') as f:\n    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)\n    ...     with open(filename, 'rb') as f2:\n    ...         Iter.read_bytes(f2).collect()\n    [b'aabbcc']\n    >>> with open(filename, 'wb') as f:\n    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)\n    ...     with open(filename, 'rb') as f2:\n    ...         Iter.read_bytes(f2).concat(b'')\n    b'aabbcc'\n    >>> with open(filename, 'wb') as f:\n    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)\n    ...     with open(filename, 'rb') as f2:\n    ...         Iter.read_bytes(f2, size=1).collect()\n    [b'a', b'a', b'b', b'b', b'c', b'c']\n    >>> with open(filename, 'wb') as f:\n    ...     Iter(data).map(lambda x: x * 2 ).write_bytes_to_stream(f)\n    ...     with open(filename, 'rb') as f2:\n    ...         Iter.read_bytes(f2, size=2).map(bytes.decode).collect()\n    ['aa', 'bb', 'cc']\n\nFlushing can be delayed if multiple parts are to be written.\n\n.. code-block:: python\n\n    >>> with open(filename, 'wb') as f:\n    ...     it = Iter(data)\n    ...     it.map(lambda x: x * 2 ).take(2).write_bytes_to_stream(f, flush=False)\n    ...     it.map(lambda x: x * 2 ).write_bytes_to_stream(f, flush=True)\n    ...     with open(filename, 'rb') as f2:\n    ...         Iter.read_bytes(f2, size=2).map(bytes.decode).collect()\n    ['aa', 'bb', 'cc']\n    >>> td.cleanup()\n\n\n\n.. _Iter.write_to_file:\n\n\n|cool| |sink| ``Iter.write_to_file(self, file, mode=\"w\", buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, )``\n===============================================================================================================================================\n\n\n\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> with tempfile.TemporaryDirectory() as td:\n    ...     # Put some random text into a temporary file\n    ...     with open(td + 'text.txt', 'w') as f:\n    ...         f.writelines(['abc\\n', 'def\\n', 'ghi\\n'])\n    ...\n    ...     # Open the file, transform, write out to new file.\n    ...     Iter.open(td + 'text.txt').map(str.upper).write_to_file(td + 'test2.txt')\n    ...     # Read the new file, for the test\n    ...     Iter.open(td + 'test2.txt').collect()\n    ['ABC\\n', 'DEF\\n', 'GHI\\n']\n\n\n\n.. _Iter.range:\n\n\n|source| ``@classmethod Iter.range(cls, *args) -> \"Iter[int]\"``\n===============================================================\n\n\n\nThe ``range`` function you all know and love.\n\n.. code-block:: python\n\n    >>> Iter.range(3).collect()\n    [0, 1, 2]\n    >>> Iter.range(0).collect()\n    []\n\n\n\n.. _Iter.zip:\n\n\n``Iter.zip(self, *iterables: Any) -> \"Iter[Tuple[T, ...]]\"``\n============================================================\n\n\nThe ``zip`` function you all know and love. The only thing to\nnote here is that the first iterable is really what the Iter_\ninstance is wrapping. The Iter.zip_ invocation brings in the\nother iterables.\n\nMake an Iter_ instance, then call ``zip`` on that.\n\n.. code-block:: python\n\n    >>> Iter('caleb').zip(range(10)).collect()\n    [('c', 0), ('a', 1), ('l', 2), ('e', 3), ('b', 4)]\n\nUse a classmethod to get an infinite stream using Iter.count_\nand zip against that with more finite iterators.\n\n.. code-block:: python\n\n    >>> Iter.count().zip(range(5), range(3, 100, 2)).collect()\n    [(0, 0, 3), (1, 1, 5), (2, 2, 7), (3, 3, 9), (4, 4, 11)]\n\nIt takes a few minutes to get used to that but feels comfortable\npretty quickly.\n\nIter.take_ can be used to stop infinite zip sequences:\n\n.. code-block:: python\n\n    >>> Iter('caleb').cycle().enumerate().take(8).collect()\n    [(0, 'c'), (1, 'a'), (2, 'l'), (3, 'e'), (4, 'b'), (5, 'c'), (6, 'a'), (7, 'l')]\n\nWhile we're here (assuming you worked through the previous\nexample), note the difference if you switch the order of the\nIter.cycle_ and Iter.enumerate_ calls:\n\n.. code-block:: python\n\n    >>> Iter('caleb').enumerate().cycle().take(8).collect()\n    [(0, 'c'), (1, 'a'), (2, 'l'), (3, 'e'), (4, 'b'), (0, 'c'), (1, 'a'), (2, 'l')]\n\nIf you understand how this works, everything else in _excitertools_\nwill be intuitive to use.\n\n\n\n.. _Iter.any:\n\n\n|sink| ``Iter.any(self) -> \"bool\"``\n===================================\n\n\n\n.. code-block:: python\n\n    >>> Iter([0, 0, 0]).any()\n    False\n    >>> Iter([0, 0, 1]).any()\n    True\n    >>> Iter([]).any()\n    False\n\n\n\n.. _Iter.all:\n\n\n|sink| ``Iter.all(self) -> \"bool\"``\n===================================\n\n\n\n\n.. code-block:: python\n\n    >>> Iter([0, 0, 0]).all()\n    False\n    >>> Iter([0, 0, 1]).all()\n    False\n    >>> Iter([1, 1, 1]).all()\n    True\n\nNow pay attention:\n\n.. code-block:: python\n\n    >>> Iter([]).all()\n    True\n\nThis behaviour has some controversy around it, but that's how the\n``all()`` builtin works so that's what we do too. The way to\nthink about what ``all()`` does is this: it returns False if there\nis at least one element that is falsy.  Thus, if there are no elements\nit follows that there are no elements that are falsy and that's why\n``all([]) == True``.\n\n\n\n.. _Iter.enumerate:\n\n\n``Iter.enumerate(self) -> \"Iter[Tuple[int, T]]\"``\n=================================================\n\n\n.. code-block:: python\n\n    >>> Iter('abc').enumerate().collect()\n    [(0, 'a'), (1, 'b'), (2, 'c')]\n    >>> Iter([]).enumerate().collect()\n    []\n\n\n\n.. _Iter.dict:\n\n\n``Iter.dict(self) -> \"Dict\"``\n=============================\n\nIn regular Python a dict can be constructed through an iterable \nof tuples:\n\n.. code-block:: python\n\n    >>> dict([('a', 0), ('b', 1)])                  \n    {'a': 0, 'b': 1}\n\nIn *excitertools* we prefer chaining so this method is a shortcut\nfor that:\n\n.. code-block:: python\n\n    >>> d = Iter('abc').zip(count()).dict()\n    >>> assert d == {'a': 0, 'b': 1, 'c': 2}\n\n\n\n.. _Iter.map:\n\n\n``Iter.map(self, func: Union[Callable[..., C], str]) -> \"Iter[C]\"``\n===================================================================\n\nThe ``map`` function you all know and love.\n\n.. code-block:: python\n\n    >>> Iter('abc').map(str.upper).collect()\n    ['A', 'B', 'C']\n    >>> Iter(['abc', 'def']).map(str.upper).collect()\n    ['ABC', 'DEF']\n\nUsing lambdas might seem convenient but in practice it turns\nout that they make code difficult to read:\n\n.. code-block:: python\n\n    >>> result = Iter('caleb').map(lambda x: (x, ord(x))).dict()\n    >>> assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}\n\nIt's recommended that you make a separate function instead:\n\n.. code-block:: python\n\n    >>> def f(x):\n    ...     return x, ord(x)\n    >>> result = Iter('caleb').map(f).dict()\n    >>> assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}\n\nI know many people prefer anonymous functions (often on\nphilosphical grounds) but in practice it's just easier to make\na separate, named function.\n\nI've experimented with passing a string into the map, and using\n``eval()`` to make a lambda internally. This simplifies the code\nvery slightly, at the cost of using strings-as-code. I'm pretty\nsure this feature will be removed so don't use it.\n\n.. code-block:: python\n\n    >>> result = Iter('caleb').map('x, ord(x)').dict()\n    >>> assert result == {'a': 97, 'b': 98, 'c': 99, 'e': 101, 'l': 108}\n\n\n\n.. _Iter.filter:\n\n\n``Iter.filter(self, function: \"Optional[Callable[[T], bool]]\" = None) -> \"Iter[T]\"``\n====================================================================================\n\nThe ``map`` function you all know and love.\n\n.. code-block:: python\n\n    >>> Iter('caleb').filter(lambda x: x in 'aeiou').collect()\n    ['a', 'e']\n\nThere is a slight difference between this method signature and\nthe builtin ``filter``:  how the identity function is handled.\nThis is a consquence of chaining. In the function signature above\nit is possible for us to give the ``function`` parameter a\ndefault value of ``None`` because the parameter appears towards\nthe end of the parameter list. Last, in fact.  In the\n`builtin filter signature <https://docs.python.org/3/library/functions.html#filter>`_\nit doesn't allow for this because the predicate parameter appears\nfirst.\n\nThis is a long way of saying: if you just want to filter out\nfalsy values, no parameter is needed:\n\n.. code-block:: python\n\n    >>> Iter([0, 1, 0, 0, 0, 1, 1, 1, 0, 0]).filter().collect()\n    [1, 1, 1, 1]\n\nUsing the builtin, you'd have to do ``filter(None, iterable)``.\n\nYou'll find that Iter.map_ and Iter.filter_\n(and Iter.reduce_, up next) work together very nicely:\n\n.. code-block:: python\n\n    >>> def not_eve(x):\n    ...    return x != 'eve'\n    >>> Iter(['bob', 'eve', 'alice']).filter(not_eve).map(str.upper).collect()\n    ['BOB', 'ALICE']\n\nThe long chains get unwieldy so let's rewrite that:\n\n.. code-block:: python\n\n    >>> (\n    ...     Iter(['bob', 'eve', 'alice'])\n    ...         .filter(not_eve)\n    ...         .map(str.upper)\n    ...         .collect()\n    ... )\n    ['BOB', 'ALICE']\n\n\n\n.. _Iter.starfilter:\n\n\n|cool| ``Iter.starfilter(self, function: \"Optional[Callable[[T, ...], bool]]\" = None) -> \"Iter[T]\"``\n====================================================================================================\n\n\nLike Iter.filter_, but arg unpacking in lambdas will work.\n\nWith the normal ``filter``, this fails:\n\n.. code-block:: python\n\n    >>> Iter('caleb').enumerate().filter(lambda i, x: i > 2).collect()\n    Traceback (most recent call last):\n        ...\n    TypeError: <lambda>() missing 1 required positional argument: 'x'\n\nThis is a real buzzkill. ``starfilter`` is very similar to \n``starmap`` in that tuples are unpacked when calling the function:\n\n.. code-block:: python\n\n    >>> Iter('caleb').enumerate().starfilter(lambda i, x: i > 2).collect()\n    [(3, 'e'), (4, 'b')]\n\n\n\n.. _Iter.filter_gt:\n\n\n``Iter.filter_gt(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_gt(1).collect()\n    [2, 3]\n\n\n\n.. _Iter.filter_ge:\n\n\n``Iter.filter_ge(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_ge(2).collect()\n    [2, 3]\n\n\n\n.. _Iter.filter_lt:\n\n\n``Iter.filter_lt(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_lt(3).collect()\n    [1, 2]\n\n\n.. _Iter.filter_le:\n\n\n``Iter.filter_le(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_le(2).collect()\n    [1, 2]\n\n\n.. _Iter.filter_eq:\n\n\n``Iter.filter_eq(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_eq(2).collect()\n    [2]\n\n\n.. _Iter.filter_ne:\n\n\n``Iter.filter_ne(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_ne(2).collect()\n    [1, 3]\n\n\n.. _Iter.filter_in:\n\n\n``Iter.filter_in(self, value: Sized) -> \"Iter[T]\"``\n===================================================\n\nConvenience method for membership testing. Note that the value\nparameter must be at least ``Sized`` because it gets reused\nover and over for each pass of the iterator chain. For example,\npassing in things like ``range()`` will not work properly because\nit will become progressively exhausted.\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_in([2, 3, 4, 5]).collect()\n    [2, 3]\n    >>> Iter([1,2,3]).filter_in(range(2, 8).collect()).collect()\n    [2, 3]\n    >>> Iter([1,2,3]).filter_in({2, 3, 4, 5}).collect()\n    [2, 3]\n    >>> Iter([1,2,3]).filter_in(dict.fromkeys({2, 3, 4, 5})).collect()\n    [2, 3]\n\n\n.. _Iter.filter_ni:\n\n\n``Iter.filter_ni(self, value) -> \"Iter[T]\"``\n============================================\n\nConvenience method for membership testing. Note that the value\nparameter must be at least ``Sized`` because it gets reused\nover and over for each pass of the iterator chain. For example,\npassing in things like ``range()`` will not work properly because\nit will become progressively exhausted.\n\n.. code-block:: python\n\n    >>> Iter([1,2,3]).filter_ni([2, 3, 4, 5]).collect()\n    [1]\n    >>> Iter([1,2,3]).filter_ni(range(2, 8).collect()).collect()\n    [1]\n    >>> Iter([1,2,3]).filter_ni({2, 3, 4, 5}).collect()\n    [1]\n    >>> Iter([1,2,3]).filter_ni(dict.fromkeys({2, 3, 4, 5})).collect()\n    [1]\n\n\n.. _Iter.reduce:\n\n\n|sink| ``Iter.reduce(self, func: Callable[..., T], *args) -> \"T\"``\n==================================================================\n\n\nThe ``reduce`` function you all know and...hang on, actually\n``reduce`` is rather unloved. In the past I've found it very complex\nto reason about, when looking at a bunch of nested function calls\nin typical ``itertools`` code. Hopefully iterable chaining makes\nit easier to read code that uses ``reduce``?\n\nLet's check, does this make sense?\n\n.. code-block:: python\n\n    >>> payments = [\n    ...     ('bob', 100),\n    ...     ('alice', 50),\n    ...     ('eve', -100),\n    ...     ('bob', 19.95),\n    ...     ('bob', -5.50),\n    ...     ('eve', 11.95),\n    ...     ('eve', 200),\n    ...     ('alice', -45),\n    ...     ('alice', -67),\n    ...     ('bob', 1.99),\n    ...     ('alice', 89),\n    ... ]\n    >>> (\n    ...     Iter(payments)\n    ...         .filter(lambda entry: entry[0] == 'bob')\n    ...         .map(lambda entry: entry[1])\n    ...         .reduce(lambda total, value: total + value, 0)\n    ... )\n    116.44\n\nI intentionally omitted comments above so that you can try the\n\"readability experiment\", but in practice you would definitely\nwant to add some comments on these chains:\n\n.. code-block:: python\n\n    >>> (\n    ...     # Iterate over all payments\n    ...     Iter(payments)\n    ...         # Only look at bob's payments\n    ...         .filter(lambda entry: entry[0] == 'bob')\n    ...         # Extract the value of the payment\n    ...         .map(lambda entry: entry[1])\n    ...         # Add all those payments together\n    ...         .reduce(lambda total, value: total + value, 0)\n    ... )\n    116.44\n\n``reduce`` is a quite crude low-level tool. In many cases you'll\nfind that there are other functions and methods better suited\nto the situations you'll encounter most often. For example, \nthere is already Iter.sum_ if you just want to add up numbers,\nand it's much easier to use Iter.groupby_ for grouping than \nto try to make that work with Iter.reduce_. You *can* make it \nwork but it'll be easier to use Iter.groupby_.\n\n\n\n.. _Iter.starreduce:\n\n\n|sink| ``Iter.starreduce(self, function: Callable[..., T], initializer=0) -> \"T\"``\n==================================================================================\n\n\nIter.starreduce_ is the same as Iter.reduce_ except that args are\nstar-unpacked when passed into ``function``. This is frequently\nmore convenient than the default behaviour.\n\nWe can see this using the same example shown for Iter.reduce_.\nThe star unpacking makes it easier to just do the filtering\ndirectly inside the reducer function.\n\n.. code-block:: python\n\n    >>> payments = [\n    ...     ('bob', 100),\n    ...     ('alice', 50),\n    ...     ('eve', -100),\n    ...     ('bob', 19.95),\n    ...     ('bob', -5.50),\n    ...     ('eve', 11.95),\n    ...     ('eve', 200),\n    ...     ('alice', -45),\n    ...     ('alice', -67),\n    ...     ('bob', 1.99),\n    ...     ('alice', 89),\n    ... ]\n    >>> (\n    ...     Iter(payments)\n    ...         .starreduce(\n    ...             lambda tot, name, value: tot + value if name == 'bob' else tot,\n    ...             0\n    ...         )\n    ... )\n    116.44\n\nThis is how that looks if you avoid a lambda:\n\n.. code-block:: python\n\n    >>> def f(tot, name, value):\n    ...     if name == 'bob':\n    ...         return tot + value\n    ...     else:\n    ...         return tot\n    >>> Iter(payments).starreduce(f)\n    116.44\n\n\n\n.. _Iter.sum:\n\n\n|sink| ``Iter.sum(self)``\n=========================\n\n\nExactly what you expect:\n\n.. code-block:: python\n\n    >>> Iter(range(10)).sum()\n    45\n\n\n\n.. _Iter.concat:\n\n\n|sink| ``Iter.concat(self, glue: AnyStr = '') -> \"AnyStr\"``\n===========================================================\n\n\n\nJoining strings (and bytes).\n\n.. code-block:: python\n\n    >>> Iter(['hello', 'there']).concat()\n    'hellothere'\n    >>> Iter(['hello', 'there']).concat(' ')\n    'hello there'\n    >>> Iter(['hello', 'there']).concat(',')\n    'hello,there'\n    >>> Iter([b'hello', b'there']).concat(b',')\n    b'hello,there'\n\n\n\n.. _Iter.insert:\n\n\n``Iter.insert(self, glue: C) -> \"Iter[Union[C, T]]\"``\n=====================================================\nDocstring TBD\n\n\n.. _Iter.count:\n\n\n|source| ``@classmethod Iter.count(cls, *args) -> \"Iter[int]\"``\n===============================================================\n\n\n\n.. code-block:: python\n\n    >>> Iter.count().take(3).collect()\n    [0, 1, 2]\n    >>> Iter.count(100).take(3).collect()\n    [100, 101, 102]\n    >>> Iter.count(100, 2).take(3).collect()\n    [100, 102, 104]\n\n\n\n.. _Iter.cycle:\n\n\n|inf| ``Iter.cycle(self) -> \"Iter[T]\"``\n=======================================\n\n\n\n.. code-block:: python\n\n    >>> Iter('abc').cycle().take(8).collect()\n    ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b']\n    >>> Iter('abc').cycle().take(8).concat('')\n    'abcabcab'\n\n\n\n.. _Iter.repeat:\n\n\n|source| |inf| ``@classmethod Iter.repeat(cls, elem: C, times=None) -> \"Iter[C]\"``\n==================================================================================\n\n\n\n\n.. code-block:: python\n\n    >>> Iter.repeat('c', times=3).collect()\n    ['c', 'c', 'c']\n\n\n\n.. _Iter.accumulate:\n\n\n``Iter.accumulate(self, func=None, *, initial=None)``\n=====================================================\nDocstring TBD\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3, 4, 5]).accumulate().collect()\n    [1, 3, 6, 10, 15]\n    >>> if sys.version_info >= (3, 8):\n    ...     out = Iter([1, 2, 3, 4, 5]).accumulate(initial=100).collect()\n    ...     assert out == [100, 101, 103, 106, 110, 115]\n    >>> Iter([1, 2, 3, 4, 5]).accumulate(operator.mul).collect()\n    [1, 2, 6, 24, 120]\n\n\n\n.. _Iter.chain:\n\n\n``Iter.chain(self, *iterables: Iterable[T]) -> \"Iter[T]\"``\n==========================================================\nDocstring TBD\n\n.. code-block:: python\n\n    >>> Iter('ABC').chain('DEF').collect()\n    ['A', 'B', 'C', 'D', 'E', 'F']\n    >>> Iter('ABC').chain().collect()\n    ['A', 'B', 'C']\n\n\n\n.. _Iter.chain_from_iterable:\n\n\n``Iter.chain_from_iterable(self) -> \"Iter[T]\"``\n===============================================\nDocstring TBD\n\n.. code-block:: python\n\n    >>> Iter(['ABC', 'DEF']).chain_from_iterable().collect()\n    ['A', 'B', 'C', 'D', 'E', 'F']\n\n\n\n.. _Iter.compress:\n\n\n``Iter.compress(self, selectors)``\n==================================\nReplacement for the itertools ``compress`` function.  This version returns\nan instance of Iter_ to allow further iterable chaining.\n\n.. code-block:: python\n\n    >>> Iter('ABCDEF').compress([1, 0, 1, 0, 1, 1]).collect()\n    ['A', 'C', 'E', 'F']\n\n\n\n.. _Iter.dropwhile:\n\n\n``Iter.dropwhile(self, pred)``\n==============================\nDocstring TBD\n\n\n.. _Iter.filterfalse:\n\n\n``Iter.filterfalse(self, pred)``\n================================\nDocstring TBD\n\n\n.. _Iter.groupby:\n\n\n``Iter.groupby(self, key=None)``\n================================\nDocstring TBD\n\n\n.. _Iter.islice:\n\n\n``Iter.islice(self, *args) -> \"Iter\"``\n======================================\nDocstring TBD\n\n\n.. _Iter.starmap:\n\n\n``Iter.starmap(self, func)``\n============================\nDocstring TBD\n\n\n.. _Iter.takewhile:\n\n\n``Iter.takewhile(self, pred)``\n==============================\nDocstring TBD\n\n\n.. _Iter.tee:\n\n\n``Iter.tee(self, n=2)``\n=======================\nDocstring TBD\n\n\n.. _Iter.zip_longest:\n\n\n``Iter.zip_longest(self, *iterables, fillvalue=None)``\n======================================================\nDocstring TBD\n\n\n.. _Iter.chunked:\n\n\n``Iter.chunked(self, n: int) -> \"Iter\"``\n========================================\nDocstring TBD\n\n\n.. _Iter.ichunked:\n\n\n``Iter.ichunked(self, n: int) -> \"Iter\"``\n=========================================\nDocstring TBD\n\n\n.. _Iter.sliced:\n\n\n``@classmethod Iter.sliced(cls, seq: Sequence, n: int) -> \"Iter\"``\n==================================================================\nDocstring TBD\n\n\n.. _Iter.distribute:\n\n\n``Iter.distribute(self, n: int) -> \"Iter\"``\n===========================================\nDocstring TBD\n\n\n.. _Iter.divide:\n\n\n``Iter.divide(self, n: int) -> \"Iter\"``\n=======================================\nDocstring TBD\n\n\n.. _Iter.split_at:\n\n\n``Iter.split_at(self, pred)``\n=============================\nDocstring TBD\n\n\n.. _Iter.split_before:\n\n\n``Iter.split_before(self, pred)``\n=================================\nDocstring TBD\n\n\n.. _Iter.split_after:\n\n\n``Iter.split_after(self, pred)``\n================================\nDocstring TBD\n\n\n.. _Iter.split_into:\n\n\n``Iter.split_into(self, sizes)``\n================================\nDocstring TBD\n\n\n.. _Iter.split_when:\n\n\n``Iter.split_when(self, pred)``\n===============================\nDocstring TBD\n\n\n.. _Iter.bucket:\n\n\n``Iter.bucket(self, key, validator=None)``\n==========================================\n\nThis is the basic example, copied from the more-itertools\ndocs:\n\n.. code-block:: python\n\n    >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n    >>> b = Iter(iterable).bucket(key=lambda x: x[0])\n    >>> sorted(b)\n    ['a', 'b', 'c']\n    >>> list(b['a'])\n    ['a1', 'a2']\n\nNote that once consumed, you can't iterate over the contents\nof a group again.\n\n\n.. _Iter.unzip:\n\n\n``Iter.unzip(self)``\n====================\nDocstring TBD\n\n\n.. _Iter.grouper:\n\n\n``Iter.grouper(self, n: int, fillvalue=None) -> \"Iter\"``\n========================================================\nDocstring TBD\n\n\n.. _Iter.partition:\n\n\n``Iter.partition(self, pred) -> \"Iter\"``\n========================================\nDocstring TBD\n\n\n.. _Iter.spy:\n\n\n``Iter.spy(self, n=1) -> \"Tuple[Iter, Iter]\"``\n==============================================\nDocstring TBD\n\n\n.. _Iter.peekable:\n\n\n``Iter.peekable(self) -> \"more_itertools.peekable\"``\n====================================================\n\nDocstring TBD\n\n.. code-block:: python\n\n    >>> p = Iter(['a', 'b']).peekable()\n    >>> p.peek()\n    'a'\n    >>> next(p)\n    'a'\n\nThe peekable can be used to inspect what will be coming up.\nBut if you then want to resume iterator chaining, pass the\npeekable back into an Iter_ instance.\n\n.. code-block:: python\n\n    >>> p = Iter(range(10)).peekable()\n    >>> p.peek()\n    0\n    >>> Iter(p).take(3).collect()\n    [0, 1, 2]\n\nA peekable is not an Iter_ instance so it doesn't provide\nthe iterator chaining methods. But if you want to get into\nchaining, use the ``iter()`` method.\n\n.. code-block:: python\n\n    >>> p = Iter(range(5)).peekable()\n    >>> p.peek()\n    0\n    >>> p[1]\n    1\n    >>> p.iter().take(3).collect()\n    [0, 1, 2]\n\nPeekables can be prepended. But then you usually want to go\nright back to iterator chaining. Thus, the ``prepend`` method\n(on the returned ``peekable`` instance) returns an Iter_ instance.\n\n.. code-block:: python\n\n    >>> p = Iter(range(3)).peekable()\n    >>> p.peek()\n    0\n    >>> p.prepend('a', 'b').take(4).collect()\n    ['a', 'b', 0, 1]\n\n\n\n.. _Iter.seekable:\n\n\n``Iter.seekable(self) -> \"more_itertools.seekable\"``\n====================================================\nDocstring TBD\n\n\n.. _Iter.windowed:\n\n\n``Iter.windowed(self, n, fillvalue=None, step=1) -> \"Iter\"``\n============================================================\nDocstring TBD\n\n\n.. _Iter.substrings:\n\n\n``Iter.substrings(self)``\n=========================\nDocstring TBD\n\n\n.. _Iter.substrings_indexes:\n\n\n``Iter.substrings_indexes(self, reverse=False)``\n================================================\nDocstring TBD\n\n\n.. _Iter.stagger:\n\n\n``Iter.stagger(self, offsets=(-1, 0, 1), longest=False, fillvalue=None)``\n=========================================================================\n\n.. code-block:: python\n\n    >>> Iter([0, 1, 2, 3]).stagger().collect()\n    [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n    >>> Iter(range(8)).stagger(offsets=(0, 2, 4)).collect()\n    [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n    >>> Iter([0, 1, 2, 3]).stagger(longest=True).collect()\n    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n\n\n.. _Iter.pairwise:\n\n\n``Iter.pairwise(self)``\n=======================\n\nReference `more_itertools.pairwise <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.pairwise>`_\n\n.. code-block:: python\n\n    >>> Iter.count().pairwise().take(4).collect()\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n\n.. _Iter.count_cycle:\n\n\n``Iter.count_cycle(self, n=None) -> \"Iter\"``\n============================================\n\n\nReference: `more_itertools.count_cycle <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.count_cycle>`_\n\n.. code-block:: python\n\n    >>> Iter('AB').count_cycle(3).collect()\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n\n\n.. _Iter.intersperse:\n\n\n``Iter.intersperse(self, e, n=1) -> \"Iter\"``\n============================================\n\nReference: `more_itertools.intersperse <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.intersperse>`_\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3, 4, 5]).intersperse('!').collect()\n    [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n    >>> Iter([1, 2, 3, 4, 5]).intersperse(None, n=2).collect()\n    [1, 2, None, 3, 4, None, 5]\n\n\n\n.. _Iter.padded:\n\n\n``Iter.padded(self, fillvalue: Optional[C] = None, n: Optional[int] = None, next_multiple: bool = False, ) -> \"Iter[Union[T, C]]\"``\n===================================================================================================================================\n\nReference: `more_itertools.padded <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.padded>`_\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3]).padded('?', 5).collect()\n    [1, 2, 3, '?', '?']\n\n    >>> Iter([1, 2, 3, 4]).padded(n=3, next_multiple=True).collect()\n    [1, 2, 3, 4, None, None]\n\n\n\n.. _Iter.repeat_last:\n\n\n``Iter.repeat_last(self, default=None) -> \"Iter[T]\"``\n=====================================================\n\nReference: `more_itertools.repeat_last <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.repeat_last>`_\n\n.. code-block:: python\n\n    >>> Iter(range(3)).repeat_last().islice(5).collect()\n    [0, 1, 2, 2, 2]\n\n    >>> Iter(range(0)).repeat_last(42).islice(5).collect()\n    [42, 42, 42, 42, 42]\n\n\n\n.. _Iter.adjacent:\n\n\n``Iter.adjacent(self, pred, distance=1) -> \"Iter[Tuple[bool, T]]\"``\n===================================================================\n\nReference: `more_itertools.adjacent <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.adjacent>`_\n\n.. code-block:: python\n\n    >>> Iter(range(6)).adjacent(lambda x: x == 3).collect()\n    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    >>> Iter(range(6)).adjacent(lambda x: x == 3, distance=2).collect()\n    [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n\n\n\n.. _Iter.groupby_transform:\n\n\n``Iter.groupby_transform(self, keyfunc: Optional[Callable[..., K]] = None, valuefunc: Optional[Callable[..., V]] = None, ) -> \"Iter[Tuple[K, Iterable[V]]]\"``\n=============================================================================================================================================================\n\nReference: `more_itertools.groupby_transform <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.groupby_transform>`_\n\nThis example has been modified somewhat from the original. We're using\n``starmap`` here to \"unzip\" the tuples produced by the group\ntransform.\n\n.. code-block:: python\n\n    >>> iterable = 'AaaABbBCcA'\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: x.lower()\n    >>> (\n    ...    Iter(iterable)\n    ...        .groupby_transform(keyfunc, valuefunc)\n    ...        .starmap(lambda k, g: (k, ''.join(g)))\n    ...        .collect()\n    ... )\n    [('A', 'aaaa'), ('B', 'bbb'), ('C', 'cc'), ('A', 'a')]\n\n    >>> from operator import itemgetter\n    >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n    >>> values = 'abcdefghi'\n    >>> iterable = zip(keys, values)\n    >>> (\n    ...     Iter(iterable)\n    ...        .groupby_transform(itemgetter(0), itemgetter(1))\n    ...        .starmap(lambda k, g: (k, ''.join(g)))\n    ...        .collect()\n    ... )\n    [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n\n\n.. _Iter.padnone:\n\n\n``Iter.padnone(self) -> \"Iter[Union[T, None]]\"``\n================================================\n\nReference: `more_itertools.padnone <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.padnone>`_\n\n.. code-block:: python\n\n    >>> Iter(range(3)).padnone().take(5).collect()\n    [0, 1, 2, None, None]\n\n\n\n.. _Iter.ncycles:\n\n\n``Iter.ncycles(self, n) -> \"Iter[T]\"``\n======================================\n\nReference: `more_itertools.ncycles <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.ncycles>`_\n\n.. code-block:: python\n\n    >>> Iter(['a', 'b']).ncycles(3).collect()\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n\n\n.. _Iter.collapse:\n\n\n``Iter.collapse(self, base_type=None, levels=None) -> \"Iter\"``\n==============================================================\n\nReference: `more_itertools.collapse <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse>`_\n\n.. code-block:: python\n\n    >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n    >>> Iter(iterable).collapse().collect()\n    [1, 2, 3, 4, 5, 6]\n\n    >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n    >>> Iter(iterable).collapse(base_type=tuple).collect()\n    ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> Iter(iterable).collapse().collect() # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> Iter(iterable).collapse(levels=1).collect() # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n\n\n.. _Iter.sort_together:\n\n\n``@class_or_instancemethod Iter.sort_together(self_or_cls, iterables, key_list=(0,), reverse=False)``\n=====================================================================================================\n\nReference: `more_itertools.sort_together <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.sort_together>`_\n\nThis can be called either as an instance method or a class method.\nThe classmethod form is more convenient if all the iterables are\nalready available. The instancemethod form is more convenient if\none of the iterables already goes through some transformation.\n\nHere are examples from the classmethod form, which mirror the\nexamples in the more-itertools_ documentation:\n\n.. code-block:: python\n\n    >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n    >>> Iter.sort_together(iterables).collect()\n    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n    >>> Iter.sort_together(iterables, key_list=(1, 2)).collect()\n    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    >>> Iter.sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True).collect()\n    [(3, 2, 1), ('a', 'b', 'c')]\n\nHere is an examples using the instancemethod form:\n\n.. code-block:: python\n\n    >>> iterables = [('a', 'b', 'c', 'd')]\n    >>> Iter([4, 3, 2, 1]).sort_together(iterables).collect()\n    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n\n\n.. _Iter.interleave:\n\n\n``@class_or_instancemethod Iter.interleave(self_or_cls, *iterables) -> \"Iter\"``\n===============================================================================\n\nReference: `more_itertools.interleave <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.interleave>`_\n\nClassmethod form:\n\n.. code-block:: python\n\n    >>> Iter.interleave([1, 2, 3], [4, 5], [6, 7, 8]).collect()\n    [1, 4, 6, 2, 5, 7]\n\nInstancemethod form:\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3]).interleave([4, 5], [6, 7, 8]).collect()\n    [1, 4, 6, 2, 5, 7]\n\n\n\n.. _Iter.interleave_longest:\n\n\n``@class_or_instancemethod Iter.interleave_longest(self_or_cls, *iterables) -> \"Iter\"``\n=======================================================================================\n\nReference: `more_itertools.interleave_longest <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.interleave_longest>`_\n\nClassmethod form:\n\n.. code-block:: python\n\n    >>> Iter.interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]).collect()\n    [1, 4, 6, 2, 5, 7, 3, 8]\n\nInstancemethod form:\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3]).interleave_longest([4, 5], [6, 7, 8]).collect()\n    [1, 4, 6, 2, 5, 7, 3, 8]\n\n\n\n.. _Iter.zip_offset:\n\n\n``@classmethod Iter.zip_offset(cls, *iterables, offsets, longest=False, fillvalue=None) -> \"Iter\"``\n===================================================================================================\n\nReference: `more_itertools.zip_offset <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset>`_\n\n.. code-block:: python\n\n    >>> Iter.zip_offset('0123', 'abcdef', offsets=(0, 1)).collect()\n    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    >>> Iter.zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True).collect()\n    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n\n.. _Iter.dotproduct:\n\n\n``Iter.dotproduct(self, vec2: Iterable)``\n=========================================\n\nReference: `more_itertools.dotproduct <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.dotproduct>`_\n\n.. code-block:: python\n\n    >>> Iter([10, 10]).dotproduct([20, 20])\n    400\n\n\n.. _Iter.flatten:\n\n\n``Iter.flatten(self) -> \"Iter[T]\"``\n===================================\n\nReference: `more_itertools.flatten <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.flatten>`_\n\n.. code-block:: python\n\n    >>> Iter([[0, 1], [2, 3]]).flatten().collect()\n    [0, 1, 2, 3]\n\n\n\n.. _Iter.roundrobin:\n\n\n``@class_or_instancemethod Iter.roundrobin(self_or_cls: Union[Type[T], T], *iterables: C) -> \"Iter[Union[T, C]]\"``\n==================================================================================================================\n\nReference: `more_itertools.roundrobin <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.roundrobin>`_\n\nClassmethod form:\n\n.. code-block:: python\n\n    >>> Iter.roundrobin('ABC', 'D', 'EF').collect()\n    ['A', 'D', 'E', 'B', 'F', 'C']\n\nInstancemethod form:\n\n.. code-block:: python\n\n    >>> Iter('ABC').roundrobin('D', 'EF').collect()\n    ['A', 'D', 'E', 'B', 'F', 'C']\n\n\n\n.. _Iter.prepend:\n\n\n``Iter.prepend(self, value: C) -> \"Iter[Union[T, C]]\"``\n=======================================================\n\nReference: `more_itertools.prepend <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.prepend>`_\n\n.. code-block:: python\n\n    >>> value = '0'\n    >>> iterator = ['1', '2', '3']\n    >>> Iter(iterator).prepend(value).collect()\n    ['0', '1', '2', '3']\n\n\n\n.. _Iter.ilen:\n\n\n|sink| ``Iter.ilen(self) -> \"int\"``\n===================================\n\n\n\nReference: `more_itertools.ilen <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.ilen>`_\n\n.. code-block:: python\n\n    >>> Iter(x for x in range(1000000) if x % 3 == 0).ilen()\n    333334\n\n\n\n.. _Iter.unique_to_each:\n\n\n``Iter.unique_to_each(self) -> \"Iter[T]\"``\n==========================================\n\nReference: `more_itertools.unique_to_each <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_to_each>`_\n\n.. code-block:: python\n\n    >>> Iter([{'A', 'B'}, {'B', 'C'}, {'B', 'D'}]).unique_to_each().collect()\n    [['A'], ['C'], ['D']]\n\n    >>> Iter([\"mississippi\", \"missouri\"]).unique_to_each().collect()\n    [['p', 'p'], ['o', 'u', 'r']]\n\n\n.. _Iter.sample:\n\n\n``Iter.sample(self, k=1, weights=None) -> \"Iter\"``\n==================================================\n\nReference: `more_itertools.sample <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.sample>`_\n\n.. code-block:: python\n\n    >>> iterable = range(100)\n    >>> Iter(iterable).sample(5).collect()                  \n    [81, 60, 96, 16, 4]\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> Iter(iterable).sample(5, weights=weights)                  \n    [79, 67, 74, 66, 78]\n\n    >>> data = \"abcdefgh\"\n    >>> weights = range(1, len(data) + 1)\n    >>> Iter(data).sample(k=len(data), weights=weights)                  \n    ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']\n\n\n    >>> # This one just to let the doctest run\n    >>> iterable = range(100)\n    >>> Iter(iterable).sample(5).map(lambda x: 0 <= x < 100).all()\n    True\n\n\n\n.. _Iter.consecutive_groups:\n\n\n``Iter.consecutive_groups(self, ordering=lambda x: x)``\n=======================================================\n\nReference: `more_itertools.consecutive_groups <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.consecutive_groups>`_\n\n.. code-block:: python\n\n    >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n    >>> Iter(iterable).consecutive_groups().map(lambda g: list(g)).print('{v}').consume()\n    [1]\n    [10, 11, 12]\n    [20]\n    [30, 31, 32, 33]\n    [40]\n\n\n\n.. _Iter.run_length_encode:\n\n\n``Iter.run_length_encode(self) -> \"Iter[Tuple[T, int]]\"``\n=========================================================\n\nReference: `more_itertools.run_length <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.run_length>`_\n\n.. code-block:: python\n\n    >>> uncompressed = 'abbcccdddd'\n    >>> Iter(uncompressed).run_length_encode().collect()\n    [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n\n\n.. _Iter.run_length_decode:\n\n\n``Iter.run_length_decode(self) -> \"Iter\"``\n==========================================\n\nReference: `more_itertools.run_length <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.run_length>`_\n\n.. code-block:: python\n\n    >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n    >>> Iter(compressed).run_length_decode().collect()\n    ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n\n\n.. _Iter.map_reduce:\n\n\n``Iter.map_reduce(self, keyfunc, valuefunc=None, reducefunc=None) -> \"Dict\"``\n=============================================================================\n\nReference: `more_itertools.map_reduce <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_reduce>`_\n\nThis interface mirrors what more-itertools_ does in that it returns\na dict. See ``map_reduce_it()`` for a slightly-modified interface\nthat returns the dict items as another iterator.\n\n.. code-block:: python\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> d = Iter('abbccc').map_reduce(keyfunc)\n    >>> sorted(d.items())\n    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> d = Iter('abbccc').map_reduce(keyfunc, valuefunc)\n    >>> sorted(d.items())\n    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> reducefunc = sum\n    >>> d = Iter('abbccc').map_reduce(keyfunc, valuefunc, reducefunc)\n    >>> sorted(d.items())\n    [('A', 1), ('B', 2), ('C', 3)]\n\nNote the warning given in the more-itertools_ docs about how\nlists are created before the reduce step. This means you always want\nto filter *before* applying map_reduce, not after.\n\n.. code-block:: python\n\n    >>> all_items = _range(30)\n    >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n    >>> categories = Iter(all_items).filter(lambda x: 10<=x<=20).map_reduce(keyfunc=keyfunc)\n    >>> sorted(categories.items())\n    [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n    >>> summaries = Iter(all_items).filter(lambda x: 10<=x<=20).map_reduce(keyfunc=keyfunc, reducefunc=sum)\n    >>> sorted(summaries.items())\n    [(0, 90), (1, 75)]\n\n\n\n.. _Iter.map_reduce_it:\n\n\n``Iter.map_reduce_it(self, keyfunc: Callable[..., K], valuefunc: Optional[Callable[..., V]] = None, reducefunc: Optional[Callable[..., R]] = None, ) -> \"Iter[Tuple[K, R]]\"``\n=============================================================================================================================================================================\n\nReference: `more_itertools.map_reduce <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_reduce>`_\n\n.. code-block:: python\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> Iter('abbccc').map_reduce_it(keyfunc).collect()\n    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> Iter('abbccc').map_reduce_it(keyfunc, valuefunc).collect()\n    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> reducefunc = sum\n    >>> Iter('abbccc').map_reduce_it(keyfunc, valuefunc, reducefunc).collect()\n    [('A', 1), ('B', 2), ('C', 3)]\n\n\n\n.. _Iter.exactly_n:\n\n\n|sink| ``Iter.exactly_n(self, n, predicate=bool) -> \"bool\"``\n============================================================\n\n\n\nDocstring TBD\n\n.. code-block:: python\n\n    >>> Iter([True, True, False]).exactly_n(2)\n    True\n\n\n\n.. _Iter.all_equal:\n\n\n``Iter.all_equal(self)``\n========================\n\n.. _Iter.first_true:\n\n\n``Iter.first_true(self)``\n=========================\n\n.. _Iter.quantify:\n\n\n``Iter.quantify(self)``\n=======================\n\n.. _Iter.islice_extended:\n\n\n``Iter.islice_extended(self, *args)``\n=====================================\n\nReference: `more_itertools.islice_extended <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.islice_extended>`_\n\n.. code-block:: python\n\n    >>> Iter('abcdefgh').islice_extended(-4, -1).collect()\n    ['e', 'f', 'g']\n\n.. code-block:: python\n\n    >>> Iter.count().islice_extended( 110, 99, -2).collect()\n    [110, 108, 106, 104, 102, 100]\n\n\n\n.. _Iter.first:\n\n\n``Iter.first(self)``\n====================\n\nReference: `more_itertools.first <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.first>`_\n\n\n.. _Iter.last:\n\n\n``Iter.last(self)``\n===================\n\nReference: `more_itertools.last <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.last>`_\n\n\n.. _Iter.one:\n\n\n``Iter.one(self)``\n==================\n\nReference: `more_itertools.one <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.one>`_\n\n\n\n.. _Iter.only:\n\n\n``Iter.only(self, default=None, too_long=ValueError) -> \"T\"``\n=============================================================\n\nReference: `more_itertools.one <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.one>`_\n\n.. code-block:: python\n\n    >>> Iter([]).only(default='missing')\n    'missing'\n    >>> Iter([42]).only(default='missing')\n    42\n    >>> Iter([1, 2]).only()\n    Traceback (most recent call last):\n        ...\n    ValueError: ...\n\n\n\n.. _Iter.strip:\n\n\n``Iter.strip(self, pred) -> \"Iter[T]\"``\n=======================================\n\nReference: `more_itertools.strip <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.strip>`_\n\n.. code-block:: python\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> Iter(iterable).strip(pred).collect()\n    [1, 2, None, 3]\n\n\n\n.. _Iter.lstrip:\n\n\n``Iter.lstrip(self, pred) -> \"Iter[T]\"``\n========================================\n\nReference: `more_itertools.lstrip <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.lstrip>`_\n\n.. code-block:: python\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> Iter(iterable).lstrip(pred).collect()\n    [1, 2, None, 3, False, None]\n\n\n\n.. _Iter.rstrip:\n\n\n``Iter.rstrip(self, pred) -> \"Iter[T]\"``\n========================================\n\nReference: `more_itertools.rstrip <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.rstrip>`_\n\n.. code-block:: python\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> Iter(iterable).rstrip(pred).collect()\n    [None, False, None, 1, 2, None, 3]\n\n\n\n.. _Iter.filter_except:\n\n\n``Iter.filter_except(self, validator, *exceptions) -> \"Iter[T]\"``\n=================================================================\n\nReference: `more_itertools.filter_except <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.filter_except>`_\n\n.. code-block:: python\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> Iter(iterable).filter_except(int, ValueError, TypeError).collect()\n    ['1', '2', '4']\n\n\n\n.. _Iter.map_except:\n\n\n``Iter.map_except(self, function, *exceptions) -> \"Iter\"``\n==========================================================\n\nReference: `more_itertools.map_except <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_except>`_\n\n.. code-block:: python\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> Iter(iterable).map_except(int, ValueError, TypeError).collect()\n    [1, 2, 4]\n\n\n\n.. _Iter.nth_or_last:\n\n\n``Iter.nth_or_last(self, n, default=_marker) -> \"T\"``\n=====================================================\n\nReference: `more_itertools.nth_or_last <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth_or_last>`_\n\n.. code-block:: python\n\n    >>> Iter([0, 1, 2, 3]).nth_or_last(2)\n    2\n    >>> Iter([0, 1]).nth_or_last(2)\n    1\n    >>> Iter([]).nth_or_last(0, 'some default')\n    'some default'\n\n\n\n.. _Iter.nth:\n\n\n``Iter.nth(self, n, default=None)``\n===================================\n\nReference: `more_itertools.nth <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth>`_\n\n\n.. _Iter.take:\n\n\n``Iter.take(self, n: int) -> \"Iter\"``\n=====================================\n\nReference: `more_itertools.take <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.take>`_\n\n\n.. _Iter.tail:\n\n\n``Iter.tail(self, n) -> \"Iter[T]\"``\n===================================\n\nReference: `more_itertools.tail <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.tail>`_\n\n.. code-block:: python\n\n    >>> Iter('ABCDEFG').tail(3).collect()\n    ['E', 'F', 'G']\n\n\n\n.. _Iter.unique_everseen:\n\n\n``Iter.unique_everseen(self, key=None) -> \"Iter[T]\"``\n=====================================================\n\nReference: `more_itertools.unique_everseen <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen>`_\n\n.. code-block:: python\n\n    >>> Iter('AAAABBBCCDAABBB').unique_everseen().collect()\n    ['A', 'B', 'C', 'D']\n    >>> Iter('ABBCcAD').unique_everseen(key=str.lower).collect()\n    ['A', 'B', 'C', 'D']\n\nBe sure to read the *more-itertools* docs whne using unhashable\nitems.\n\n.. code-block:: python\n\n    >>> iterable = ([1, 2], [2, 3], [1, 2])\n    >>> Iter(iterable).unique_everseen().collect()  # Slow\n    [[1, 2], [2, 3]]\n    >>> Iter(iterable).unique_everseen(key=tuple).collect()  # Faster\n    [[1, 2], [2, 3]]\n\n\n\n.. _Iter.unique_justseen:\n\n\n``Iter.unique_justseen(self, key=None) -> \"Iter[T]\"``\n=====================================================\n\nReference: `more_itertools.unique_justseen <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_justseen>`_\n\n.. code-block:: python\n\n    >>> Iter('AAAABBBCCDAABBB').unique_justseen().collect()\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> Iter('ABBCcAD').unique_justseen(key=str.lower).collect()\n    ['A', 'B', 'C', 'A', 'D']\n\n\n\n.. _Iter.distinct_permutations:\n\n\n``Iter.distinct_permutations(self)``\n====================================\n\nReference: `more_itertools.distinct_permutations <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.distinct_permutations>`_\n\n.. code-block:: python\n\n    >>> Iter([1, 0, 1]).distinct_permutations().sorted().collect()\n    [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n\n\n.. _Iter.distinct_combinations:\n\n\n``Iter.distinct_combinations(self, r) -> \"Iter[T]\"``\n====================================================\n\nReference: `more_itertools.distinct_combinations <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.distinct_combinations>`_\n\n.. code-block:: python\n\n    >>> Iter([0, 0, 1]).distinct_combinations(2).collect()\n    [(0, 0), (0, 1)]\n\n\n\n.. _Iter.circular_shifts:\n\n\n``Iter.circular_shifts(self) -> \"Iter[T]\"``\n===========================================\n\nReference: `more_itertools.circular_shifts <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.circular_shifts>`_\n\n.. code-block:: python\n\n    >>> Iter(range(4)).circular_shifts().collect()\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\n\n\n.. _Iter.partitions:\n\n\n``Iter.partitions(self) -> \"Iter[T]\"``\n======================================\n\nReference: `more_itertools.partitions <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.partitions>`_\n\n.. code-block:: python\n\n    >>> Iter('abc').partitions().collect()\n    [[['a', 'b', 'c']], [['a'], ['b', 'c']], [['a', 'b'], ['c']], [['a'], ['b'], ['c']]]\n    >>> Iter('abc').partitions().print('{v}').consume()\n    [['a', 'b', 'c']]\n    [['a'], ['b', 'c']]\n    [['a', 'b'], ['c']]\n    [['a'], ['b'], ['c']]\n    >>> Iter('abc').partitions().map(lambda v: [''.join(p) for p in v]).print('{v}').consume()\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n\n\n.. _Iter.set_partitions:\n\n\n``Iter.set_partitions(self, k=None) -> \"Iter[T]\"``\n==================================================\n\nReference: `more_itertools.set_partitions <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.set_partitions>`_\n\n.. code-block:: python\n\n    >>> Iter('abc').set_partitions(2).collect()\n    [[['a'], ['b', 'c']], [['a', 'b'], ['c']], [['b'], ['a', 'c']]]\n\n\n\n.. _Iter.powerset:\n\n\n``Iter.powerset(self)``\n=======================\n\nReference: `more_itertools.powerset <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.powerset>`_\n\n.. code-block:: python\n\n    >>> Iter([1, 2, 3]).powerset().collect()\n    [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n\n\n.. _Iter.random_product:\n\n\n``@class_or_instancemethod Iter.random_product(self_or_cls, *args, repeat=1)``\n==============================================================================\n\nReference: `more_itertools.random_product <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_product>`_\n\n.. code-block:: python\n\n    >>> Iter('abc').random_product(range(4), 'XYZ').collect()                  \n    ['c', 3, 'X']\n    >>> Iter.random_product('abc', range(4), 'XYZ').collect()                  \n    ['c', 0, 'Z']\n    >>> Iter('abc').random_product(range(0)).collect()\n    Traceback (most recent call last):\n        ...\n    IndexError: Cannot choose from an empty sequence\n    >>> Iter.random_product(range(0)).collect()\n    Traceback (most recent call last):\n        ...\n    IndexError: Cannot choose from an empty sequence\n\n\n\n.. _Iter.random_permutation:\n\n\n``Iter.random_permutation(self, r=None)``\n=========================================\n\nReference: `more_itertools.random_permutation <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_permutation>`_\n\n.. code-block:: python\n\n    >>> Iter(range(5)).random_permutation().collect()                  \n    [2, 0, 4, 3, 1]\n    >>> Iter(range(0)).random_permutation().collect()\n    []\n\n\n\n.. _Iter.random_combination:\n\n\n``Iter.random_combination(self, r)``\n====================================\n\nReference: `more_itertools.random_combination <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_combination>`_\n\n.. code-block:: python\n\n    >>> Iter(range(5)).random_combination(3).collect()                  \n    [0, 1, 4]\n    >>> Iter(range(5)).random_combination(0).collect()\n    []\n\n\n\n.. _Iter.random_combination_with_replacement:\n\n\n``Iter.random_combination_with_replacement(self, r)``\n=====================================================\n\nReference: `more_itertools.random_combination_with_replacement <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.random_combination_with_replacement>`_\n\n.. code-block:: python\n\n    >>> Iter(range(3)).random_combination_with_replacement(5).collect()                  \n    [0, 0, 1, 2, 2]\n    >>> Iter(range(3)).random_combination_with_replacement(0).collect()\n    []\n\n\n\n.. _Iter.nth_combination:\n\n\n``Iter.nth_combination(self, r, index)``\n========================================\n\nReference: `more_itertools.nth_combination <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.nth_combination>`_\n\n.. code-block:: python\n\n    >>> Iter(range(9)).nth_combination(3, 1).collect()\n    [0, 1, 3]\n    >>> Iter(range(9)).nth_combination(3, 2).collect()\n    [0, 1, 4]\n    >>> Iter(range(9)).nth_combination(3, 3).collect()\n    [0, 1, 5]\n    >>> Iter(range(9)).nth_combination(4, 3).collect()\n    [0, 1, 2, 6]\n    >>> Iter(range(9)).nth_combination(3, 7).collect()\n    [0, 2, 3]\n\n\n\n.. _Iter.always_iterable:\n\n\n``@classmethod Iter.always_iterable(cls, obj, base_type=(str, bytes)) -> 'Iter'``\n=================================================================================\n\nReference: `more_itertools.always_iterable <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable>`_\n\n.. code-block: python\n\n.. code-block:: python\n\n    >>> Iter.always_iterable([1, 2, 3]).collect()\n    [1, 2, 3]\n    >>> Iter.always_iterable(1).collect()\n    [1]\n    >>> Iter.always_iterable(None).collect()\n    []\n    >>> Iter.always_iterable('foo').collect()\n    ['foo']\n    >>> Iter.always_iterable(dict(a=1), base_type=dict).collect()\n    [{'a': 1}]\n\n\n\n.. _Iter.always_reversible:\n\n\n``Iter.always_reversible(self)``\n================================\n\nReference: `more_itertools.always_reversible <https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_reversible>`_\n\nThis is like ``reversed()`` but it also operates on things that\nwouldn't normally be reversible, like generators. It does this with\ninternal caching, so be careful with memory use.\n\n.. code-block: python\n\n    >>> Iter('abc').always_reversible().collect()\n    ['c', 'b', 'a']\n    >>> Iter(x for x in 'abc').always_reversible().collect()\n    ['c', 'b', 'a']\n\n\n\n.. _Iter.with_iter:\n\n\n``@classmethod Iter.with_iter(cls, context_manager)``\n=====================================================\n\nReference: `more_itertools.with_iter <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.with_iter>`_\n\nNote: Any context manager which returns an iterable is a candidate for\nIter.with_iter_.\n\n.. code-block:: python\n\n    >>> import tempfile\n    >>> with tempfile.TemporaryDirectory() as td:\n    ...     with open(td + 'text.txt', 'w') as f:\n    ...         f.writelines(['abc\\n', 'def\\n', 'ghi\\n'])\n    ...     Iter.with_iter(open(td + 'text.txt')).map(lambda x: x.upper()).collect()\n    ['ABC\\n', 'DEF\\n', 'GHI\\n']\n\nSee also: Iter.open_\n\n|flux| TODO: perhaps we should get rid of Iter.open_ and just use this?\n\n\n\n.. _Iter.iter_except:\n\n\n``@classmethod Iter.iter_except(cls, func, exception, first=None) -> \"Iter\"``\n=============================================================================\n\nReference: `more_itertools.iter_except <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.iter_except>`_\n\n.. code-block:: python\n\n    >>> l = [0, 1, 2]\n    >>> Iter.iter_except(l.pop, IndexError).collect()\n    [2, 1, 0]\n\n\n\n.. _Iter.locate:\n\n\n``Iter.locate(self, pred=bool, window_size=None) -> \"Iter\"``\n============================================================\n\nReference: `more_itertools.locate <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.locate>`_\n\n.. code-block:: python\n\n    >>> Iter([0, 1, 1, 0, 1, 0, 0]).locate().collect()\n    [1, 2, 4]\n\n.. code-block:: python\n\n    >>> Iter(['a', 'b', 'c', 'b']).locate(lambda x: x == 'b').collect()\n    [1, 3]\n\n.. code-block:: python\n\n    >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n    >>> pred = lambda *args: args == (1, 2, 3)\n    >>> Iter(iterable).locate(pred=pred, window_size=3).collect()\n    [1, 5, 9]\n\n.. code-block:: python\n\n    >>> from itertools import count\n    >>> from more_itertools import seekable\n    >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n    >>> it = Iter(source).seekable()\n    >>> pred = lambda x: x > 100\n    >>> # TODO: can we avoid making two instances?\n    >>> indexes = Iter(it).locate(pred=pred)\n    >>> i = next(indexes)\n    >>> it.seek(i)\n    >>> next(it)\n    106\n\n\n\n.. _Iter.rlocate:\n\n\n``Iter.rlocate(self, pred=bool, window_size=None) -> \"Iter\"``\n=============================================================\n\nReference: `more_itertools.rlocate <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.rlocate>`_\n\n.. code-block:: python\n\n    >>> Iter([0, 1, 1, 0, 1, 0, 0]).rlocate().collect()  # Truthy at 1, 2, and 4\n    [4, 2, 1]\n\n.. code-block:: python\n\n    >>> pred = lambda x: x == 'b'\n    >>> Iter('abcb').rlocate(pred).collect()\n    [3, 1]\n\n.. code-block:: python\n\n    >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n    >>> pred = lambda *args: args == (1, 2, 3)\n    >>> Iter(iterable).rlocate(pred=pred, window_size=3).collect()\n    [9, 5, 1]\n\n\n\n.. _Iter.replace:\n\n\n``Iter.replace(self, pred, substitutes, count=None, window_size=1) -> \"Iter\"``\n==============================================================================\n\nReference: `more_itertools.replace <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.replace>`_\n\n.. code-block:: python\n\n    >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n    >>> pred = lambda x: x == 0\n    >>> substitutes = (2, 3)\n    >>> Iter(iterable).replace(pred, substitutes).collect()\n    [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n.. code-block:: python\n\n    >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n    >>> pred = lambda x: x == 0\n    >>> substitutes = [None]\n    >>> Iter(iterable).replace(pred, substitutes, count=2).collect()\n    [1, 1, None, 1, 1, None, 1, 1, 0]\n\n.. code-block:: python\n\n    >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n    >>> window_size = 3\n    >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n    >>> substitutes = [3, 4] # Splice in these items\n    >>> Iter(iterable).replace(\n    ...     pred, substitutes, window_size=window_size\n    ... ).collect()\n    [3, 4, 5, 3, 4, 5]\n\n\n\n.. _Iter.numeric_range:\n\n\n``@classmethod Iter.numeric_range(cls, *args) -> \"Iter\"``\n=========================================================\n\nReference: `more_itertools.numeric_range <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.numeric_range>`_\n\n.. code-block:: python\n\n    >>> Iter.numeric_range(3.5).collect()\n    [0.0, 1.0, 2.0, 3.0]\n\n.. code-block:: python\n\n    >>> from decimal import Decimal\n    >>> start = Decimal('2.1')\n    >>> stop = Decimal('5.1')\n    >>> Iter.numeric_range(start, stop).collect()\n    [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n.. code-block:: python\n\n    >>> from fractions import Fraction\n    >>> start = Fraction(1, 2)  # Start at 1/2\n    >>> stop = Fraction(5, 2)  # End at 5/2\n    >>> step = Fraction(1, 2)  # Count by 1/2\n    >>> Iter.numeric_range(start, stop, step).collect()\n    [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n.. code-block:: python\n\n    >>> Iter.numeric_range(3, -1, -1.0).collect()\n    [3.0, 2.0, 1.0, 0.0]\n\n\n\n.. _Iter.side_effect:\n\n\n``Iter.side_effect(self, func, *args, chunk_size=None, before=None, after=None)``\n=================================================================================\n\nReference: `more_itertools.side_effect <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.side_effect>`_\n\n.. code-block:: python\n\n    >>> def f(item):\n    ...     if item == 3:\n    ...         raise Exception('got 3')\n    >>> Iter.range(5).side_effect(f).consume()\n    Traceback (most recent call last):\n        ...\n    Exception: got 3\n\n.. code-block:: python\n\n    >>> func = lambda item: print('Received {}'.format(item))\n    >>> Iter.range(2).side_effect(func).consume()\n    Received 0\n    Received 1\n\nThis version of ``side_effect`` also allows extra args:\n\n.. code-block:: python\n\n    >>> func = lambda item, format_str='Received {}': print(format_str.format(item))\n    >>> Iter.range(2).side_effect(func).consume()\n    Received 0\n    Received 1\n    >>> func = lambda item, format_str='Received {}': print(format_str.format(item))\n    >>> Iter.range(2).side_effect(func, 'Got {}').consume()\n    Got 0\n    Got 1\n\n\n\n\n.. _Iter.iterate:\n\n\n``Iter.iterate(self)``\n======================\n\n.. _Iter.difference:\n\n\n``Iter.difference(self, func=operator.sub, *, initial=None)``\n=============================================================\n\nReference: `more_itertools.difference <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=difference#more_itertools.difference>`_\n\n.. code-block:: python\n\n    >>> iterable = [0, 1, 3, 6, 10]\n    >>> Iter(iterable).difference().collect()\n    [0, 1, 2, 3, 4]\n\n.. code-block:: python\n\n    >>> iterable = [1, 2, 6, 24, 120]  # Factorial sequence\n    >>> func = lambda x, y: x // y\n    >>> Iter(iterable).difference(func).collect()\n    [1, 2, 3, 4, 5]\n\n\n\n.. _Iter.make_decorator:\n\n\n``Iter.make_decorator(self)``\n=============================\n\n.. _Iter.SequenceView:\n\n\n``Iter.SequenceView(self)``\n===========================\n\n.. _Iter.time_limited:\n\n\n``Iter.time_limited(self, limit_seconds) -> \"Iter\"``\n====================================================\n\nReference: `more_itertools.time_limited <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=time_limited#more_itertools.time_limited>`_\n\n.. code-block:: python\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> Iter(generator()).time_limited(0.1).collect()\n    [1, 2]\n\n\n\n.. _Iter.consume:\n\n\n|sink| ``Iter.consume(self, n: Optional[int] = None) -> \"Optional[Iter[T]]\"``\n=============================================================================\n\n\nIf n is not provided, the entire iterator is consumed and\n``None`` is returned. Otherwise, an iterator will *always* be\nreturned, even if n is greater than the number of items left in\nthe iterator.\n\nIn this example, the source has more elements than what we consume,\nso there will still be data available on the chain:\n\n.. code-block:: python\n\n    >>> range(10).consume(5).collect()\n    [5, 6, 7, 8, 9]\n\nWe can bump up the count of how many items can be consumed. Note that\neven though ``n`` is greater than the number of items in the source,\nit is still required to call Iter.collect_ to consume the remaining\nitems.\n\n.. code-block:: python\n\n    >>> range(10).consume(50).collect()\n    []\n\nFinally, if ``n`` is not provided, the entire stream is consumed.\nIn this scenario, Iter.collect_ would fail since nothing is being\nreturned from the consume call.\n\n.. code-block:: python\n\n    >>> assert range(10).consume() is None\n\n\n\n.. _Iter.tabulate:\n\n\n``Iter.tabulate(self)``\n=======================\n\n.. _Iter.repeatfunc:\n\n\n|source| ``@classmethod Iter.repeatfunc(cls, func, *args, times=None)``\n=======================================================================\n\n\nDocstring TBD\n\n.. code-block:: python\n\n    >>> Iter.repeatfunc(operator.add, 3, 5, times=4).collect()\n    [8, 8, 8, 8]\n\n\n\n.. _Iter.wrap:\n\n\n``Iter.wrap(self, ends: \"Sequence[T, T]\" = \"()\")``\n==================================================\nOther examples for ends: '\"' * 2, or '`' * 2, or '[]' etc.\n\n\n.. _Iter.print:\n\n\n``Iter.print(self, template=\"{i}: {v}\") -> \"Iter[T]\"``\n======================================================\n\nPrinting during the execution of an iterator. Mostly useful\nfor debugging. Returns another iterator instance through which\nthe original data is passed unchanged. This means you can include\na `print()` step as necessary to observe data during iteration.\n\n.. code-block:: python\n\n    >>> Iter('abc').print().collect()\n    0: a\n    1: b\n    2: c\n    ['a', 'b', 'c']\n\n    >>> (\n    ...    Iter(range(5))\n    ...        .print('before filter {i}: {v}')\n    ...        .filter(lambda x: x > 2)\n    ...        .print('after filter {i}: {v}')\n    ...        .collect()\n    ... )\n    before filter 0: 0\n    before filter 1: 1\n    before filter 2: 2\n    before filter 3: 3\n    after filter 0: 3\n    before filter 4: 4\n    after filter 1: 4\n    [3, 4]\n\n\n\n.. _Iter.from_queue:\n\n\n|source| ``@classmethod Iter.from_queue(cls, q: queue.Queue, timeout=None, sentinel=None)``\n===========================================================================================\n\n\nWrap a queue with an iterator interface. This allows it to participate\nin chaining operations. The iterator will block while waiting for\nnew values to appear on the queue. This is useful: it allows you\nto easily and safely pass data between threads or processes, and\nfeed the incoming data into a pipeline.\n\nThe sentinel value, default ``None``, will terminate the iterator.\n\n.. code-block:: python\n\n    >>> q = queue.Queue()\n    >>> # This line puts stuff onto a queue\n    >>> range(10).chain([None]).map(q.put).consume()\n    >>> # This is where we consume data from the queue:\n    >>> Iter.from_queue(q).filter(lambda x: 2 < x < 9).collect()\n    [3, 4, 5, 6, 7, 8]\n\nIf ``None`` had not been chained onto the data, the iterator would\nhave waited in Iter.collect_ forever.\n\n\n\n.. _Iter.into_queue:\n\n\n``Iter.into_queue(self, q: queue.Queue) -> \"Iter[T]\"``\n======================================================\n\nThis is a sink, like Iter.collect_, that consumes data from\nan iterator chain and puts the data into the given queue.\n\n.. code-block:: python\n\n    >>> q = queue.Queue()\n    >>> # This demonstrates the queue sink\n    >>> range(5).into_queue(q).consume()\n    >>> # Code below is only for verification\n    >>> out = []\n    >>> finished = False\n    >>> while not finished:\n    ...     try:\n    ...         out.append(q.get_nowait())\n    ...     except queue.Empty:\n    ...         finished = True\n    >>> out\n    [0, 1, 2, 3, 4]\n\n\n\n.. _Iter.send:\n\n\n|sink| ``Iter.send(self, collector: Generator, close_collector_when_done=False) -> \"None\"``\n===========================================================================================\n\n\nSee also: `more_itertools.consumer <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.consumer>`_\n\nSend data into a generator. You do not have to first call ``next()``\non the generator. Iter.send_ will do this for you.\n\n|warning| Look carefully at the examples below; you'll see that the\n``yield`` keyword is wrapped in a second set of parens, e.g.\n``output.append((yield))``. This is required!\n\nSimple case:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...     while True:\n    ...         output.append((yield))\n    >>> Iter.range(3).send(collector())\n    >>> output\n    [0, 1, 2]\n\nNote that the generator is **not** closed by default after the iterable is\nexhausted. But this can be changed. If you choose to close the\ngenerator, use the parameter:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...     while True:\n    ...         output.append((yield))\n    >>> g = collector()\n    >>> Iter.range(3).send(g, close_collector_when_done=True)\n    >>> Iter.range(3).send(g)\n    Traceback (most recent call last):\n        ...\n    StopIteration\n\nThe default behaviour is that the generator is left open which means you\ncan keep using it for other iterators:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...     while True:\n    ...         output.append((yield))\n    >>> g = collector()\n    >>> Iter.range(3).send(g)\n    >>> Iter.range(10, 13).send(g)\n    >>> Iter.range(100, 103).send(g)\n    >>> output\n    [0, 1, 2, 10, 11, 12, 100, 101, 102]\n\n\nIf the generator is closed before the iteration is complete,\nyou'll get a ``StopIteration`` exception:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...   for i in range(3):\n    ...       output.append((yield))\n    >>> Iter.range(5).send(collector())\n    Traceback (most recent call last):\n        ...\n    StopIteration\n\nNote that Iter.send_ is a sink, so no further chaining is allowed.\n\n\n\n.. _Iter.send_also:\n\n\n``Iter.send_also(self, collector: Generator) -> \"Iter\"``\n========================================================\n\nReference: `more_itertools.consumer <https://more-itertools.readthedocs.io/en/stable/api.html?highlight=numeric_range#more_itertools.consumer>`_\n\nSome ideas around a reverse iterator as a sink. Usually you have\nfirst to \"send\" a ``None`` into a generator if you want to send\nmore values into it (or call ``next()`` on it), but we handle \nthat automatically.\n\nSimple case:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...     while True:\n    ...         output.append((yield))\n    >>> Iter.range(3).send_also(collector()).collect()\n    [0, 1, 2]\n    >>> output\n    [0, 1, 2]\n\nHowever, if the caller already started the generator, that \nworks too:\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...     while True:\n    ...         output.append((yield))\n    >>> g = collector()\n    >>> next(g)  # This \"starts\" the generator\n    >>> Iter.range(3).send_also(g).collect()\n    [0, 1, 2]\n    >>> output\n    [0, 1, 2]\n\nIf the generator is closed before the iteration is complete,\nyou'll get an exception (Python 3.7+):\n\n.. code-block:: python\n\n    >>> output = []\n    >>> def collector():\n    ...   for i in builtins.range(3):\n    ...       output.append((yield))\n    >>> Iter.range(50).send_also(collector()).collect()                  \n    Traceback (most recent call last):\n        ...\n    RuntimeError\n\nNote that the above doesn't happen in Python < 3.7 (which includes\npypy 7.3.1 that matches Python 3.6.9 compatibility). Instead, you\ncollect out the items up to until the point that the collector\nreturns; in this case, you'd get [0, 1, 2]. This change was made\nas part of `PEP 479 <https://www.python.org/dev/peps/pep-0479/>`_.\n\nRegardless, for any Python it's recommended that your generator\nlive at least as long as the iterator feeding it.\n\n\n\n.. _Iter.sorted:\n\n\n|sink| |warning| ``Iter.sorted(self, key=None, reverse=False) -> \"Iter[T]\"``\n============================================================================\n\n\n\nSimple wrapper for the ``sorted`` builtin.\n\n\nCalling this will read the entire stream before producing\nresults.\n\n.. code-block:: python\n\n    >>> Iter('bac').sorted().collect()\n    ['a', 'b', 'c']\n    >>> Iter('bac').sorted(reverse=True).collect()\n    ['c', 'b', 'a']\n    >>> Iter('bac').zip([2, 1, 0]).sorted(key=lambda tup: tup[1]).collect()\n    [('c', 0), ('a', 1), ('b', 2)]\n\n\n\n.. _Iter.reversed:\n\n\n|sink| |warning| ``Iter.reversed(self) -> \"Iter[T]\"``\n=====================================================\n\n\n\nSimple wrapper for the ``reversed`` builtin.\n\n\nCalling this will read the entire stream before producing\nresults.\n\n.. code-block:: python\n\n    >>> Iter(range(4)).reversed().collect()\n    [3, 2, 1, 0]\n\n\n\n\nExperiments and Provisional Ideas\n#################################\n\n\n\n.. _IterDict:\n\n\n|flux| ``class IterDict(UserDict)``\n***********************************\n\n\n\nThe idea here was to make a custom dict where several of\nthe standard dict methods return ``Iter`` instances, which can then\nbe chained. I'm not sure if this will be kept yet.\n\n\n.. _IterDict.keys:\n\n\n``IterDict.keys(self) -> \"Iter\"``\n=================================\n\n.. _IterDict.values:\n\n\n``IterDict.values(self) -> \"Iter\"``\n===================================\n\n.. _IterDict.items:\n\n\n``IterDict.items(self) -> \"Iter\"``\n==================================\n\n.. _IterDict.update:\n\n\n``IterDict.update(self, *args, **kwargs) -> \"IterDict\"``\n========================================================\n\n.. _insert_separator:\n\n\n``insert_separator(iterable: Iterable[Any], glue: Any) -> \"Iterable[Any]\"``\n***************************************************************************\nSimilar functionality can be obtained with, e.g.,\ninterleave, as in\n\n.. code-block:: python\n\n    >>> result = Iter('caleb').interleave(Iter.repeat('x')).collect()\n    >>> result == list('cxaxlxexbx')\n    True\n\nBut you'll see a trailing \"x\" there, which join avoids. join\nmakes sure to only add the glue separator if another element\nhas arrived.\n\nIt can handle strings without any special considerations, but it doesn't\ndo any special handling for bytes and bytearrays. For that, rather\nlook at `concat()`.\n\n\n\nRelated projects\n################\n\nIt turns out the idea of chaining iterators is not new. There are many\nlibraries that offer similar features:\n\n* My fork of a now-missing library: `chained-iterable <https://github.com/cjrh/chained-iterable>`_.\n\n* `https://github.com/olirice/flupy <https://github.com/olirice/flupy>`_\n\n* `https://github.com/ddstte/chiter <https://github.com/ddstte/chiter>`_\n\n* `https://github.com/neverendingqs/pyiterable <https://github.com/neverendingqs/pyiterable>`_\n\n* `https://github.com/alliefitter/iterable_collections <https://github.com/alliefitter/iterable_collections>`_\n\n* `https://github.com/halprin/iterator-chain <https://github.com/halprin/iterator-chain>`_\n\n* `https://github.com/jagill/python-chainz <https://github.com/jagill/python-chainz>`_\n\n* `https://github.com/ZianVW/IterPipe <https://github.com/ZianVW/IterPipe>`_\n\n* `https://github.com/Evelyn-H/iterchain <https://github.com/Evelyn-H/iterchain>`_\n\n* `https://github.com/EntilZha/PyFunctional <https://github.com/EntilZha/PyFunctional>`_\n\n* `https://github.com/dwt/fluent <https://github.com/dwt/fluent>`_\n\nSomewhat related:\n\n* `https://github.com/jreese/aioitertools <https://github.com/jreese/aioitertools>`_\n\nDev Instructions\n################\n\nSetup\n*****\n\n.. code-block:: shell\n\n    $ python -m venv venv\n    $ source venv/bin/activate\n    (venv) $ pip install -e .[dev,test]\n\nTesting\n*******\n\n.. code-block:: shell\n\n    (venv) $ pytest --cov\n\nDocumentation\n*************\n\nTo regenerate the documentation, file ``README.rst``:\n\n.. code-block:: shell\n\n    (venv) $ python regenerate_readme.py -m excitertools.py > README.rst\n\nReleasing\n*********\n\nTo do a release, we're using `bumpymcbumpface <https://pypi.org/project/bumpymcbumpface/>`_.\nMake sure that is set up correctly according to its own documentation. I \nlike to use `pipx <https://github.com/pipxproject/pipx>`_ to install and \nmanage these kinds of tools.\n\n.. code-block:: shell\n\n    $ bumpymcbumpface --push-git --push-pypi\n\n|\n|\n\n-----\n\n|\n|\n\n    Work is a necessary evil to be avoided. \n    *Mark Twain*\n\n\n\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/cjrh/excitertools",
    "keywords": "itertools",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "excitertools",
    "package_url": "https://pypi.org/project/excitertools/",
    "platform": "",
    "project_url": "https://pypi.org/project/excitertools/",
    "project_urls": {
      "Homepage": "https://github.com/cjrh/excitertools"
    },
    "release_url": "https://pypi.org/project/excitertools/2021.10.5/",
    "requires_dist": [
      "more-itertools",
      "check-manifest ; extra == 'dev'",
      "pytest ; extra == 'test'",
      "coverage ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "itertools with function chaining",
    "version": "2021.10.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11845671,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3c9b139a5434f8bc782436c48fdc968b7f2abeec136432837c38447cf5d50df3",
          "md5": "b6b63e799bcc395df37f5d685ebdd9c0",
          "sha256": "eb7e4c204c0df8130cfb1399cc4421517ec1ced0f661e23c012879560f45b488"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b6b63e799bcc395df37f5d685ebdd9c0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13516,
        "upload_time": "2020-05-03T06:33:49",
        "upload_time_iso_8601": "2020-05-03T06:33:49.247025Z",
        "url": "https://files.pythonhosted.org/packages/3c/9b/139a5434f8bc782436c48fdc968b7f2abeec136432837c38447cf5d50df3/excitertools-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7082b5bd7b749223b11127f00f76feb783bbcd4add802c01013512685a61c4cc",
          "md5": "f47f1ec8b2ddef8d7e7b2de9c2a7ea11",
          "sha256": "75d16169a8710f09e90a167cabff5f2f66031d19daee74986c1ac5eada1308dc"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f47f1ec8b2ddef8d7e7b2de9c2a7ea11",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28843,
        "upload_time": "2020-05-03T06:33:53",
        "upload_time_iso_8601": "2020-05-03T06:33:53.092396Z",
        "url": "https://files.pythonhosted.org/packages/70/82/b5bd7b749223b11127f00f76feb783bbcd4add802c01013512685a61c4cc/excitertools-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0a06844eadae34d9c236536e76251c02505277b5c375d84c674907a118622dd6",
          "md5": "d90f48d5a84d7ec5c4172ae4e3f48b56",
          "sha256": "a3aa90d724c5e6d78cd591735d2fa866b822ba4221f5e1bd0af431ccfca23b60"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d90f48d5a84d7ec5c4172ae4e3f48b56",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13583,
        "upload_time": "2020-05-03T06:40:17",
        "upload_time_iso_8601": "2020-05-03T06:40:17.146509Z",
        "url": "https://files.pythonhosted.org/packages/0a/06/844eadae34d9c236536e76251c02505277b5c375d84c674907a118622dd6/excitertools-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2dbd5a55ceff6fa32e01f85ab50596e1cbc5497c5db97c729d5b99443796b50c",
          "md5": "86ef3052509db0d4d16f4f7defda749a",
          "sha256": "778fc80de7a370e9b0bca05516a68bd5ec580053bd2b84f35457ae46be67b71f"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "86ef3052509db0d4d16f4f7defda749a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28949,
        "upload_time": "2020-05-03T06:40:22",
        "upload_time_iso_8601": "2020-05-03T06:40:22.135715Z",
        "url": "https://files.pythonhosted.org/packages/2d/bd/5a55ceff6fa32e01f85ab50596e1cbc5497c5db97c729d5b99443796b50c/excitertools-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "73f55f008278938e3f48883bd67346390ecf3e91ec527257f2d2a3d893c23ae9",
          "md5": "90d0ec7fc0f01ea008eacf2aff8d5773",
          "sha256": "fce4c408becb0032953df349d60ad471c133cbc8fdd32c7548b23f0703b73977"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "90d0ec7fc0f01ea008eacf2aff8d5773",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13584,
        "upload_time": "2020-05-03T06:45:31",
        "upload_time_iso_8601": "2020-05-03T06:45:31.602801Z",
        "url": "https://files.pythonhosted.org/packages/73/f5/5f008278938e3f48883bd67346390ecf3e91ec527257f2d2a3d893c23ae9/excitertools-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "808fbd67c01afa12fe0a37e01a2e0808b8ba410af84444d4d2911d82ddcc7d75",
          "md5": "789aa685d5970ef664ba5b093ff97f62",
          "sha256": "2e94466da4e881d80c70bddc3915377ac453c668f8c3d7ffe6fba93a234944bd"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "789aa685d5970ef664ba5b093ff97f62",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 28976,
        "upload_time": "2020-05-03T06:45:35",
        "upload_time_iso_8601": "2020-05-03T06:45:35.044177Z",
        "url": "https://files.pythonhosted.org/packages/80/8f/bd67c01afa12fe0a37e01a2e0808b8ba410af84444d4d2911d82ddcc7d75/excitertools-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "988dd794421ccde0119508026474c490d732e47bd7247a981f80aca46bb81f7c",
          "md5": "4780dc964dbc7c16146839bd47928937",
          "sha256": "770b1ffed10eb16705c155064c38184209d530979f7b8645b964c9e09c559a59"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4780dc964dbc7c16146839bd47928937",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13718,
        "upload_time": "2020-05-03T06:59:34",
        "upload_time_iso_8601": "2020-05-03T06:59:34.147980Z",
        "url": "https://files.pythonhosted.org/packages/98/8d/d794421ccde0119508026474c490d732e47bd7247a981f80aca46bb81f7c/excitertools-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7201ed67cc0529462904b8a136843ce0ce2e42000055b0bc89b7482d974b489b",
          "md5": "b2d822c03419076d31783fcd5dc1cec5",
          "sha256": "d1f76fe22e502ab371c3247849c554ba6b2197b7b1171d642b007461996b93af"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "b2d822c03419076d31783fcd5dc1cec5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 29568,
        "upload_time": "2020-05-03T06:59:37",
        "upload_time_iso_8601": "2020-05-03T06:59:37.323744Z",
        "url": "https://files.pythonhosted.org/packages/72/01/ed67cc0529462904b8a136843ce0ce2e42000055b0bc89b7482d974b489b/excitertools-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "842825edcea65bdb09788c7080bd60cb04afa19a37bc28c241e420cb10873491",
          "md5": "625315dd695c8d7ce630a80746068273",
          "sha256": "ce339c6f6ab422157622ad76ab75b41a07289433fc39329316096a2ef297f2f5"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "625315dd695c8d7ce630a80746068273",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 15860,
        "upload_time": "2020-05-03T13:55:16",
        "upload_time_iso_8601": "2020-05-03T13:55:16.251807Z",
        "url": "https://files.pythonhosted.org/packages/84/28/25edcea65bdb09788c7080bd60cb04afa19a37bc28c241e420cb10873491/excitertools-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0e55d0dbe72ddf2905430c9d97274f3d8d477dc0d57f3ce02a9e20f2fcdc2833",
          "md5": "5ec8cf5b2e88d161f1f6d633bf44706b",
          "sha256": "0584ed00fcaa2236cb9159a91be89718419d6b553e108afae3d3c79ac37fd2da"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5ec8cf5b2e88d161f1f6d633bf44706b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 36085,
        "upload_time": "2020-05-03T13:55:19",
        "upload_time_iso_8601": "2020-05-03T13:55:19.720794Z",
        "url": "https://files.pythonhosted.org/packages/0e/55/d0dbe72ddf2905430c9d97274f3d8d477dc0d57f3ce02a9e20f2fcdc2833/excitertools-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7027cecc883a3bffa54a12a67131d94870d0df9d07a22c49fe2971a32e35efee",
          "md5": "b6fdab5f1ecbe316a619b6f4b4e17dea",
          "sha256": "5e234afcc915c4f968cec6e60cfa75981e7b859407503fc51ad3fc2f29887d08"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b6fdab5f1ecbe316a619b6f4b4e17dea",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 15891,
        "upload_time": "2020-05-03T13:59:11",
        "upload_time_iso_8601": "2020-05-03T13:59:11.940642Z",
        "url": "https://files.pythonhosted.org/packages/70/27/cecc883a3bffa54a12a67131d94870d0df9d07a22c49fe2971a32e35efee/excitertools-0.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "09d8893760304e40a73fc483f14b7f2cada7d203867e9fc6148d96f6a6e20b18",
          "md5": "2e3bb4c25b863ea0b7715989389cfeb2",
          "sha256": "b0206df43c5a7dc8b6ae93a4c10e6568c540177f5639c3c28d5b4bce62b33259"
        },
        "downloads": -1,
        "filename": "excitertools-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "2e3bb4c25b863ea0b7715989389cfeb2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 36163,
        "upload_time": "2020-05-03T13:59:15",
        "upload_time_iso_8601": "2020-05-03T13:59:15.728665Z",
        "url": "https://files.pythonhosted.org/packages/09/d8/893760304e40a73fc483f14b7f2cada7d203867e9fc6148d96f6a6e20b18/excitertools-0.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "349361d9bb08b9ac61821da7c7141282edf6fca0946110436013265ba8df5fb8",
          "md5": "a7e6204dc97afa8ea0e9b384e14f2bd7",
          "sha256": "f23a1b5bd44d8cf1e9a2c83eda583eae1e943041c5294b5389ab13ab377d8001"
        },
        "downloads": -1,
        "filename": "excitertools-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a7e6204dc97afa8ea0e9b384e14f2bd7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 19963,
        "upload_time": "2020-05-04T05:35:53",
        "upload_time_iso_8601": "2020-05-04T05:35:53.705693Z",
        "url": "https://files.pythonhosted.org/packages/34/93/61d9bb08b9ac61821da7c7141282edf6fca0946110436013265ba8df5fb8/excitertools-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ba30b7b05e4ba64801498d049e94e34edc9598e2bce7ad63ff5f316d2d405597",
          "md5": "82998b71fc98cb26056651a802c950b7",
          "sha256": "c6fbdece26530f8d1205f25deb27f2671ffe223ff5747a49f56786843696543c"
        },
        "downloads": -1,
        "filename": "excitertools-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "82998b71fc98cb26056651a802c950b7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 48737,
        "upload_time": "2020-05-04T05:35:58",
        "upload_time_iso_8601": "2020-05-04T05:35:58.387570Z",
        "url": "https://files.pythonhosted.org/packages/ba/30/b7b05e4ba64801498d049e94e34edc9598e2bce7ad63ff5f316d2d405597/excitertools-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bcd8f55623dd4b466634b61890fc33d9d52f62a438f04b985c91734c98b1d4eb",
          "md5": "d7ea69ded4ad3d05dfb6d1ace98b6648",
          "sha256": "15d90f04349042d96f71847314ba4753b039a6a6bb4d9b3b60dcf93ab16a7dcf"
        },
        "downloads": -1,
        "filename": "excitertools-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d7ea69ded4ad3d05dfb6d1ace98b6648",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 19962,
        "upload_time": "2020-05-04T05:40:06",
        "upload_time_iso_8601": "2020-05-04T05:40:06.632682Z",
        "url": "https://files.pythonhosted.org/packages/bc/d8/f55623dd4b466634b61890fc33d9d52f62a438f04b985c91734c98b1d4eb/excitertools-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d22f604b740c8f643fb6309fc8b6b673926a8996b292aaa668c8203598c23440",
          "md5": "45b9415053847c011e8123602a141673",
          "sha256": "f87f1d9ee46dfa81401c5b1ad431d9798dd24634d2facca69a6bfebdf17f9475"
        },
        "downloads": -1,
        "filename": "excitertools-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "45b9415053847c011e8123602a141673",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 48736,
        "upload_time": "2020-05-04T05:40:11",
        "upload_time_iso_8601": "2020-05-04T05:40:11.087771Z",
        "url": "https://files.pythonhosted.org/packages/d2/2f/604b740c8f643fb6309fc8b6b673926a8996b292aaa668c8203598c23440/excitertools-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e84bf78e51c238ffd6f78f5a854c98820a2e77220e8152ece61f1962a687f146",
          "md5": "173927528f1596afde6dcc194c67b358",
          "sha256": "0e15a06bb3c2994f9e3fbf0f155cfe16f24ad235c0418b1d3385cf23a0abaf8e"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "173927528f1596afde6dcc194c67b358",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 20345,
        "upload_time": "2020-05-04T07:12:52",
        "upload_time_iso_8601": "2020-05-04T07:12:52.875629Z",
        "url": "https://files.pythonhosted.org/packages/e8/4b/f78e51c238ffd6f78f5a854c98820a2e77220e8152ece61f1962a687f146/excitertools-0.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "de414f3dfc3ab2180572256026b95e79d86a4eda867522f10f0ad2ff526a102d",
          "md5": "d22ace5e8cc7d4000b1220a85a69e6e9",
          "sha256": "023e739d5661cd80795042354fa346010d93ab7180775e834deaa01a9841b12e"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d22ace5e8cc7d4000b1220a85a69e6e9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49796,
        "upload_time": "2020-05-04T07:12:57",
        "upload_time_iso_8601": "2020-05-04T07:12:57.103097Z",
        "url": "https://files.pythonhosted.org/packages/de/41/4f3dfc3ab2180572256026b95e79d86a4eda867522f10f0ad2ff526a102d/excitertools-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e45d4af0e5e7a4bd3bd5added38c863d5ee9ffd1ee94811ab3990e70f3167a4d",
          "md5": "caae572b49c3b41919c827c5b8a10d43",
          "sha256": "8c4442b654574f90d80e81e8085404fd24af09e220a4dde1f27d6b0faac9529d"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "caae572b49c3b41919c827c5b8a10d43",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 20354,
        "upload_time": "2020-05-04T07:16:36",
        "upload_time_iso_8601": "2020-05-04T07:16:36.967287Z",
        "url": "https://files.pythonhosted.org/packages/e4/5d/4af0e5e7a4bd3bd5added38c863d5ee9ffd1ee94811ab3990e70f3167a4d/excitertools-0.2.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "680dffe66bb8157e312ddbc59da8658215aef57327c2800c215d55e82c420a9c",
          "md5": "701d7feb04d279e3c3be2df6e501deaa",
          "sha256": "100e8110625102b8f5d8bbca584d205a463bbac67a5e7e7c99c14f17225517fe"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "701d7feb04d279e3c3be2df6e501deaa",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49821,
        "upload_time": "2020-05-04T07:16:43",
        "upload_time_iso_8601": "2020-05-04T07:16:43.050127Z",
        "url": "https://files.pythonhosted.org/packages/68/0d/ffe66bb8157e312ddbc59da8658215aef57327c2800c215d55e82c420a9c/excitertools-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "278ca27866d320297b4f3cd12acf1e3b727418ee91bcdecb7dfd97fa1f00d3ae",
          "md5": "79e3031bfd5046b08c4705f05c1d2c60",
          "sha256": "05feb8e2666c0f3e50542aa043091c083f9043e33dc3a4ca6b9da679f80856d5"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "79e3031bfd5046b08c4705f05c1d2c60",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 20977,
        "upload_time": "2020-05-04T09:05:40",
        "upload_time_iso_8601": "2020-05-04T09:05:40.991185Z",
        "url": "https://files.pythonhosted.org/packages/27/8c/a27866d320297b4f3cd12acf1e3b727418ee91bcdecb7dfd97fa1f00d3ae/excitertools-0.2.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "03145854d8ca325c39bc611ce86cb4a4554cea067881b6c85d2e349e79d064b9",
          "md5": "f3471283d4b3b4ebc09990fa15033ac7",
          "sha256": "d7cc2e0c6cfc27c0fec665e6c3d8798ca9bef2c61ceeaa09665cacf8bf071cf4"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f3471283d4b3b4ebc09990fa15033ac7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 51619,
        "upload_time": "2020-05-04T09:05:45",
        "upload_time_iso_8601": "2020-05-04T09:05:45.810537Z",
        "url": "https://files.pythonhosted.org/packages/03/14/5854d8ca325c39bc611ce86cb4a4554cea067881b6c85d2e349e79d064b9/excitertools-0.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1d77c5642b96cc97dc6f72fbb3b9e55a8f86c27aa3bb21fbce63e11b5f44f358",
          "md5": "bbdfb7bd2058f51777e1401075a817e7",
          "sha256": "a906914feb458071f37233f5dbd953165515d6e72cf6451ea088a33801eda903"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "bbdfb7bd2058f51777e1401075a817e7",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 20977,
        "upload_time": "2020-05-20T11:39:57",
        "upload_time_iso_8601": "2020-05-20T11:39:57.088359Z",
        "url": "https://files.pythonhosted.org/packages/1d/77/c5642b96cc97dc6f72fbb3b9e55a8f86c27aa3bb21fbce63e11b5f44f358/excitertools-0.2.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3f7d70299bc6c876e050efa39442c94466030648809695cccc659b3056d7dcd4",
          "md5": "289d62f262a32b3995284bb2e4936673",
          "sha256": "fdc3e51292ba82cb795905c8ff1dfaeb2f8c89b6940d095068f27cde0aeb1cf1"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "289d62f262a32b3995284bb2e4936673",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 51623,
        "upload_time": "2020-05-20T11:40:02",
        "upload_time_iso_8601": "2020-05-20T11:40:02.740161Z",
        "url": "https://files.pythonhosted.org/packages/3f/7d/70299bc6c876e050efa39442c94466030648809695cccc659b3056d7dcd4/excitertools-0.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0c62f78a61fff1d7f8c512a2bc0da59ec875bba0bf7236fb5ba5d4510615fce1",
          "md5": "ae1900732128e984c2c22573dd3261f2",
          "sha256": "7cd2859f3fecfc0c1c6a9d993d1013ad24b8cdb28a234dc051ebdda4b4ada454"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ae1900732128e984c2c22573dd3261f2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 20978,
        "upload_time": "2020-05-20T14:33:00",
        "upload_time_iso_8601": "2020-05-20T14:33:00.275377Z",
        "url": "https://files.pythonhosted.org/packages/0c/62/f78a61fff1d7f8c512a2bc0da59ec875bba0bf7236fb5ba5d4510615fce1/excitertools-0.2.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "806676b6bd6ab20c3ee2d247e938a44eee38be359e912f7b5e11308a08a61094",
          "md5": "b535fb2217970c401e7f86d1debca321",
          "sha256": "50850e460006bf6283b707b5a13644afa2d7fd5e13b72c4d498a2c71c1719a94"
        },
        "downloads": -1,
        "filename": "excitertools-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "b535fb2217970c401e7f86d1debca321",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 51617,
        "upload_time": "2020-05-20T14:33:05",
        "upload_time_iso_8601": "2020-05-20T14:33:05.391110Z",
        "url": "https://files.pythonhosted.org/packages/80/66/76b6bd6ab20c3ee2d247e938a44eee38be359e912f7b5e11308a08a61094/excitertools-0.2.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "68bb8b58aa98abe86dd4f06a0623157b6f43258e4dd3364d610ad8fba5f8f849",
          "md5": "dc30deb85ffe28f8ab47d93130b18c48",
          "sha256": "682eeb743fa3d48c8e27b080088000aeb4a72bbe04231e712c056d1233245f09"
        },
        "downloads": -1,
        "filename": "excitertools-0.3.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "dc30deb85ffe28f8ab47d93130b18c48",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23000,
        "upload_time": "2020-05-22T14:25:45",
        "upload_time_iso_8601": "2020-05-22T14:25:45.166372Z",
        "url": "https://files.pythonhosted.org/packages/68/bb/8b58aa98abe86dd4f06a0623157b6f43258e4dd3364d610ad8fba5f8f849/excitertools-0.3.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b0280c917fea4008307ba43b27cc74f0157e8b5026a99db4ec98d5fadf208934",
          "md5": "1d9e10d8dc5a64b1c40ed05fea848b06",
          "sha256": "ea482784b8083a13f3a145689875270a3f676e8524e426a1b668556eff39e833"
        },
        "downloads": -1,
        "filename": "excitertools-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1d9e10d8dc5a64b1c40ed05fea848b06",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 57964,
        "upload_time": "2020-05-22T14:25:50",
        "upload_time_iso_8601": "2020-05-22T14:25:50.127509Z",
        "url": "https://files.pythonhosted.org/packages/b0/28/0c917fea4008307ba43b27cc74f0157e8b5026a99db4ec98d5fadf208934/excitertools-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8fb5f4e45657ffd1caeaa0b3f780829ab307618abd90fd88ed314dfe395f25fc",
          "md5": "2818bfc9c2d803ac319d98b819a543ac",
          "sha256": "00b8fe855a5cb32469b1755a657340cabad389e85a28cc73a264bc96c333f02a"
        },
        "downloads": -1,
        "filename": "excitertools-0.3.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2818bfc9c2d803ac319d98b819a543ac",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 23001,
        "upload_time": "2020-05-22T14:37:12",
        "upload_time_iso_8601": "2020-05-22T14:37:12.387975Z",
        "url": "https://files.pythonhosted.org/packages/8f/b5/f4e45657ffd1caeaa0b3f780829ab307618abd90fd88ed314dfe395f25fc/excitertools-0.3.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "543535f2b19f761742580b91b43e0150eab2c7eaa8d703bab1eb768211985352",
          "md5": "4ffd197ba56aed4325fa78f74531f0ec",
          "sha256": "f02810968ae62950b4d35e4de13e1714b1fb06b08b7ebaa037546a9135dd1f1e"
        },
        "downloads": -1,
        "filename": "excitertools-0.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "4ffd197ba56aed4325fa78f74531f0ec",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 57967,
        "upload_time": "2020-05-22T14:37:16",
        "upload_time_iso_8601": "2020-05-22T14:37:16.769468Z",
        "url": "https://files.pythonhosted.org/packages/54/35/35f2b19f761742580b91b43e0150eab2c7eaa8d703bab1eb768211985352/excitertools-0.3.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "89f72c701e1bb8b03923c746de4f2e7376f495750ef22ddcd8cc70d1402df84f",
          "md5": "b852249416362be262a0f510a76e947e",
          "sha256": "a2d0f18a8bbdc8cbc1cc12ea5f56eccb481567f5ac598df68238e541b69f6202"
        },
        "downloads": -1,
        "filename": "excitertools-0.4.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b852249416362be262a0f510a76e947e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26074,
        "upload_time": "2020-05-23T05:11:52",
        "upload_time_iso_8601": "2020-05-23T05:11:52.131032Z",
        "url": "https://files.pythonhosted.org/packages/89/f7/2c701e1bb8b03923c746de4f2e7376f495750ef22ddcd8cc70d1402df84f/excitertools-0.4.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aea20c86ee6b7d82bd0dc87760761ae815a958596292b4a78b2490e8033737b2",
          "md5": "a1ec5ac735e03129340865256a1e3123",
          "sha256": "4fb83988480f572e11f40986655d730bf67e694db9d639ce4124fe7a346ba009"
        },
        "downloads": -1,
        "filename": "excitertools-0.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a1ec5ac735e03129340865256a1e3123",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 67556,
        "upload_time": "2020-05-23T05:11:56",
        "upload_time_iso_8601": "2020-05-23T05:11:56.876716Z",
        "url": "https://files.pythonhosted.org/packages/ae/a2/0c86ee6b7d82bd0dc87760761ae815a958596292b4a78b2490e8033737b2/excitertools-0.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6c9d9f2e4ec271480b272337857723acff55371399ff95073053f4d55147ce4c",
          "md5": "54deb744f2024df8ec927bffd9dc6c4c",
          "sha256": "cc9804f9085f663fe6e7e801ee372b1e45c460e02e0a3c71e0c944adb8dcb31b"
        },
        "downloads": -1,
        "filename": "excitertools-0.5.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "54deb744f2024df8ec927bffd9dc6c4c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26782,
        "upload_time": "2020-05-24T03:29:32",
        "upload_time_iso_8601": "2020-05-24T03:29:32.697352Z",
        "url": "https://files.pythonhosted.org/packages/6c/9d/9f2e4ec271480b272337857723acff55371399ff95073053f4d55147ce4c/excitertools-0.5.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "96f1f00c63acafee9f9a4e1caa59e9613abc81ccdd25efb96115ed0a3ff6f7d0",
          "md5": "05300c4614234cbe3254e288dc66120a",
          "sha256": "fa009e9c907b0599abbaed017f815aa0cf7d1e3e0c9fd5dc44ba745014b604da"
        },
        "downloads": -1,
        "filename": "excitertools-0.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "05300c4614234cbe3254e288dc66120a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 70188,
        "upload_time": "2020-05-24T03:29:37",
        "upload_time_iso_8601": "2020-05-24T03:29:37.625606Z",
        "url": "https://files.pythonhosted.org/packages/96/f1/f00c63acafee9f9a4e1caa59e9613abc81ccdd25efb96115ed0a3ff6f7d0/excitertools-0.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2020.12.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cbb3b9c23a2c5eb6f85099d1d7dc44391ce5de4dea84e85413c27e244e205499",
          "md5": "1be2661cd6b24daa04ca03f04554c99d",
          "sha256": "02272e38b791fb6ac451663fd41b1991a329511538a8e8a1ade86adf0f4d9dfc"
        },
        "downloads": -1,
        "filename": "excitertools-2020.12.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "1be2661cd6b24daa04ca03f04554c99d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 29566,
        "upload_time": "2020-12-27T01:31:31",
        "upload_time_iso_8601": "2020-12-27T01:31:31.531139Z",
        "url": "https://files.pythonhosted.org/packages/cb/b3/b9c23a2c5eb6f85099d1d7dc44391ce5de4dea84e85413c27e244e205499/excitertools-2020.12.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c09090478b6ff0e8df35daab05a9a3800551d86e535c1cf7e37273d7bc65c215",
          "md5": "67e72fc7723d0d5372513aadd4f3876b",
          "sha256": "ce5d7c066a14c99d6680ff65adfe8abc3121eb3add1b0e21a6632bebafdec9ca"
        },
        "downloads": -1,
        "filename": "excitertools-2020.12.1.tar.gz",
        "has_sig": false,
        "md5_digest": "67e72fc7723d0d5372513aadd4f3876b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 77837,
        "upload_time": "2020-12-27T01:31:37",
        "upload_time_iso_8601": "2020-12-27T01:31:37.761752Z",
        "url": "https://files.pythonhosted.org/packages/c0/90/90478b6ff0e8df35daab05a9a3800551d86e535c1cf7e37273d7bc65c215/excitertools-2020.12.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2020.12.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6e545b1ad16f9aee088f1b1929b30be4170a7b127762b7e4f628eec999ea2c6d",
          "md5": "c47ac3b522fc4d2a0e9f932b7b14a107",
          "sha256": "8de84344218908183f959de1743027c7c65a3f826849fdcb4e4cf887412e6482"
        },
        "downloads": -1,
        "filename": "excitertools-2020.12.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c47ac3b522fc4d2a0e9f932b7b14a107",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 30153,
        "upload_time": "2020-12-27T02:18:31",
        "upload_time_iso_8601": "2020-12-27T02:18:31.752378Z",
        "url": "https://files.pythonhosted.org/packages/6e/54/5b1ad16f9aee088f1b1929b30be4170a7b127762b7e4f628eec999ea2c6d/excitertools-2020.12.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6d65fc8c4ad6b11074eb460e5a0b4fb041afc66a8c06dff9a53fa6eb68e7c1f5",
          "md5": "ad98e4d250adc9aac1bea6870fd429bc",
          "sha256": "7f48d704ad487d9ba587cd5dd212e53d2d4cde6988c8d01366d4668bd79748de"
        },
        "downloads": -1,
        "filename": "excitertools-2020.12.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ad98e4d250adc9aac1bea6870fd429bc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 79447,
        "upload_time": "2020-12-27T02:18:37",
        "upload_time_iso_8601": "2020-12-27T02:18:37.226715Z",
        "url": "https://files.pythonhosted.org/packages/6d/65/fc8c4ad6b11074eb460e5a0b4fb041afc66a8c06dff9a53fa6eb68e7c1f5/excitertools-2020.12.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2020.5.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eaf2897253e5a0fef21565bc670422e3c53c1f189ded07e6901b3fa74fd9ac4f",
          "md5": "d1d136106ef412692c84cc56f9249678",
          "sha256": "872bce36c9e1c201948e2f49b9a6af75cc21841118ff3dbff9ed686d71d318b3"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d1d136106ef412692c84cc56f9249678",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 26813,
        "upload_time": "2020-05-24T04:04:44",
        "upload_time_iso_8601": "2020-05-24T04:04:44.696352Z",
        "url": "https://files.pythonhosted.org/packages/ea/f2/897253e5a0fef21565bc670422e3c53c1f189ded07e6901b3fa74fd9ac4f/excitertools-2020.5.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a260db021a47983260ac74b733d8f4741d2813161b0b113cd8608529f7ae85b3",
          "md5": "7bf32b1ed580bff0048481d8b127003b",
          "sha256": "0275fd963c9421477d55ce73f5188ffdca1518143d389365b10028d9bffeb5c6"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "7bf32b1ed580bff0048481d8b127003b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 70187,
        "upload_time": "2020-05-24T04:06:14",
        "upload_time_iso_8601": "2020-05-24T04:06:14.260379Z",
        "url": "https://files.pythonhosted.org/packages/a2/60/db021a47983260ac74b733d8f4741d2813161b0b113cd8608529f7ae85b3/excitertools-2020.5.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2020.5.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "91330118750a6a0b3960ba9eac5298f8bce717939ded1c9dc709c5af916b035f",
          "md5": "89caceba663c0adedc9a83eb268ee72a",
          "sha256": "1196d92ca4fcddaa78d2e55680fbf6863d0813e9ed521be9c29e78caccf1fedb"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "89caceba663c0adedc9a83eb268ee72a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 29528,
        "upload_time": "2020-12-27T01:12:04",
        "upload_time_iso_8601": "2020-12-27T01:12:04.213876Z",
        "url": "https://files.pythonhosted.org/packages/91/33/0118750a6a0b3960ba9eac5298f8bce717939ded1c9dc709c5af916b035f/excitertools-2020.5.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "af66170b038b3ae74077e0220c7e3b2ddc2f063954f058df3653305543edb350",
          "md5": "8b1b73fd15bd40a0b7ba5b25055257f2",
          "sha256": "276dca64ec3c117f02fafdaa32c9dadc1a183cc3f9b0b6ee153a1fc4bef8e75e"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.3.tar.gz",
        "has_sig": false,
        "md5_digest": "8b1b73fd15bd40a0b7ba5b25055257f2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 77730,
        "upload_time": "2020-12-27T01:12:10",
        "upload_time_iso_8601": "2020-12-27T01:12:10.106608Z",
        "url": "https://files.pythonhosted.org/packages/af/66/170b038b3ae74077e0220c7e3b2ddc2f063954f058df3653305543edb350/excitertools-2020.5.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2020.5.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c8a756ec204b68b7f677cc60da346d5bdd76aa2c763681bd8a2c2fbb33c718f3",
          "md5": "bcb6f916c653a68c06f0323beb9b2e95",
          "sha256": "70fae2ca3b8ca5a01faf73f669b21b6864389d0dd5759fe623d04644889be3c6"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "bcb6f916c653a68c06f0323beb9b2e95",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 29536,
        "upload_time": "2020-12-27T01:27:25",
        "upload_time_iso_8601": "2020-12-27T01:27:25.455240Z",
        "url": "https://files.pythonhosted.org/packages/c8/a7/56ec204b68b7f677cc60da346d5bdd76aa2c763681bd8a2c2fbb33c718f3/excitertools-2020.5.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "58c001e38e1c7742ec14ba18c5752c7f32f82640180751035847f333fce840d9",
          "md5": "cde138ec5329d28412550350c032af80",
          "sha256": "d299b4d79c6249c8bbbd4afba8ddb900b99f121b61dc638212e038c9c9081ddf"
        },
        "downloads": -1,
        "filename": "excitertools-2020.5.4.tar.gz",
        "has_sig": false,
        "md5_digest": "cde138ec5329d28412550350c032af80",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 77737,
        "upload_time": "2020-12-27T01:27:30",
        "upload_time_iso_8601": "2020-12-27T01:27:30.830586Z",
        "url": "https://files.pythonhosted.org/packages/58/c0/01e38e1c7742ec14ba18c5752c7f32f82640180751035847f333fce840d9/excitertools-2020.5.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.10.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0505f41a907f81e752b65cf5a4176341753b09476cafa453798432699c516622",
          "md5": "4f4c77e5bedf497cb5ef3b6f4e61356b",
          "sha256": "b623174c67cb1f3916f81a57d371e0be4af29665a4131237391f22a7aca03717"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4f4c77e5bedf497cb5ef3b6f4e61356b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 30972,
        "upload_time": "2021-10-23T13:27:38",
        "upload_time_iso_8601": "2021-10-23T13:27:38.618613Z",
        "url": "https://files.pythonhosted.org/packages/05/05/f41a907f81e752b65cf5a4176341753b09476cafa453798432699c516622/excitertools-2021.10.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "18ee008b85a4d1937696967856e813c0081de5310504555c85f7c04a88c2fed9",
          "md5": "ce50471747170c3713453cf2af063aae",
          "sha256": "a56aabfc741fbfeac14c05bdd1299f1d4130b295409e4a7ca493f8d2f9e2e29b"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ce50471747170c3713453cf2af063aae",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 82887,
        "upload_time": "2021-10-23T13:27:44",
        "upload_time_iso_8601": "2021-10-23T13:27:44.935746Z",
        "url": "https://files.pythonhosted.org/packages/18/ee/008b85a4d1937696967856e813c0081de5310504555c85f7c04a88c2fed9/excitertools-2021.10.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.10.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "91486478dc70ad051cec59ebd1051d0dfee5b6d5ce02b2568ae8d87c82ab2099",
          "md5": "c278768ef2a5dcb00882306eb3bc5a5b",
          "sha256": "098c6a1c9870bce82aa48006b469bc8f911e27df868eeb4b9c87e7a665d74c56"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c278768ef2a5dcb00882306eb3bc5a5b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 60427,
        "upload_time": "2021-10-27T10:59:34",
        "upload_time_iso_8601": "2021-10-27T10:59:34.335217Z",
        "url": "https://files.pythonhosted.org/packages/91/48/6478dc70ad051cec59ebd1051d0dfee5b6d5ce02b2568ae8d87c82ab2099/excitertools-2021.10.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3a21e120e8dea54b90f321985649699080621ac7670432f9ef5246e7225e0ff6",
          "md5": "aeac72251cd83b662c8e3b480ea811c7",
          "sha256": "4e419922dc7bf002ecf18663f76cd803ee026ad9952ef08f4cc472b5be1898c3"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.3.tar.gz",
        "has_sig": false,
        "md5_digest": "aeac72251cd83b662c8e3b480ea811c7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 114394,
        "upload_time": "2021-10-27T10:59:41",
        "upload_time_iso_8601": "2021-10-27T10:59:41.786639Z",
        "url": "https://files.pythonhosted.org/packages/3a/21/e120e8dea54b90f321985649699080621ac7670432f9ef5246e7225e0ff6/excitertools-2021.10.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2021.10.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "28c649a9f35fc4f27c300091e796e23b7c093160ed9aba4f0283fb393fa46e46",
          "md5": "0fabac943c81afb8fd159d5636e7f4f3",
          "sha256": "08514888e7044776d2ebb4f0a7fe13912f1cd082665fe9982ecd006a81025774"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0fabac943c81afb8fd159d5636e7f4f3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 60450,
        "upload_time": "2021-10-27T11:49:42",
        "upload_time_iso_8601": "2021-10-27T11:49:42.449055Z",
        "url": "https://files.pythonhosted.org/packages/28/c6/49a9f35fc4f27c300091e796e23b7c093160ed9aba4f0283fb393fa46e46/excitertools-2021.10.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3f0ebb1be87b46194cf2327228707b9324c395d817360fceea6ba60752fe15e2",
          "md5": "f7f8a76ed1ff8506310ebdc434138385",
          "sha256": "e469ca1fcf8e72f1c320ae6e238ba6c1960025e0a0def08f3878ce561daaf954"
        },
        "downloads": -1,
        "filename": "excitertools-2021.10.5.tar.gz",
        "has_sig": false,
        "md5_digest": "f7f8a76ed1ff8506310ebdc434138385",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 114432,
        "upload_time": "2021-10-27T11:49:49",
        "upload_time_iso_8601": "2021-10-27T11:49:49.824780Z",
        "url": "https://files.pythonhosted.org/packages/3f/0e/bb1be87b46194cf2327228707b9324c395d817360fceea6ba60752fe15e2/excitertools-2021.10.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "28c649a9f35fc4f27c300091e796e23b7c093160ed9aba4f0283fb393fa46e46",
        "md5": "0fabac943c81afb8fd159d5636e7f4f3",
        "sha256": "08514888e7044776d2ebb4f0a7fe13912f1cd082665fe9982ecd006a81025774"
      },
      "downloads": -1,
      "filename": "excitertools-2021.10.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "0fabac943c81afb8fd159d5636e7f4f3",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 60450,
      "upload_time": "2021-10-27T11:49:42",
      "upload_time_iso_8601": "2021-10-27T11:49:42.449055Z",
      "url": "https://files.pythonhosted.org/packages/28/c6/49a9f35fc4f27c300091e796e23b7c093160ed9aba4f0283fb393fa46e46/excitertools-2021.10.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3f0ebb1be87b46194cf2327228707b9324c395d817360fceea6ba60752fe15e2",
        "md5": "f7f8a76ed1ff8506310ebdc434138385",
        "sha256": "e469ca1fcf8e72f1c320ae6e238ba6c1960025e0a0def08f3878ce561daaf954"
      },
      "downloads": -1,
      "filename": "excitertools-2021.10.5.tar.gz",
      "has_sig": false,
      "md5_digest": "f7f8a76ed1ff8506310ebdc434138385",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 114432,
      "upload_time": "2021-10-27T11:49:49",
      "upload_time_iso_8601": "2021-10-27T11:49:49.824780Z",
      "url": "https://files.pythonhosted.org/packages/3f/0e/bb1be87b46194cf2327228707b9324c395d817360fceea6ba60752fe15e2/excitertools-2021.10.5.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}