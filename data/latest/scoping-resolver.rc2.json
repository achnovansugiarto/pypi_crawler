{
  "info": {
    "author": "thautwarm",
    "author_email": "twshere@outlook.com",
    "bugtrack_url": null,
    "classifiers": [
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: Implementation :: CPython"
    ],
    "description": "About\n==============\n\nThis repo brings about a strong analysis of scoping for Python language,\nwhich could tell a symbol inside a context is a `freevar`, `bounded var` or `cell var`, and many other details\nlike, \"is this closure a coroutine/generator/async generator?\" and so on.\n\nMore about Python's scoping, check [code object](https://github.com/Xython/YAPyPy/blob/master/python-internals/code-object.md).\n\n`Symbol-Resolver` could be leveraged to implement transpilers from Python to another language with hygienic scopes,\nlike [Tensorflow AutoGraph](https://www.tensorflow.org/guide/autograph) and [Numba AutoJit](http://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#jit-functions):\n\n```python\nfrom utranspiler import transpile, func\n# The `func` might not be a valid python function,\n# but it can be used to denote some external function.\n\n@transpile\ndef ufunc(x):\n    func(x)\n```\n\nIn above codes, `func` is resolved to be a `global` variable, in other words,\nyou can then search the name `func` from global context from current module,\nand make sure it's exactly the `func` object that is the expected external function.\n\nIf you're still confused about the power of **Symbol-Resolver**, there is also an example for you:\n\n```python\nfrom utranspiler import transpile, func\n\n@transpile\ndef ufunc(x):\n    func = lambda x: x + 1\n    func(x)\n```\n\nOr\n\n```python\nfrom utranspiler import transpile, func\nfunc = lambda x: x + 1\n@transpile\ndef ufunc(x):\n    func(x)\n```\n\nNow you cannot expect `func` as an external function, but you might not want to check the symbol manually by implementing\nyour specific symbol analyzer.\n\nTensorflow team is still struggling with above problem, you can something unhygienic in following link:\n\nhttps://github.com/tensorflow/tensorflow/blob/3ae375aa92fbb6155f82393735d0b98d8fb9c1b2/tensorflow/python/autograph/converters/lists.py#L129\n\nUsage\n=======\n\nCheck `test/test_simple.py`.\n\nThe `ScopeTagger` converts any AST that lead to a new context into a wrapped node named `ScopedAst`, where all\nthe information about current context is held.\n\n```python\nimport unittest\nimport ast\nfrom scoping_resolver import to_scoped_ast, ScopedAst, SymTable, ScopeTagger\n\nmod_code = \"\"\"\nc = lambda x: x\ndef f(x):\n    g(x)\n    c = 2\n    g(c)\n\"\"\"\nclass TestSimple(unittest.TestCase):\n    def test(self):\n        mod = ast.parse(mod_code)\n\n        # Make a new symbol table object for global context.\n        # Of course, symbol tables for sub-contexts would be created\n        # when analyzing the whole module AST.\n        g = SymTable.global_context()\n\n        # Get raw information of AST.\n        ScopeTagger(g).visit(mod)\n\n        # Peform analysis.\n        g.analyze()\n\n        # You can directly use `to_scoped_ast(mod)`\n        # instead when you don't need a top level `g`.\n\n        # Show representations of nested scopes:\n        print(g.show_resolution())\n        # [AnalyzedSymTable(bounds=set(), freevars=set(), cellvars=set()),\n        #  [[AnalyzedSymTable(bounds={'x'}, freevars=set(), cellvars=set()), []],\n        #   [AnalyzedSymTable(bounds={'x', 'c'}, freevars=set(), cellvars=set()), []]]]\n\n        body = mod.body\n        def_f: ScopedAst = body[1]\n\n        # `FunctionDef` creates a new context, so it'll be wrapped inside a ScopedAst\n\n        self.assertEqual(type(def_f), ScopedAst)\n        self.assertEqual(type(def_f.node), ast.FunctionDef)\n        self.assertIn('c', def_f.scope.analyzed.bounds)\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/thautwarm/symbol-resolver",
    "keywords": "",
    "license": "mit",
    "maintainer": "",
    "maintainer_email": "",
    "name": "scoping-resolver",
    "package_url": "https://pypi.org/project/scoping-resolver/",
    "platform": "",
    "project_url": "https://pypi.org/project/scoping-resolver/",
    "project_urls": {
      "Homepage": "https://github.com/thautwarm/symbol-resolver"
    },
    "release_url": "https://pypi.org/project/scoping-resolver/0.0.5/",
    "requires_dist": null,
    "requires_python": ">=3.6.0",
    "summary": "",
    "version": "0.0.5",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 4650705,
  "releases": {
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6d4242c8cb61afbec64c94c5347656b2c883f683ce583cee4961738520f547e6",
          "md5": "52a55b01d759ba3452a37d6aba2b699c",
          "sha256": "5bd570d509dce393cb896a714ad2b0946b16f3577d13edbc693a5126825165eb"
        },
        "downloads": -1,
        "filename": "scoping_resolver-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "52a55b01d759ba3452a37d6aba2b699c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 6435,
        "upload_time": "2019-01-01T08:47:23",
        "upload_time_iso_8601": "2019-01-01T08:47:23.021501Z",
        "url": "https://files.pythonhosted.org/packages/6d/42/42c8cb61afbec64c94c5347656b2c883f683ce583cee4961738520f547e6/scoping_resolver-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "61a27200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b",
          "md5": "558b73630efbb94dc2aa8826e2603398",
          "sha256": "f0ff1470a4bc6815eecb4399f56a013a222b776869a872d98b8d3e9292eb9cde"
        },
        "downloads": -1,
        "filename": "scoping_resolver-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "558b73630efbb94dc2aa8826e2603398",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 6437,
        "upload_time": "2019-01-01T18:07:17",
        "upload_time_iso_8601": "2019-01-01T18:07:17.718683Z",
        "url": "https://files.pythonhosted.org/packages/61/a2/7200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b/scoping_resolver-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "61a27200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b",
        "md5": "558b73630efbb94dc2aa8826e2603398",
        "sha256": "f0ff1470a4bc6815eecb4399f56a013a222b776869a872d98b8d3e9292eb9cde"
      },
      "downloads": -1,
      "filename": "scoping_resolver-0.0.5-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "558b73630efbb94dc2aa8826e2603398",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6.0",
      "size": 6437,
      "upload_time": "2019-01-01T18:07:17",
      "upload_time_iso_8601": "2019-01-01T18:07:17.718683Z",
      "url": "https://files.pythonhosted.org/packages/61/a2/7200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b/scoping_resolver-0.0.5-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}