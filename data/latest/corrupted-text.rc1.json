{
  "info": {
    "author": "Michael Weiss",
    "author_email": "michael.weiss@usi.ch",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Corrupted-Text: Realistic Out-of-Distribution Texts\n\n![test](https://github.com/vikpe/python-package-starter/workflows/test/badge.svg?branch=master)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![Imports: isort](https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336)](https://pycqa.github.io/isort/)\n[![Docstr-Coverage](https://badgen.net/badge/docstr-coverage/100%25/green?cache=30)](https://github.com/HunterMcGushion/docstr_coverage)\n[![Python Version](https://img.shields.io/pypi/pyversions/corrupted-text)](https://img.shields.io/pypi/pyversions/corrupted-text)\n[![PyPi Deployment](https://badgen.net/pypi/v/corrupted-text?cache=30)](https://pypi.org/project/corrupted-text/)\n\nA python library to generate out-of-distribution text datasets.\nSpecifically, the library applies **model-independent**, **commonplace corruptions** \n(not model-specific, worst-case adversarial corruptions).\nWe thus aim to allow benchmark-studies regarding robustness against **realistic outliers**.\n\n\n## Implemented Corruptions\n\nMost corruptions are based on a set of *common words*, to which a corruptor is fitted. These *common words* may be\ndomain specific and thus, the corruptor can be fitted with a *base dataset* from which the most common words are\nextracted.\n\nThen, the following corruptions are randomly applied on a per-word basis:\n\n1. **Bad Autocorrection**\n   Words are replaced with another, common word to which it has a small levenshtein distance. This mimicks wrong\n   autocorrection, as for example done by \"intelligent\" mobile phone keyboards.\n2. **Bad Autocompletion**\n   Words are replaced with another, common word with the same starting letters. This mimicks wrong autocompletion. If no\n   common word with at least 3 common start letters is found, a bad autocorrection is attempted instead.\n3. **Bad Synonym** Words are replaced with a synonym, accoring to a naive, flat mapping extracted\n   from [WordNet](https://wordnet.princeton.edu/), ignoring the context. This mimicks dictionary based translations,\n   which are often wrong. This assumes that you are using an english-language dataset.\n4. **Typo** A single letter is replaced with another, randomly chosen letter.\n\nTo any word, at most one corruption is applied, i.e., corruptions are not applied on top of each other.\n\nThe severity `]0, 1]` is a parameter to steer how many corruptions should be applied. It roughly corresponds to the\npercentage of words that should be corrupted\n(only *rougly* as not all bad autocompletion attempts are successful, and as sometimes, the bad synonyms consist of\nmultiple words, thus extending the number of words in the text).\n\nOptionally, users can define weights to each corruption type, steering how often they should be applied.\n\n## Accuracies\n\nThe following shows the accuracy of a regular, simple transformer model on the imdb sentiment classification dataset.\nClearly, the higher the chosen corruption severity, the lower the model accuracy.\n\n| *Severity* | 0 (*) | 0.1 | 0.3 | 0.5 | 0.7 | 0.9  | 1 (max!) |  \n|------------|-------|-----|-----|-----|-----|------|----------|\n| *Accuracy* | .87   | .81 | .78 | .75 | .71 | 0.66 | 0.64     |  \n\n(*) No corruption, original test set.\n\n## Installation\n\nIt's as simple as `pip install corrupted-text`.\n\nYou'll need python >= 3.7\n\n## Usage\n\nUsage is very straigthforward.\nThe following shows an example on how to corrupt the imdb sentiment classification dataset.\n\nYou can also run the example in colab: <a class=\"reference external\" href=\"https://colab.research.google.com/github/testingautomated-usi/corrupted-text/blob/jupyter_example/imdb_example.ipynb\"><img alt=\"Run Example in Colab\" src=\"https://colab.research.google.com/assets/colab-badge.svg\"></a>\n\n\n```python\nimport corrupted_text  # pip install corrupted-text\nimport logging \nfrom datasets import load_dataset # pip install datasets\n\n# Enable Detailed Logging\nlogging.basicConfig(level=logging.INFO)\n\n# Load the dataset (we use huggingface-datasets, but any list of strings is fine).\nnominal_train = load_dataset(\"imdb\", split=\"train\")[\"text\"]\nnominal_test = load_dataset(\"imdb\", split=\"test\")[\"text\"]\n\n# Fit a corruptor (we fit on the training and test set,\n#   but as this takes a while, you'd want to choose a smaller subset for larger datasets)\ncorruptor = corrupted_text.TextCorruptor(base_dataset=nominal_test + nominal_train,\n                                         cache_dir=\".mycache\")\n\n# Corrupt the test set with severity 0.5. The result is again a list of corrupted strings.\nimdb_corrupted = corruptor.corrupt(nominal_test, severity=0.5, seed=1)\n```\n\n## Citation\n\n    @inproceedings{Weiss2022SimpleTip, \n      title={Simple Techniques Work Surprisingly Well for Neural Network Test Prioritization and Active Learning (Replication Paper)},\n      author={Weiss, Michael and Paolo, Tonella}, \n      booktitle={Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis},\n      year={2022}\n    }\n\n## Other Corrupted Datasets\n\n- [MNIST-C](https://github.com/google-research/mnist-c) by Mu and Gilmer\n- [CIFAR-10-C](https://zenodo.org/record/2535967#.YmAC7nVBy8I) by Hendrycks and Dietterich\n- [Imagenet-C](https://zenodo.org/record/2235448) by Hendrycks and Dietterich\n- [Fashion-MNIST-C](https://github.com/testingautomated-usi/fashion-mnist-c) by Weiss and Tonella (i.e., same as `corrupted-text`)\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/testingautomated-usi/corrupted-text",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "corrupted-text",
    "package_url": "https://pypi.org/project/corrupted-text/",
    "platform": null,
    "project_url": "https://pypi.org/project/corrupted-text/",
    "project_urls": {
      "Homepage": "https://github.com/testingautomated-usi/corrupted-text"
    },
    "release_url": "https://pypi.org/project/corrupted-text/0.2.0/",
    "requires_dist": [
      "numpy (>=1.16.4)",
      "polyleven (==0.7)",
      "datasets (>=1.0.0) ; extra == 'acc_measurement'",
      "tensorflow (>=2.6.0) ; extra == 'acc_measurement'",
      "black (==22.3.0) ; extra == 'lint'",
      "docstr-coverage (==2.2.0) ; extra == 'lint'",
      "flake8 (==3.8.2) ; extra == 'lint'",
      "isort (==5.6.4) ; extra == 'lint'",
      "datasets (>=1.0.0) ; extra == 'test'",
      "pytest (>=6.2.5) ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "Corruption of text datasets; model-independent and inspired byreal-world corruption causes.",
    "version": "0.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 13569001,
  "releases": {
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "85e5aec3aa3ff91c097e6fa8853f4c7c239244310545e68c4573b0991a7bb4a5",
          "md5": "aac05ba6e109e30f4d625d0de6f074aa",
          "sha256": "c35dcebf43b454aef450544108b37a5e08f4c833f4e0c3b5ee80c1844ef9cf20"
        },
        "downloads": -1,
        "filename": "corrupted_text-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "aac05ba6e109e30f4d625d0de6f074aa",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 11397,
        "upload_time": "2022-04-20T15:02:45",
        "upload_time_iso_8601": "2022-04-20T15:02:45.787203Z",
        "url": "https://files.pythonhosted.org/packages/85/e5/aec3aa3ff91c097e6fa8853f4c7c239244310545e68c4573b0991a7bb4a5/corrupted_text-0.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3596d164116baba2a0190603c59c0a2eaa73b7f76566150ace4aa61c5bab095e",
          "md5": "315155dc9cc9f3bb3ae5017665fb28ff",
          "sha256": "ff43fd3e1c96607fd645cbb9c32132f51e639e4dbbb10f499ca03b9baf1dd1d0"
        },
        "downloads": -1,
        "filename": "corrupted-text-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "315155dc9cc9f3bb3ae5017665fb28ff",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 12919,
        "upload_time": "2022-04-20T15:02:47",
        "upload_time_iso_8601": "2022-04-20T15:02:47.385646Z",
        "url": "https://files.pythonhosted.org/packages/35/96/d164116baba2a0190603c59c0a2eaa73b7f76566150ace4aa61c5bab095e/corrupted-text-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "85e5aec3aa3ff91c097e6fa8853f4c7c239244310545e68c4573b0991a7bb4a5",
        "md5": "aac05ba6e109e30f4d625d0de6f074aa",
        "sha256": "c35dcebf43b454aef450544108b37a5e08f4c833f4e0c3b5ee80c1844ef9cf20"
      },
      "downloads": -1,
      "filename": "corrupted_text-0.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "aac05ba6e109e30f4d625d0de6f074aa",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 11397,
      "upload_time": "2022-04-20T15:02:45",
      "upload_time_iso_8601": "2022-04-20T15:02:45.787203Z",
      "url": "https://files.pythonhosted.org/packages/85/e5/aec3aa3ff91c097e6fa8853f4c7c239244310545e68c4573b0991a7bb4a5/corrupted_text-0.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3596d164116baba2a0190603c59c0a2eaa73b7f76566150ace4aa61c5bab095e",
        "md5": "315155dc9cc9f3bb3ae5017665fb28ff",
        "sha256": "ff43fd3e1c96607fd645cbb9c32132f51e639e4dbbb10f499ca03b9baf1dd1d0"
      },
      "downloads": -1,
      "filename": "corrupted-text-0.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "315155dc9cc9f3bb3ae5017665fb28ff",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 12919,
      "upload_time": "2022-04-20T15:02:47",
      "upload_time_iso_8601": "2022-04-20T15:02:47.385646Z",
      "url": "https://files.pythonhosted.org/packages/35/96/d164116baba2a0190603c59c0a2eaa73b7f76566150ace4aa61c5bab095e/corrupted-text-0.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}