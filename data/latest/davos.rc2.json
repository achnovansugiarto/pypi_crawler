{
  "info": {
    "author": "Paxton Fitzpatrick, Jeremy Manning",
    "author_email": "contextualdynamics@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Operating System :: MacOS",
      "Operating System :: POSIX",
      "Operating System :: Unix",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: System :: Filesystems",
      "Topic :: Utilities",
      "Typing :: Typed"
    ],
    "description": "<div align=\"center\">\n  <h1>davos</h1>\n  <img src=\"https://user-images.githubusercontent.com/26118297/116332586-0c6ce080-a7a0-11eb-94ad-0502c96cf8ef.png\" width=250/>\n  <br>\n  <br>\n  <a href=\"https://github.com/ContextLab/davos/actions/workflows/ci-tests-jupyter.yml\">\n    <img src=\"https://github.com/ContextLab/davos/actions/workflows/ci-tests-jupyter.yml/badge.svg?branch=main\" alt=\"CI Tests (Jupyter)\">\n  </a>\n  <!-- <a href=\"https://github.com/ContextLab/davos/actions/workflows/ci-tests-colab.yml\">\n    <img src=\"https://github.com/ContextLab/davos/actions/workflows/ci-tests-colab.yml/badge.svg?branch=main&event=push\" alt=\"CI Tests (Colab)\">\n  </a> -->\n  <a href=\"https://pypi.org/project/davos/\">\n    <img src=\"https://img.shields.io/pypi/pyversions/davos?logo=python&logoColor=white\" alt=\"Python Versions\">\n  </a>\n  <a href=\"https://pepy.tech/project/davos\">\n    <img src=\"https://static.pepy.tech/personalized-badge/davos?period=total&units=international_system&left_color=grey&right_color=blue&left_text=Downloads\" alt=\"PyPI Downloads\">\n  </a>\n  <br>\n  <a href=\"https://github.com/ContextLab/davos/blob/main/paper/main.pdf\">\n    <img src=\"https://img.shields.io/badge/paper-PDF-9cf\" alt=\"paper (PDF)\">\n  </a>\n  <img src=\"https://img.shields.io/codefactor/grade/github/paxtonfitzpatrick/davos/main?logo=codefactor&logoColor=brightgreen\" alt=\"code quality (CodeFactor)\">\n  <img src=\"https://img.shields.io/badge/mypy-type%20checked-blue\" alt=\"mypy: checked\">\n  <br>\n  <a href=\"https://github.com/ContextLab/davos/blob/main/LICENSE\">\n    <img src=\"https://img.shields.io/github/license/ContextLab/davos\" alt=\"License: MIT\">\n  </a>\n  <br>\n  <br>\n</div>\n\n> _Someone once told me that the night is dark and full of terrors. And tonight I am no knight. Tonight I am Davos the\nsmuggler again. Would that you were an onion._\n<div align=\"right\">\n  &mdash;<a href=\"https://gameofthrones.fandom.com/wiki/Davos_Seaworth\">Ser Davos Seaworth</a>\n  <br>\n  <a href=\"https://en.wikipedia.org/wiki/A_Song_of_Ice_and_Fire\"><i>A Clash of Kings</i></a> by\n  <a href=\"https://en.wikipedia.org/wiki/George_R._R._Martin\">George R. R. Martin</a>\n  <br>\n</div>\n\n# Introduction\n\nThe `davos` library provides Python with an additional keyword: **`smuggle`**.\n\n[The `smuggle` statement](#the-smuggle-statement) works just like the built-in [`import` statement](https://docs.python.org/3/reference/import.html), with two major differences: \n1. You can `smuggle` a package _without installing it first_\n2. You can `smuggle` a _specific version_ of a package\n\n## Why would I want an alternative to `import`?\n\nIn many cases, `smuggle` and `import` do the same thing&mdash;*if you're running code in the same environment you\ndeveloped it in*.  But what if you want to share a [Jupyter notebook](https://jupyter.org/) containing your code with\nsomeone else?  If the user (i.e., the \"someone else\" in this example) doesn't have all of the packages your notebook\nimports, Python will raise an exception and the code won't run.  It's not a huge deal, of course, but it's inconvenient\n(e.g., the user might need to `pip`-install the missing packages, restart their kernel, re-run the code up to the point\nit crashed, etc.&mdash;possibly going through this cycle multiple times until the thing finally runs).  \n\nA second (and more subtle) issue arises when the developer (i.e., the person who *wrote* the code) used or assumed\ndifferent versions of the imported packages than what the user has installed in their environment.  So maybe the\noriginal author was developing and testing their code using `pandas` 1.3.5, but the user hasn't upgraded their `pandas`\ninstallation since 0.25.0.  Python will happily \"`import pandas`\" in both cases, but any changes across those versions\nmight change what the developer's code actually does in the user's (different) environment&mdash;or cause it to fail\naltogether.\n\nThe problem `davos` tries to solve is similar to the idea motivating virtual environments, containers, and virtual\nmachines: we want a way of replicating the original developer's environment on the user's machine, to a sufficiently\ngood approximation that we can be \"reasonably confident\" that the code will continue to behave as expected.\n\nWhen you `smuggle` packages instead of importing them, it guarantees (for whatever environment the code is running in)\nthat the packages are importable, even if they hadn't been installed previously.  Under the hood, `davos` figures out\nwhether the package is available, and if not, it uses `pip` to download and install anything that's missing (including\nmissing dependencies).  From that point, after having automatically handled those sorts of dependency issues, `smuggle`\nbehaves just like `import`.\n\nThe second powerful feature of `davos` comes from another construct, called \"[_onion comments_](#the-onion-comment).\"\nThese are like standard Python comments, but they appear on the same line(s) as `smuggle` statements, and they are\nformatted in a particular way.  Onion comments provide a way of precisely controlling how, when, and where packages are\ninstalled, how (or if) the system checks for existing installations, and so on.  A key feature is the ability to specify\nexactly which version(s) of each package are imported into the current workspace.  When used in this way, `davos`\nenables authors to guarantee that the same versions of the packages they developed their code with will also be imported\ninto the user's workspace at the appropriate times.\n\n## Why not use virtual environments, containers, and/or virtual machines instead?\n\nYou can!  In fact, `davos` works great when used inside of virtual environments, containers, and virtual machines.\nThere are a few specific advantages to `davos`, however:\n  - `davos` is very lightweight&mdash;importing `davos` into a notebook-based environment unlocks all of its\n    functionality without needed to install, set up, and learn how to use additional stuff.  There is none of the\n    typical overhead of setting up a new virtual environment (or container, virtual machine, etc.), installing\n    third-party tools, writing and sharing configuration files, and so on.  All of your code *and its dependencies* may\n    be contained in a single notebook file.\n  - using onion comments, `davos` can enable mutliple versions of the same package to be used or specified in different\n    parts of the same notebook.  Want to use some deprecated or removed function in `scikit-learn` in one cell, but then\n    use one of the latest features in another?  You can!  Just add onion comments specifying which versions of the\n    package you want to `smuggle` in which cells of your notebook.\n\n## Okay... so how do I use this thing?\n\nTo turn a standard [Jupyter (IPython) notebook](https://jupyter.org/), including a [Google Colaboratory notebook](https://colab.research.google.com), into a `davos`-enhanced notebook, just add two lines to the first cell:\n```python\n%pip install davos\nimport davos\n```\n\nThis will enable the `smuggle` keyword in your notebook environment.  Then you can do things like:\n\n```python\n# pip-install numpy v1.20.2, if needed\nsmuggle numpy as np    # pip: numpy==1.20.2\n\n# the smuggled package is fully imported and usable\narr = np.arange(15).reshape(3, 5)\n\n# and the onion comment guarantees the desired version!\nassert np.__version__ == '1.20.2'\n```\n\nInterested?  Curious? Intrigued?  Check out the table of contents for more details!  You may also want to check out our [paper](paper/main.pdf) for more formal descriptions and explanations.\n\n## Table of contents\n- [Table of contents](#table-of-contents)\n- [Installation](#installation)\n  - [Latest Stable PyPI Release](#latest-stable-pypi-release)\n  - [Latest GitHub Update](#latest-github-update)\n  - [Installing in Colaboratory](#installing-in-colaboratory)\n- [Overview](#overview)\n  - [Smuggling Missing Packages](#smuggling-missing-packages)\n  - [Smuggling Specific Package Versions](#smuggling-specific-package-versions)\n  - [Use Cases](#use-cases)\n    - [Simplify sharing reproducible code & Python environments](#simplify-sharing-reproducible-code--python-environments)\n    - [Guarantee your code always uses the latest version, release, or revision](#guarantee-your-code-always-uses-the-latest-version-release-or-revision)\n    - [Compare behavior across package versions](#compare-behavior-across-package-versions)\n- [Usage](#usage)\n  - [The `smuggle` Statement](#the-smuggle-statement)\n    - [Syntax](#smuggle-statement-syntax)\n    - [Rules](#smuggle-statement-rules)\n  - [The Onion Comment](#the-onion-comment)\n    - [Syntax](#onion-comment-syntax)\n    - [Rules](#onion-comment-rules)\n  - [The `davos` Config](#the-davos-config)\n    - [Reference](#config-reference)\n    - [Top-level Functions](#top-level-functions)\n- [How It Works: The `davos` Parser](#how-it-works-the-davos-parser)\n- [Additional Notes](#additional-notes)\n\n\n## Installation\n### Latest Stable PyPI Release\n[![](https://img.shields.io/pypi/v/davos?label=PyPI&logo=pypi)](https://pypi.org/project/davos/)\n[![](https://img.shields.io/pypi/status/davos)]((https://pypi.org/project/davos/))\n[![](https://img.shields.io/pypi/format/davos)]((https://pypi.org/project/davos/))\n```sh\npip install davos\n```\n\n\n### Latest GitHub Update\n[![](https://img.shields.io/github/commits-since/ContextLab/davos/latest)](https://github.com/ContextLab/davos/releases)\n[![](https://img.shields.io/github/last-commit/ContextLab/davos?logo=git&logoColor=white)](https://github.com/ContextLab/davos/commits/main)\n[![](https://img.shields.io/github/release-date/ContextLab/davos?label=last%20release)](https://github.com/ContextLab/davos/releases/latest)\n\n```sh\npip install git+https://github.com/ContextLab/davos.git\n```\n\n\n### Installing in Colaboratory\nTo use `davos` in [Google Colab](https://colab.research.google.com/), add a cell at the top of your notebook with an\npercentage sign (`%`) followed by one of the commands above (e.g., `%pip install davos`). Run the cell to install\n`davos` on the runtime virtual machine.\n\n**Note**: restarting the Colab runtime does not affect installed packages. However, if the runtime is \"factory reset\"\nor disconnected due to reaching its idle timeout limit, you'll need to rerun the cell to reinstall `davos` on the fresh\nVM instance.\n\n\n## Overview\nThe primary way to use `davos` is via [the `smuggle` statement](#the-smuggle-statement), which is made available\nsimply by running `import davos`. Like\n[the built-in `import` statement](https://docs.python.org/3/reference/import.html), the `smuggle` statement is used to\nload packages, modules, and other objects into the current namespace. The main difference between the two is in how\nthey handle missing packages and specific package versions.\n\n\n### Smuggling Missing Packages\n`import` requires that packages be installed _before_ the start of the interpreter session. Trying to `import` a package\nthat can't be found locally will throw a\n[`ModuleNotFoundError`](https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError), and you'll have to\ninstall the package from the command line, restart the Python interpreter to make the new package importable, and rerun\nyour code in full in order to use it.\n\n**The `smuggle` statement, however, can handle missing packages on the fly**. If you `smuggle` a package that isn't\ninstalled locally, `davos` will install it for you, make its contents available to Python's\n[import machinery](https://docs.python.org/3/reference/import.html), and load it into the namespace for immediate use.\nYou can control _how_ `davos` installs missing packages by adding a special type of inline comment called an\n[\"onion\" comment](#the-onion-comment) next to a `smuggle` statement.\n\n\n### Smuggling Specific Package Versions\nOne simple but powerful use for [onion comments](#the-onion-comment) is making `smuggle` statements _version-sensitive_.\n\nPython doesn't provide a native, viable way to ensure a third-party package imported at runtime matches a specific\nversion or satisfies a particular [version constraint](https://www.python.org/dev/peps/pep-0440/#version-specifiers).\nMany packages expose their version info via a top-level `__version__` attribute (see\n[PEP 396](https://www.python.org/dev/peps/pep-0396/)), and certain tools (such as the standard library's\n[`importlib.metadata`](https://docs.python.org/3/library/importlib.metadata.html) and\n[`setuptools`](https://setuptools.readthedocs.io/en/latest/index.html)'s\n[`pkg_resources`](https://setuptools.readthedocs.io/en/latest/pkg_resources.html)) attempt to parse version info from\ninstalled distributions. However, using these to constrain imported package would require writing extra code to compare\nversion strings and _still_ manually installing the desired version and restarting the interpreter any time an\ninvalid version is caught.\n\nAdditionally, for packages installed through a version control system (e.g., [git](https://git-scm.com/)), this would be\ninsensitive to differences between revisions (e.g., commits) within the same semantic version.\n\n**`davos` solves these issues** by allowing you to specify a specific version or set of acceptable versions for each\nsmuggled package. To do this, simply provide a\n[version specifier](https://www.python.org/dev/peps/pep-0440/#version-specifiers) in an\n[onion comment](#the-onion-comment) next to the `smuggle` statement:\n```python\nsmuggle numpy as np              # pip: numpy==1.20.2\nfrom pandas smuggle DataFrame    # pip: pandas>=0.23,<1.0\n```\nIn this example, the first line will load [`numpy`](https://numpy.org/) into the local namespace under the alias \"`np`\",\njust as \"`import numpy as np`\" would. First, `davos` will check whether `numpy` is installed locally, and if so, whether\nthe installed version _exactly_ matches `1.20.2`. If `numpy` is not installed, or the installed version is anything\nother than `1.20.2`, `davos` will use the specified _installer program_, [`pip`](https://pip.pypa.io/en/stable/), to\ninstall `numpy==1.20.2` before loading the package.\n\nSimilarly, the second line will load the \"`DataFrame`\" object from the [`pandas`](https://pandas.pydata.org/) library,\nanalogously to \"`from pandas import DataFrame`\". A local `pandas` version of `0.24.1` would be used, but a local version\nof `1.0.2` would cause `davos` to replace it with a valid `pandas` version, as if you had manually run `pip install\npandas>=0.23,<1.0`.\n\nIn both cases, the imported versions will fit the constraints specified in their [onion comments](#the-onion-comment),\nand the next time `numpy` or `pandas` is smuggled with the same constraints, valid local installations will be found.\n\nYou can also force the state of a smuggled packages to match a specific VCS ref (branch, revision, tag, release, etc.).\nFor example:\n```python\nsmuggle hypertools as hyp    # pip: git+https://github.com/ContextLab/hypertools.git@98a3d80\n```\nwill load [`hypertools`](https://hypertools.readthedocs.io/en/latest/) (aliased as \"`hyp`\"), as the package existed\n[on GitHub](https://github.com/ContextLab/hypertools), at commit\n[98a3d80](https://github.com/ContextLab/hypertools/tree/98a3d80). The general format for VCS references in\n[onion comments](#the-onion-comment) follows that of the\n[`pip-install`](https://pip.pypa.io/en/stable/topics/vcs-support) command. See the\n[notes on smuggling from VCS](#notes-vcs-smuggle) below for additional info.\n\nAnd with [a few exceptions](#notes-c-extensions), smuggling a specific package version will work _even if the package\nhas already been imported_!\n\n**Note**: `davos` v0.1 supports [IPython](https://ipython.readthedocs.io/en/stable/) environments  (e.g.,\n[Jupyter](https://jupyter.org/) and [Colaboratory](https://colab.research.google.com/) notebooks) only. v0.2 will add\nsupport for \"regular\" (i.e., non-interactive) Python scripts.\n\n\n### Use Cases\n#### Simplify sharing reproducible code & Python environments\nDifferent versions of the same package can often behave quite differently&mdash;bugs are introduced and fixed, features\nare implemented and removed, support for Python versions is added and dropped, etc. Because of this, Python code that is\nmeant to be _reproducible_ (e.g., tutorials, demos, data analyses) is commonly shared alongside a set of fixed versions\nfor each package used. And since there is no Python-native way to specify package versions at runtime (see\n[above](#smuggling-specific-package-versions)), this typically takes the form of a pre-configured development\nenvironment the end user must build themselves (e.g., a [Docker](https://www.docker.com/) container or\n[conda](https://docs.conda.io/en/latest/) environment), which can be cumbersome, slow to set up, resource-intensive, and\nconfusing for newer users, as well as require shipping both additional specification files _and_ setup instructions\nalong with your code. And even then, a well-intentioned user may alter the environment in a way that affects your\ncarefully curated set of pinned packages (such as installing additional packages that trigger dependency updates).\n\nInstead, `davos` allows you to share code with one simple instruction: _just `pip install davos`!_ Replace your `import`\nstatements with `smuggle` statements, pin package versions in onion comments, and let `davos` take care of the rest.\nBeyond its simplicity, this approach ensures your predetermined package versions are in place every time your code is\nrun.\n\n\n#### Guarantee your code always uses the latest version, release, or revision\nIf you want to make sure you're always using the most recent release of a certain package, `davos` makes doing so easy:\n```python\nsmuggle mypkg    # pip: mypkg --upgrade\n```\nOr if you have an automation designed to test your most recent commit on GitHub:\n```python\nsmuggle mypkg    # pip: git+https://username/reponame.git\n```\n\n\n#### Compare behavior across package versions\nThe ability to `smuggle` a specific package version even after a different version has been imported makes `davos` a\nuseful tool for comparing behavior across multiple versions of the same package, within the same interpreter session:\n```python\ndef test_my_func_unchanged():\n    \"\"\"Regression test for `mypkg.my_func()`\"\"\"\n    data = list(range(10))\n\n    smuggle mypkg                    # pip: mypkg==0.1\n    result1 = mypkg.my_func(data)\n\n    smuggle mypkg                    # pip: mypkg==0.2\n    result2 = mypkg.my_func(data)\n\n    smuggle mypkg                    # pip: git+https://github.com/MyOrg/mypkg.git\n    result3 = mypkg.my_func(data)\n\n    assert result1 == result2 == result3\n```\n\n\n## Usage\n### The `smuggle` Statement\n#### <a name=\"smuggle-statement-syntax\"></a>Syntax\nThe `smuggle` statement is meant to be used in place of\n[the built-in `import` statement](https://docs.python.org/3/reference/import.html) and shares\n[its full syntactic definition](https://docs.python.org/3/reference/simple_stmts.html#the-import-statement):\n```ebnf\nsmuggle_stmt    ::=  \"smuggle\" module [\"as\" identifier] (\",\" module [\"as\" identifier])*\n                     | \"from\" relative_module \"smuggle\" identifier [\"as\" identifier]\n                     (\",\" identifier [\"as\" identifier])*\n                     | \"from\" relative_module \"smuggle\" \"(\" identifier [\"as\" identifier]\n                     (\",\" identifier [\"as\" identifier])* [\",\"] \")\"\n                     | \"from\" module \"smuggle\" \"*\"\nmodule          ::=  (identifier \".\")* identifier\nrelative_module ::=  \".\"* module | \".\"+\n```\n<sup>\n  <i>\n    NB: uses the modified BNF grammar notation described in\n    <a href=\"https://docs.python.org/3/reference\">The Python Language Reference</a>,\n    <a href=\"https://docs.python.org/3/reference/introduction.html#notation\">here</a>; see\n    <a href=\"https://docs.python.org/3/reference/lexical_analysis.html#identifiers\">here</a> for the lexical definition\n    of <code>identifier</code>\n  </i>\n</sup>\n\n\nIn simpler terms, **any valid syntax for `import` is also valid for `smuggle`**.\n\n\n#### <a name=\"smuggle-statement-rules\"></a>Rules\n- Like `import` statements, `smuggle` statements are whitespace-insensitive, unless a lack of whitespace between two\n  tokens would cause them to be interpreted as a different token:\n  ```python\n  from os.path smuggle dirname, join as opj                       # valid\n  from   os   . path   smuggle  dirname    ,join      as   opj    # also valid\n  from os.path smuggle dirname, join asopj                        # invalid (\"asopj\" != \"as opj\")\n  ```\n- Any context that would cause an `import` statement _not_ to be executed will have the same effect on a `smuggle`\n  statement:\n  ```python\n  # smuggle matplotlib.pyplot as plt           # not executed\n  print('smuggle matplotlib.pyplot as plt')    # not executed\n  foo = \"\"\"\n  smuggle matplotlib.pyplot as plt\"\"\"          # not executed\n  ```\n- Because the `davos` parser is less complex than the full Python parser, there are two fairly non-disruptive edge\n  cases where an `import` statement would be syntactically valid but a `smuggle` statement would not:\n  1. The [exec](https://docs.python.org/3.8/library/functions.html#exec) function\n     ```python\n     exec('from pathlib import Path')         # executed\n     exec('from pathlib smuggle Path')        # raises SyntaxError\n     ```\n  2. A one-line [compound statement](https://docs.python.org/3.9/reference/compound_stmts.html#compound-statements)\n     clause:\n     ```python\n     if True: import random                   # executed\n     if True: smuggle random                  # raises SyntaxError\n\n     while True: import math; break           # executed\n     while True: smuggle math; break          # raises SyntaxError\n\n     for _ in range(1): import json           # executed\n     for _ in range(1): smuggle json          # raises SyntaxError\n\n     # etc...\n     ```\n- In [IPython](https://ipython.readthedocs.io/en/stable/) environments (e.g., [Jupyter](https://jupyter.org/) &\n  [Colaboratory](https://colab.research.google.com/) notebooks) `smuggle` statements always load names into the global\n  namespace:\n  ```python\n  # example.ipynb\n  import davos\n\n\n  def import_example():\n      import datetime\n\n\n  def smuggle_example():\n      smuggle datetime\n\n\n  import_example()\n  type(datetime)                               # raises NameError\n\n  smuggle_example()\n  type(datetime)                               # returns\n  ```\n\n\n### The Onion Comment\nAn _onion comment_ is a special type of inline comment placed on a line containing a `smuggle` statement. Onion comments\ncan be used to control how `davos`:\n1. determines whether the smuggled package should be installed\n2. installs the smuggled package, if necessary\n\nOnion comments are also useful when smuggling a package whose _distribution name_ (i.e., the name\nused when installing it) is different from its _top-level module name_ (i.e., the name used when importing it). Take for\nexample:\n```python\nfrom sklearn.decomposition smuggle pca    # pip: scikit-learn\n```\nThe onion comment here (`# pip: scikit-learn`) tells `davos` that if \"`sklearn`\" does not exist\nlocally, the \"`scikit-learn`\" package should be installed.\n\n#### <a name=\"onion-comment-syntax\"></a>Syntax\nOnion comments follow a simple but specific syntax, inspired in part by the\n[type comment syntax](https://www.python.org/dev/peps/pep-0484/#type-comments) introduced in\n[PEP 484](https://www.python.org/dev/peps/pep-0484). The following is a loose (pseudo-)syntactic definition for an onion\ncomment:\n```ebnf\nonion_comment   ::=  \"#\" installer \":\" install_opt* pkg_spec install_opt*\ninstaller       ::=  (\"pip\" | \"conda\")\npkg_spec        ::=  identifier [version_spec]\n```\n<sup>\n  <i>\n    NB: uses the modified BNF grammar notation described in\n    <a href=\"https://docs.python.org/3/reference\">The Python Language Reference</a>,\n    <a href=\"https://docs.python.org/3/reference/introduction.html#notation\">here</a>; see\n    <a href=\"https://docs.python.org/3/reference/lexical_analysis.html#identifiers\">here</a> for the lexical definition\n    of <code>identifier</code>\n  </i>\n</sup>\n\nwhere `installer` is the program used to install the package; `install_opt` is any option accepted by the installer's\n\"`install`\" command; and `version_spec` may be a\n[version specifier](https://www.python.org/dev/peps/pep-0440/#version-specifiers) defined by\n[PEP 440](https://www.python.org/dev/peps/pep-0440) followed by a\n[version string](https://www.python.org/dev/peps/pep-0440/#public-version-identifiers), or an alternative syntax valid\nfor the given `installer` program. For example, [`pip`](https://pip.pypa.io/en/stable/) uses specific syntaxes for\n[local](https://pip.pypa.io/en/stable/cli/pip_install/#local-project-installs),\n[editable](https://pip.pypa.io/en/stable/cli/pip_install/#editable-installs), and\n[VCS-based](https://pip.pypa.io/en/stable/topics/vcs-support) installation.\n\nLess formally, **an onion comment simply consists of two parts, separated by a colon**:\n1. the name of the installer program (e.g., [`pip`](https://pip.pypa.io/en/stable/))\n2. arguments passed to the program's \"install\" command\n\nThus, you can essentially think of writing an onion comment as taking the full shell command you would run to install\nthe package, and replacing \"_install_\" with \"_:_\". For instance, the command:\n```sh\npip install -I --no-cache-dir numpy==1.20.2 -vvv --timeout 30\n```\nis easily translated into an onion comment as:\n```python\nsmuggle numpy    # pip: -I --no-cache-dir numpy==1.20.2 -vvv --timeout 30\n```\n\nIn practice, onion comments are identified as matches for the\n[regular expression](https://en.wikipedia.org/wiki/Regular_expression):\n```regex\n#+ *(?:pip|conda) *: *[^#\\n ].+?(?= +#| *\\n| *$)\n```\n<sup>\n  <i>\n    NB: support for installing <code>smuggle</code>d packages via\n    <a href=\"https://docs.conda.io/en/latest/\"><code>conda</code></a> will be added in v0.2. For v0.1,\n    \"<code>pip</code>\" should be used exclusively.\n  </i>\n</sup>\n\n**Note**: support for installing smuggled packages via the [`conda`](https://docs.conda.io/en/latest/) package manager\nwill be added in v0.2. For v0.1, onion comments should always specify \"`pip`\" as the `installer` program.\n\n\n#### <a name=\"onion-comment-rules\"></a>Rules\n- An onion comment must be placed on the same line as a `smuggle` statement; otherwise, it is not parsed:\n  ```python\n  # assuming the dateutil package is not installed...\n\n  # pip: python-dateutil                       # <-- has no effect\n  smuggle dateutil                             # raises InstallerError (no \"dateutil\" package exists)\n\n  smuggle dateutil                             # raises InstallerError (no \"dateutil\" package exists)\n  # pip: python-dateutil                       # <-- has no effect\n\n  smuggle dateutil    # pip: python-dateutil   # installs \"python-dateutil\" package, if necessary\n  ```\n- An onion comment may be followed by unrelated inline comments as long as they are separated by at least one space:\n  ```python\n  smuggle tqdm    # pip: tqdm>=4.46,<4.60 # this comment is ignored\n  smuggle tqdm    # pip: tqdm>=4.46,<4.60            # so is this one\n  smuggle tqdm    # pip: tqdm>=4.46,<4.60# but this comment raises OnionArgumentError\n  ```\n- An onion comment must be the first inline comment immediately following a `smuggle` statement; otherwise, it is not\n  parsed:\n  ```python\n  smuggle numpy    # pip: numpy!=1.19.1        # <-- guarantees smuggled version is *not* v1.19.1\n  smuggle numpy    # has no effect -->         # pip: numpy==1.19.1\n  ```\n  This also allows you to easily \"comment out\" onion comments:\n  ```python\n  smuggle numpy    ## pip: numpy!=1.19.1       # <-- has no effect\n  ```\n- Onion comments are generally whitespace-insensitive, but installer arguments must be separated by at least one space:\n  ```python\n  from umap smuggle UMAP    # pip: umap-learn --user -v --no-clean     # valid\n  from umap smuggle UMAP#pip:umap-learn --user     -v    --no-clean    # also valid\n  from umap smuggle UMAP    # pip: umap-learn --user-v--no-clean       # raises OnionArgumentError\n  ```\n- Onion comments have no effect on standard library modules:\n  ```python\n  smuggle threading    # pip: threading==9999  # <-- has no effect\n  ```\n- When smuggling multiple packages with a _single_ `smuggle` statement, an onion comment may be used to refer to the\n  **first** package listed:\n  ```python\n  smuggle nilearn, nibabel, nltools    # pip: nilearn==0.7.1\n  ```\n- If multiple _separate_ `smuggle` statements are placed on a single line, an onion comment may be used to refer to the\n  **last** statement:\n  ```python\n  smuggle gensim; smuggle spacy; smuggle nltk    # pip: nltk~=3.5 --pre\n  ```\n- For multiline `smuggle` statements, an onion comment may be placed on the first line:\n  ```python\n  from scipy.interpolate smuggle (    # pip: scipy==1.6.3\n      interp1d,\n      interpn as interp_ndgrid,\n      LinearNDInterpolator,\n      NearestNDInterpolator,\n  )\n  ```\n  ... or on the last line:\n  ```python\n  from scipy.interpolate smuggle (interp1d,                  # this comment has no effect\n                                  interpn as interp_ndgrid,\n                                  LinearNDInterpolator,\n                                  NearestNDInterpolator)     # pip: scipy==1.6.3\n  ```\n  ... though the first line takes priority:\n  ```python\n  from scipy.interpolate smuggle (    # pip: scipy==1.6.3    # <-- this version is installed\n      interp1d,\n      interpn as interp_ndgrid,\n      LinearNDInterpolator,\n      NearestNDInterpolator,\n  )    # pip: scipy==1.6.2                                   # <-- this comment is ignored\n  ```\n  ... and all comments _not_ on the first or last line are ignored:\n  ```python\n  from scipy.interpolate smuggle (\n      interp1d,                       # pip: scipy==1.6.3    # <-- ignored\n      interpn as interp_ndgrid,\n      LinearNDInterpolator,           # unrelated comment    # <-- ignored\n      NearestNDInterpolator\n  )                                   # pip: scipy==1.6.2    # <-- parsed\n  ```\n- The onion comment is intended to describe how a specific smuggled package should be installed if it is not found\n  locally, in order to make it available for immediate use. Therefore, installer options that either (A) install\n  packages other than the smuggled package and its dependencies (e.g., from a specification file), or (B) cause the\n  smuggled package not to be installed, are disallowed. The options listed below will raise an `OnionArgumentError`:\n  - `-h`, `--help`\n  - `-r`, `--requirement`\n  - `-V`, `--version`\n\n\n### The `davos` Config\nThe `davos` config object stores options and data that affect how `davos` behaves. After importing `davos`, the config\ninstance (a singleton) for the current session is available as `davos.config`, and its various fields are accessible as\nattributes. The config object exposes a mixture of writable and read-only fields. Most `davos.config` attributes can be\nassigned values to control aspects of `davos` behavior, while others are available for inspection but are set and used\ninternally. Additionally, certain config fields may be writable in some situations but not others (e.g. only if the\nimporting environment supports a particular feature). Once set, `davos` config options last for the lifetime of the\ninterpreter (unless updated); however, they do *not* persist across interpreter sessions. A full list of `davos` config\nfields is available [below](#config-reference):\n\n#### <a name=\"config-reference\"></a>Reference\n| Field | Description | Type | Default | Writable? |\n| :---: | --- | :---: | :---: | :---: |\n| `active` | Whether or not the `davos` parser should be run on subsequent input (cells, in Jupyter/Colab notebooks). Setting to `True` activates the `davos` parser, enables the `smuggle` keyword, and injects the `smuggle()` function into the user namespace. Setting to `False` deactivates the `davos` parser, disables the `smuggle` keyword, and removes \"`smuggle`\" from the user namespace (if it holds a reference to the `smuggle()` function). See [How it Works](#how-it-works) for more info. | `bool` | `True` | ✅ |\n| `auto_rerun` | If `True`, when smuggling a previously-imported package that cannot be reloaded (see [Smuggling packages with C-extensions](#notes-c-extensions)), `davos` will automatically restart the interpreter and rerun all code up to (and including) the current `smuggle` statement. Otherwise, issues a warning and prompts the user with buttons to either restart/rerun or continue running. | `bool` | `False` | ✅ (**Jupyter notebooks only**) |\n| `confirm_install` | Whether or not `davos` should require user confirmation (`[y/n]` input) before installing a smuggled package | `bool` | `False` | ✅ |\n| `environment` | A label describing the environment into which `davos` was running. Checked internally to determine which interchangeable implementation functions are used, whether certain config fields are writable, and various other behaviors | `Literal['Python', 'IPython<7.0', 'IPython>=7.0', 'Colaboratory']` | N/A | ❌ |\n| `ipython_shell` | The global IPython interactive shell instance | [`IPython.core`<br>`.interactiveshell`<br>`.InteractiveShell`](https://ipython.readthedocs.io/en/stable/api/generated/IPython.core.interactiveshell.html#IPython.core.interactiveshell.InteractiveShell) | N/A | ❌ |\n| `noninteractive` | Set to `True` to run `davos` in non-interactive mode (all user input and confirmation will be disabled). **NB**:<br>1. Setting to `True` disables `confirm_install` if previously enabled <br>2. If `auto_rerun` is `False` in non-interactive mode, `davos` will throw an error if a smuggled package cannot be reloaded | `bool` | `False` | ✅ (**Jupyter notebooks only**) |\n| `pip_executable` | The path to the `pip` executable used to install smuggled packages. Must be a path (`str` or [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path)) to a real file. Default is programmatically determined from Python environment; falls back to `sys.executable -m pip` if executable can't be found | `str` | `pip` exe path or `sys.executable -m pip` | ✅ |\n| `smuggled` | A cache of packages smuggled during the current interpreter session. Formatted as a `dict` whose keys are package names and values are the (`.split()` and `';'.join()`ed) onion comments. Implemented this way so that any non-whitespace change to installer arguments  re-installation | `dict[str, str]` | `{}` | ❌ |\n| `suppress_stdout` | If `True`, suppress all unnecessary output issued by both `davos` and the installer program. Useful when smuggling packages that need to install many dependencies and therefore generate extensive output. If the installer program throws an error while output is suppressed, both stdout & stderr will be shown with the traceback | `bool` | `False` | ✅ |\n\n#### <a name=\"top-level-functions\"></a>Top-level Functions\n`davos` also provides a few convenience for reading/setting config values:\n- **`davos.activate()`**\n  Activate the `davos` parser, enable the `smuggle` keyword, and inject the `smuggle()` function into the namespace.\n  Equivalent to setting `davos.config.active = True`. See [How it Works](#how-it-works) for more info.\n\n- **`davos.deactivate()`**\n  Deactivate the `davos` parser, disable the `smuggle` keyword, and remove the name `smuggle` from the namespace if (and\n  only if) it refers to the `smuggle()` function. If `smuggle` has been overwritten with a different value, the variable\n  will not be deleted. Equivalent to setting `davos.config.active = False`. See [How it Works](#how-it-works) for more\n- info.\n\n- **`davos.is_active()`**\n  Return the current value of `davos.config.active`.\n\n- **`davos.configure(**kwargs)`**\n  Set multiple `davos.config` fields at once by passing values as keyword arguments, e.g.:\n  ```python\n  import davos\n  davos.configure(active=False, noninteractive=True, pip_executable='/usr/bin/pip3')\n  ```\n  is equivalent to:\n  ```python\n  import davos\n  davos.active = False\n  davos.noninteractive = True\n  davos.pip_executable = '/usr/bin/pip3'\n  ```\n\n## How It Works: The `davos` Parser\nFunctionally, importing `davos` appears to enable a new Python keyword, \"_`smuggle`_\". However, `davos` doesn't actually\nmodify the rules or [reserved keywords](https://docs.python.org/3/reference/lexical_analysis.html#keywords) used by\nPython's parser and lexical analyzer in order to do so&mdash;in fact, modifying the Python grammar is not possible at\nruntime and would require rebuilding the interpreter. Instead, in [IPython](https://ipython.readthedocs.io/en/stable/)\nenivonments like [Jupyter](https://jupyter.org/) and\n[Colaboratory](https://colab.research.google.com/notebooks/intro.ipynb) notebooks, `davos` implements the `smuggle`\nkeyword via a combination of namespace injections and its own (far simpler) custom parser.\n\nThe `smuggle` keyword can be enabled and disabled at will by \"activating\" and \"deactivating\" `davos` (see the\n[`davos` Config Reference](config-reference) and [Top-level Functions](#top-level-functions), above). When `davos` is\nimported, it is automatically activated by default. Activating `davos` triggers two things:\n1. The _`smuggle()` function_ is injected into the `IPython` user namespace\n2. The _`davos` parser_ is registered as a\n[custom input transformer](https://ipython.readthedocs.io/en/stable/config/inputtransforms.html)\n\nIPython preprocesses all executed code as plain text before it is sent to the Python parser in order to handle\nspecial constructs like [`%magic`](https://ipython.readthedocs.io/en/stable/interactive/magics.html) and\n[`!shell`](https://ipython.readthedocs.io/en/stable/interactive/reference.html#system-shell-access) commands. `davos`\nhooks into this process to transform `smuggle` statements into syntactically valid Python code. The `davos`\nparser uses [this regular expression](https://github.com/ContextLab/davos/blob/main/davos/core/regexps.py) to match each\nline of code containing a `smuggle` statement (and, optionally, an onion comment), extracts information from its text,\nand replaces it with an analogous call to the _`smuggle()` function_. Thus, even though the code visible to the user may\ncontain `smuggle` statements, e.g.:\n```python\nsmuggle numpy as np    # pip: numpy>1.16,<=1.20 -vv\n```\nthe code that is actually executed by the Python interpreter will not:\n```python\nsmuggle(name=\"numpy\", as_=\"np\", installer=\"pip\", args_str=\"\"\"numpy>1.16,<=1.20 -vv\"\"\", installer_kwargs={'editable': False, 'spec': 'numpy>1.16,<=1.20', 'verbosity': 2})\n```\n\nThe `davos` parser can be deactivated at any time, and doing so triggers the opposite actions of activating it:\n1. The name \"`smuggle`\" is deleted from the `IPython` user namespace, *unless it has been overwritten and no longer\n   refers to the `smuggle()` function*\n2. The `davos` parser input transformer is deregistered.\n\n**Note**: in Jupyter and Colaboratory notebooks, IPython parses and transforms all text in a cell before sending it\nto the kernel for execution. This means that importing or activating `davos` will not make the `smuggle` statement\navailable until the _next_ cell, because all lines in the current cell were transformed before the `davos` parser was\nregistered. However, _deactivating_ `davos` disables the `smuggle` statement immediately&mdash;although the `davos`\nparser will have already replaced all `smuggle` statements with `smuggle()` function calls, removing the function from\nthe namespace causes them to throw `NameError`.\n\n\n## Additional Notes\n- <a name=\"notes-reimplement-cli\"></a>**Reimplementing installer programs' CLI parsers**\n\n  The `davos` parser extracts info from onion comments by passing them to a (slightly modified) reimplementation of\n  their specified installer program's CLI parser. This is somewhat redundant, since the arguments will eventually be\n  re-parsed by the _actual_ installer program if the package needs to be installed. However, it affords a number of\n  advantages, such as:\n  - detecting errors early during the parser phase, before spending any time running code above the line containing the\n    `smuggle` statement\n  - preventing shell injections in onion comments&mdash;e.g., `#pip: --upgrade numpy && rm -rf /` fails due to the\n    `OnionParser`, but would otherwise execute successfully.\n  - allowing certain installer arguments to temporarily influence `davos` behavior while smuggling the current package\n    (see [Installer options that affect `davos` behavior](#notes-installer-opts) below for specific info)\n\n- <a name=\"notes-installer-opts\"></a>**Installer options that affect `davos` behavior**\n\n  Passing certain options to the installer program via an [onion comment](#the-onion-comment) will also affect the\n  corresponding `smuggle` statement in a predictable way:\n\n  - [**`--force-reinstall`**](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-force-reinstall) |\n    [**`-I`, `--ignore-installed`**](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-I) |\n    [**`-U`, `--upgrade`**](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-I)\n\n    The package will be installed, even if it exists locally\n\n  - [**`--no-input`**](https://pip.pypa.io/en/stable/cli/pip/#cmdoption-no-input)\n\n    Disables input prompts, analogous to temporarily setting `davos.config.noninteractive` to `True`. Overrides value\n    of `davos.config.confirm_install`.\n\n  - [**`--src <dir>`**](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-src) |\n    [**`-t`, `--target <dir>`**](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-t)\n\n    Prepends `<dir>` to [`sys.path`](https://docs.python.org/3/library/sys.html#sys.path) if not already present so\n    the package can be imported.\n\n- <a name=\"notes-c-extensions\"></a>**Smuggling packages with C-extensions**\n\n  Some Python packages that rely heavily on custom data types implemented via\n  [C-extensions](https://docs.python.org/3.9/extending/extending.html) (e.g., `numpy`, `pandas`) dynamically generate\n  modules defining various C functions and data structures, and link them to the Python interpreter when they are first\n  imported. Depending on how these objects are initialized, they may not be subject to normal garbage collection, and\n  persist despite their reference count dropping to zero. This can lead to unexpected errors when reloading the Python\n  module that creates them, particularly if their dynamically generated source code has been changed (e.g., because the\n  reloaded package is a newer version).\n\n  This can occasionally affect `davos`'s ability to `smuggle` a new version of a package (or dependency) that was\n  previously imported. To handle this, `davos` first checks each package it installs against\n  [`sys.modules`](https://docs.python.org/3.9/library/sys.html#sys.modules). If a different version has already been\n  loaded by the interpreter, `davos` will attempt to replace it with the requested version. If this fails, `davos` will\n  restore the old package version _in memory_, while replacing it with the new package version _on disk_. This allows\n  subsequent code that uses the non-reloadable module to still execute in most cases, while dependency checks for other\n  packages run against the updated version. Then, depending on the value of `davos.config.auto_rerun`, `davos` will\n  either either automatically restart the interpreter to load the updated package, prompt you to do so, or raise an\n  exception.\n\n- <a name=\"notes-from-reload\"></a>**_`from` ... `import` ..._ statements and reloading modules**\n\n  The Python docs for [`importlib.reload()`](https://docs.python.org/3/library/importlib.html#importlib.reload) include\n  the following caveat:\n  > If a module imports objects from another module using\n  > [`from`](https://docs.python.org/3/reference/simple_stmts.html#from) …\n  > [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) …, calling\n  > [`reload()`](https://docs.python.org/3/library/importlib.html#importlib.reload) for the other module does\n  > not redefine the objects imported from it — one way around this is to re-execute the `from` statement, another is to\n  > use `import` and qualified names (_module.name_) instead.\n\n  The same applies to smuggling packages or modules from which objects have already been loaded. If object _`name`_ from\n  module _`module`_ was loaded using either _`from module import name`_ or _`from module smuggle name`_, subsequently\n  running _`smuggle module    # pip --upgrade`_ will in fact install and load an upgraded version of _`module`_, but the\n  the _`name`_ object will still be that of the old version! To fix this, you can simply run _`from module smuggle\n  name`_ either instead in lieu of or after _`smuggle module`_.\n\n\n- <a name=\"notes-vcs-smuggle\"></a>**Smuggling packages from version control systems**\n\n  The first time during an interpreter session that a given package is installed from a VCS URL, it is assumed not to be\n  present locally, and is therefore freshly installed. `pip` clones non-editable VCS repositories into a temporary\n  directory, runs `setup.py install`, and then immediately deletes them. Since no information is retained about the\n  state of the repository at installation, it is impossible to determine whether an existing package satisfies the state\n  (i.e., branch, tag, commit hash, etc.) requested for smuggled package.\n\n[comment]: <> (- As with _all_ code, you should use caution when running Python code containing `smuggle` statements that was not written by you or someone you know. )\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/ContextLab/davos",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ContextLab/davos",
    "keywords": "import install package module automatic davos smuggle pip conda",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "davos",
    "package_url": "https://pypi.org/project/davos/",
    "platform": null,
    "project_url": "https://pypi.org/project/davos/",
    "project_urls": {
      "Download": "https://github.com/ContextLab/davos",
      "Homepage": "https://github.com/ContextLab/davos"
    },
    "release_url": "https://pypi.org/project/davos/0.1.1/",
    "requires_dist": [
      "packaging",
      "setuptools",
      "google-colab ; extra == 'tests'",
      "IPython (>=5.5.0) ; extra == 'tests'",
      "ipykernel (>=5.0.0) ; extra == 'tests'",
      "mypy (==0.910) ; extra == 'tests'",
      "pytest (==6.2) ; extra == 'tests'",
      "requests ; extra == 'tests'",
      "selenium (>=3.141) ; extra == 'tests'",
      "typing-extensions ; (python_version < \"3.7\") and extra == 'tests'",
      "IPython (>=7.3.0) ; (python_version >= \"3.8\") and extra == 'tests'",
      "IPython (>=7.15) ; (python_version >= \"3.9\") and extra == 'tests'"
    ],
    "requires_python": ">=3.6",
    "summary": "Install and manage Python packages at runtime using the \"smuggle\" statement.",
    "version": "0.1.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15870281,
  "releases": {
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "20220ea446564a7b14954b5181e01a2a28e6a8bd14f1cd54bfa6f2249aabd7a4",
          "md5": "8b1f14b4b72f23b46fea290aaafa3d9f",
          "sha256": "7f32340b9507e1674f9f18d2125ee80616308193e07d2eabebcdd98d314423ef"
        },
        "downloads": -1,
        "filename": "davos-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8b1f14b4b72f23b46fea290aaafa3d9f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 76593,
        "upload_time": "2022-01-21T22:16:43",
        "upload_time_iso_8601": "2022-01-21T22:16:43.387459Z",
        "url": "https://files.pythonhosted.org/packages/20/22/0ea446564a7b14954b5181e01a2a28e6a8bd14f1cd54bfa6f2249aabd7a4/davos-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bc3bcf117ef84e8c6a5d18036c545d3aaa5e1232b1ff729af4905cc0416de899",
          "md5": "18f0fcfd114c028b2899f1e24baf1c31",
          "sha256": "58ffd187bfa04bb358700f61226f606a9d79effc0cc8228a9b413e116594665e"
        },
        "downloads": -1,
        "filename": "davos-0.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "18f0fcfd114c028b2899f1e24baf1c31",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 90512,
        "upload_time": "2022-01-21T22:16:45",
        "upload_time_iso_8601": "2022-01-21T22:16:45.608355Z",
        "url": "https://files.pythonhosted.org/packages/bc/3b/cf117ef84e8c6a5d18036c545d3aaa5e1232b1ff729af4905cc0416de899/davos-0.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dd0226d18ee6205a866687e297c9d6ae45c6ed341c396f8b117054cf1b356d52",
          "md5": "585c6ab20f72047ced9ee7493ed571f3",
          "sha256": "015e11d2fe04c1ad96b1bbfea7e6028a75968f395858ed07af1841c0051922cb"
        },
        "downloads": -1,
        "filename": "davos-0.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "585c6ab20f72047ced9ee7493ed571f3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 78773,
        "upload_time": "2022-11-23T18:36:29",
        "upload_time_iso_8601": "2022-11-23T18:36:29.451055Z",
        "url": "https://files.pythonhosted.org/packages/dd/02/26d18ee6205a866687e297c9d6ae45c6ed341c396f8b117054cf1b356d52/davos-0.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f21fe2983b3ac3992c1f3212a804be2d8676396d26674d8a9904d83d43f28bc7",
          "md5": "e086dfa8186b0eaee41e2ecfefcd9656",
          "sha256": "4a8f4e79799b1f46e63b7b4d1fd4e7ecebbb253d8bde83e6dd47fd1de02cc799"
        },
        "downloads": -1,
        "filename": "davos-0.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e086dfa8186b0eaee41e2ecfefcd9656",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 95476,
        "upload_time": "2022-11-23T18:36:31",
        "upload_time_iso_8601": "2022-11-23T18:36:31.711722Z",
        "url": "https://files.pythonhosted.org/packages/f2/1f/e2983b3ac3992c1f3212a804be2d8676396d26674d8a9904d83d43f28bc7/davos-0.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "dd0226d18ee6205a866687e297c9d6ae45c6ed341c396f8b117054cf1b356d52",
        "md5": "585c6ab20f72047ced9ee7493ed571f3",
        "sha256": "015e11d2fe04c1ad96b1bbfea7e6028a75968f395858ed07af1841c0051922cb"
      },
      "downloads": -1,
      "filename": "davos-0.1.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "585c6ab20f72047ced9ee7493ed571f3",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 78773,
      "upload_time": "2022-11-23T18:36:29",
      "upload_time_iso_8601": "2022-11-23T18:36:29.451055Z",
      "url": "https://files.pythonhosted.org/packages/dd/02/26d18ee6205a866687e297c9d6ae45c6ed341c396f8b117054cf1b356d52/davos-0.1.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f21fe2983b3ac3992c1f3212a804be2d8676396d26674d8a9904d83d43f28bc7",
        "md5": "e086dfa8186b0eaee41e2ecfefcd9656",
        "sha256": "4a8f4e79799b1f46e63b7b4d1fd4e7ecebbb253d8bde83e6dd47fd1de02cc799"
      },
      "downloads": -1,
      "filename": "davos-0.1.1.tar.gz",
      "has_sig": false,
      "md5_digest": "e086dfa8186b0eaee41e2ecfefcd9656",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 95476,
      "upload_time": "2022-11-23T18:36:31",
      "upload_time_iso_8601": "2022-11-23T18:36:31.711722Z",
      "url": "https://files.pythonhosted.org/packages/f2/1f/e2983b3ac3992c1f3212a804be2d8676396d26674d8a9904d83d43f28bc7/davos-0.1.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}