{
  "info": {
    "author": "Matthew Fox <matt@tansen.ca>, Joshua Oreman <oremanj@gmail.com>",
    "author_email": "oremanj@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: Telecommunications Industry",
      "License :: OSI Approved :: MIT License",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: Cython",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 3",
      "Topic :: Security",
      "Topic :: System :: Networking"
    ],
    "description": ".. image:: https://img.shields.io/pypi/v/netfilterqueue.svg\n   :target: https://pypi.org/project/netfilterqueue\n   :alt: Latest PyPI version\n\n.. image:: https://github.com/oremanj/python-netfilterqueue/actions/workflows/ci.yml/badge.svg?branch=master\n   :target: https://github.com/oremanj/python-netfilterqueue/actions?query=branch%3Amaster\n   :alt: Automated test status\n\n==============\nNetfilterQueue\n==============\n\nNetfilterQueue provides access to packets matched by an iptables rule in\nLinux. Packets so matched can be accepted, dropped, altered, reordered,\nor given a mark.\n\nlibnetfilter_queue (the netfilter library, not this module) is part of the\n`Netfilter project <http://netfilter.org/projects/libnetfilter_queue/>`_.\n\nThe current version of NetfilterQueue requires Python 3.6 or later.\nThe last version with support for Python 2.7 was 0.9.0.\n\nExample\n=======\n\nThe following script prints a short description of each packet before accepting\nit. ::\n\n    from netfilterqueue import NetfilterQueue\n\n    def print_and_accept(pkt):\n        print(pkt)\n        pkt.accept()\n\n    nfqueue = NetfilterQueue()\n    nfqueue.bind(1, print_and_accept)\n    try:\n        nfqueue.run()\n    except KeyboardInterrupt:\n        print('')\n\n    nfqueue.unbind()\n\nYou can also make your own socket so that it can be used with gevent, for example. ::\n\n    from netfilterqueue import NetfilterQueue\n    import socket\n\n    def print_and_accept(pkt):\n        print(pkt)\n        pkt.accept()\n\n    nfqueue = NetfilterQueue()\n    nfqueue.bind(1, print_and_accept)\n    s = socket.fromfd(nfqueue.get_fd(), socket.AF_UNIX, socket.SOCK_STREAM)\n    try:\n        nfqueue.run_socket(s)\n    except KeyboardInterrupt:\n        print('')\n\n    s.close()\n    nfqueue.unbind()\n\nTo send packets destined for your LAN to the script, type something like::\n\n    iptables -I INPUT -d 192.168.0.0/24 -j NFQUEUE --queue-num 1\n\nInstallation\n============\n\nNetfilterQueue is a C extention module that links against libnetfilter_queue.\nBefore installing, ensure you have:\n\n1. A C compiler\n\n2. Python development files\n\n3. Libnetfilter_queue development files and associated dependencies\n\nOn Debian or Ubuntu, install these files with::\n\n    apt-get install build-essential python3-dev libnetfilter-queue-dev\n\nFrom PyPI\n---------\n\nTo install from PyPI by pip::\n\n    pip install NetfilterQueue\n\nFrom source\n-----------\n\nTo install from source::\n\n    pip install cython\n    git clone https://github.com/oremanj/python-netfilterqueue\n    cd python-netfilterqueue\n    pip install .\n\nAPI\n===\n\n``NetfilterQueue.COPY_NONE``, ``NetfilterQueue.COPY_META``, ``NetfilterQueue.COPY_PACKET``\n    These constants specify how much of the packet should be given to the\n    script: nothing, metadata, or the whole packet.\n\nNetfilterQueue objects\n----------------------\n\nA NetfilterQueue object represents a single queue. Configure your queue with\na call to ``bind``, then start receiving packets with a call to ``run``.\n\n``NetfilterQueue.bind(queue_num, callback, max_len=1024, mode=COPY_PACKET, range=65535, sock_len=...)``\n    Create and bind to the queue. ``queue_num`` uniquely identifies this\n    queue for the kernel. It must match the ``--queue-num`` in your iptables\n    rule, but there is no ordering requirement: it's fine to either ``bind()``\n    first or set up the iptables rule first.\n    ``callback`` is a function or method that takes one\n    argument, a Packet object (see below). ``max_len`` sets the largest number\n    of packets that can be in the queue; new packets are dropped if the size of\n    the queue reaches this number. ``mode`` determines how much of the packet\n    data is provided to your script. Use the constants above. ``range`` defines\n    how many bytes of the packet you want to get. For example, if you only want\n    the source and destination IPs of a IPv4 packet, ``range`` could be 20.\n    ``sock_len`` sets the receive socket buffer size.\n\n``NetfilterQueue.unbind()``\n    Remove the queue. Packets matched by your iptables rule will be dropped.\n\n``NetfilterQueue.get_fd()``\n    Get the file descriptor of the socket used to receive queued\n    packets and send verdicts. If you're using an async event loop,\n    you can poll this FD for readability and call ``run(False)`` every\n    time data appears on it.\n\n``NetfilterQueue.run(block=True)``\n    Send packets to your callback. By default, this method blocks, running\n    until an exception is raised (such as by Ctrl+C). Set\n    ``block=False`` to process the pending messages without waiting for more;\n    in conjunction with the ``get_fd`` method, you can use this to integrate\n    with async event loops.\n\n``NetfilterQueue.run_socket(socket)``\n    Send packets to your callback, but use the supplied socket instead of\n    recv, so that, for example, gevent can monkeypatch it. You can make a\n    socket with ``socket.fromfd(nfqueue.get_fd(), socket.AF_NETLINK, socket.SOCK_RAW)``\n    and optionally make it non-blocking with ``socket.setblocking(False)``.\n\nPacket objects\n--------------\n\nObjects of this type are passed to your callback.\n\n``Packet.get_payload()``\n    Return the packet's payload as a bytes object. The returned value\n    starts with the IP header. You must call ``retain()`` if you want\n    to be able to ``get_payload()`` after your callback has returned.\n    If you have already called ``set_payload()``, then ``get_payload()``\n    returns what you passed to ``set_payload()``.\n\n``Packet.set_payload(payload)``\n    Set the packet payload. Call this before ``accept()`` if you want to\n    change the contents of the packet before allowing it to be released.\n    Don't forget to update the transport-layer checksum (or clear it,\n    if you're using UDP), or else the recipient is likely to drop the\n    packet. If you're changing the length of the packet, you'll also need\n    to update the IP length, IP header checksum, and probably some\n    transport-level fields (such as UDP length for UDP).\n\n``Packet.get_payload_len()``\n    Return the size of the payload.\n\n``Packet.set_mark(mark)``\n    Give the packet a kernel mark, which can be used in future iptables\n    rules. ``mark`` is a 32-bit number.\n\n``Packet.get_mark()``\n    Get the mark on the packet (either the one you set using\n    ``set_mark()``, or the one it arrived with if you haven't called\n    ``set_mark()``).\n\n``Packet.get_hw()``\n    Return the source hardware address of the packet as a Python\n    bytestring, or ``None`` if the source hardware address was not\n    captured (packets captured by the ``OUTPUT`` or ``PREROUTING``\n    hooks). For example, on Ethernet the result will be a six-byte\n    MAC address. The destination hardware address is not available\n    because it is determined in the kernel only after packet filtering\n    is complete.\n\n``Packet.get_timestamp()``\n    Return the time at which this packet was received by the kernel,\n    as a floating-point Unix timestamp with microsecond precision\n    (comparable to the result of ``time.time()``, for example).\n    Packets captured by the ``OUTPUT`` or ``POSTROUTING`` hooks\n    do not have a timestamp, and ``get_timestamp()`` will return 0.0\n    for them.\n\n``Packet.id``\n    The identifier assigned to this packet by the kernel. Typically\n    the first packet received by your queue starts at 1 and later ones\n    count up from there.\n\n``Packet.hw_protocol``\n    The link-layer protocol for this packet. For example, IPv4 packets\n    on Ethernet would have this set to the EtherType for IPv4, which is\n    ``0x0800``.\n\n``Packet.mark``\n    The mark that had been assigned to this packet when it was enqueued.\n    Unlike the result of ``get_mark()``, this does not change if you call\n    ``set_mark()``.\n\n``Packet.hook``\n    The netfilter hook (iptables chain, roughly) that diverted this packet\n    into our queue. Values 0 through 4 correspond to PREROUTING, INPUT,\n    FORWARD, OUTPUT, and POSTROUTING respectively.\n\n``Packet.indev``, ``Packet.outdev``, ``Packet.physindev``, ``Packet.physoutdev``\n    The interface indices on which the packet arrived (``indev``) or is slated\n    to depart (``outdev``). These are integers, which can be converted to\n    names like \"eth0\" by using ``socket.if_indextoname()``. Zero means\n    no interface is applicable, either because the packet was locally generated\n    or locally received, or because the interface information wasn't available\n    when the packet was queued (for example, ``PREROUTING`` rules don't yet\n    know the ``outdev``). If the ``indev`` or ``outdev`` refers to a bridge\n    device, then the corresponding ``physindev`` or ``physoutdev`` will name\n    the bridge member on which the actual traffic occurred; otherwise\n    ``physindev`` and ``physoutdev`` will be zero.\n\n``Packet.retain()``\n    Allocate a copy of the packet payload for use after the callback\n    has returned. ``get_payload()`` will raise an exception at that\n    point if you didn't call ``retain()``.\n\n``Packet.accept()``\n    Accept the packet. You can reorder packets by accepting them\n    in a different order than the order in which they were passed\n    to your callback.\n\n``Packet.drop()``\n    Drop the packet.\n\n``Packet.repeat()``\n    Restart processing of this packet from the beginning of its\n    Netfilter hook (iptables chain, roughly). Any changes made\n    using ``set_payload()`` or ``set_mark()`` are preserved; in the\n    absence of such changes, the packet will probably come right\n    back to the same queue.\n\nCallback objects\n----------------\n\nYour callback can be any one-argument callable and will be invoked with\na ``Packet`` object as argument. You must call ``retain()`` within the\ncallback if you want to be able to ``get_payload()`` after the callback\nhas returned. You can hang onto ``Packet`` objects and resolve them later,\nbut note that packets continue to count against the queue size limit\nuntil they've been given a verdict (accept, drop, or repeat). Also, the\nkernel stores the enqueued packets in a linked list, so keeping lots of packets\noutstanding is likely to adversely impact performance.\n\nMonitoring a different network namespace\n----------------------------------------\n\nIf you are using Linux network namespaces (``man 7\nnetwork_namespaces``) in some kind of containerization system, all of\nthe Netfilter queue state is kept per-namespace; queue 1 in namespace\nX is not the same as queue 1 in namespace Y. NetfilterQueue will\nordinarily pass you the traffic for the network namespace you're a\npart of. If you want to monitor a different one, you can do so with a\nbit of trickery and cooperation from a process in that\nnamespace; this section describes how.\n\nYou'll need to arrange for a process in the network namespace you want\nto monitor to call ``socket(AF_NETLINK, SOCK_RAW, 12)`` and pass you\nthe resulting file descriptor using something like\n``socket.send_fds()`` over a Unix domain socket. (12 is\n``NETLINK_NETFILTER``, a constant which is not exposed by the Python\n``socket`` module.)  Once you've received that file descriptor in your\nprocess, you can create a NetfilterQueue object using the special\nconstructor ``NetfilterQueue(sockfd=N)`` where N is the file\ndescriptor you received. Because the socket was originally created\nin the other network namespace, the kernel treats it as part of that\nnamespace, and you can use it to access that namespace even though it's\nnot the namespace you're in yourself.\n\nUsage\n=====\n\nTo send packets to the queue::\n\n    iptables -I <table or chain> <match specification> -j NFQUEUE --queue-num <queue number>\n\nFor example::\n\n    iptables -I INPUT -d 192.168.0.0/24 -j NFQUEUE --queue-num 1\n\nThe only special part of the rule is the target. Rules can have any match and\ncan be added to any table or chain.\n\nValid queue numbers are integers from 0 to 65,535 inclusive.\n\nTo view libnetfilter_queue stats, refer to /proc/net/netfilter/nfnetlink_queue::\n\n    cat /proc/net/netfilter/nfnetlink_queue\n    1  31621     0 2  4016     0     0        2  1\n\nThe fields are:\n\n1. Queue ID\n\n2. Bound process ID\n\n3. Number of currently queued packets\n\n4. Copy mode\n\n5. Copy size\n\n6. Number of packets dropped due to reaching max queue size\n\n7. Number of packets dropped due to netlink socket failure\n\n8. Total number of packets sent to queue\n\n9. Something for libnetfilter_queue's internal use\n\nLimitations\n===========\n\n* We use a fixed-size 4096-byte buffer for packets, so you are likely\n  to see truncation on loopback and on Ethernet with jumbo packets.\n  If this is a problem, either lower the MTU on your loopback, disable\n  jumbo packets, or get Cython, change ``DEF BufferSize = 4096`` in\n  ``netfilterqueue.pyx``, and rebuild.\n\n* Not all information available from libnetfilter_queue is exposed:\n  missing pieces include packet input/output network interface names,\n  checksum offload flags, UID/GID and security context data\n  associated with the packet (if any).\n\n* Not all information available from the kernel is even processed by\n  libnetfilter_queue: missing pieces include additional link-layer\n  header data for some packets (including VLAN tags), connection-tracking\n  state, and incoming packet length (if truncated for queueing).\n\n* We do not expose the libnetfilter_queue interface for changing queue flags.\n  Most of these pertain to other features we don't support (listed above),\n  but there's one that could set the queue to accept (rather than dropping)\n  packets received when it's full.\n\nSource\n======\n\nhttps://github.com/oremanj/python-netfilterqueue\n\nAuthorship\n==========\n\npython-netfilterqueue was originally written by Matthew Fox of\nKerkhoff Technologies, Inc. Since 2022 it has been maintained by\nJoshua Oreman of Hudson River Trading LLC. Both authors wish to\nthank their employers for their support of open source.\n\nLicense\n=======\n\nCopyright (c) 2011, Kerkhoff Technologies, Inc, and contributors.\n\n`MIT licensed <https://github.com/kti/python-netfilterqueue/blob/master/LICENSE.txt>`_",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/oremanj/python-netfilterqueue",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "NetfilterQueue",
    "package_url": "https://pypi.org/project/NetfilterQueue/",
    "platform": null,
    "project_url": "https://pypi.org/project/NetfilterQueue/",
    "project_urls": {
      "Homepage": "https://github.com/oremanj/python-netfilterqueue"
    },
    "release_url": "https://pypi.org/project/NetfilterQueue/1.1.0/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "Python bindings for libnetfilter_queue",
    "version": "1.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17108234,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2eddfa1099d27644b053567922cc41d4e67cca5e39938ff0f6ac65ef373719aa",
          "md5": "e749a0f7df5e947d4241e9785866765c",
          "sha256": "ad797bd4dd083b59b05dd96720c20d22b296a09418bd1fa7840e0b27c35468d4"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e749a0f7df5e947d4241e9785866765c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 37969,
        "upload_time": "2011-05-13T17:44:01",
        "upload_time_iso_8601": "2011-05-13T17:44:01.909222Z",
        "url": "https://files.pythonhosted.org/packages/2e/dd/fa1099d27644b053567922cc41d4e67cca5e39938ff0f6ac65ef373719aa/NetfilterQueue-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4b32d6baddf0718bfb5fab708992781c6f979aa871672e7f6e8ce53f88d9edea",
          "md5": "5a5c634a896668bbd4e4eb2923a5481e",
          "sha256": "c72f90b93a95adb8273bbd6b70c69709de4a6647caa4c5df0d0e71fa19e3745b"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "5a5c634a896668bbd4e4eb2923a5481e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39330,
        "upload_time": "2011-05-13T18:50:03",
        "upload_time_iso_8601": "2011-05-13T18:50:03.746171Z",
        "url": "https://files.pythonhosted.org/packages/4b/32/d6baddf0718bfb5fab708992781c6f979aa871672e7f6e8ce53f88d9edea/NetfilterQueue-0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8df5bc84583edb9733e00f9efbf05c3c448cfdd1afcf00e84cae0e7f3f15acf9",
          "md5": "4bc4cab885a0326fad3f6d8e2c5c3b09",
          "sha256": "06d0980c245b2bef4bd15bf6a8f4520e42be44309ccd81166854e9c3f15259b7"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "4bc4cab885a0326fad3f6d8e2c5c3b09",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39862,
        "upload_time": "2011-10-14T23:57:46",
        "upload_time_iso_8601": "2011-10-14T23:57:46.732065Z",
        "url": "https://files.pythonhosted.org/packages/8d/f5/bc84583edb9733e00f9efbf05c3c448cfdd1afcf00e84cae0e7f3f15acf9/NetfilterQueue-0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7bc3204d47c1c47a7fd6ac1e4e341bdc6021f8142e6c7b6e488436592a6d2488",
          "md5": "7aa401680fc1ad25312eb50f465fa05f",
          "sha256": "f24c592a0d2e8b2233ee365528fc1f90f7e3d80cb35c09195e3aafe3d451eac5"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "7aa401680fc1ad25312eb50f465fa05f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 55215,
        "upload_time": "2016-06-29T05:48:05",
        "upload_time_iso_8601": "2016-06-29T05:48:05.299928Z",
        "url": "https://files.pythonhosted.org/packages/7b/c3/204d47c1c47a7fd6ac1e4e341bdc6021f8142e6c7b6e488436592a6d2488/NetfilterQueue-0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "945b83d10952c1312fe056f8f2f524a4a59fdc9d56b84a67cae1ed779e2da50b",
          "md5": "8e78db992ad3a73dd86fef05293fff65",
          "sha256": "1c0316d062dd18678473d2cd661d89fbc5d708354a9e5ce03dcec14829a86560"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.8.tar.gz",
        "has_sig": false,
        "md5_digest": "8e78db992ad3a73dd86fef05293fff65",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 58503,
        "upload_time": "2016-12-15T09:35:48",
        "upload_time_iso_8601": "2016-12-15T09:35:48.126819Z",
        "url": "https://files.pythonhosted.org/packages/94/5b/83d10952c1312fe056f8f2f524a4a59fdc9d56b84a67cae1ed779e2da50b/NetfilterQueue-0.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "39c48f73f70442aa4094b3c37876c96cddad2c3e74c058f6cd9cb017d37ffac0",
          "md5": "ea2c262d6a571cb5ecdaed1bbb0da2b4",
          "sha256": "beda851dfb8f3199f716e246c4cfd2c8492f7cdce32a03613c7eeab152e0a4a6"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.8.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ea2c262d6a571cb5ecdaed1bbb0da2b4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 58616,
        "upload_time": "2017-01-31T07:42:22",
        "upload_time_iso_8601": "2017-01-31T07:42:22.210141Z",
        "url": "https://files.pythonhosted.org/packages/39/c4/8f73f70442aa4094b3c37876c96cddad2c3e74c058f6cd9cb017d37ffac0/NetfilterQueue-0.8.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7d3427b2dafb00d6c4dd4c6e88cc6eaeba2e345e6d84f33748520dc3ebe813b6",
          "md5": "56b6cfa382f1ca3f7012e0241f5522be",
          "sha256": "31c0bcddb72efba6d58c32cb5103c56206c7ddd55693f8eb2d990770ee4004ea"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-0.9.0.tar.gz",
        "has_sig": false,
        "md5_digest": "56b6cfa382f1ca3f7012e0241f5522be",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 79001,
        "upload_time": "2022-01-13T06:50:56",
        "upload_time_iso_8601": "2022-01-13T06:50:56.436894Z",
        "url": "https://files.pythonhosted.org/packages/7d/34/27b2dafb00d6c4dd4c6e88cc6eaeba2e345e6d84f33748520dc3ebe813b6/NetfilterQueue-0.9.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5240cc706275da4c9b968ce1223f586e0ab6ef20f3f6e840724b43070e85234e",
          "md5": "d79e4029e1f18b45b6dcd75de2db6196",
          "sha256": "507be475d8c9f98834763aacf2f6cfe800b253ccd283f14f3d6f89a4f87a5878"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d79e4029e1f18b45b6dcd75de2db6196",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 87657,
        "upload_time": "2022-01-14T20:30:52",
        "upload_time_iso_8601": "2022-01-14T20:30:52.132032Z",
        "url": "https://files.pythonhosted.org/packages/52/40/cc706275da4c9b968ce1223f586e0ab6ef20f3f6e840724b43070e85234e/NetfilterQueue-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "791e216bc353a860a7baa580573e6e161343e88c29b80badc778a60b6bcebb74",
          "md5": "85b2c3347893ef2c36aa627be2493a7a",
          "sha256": "e30eff999325617f54bd95b3d8d3353214cc77b5e3188f90ec3a6f6288888d72"
        },
        "downloads": -1,
        "filename": "NetfilterQueue-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "85b2c3347893ef2c36aa627be2493a7a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 90337,
        "upload_time": "2023-03-01T08:01:40",
        "upload_time_iso_8601": "2023-03-01T08:01:40.211072Z",
        "url": "https://files.pythonhosted.org/packages/79/1e/216bc353a860a7baa580573e6e161343e88c29b80badc778a60b6bcebb74/NetfilterQueue-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "791e216bc353a860a7baa580573e6e161343e88c29b80badc778a60b6bcebb74",
        "md5": "85b2c3347893ef2c36aa627be2493a7a",
        "sha256": "e30eff999325617f54bd95b3d8d3353214cc77b5e3188f90ec3a6f6288888d72"
      },
      "downloads": -1,
      "filename": "NetfilterQueue-1.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "85b2c3347893ef2c36aa627be2493a7a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 90337,
      "upload_time": "2023-03-01T08:01:40",
      "upload_time_iso_8601": "2023-03-01T08:01:40.211072Z",
      "url": "https://files.pythonhosted.org/packages/79/1e/216bc353a860a7baa580573e6e161343e88c29b80badc778a60b6bcebb74/NetfilterQueue-1.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}