{
  "info": {
    "author": "",
    "author_email": "Stanislav Tsaplev <stanislav.tsaplev@gmail.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# SuperExpressive\n\nThis package is the Python port of the following JavaScript library: https://github.com/francisrstokes/super-expressive\n<br/>\n\n## Installation\n```\npip install super_expressive\n```\n<br/>\n\n## Example\n\nThe following example recognises and captures the value of a 16-bit hexadecimal number like `0xC0D3`.\n\n```py\nfrom super_expressive import SuperExpressive\n\n\nmy_regex = (\n    SuperExpressive()\n        .start_of_input\n        .optional.string('0x')\n        .capture\n            .exactly(4).any_of\n                .range('a', 'f')\n                .range('a', 'f')\n                .range('0', '9')\n            .end()\n        .end()\n        .end_of_input\n    .to_regex()\n)\n\n// Produces the following regular expression:\nre.compile('^(?:0x)?([A-Fa-f0-9]{4})$')\n```\n<br/>\n\n## API\n**Legend:**\n\n    [–] original, not supported\n    [=] original, supported\n    [≈] original, supported (slightly different syntax)\n    [+] new, added\n\n---\n\n[–] **`.allow_multiple_matches`**\n\nAPI compatibility stub.\n\nHas been intended to use the `g` flag on the regular expression, which indicates that it should match multiple values when run on a string.\n\nPython does not have a `g` flag, it implements this behavior at the pattern object method level.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .allow_multiple_matches\n        .string(\"hello\")\n    .to_regex_string()\n)\n# 'hello'\n```\n\n---\n\n[–] **`.sticky`**\n\nAPI compatibility stub.\n\nHas been intended to use the y flag on the regular expression, which indicates that it should create a stateful regular expression that can be resumed from the last match.\n\nPython does not have a `y` flag.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .sticky\n        .string(\"hello\")\n    .to_regex_string()\n)\n# 'hello'\n```\n\n---\n\n[+] **`.ascii`**\n\nAssumes ascii 'locale'.\n\nUses the `a` flag on the regular expression, which indicates that it should use only ascii characters matching.\n\nYou could use this flag when necessary, considering the default mode in Python 3 is the unicode mode.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .ascii\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?a)hello'\n```\n---\n\n[=] **`.case_insensitive`**\n- `.caseInsensitive`\n- `.ignore_case`\n- `.ignoreCase`\n\nIgnores case.\n\nUses the `i` flag on the regular expression, which indicates that it should treat ignore the uppercase/lowercase distinction when matching.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .case_insensitive\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?i)hello'\n```\n---\n\n[=] **`.line_by_line`**\n- `.lineByLine`\n- `.multiline`\n\nMakes anchors look for newline.\n\nUses the `m` flag on the regular expression, which indicates that it should treat the `.start_of_input` and `.end_of_input` markers as the start and end of lines.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .line_by_line\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?m)hello'\n```\n---\n\n[=] **`.single_line`**\n- `.singleLine`\n- `.dotall`\n\nMakes dot match newline.\n\nUses the `s` flag on the regular expression, which indicates \nthat the input should be treated as a single line, where the `.start_of_input` and `.end_of_input` markers explicitly mark the start and end of input, and `.any_char` also matches newlines.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .single_line\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?s)hello'\n```\n---\n\n[=] **`.unicode`**\n\nAssumes unicode 'locale'.\n\nUses the `u` flag on the regular expression, which indicates \nthat it should use full unicode matching.\n\nSince unicode mode is the default in Python 3, there is no need for using this flag\n(but you can use `.ascii` instead when necessary).\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .unicode\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?u)hello'\n```\n---\n\n[=] **`.any_char`**\n- `.anyChar`\n\nMatches any single character.\n\nWhen combined with `.single_line` (aka `.dotall`), it also matches newlines.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_char\n    .to_regex_string()\n)\n# '.'\n```\n---\n\n[=] **`.whitespace_char`**\n- `.whitespaceChar`\n- `.whitespace`\n\nMatches any whitespace character, including the special whitespace characters: `\\r`, `\\n`, `\\t`, `\\f`, `\\v`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .whitespace_char\n    .to_regex_string()\n)\n# '\\\\s'\n```\n---\n\n[=] **`.non_whitespace_char`**\n- `.nonWhitespaceChar`\n- `.non_whitespace`\n- `.nonWhitespace`\n\nMatches any non-whitespace character, excluding also the special whitespace characters: `\\r`, `\\n`, `\\t`, `\\f`, `\\v`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_whitespace_char\n    .to_regex_string()\n)\n# '\\\\S'\n```\n---\n\n[=] **`.digit`**\n\nMatches any digit from `0-9`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .digit\n    .to_regex_string()\n)\n# '\\\\d'\n```\n---\n\n[=] **`.non_digit`**\n- `.nonDigit`\n\nMatches any non-digit.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_digit\n    .to_regex_string()\n)\n# '\\\\D'\n```\n---\n\n[=] **`.word`**\n- `.word_char`\n- `.wordChar`\n\nMatches any alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, as well as `_`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .word\n    .to_regex_string()\n)\n# '\\\\w'\n```\n---\n\n[=] **`.non_word`**\n- `.nonWord`\n- `.non_word_char`\n- `.nonWordChar`\n\nMatches any non alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, excluding `_` as well.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_word\n    .to_regex_string()\n)\n# '\\\\W'\n```\n---\n\n[=] **`.word_boundary`**\n- `.wordBoundary`\n\nMatches (without consuming any characters) immediately between a character matched by `.word` and a character not matched by `.word` (in either order).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .word_boundary\n    .to_regex_string()\n)\n# '\\\\b'\n```\n---\n\n[=] **`.non_word_boundary`**\n- `.nonWordBoundary`\n\nMatches (without consuming any characters) at the position between two characters matched by `.word`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_word_boundary\n    .to_regex_string()\n)\n# '\\\\B'\n```\n---\n\n[=] **`.new_line`**\n- `.newLine`\n\nMatches a `\\n` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .new_line\n    .to_regex_string()\n)\n# '\\\\n'\n```\n---\n\n[=] **`.carriage_return`**\n- `.carriageReturn`\n\nMatches a `\\r` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .new_line\n    .to_regex_string()\n)\n# '\\\\r'\n```\n---\n\n[=] **`.tab`**\n\nMatches a `\\t` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .tab\n    .to_regex_string()\n)\n# '\\\\t'\n```\n---\n\n[=] **`.null_byte`**\n- `.nullByte`\n\nMatches a `\\\\u0000` character (ASCII 0).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .null_byte\n    .to_regex_string()\n)\n# '\\\\0'\n```\n---\n\n[=] **`.char(c: str)`**\n\nMatches the exact (single) character `c`.\n\nThe `c` parameter must be a single character string.\nRaises a `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .char('.')\n    .to_regex_string()\n)\n# '\\\\.'\n```\n---\n\n[=] **`.string(s: str)`**\n\nMatches the exact string (the sequential characters) `s`.\n\nThe `s` parameter must be a non-empty string.\nRaises a `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"1+1\")\n    .to_regex_string()\n)\n# '1\\\\+1'\n```\n---\n\n[=] **`.range(a: str|int, b: str|int)`**\n\nMatches any character that falls between `a` and `b`.\n\nOrdering is defined by a characters ASCII or unicode value.\n\nBoth `a` and `b` parameters must be a single character string or a single digit integer.\nThe `a` character must precede the `b` character alphabetically.\nOtherwise raises `RegexError`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .range(0, 9)\n        .range('a', 'f')\n    .to_regex_string()\n)\n# '[0-9][a-f]'\n```\n---\n\n[=] **`.any_of`**\n- `.anyOf`\n\nMatches a choice between specified elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_of\n            .char('-')\n            .range(0, 9)\n            .string(\"no\")\n        .end()\n    .to_regex_string()\n)\n# '(?:no|[\\\\-0-9])'\n```\n---\n\n[=] **`.group`**\n\nCreates a non-capturing group of the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .optional.group\n            .char('-')\n            .range(0, 9)\n            .string(\"no\")\n        .end()\n    .to_regex_string()\n)\n# '(?:\\\\-[0-9]no)?'\n```\n---\n\n[=] **`.assert_ahead`**\n- `.assertAhead`\n\nAssert that the proceeding elements are found without consuming them.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_ahead\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?=[a-f])[a-z]'\n```\n---\n\n[=] **`.assert_behind`**\n- `.assertBehind`\n\nAssert that the elements contained within are found immediately before this point in the string.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_behind\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?<=[a-f])[a-z]'\n```\n---\n\n[=] **`.assert_not_ahead`**\n- `.assertNotAhead`\n\nAssert that the proceeding elements are not found without consuming them. \n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_not_ahead\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?![a-f])[a-z]'\n```\n---\n\n[=] **`.assert_not_behind`**\n- `.assertNotBehind`\n\nAssert that the elements contained within are not found immediately before this point in the string.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_not_behind\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?<![a-f])[a-z]'\n```\n---\n\n[=] **`.any_of_chars(chars: str)`**\n- `.anyOfChars(chars: str)`\n\nMatches any of the characters in the provided string `chars`.\n\nThe `chars` parameter must be a non-empty string.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_of_chars(\"aeiou\")\n        .any_of_chars(\"+-*/=\")\n    .to_regex_string()\n)\n# '[aeiou][\\\\+\\\\-\\\\*/=]'\n```\n---\n\n[=] **`.anything_but_chars(chars: str)`**\n- `.anythingButChars(chars: str)`\n\nMatches any character, except any of those in the provided string `chars`.\n\nThe `chars` parameter must be a non-empty string.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_chars(\"aeiou\")\n        .anything_but_chars(\"+-*/=\")\n    .to_regex_string()\n)\n# '[^aeiou][^\\\\+\\\\-\\\\*/=]'\n```\n---\n\n[=] **`.anything_but_range(a: str, b: str)`**\n- `.anythingButRange(a: str, b: str)`\n\nMatches any character, except those that would be captured by the range specified by `a` and `b`.\n\nBoth `a` and `b` parameters must be a single character string or a single digit integer.\nThe `a` character must precede the `b` character alphabetically.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_range(0, 9)\n        .anything_but_range('a', 'f')\n    .to_regex_string()\n)\n# '[^0-9][^a-f]'\n```\n---\n\n[=] **`.anything_but_string(s: str)`**\n- `.anythingButString(s: str)`\n\nMatches any string the same length as `s`, except the `s` itself (the sequential characters in `s`).\n\nThe `s` parameter must be a non-empty string.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_string(\"aeiou\")\n        .anything_but_string(\"+-*/=\")\n    .to_regex_string()\n)\n# '(?:(?!aeiou).{5})(?:(?!\\\\+\\\\-\\\\*/=).{5})'\n```\n---\n\n[=] **`.capture`**\n\nCreates a capture group for the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\nCan be later referenced with `.backreference(index)`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .capture\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n    .to_regex_string()\n)\n# '(prefix:[0-9]\\\\-[a-f])'\n```\n---\n\n[=] **`.named_capture(name: str)`**\n- `.namedCapture(name: str)`\n\nCreates a named capture group for the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\nCan be later referenced with `.named_backreference(name)` or `.backreference(index)`.\n\nThe `name` parameter must be non-empty string consisting of latin letters, numbers, and underscores only and must not coincide with the name of the capture group defined before.\nRaises `RegexError` otherwise.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .named_capture(\"some_stuff\")\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n    .to_regex_string()\n)\n# '(?P<some_stuff>prefix:[0-9]\\\\-[a-f])'\n```\n---\n\n[=] **`.backreference(index: int)`**\n- `.backref(index: int)`\n\nMatches exactly what was previously matched by a `.capture` or `.named_capture` using a positional index.\n\nNote that regex indices start at 1, so the first capture group has index 1.\n\nThe `index` parameter must be a number between 1 and capture groups count.\nRaises `RegexError` otherwise.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .capture\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n        .string(\"something else\")\n        .backreference(1)\n    .to_regex_string()\n)\n# '(prefix:[0-9]\\\\-[a-f])something else\\\\1'\n```\n---\n\n[=] **`.named_backreference(name: str)`**\n- `.namedBackreference(name: str)`\n- `.named_backref(name: str)`\n- `.namedBackref(name: str)`\n\nMatches exactly what was previously matched by a `.named_capture`.\n\nThe `name` parameter must be one of the names of existing capture groups.\nRaises `RegexError` otherwise.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .named_capture(\"some_stuff\")\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n        .string(\"something else\")\n        .named_backreference(\"some_stuff\")\n    .to_regex_string()\n)\n# '(?P<some_stuff>prefix:[0-9]\\\\-[a-f])something else(?P=some_stuff)'\n```\n---\n\n[=] **`.optional`**\n\nAsserts that the proceeding element may or may not be matched.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .optional.digit\n    .to_regex_string()\n)\n# '\\d?'\n```\n---\n\n[=] **`.zero_or_more`**\n- `.zeroOrMore`\n\nAsserts that the proceeding element may not be matched, or may be matched multiple times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .zero_or_more.digit\n    .to_regex_string()\n)\n# '\\d*'\n```\n---\n\n[=] **`.zero_or_more_lazy`**\n- `.zeroOrMoreLazy`\n\nAsserts that the proceeding element may not be matched, or may be matched multiple times, but as few times as possible.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .zero_or_more_lazy.digit\n    .to_regex_string()\n)\n# '\\d*?'\n```        \n---\n\n[=] **`.one_or_more`**\n- `.oneOrMore`\n\nAsserts that the proceeding element may be matched once, or may be matched multiple times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .one_or_more.digit\n    .to_regex_string()\n)\n# '\\d+'\n```\n---\n\n[=] **`.one_or_more_lazy`**\n- `.oneOrMoreLazy`\n\nAsserts that the proceeding element may be matched once, or may be matched multiple times, but as few times as possible.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .one_or_more_lazy.digit\n    .to_regex_string()\n)\n# '\\d+?'\n```\n---\n\n[=] **`.exactly(n: int)`**\n\nAsserts that the proceeding element will be matched exactly `n` times.\n\nThe `n` parameter must be a positive integer.\nThe application of the method must not conflict with previously applied quantifiers.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .exactly(5).digit\n    .to_regex_string()\n)\n# '\\d{5}'\n```\n---\n\n[=] **`.at_least(n: int)`**\n- `.atLeast(n: int)`\n\nAsserts that the proceeding element will be matched at least `n` times.\n\nThe `n` parameter must be a positive integer.\nThe application of the method must not conflict with previously applied quantifiers.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .at_least(5).digit\n    .to_regex_string()\n)\n# '\\d{5,}'\n```\n---\n\n[=] **`.between(x: int, y: int)`**\n\nAsserts that the proceeding element will be matched somewhere between `x` and `y` times.\n\nBoth `x` and `y` parameters must be non-negative integers.\nThe `x` parameter must be less than `y` parameter.\nThe application of the method must not conflict with previously applied quantifiers.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .between(3, 5).digit\n    .to_regex_string()\n)\n# '\\d{3,5}'\n```\n---\n\n[=] **`.between_lazy(x: int, y: int)`**\n- `.betweenLazy(x: int, y: int)`\n\nAsserts that the proceeding element will be matched somewhere between `x` and `y` times, but as few times as possible.\n\nBoth `x` and `y` parameters must be non-negative integers.\nThe `x` parameter must be less than `y` parameter.\nThe application of the method must not conflict with previously applied quantifiers.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .between(3, 5).digit\n    .to_regex_string()\n)\n# '\\d{3,5}?'\n```\n---\n\n[+] **`.start_of_string`**\n- `.startOfString`\n\nAlways asserts the start of input string, regardless of using multiline mode (aka `.line_by_line`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .start_of_string\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '\\Ahello'\n```\n---\n\n[+] **`.end_of_string`**\n- `.endOfString`\n\nAlways asserts the end of input string, regardless of using multiline mode (aka `.line_by_line`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"hello\")\n        .end_of_string\n    .to_regex_string()\n)\n# 'hello\\Z'\n```\n---\n\n[=] **`.start_of_input`**\n- `.startOfInput`\n\nAsserts the start of input string, or the start of a line when multiline mode ( aka `.line_by_line`) is used.\n\nThe application of the method must not conflict with previously applied start-of-input or end-of-input methods.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .start_of_input\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '^hello'\n```\n---\n\n[=] **`.end_of_input`**\n- `.endOfInput`\n\nAsserts the end of input string, or the end of a line when multiline mode (aka `.line_by_line`) is used.\n\nThe application of the method must not conflict with previously applied end-of-input method.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"hello\")\n        .end_of_input\n    .to_regex_string()\n)\n# 'hello$'\n```\n---\n\n[=] **`.end()`**\n\nCloses the context of `.any_of`, `.group`, `.capture`, or `.assert_*`.\n\nRequires parentheses when invoked (see also `.over`).\n\nThe method must not be applied out of the context mentioned above.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"prefix:\")\n        .capture\n            .anyOf\n                .range(0, 9)\n                .char(\"-\")\n                .range('a', 'f')\n                .string(\"something else\")\n            .end()\n        .end()\n    .to_regex_string()\n)\n# 'prefix:((?:something else|[0-9\\\\-a-f]))'\n```\n---\n\n[+] **`.over`**\n\nCloses the context of `.any_of`, `.group`, `.capture` or `.assert_*`.\n\nAlias for `.end()`, but doesn't require parentheses.\n\nThe method must not be applied out of the context mentioned above.\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"prefix:\")\n        .capture\n            .anyOf\n                .range(0, 9)\n                .char(\"-\")\n                .range('a', 'f')\n                .string(\"something else\")\n            .over\n        .over\n    .to_regex_string()\n)\n# 'prefix:((?:something else|[0-9\\\\-a-f]))'\n```\n---\n\n[≈] **`.subexpression(expr: SuperExpressive, *, namespace: str = \"\", ignore_flags: bool = True, ignore_start_and_end: bool = True)`**\n- `.sub(expr, *, namespace=\"\", ignore_flags=True, ignore_start_and_end=True)`\n\nMatches another `SuperExpressive` instance inline. \n\nCan be used to create libraries, or to modularise you code.\n\nThe `expr` parameter must be a correctly defined `SuperExpressive` object and must not conflict with start-of-input or end-of-input markers defined in the caller object (see also `ignore_start_and_end` parameter description below).\nRaises `RegexError` otherwise.\n\n**Example:**\n```py\nhex_number = SuperExpressive().one_or_more.any_of.range(0, 9).range('A', 'F').end()\n\npattern = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n```\n\nBy default, flags and start/end of input markers are ignored, but can be explicitly turned on in the keyword parameters.\n- `ignore_flags`: If set to true, any flags this subexpression specifies \nshould be disregarded (default is `True`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .case_insensitive\n        .one_or_more.any_of\n            .range(0, 9)\n            .range('A', 'F')\n        .end()\n)\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n\npattern2 = (\n    SuperExpressive()\n        .subexpression(hex_number, ignore_flags=False)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '(?i)[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n```\n\n- `ignore_start_and_end`: If set to true, any `.start_of_input` / `.end_of_input` \nasserted in this subexpression specifies should be disregarded (default is `True`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .start_of_input\n        .one_or_more.any_of\n            .range(0, 9)\n            .range('A', 'F')\n        .end()\n        .end_of_input\n)\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n\npattern2 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number, ignore_start_and_end=False)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:^[0-9A-F]+$)?'\n```\n\n- `namespace`: A string namespace to use on all named capture groups in the subexpression, to avoid naming collisions with your own named groups (default is `\"\"`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .named_capture(\"hex\")\n            .one_or_more.any_of\n                .range(0, 9)\n                .range('A', 'F')\n            .end()\n        .end()\n        .named_backreference(\"hex\")\n)\n#'(?P<hex>[0-9A-F]+)(?P=hex)'\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number, namespace=\"snd_\")\n    .to_regex_string()\n)\n# '(?P<hex>[0-9A-F]+)(?P=hex)\\\\s+(?:(?P<snd_hex>[0-9A-F]+)(?P=snd_hex))?'\n\npattern2 = (\n    SuperExpressive()\n        .named_capture(\"hex\")\n            .subexpression(hex_number, namespace=\"sub1_\")\n            .one_or_more.whitespace\n            .optional.subexpression(hex_number, namespace=\"sub2_\")\n        .end()\n        .named_backreference(\"hex\")\n    .to_regex_string()\n)\n# '(?P<hex>(?P<sub1_hex>[0-9A-F]+)(?P=sub1_hex)\\\\s+(?:(?P<sub2_hex>[0-9A-F]+)(?P=sub2_hex))?)(?P=hex)'\n\n```\n---\n\n[=] **`.to_regex()`**\n- `.toRegex()`\n\nOutputs the regular expression pattern that this `SuperExpression` models.\n\n---\n\n[=] **`.to_regex_string()`**\n- `.toRegexString()`\n- `.to_string()`\n- `.toString()`\n\nOutputs a string representation of the regular expression that this `SuperExpression` models.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "super-expressive",
    "package_url": "https://pypi.org/project/super-expressive/",
    "platform": null,
    "project_url": "https://pypi.org/project/super-expressive/",
    "project_urls": {
      "bugtracker": "https://github.com/stanislav-tsaplev/super_expressive/issues",
      "documentation": "https://github.com/stanislav-tsaplev/super_expressive/README.md",
      "homepage": "https://github.com/stanislav-tsaplev/super_expressive",
      "repository": "https://github.com/stanislav-tsaplev/super_expressive"
    },
    "release_url": "https://pypi.org/project/super-expressive/1.0.3/",
    "requires_dist": null,
    "requires_python": ">=3.10",
    "summary": "Python port of the JS library: https://github.com/francisrstokes/super-expressive",
    "version": "1.0.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16280930,
  "releases": {
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dbc61f195a780cf40e93a322d49f3b6ac66f5b9a56280ccf5b28e51ee9433d93",
          "md5": "e65ad933869d306b651dc26dcd24d154",
          "sha256": "ba74b4a2f8f9802a4c577cdd3934912fd740e6033472c5b18b592a6bc2115a3f"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e65ad933869d306b651dc26dcd24d154",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 14439,
        "upload_time": "2022-12-13T17:28:44",
        "upload_time_iso_8601": "2022-12-13T17:28:44.903638Z",
        "url": "https://files.pythonhosted.org/packages/db/c6/1f195a780cf40e93a322d49f3b6ac66f5b9a56280ccf5b28e51ee9433d93/super_expressive-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3ee07f03eb01fa0a54d813f32efda143be766deb2d43d4dfdb8ce88bc038b053",
          "md5": "22f647b7731d003adc886846af6fc1f5",
          "sha256": "4a3bd98e9d6774551c09a7ccb80e18bfa25e6158df68c664f9e0193b33395233"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "22f647b7731d003adc886846af6fc1f5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 17908,
        "upload_time": "2022-12-13T17:28:47",
        "upload_time_iso_8601": "2022-12-13T17:28:47.784031Z",
        "url": "https://files.pythonhosted.org/packages/3e/e0/7f03eb01fa0a54d813f32efda143be766deb2d43d4dfdb8ce88bc038b053/super_expressive-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "81a68beb9c927d12e63d9833d87556ac6681757349f39e520395421fcfe0ad1b",
          "md5": "dff3a0c1779b57f5111c20638ded80d9",
          "sha256": "cdd7626590f1901d06741c19584fde79c4cf6334d00d0e1dc59a19a8c5811e83"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "dff3a0c1779b57f5111c20638ded80d9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 14965,
        "upload_time": "2023-01-02T17:49:45",
        "upload_time_iso_8601": "2023-01-02T17:49:45.151476Z",
        "url": "https://files.pythonhosted.org/packages/81/a6/8beb9c927d12e63d9833d87556ac6681757349f39e520395421fcfe0ad1b/super_expressive-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1a70b9df91b522b0f5500f0afae8c37690b222b79ac3b190445df8102e71d10f",
          "md5": "3ad41f4815bed33cb3f94bad2c03142f",
          "sha256": "71c88fcde979ffa2df037203fe289e12c6e10a310a9dbb442285837382167188"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "3ad41f4815bed33cb3f94bad2c03142f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 18909,
        "upload_time": "2023-01-02T17:49:48",
        "upload_time_iso_8601": "2023-01-02T17:49:48.442191Z",
        "url": "https://files.pythonhosted.org/packages/1a/70/b9df91b522b0f5500f0afae8c37690b222b79ac3b190445df8102e71d10f/super_expressive-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c164575dc957f341f8a9fcfbf37a10ed3caa48c67b6c1449ccac84a0e0a41b91",
          "md5": "48634bdf3e8fb6e031ee8a5e504a6137",
          "sha256": "24bd61976d7b31326b8c8f95949d89a19f068f250b5ec0796aed233a2b82af54"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "48634bdf3e8fb6e031ee8a5e504a6137",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 15397,
        "upload_time": "2023-01-02T17:49:46",
        "upload_time_iso_8601": "2023-01-02T17:49:46.765640Z",
        "url": "https://files.pythonhosted.org/packages/c1/64/575dc957f341f8a9fcfbf37a10ed3caa48c67b6c1449ccac84a0e0a41b91/super_expressive-1.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5ae969e01c6108933044633f31c2c94eb6d36473aabc0879ec5db96666afca45",
          "md5": "b77a84e07ec33b51c2353fccd9e6e460",
          "sha256": "d4a81022f3968d39a5834ca246f3908a3cd0f0e81ef94bc2ca0b917b39eb000d"
        },
        "downloads": -1,
        "filename": "super_expressive-1.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "b77a84e07ec33b51c2353fccd9e6e460",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 19343,
        "upload_time": "2023-01-02T17:49:49",
        "upload_time_iso_8601": "2023-01-02T17:49:49.925389Z",
        "url": "https://files.pythonhosted.org/packages/5a/e9/69e01c6108933044633f31c2c94eb6d36473aabc0879ec5db96666afca45/super_expressive-1.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c164575dc957f341f8a9fcfbf37a10ed3caa48c67b6c1449ccac84a0e0a41b91",
        "md5": "48634bdf3e8fb6e031ee8a5e504a6137",
        "sha256": "24bd61976d7b31326b8c8f95949d89a19f068f250b5ec0796aed233a2b82af54"
      },
      "downloads": -1,
      "filename": "super_expressive-1.0.3-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "48634bdf3e8fb6e031ee8a5e504a6137",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.10",
      "size": 15397,
      "upload_time": "2023-01-02T17:49:46",
      "upload_time_iso_8601": "2023-01-02T17:49:46.765640Z",
      "url": "https://files.pythonhosted.org/packages/c1/64/575dc957f341f8a9fcfbf37a10ed3caa48c67b6c1449ccac84a0e0a41b91/super_expressive-1.0.3-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5ae969e01c6108933044633f31c2c94eb6d36473aabc0879ec5db96666afca45",
        "md5": "b77a84e07ec33b51c2353fccd9e6e460",
        "sha256": "d4a81022f3968d39a5834ca246f3908a3cd0f0e81ef94bc2ca0b917b39eb000d"
      },
      "downloads": -1,
      "filename": "super_expressive-1.0.3.tar.gz",
      "has_sig": false,
      "md5_digest": "b77a84e07ec33b51c2353fccd9e6e460",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.10",
      "size": 19343,
      "upload_time": "2023-01-02T17:49:49",
      "upload_time_iso_8601": "2023-01-02T17:49:49.925389Z",
      "url": "https://files.pythonhosted.org/packages/5a/e9/69e01c6108933044633f31c2c94eb6d36473aabc0879ec5db96666afca45/super_expressive-1.0.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}