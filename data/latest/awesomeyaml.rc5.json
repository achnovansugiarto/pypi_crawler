{
  "info": {
    "author": "Łukasz Dudziak",
    "author_email": "l.dudziak@samsung.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# AwesomeYaml\n\nAwesomeYaml is a Python-based library which extends standard yaml with a set of custom tags and a processing pipeline designed to make the process of building and manipulating yaml-based config files easier.\nWe use a popular [pyyaml](https://pypi.org/project/PyYAML/) package as the core component to read and write yaml files.\n\n> **Note:** AwesomeYaml is *NOT* designed to be safe! Be cautious when using it with externally provided content.\n\n## Content\n - [Overview](#AwesomeYaml)\n   - [Capabilities](#Capabilities)\n   - [Installation](#Installation)\n   - [Running Tests](#Running-tests)\n   - [Generating documentaion](#Generating-documentation)\n - [Quick reference](#Quick-reference)\n   - [Low-level API](#Low-level-API)\n - [Detailed description](#Detailed-description)\n   - [Yaml](#Yaml-side)\n     - [Merging](#Merging-yaml-files)\n     - [Yaml streams](#Yaml-streams)\n     - [Evaluation](#Evaluation-of-nodes)\n     - [Metadata](#Adding-user-defined-metadata)\n   - [Python](#Python-side)\n     - [Basic usage](#Basic-usage)\n     - [Command line](#Handling-command-line-arguments)\n     - [Accessing data](#Accessing-evaluated-fields)\n   - [Tags summary](#Summary-of-extended-tags)\n - [Contributing](#contributing)\n - [Reporting issues](#reporting-issues)\n - [License](#license)\n\n## Capabilities\n\nBriefly speaking, `awesomeyaml` is capable of:\n - merging multiple (partial) config files into a common config object, allowing for:\n   - cross-referencing elements from different files and expressing dependencies\n   - controlling the merging process by defining 3 priorities and allowing the user to set them arbitralily for any entity within the config tree\n   - moving and deleting entire subtrees during the merging process for easier wrapping of components\n   - including files, supporting nested and within-the-tree includes\n - dynamically evaluating content of the nodes in the config tree, supporting:\n   - f-string-like mechanism to evaluate strings\n   - importing and embedding python entities directly in the evaluated config tree\n   - calling python entities with the provided arguments (or binding arguments to them)\n   - evalauting arbitrary python code (**UNSAFE!**) \n - attaching user-defined metadata to any node in the config tree via a generic yaml-compatible mechanism\n\n\n## Installation\n\nAwesomeyaml requires `pyyaml` and `Python>=3.6`.\nYou can install `awesomeyaml` from PyPI by simply issuing:\n```bash\npython -m pip install awesomeyaml\n```\n\nAlternatively, you can also perform installation by cloning this repo and installing directly from it with pip:\n```bash\ngit clone https://github.com/SamsungLabs/awesomeyaml.git\npython -m pip install ./awesomeyaml\n```\n\nOptionally, you can add `-e` option to allow for in-place (also called editable or developer) installation:\n\n```bash\npython -m pip install -e ./awesomeyaml\n```\n\nor, if you don't need the repo to be laying around simply install directly from github:\n\n```bash\npython -m pip install https://github.com/SamsungLabs/awesomeyaml/tarball/master#egg=awesomeyaml\n```\n\n## Running tests\n\nWe use a standard `unittest` python package for writing tests.\n\nSince `awesomeyaml` is a pure python library with minimal dependencies and does not directly depend on any OS or HW specific components, it is rather unlikely that a version tested on one machine would break on another.\nHowever, if you want to be extra safe, you can run tests provided with the repo by using the following command (run from the cloned directory):\n\n```\npython -m unittest discover -v -s . -p '*_test.py'\n```\n\nYou should see output ending with something similar to:\n\n```\n----------------------------------------------------------------------\nRan 118 tests in 0.131s\n\nOK\n```\n\nIf any errors have occurred, they should be mentioned at the end instead of `OK`.\nPlease [raise an issue]() if you encounter any.\n\n> **Note:** the tests are only shipped with the repo, so you need to clone it in order to run them. Installing the cloned code is not required as the testing code always uses the code provided in the repo (by altering `sys.path`).\n\n## Generating documentation\nTo automatically generate API documentation for the library, make sure `sphinx` and `sphinx_rtd_theme` are installed first.\nYou can easily install them with `pip`:\n```bash\npip install sphinx sphinx_rtd_theme\n```\n\n> **Note:** `sphinx_rtd_theme` is only required if you want to use the readthedocs theme (the default one for this project).\n> You can change the theme used by modifying your `docs/source/conf.py` file.\n\nAfter installing `sphinx`, go to `docs/` and execute `make html`.\nYour newly generated documentation should be available at `docs/build/index.html`.\n\n# Quick reference\n\nUse `awesomeyaml.Config` for default, out-of-the-box behaviour.\nSpecifically, to build a config from a sequence of yaml sources, use:\n```python\nimport awesomeyaml as ay\nwith open('file2.yaml', 'r') as f:\n    # read yaml from: filename, file object and inline yaml\n    cfg = ay.Config.build('file1.yaml', f, 'field: !!null')\n```\n\nalternatively, you can let awesomeyaml parse part of your command line arguments and handle filenames and inline overwrites:\n\n```python\nimport argparse\nimport pathlib\n\nimport awesomeyaml as ay\n\nparser = argparse.ArgumentParser()\n# add some custom arguments\nparser.add_argument('--debug', action='store_true')\n# identify arguments which should be used to build config\nparser.add_argument('yamls', action='append')\nargs = parser.parse_arguments()\n\n# optional function to lookup yaml files in a non-standard way\n_lookup_dirs = ['.', '~/.project']\ndef lookup(filename):\n    for d in _lookup_dirs:\n        candidate = pathlib.Path(d).joinpath(filename).expanduser()\n        if candidate.exists():\n            return str(candidate)\n\n    return filename\n\ncfg = ay.Config.build_from_cmdline(*args.yamls, filename_lookup_fn=lookup)\n```\n\nAccess fields in a dict by either standard indexing operator or by attribute names: `cfg['field']` is the same as `cfg.field`; consequently, access awesomeyaml API via a proxy object (namespace), e.g.: `cfg.ayns.children()`\n\n## Low-level API\nUse `awesomeyaml.Builder` to merge multiple yaml sources without evaluating dynamic nodes.\nUse `awesomeyaml.EvalContext` to evaluate merged config:\n\n```python\nimport awesomeyaml as ay\n\n# merge multiple files\nbuilder = ay.Builder()\nbuilder.add_source('file1.yaml')\nbuilder.add_multiple_sources('file2.yaml', 'field: !!null')\ncfg = builder.build()\n\n# evaluate dynamic nodes in cfg\neval_ctx = ay.EvalContext(cfg)\ncfg = eval_ctx.evaluate()\n# at this point cfg should be roughly the same as cfg from the first example\n```\n\nUse `awesomeyaml.yaml` for core functionality of reading and writing yaml files and to add support for custom tags.\n\n```python\nimport awesomeyaml as ay\nimport awesomeyaml.yaml as ayyaml\n\n#\n# Read and write files with support for awesomeyaml tags\n#\n\nwith open('file1.yaml', 'r') as f:\n    # optionally pass filename as well to make\n    # e.g. include nodes know were they come from,\n    # otherwise everything is done w.r.t to the\n    # current working directory\n    # you can also pass awesomeyaml.Builder instance\n    # for more complete functionality,\n    # this is what happens normally when using\n    # higher-level functions\n    obj = ayyaml.parse(f.read())\n\nayyaml.dump(obj, 'file1_copy.yaml')\n\n\n#\n# define custom yaml constructor\n#\n\n# returned value should be derived from `awesomeyaml.nodes.ConfigNode\nclass MyNodeType(ay.nodes.ConfigNode):\n    pass\n\ndef my_node_constructor(loader, node):\n    # expects scalar value\n    return MyNodeType(loader.construct_scalar(node))\n\n# ayyaml.yaml is the standard yaml package used by awesomeyaml\nayyaml.yaml.add_constructor('!mynode', my_node_constructor)\n```\n\nSee the [summary of the extended tags](#Summary-of-extended-tags) for an overview of extra tags implemented by awesomeyaml.\n\n# Detailed description\n\n## Introduction\n\nAwesomeyaml was originally developed to make it easier to work with multiple configuration files, therefore it shines especially when configuration has a modular nature -- i.e., different parts of the system can be configured independently from each other, but at the same time might introduce requirements for each other, etc.\nA prominent example of such a system could be a machine learning project which supports multiple models, datasets and optimization techniques.\nUsually, each of these elements can be configured independently from the rest, e.g., the dataset configuration can include parameters for a common preprocessing done for this dataset regardless of what model is used.\nAnalogically, the model configuration can also be done mostly independently from the dataset in use, however, it does contain some parameters which are strictly determined by the dataset - e.g., for an image classification network that would be a number of classes for the last layer.\n\nAs mentioned before, to help dealing with situations like that, awesomeyaml is designed to work with configurations which are split into multiple files.\nFor example, following the machine learning analogy, the configuration could be split in the following way:\n\n```\n+ configs\n|   + datasets\n|   |    dataset1.yaml\n|   |    dataset2.yaml\n|   |\n|   + models\n|   |    model1.yaml\n|   |    model2.yaml\n|   |\n|   + optimizers\n|        optim1.yaml\n|        optim2.yaml\n|\n+ train.py\n```\n\nwe would like to be able to call `train.py` with a set of 3 config files by selecting any one of datasets, models and optimizers, e.g., let us train model1 with dataset2 and optimizer2:\n\n```\npython train.py configs/models/model1.yaml configs/datasets/dataset2.yaml configs/optimizers/optim2.yaml\n```\n\nor use the same setting but try a different optimizer:\n\n```\npython train.py configs/models/model1.yaml configs/datasets/dataset2.yaml configs/optimizers/optim1.yaml\n```\n\nIn both cases, the command line arguments define a sequence of config files which need to be processed to construct the final form of the config - we call this process **building** and split it into two parts: *1)* **merging** of the provided config files, and *2)* **evaluating** dynamic elements.\nThe following code snippet presents the basic idea behind building a config object:\n\n```python\ndef build_config(*yaml_sources):\n    merged_cfg = merge(yaml_sources)\n    evaluated_cfg = evaluate(merged_cfg)\n    return evaluated_cfg\n```\n\nMerging of the yaml files is handed by `awesomeyaml.Builder` and evaluation is done by `awesomeyaml.EvalContext`, with `awesomeyaml.Config` being the top-level class encapsulating both steps in a standard way presented in the code snippet above.\n\nThe following documentation is split into two parts.\nThe first talks about working with yaml files and how awesomeyaml functionality helps with that.\nThe second concerns awesomeyaml Python's API and how to achieve the behaviour explained in the first part.\n\n## Yaml side\n### Merging yaml files\n\nLet us begin by providing some examples of how the config files could look like/ For example, consider the content of the `model1.yaml` file like the following:\n\n```yaml\n---\nmodel:\n    name: MyAwesomeCNN\n    channels: 64\n    stacks: 3\n    classes: !required\n```\n\nThe file is a pretty straightforward yaml file which defines a set of parameters grouped under a common `\"model\"` key.\nThe only unusual thing is the non-standard `!required` tag - this tag is provided by awesomeyaml and can be used to identify parameters which are introduced (and required) by a specific part of the system but should be defined by other parts of the system.\nIn our case specifically, we want to say that our model needs to know how many classes are to be used but this value should be defined somewhere else (as mentioned earlier, this is defined by the choice of a dataset).\nFollowing this, we could further define the `dataset1.yaml` file as:\n```yaml\n---\ndataset:\n    name: cifar100\n    folder: ~/data/cifar100\n    process:\n        random_vflip: 0.5\n        cutout: 3\n        normalize: [[0.4914, 0.4822, 0.4465], [0.2023, 0.1994, 0.2010]]\n\nmodel:\n    classes: 100\n``` \n\nIn both cases the final config, which will be used by the training script, will be *build* by reading and *merging* the content of the consecutive config files in the provided sequence.\n\nMerging is performed by reading and combing files sequentially, strictly in a user-defined order (more about it can be found in the Python part).\nWe carefully define the rules of combing elements and provide ways of manipulating them which are explained in details later.\nHowever, the most typical (and intuitive) example would be merging of two dictionaries where elements with common keys are overwritten with their value from the newer dict and all the others are taken from either of the dicts (no elements are removed).\nThis is what would happen most of the time when merging content `model1.yaml` with `dataset1.yaml`, since both files contain mostly simple dictionaries.\nSpecifically, if the merging order is defined as:  \n`model1.yaml <- dataset1.yaml`  \nthen the content of `dataset1.yaml` will be used to update content of `model1.yaml` and the expected result would be:\n\n```yaml\n---\ndataset:\n    name: cifar100\n    folder: ~/data/cifar100\n    process:\n        random_vflip: 0.5\n        cutout: 3\n        normalize: [[0.4914, 0.4822, 0.4465], [0.2023, 0.1994, 0.2010]]\n\nmodel:\n    name: MyAwesomeCNN\n    channels: 64\n    stacks: 3\n    classes: 100\n```\n\nPlease note that the value of `model.classes` was overwritten with from the original `!required` to `100`.\nALso, please note that in general merging operation is non-commutativie, meaning that merging `A <- B` and `B <- A` can result in different outcomes.\nFor example, in our example above, if the merging order was swappedt he value `100` would be overwritten with `!required`.\n\n### Yaml streams\nYaml includes a built-in mechanism for including multiple \"files\" inside a single physical file.\nThis is achieved by separating contents with a line containing `---`.\nAwesomeyaml supports reading yaml sources with more than one \"file\" inside them - we call such entities yaml streams (the term also covers multiple yaml sources defined outside of yaml).\n\nYaml streams can be nested.\nFor example, consider a user-defined list of files: `['file1.yaml', 'file2.yaml']`.\nThis list is a yaml stream with two sources.\nNow, suppose `file1.yaml` has the following structure:\n\n```yaml\n---\n!include file3.yaml\n---\nfoo: !include [file4.yaml, file5.yaml]\n```\n\nHere, `!include` is one of the extended tags introduced by awesomeyaml.\nThe tag read content of a file and embeds it in the parent file - either as a top-level entitiy (`file3.yaml`) or as a subelement of a node (`file4.yaml` and `file5.yaml`).\nIf more than one file is provided to `!include`, the files are merged recursively before being embedded.\nPutting it all together, after considering nested stream, our example expands from a single stream of two files to nested streams which need to be merged in a correct order to eventually form a single, final config.\nThe snippet below roughly illustrates how this process progresses:\n\n```\n1. file1.yaml <- file2.yaml\n2. [file3.yaml <- { foo: [file4.yaml <- file5.yaml] }] <- file2.yaml\n3. file3.yaml <- { foo: content } <- file2.yaml\n4. final_config\n```\n\n### Evaluation of nodes\n\nApart from merging, another important aspect of awesomeyaml is support for lazily-evaluated nodes.\nThe requirement behind laziness comes from the fact that when a single yaml file is parsed - that is, before merging - the final content of the config object is not yet defined, so any node who content depends on another node's value could evaluate to an undesired value.\nThis is also one of the reasons why evaluation happens after merging is performed.\n\nConsider the following example, where we add a short section to the config file defining the experiment directory:\n\n```yaml\n---\nfs:\n    root: ~/.project\n    exp_folder: !path [!xref fs.root, !xref model.name]\n```\n\nWe define the experiment folder (`fs.exp_folder`) with respect to the root folder (`fs.root`) by appending the selected model's name.\nBy doing so, each model will have it's own experiment directory.\nObviously, we could create a deeper structure by considering other elements, like dataset, but for the purpose of this example one extra level is enough.\n\nThe `!path` node in this example is used to define and manipulate paths - in this specific case, during evaluation phase, it will try joining the two elements in its list to form the final path.\nThe `!xref` argument, on the other hand, is used to cross-reference another node in the config - that is, use its value in another place.\nBoth of these nodes are examples of nodes which are evaluated lazily.\nYou can see the reason why in the example itself - even though the first parameter in `fs.exp_folder` could be evaluated eagerly, the second one references a node which does not exist in this file - the expectation is that it will be defined later.\n\n> **Note:** For more user-friendly behaviour, the example could also set `model.name` to `!required` to make sure that the error messages are more meaningful.\n\nTherefore, eager execution would always result in an error.\nWhat is more, even if the missing value was defined, we still would like to allow the user to overwrite some of the values later.\nAll this makes the value of the entire `fs.exp_folder` undefined at the moment of parsing of the yaml file.\n\nFor more information about what nodes are executed lazily and what they do, please see the [summary of tags](#Summary-of-extended-tags).\n\n### Adding user-defined metadata\n\nAwesomeyaml allows its users to assign arbitrary metadata to any of the nodes in the config - this is done by (ab)using yaml tag mechanism.\nAt the core level, metadata are stored as a postfix to any tag which contains hex-encoded result of pickling python literals - this tag suffix can potentially be added to any other tag.\n\n> **Note:** although not directly enforced, official support for metadata is only limited to the cases where the top level element is a `dict`. You can try encoding other literals and there's a chance that everything will be fine (since internally metadata are unused), but we do not guarantee anything. Also, as explained later, our syntax extension only supports `dict` types.\n\nTo further explain the process of encoding metadata, consider the following yaml file which extend the previous example with some caching parameters:\n```yaml\n---\nfs:\n    root: ~/.project\n    exp_folder: !path [!xref fs.root, !xref model.name]\n    cache: !path [ !xref fs.root, cache ]\n    cache_size: 16GB\n    caching_policy: lru\n```\n\nLet's say, that the `fs.caching_policy` is an argument expecting one of the following values: `['lru', 'fifo', 'filo']` and the user would like to embed this information (to later handle validation of the passed value) in a form of the following metadata dict:\n```python\n{ 'available_options': ['lru', 'fifo', 'filo'] }\n```\n\nIn order to form a valid yaml document, the python code defining the metadata needs to be encoded by pickling the desired value and encoding the resulting stream of bytes using hexadecimal literals.\nFor the example above, this goes roughly like:\n```python\nimport pickle\nmetadata = { 'available_options': ['lru', 'fifo', 'filo'] }\nencoded = pickle.dumps(metadata).hex()\nprint(encoded)\n# prints '80037d71005811000000617661696c61626c655f6f7074696f6e7371015d71022858030000006c7275710358040000006669666f7104580400000066696c6f710565732e'\n```\n\nAfter the encoded metadata are obtained, they can be added to any tag as a suffix, separated by `:` from the main tag.\nSince in the example above the target node does not have any tag, we can add a simple `!metadata` tag which does nothing except serving as a way to add metadata\nto an otherwise standard node.\nThe final form would then look like:\n```yaml\nfs:\n    root: ~/.project\n    cache: !path [ !xref fs.root, cache ]\n    cache_size: 16GB\n    caching_policy: !metadata:80037d71005811000000617661696c61626c655f6f7074696f6e7371015d71022858030000006c7275710358040000006669666f7104580400000066696c6f710565732e lru\n```\n\nAlthough, encoding metadata in this form has the benefit of being compatible with standard yaml, it is obvious that this form is neither easy to write nor read by humans.\nTherefore, even though at its core awesomeyaml will use the aforementioned mechanism to store and read metadata, it also provides a human-friendly way of defining metadata by extending yaml syntax a little bit.\nSpecifically, instead of using `!tag:encoded_metadata` syntax, the user can: `!tag{{ metadata }}` non-standard syntax, where `metadata` is content of the metadata dict in plain python.\n\nUsing the extended metadata syntax, the example above becomes:\n```yaml\nfs:\n    root: ~/.project\n    cache: !path [ !xref fs.root, cache ]\n    cache_size: 16GB\n    caching_policy: !metadata{{ 'available_options': ['lru', 'fifo', 'filo'] }} lru\n```\n\n## Python side\n### Basic usage\n\nFollowing the example command lines above, the desired behaviour could be achieved by using `awesomeyaml.Config.build` static method, for example:\n\n\n```python\n# train.py\nimport awesomeyaml as ay\n\ncfg = ay.Config.build('configs/models/model1.yaml',\n    'configs/datasets/dataset2.yaml',\n    'configs/optimizers/optim2.yaml')\n```\n\nor, in a more generic way:\n\n```python\n# train.py\nimport sys\nimport awesomeyaml as ay\n\ncfg = ay.Config.build(*sys.argv[1:])\n```\n\n### Handling command-line arguments\n\nPlease note that awesomeyaml does not perform any sophisticated command line parsing, so the example above with `sys.argv` can easily break it.\nSpecifically, the `awesomeyaml.Config.build` method expects all its arguments to be either of:\n - a filename\n - a file object\n - yaml string\n\nBecause of that, it's advised to use `argparse` to extract arguments which are meaningful for awesomeyaml and preprocess the rest independently.\n\nHowever, there is one extra thing awesomeyaml is capable of with regard to command line processing - it can construct valid yaml from one-liners which can be used to overwrite a specific value. Consider the following example: we'd like to train `model1` with `dataset2` and `optim2` (as in the examples before) but we want to experiment with different number of channels. It is impractical to create a new config file each time we want to change just a single value, so we try to overwrite the default values by appending some yaml to the command line:\n\n```bash\n# try the model with 16 channels, instead of 64\npython train.py configs/models/model1.yaml configs/datasets/dataset2.yaml configs/optimizers/optim2.yaml \"model: { channels: 16 }\"\n```\n\nThe example above works by first merging content defined in the files and then with the content defined with inlined yaml.\nHowever, specifying a full yaml structure to simply overwrite a single value introduce unnecessary burden and makes it hard to quickly change some values from the command line.\nTherefore, the user is free to use a shorted form where the target node is specified with syntax similar to accessing attributes of the evaluated config (see [below](#Accessing-evaluated-fields)) and its new value is given after `=`.\nFor example, the number of channels in our previous example could be overwriten with:\n```bash\nmodel.channels=16\n```\n\n> **Note:** It is important to make sure that the entire expression is passed as a single argument. This can be achieved by either not putting spaces around `=` or using quotes.\n\nHowever, expressions like the one above are not valid yaml and hence cannot be used directly with `awesomeyaml.Config.build`.\nInstead, awesomeyaml provides another function `awesomeyaml.Config.build_from_cmdline` which is capable of identifying and transforming those expressions into their full-yaml form (like the one in the first example) suitable to be given to the standard `build` function.\n\nSee [quick reference](#Quick-reference) for a short example of how handling of the command line arguments could be done.\n\n### Accessing evaluated fields\n\nAwesomeyaml implements the [bunch](https://pypi.org/project/bunch/) pattern for all its `dict`-like objects, including the main config object.\nTherefore, after the config object is built, its content can be accessed either by using standard indexing operator (like normal `dict`) or through attribute names.\nFollowing our example from above, the following lines are analogical:\n```python\nobj1 = cfg['a']\nobj2 = cfg.a\nassert obj1 is obj2\n```\nThe bunch pattern is applied recursively to all dictionaries so it's possible to chain attributes.\n\nHowever, using the bunch pattern introduces certain problems.\nSpecifically, because it is possible in Python to shadow methods and other class-level attributes with instance-level attributes, it is fairly easy to introduce undesired conficts between attributes introduced by reading the user's config file and either internal or external API of awesomeyaml's entities.\n\nFor example, [ComposedNode](awesomeyaml/nodes/composed.py) class, which is the base class for both lists and dicts within awesomeyaml, provides a common interface for iterating and manipulating sub-nodes of a node. One of the methods introduced by this class is called `children` and can be used to simply iterate over sub-nodes.\nHowever, it is quite likely that a key `\"children\"` would appear inside the user's config file,\ne.g., if the config file describes some tree-like structure.\nIn that case, any code which would access `obj.children` with the intention of calling the awesomeyaml function would instead access the value read from the config file, most likely resulting in an error.\n\nTo avoid name conflicts and still be able to use the bunch pattern, we decided to introduce two rules:\n - the bunch pattern does not pick up names starting with `_`, that means that any internal method, attribute etc. can be safely accessed by its names; from the end-user's perspective, that also means that if a name starting with an `_` appears in the `.yaml` file, it can only be accessed by the standard indexing operator, e.g.: `cfg['_some_field']`\n - all other methods and attributes which are part of the awesomeyaml API are put under `ayns` namespace - in order to access them, one needs to go through the proxy called `ayns`, e.g. to access the previously mentioned `children` method, the relevant call would look like: `cfg.ayns.children()`\n > **Note:** it is still possible to shadow `ayns` name with a value from a config file as there are no checks to prevent this, therefore the user should be careful about (not) using this name - including it in a config file would result in undefined behaviour.\n\n\n## Summary of extended tags\nThis section includes a brief summary of the new tags introduced by awesomeyaml, each with a short description and a link to more information.\nPlease note that many tags supports more than one syntax and the behaviour of some can be achieved in different way than using the tag.\nIn either case, more information can always be found in the provided link to documentation.\n\n> **Note:** For the links to work, please [generate html documentation](#generating-documentation)\n\n| Tag | Description | Doc |\n|-|-|-|\n| `!append [list]` | Appends to an existing list on merge | [AppendNode](docs/build/html/awesomeyaml.nodes.append.html) |\n| `!bind:name { args }` | Binds arguments `args` to a python entity called `name` | [BindNode](docs/build/html/awesomeyaml.nodes.bind.html) |\n| `!call:name { args }` | Calls a python entity called `name` with arguments `args` | [CallNode](docs/build/html/awesomeyaml.nodes.call.html) |\n| `!eval code` | Evaluates arbitrary python `code` | [EvalNode](docs/build/html/awesomeyaml.nodes.eval.html) |\n| `!fstr str` | Evaluates an f-string expression `str` | [FStrNode](docs/build/html/awesomeyaml.nodes.fstr.html) |\n| `!import name` | Embeds a python entity called `name` | [ImportNode](docs/build/html/awesomeyaml.nodes.import.html) |\n| `!include file` | Includes another config `file` recursively | [IncludeNode](docs/build/html/awesomeyaml.nodes.include.html) |\n| `!path:ref [joins]` | Computes a path, starting with a reference point `ref` and then following a list of folders in `joins` | [PathNode](docs/build/html/awesomeyaml.nodes.path.html) |\n| `!prev node` | Moves the content of `node` to a new place on merge | [PrevNode](docs/build/html/awesomeyaml.nodes.prev.html) |\n| `!required` | Specifies that a value should be provided later | [RequiredNode](docs/build/html/awesomeyaml.nodes.required.html) |\n| `!xref node` | Cross-references another node | [XRefNode](docs/build/html/awesomeyaml.nodes.xref.html) |\n| `!null` | Evaluates to `None` | N/A |\n| `!metadata:str` | Embeds metadata encoded in `str` to a node | [Metadata]() |\n| `!weak` | Changes a node's priority to low | [Merging]() |\n| `!force` | Changes a node's priority to high | [Merging]() |\n| `!del` | Replaces the content of a matching node on merge | [Merging]() |\n| `!merge` | Merges the content of a matching node on merge | [Merging]() |\n\n\n## Contributing\n\nAll contributions are welcome, please open a pull request with your changes!\n\nIf a substantial change is accepted and merged into the codebase the author might be asked to own contributed pieces of code and become responsible for reviewing/maintaining those parts.\nLack of commitment to fulfil this obligation might result in reverting any changes, arbitrary changes of ownership, or any other actions deemed necessary to allow for healthy development of the package.\n\nWhen making your changes, please follow the coding style used throughout the project (PEP-8).\n\n\n## Reporting issues\n\nPlease open an issue on GitHub and provide minimal failing example, together with information about the specific version of the package (ideally git commit), Python version, pyyaml version, libyaml version (if used), and OS used.\n\n\n## License\n\nThe package is released under Apache License 2.0.\nSee LICENSE file for more information.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "https://github.com/SamsungLabs/awesomeyaml",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/SamsungLabs/awesomeyaml",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "awesomeyaml",
    "package_url": "https://pypi.org/project/awesomeyaml/",
    "platform": null,
    "project_url": "https://pypi.org/project/awesomeyaml/",
    "project_urls": {
      "Download": "https://github.com/SamsungLabs/awesomeyaml",
      "Homepage": "https://github.com/SamsungLabs/awesomeyaml"
    },
    "release_url": "https://pypi.org/project/awesomeyaml/1.1.0.post1/",
    "requires_dist": [
      "pyyaml (>=5.1)"
    ],
    "requires_python": ">=3.6.0",
    "summary": "Config-building utilities using YAML",
    "version": "1.1.0.post1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17513238,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2639210074379c9205129c5c8e28b284e7aea4098f3b4594481ef119b871c69a",
          "md5": "f7935b89a824fe2cdbe98ad7d9eef0d6",
          "sha256": "162c5d7de4a744d07ee70b57f69e6f7b2a6a1ff650e827ceeedadd2d4316101c"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f7935b89a824fe2cdbe98ad7d9eef0d6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 73655,
        "upload_time": "2022-09-12T13:13:09",
        "upload_time_iso_8601": "2022-09-12T13:13:09.750961Z",
        "url": "https://files.pythonhosted.org/packages/26/39/210074379c9205129c5c8e28b284e7aea4098f3b4594481ef119b871c69a/awesomeyaml-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "370fd9a47fc1841cbbe854ffd45cd12344f083a57758266832487996f65878fe",
          "md5": "88d8424df3eafc6274e5cd2d910a6e94",
          "sha256": "f6d4bfd89c8015a0cde36c1455c357a002eecbb655749146c89d3c0627e36b44"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "88d8424df3eafc6274e5cd2d910a6e94",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.0",
        "size": 64007,
        "upload_time": "2022-09-12T13:13:12",
        "upload_time_iso_8601": "2022-09-12T13:13:12.103658Z",
        "url": "https://files.pythonhosted.org/packages/37/0f/d9a47fc1841cbbe854ffd45cd12344f083a57758266832487996f65878fe/awesomeyaml-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "14e1d08cec8c9411e6561e72a72e9adda5c2f81446d4039cb1dfd8c7d95e7505",
          "md5": "b77551cc9ec2f1473a02468c0e5cae24",
          "sha256": "bd92c2f0a828dc824c891286661187937f19b309d43fea30831de969fa374596"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b77551cc9ec2f1473a02468c0e5cae24",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 73985,
        "upload_time": "2022-10-10T15:20:59",
        "upload_time_iso_8601": "2022-10-10T15:20:59.927456Z",
        "url": "https://files.pythonhosted.org/packages/14/e1/d08cec8c9411e6561e72a72e9adda5c2f81446d4039cb1dfd8c7d95e7505/awesomeyaml-1.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "46be4984a70bf86f476d7f008cad0d16332f08d57d5209b52f2ddc0d038ee587",
          "md5": "0a942e41e992ca2531a1732f8c493629",
          "sha256": "edf47100c799a92f63d8eb346a4854358ab95cabe8de42d19a1b6012bf384542"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "0a942e41e992ca2531a1732f8c493629",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.0",
        "size": 64310,
        "upload_time": "2022-10-10T15:21:03",
        "upload_time_iso_8601": "2022-10-10T15:21:03.923035Z",
        "url": "https://files.pythonhosted.org/packages/46/be/4984a70bf86f476d7f008cad0d16332f08d57d5209b52f2ddc0d038ee587/awesomeyaml-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bf70ff32ba4569da76327d2610606a59f6e320b42a84d177e7624a31a313fdef",
          "md5": "60a0eab5d7092d4efc34fb780eca0e4e",
          "sha256": "9dddbcd0eaacd99fe03be8240a71200e128558530b314b7261e940ecf931390b"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "60a0eab5d7092d4efc34fb780eca0e4e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 74030,
        "upload_time": "2022-10-18T13:21:35",
        "upload_time_iso_8601": "2022-10-18T13:21:35.329700Z",
        "url": "https://files.pythonhosted.org/packages/bf/70/ff32ba4569da76327d2610606a59f6e320b42a84d177e7624a31a313fdef/awesomeyaml-1.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7b4f4e42daa1e4f74846560baa124483efe06204183389dfa7e85c3598900ffc",
          "md5": "cff18781a0a3bf03ec27d7d670bb7f96",
          "sha256": "354f7c29247b3e209ca616b23a4ccf5b9df45fb4cf104f2a728f6d322d849cca"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "cff18781a0a3bf03ec27d7d670bb7f96",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.0",
        "size": 64388,
        "upload_time": "2022-10-18T13:21:38",
        "upload_time_iso_8601": "2022-10-18T13:21:38.044150Z",
        "url": "https://files.pythonhosted.org/packages/7b/4f/4e42daa1e4f74846560baa124483efe06204183389dfa7e85c3598900ffc/awesomeyaml-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2a7313de0931baca27ad12e41b06ad97a55209109b82e0edda1967f986152e72",
          "md5": "50ced548b1a101d27fa8fc63cca0f7a2",
          "sha256": "662921f54c33d25069722dd4541eae756568f09518c8f4bbab3ff12c24ad7a97"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "50ced548b1a101d27fa8fc63cca0f7a2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 84688,
        "upload_time": "2023-03-30T16:10:10",
        "upload_time_iso_8601": "2023-03-30T16:10:10.307660Z",
        "url": "https://files.pythonhosted.org/packages/2a/73/13de0931baca27ad12e41b06ad97a55209109b82e0edda1967f986152e72/awesomeyaml-1.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "70300d760b169a8148e12a25c88f8450dbf3b4878d69496aef2610337446c5ef",
          "md5": "41397b85a0b445ccbc4db5e79f00d03a",
          "sha256": "49c9cb4e49a6613b5aae0c222aa675bafa96f3530306e84f3eef024e53a5e935"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "41397b85a0b445ccbc4db5e79f00d03a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.0",
        "size": 73772,
        "upload_time": "2023-03-30T16:10:12",
        "upload_time_iso_8601": "2023-03-30T16:10:12.202311Z",
        "url": "https://files.pythonhosted.org/packages/70/30/0d760b169a8148e12a25c88f8450dbf3b4878d69496aef2610337446c5ef/awesomeyaml-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0.post1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "60be7b726e065ce0fb19153a802539ea3da42926bd658acb7bbfd0d82f73bafe",
          "md5": "57c6424a482f05d0343f5abead934bf2",
          "sha256": "f0c18ebee737e1a5e31870731ccddad3ab1a1b4565668a56d99438fcc0ebe266"
        },
        "downloads": -1,
        "filename": "awesomeyaml-1.1.0.post1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "57c6424a482f05d0343f5abead934bf2",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.0",
        "size": 84954,
        "upload_time": "2023-03-30T16:36:12",
        "upload_time_iso_8601": "2023-03-30T16:36:12.033621Z",
        "url": "https://files.pythonhosted.org/packages/60/be/7b726e065ce0fb19153a802539ea3da42926bd658acb7bbfd0d82f73bafe/awesomeyaml-1.1.0.post1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "60be7b726e065ce0fb19153a802539ea3da42926bd658acb7bbfd0d82f73bafe",
        "md5": "57c6424a482f05d0343f5abead934bf2",
        "sha256": "f0c18ebee737e1a5e31870731ccddad3ab1a1b4565668a56d99438fcc0ebe266"
      },
      "downloads": -1,
      "filename": "awesomeyaml-1.1.0.post1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "57c6424a482f05d0343f5abead934bf2",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6.0",
      "size": 84954,
      "upload_time": "2023-03-30T16:36:12",
      "upload_time_iso_8601": "2023-03-30T16:36:12.033621Z",
      "url": "https://files.pythonhosted.org/packages/60/be/7b726e065ce0fb19153a802539ea3da42926bd658acb7bbfd0d82f73bafe/awesomeyaml-1.1.0.post1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}