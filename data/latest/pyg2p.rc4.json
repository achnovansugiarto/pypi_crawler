{
  "info": {
    "author": "Domenico Nappo",
    "author_email": "domenico.nappo@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Developers",
      "Intended Audience :: Education",
      "Intended Audience :: Financial and Insurance Industry",
      "Intended Audience :: Other Audience",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: European Union Public Licence 1.2 (EUPL 1.2)",
      "Operating System :: MacOS :: MacOS X",
      "Operating System :: Microsoft :: Windows",
      "Operating System :: POSIX",
      "Operating System :: Unix",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering :: Physics"
    ],
    "description": "[ChangeLog](CHANGE_LOG.rst)\n\n\n# pyg2p\npyg2p is a converter between GRIB and netCDF4/PCRaster files. \nIt can also manipulates GRIB messages (performing aggregation or simple unit conversion) before to apply format conversion.\n\n## Installation\n\nTo install package, you can use a python virtual environment or directly install dependencies and\npackage at system level (executable script will be saved into /usr/local/bin in this case).\n\n>IMPORTANT: Before to launch setup, you need the following steps:\n\n>Install eccodes: this can be done compiling from source code or using the available conda virtual environment package by running \n\n```bash\n$ conda install -c conda-forge eccodes\n```\n\n>Configure geopotentials and intertables paths in\nconfiguration/global/global_conf.json. These paths are used by pyg2p to read\ngeopotentials and intertables already configured. You may need to download files from FTP (launch `pyg2p -W` for this). \nUsers running pyg2p installed by a different user (ie. root) will configure similar paths for their own intertables \nand geopotentials under his home folder. These paths will need write permissions.\n\n\n\nGrab last archive and extract it in a folder (or clone this repository) and follow these steps:\n\n```bash\n$ cd pyg2p\n$ vim configuration/global/global_conf.json # to edit shared paths !!!\n$ python setup.py install\n```\n\nAfter installation, you will have all dependencies installed and an executable script 'pyg2p' (in a\nvirtual environment, script is located under <VIRTUALENV_PATH>/bin folder otherwise under\n/usr/local/bin). To check correct installation of eccodes run the following command: \n\n```bash\n$ python -m eccodes selfcheck\n```\n\nSome python packages can be problematic to install at first shot. Read\nfollowing paragraph for details.\n\n## Configuration\n\nOne of the things to configure for any user running pyg2p, is GEOPOTENTIALS and INTERTABLES\nvariables with paths to folders with write permissions.\n\n>NOTE: From version 2.1, the user needs to setup these variables only if she/he\nneeds to write new interpolation tables (option -B [-X]) or to add new\ngeopotentials from grib files (option -g).\n\nThese variables contains user paths and must be configured in a .conf file (e.g. paths.conf) under\n~/.pyg2p/ directory. This can look like:\n\n```text\nGEOPOTENTIALS=/dataset/pyg2p_data_user/geopotentials\nINTERTABLES=/dataset/pyg2p_data_user/intertables\n```\n\nUser intertables (for interpolation) are read/write from `INTERTABLES` and geopotentials (for\ncorrection) are read from `GEOPOTENTIALS`.\nPyg2p will use its default configuration for available intertables and geopotentials. These are read\nfrom paths configured during installation in global_conf.json.\nIf you need to download default files from ECMWF FTP, just launch pyg2p with -W option and the\ndataset argument (argument can be *geopotentials* or *intertables*) and files are saved in user\npaths configured above:\n\n```bash\n$ pyg2p -W intertables\n```\n\nYou can edit FTP authentication parameters in *~/.pyg2p/ftp.json*\n\n### Advanced configuration\n\nUser json configuration files are empty. If you need a new parameter or geopotential that is not\nconfigured internally in pyg2p, you can setup new items (or overwrite internal configuration).\n\n#### Adding a parameter to ~/.pyg2p/parameters.json\n\nIf you are extracting a parameter with shortName xy from a grib file that is not already globally\nconfigured, add an element as shown below (only part in bold has been added):\n\n\n```json\n{\n  \"xy\": {\n    \"@description\": \"Variable description\",\n    \"@shortName\": \"xy\",\n    \"@unit\": \"unitstring\"\n  }\n}\n```\n\nYou can configure (more than) a conversion element with different ids and functions. You will use\nshortName and conversionId in the execution JSON templates.\n\n\n```json\n{\n    \"xy\": { \"@description\": \"Variable description\",\n    \"@shortName\": \"xy\",\n    \"@unit\": \"unitstring\"\n    },\n    \"xyz\": {\n    \"@description\": \"Variable description\",\n    \"@shortName\": \"xyz\",\n    \"@unit\": \"unitstring/unistring2\",\n    \"Conversion\": [\n        {\n        \"@cutOffNegative\": true,\n        \"@function\": \"x=x*(-0.13)**2\",\n        \"@id\": \"conv_xyz1\",\n        \"@unit\": \"g/d\"\n        },\n        {\n        \"@cutOffNegative\": true,\n        \"@function\": \"x=x/5466 - (x**2)\",\n        \"@id\": \"conv_xyz2\",\n        \"@unit\": \"g/h\"\n        }\n      ]\n    }\n}\n```\n\n>Note: Aware the syntax of conversion functions. They must start with x= followed\nby the actual conversion formula where x is the value to convert. Units are only\nused for logging.\n\n#### Adding a geopotential for correction\n\nIf the input grib file has a geopotential message, pyg2p will use it for correction. Otherwise, it will\nread the file from user data paths or global data paths.\nTo add a geopotential GRIB file to pyg2p configuration, use this command:\n\n```bash\n$ pyg2p -g path_to_geopotential_grib\n```\n\nThis will copy the file to folder defined in `GEOPOTENTIALS` variable and will update\ngeopotentials.json with the new item.\n\n#### Interpolation tables\n\nInterpolation tables are read from user or global data folders.\nIf the table is missing, it will create it into user data folder for future interpolations (you must pass\n-B option to pyg2p).\nDepending on source and target grids size, and on interpolation method, table creation can take\nfrom minutes to days. To speed up interpolation table creation, use parallel option -X to have up to\nx6 speed gain.\n\n### Execution templates\n\nExecution templates are JSON files that you will use to configure a conversion. You will pass path to\nthe file to pyg2p with command line option `-c`.\nMost of options can be both defined in this JSON file and from command line. \n**Note that command line options overwrite JSON template.**\n\nIf you have a large set of conversions for same parameters, it's more convenient to define a single\ntemplate where you define parameter, interpolation and aggregation and pass the rest of parameters from command line.\nHere some examples of JSON commands files:\n\n```json\n{\n    \"Execution\": {\n        \"@name\": \"Octahedral test 1\",\n        \"Aggregation\": {\n            \"@step\": 24,\n            \"@type\": \"average\"\n        },\n        \"OutMaps\": {\n            \"@cloneMap\": \"/dataset/maps/europe5km/dem.map\",\n            \"@ext\": 1,\n            \"@fmap\": 1,\n            \"@namePrefix\": \"t2\",\n            \"@unitTime\": 24,\n            \"Interpolation\": {\n                \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n                \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n                \"@mode\": \"grib_nearest\"\n            }\n        },\n        \"Parameter\": {\n            \"@applyConversion\": \"k2c\",\n            \"@correctionFormula\": \"p+gem-dem*0.0065\",\n            \"@demMap\": \"/dataset/maps/europe5km/dem.map\",\n            \"@gem\": \"(z/9.81)*0.0065\",\n            \"@shortName\": \"2t\"\n        }\n    }\n}\n```\n\nThere are four sections of configuration.\n\n#### Aggregation\nDefines the aggregation method and step. Method can be `accumulation`, `average` or `instantaneous`.\n\n#### OutMaps\nHere you define interpolation method and paths to coordinates PCRaster maps, output unit time, the clone map etc.\n\n#### Interpolation\nThis is a subelement of OutMaps. Here you define interpolation method (see later for details), paths\nto coordinates maps.\n\n#### Parameter\nIn this section, you configure the parameter to select by using its shortName, as stored in GRIB file.\nYou also configure conversion with applyConversion property set to a conversion id. Parameter\nshortName must be already configured in `~/.pyg2p/parameters.json` along with conversion ids.\nIf you need to apply correction based on DEM files and geopotentials, you can configure formulas\nand the path to DEM map.\n\n#### Path configuration\n\nYou can use variables in JSON files to define paths. Variables can be configured in `.conf` files under\n~/.pyg2p/ folder.\n`/home/domenico/.pyg2p/myconf.conf`\n\n```console\nEUROPE_MAPS=/dataset/maps/europe5km\nDEM_MAP=/dataset/maps/dem05.map\nEUROPE_DEM=/dataset/maps/europe/dem.map\nEUROPE_LAT=/dataset/maps/europe/lat.map\nEUROPE_LON=/dataset/maps/europe/long.map\n```\n\nUsage of user defined paths in JSON command file:\n\n```json\n{ \n\"Execution\": {\n  \"@name\": \"eue_t24\",\n  \"Aggregation\": {\n    \"@step\": 24,\n    \"@type\": \"average\"\n  },\n  \"OutMaps\": {\n        \"@format\": \"netcdf\",\n        \"@cloneMap\": \"{EUROPE_MAPS}/lat.map\",\n        \"@ext\": 1,\n        \"@fmap\": 1,\n        \"@namePrefix\": \"pT24\",\n        \"@unitTime\": 24,\n        \"Interpolation\": {\n          \"@latMap\": \"{EUROPE_MAPS}/lat.map\",\n          \"@lonMap\": \"{EUROPE_MAPS}/long.map\",\n          \"@mode\": \"grib_nearest\"\n        }\n  },\n  \"Parameter\": {\n    \"@applyConversion\": \"k2c\",\n    \"@correctionFormula\": \"p+gem-dem*0.0065\",\n    \"@demMap\": \"{DEM_MAP}\",\n    \"@gem\": \"(z/9.81)*0.0065\",\n    \"@shortName\": \"2t\"\n  }\n }\n}\n```\n\n### Full list of options\n\n<table> \n    <thead> \n        <tr> \n            <th>Section</th> \n            <th>Attribute</th> \n            <th>Description</th> \n        </tr> \n    </thead>\n    <tbody>\n        <tr>\n        <td><b>Execution</b></td>\n        <td>name</td>\n        <td>Descriptive name of the execution configuration.</td>\n        </tr>\n        <tr>\n        <td></td><td><b>Parameter</b></td><td>See relative table</td>\n        </tr>\n        <tr>\n        <td></td><td><b>OutMaps</b></td><td>See relative table</td>\n        </tr>\n        <tr>\n        <td></td><td><b>Parameter</b></td><td>See relative table</td>\n        </tr>\n        <tr>\n        <td colspan=\"3\"><hr/></td>\n        </tr>\n        <tr>\n        <td><b>Parameter</b></td><td><b>shortName</b></td><td>The short name of the parameter, as it is in the grib file. The application use this to select messages. Must be configured in the parameters.json file, otherwise the application exits with an error.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>tstart</td><td rowspan=\"6\">Optional grib selectors perturbationNumber,\ntstart, tend, dataDate and dataTime can also be\nissued via command line arguments (-m, -s, -e,\n-D, -T), which overwrite the ones in the\nexecution JSON file.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>tend</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>perturbationNumber</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>dataDate</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>dataTime</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>level</td>\n        </tr>\n        <tr><td>&nbsp;</td><td>applyConversion</td><td>The conversion id to apply, as in the\nparameters.json file for the parameter to select.\nThe combination parameter/conversion must be\nproperly configured in parmaters.json file,\notherwise the application exits with an error.</td></tr>\n        <tr><td>&nbsp;</td><td>correctionFormula</td><td>Formula to use for parameter correction with p,\ngem, dem variables, representing parameter\nvalue, converted geopotential to gem, and DEM\nmap value. E.g.: p+gem*0.0065-dem*0.0065</td></tr>\n        <tr><td>&nbsp;</td><td>demMap</td><td>The dem map used for correction.</td></tr>\n        <tr><td>&nbsp;</td><td>gem</td><td>Formula for geopotential conversion for\ncorrection.</td></tr>\n        <tr>\n        <td colspan=\"3\"><hr/></td>\n        </tr>\n        <tr>\n        <td><b>OutMaps</b></td><td>cloneMap</td><td>The clone map with area (must have a REAL cell\ntype and missing values for points outside area\nof interest. A dem map works fine. A typical area boolean map will not).</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>unitTime</b></td><td>Time unit in hours of output maps. Tipical value\nis 24 (daily maps).</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>format</b></td><td>Output file format. Default 'pcraster'. Available\nformats are 'pcraster', 'netcdf'.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>namePrefix</b></td><td>Prefix for maps. Default is parameter\nshortName.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>fmap</b></td><td>First PCRaster map number. Default 1.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>Interpolation</b></td><td>See relative table.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>ext</b></td><td>Extension mode. It's the integer number\ndefining the step numbers to skip when writing maps. Same as old grib2pcraster. Default 1.</td>\n        </tr>\n        <tr>\n        <td colspan=\"3\"><hr/></td>\n        </tr>\n        <tr>\n        <td><b>Aggregation</b></td><td><b>step</b></td><td>Step of aggregation in hours.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>type</b></td><td>Type of aggregation (it was Manipulation in\ngrib2pcraster). It can be average or accumulation.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>halfweights</b></td><td>If set to True and type is \"average\", it will avaluate the average by using half weights for the first and the last step</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>forceZeroArray</td><td>Optional. In case of “accumulation”, and only\nthen, if this attribute is set to”y” (or any value different from “false”, “False”, “FALSE”, “no”,\n“NO”, “No”, “0”), the program will use a zero array as message at step 0 to compute the first\nmap, even if the GRIB file has a step 0 message.</td>\n        </tr>\n        <tr>\n        <td><b>Interpolation</b></td><td><b>mode</b></td><td>Interpolation mode. Possible values are:\n“nearest”, “invdist”, “grib_nearest”,\n“grib_invdist”</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>latMap</b></td><td>PCRaster map of target latitudes.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td><b>lonMap</b></td><td>PCRaster map of target longitudes.</td>\n        </tr>\n        <tr>\n        <td>&nbsp;</td><td>intertableDir</td><td>Alternative home folder for interpolation lookup\ntables, where pyg2p will load/save intertables. Folder must be existing. If not set, pyg2p will use intertables from ~/.pyg2p/intertables/</td>\n        </tr>\n    </tbody>\n</table>\n\n## Usage\n\nTo use the application, after the main configuration you need to configure a template JSON file for\neach type of extraction you need to perform.\n\n### Grabbing information from GRIB files.\n\nTo configure the application and compile your JSON templates, you might need to know the variable\nshortName as stored in the input GRIB file you're using or in the geopotential GRIB. Just execute the\nfollowing GRIB tool command:\n\n`grib_get -p shortName /path/to/grib`\n\nOther keys you would to know for configuration or debugging purposes are:\n* startStep\n* endStep (for instantaneous messages, it can be the same of startStep)\n* perturbationNumber (the EPS member number)\n* stepType (type of field: instantaneous: 'instant', average: 'avg', cumulated: 'cumul')\n* longitudeOfFirstGridPointInDegrees\n* longitudeOfLastGridPointInDegrees\n* latitudeOfFirstGridPointInDegrees\n* latiitudeOfLastGridPointInDegrees\n* Ni (it can be missing)\n* Nj (it states the resolution: it's the number of points along the meridian)\n* numberOfValues\n* gridType (e.g.: regular_ll, reduced_gg, rotated_ll)\n\n### Input arguments\n\nIf you run pyg2p without arguments, it shows help of all input arguments.\n\n```console\nusage: pyg2p [-h] [-c json_file] [-o out_dir] [-i input_file]\n[-I input_file_2nd] [-s tstart] [-e tend] [-m eps_member]\n[-T data_time] [-D data_date] [-f fmap] [-F format] [-x extension_step]\n[-n outfiles_prefix] [-l log_level] [-N intertable_dir] [-B] [-X]\n[-t cmds_file] [-g geopotential] [-C path] [-z path] [-W dataset]\n\nExecute the grib to pcraster conversion using parameters from the input json configuration.\nRead user manual.\n\noptional arguments:\n-h, --help show this help message and exit\n-c json_file, --commandsFile json_file\nPath to json command file\n-o out_dir, --outDir out_dir\nPath where output maps will be created.\n-i input_file, --inputFile input_file\nPath to input grib.\n-I input_file_2nd, --inputFile2 input_file_2nd\nPath to 2nd resolution input grib.\n-s tstart, --start tstart\nGrib timestep start. It overwrites the tstart in json\nexecution file.\n-e tend, --end tend Grib timestep end. It overwrites the tend in json\nexecution file.\n-m eps_member, --perturbationNumber eps_member\neps member number\n-T data_time, --dataTime data_time\nTo select messages by dataTime key value\n-D data_date, --dataDate data_date\n<YYYYMMDD> to select messages by dataDate key value\n-f fmap, --fmap fmap First map number\n-F format, --format format\nOutput format. Available options: netcdf, pcraster.\nDefault pcraster\n-x extension_step, --ext extension_step\nExtension number step\n-n outfiles_prefix, --namePrefix outfiles_prefix\nPrefix name for maps\n-l log_level, --loggerLevel log_level\nConsole logging level\n-N intertable_dir, --intertableDir intertable_dir\ninterpolation tables dir\n-B, --createIntertable\ncreate intertable file\n-X, --interpolationParallel\nUse parallelization tools to make interpolation\nfaster.If -B option is not passed or intertable\nalready exists it does not have any effect.\n-t cmds_file, --test cmds_file\nPath to a text file containing list of commands,\ndefining a battery of tests. Then it will create diff\npcraster maps and log alerts if differences are higher\nthan a threshold (edit configuration in test.json)\n-g geopotential, --addGeopotential geopotential\nAdd the file to geopotentials.json configuration file, to use for correction. The file will be copied into\nthe right folder (configuration/geopotentials) Note:\nshortName of geopotential must be \"fis\" or \"z\"\n-C path, --convertConf path\nConvert old xml configuration to new json format\n-z path, --convertIntertables path\nConvert old pyg2p intertables to new version and copy\nto user folders\n-W dataset, --downloadConf dataset\nDownload intertables and geopotentials (FTP settings\ndefined in ftp.json)\n```\n#### Usage examples:\n\n```bash\npyg2p -c ./exec1.json -i ./input.grib -o /out/dir -s 12 -e 36 -F netcdf\npyg2p -c ./exec2.json -i ./input.grib -o /out/dir -m 10 -l INFO --format netcdf\npyg2p -c ./exec3.json -i ./input.grib -I /input2ndres.grib -o /out/dir -m 10 -l DEBUG\npyg2p -g /path/to/geopotential/grib/file # add geopotential to configuration\npyg2p -t /path/to/test/commands.txt\npyg2p -h\n```\n\n```text\nNote: Even if 'netcdf' format is used for output, paths to PCRaster clone/area,\nlatitudes and longitudes maps have to be setup in any case.\n```\n\n### Check output maps\n\nAfter the execution, you can check output maps by using the PCRaster2 Aguila viewer for PCRaster\nmaps or the NASA Panoply3 viewer for NetCDF files.\n\n`aguila /dataset/testdiffmaps/eueT24/pT240000.001`\n\n![Aguila](https://raw.githubusercontent.com/ec-jrc/pyg2p/master/media/aguila.png)\n\n\n`./panoply.sh /dataset/octahedral/out/grib_vs_scipy/global/ta/p_2016-09-25_average.nc`\n\n![Panoply](https://raw.githubusercontent.com/ec-jrc/pyg2p/master/media/panoply.png)\n\nMaps will be written in the folder specified by -o input argument. If this is missing, you will find\nmaps in the folder where you launched the application (./).\nRefer to official documentation for further information about Aguila and Panoply.\n\n## Interpolation modes\n\nInterpolation is configured in JSON execution templates using the *Interpolation* attribute inside\n*OutMaps*.\nThere are four interpolation methods available. Two are using GRIB_API nearest neighbours routines\nwhile the other two leverage on Scipy kd_tree module.\n\n```text\nNote: GRIB_API does not implement nearest neighbours routing for rotated grids.\nYou have to use scipy methods and regular target grids (i.e.: latitudes and\nlongitudes PCRaster maps).\n```\n\n### Intertable creation\nInterpolation will use precompiled intertables. They will be found in the path configured in\n`INTERTABLES` folder (take into account that can potentially contains gigabytes of files) or in global\ndata path. You can also define an alternate intertables directory with -N argument (or\n*@intertableDir* attribute in JSON template).\n\nIf interlookup table doesn't exist, the application will create one into `INTERTABLES` folder and\nupdate intertables.json configuration **only if -B option is passed**, otherwise program will exit.\nBe aware that for certain combination of grid and maps, the creation of the interlookup table (which\nis a numpy array saved in a binary file) could take several hours or even days for GRIB interpolation\nmethods. \n\nTo have better performances (up to x6 of gain) you can pass -X option to enable parallel\nprocessing.\n\nPerformances are not comparable with scipy based interpolation (seconds or minutes) but this\noption could not be viable for all GRIB inputs.\n\n### GRIB/ecCodes API interpolation methods\n\nTo configure the interpolation method for conversion, set the @mode attribute in Execution/OutMaps/Interpolation property.\n\n#### grib_nearest\n\nThis method uses GRIB API to perform nearest neighbour query.\nTo configure this method, define:\n\n```json\n{\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"grib_nearest\"}\n}\n```\n\n#### grib_invdist\nIt uses GRIB_API to query for four neighbours and relative distances. It applies inverse distance\ncalculation to compute the final value.\nTo configure this method:\n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"grib_invdist\"}\n}\n```\n\n### SciPy interpolation methods\n\n#### nearest\nIt's the same nearest neighbour algorithm of grib_nearest but it uses the scipy kd_tree4 module to\nobtain neighbours and distances.\n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"nearest\"}\n}\n```\n\n#### invdist\nIt's the inverse distance algorithm with scipy.kd_tree, using 4 neighbours.\n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"invdist\"}\n}\n```\n\nAttributes p, leafsize and eps for the kd tree algorithm are default in scipy library:\n\n| Attribute | Details              |\n|-----------|----------------------|\n| p         | 2 (Euclidean metric) |\n| eps       | 0                    |\n| leafsize  | 10                   |\n\n#### bilinear\nIt's the bilinear interpolation algorithm applyied on regular and irregular grids. On irregular grids, it tries to get the best quatrilateral around each target point, but at the same time tries to use the best stable and grid-like shape from starting points. To do so, evaluates interpolation looking at point on similar latitude, thus on projected grib files may show some irregular results. \n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"bilinear\"}\n}\n```\n\n#### triangulation\nThis interpolation works on a triangular tessellation of the starting grid applying the Delaunay criteria, and the uses the linear barycentric interpolation to get the target intrpolated values. It works on all type of grib files, but for some resolutions may show some edgy shapes.\n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"triangulation\"}\n}\n```\n\n#### bilinear_delaunay\nThis algorithm merges bilinear interpolation and triangular tessellation. Quadrilaters used for the bilinear interpolation are obtained joining two adjacent triangles detected from the Delaunay triangulation of the source points. The merge is done giving priority to the ones distributed on a grid-like shape. When a quadrilateral is not available (there are no more adjacent triangles left on the grid able to merge), the linear barycentric interpolation is applyied. The result of this interpolation works smoothly and adapts automatically on all kind of source grib file. \n\n```json\n{\n\"Interpolation\": {\n  \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n  \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n  \"@mode\": \"bilinear_delaunay\"}\n}\n```\n\n## OutMaps configuration\n\nInterpolation is configured under the OutMaps tag. With additional attributes, you also configure\nresulting PCRaster maps. Output dir is ./ by default or you can set it via command line using the\noption -o (--outDir).\n\n| Attribute      | Details                                                                                                                           |\n|----------------|-----------------------------------------------------------------------------------------------------------------------------------|\n| namePrefix     | Prefix name for output map files. Default is the value of shortName key.                                                          |\n| **unitTime**   | Unit time in hours for results. This is used during aggregation operations.                                                       |\n| fmap           | Extension number for the first map. Default 1.                                                                                    |\n| ext            | Extension mode. It's the integer number defining the step numbers to skip when writing maps. Same as old grib2pcraster. Default 1.|\n| **cloneMap**   | Path to a PCRaster clone map, needed by PCRaster libraries to write a new map on disk.                                            |\n\n## Aggregation\n\nValues from grib files can be aggregated before to write the final PCRaster maps. There are two kinds of aggregation available: average and accumulation. \nThe JSON configuration in the execution file will look like:\n\n```json\n{\n\"Aggregation\": {\n  \"@type\": \"average\",\n  \"@halfweights\": False}\n}\n```\n\nTo better understand what these two types of aggregations do, the DEBUG output of execution is presented later in same paragraph.\n\n### Average\nTemperatures are often extracted as averages on 24 hours or 6 hours. Here's a typical execution configuration and the output of interest:\n\n**cosmo_t24.json**\n\n```json\n{\n\"Execution\": {\n\"@name\": \"cosmo_T24\",\n\"Aggregation\": {\n\"@step\": 24,\n\"@type\": \"average\",\n\"@halfweights\": False\n},\n\"OutMaps\": {\n\"@cloneMap\": \"/dataset/maps/europe/dem.map\",\n\"@ext\": 4,\n\"@fmap\": 1,\n\"@namePrefix\": \"T24\",\n\"@unitTime\": 24,\n\"Interpolation\": {\n\"@latMap\": \"/dataset/maps/europe/lat.map\",\n\"@lonMap\": \"/dataset/maps/europe/lon.map\",\n\"@mode\": \"nearest\"\n}\n},\n\"Parameter\": {\n\"@applyConversion\": \"k2c\",\n\"@correctionFormula\": \"p+gem-dem*0.0065\",\n\"@demMap\": \"/dataset/maps/europe/dem.map\",\n\"@gem\": \"(z/9.81)*0.0065\",\n\"@shortName\": \"2t\"\n}\n}\n}\n\n```\n\n**Command**\n`pyg2p -l DEBUG -c /execution_templates/cosmo_t24.json -i /dataset/cosmo/2012111912_pf10_t2.grb -o ./cosmo -m 10`\n\n**ext parameter**\next value will affect numbering of output maps:\n\n```console\n[2013-07-12 00:06:18,545] :./cosmo/T24a0000.001 written!\n[2013-07-12 00:06:18,811] :./cosmo/T24a0000.005 written!\n[2013-07-12 00:06:19,079] :./cosmo/T24a0000.009 written!\n[2013-07-12 00:06:19,349] :./cosmo/T24a0000.013 written!\n[2013-07-12 00:06:19,620] :./cosmo/T24a0000.017 written!\n```\n\nThis is needed because we performed 24 hours average over 6 hourly steps.\n\n**Details about average parameters:**\n\nThe to evaluate the average, the following steps are executed:\n\n- when \"halfweights\" is False, the results of the function is the sum of all the values from \"start_step-aggregation_step+1\" to end_step, taking for each step the value corresponding to the next available value in the grib file. E.g:\n\n  INPUT: start_step=24, end_step=<not specified, will take the end of file>, aggregation_step=24\nGRIB File: contains data starting from step 0 to 48 every 6 hours: 0,6,12,18,24,30,....\n\n  Day 1: Aggregation starts from 24-24+1=1, so it will sum up the step 6 six times, then the step 12 six times, step 18 six times, and finally the step 24 six times. The sum will be divided by the aggretation_step (24) to get the average.\n\n  Day 2: same as Day 1 starting from (24+24)-24+1=25...\n\n- when \"halfweights\" is True, the results of the function is the sum of all the values from \"start_step-aggregation_step\" to end_step, taking for each step the value corresponding to the next available value in the grib file but using half of the weights for the first and the last step in each aggregation_step cicle. E.g:\n\n  INPUT: start_step=24, end_step=<not specified, will take the end of file>, aggregation_step=24\nGRIB File: contains data starting from step 0 to 72 every 6 hours: 0,6,12,18,24,30,36,....\n\n  Day 1: Aggregation starts from 24-24=0, and will consider the step 0 value multiplied but 3, that is half of the number of steps between two step keys in the grib file. Then it will sum up the step 6 six times, then the step 12 six times, step 18 six times, and finally the step 24 again multiplied by 3. The sum will be divided by the aggretation_step (24) to get the average.\n\n  Day 2: same as Day 1 starting from (24+24)-24=24: the step 24 will have a weight of 3, while steps 30,36 and 42 will be counted 6 times, and finally the step 48 will have a weight of 3. \n\n- if start_step is zero or is not specified, the aggregation will start from 1\n\n### Accumulation\nFor precipitation values, accumulation over 6 or 24 hours is often performed. Here's an example of configuration and execution output in DEBUG mode.\n\n**dwd_r06.json**\n\n```json\n\n{\"Execution\": {\n\"@name\": \"dwd_rain_gsp\",\n\"Aggregation\": {\n\"@step\": 6,\n\"@type\": \"accumulation\"\n},\n\"OutMaps\": {\n\"@cloneMap\": \"/dataset/maps/europe/dem.map\",\n\"@fmap\": 1,\n\"@namePrefix\": \"pR06\",\n\"@unitTime\": 24,\n\"Interpolation\": {\n\"@latMap\": \"/dataset/maps/europe/lat.map\",\n\"@lonMap\": \"/dataset/maps/europe/lon.map\",\n\"@mode\": \"nearest\"\n}\n},\n\"Parameter\": {\n\"@shortName\": \"RAIN_GSP\",\n\"@tend\": 18,\n\"@tstart\": 12\n}\n}\n}\n```\n\n**Command**\n`pyg2p -l DEBUG -c /execution_templates/dwd_r06.json -i /dataset/dwd/2012111912_pf10_tp.grb -o ./cosmo -m 10`\n\n**Output**\n```console\n[2013-07-11 23:33:19,646] : Opening the GRIBReader for\n/dataset/dwd/grib/dwd_grib1_ispra_LME_2012111900\n[2013-07-11 23:33:19,859] : Grib input step 1 [type of step: accum]\n[2013-07-11 23:33:19,859] : Gribs from 0 to 78\n...\n...\n[2013-07-11 23:33:20,299] : ******** **** MANIPULATION **** *************\n[2013-07-11 23:33:20,299] : Accumulation at resolution: 657\n[2013-07-11 23:33:20,300] : out[s:6 e:12 res:657 step-lenght:6] = grib:12 - grib:6 *\n(24/6))\n[2013-07-11 23:33:20,316] : out[s:12 e:18 res:657 step-lenght:6] = grib:18 - grib:12 *\n(24/6))\n```\n\n```text\nNote: If you want to perform accumulation from Ts to Te with an aggregation step\nTa, and Ts-Ta=0 (e.g. Ts=6h, Te=48h, Ta=6h), the program will select the first\nmessage at step 0 if present in the GRIB file, while you would use a zero values\nmessage instead.\nTo use a zero values array, set the attribute forceZeroArray to ”true” in the\nAggregation configuration element.\nFor some DWD5 and COSMO6 accumulated precipitation files, the first zero message is\nan instant precipitation and the decision at EFAS was to use a zero message, as it\nhappens for UKMO extractions, where input GRIB files don't have a first zero step\nmessage.\n```\n\n```bash\ngrib_get -p units,name,stepRange,shortName,stepType 2012111912_pf10_tp.grb\n\nkg m**-2 Total Precipitation 0 tp instant\nkg m**-2 Total Precipitation 0-6 tp accum\nkg m**-2 Total Precipitation 0-12 tp accum\nkg m**-2 Total Precipitation 0-18 tp accum\n...\n...\nkg m**-2 Total Precipitation 0-48 tp accum\n```\n\n## Correction\n\nValues from grib files can be corrected with respect to their altitude coordinate (Lapse rate\nformulas). Formulas will use also a geopotential value (to read from a GRIB file, see later in this\nchapter for configuration).\nCorrection has to be configured in the Parameter element, with three mandatory attributes.\n\n* correctionFormula (the formula used for correction, with input variables parameter value (p), gem, and dem value.\n* gem (the formula to obtain gem value from geopotential z value)\n* demMap (path to the DEM PCRaster map)\n\n`Note: formulas must be written in python notation.`\n\nTested configurations are only for temperature and are specified as follows:\n\n**Temperature correction**\n\n```json\n{\n\"Parameter\": {\n  \"@applyConversion\": \"k2c\",\n  \"@correctionFormula\": \"p+gem-dem*0.0065\",\n  \"@demMap\": \"/dataset/maps/europe/dem.map\",\n  \"@gem\": \"(z/9.81)*0.0065\",\n  \"@shortName\": \"2t\"}\n}\n```\n\n**A more complicated correction formula:**\n\n```json\n{\n\"Parameter\": {\n  \"@applyConversion\": \"k2c\",\n  \"@correctionFormula\": \"p/gem*(10**((-0.159)*dem/1000))\",\n  \"@demMap\": \"/dataset/maps/europe/dem.map\",\n  \"@gem\": \"(10**((-0.159)*(z/9.81)/1000))\",\n  \"@shortName\": \"2t\"}\n}\n```\n\n### How to write formulas\n\n**z** is the geopotential value as read from the grib file\n**gem** is the value resulting from the formula specified in gem attribute I.e.: (gem=\"(10**((-0.159)*(z/9.81)/1000)))\"\n**dem** is the dem value as read from the PCRaster map\n\nBe aware that if your dem map has directions values, those will be replicated in the final map.\n\n### Which geopotential file is used?\n\nThe application will try to find a geopotential message in input GRIB file. If a geopotential message\nis not found, pyg2p will select a geopotential file from user or global data paths, by selecting\nfilename from configuration according the geodetic attributes of GRIB message. If it doesn't find\nany suitable grib file, application will exit with an error message.\n\nGeodetic attributes compose the key id in the JSON configuration (note the $ delimiter):\n\n`longitudeOfFirstGridPointInDegrees$longitudeOfLastGridPointInDegrees$Ni$Nj$numberOfValues$gridType`\n\nIf you want to add another geopotential file to the configuration, just execute the command:\n\n`pyg2p -g /path/to/geopotential/grib/file`\n\nThe application will copy the geopotential GRIB file into `GEOPOTENTIALS` folder (under user home directory) \nand will also add the proper JSON configuration to geopotentials.json file.\n\n## Conversion\n\nValues from GRIB files can be converted before to write final output maps. Conversions are\nconfigured in the parameters.json file for each parameter (ie. shortName).\n \nThe right conversion formula will be selected using the id specified in the *applyConversion* attribute, and the shortName\nattribute of the parameter that is going to be extracted and converted.\n\nRefer to Parameter configuration paragraph for details.\n\n## Logging\n\nConsole logger level is INFO by default and can be optionally set by using **-l** (or **–loggerLevel**)\ninput argument.\n\nPossible logger level values are ERROR, WARN, INFO, DEBUG, in increasing order of verbosity .\n\n## pyg2p API\nFrom version 1.3, pyg2p comes with a simple API to import and use from other python programs\n(e.g. pyEfas).\nThe pyg2p API is intended to mimic the pyg2p.py script execution from command line so it provides\na Command class with methods to set input parameters and a *run_command(cmd)* module level function to execute pyg2p.\n\n### Setting execution parameters\n\n1. Create a pyg2p command:\n\n```python\nfrom pyg2p.main import api\ncommand = api.command()\n```\n\n2. Setup execution parameters using a chain of methods (or single calls):\n\n```python\ncommand.with_cmdpath('a.json')\ncommand.with_inputfile('0.grb')\ncommand.with_log_level('ERROR').with_out_format('netcdf')\ncommand.with_outdir('/dataout/').with_tstart('6').with_tend('24').with_eps('10').with_fmap('1')\ncommand.with_ext('4')\nprint(str(command))\n'pyg2p.py -c a.json -e 240 -f 1 -i 0.grb -l ERROR -m 10 -o /dataout/test -s 6 -x 4 -F netcdf'\n```\n\nYou can also create a command object using the input arguments as you would do when execute pyg2p from command line:\n\n```python\nargs_string = '-l ERROR -c /pyg2p_git/execution_templates_devel/eue_t24.json -i /dataset/test_2013330702/EpsN320-2013063000.grb -o /dataset/testdiffmaps/eueT24 -m 10'\ncommand2 = api.command(args_string)\n```\n\n### Execute\n\nUse the run_command function from pyg2p module. This will delegate the main method, without\nshell execution.\n\n```python\nret = api.run_command(command)\n```\n\nThe function returns the same value pyg2p returns if executed from shell (0 for correct executions,\nincluded those for which messages are not found).\n\n### Adding geopotential file to configuration\n\nYou can add a geopotential file to configuration from pyg2p API as well, using Configuration classes:\n\n```python\nfrom pyg2p.main.config import UserConfiguration, GeopotentialsConfiguration\nuser=UserConfiguration()\ngeopotentials=GeopotentialsConfiguration(user)\ngeopotentials.add('path/to/geopotential.grib')\n```\nThe result will be the same as executing `pyg2p -g path/to/geopotential.grib`.\n\n### Using API to bypass I/O\n\nSince version 3.1, pyg2p has a more usable api, useful for programmatically convert values\n\nHere an example of usage:\n\n```python\nfrom pyg2p.main.api import Pyg2pApi, ApiContext\n\nconfig = {\n        'loggerLevel': 'ERROR',\n        'inputFile': '/data/gribs/cosmo.grib',\n        'fmap': 1,\n        'start': 6,\n        'end': 132,\n        'perturbationNumber': 2,\n        'intertableDir': '/data/myintertables/',\n        'geopotentialDir': '/data/mygeopotentials',\n        'OutMaps': {\n            'unitTime': 24,\n            'cloneMap': '/data/mymaps/dem.map',\n            'Interpolation': {\n                \"latMap\": '/data/mymaps/lat.map',\n                \"lonMap\": '/data/mymaps/lon.map',\n                \"mode\": \"nearest\"\n            }\n        },\n\n        'Aggregation': {\n            'step': 6,\n            'type': 'average'\n        },\n        'Parameter': {\n            'shortName': 'alhfl_s',\n            'applyConversion': 'tommd',\n        },\n    }\n\nctx = ApiContext(config)\napi = Pyg2pApi(ctx)\nvalues = api.execute()\n```\n\nThe `values` variable is an ordered dictionary with keys of class `pyg2p.Step`, which is simply a tuple of (start, end, resolution_along_meridian, step, level))\nEach value of the dictionary is a numpy array representing a map of the converted variable for that step.\nFor example, the first value would correspond to a PCRaster map file <var>0000.001 generated and written by pyg2p when executed normally via CLI.\n\nCheck also this code we used in tests to validate API execution against CLI execution with same parameters:\n\n```python\nimport numpy as np\nfrom pyg2p.main.readers import PCRasterReader\nfor i, (step, val) in enumerate(values.items(), start=1):\n    i = str(i).zfill(3)\n    reference = PCRasterReader(f'/data/reference/cosmo/E06a0000.{i}')).values\n    diff = np.abs(reference - val)\n    assert np.allclose(diff, np.zeros(diff.shape), rtol=1.e-2, atol=1.e-3, equal_nan=True)\n```\n\n\n## Appendix A - Execution JSON files examples\n\nThis paragraph will explain typical execution json configurations.\n\n### Example 1: Correction with dem and geopotentials\n\n```shell script\npyg2p -c example1.json -i /dataset/cosmo/2012111912_pf2_t2.grb -o ./out_1\n```\n\n**example1.json**\n```json\n{\n  \"Execution\": {\n    \"@name\": \"eue_t24\",\n    \"Aggregation\": {\n      \"@step\": 24,\n      \"@type\": \"average\"\n    },\n    \"OutMaps\": {\n      \"@cloneMap\": \"{EUROPE_MAPS}/lat.map\",\n      \"@ext\": 1,\n      \"@fmap\": 1,\n      \"@namePrefix\": \"pT24\",\n      \"@unitTime\": 24,\n      \"Interpolation\": {\n        \"@latMap\": \"{EUROPE_MAPS}/lat.map\",\n        \"@lonMap\": \"{EUROPE_MAPS}/long.map\",\n        \"@mode\": \"grib_nearest\"\n      }\n    },\n    \"Parameter\": {\n        \"@applyConversion\": \"k2c\",\n        \"@correctionFormula\": \"p+gem-dem*0.0065\",\n        \"@demMap\": \"{DEM_MAP}\",\n        \"@gem\": \"(z/9.81)*0.0065\",\n        \"@shortName\": \"2t\"\n    }\n  }\n}\n```\n\nThis configuration, will select the 2t parameter from time step 0 to 12, out of a cosmo t2 file. \nValues will be corrected using the dem map and a geopotential file as in geopotentials.json configuration.\n\nMaps will be written under ./out_1 folder (the folder will be created if not existing yet). The clone map is set as same as dem.map. \n\n>Note that paths to maps uses variables `EUROPE_MAPS` and `DEM_MAP`. \n>You will set these variables in myconf.conf file under ~/.pyg2p/ folder.\n\nThe original values will be converted using the conversion “k2c”. This conversion must be\nconfigured in the parameters.json file for the variable which is being extracted (2t). See Parameter\nproperty configuration at Parameter.\nThe interpolation method is grib_nearest. Latitudes and longitudes values will be used only if the\ninterpolation lookup table (intertable) hasn't be created yet but it's mandatory to set latMap and\nlonMap because the application uses their metadata raster attributes to select the right intertable.\nThe table filename to be read and used for interpolation is automatically found by the application,\nso there is no need to specify it in configuration. However, lat and lon maps are mandatory\nconfiguration attributes.\n\n### Example 2: Dealing with multiresolution files\n\n```shell script\npyg2p -c example1.json -i 20130325_en0to10.grib -I 20130325_en11to15.grib -o ./out_2\n```\n\nPerforms accumulation 24 hours out of sro values of two input grib files having different vertical\nresolutions. You can also feed pyg2p with a single multiresolution file.\n\n```shell script\npyg2p -c example1.json -i 20130325_sro_0to15.grib o ./out_2 -m 0\n```\n\n```json\n{\n  \"Execution\": {\n    \"@name\": \"multi_sro\",\n    \"Aggregation\": {\n      \"@step\": 24,\n      \"@type\": \"accumulation\"\n    },\n    \"OutMaps\": {\n      \"@cloneMap\": \"/dataset/maps/global/dem.map\",\n      \"@fmap\": 1,\n      \"@namePrefix\": \"psro\",\n      \"@unitTime\": 24,\n      \"Interpolation\": {\n        \"@latMap\": \"/dataset/maps/global/lat.map\",\n        \"@lonMap\": \"/dataset/maps/global/lon.map\",\n        \"@mode\": \"grib_nearest\"\n      }\n    },\n    \"Parameter\": {\n      \"@applyConversion\": \"m2mm\",\n      \"@shortName\": \"sro\",\n      \"@tend\": 360,\n      \"@tstart\": 0\n    }\n  }\n}\n```\n\nThis execution configuration will extract global overlapping messages sro (perturbation number 0)\nfrom two files at different resolution.\nValues will be converted using “tomm” conversion and maps (interpolation used here is\ngrib_nearest) will be written under ./out_6 folder.\n\n### Example 3: Accumulation 24 hours\n\n```shell script\n./pyg2p.py -i /dataset/eue/EpsN320-2012112000.grb -o ./out_eue -c execution_file_examples/execution_9.json\n```\n\n```json\n{\n  \"Execution\": {\n    \"@name\": \"eue_tp\",\n    \"Aggregation\": {\n      \"@step\": 24,\n      \"@type\": \"accumulation\"\n    },\n    \"OutMaps\": {\n      \"@cloneMap\": \"/dataset/maps/europe5km/lat.map\",\n      \"@fmap\": 1,\n      \"@namePrefix\": \"pR24\",\n      \"@unitTime\": 24,\n      \"Interpolation\": {\n        \"@latMap\": \"/dataset/maps/europe5km/lat.map\",\n        \"@lonMap\": \"/dataset/maps/europe5km/long.map\",\n        \"@mode\": \"grib_nearest\"\n      }\n    },\n    \"Parameter\": {\n      \"@applyConversion\": \"tomm\",\n      \"@shortName\": \"tp\"\n    }\n  }\n}\n```\n\n## Appendix B – Netcdf format output\n\n```prettier\nFormat: NETCDF4_CLASSIC.\nConvention: CF-1.6\nDimensions:\n        xc: Number of rows of area/clone map\n        yc: Number of cols of area/clone map\n        time: Unlimited dimension for time steps\nVariables:\n        lon: 2D array with shape (yc, xc)\n        lat: 2D array with shape (yc, xc)\n        time_nc: 1D array of values representing hours since dataDate of first grib message (endStep)\n        values_nc: a 3D array of dimensions (time, yc, xc), with coordinates set to 'lon, lat'.\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "NetCDF GRIB PCRaster Lisflood EFAS GLOFAS",
    "license": "EUPL 1.2",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pyg2p",
    "package_url": "https://pypi.org/project/pyg2p/",
    "platform": null,
    "project_url": "https://pypi.org/project/pyg2p/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/pyg2p/3.2.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Convert GRIB files to netCDF or PCRaster",
    "version": "3.2.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16946916,
  "releases": {
    "3.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "86cc3099bb12f61c7596c0e34058f410f0139628ee6deca0b679ca613a7261ca",
          "md5": "dc26507d45abab9953c519c6649d407d",
          "sha256": "b453c37fd33f582ae20af25905abf6a010e01bd247c7dabc8f1a217ecd7ce67f"
        },
        "downloads": -1,
        "filename": "pyg2p-3.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "dc26507d45abab9953c519c6649d407d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 80064,
        "upload_time": "2019-12-18T15:58:17",
        "upload_time_iso_8601": "2019-12-18T15:58:17.343635Z",
        "url": "https://files.pythonhosted.org/packages/86/cc/3099bb12f61c7596c0e34058f410f0139628ee6deca0b679ca613a7261ca/pyg2p-3.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0b643e702206affc1e010f9b8918e05aaab1cf04eb11bdc469868276da4e3d01",
          "md5": "5a8936c7e58a7cfaf7605a050aff9e21",
          "sha256": "bce4f01aa7da1f1a6bdf3ca97ec5a695d16ccd73e7213ef8b2ae00ec76fa8ad6"
        },
        "downloads": -1,
        "filename": "pyg2p-3.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5a8936c7e58a7cfaf7605a050aff9e21",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 85453,
        "upload_time": "2020-03-24T17:41:52",
        "upload_time_iso_8601": "2020-03-24T17:41:52.884014Z",
        "url": "https://files.pythonhosted.org/packages/0b/64/3e702206affc1e010f9b8918e05aaab1cf04eb11bdc469868276da4e3d01/pyg2p-3.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "35b031dbf1aeeb7e6ef591a9dd4fc7c8988aa08dfd962ba7a5e6bd2c6482f23a",
          "md5": "3575af97dd6dc6d023655d29a4422a98",
          "sha256": "490d749b19c2ab2e975bcb656818189860e7c18ce95bc482672caffe7ab679a3"
        },
        "downloads": -1,
        "filename": "pyg2p-3.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "3575af97dd6dc6d023655d29a4422a98",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 104417,
        "upload_time": "2023-02-15T12:58:02",
        "upload_time_iso_8601": "2023-02-15T12:58:02.263459Z",
        "url": "https://files.pythonhosted.org/packages/35/b0/31dbf1aeeb7e6ef591a9dd4fc7c8988aa08dfd962ba7a5e6bd2c6482f23a/pyg2p-3.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c87df35088a28ac82cc75c97bc592c7683a1e437bffba4a5f27812bcd4d8c5c4",
          "md5": "3a1d48a08e434a3c8739660e804c4dc2",
          "sha256": "81f5552cec1fbce7741700ae0f77124fb0a8c51d63e84d284b7fe6dd59cb7068"
        },
        "downloads": -1,
        "filename": "pyg2p-3.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "3a1d48a08e434a3c8739660e804c4dc2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 109125,
        "upload_time": "2023-02-20T17:34:28",
        "upload_time_iso_8601": "2023-02-20T17:34:28.892593Z",
        "url": "https://files.pythonhosted.org/packages/c8/7d/f35088a28ac82cc75c97bc592c7683a1e437bffba4a5f27812bcd4d8c5c4/pyg2p-3.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c87df35088a28ac82cc75c97bc592c7683a1e437bffba4a5f27812bcd4d8c5c4",
        "md5": "3a1d48a08e434a3c8739660e804c4dc2",
        "sha256": "81f5552cec1fbce7741700ae0f77124fb0a8c51d63e84d284b7fe6dd59cb7068"
      },
      "downloads": -1,
      "filename": "pyg2p-3.2.2.tar.gz",
      "has_sig": false,
      "md5_digest": "3a1d48a08e434a3c8739660e804c4dc2",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 109125,
      "upload_time": "2023-02-20T17:34:28",
      "upload_time_iso_8601": "2023-02-20T17:34:28.892593Z",
      "url": "https://files.pythonhosted.org/packages/c8/7d/f35088a28ac82cc75c97bc592c7683a1e437bffba4a5f27812bcd4d8c5c4/pyg2p-3.2.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}