{
  "info": {
    "author": "Daniel L. Bates",
    "author_email": "danbates@verizon.net",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# puff_Trc Package\n### An alternate method to interface to tracing.\nA different approach to accomplish what is in the standard library documentation as:\n>Debugging and profiling -> trace -> Programmatic Interface.        last 0.1.3 20220112\n\n### Author: Dan Bates\n## The singleton class Puff\nA singleton class \"Puff\" to provide interfaces to the code tracing magic in Python.\nThese interfaces to filter tracing to a list of function names. And/Or to show only\ncalls and returns. Or a maximum call depth.\nTo focus on one module at a time, and omit tracing outside that module. A\nMeans of turning the trace On, Off, and resuming it.  \n\nA means of communicating a predicate function to Puff to evaluate at every line, and\nstopping via an assert False when this function triggers by returning True.  \n\nA means of providing lists of locals, nonlocals and global variables to be displayed\nevery time they are modified.  \n\nA trace that calls attention to any non-sequential change in line number.  \n\nA trace object of class Puff has these interfaces:  \n```\nTrc = puff_Trc()\nTrc.focus(module name or module filename)\nTrc.On(nest=100, lines=None, funcs=None, callsonly=False)\nTrc.Off()\nTrc.Resume()\nTrc.StopWhen(condition_function)\nTrc.Watch(lcls=IsNot, globs=IsNot, nonlcls=IsNot) where IsNot is an internal None\n```\nThis is Puff the magic Debugging Dragon.  \n\nOf Course an example/testing frame Honalee.py is provided.  \n\nWhere else can a Magic Dragon live than in Honalee.  \n\nThis is very much through the looking glass.  \n## The Trc.focus member.\n```\nUsage puff_Trc.Puff().focus(__file__)\nor\nfocus(module.__file__)\n```\nFocus the trace (allow the trace) only on one module at a time and\nthat module cannot be puff_Trc.\n\n## The Trc.On member.\n```\nTrc.On(nest=100, lines=None, funcs=None, callsonly=False)\n```\nnest is an int which is the maximum level of call nesting to print\nthe trace for. A value of -1 indidcates no limit for call nesting.  \n\nlines can be an int representing the single line number to be traced.\nlines can also be a list of two ints representing a range of line\nnumbers. Line numbers are the most transiant measure to control the\ntrace, but they are available.  \n\nfuncs is either a function reference or the function name as a string,\nor a list of function references, or a list of function names as\nstrings.  \n\ncallsonly is a boolean. Set to True only shows calls/returns in the\ntrace. Set to False means trace everything.  \n\n## The Trc.Off member.\n```\nTrc.Off() \n```\nStops the trace.\n\n## The Trc.Resume member.\n```\nTrc.Resume()\n```\ncontinues a trace printing with no changes to\nthe trace parameters in effect on the preceding Trc.Off().\n\n## The Trc.StopWhen member.\n```\nTrc.StopWhen(stoptestfunc) \n```\nGives a reference to a predicate function\nwhich returns True when an event occurs where you want the state\nof the program preserved. The function should be optimized for the\npath that returns False.\n\nThis call mustbe made after the Trc.On().\n\nThe function must be valid to execute in any environment. Variables must\nremain in scope.\n\nThe function may be a lambda function, but it need not be. it can take the\nform:\n```\ndef StopTheWorld():\n    if not <stop the world condition>:\n        return False\n    <other processing>\n```\nWhere other processing can be a smart dump of the state or a breakpoint()\n\n## The Trc.Watch member.\n```\nTrc.Watch(lcls=IsNot, globs=IsNot, nonlcls=IsNot)\n```\nTells puff what variables to watch for modifications to.\nIdeally variables will not fall out of scope. If they do we\ndo not monitor them.  \n\nVariable that are local are in the lcls list, The global variables are in the\nglobs list and nonlocals in the nonlcls list.  \n\nVariables must be simple, a good list would be like \"x, y, z\"\nThis part while useful is not bullet proof.  \n\n## Sample Output\n```\n  \"c:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\"\n*** Puff trace focused on module file :\n\t C:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\n***Tracing On, nest = 1 lines =None funcs = None callsonly = False\nwaiting on you\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\nIn baz\n\t\t\t*** return from \"baz\" ***\n\t\t\t*** return from \"foo\" ***\n***Tracing On, nest = 2 lines =None funcs = None callsonly = False\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\n\t\t\t*** \"baz\" called ***\nHonahLee.py(25):     print (\"In baz\")\nIn baz\n\t\t\t*** return from \"baz\" ***\n\t\t\t*** return from \"foo\" ***\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n5\nHonahLee.py(29):     if n > 0:\nHonahLee.py(30):         recurse(n-1)\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n4\nHonahLee.py(29):     if n > 0:\nHonahLee.py(30):         recurse(n-1)\n3\n2\n1\n0\nHit Bottom\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n***Tracing On, nest = 100 lines =None funcs = ['foo'] callsonly = False\nwaiting on you A !\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\nIn baz\n***Tracing On, nest = 100 lines =None funcs = ['baz'] callsonly = False\nwaiting on you B !\n\t\t\t*** \"baz\" called ***\nHonahLee.py(25):     print (\"In baz\")\nIn baz\n\t\t\t*** return from \"baz\" ***\n***Tracing On, nest = 100 lines =None funcs = ['foo', 'baz'] callsonly = False\nwaiting on you C !\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\n\t\t\t*** \"baz\" called ***\nHonahLee.py(25):     print (\"In baz\")\nIn baz\n\t\t\t*** return from \"baz\" ***\n\t\t\t*** return from \"foo\" ***\n5\n4\n3\n2\n1\n0\nHit Bottom\n***Tracing Off\n***Tracing Resumed\nwaiting on you D !\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\n\t\t\t*** \"baz\" called ***\nHonahLee.py(25):     print (\"In baz\")\nIn baz\n\t\t\t*** return from \"baz\" ***\n\t\t\t*** return from \"foo\" ***\n***Tracing On, nest = 100 lines =None funcs = None callsonly = False\nwaiting on you E !\n\t***** Only tracing line 21\n\t\t\t*** \"foo\" called ***\nHonahLee.py(19):     x = 5\nHonahLee.py(20):     y = 12\nHonahLee.py(21):     z = 2*x+y\nHonahLee.py(22):     baz()\n\t\t\t*** \"baz\" called ***\nHonahLee.py(25):     print (\"In baz\")\nIn baz\n\t\t\t*** return from \"baz\" ***\n\t\t\t*** return from \"foo\" ***\n***Tracing On, nest = 100 lines =None funcs = ['jack', 'recurse'] callsonly = False\nwaiting on you F !\n\t\t\t*** \"jack\" called ***\nHonahLee.py(35):     recurse(3)\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n3\nHonahLee.py(29):     if n > 0:\nHonahLee.py(30):         recurse(n-1)\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n2\nHonahLee.py(29):     if n > 0:\nHonahLee.py(30):         recurse(n-1)\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n1\nHonahLee.py(29):     if n > 0:\nHonahLee.py(30):         recurse(n-1)\n\t\t\t*** \"recurse\" called ***\nHonahLee.py(28):     print(n)\n0\nHonahLee.py(29):     if n > 0:\nLine number sequence break\t...\nHonahLee.py(32):         print('Hit Bottom')\nHit Bottom\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"jack\" ***\n***Tracing On, nest = 100 lines =None funcs = None callsonly = True\nwaiting on you G  !\n\t\t\t*** \"jack\" called ***\n\t\t\t*** \"recurse\" called ***\n3\n\t\t\t*** \"recurse\" called ***\n2\n\t\t\t*** \"recurse\" called ***\n1\n\t\t\t*** \"recurse\" called ***\n0\nHit Bottom\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"recurse\" ***\n\t\t\t*** return from \"jack\" ***\n*** Watch Puff.lcls={'x': IsNot, 'y': IsNot, 'z': IsNot}\n*** Watch Puff.globs={'idx': IsNot}\n***Tracing On, nest = 100 lines =None funcs = None callsonly = False\n\t\t\t*** \"jill\" called ***\n\t>>>>>>> global idx initially set to 0\nHonahLee.py(39):     print(\"Entered jill\")\nEntered jill\nHonahLee.py(40):     oldidx = idx\nHonahLee.py(41):     for x in range(3):\n\t>>>>>>> local x initially set to 0\nHonahLee.py(42):         idx += 1\n\t>>>>>>> global idx was 0 is now set to 1\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y initially set to 0\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z initially set to 100\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 0 is now set to 1\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 100 is now set to 101\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 1 is now set to 2\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 101 is now set to 102\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\nLine number sequence break\t...\nHonahLee.py(41):     for x in range(3):\n\t>>>>>>> local x was 0 is now set to 1\nHonahLee.py(42):         idx += 1\n\t>>>>>>> global idx was 1 is now set to 2\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 2 is now set to 0\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 102 is now set to 210\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 0 is now set to 1\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 210 is now set to 211\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 1 is now set to 2\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 211 is now set to 212\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\nLine number sequence break\t...\nHonahLee.py(41):     for x in range(3):\n\t>>>>>>> local x was 1 is now set to 2\nHonahLee.py(42):         idx += 1\n\t>>>>>>> global idx was 2 is now set to 3\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 2 is now set to 0\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 212 is now set to 320\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 0 is now set to 1\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 320 is now set to 321\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\n\t>>>>>>> local y was 1 is now set to 2\nHonahLee.py(44):             z = idx * 100 + x * 10 + y\n\t>>>>>>> local z was 321 is now set to 322\nLine number sequence break\t...\nHonahLee.py(43):         for y in range(3):\nLine number sequence break\t...\nHonahLee.py(41):     for x in range(3):\nLine number sequence break\t...\nHonahLee.py(45):     idx = oldidx\n\t\t\t*** return from \"jill\" ***\n\t>>>>>>> global idx was 3 is now set to 0\n*** Puff not watching variables\n***Tracing Off\n***Tracing On, nest = 100 lines =None funcs = ['opossum'] callsonly = False\nwaiting on you H  !\n***Trace and target execution stop when condition is True\n\t\t\t*** \"opossum\" called ***\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\nopossum on iteration 0\nLine number sequence break\t...\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\nopossum on iteration 1\nLine number sequence break\t...\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\nopossum on iteration 2\nLine number sequence break\t...\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\nopossum on iteration 3\nLine number sequence break\t...\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\nopossum on iteration 4\nLine number sequence break\t...\nHonahLee.py(15):     for idx in range(10):\nHonahLee.py(16):         print(\"opossum on iteration\", idx)\n***Trace and execution ends because of StopWhen\nTraceback (most recent call last):\n  File \"C:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\", line 107, in <module>\n    showall()\n  File \"C:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\", line 101, in showall\n    opossum()\n  File \"C:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\", line 16, in opossum\n    print(\"opossum on iteration\", idx)\n  File \"C:\\my\\PythonPackages\\puff_Trc\\HonahLee.py\", line 16, in opossum\n    print(\"opossum on iteration\", idx)\n  File \"C:\\my\\PythonPackages\\puff_Trc\\puff_Trc.py\", line 191, in smalltrace\n    assert False, \"***Puff had a StopWhen return True\"\nAssertionError: ***Puff had a StopWhen return True\n```\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/DanLBates/puff_Trc",
    "keywords": "'Trace','Debug','Debug Aid','Progmatic Interface Trace'",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "puff-Trc",
    "package_url": "https://pypi.org/project/puff-Trc/",
    "platform": "",
    "project_url": "https://pypi.org/project/puff-Trc/",
    "project_urls": {
      "Homepage": "https://github.com/DanLBates/puff_Trc"
    },
    "release_url": "https://pypi.org/project/puff-Trc/0.1.3/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "An alternate Programmatic Interface for tracing.",
    "version": "0.1.3",
    "yanked": true,
    "yanked_reason": null
  },
  "last_serial": 12568230,
  "releases": {
    "0.1.2": [],
    "0.1.3": []
  },
  "urls": [],
  "vulnerabilities": []
}