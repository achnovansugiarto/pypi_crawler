{
  "info": {
    "author": "Luca Zavarella, Greta Villa",
    "author_email": "lucazavarella@outlook.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Intended Audience :: Other Audience",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9"
    ],
    "description": "# binclass-tools: Binary Classification Tools for Python At Your Fingertips\n\n<img src=\"/resources/images/logo.png\" width=\"600\" height=\"200\" />\n\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/binclass-tools)\n[![GitHub license](https://img.shields.io/github/license/lucazav/binclass-tools)](https://github.com/lucazav/binclass-tools/blob/main/LICENSE)\n![GitHub release (latest by date)](https://img.shields.io/github/v/release/lucazav/binclass-tools?color=orange)\n[![Downloads](https://static.pepy.tech/personalized-badge/binclass-tools?period=total&units=international_system&left_color=grey&right_color=magenta&left_text=Downloads)](https://pepy.tech/project/binclass-tools)\n\nA set of Python wrappers and interactive plots that facilitate the analysis of binary classification problems.\n\n---\n\nThe __binclass-tools__ package makes the following available to you:\n\n* Powerful interactive charts that simplify the analysis of a binary classifier's performance, including calibration and any amounts and costs associated with individual observations.\n\n* A set of functions that return the values of metrics useful for measuring the performance of a binary classifier, for each threshold value if dependent on it.\n\n* A set of functions to find the optimal threshold value calculated on both the most popular metrics associated with the binary classifier under analysis, and any costs associated with each of the 4 categories in the confusion matrix.\n\n* A set of generic wrappers that help the analyst in daily operations dealing with binary classifications.\n\nOn [Towards Data Science](https://towardsdatascience.com/) you will find the following article describing the theory behind all the functions of the package and the path that led me to create a package for analyzing binary classifications that also included calculating optimal threshold values for specific metrics:\n\n[Finding the Best Classification Threshold for Imbalanced Classifications with the Interactive Confusion Matrix and Line Charts](https://medium.com/towards-data-science/finding-the-best-classification-threshold-for-imbalanced-classifications-with-interactive-plots-7d65828dda38)\n\n## Quick Start\n\n### Requirements and Installation\n\nThe project is based on:\n* Python 3.6+\n* A set of the most popular packages used for working with data\n* Plotly for interactive plots\n\nIf you do not have Python, install it first. Then, in your favorite conda or virtual environment, simply do:\n\n```\npip install binclass-tools\n```\n\nor, if you want to install the development version directly from github:\n\n\n```\npip install git+https://github.com/lucazav/binclass-tools\n```\n\n## New from version 1.0.0: \n**plotting functions' behaviour**: from version 1.0.0, the behavior of functions that generate plots has changed: Figure (Plotly) objects, dictionary-like, will be returned and not shown directly when the function is called. \n\n## New from version 1.1.0: \n**optimal thresholds returned in the confusion matrix plot**: from version 1.1.0 the optimal thresholds dataframe will correspond to the thresholds that give the best value of the implemented metrics (or the minimal Cost) for the given set of data.\n\nThe functions that implement the GHOST method to compute optimal thresholds are still available (renamed).\nFor more details please check New Release description.\n\n## Example Usage\n\nLet's import both the usual libraries needed to work with the data and the binclass-tools one:\n\n```python\nimport numpy as np\nimport pandas as pd\nimport bctools as bc\n```\n\nIn addition, since we will train a classifier on randomly generated data via RandomForest, let's also import some useful functions for the purpose:\n\n```python\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\n```\n\nLet's then train our model that we will use as a classifier to analyse thanks to the functions of _binclass-tools_:\n\n```python\n# Generate a binary imbalanced classification problem, with 80% zeros and 20% ones.\nX, y = make_classification(n_samples=1000, n_features=20,\n                           n_informative=14, n_redundant=0,\n                           random_state=12, shuffle=False, weights = [0.8, 0.2])\n\n# Train - test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, stratify = y, random_state=0)\n\n# Train a RF classifier\ncls = RandomForestClassifier(max_depth=6, oob_score=True)\ncls.fit(X_train, y_train)\n```\n\nHaving trained the model, let's calculate the estimated probabilities of the predictions obtained from the training and testing datasets:\n\n```python\n# Get prediction probabilities for the train set\ntrain_predicted_proba = cls.predict_proba(X_train)[:,1]\n\n# Get prediction probabilities for the test set\ntest_predicted_proba = cls.predict_proba(X_test)[:,1] \n```\nLet's generate some known graphs with the functions in the binclass-tools package to check the overall behavior of the model on the test set.\nNote that it's possible to customize the main title and choose whether to display the plotly bar mode through the parameters `title` and `show_display_modebar` in every graphical function of this library.\n\nWe can start by visualizing the _Receiver Operating Characteristic (ROC) Curve_, using the following function, which also returns the value of the area under the curve:\n\n```python\nROC_plot, area_under_ROC = bc.curve_ROC_plot(true_y = y_test, \n                                             predicted_proba = test_predicted_proba)\nROC_plot  #or ROC_plot.show(), both work \n```\n\nWhich returns the plot:\n\n![ROC Curve for the Test Set](/resources/images/01-ROC-curve-test.png)\n\nand returns the AUC value:\n\n```python\n>>> area_under_ROC\n0.9748427672955975\n```\n\nNext, you can visualize the _Precision-Recall (PR) Curve_ plot with the iso-Fbeta curves. \nFirst, let's recall the definition of the F-beta score: it is the weighted harmonic mean of precision and recall, reaching its optimal value at 1 and its worst value at 0.\nThe beta parameter determines the weight of recall in the combined score. beta < 1 lends more weight to precision, while beta > 1 favors recall.\nAn iso-Fbeta curve thus contains, by definition, all points in the precision-recall space whose F-beta scores are equal. \nThe function `curve_PR_plot` allows us to display ISO curves associated with F-beta score values of 0.2, 0.4, 0.6 and 0.8. The function takes as input the `beta` parameter (set to 1 as default value):\n\n```python\nPR_plot, area_under_PR = bc.curve_PR_plot(true_y = y_test, \n                                          predicted_proba = test_predicted_proba,\n                                          beta = 1)\nPR_plot\n```\n\nHere the plot returned:\n\n![Precision-Recall Plot with isoF1 Curves for the Test Set](/resources/images/02-PR-isoF1-plot-test.png)\n\nThis function also returns, as in the ROC curve case, the value of the area under the curve:\n```python\n>>> area_under_PR \n0.9295134692043583\n```\n\nFor a more in-depth analysis of the model's predicted probabilities, we can visualize through violin plots the distribution of the probabilities grouped by the relative true class and, for each threshold, see whether the predicted probability for each data point generates a correct prediction or not.\nThe following binclass-tools function performs the tasks just mentioned, taking as input the size of the step separating one threshold value from the other (always considering the extremes 0 and 1 inclusive):\n\n```python\nthreshold_step = 0.05\n\nviolin_plot = bc.predicted_proba_violin_plot(true_y = y_test, \n                                             predicted_proba = test_predicted_proba, \n                                             threshold_step = threshold_step)\nviolin_plot                                           \n```\n\nHere the interactive plot returned:\n\n![Interactive Probabilities Violin Plot for the Test Set](/resources/images/03-interactive-violin-plot-test.png)\n\nAnother useful tool to visualize the probabilities density is the `predicted_proba_density_curve_plot` function, that plots for each true class either the kernel density estimation curve (default) or the normal distribution curve, depending on the `curve_type` parameter. For each threshold, that can be selected through a slider, we can see the regions that are correctly or incorrectly classified:\n\n```python\nthreshold_step = 0.05\ncurve_type = 'kde' #'kde' is the default value, can also be set to 'normal'\n\ndensity_curve_kde = bc.predicted_proba_density_curve_plot(true_y = y_test, \n                                                          predicted_proba = test_predicted_proba, \n                                                          threshold_step = threshold_step,\n                                                          curve_type = curve_type)\ndensity_curve_kde                                                          \n```\n\nHere the returned plot:\n\n![Interactive Probabilities Density Plot for the Test Set](/resources/images/04-interactive-density-plot-test.png)\n\nAfterwards, we can conduct a more detailed analysis of the model's performance.\nLet's set up a set of variables to pass as parameters in the subsequent binclass-tools functions we will use. \nWe are going to do first an analysis of how the model performs on the training dataset, these are the variables we will need:\n\n* The size of the step separating one threshold value from the other (always considering the extremes 0 and 1 inclusive).\n\n* The list of individual amounts associated with each of the observables in the test dataset (since the dataset is generated by random values, the absolute value of column 13 is considered as the amount column).\n\n* Which currency symbol to use.\n\n* The dictionary of costs associated with each of the 4 categories of the confusion matrix. It is possible to associate a single numerical value to be considered as the average cost for each observation in that category, or a list of values to be associated with each observation. Clearly, the length of the lists in the dictionary must all be the same length, equal to the number of observations in the dataset under analysis (in our case the test dataset).\n\nSpecifically, you have this:\n\n```python\n# set params for the train dataset\nthreshold_step = 0.05\namounts = np.abs(X_train[:, 13])\ncurrency = '$'\n\n# The function get_cost_dict can be used to define the dictionary of costs.\n# It takes as input, for each class, a float or a list of floats. \n# Lists must have coherent lenghts \n\ntrain_cost_dict = bc.get_cost_dict(TN = 0, FP = 10, FN = np.abs(X_train[:, 12]), TP = 0)\n```\n\nAt this point we can visualize the _Interactive Confusion Matrix_ on the training dataset, including the optimal threshold for all the available metrics:\n\n```python\ncf_fig, var_metrics_df, invar_metrics_df, opt_thresh_df = bc.confusion_matrix_plot(\n    true_y = y_train, \n    predicted_proba = train_predicted_proba, \n    threshold_step = threshold_step, \n    amounts = amounts, \n    cost_dict = train_cost_dict, \n    currency = currency,\n    random_state = 123,\n    title = 'Interactive Confusion Matrix for the Training Set')\ncf_fig\n```\n\nHere the figure returned:\n\n![Interactive Confusion Matrix for the Training Set](/resources/images/05-interactive-confusion-matrix-train.png)\n\nAs you can see, the interactive confusion matrix plot also returns metrics related dataframes that can be used in your code if needed. One is the _threshold dependent metrics dataframe_:\n\n|    |   threshold |   accuracy |   balanced_accuracy |   cohens_kappa |   f1_score |   matthews_corr_coef |   precision |   recall |\n|---:|------------:|-----------:|--------------------:|---------------:|-----------:|---------------------:|------------:|---------:|\n|  0 |        0    |     0.2025 |              0.5    |         0      |     0.3368 |               0      |      0.2025 |   1      |\n|  1 |        0.05 |     0.3988 |              0.623  |         0.1168 |     0.4025 |               0.249  |      0.2519 |   1      |\n|  2 |        0.1  |     0.7475 |              0.8417 |         0.4664 |     0.616  |               0.5515 |      0.4451 |   1      |\n|  3 |        0.15 |     0.8988 |              0.9365 |         0.7358 |     0.8    |               0.7629 |      0.6667 |   1      |\n|  4 |        0.2  |     0.9462 |              0.964  |         0.8479 |     0.8822 |               0.857  |      0.7931 |   0.9938 |\n|  5 |        0.25 |     0.9812 |              0.9813 |         0.9431 |     0.955  |               0.9437 |      0.9298 |   0.9815 |\n|  6 |        0.3  |     0.9875 |              0.983  |         0.9615 |     0.9693 |               0.9615 |      0.9634 |   0.9753 |\n|  7 |        0.35 |     0.99   |              0.9822 |         0.9689 |     0.9752 |               0.9689 |      0.9812 |   0.9691 |\n|  8 |        0.4  |     0.9825 |              0.9591 |         0.9443 |     0.9551 |               0.9454 |      0.9933 |   0.9198 |\n|  9 |        0.45 |     0.9712 |              0.9313 |         0.9065 |     0.9241 |               0.9098 |      0.9929 |   0.8642 |\n| 10 |        0.5  |     0.9612 |              0.9043 |         0.8708 |     0.8942 |               0.8782 |      1      |   0.8086 |\n| 11 |        0.55 |     0.9388 |              0.8488 |         0.7862 |     0.8218 |               0.8048 |      1      |   0.6975 |\n| 12 |        0.6  |     0.91   |              0.7778 |         0.666  |     0.7143 |               0.7066 |      1      |   0.5556 |\n| 13 |        0.65 |     0.8838 |              0.713  |         0.542  |     0.5974 |               0.6097 |      1      |   0.4259 |\n| 14 |        0.7  |     0.8675 |              0.6728 |         0.4573 |     0.5138 |               0.5445 |      1      |   0.3457 |\n| 15 |        0.75 |     0.8438 |              0.6142 |         0.3207 |     0.3719 |               0.437  |      1      |   0.2284 |\n| 16 |        0.8  |     0.8238 |              0.5648 |         0.192  |     0.2295 |               0.3258 |      1      |   0.1296 |\n| 17 |        0.85 |     0.805  |              0.5185 |         0.0578 |     0.0714 |               0.1725 |      1      |   0.037  |\n| 18 |        0.9  |     0.8012 |              0.5093 |         0.0292 |     0.0364 |               0.1218 |      1      |   0.0185 |\n| 19 |        0.95 |     0.7975 |              0.5    |         0      |     0      |               0      |      1      |   0      |\n| 20 |        1    |     0.7975 |              0.5    |         0      |     0      |               0      |      1      |   0      |\n\nThe second is the _threshold invariant metrics dataframe_:\n\n|    | invariant_metric   |   value |\n|---:|:-------------------|--------:|\n|  0 | roc_auc            |  0.9992 |\n|  1 | pr_auc             |  0.9971 |\n|  2 | brier_score        |  0.0438 |\n\nThe third and last one is a dataframe containing the _optimal threshold values_ for each implemented metric. The *optimal threshold* is the one that corresponds to the best value of the given metric (or the minimal Cost) for the **given set of data**:\n\n|    | metric   |   optimal_threshold |\n|---:|:-------------------|--------------------:|\n|  0 | kappa              |                0.35  |\n|  1 | mcc                |                0.35  |\n|  2 | f1_score           |                0.35  |\n|  3 | f2_score           |                0.25 |\n|  4 | f05_score          |                0.35 |\n|  5 | cost               |                0.35 |\n\n\nLet's now use a different approach to compute general optimal thresholds: the **Ghost method**. \n\nThe previous optimal threshold values refer to the thresholds that are associated with the best metric values for the given set of data.\nWith the GHOST method (specifically designed for imbalanced datasets) we can obtain thresholds that generally optimize the given metrics. \nWe borrowed the code for calculating GHOST optimal threshold values directly from the [GHOST repository](https://github.com/rinikerlab/GHOST), introducing more metrics and optimizing the calculations using parallelism.\n\nThe `N_subset`, `subset_size`, and `with_replacement` parameters are specific to the GHOST algorithm. For more details, you can refer directly to the [paper introducing the GHOST method](https://pubs.acs.org/doi/10.1021/acs.jcim.1c00160).\n\n```python\nbc.thresholds.get_ghost_optimal_thresholds_df(\n    optimize_threshold = 'all',\n    threshold_values = threshold_values,\n    true_y = y_train,\n    predicted_proba = train_predicted_proba,\n    cost_dict = train_cost_dict, \n    # GHOST parameters (these values are also the default ones) \n    N_subsets = 70,\n    subsets_size = 0.2,\n    with_replacement = False, \n    \n    random_state = 120)\n```\nThis function outputs:\n\n|    | optimized_metric   |   GHOST_optimal_threshold |\n|---:|:-------------------|--------------------:|\n|  0 | kappa              |                0.30  |\n|  1 | mcc                |                0.30  |\n|  2 | f1_score           |                0.25  |\n|  3 | f2_score           |                0.25 |\n|  4 | f05_score          |                0.35 |\n|  5 | cost               |                0.35 |\n\n\nIf you are interested in optimizing a single non-cost-based threshold (specifically, one of these: 'MCC', 'Kappa', 'Fscore'), you can use the following function:\n\n```python\nopt_mcc_threshold_value = bc.thresholds.get_ghost_optimal_threshold(\n    y_train, \n    train_predicted_proba, \n    threshold_values,\n    ThOpt_metrics = 'MCC', # default = 'Kappa'\n    \n    N_subsets = 70, \n    subsets_size = 0.2, \n    with_replacement = False, # defaults\n\n    random_seed = 120)\n```\n\nKeep in mind that if you choose _'Fscore'_ as the metric to optimize, the output wll be a tuple with 3 optimal threshold values for metrics F1, F2 and F0.5 respectively.\n\nSpecifically for cost optimization (minimization), you can use the following function:\n\n```python\nopt_cost_threshold_value = bc.thresholds.get_ghost_optimal_cost(\n    y_train, \n    train_predicted_proba, \n    threshold_values,\n    train_cost_dict,\n    \n    N_subsets = 70, \n    subsets_size = 0.2, \n    with_replacement = False, # defaults\n\n    random_seed = 120)\n```\n\nOnce the GHOST optimized threshold values have been identified through the training data, the Interactive Confusion Matrix can be plotted for the test dataset:\n\n```python\n\nthreshold_step = 0.05\namounts = np.abs(X_test[:, 13])\ncurrency = '$'\n\ntest_cost_dict = bc.get_cost_dict(TN = 0, FP = 10, FN = np.abs(X_test[:, 12]), TP = 0)\n\ncf_fig_test, var_metrics_df, invar_metrics_df, opt_thresh_df = bc.confusion_matrix_plot(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba, \n    threshold_step = threshold_step, \n    amounts = amounts, \n    cost_dict = test_cost_dict, \n    currency = currency,\n    random_state = 123)\n\ncf_fig_test\n```\n\n![Interactive Confusion Matrix for the Test Set](/resources/images/06-interactive-confusion-matrix-test.png)\n\nShould you need to have only the returned dataframes, without generating the interactive confusion matrix plot, there are functions specifically available for this. You can get the threshold invariant metrics dataframe as follows:\n\n```python\ninvar_metrics_df = bc.utilities.get_invariant_metrics_df(true_y = y_test, \n                                      predicted_proba = test_predicted_proba)\n```\n\nYou can also get the threshold dependent metrics dataframe and the confusion matrix values for a specific threshold as following:\n\n```python\nconf_matrix, metrics_fixed_thresh_df = bc.utilities.get_confusion_matrix_and_metrics_df(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba,\n    threshold = 0.3 # default = 0.5\n)\n```\n\n(Keep in mind that the confusion matrix values are returned in an array, not in a dataframe.)\n\nFinally, the dataframe of the optimal thresholds can be also obtained directly with the following code:\n\n```python\nthreshold_values = np.arange(0.05, 1, 0.05)\n\nopt_thresh_df = bc.thresholds.get_subset_optimal_thresholds_df(\n    threshold_values = threshold_values,\n    true_y = y_test,\n    predicted_proba = test_predicted_proba,\n    cost_dict = test_cost_dict)\n\n```\n\nYou could also be also interested in visualizing the trend of possible amounts or costs associated with each category of the confusion matrix as the threshold value changes. For this purpose there is the following function that returns an _Interactive Confusion Line Chart_:\n\n```python\ncl_fig, amount_cost_df, total_amount = bc.confusion_linechart_plot(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba, \n    threshold_step =  threshold_step, \n    amounts = amounts, \n    cost_dict = test_cost_dict, \n    currency = currency)\ncl_fig\n```\nHere the plot returned:\n\n![Interactive Confusion Line Chart](/resources/images/07-interactive-confusion-line-chart.png)\n\nYou can see that there are also black \"diamonds\" indicating the first threshold value in which there is a swap of the amount and cost curves. The curve swapping points can also be more than one.\n\nThis function, in addition to the plot, returns two more outputs: the total amount given by the sum of all categories and the dataframe of the amounts and costs for each category as the threshold changes:\n\n```python\nprint(f'total amount: {currency}{total_amount}')\n\namount_cost_df \n```\n\nIn addition to the result of the total amount ($374.24), here the amounts & costs dataframe:\n\n|    |   threshold |   amount_TN |   amount_FP |   amount_FN |   amount_TP |   cost_TN |   cost_FP |   cost_FN |   cost_TP |   total_cost |\n|---:|------------:|------------:|------------:|------------:|------------:|----------:|----------:|----------:|----------:|-------------:|\n|  0 |        0    |      0      |   301.374   |     0       |    72.8675  |         0 |      1590 |   0       |         0 |    1590      |\n|  1 |        0.05 |     48.9919 |   252.382   |     0       |    72.8675  |         0 |      1300 |   0       |         0 |    1300      |\n|  2 |        0.1  |    139.883  |   161.491   |     0       |    72.8675  |         0 |       830 |   0       |         0 |     830      |\n|  3 |        0.15 |    201.993  |    99.3817  |     0       |    72.8675  |         0 |       460 |   0       |         0 |     460      |\n|  4 |        0.2  |    251.804  |    49.5706  |     0       |    72.8675  |         0 |       260 |   0       |         0 |     260      |\n|  5 |        0.25 |    267.401  |    33.9731  |     5.73307 |    67.1344  |         0 |       160 |   3.47131 |         0 |     163.471  |\n|  6 |        0.3  |    287.28   |    14.0945  |     7.87073 |    64.9967  |         0 |        70 |  10.5798  |         0 |      80.5798 |\n|  7 |        0.35 |    295.033  |     6.34141 |    12.96    |    59.9075  |         0 |        20 |  15.8962  |         0 |      35.8962 |\n|  8 |        0.4  |    301.374  |     0       |    15.0905  |    57.777   |         0 |         0 |  18.9167  |         0 |      18.9167 |\n|  9 |        0.45 |    301.374  |     0       |    17.1228  |    55.7447  |         0 |         0 |  19.9586  |         0 |      19.9586 |\n| 10 |        0.5  |    301.374  |     0       |    34.1608  |    38.7067  |         0 |         0 |  41.8435  |         0 |      41.8435 |\n| 11 |        0.55 |    301.374  |     0       |    41.0564  |    31.811   |         0 |         0 |  49.1584  |         0 |      49.1584 |\n| 12 |        0.6  |    301.374  |     0       |    47.5616  |    25.3058  |         0 |         0 |  54.6559  |         0 |      54.6559 |\n| 13 |        0.65 |    301.374  |     0       |    58.7947  |    14.0727  |         0 |         0 |  64.8295  |         0 |      64.8295 |\n| 14 |        0.7  |    301.374  |     0       |    58.7947  |    14.0727  |         0 |         0 |  64.8295  |         0 |      64.8295 |\n| 15 |        0.75 |    301.374  |     0       |    66.5553  |     6.31212 |         0 |         0 |  69.3375  |         0 |      69.3375 |\n| 16 |        0.8  |    301.374  |     0       |    71.3319  |     1.53555 |         0 |         0 |  75.9399  |         0 |      75.9399 |\n| 17 |        0.85 |    301.374  |     0       |    71.3319  |     1.53555 |         0 |         0 |  75.9399  |         0 |      75.9399 |\n| 18 |        0.9  |    301.374  |     0       |    72.8675  |     0       |         0 |         0 |  75.9666  |         0 |      75.9666 |\n| 19 |        0.95 |    301.374  |     0       |    72.8675  |     0       |         0 |         0 |  75.9666  |         0 |      75.9666 |\n| 20 |        1    |    301.374  |     0       |    72.8675  |     0       |         0 |         0 |  75.9666  |         0 |      75.9666 |\n\nJust as we have already seen with the other plots, the amount and cost dataframe can be obtained directly through a specific function. In particular, you can also choose not to report amounts, for example, if you only want to analyze costs:\n\n```python\n# this function requires a list of thresholds, instead of the step, for example:\nthreshold_values = np.arange(0, 1, 0.05)\n\n# example without amounts\ncosts_df = bc.utilities.get_amount_cost_df(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba,\n    threshold_values = threshold_values, \n    #amounts = amounts,  \n    cost_dict = test_cost_dict)\n```\n\nIt may be sometimes necessary to compare the performance of what is considered a gain (e.g., amount of TP because it escaped fraud) with what is considered a loss (amount of FN of fraud escaped from the model + fixed cost per FP representing the checking to be done on transactions that are classified as fraudulent but are not). This can be done through the _Interactive Amount-Cost Line Chart_:\n\n```python\namount_classes = ['TP', 'FP'] \ncost_classes = 'all'\n\nac_fig, total_cost_amount_df = bc.total_amount_cost_plot(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba, \n    threshold_step = threshold_step,\n    amounts = amounts, \n    cost_dict = test_cost_dict,\n    amount_classes = amount_classes,\n    cost_classes = cost_classes,\n    currency = currency)\nac_fig\n```\n\nHere the resulting plot:\n\n![Interactive Amount-Cost Line Chart](/resources/images/08-interactive-amount-cost-line-chart.png)\n\nAs in the other cases, this function returns a dataframe with the amount and cost values, both for each category in the confusion matrix and for selected aggregates of them, associated with each threshold:\n\n|    |   threshold |   amount_TP |   amount_FP |   amount_sum |   cost_TN |   cost_FP |   cost_FN |   cost_TP |   cost_sum |\n|---:|------------:|------------:|------------:|-------------:|----------:|----------:|----------:|----------:|-----------:|\n|  0 |        0    |    72.8675  |   301.374   |    374.242   |         0 |      1590 |  0        |         0 |  1590      |\n|  1 |        0.05 |    72.8675  |   266.572   |    339.44    |         0 |      1380 |  0        |         0 |  1380      |\n|  2 |        0.1  |    72.8675  |   152.006   |    224.874   |         0 |       770 |  0        |         0 |   770      |\n|  3 |        0.15 |    72.8675  |    88.4092  |    161.277   |         0 |       430 |  0        |         0 |   430      |\n|  4 |        0.2  |    72.5494  |    61.6009  |    134.15    |         0 |       290 |  0.221014 |         0 |   290.221  |\n|  5 |        0.25 |    66.5301  |    31.6006  |     98.1307  |         0 |       160 |  4.472    |         0 |   164.472  |\n|  6 |        0.3  |    65.3813  |    20.9625  |     86.3437  |         0 |       100 |  9.90665  |         0 |   109.907  |\n|  7 |        0.35 |    60.9562  |    12.0418  |     72.998   |         0 |        30 | 18.0882   |         0 |    48.0882 |\n|  8 |        0.4  |    57.8163  |     4.85876 |     62.6751  |         0 |        10 | 18.0989   |         0 |    28.0989 |\n|  9 |        0.45 |    46.3113  |     0       |     46.3113  |         0 |         0 | 34.7334   |         0 |    34.7334 |\n| 10 |        0.5  |    37.5392  |     0       |     37.5392  |         0 |         0 | 42.6685   |         0 |    42.6685 |\n| 11 |        0.55 |    31.2279  |     0       |     31.2279  |         0 |         0 | 49.2799   |         0 |    49.2799 |\n| 12 |        0.6  |    28.4496  |     0       |     28.4496  |         0 |         0 | 51.4823   |         0 |    51.4823 |\n| 13 |        0.65 |    19.7851  |     0       |     19.7851  |         0 |         0 | 58.1733   |         0 |    58.1733 |\n| 14 |        0.7  |     8.36888 |     0       |      8.36888 |         0 |         0 | 68.444    |         0 |    68.444  |\n| 15 |        0.75 |     1.53555 |     0       |      1.53555 |         0 |         0 | 75.9399   |         0 |    75.9399 |\n| 16 |        0.8  |     1.53555 |     0       |      1.53555 |         0 |         0 | 75.9399   |         0 |    75.9399 |\n| 17 |        0.85 |     0       |     0       |      0       |         0 |         0 | 75.9666   |         0 |    75.9666 |\n| 18 |        0.9  |     0       |     0       |      0       |         0 |         0 | 75.9666   |         0 |    75.9666 |\n| 19 |        0.95 |     0       |     0       |      0       |         0 |         0 | 75.9666   |         0 |    75.9666 |\n| 20 |        1    |     0       |     0       |      0       |         0 |         0 | 75.9666   |         0 |    75.9666 |\n\nYou can also directly access the previous data with the already used `get_amount_cost_df` function, excluding for example amounts to focus on costs:\n\n```python\n# this function requires a list of thresholds, instead of the step, for example:\nthreshold_values = np.arange(0, 1, 0.05)\n\n# example without amounts\ncosts_df = bc.utilities.get_amount_cost_df(\n    true_y = y_test, \n    predicted_proba = test_predicted_proba,\n    threshold_values = threshold_values, \n    #amounts = amounts,  \n    cost_dict = test_cost_dict)\n```\n\nFinally, there is also a function in this first release that simplifies the extraction of observations belonging to a specific category of the confusion matrix from a scored dataframe. If you want to extract, for example, all observations belonging to the TP category, this is the code you need:\n\n```python\n# for example, if we want the True Positive data points with a 0.7 threshold:\nconfusion_category = 'TP'\n\nbc.get_confusion_category_observations_df(\n    confusion_category = confusion_category, \n    X_data = X_test, \n    true_y = y_test, \n    predicted_proba = test_predicted_proba, \n    threshold = 0.7 # default = 0.5\n)\n```\n\n#### New functions from version 1.0.0:\nTo further evaluate your binary classification model, a new set of functions has been introduced, generating the following:  Cumulative Gain curve, Lift curve, Response curve, Cumulative Response curve and calibration plots. \nNote that the functions for the Cumulative Gain and Lift curves take as input the **2-dimensional array** of predicted probabilities (with the probabilities associated to the negative class as well) and have a parameter that allows to specify the positive label to be considered (when not given, it will try to automatically detect it).\n\nHere the code for the *Cumulative Gain curve* of the previously trained classification model:\n\n```python\ncumgain_plot = bc.cumulative_gain_plot(true_y = y_test, \n                                       full_predicted_proba = cls.predict_proba(X_test),\n                                       pos_label = 1,\n                                       )\ncumgain_plot\n ```\n The function prints the information related to the label identified as positive (even if explicitly specified in the call), in this case:\n ```\nClass 0 is associated with probabilities: full_predicted_proba[:, 0]\nClass 1 is associated with probabilities: full_predicted_proba[:, 1]\n```\n\nand returns the plot:\n\n![Cumulative-Gain plot](/resources/images/09-cumulative-gain-plot.png)\n\nThe cumulative gains plotshows the percentage of targets reached when considering a chosen percentage of the records with the highest predicted probability of belonging to the target class, while the baseline represents the performance of a random model. In this case, we can see that by selecting the top 23 percent of the cases according to our model, we select 80 percent of the target class.\n\nThe *lift_curve_plot* function plots the Lift curve, also called Index plot. This graph helps answer the question: when we apply the model, sort the records by their predicted probability, and select the best n deciles, how much better is it than using no model (or a random model)?\nHere the code for the function:\n\n```python\nlift_curve = bc.lift_curve_plot(true_y = y_test, \n                                full_predicted_proba = cls.predict_proba(X_test),\n                                pos_label = 1,\n                                )\nlift_curve\n```\n\nThe function prints:\n\n```\nClass 0 is associated with probabilities: full_predicted_proba[:, 0]\nClass 1 is associated with probabilities: full_predicted_proba[:, 1]\n```\n\nand returns the following plot:\n\n![Lift curve plot](/resources/images/10-lift-curve-plot.png)\n\nIn this example we can see that, by selecting 44 percent of the records with the highest predicted probability, this selection contains 2.2 times the percentage of target class observations that would be obtained with a random selection. \n\nThe *Response curve* allows to visualize the percentage of actual target class records per decile, where the first decile is associated with the 10 percent of observation with the highest predicted probability and so on. The baseline represents the percentage of target class records in the total set. \nThe function that generates *response_curve_plot* takes as input the true labels, the predicted probabilties for the positive class and the number of deciles (generally called n-tiles) we want to split out dataset into:\n\n```python\nresp_curve = bc.response_curve_plot(true_y = y_test, \n                                    predicted_proba = test_predicted_proba,\n                                    n_tiles = 10,\n                                    )\nresp_curve\n```\n\nIn the following plot we can see that when selecting the decile 2 the percentage of target class records in the selection is 65%.\n\n![Response curve plot](/resources/images/12-response-curve-plot.png)\n\nWe can also visualise the same information cumulatively through the *cumulative response plot*:\n\n```python\ncumres_plot = bc.cumulative_response_plot(true_y = y_test, \n                                          predicted_proba = test_predicted_proba,\n                                          )\ncumres_plot\n```\n![Cumulative-Response plot](/resources/images/11-cumulative-response-plot.png)\n\nFrom the plot we can see that in the first 28 percent of records, ordered by predicted probabilities, 64 percent belong to the target class.\n\nLastly, the following two functions help to understand how well the model is calibrated. Let's recall what calibration is through an example: if a model trained to classify images as either containing or not containing a cat is presented with 10 pictures and outputs the probability of there being a cat as 0.6 (or 60%) for every image, we expect 6 cat images to be present in the set. In general terms, probabilities returned by a classification model are calibrated when a prediction of a class with confidence `p` is correct `100*p %` of the time. \n\nThe following function plots the *calibration curve* for the model against a baseline representing a perfectly calibrated model and computes the Expected Calibration Error, taking as input the true label and the predicted probabilities of the positive class. An optional parameter *show_gaps* (True by default) allows to visualize calibration errors for each bin:\n\n```python \ncalib_curve, ece = bc.calibration_curve_plot(true_y = y_test, \n                                             predicted_proba = test_predicted_proba, \n                                             n_bins = 10,           #default\n                                             strategy = 'uniform',  #default\n                                             show_gaps = True,      #default\n                                             ece_bins = 'fd'        #default \n                                            )\n\ncalib_curve\n```\n\nHere the returned plot:\n\n![Calibration plot](/resources/images/13-calibration-plot.png)\n\nAnd here the ECE:\n\n```python\n>>> ece \n0.13359495868308954\n```\n\nThe expected calibration error can also be directly obtained with the following function:\n\n```python\n>>> bc.utilities.get_expected_calibration_error(true_y = y_test, \n                                                predicted_proba = test_predicted_proba, \n                                                bins = 'fd'           #default\n                                               )\n0.13359495868308954\n```                                         \n\nThis last function *calibration_plot_from_models* allows you to compare the calibration of different models by taking as input: feature dataframe (X), true labels, and one or more classification models (scikit-learn consistent, must have a predict_proba method) to compare. Optionally, a list of names for the different models can be passed as input to better identify performance in the graph.\nThe function returns two figure objects and a list of Expected Calibration Errors (one for each model given): the first plot represents the calibration line chart with the ECE for each estimator and the second plot shows histograms with the predicted probability distribution (one for each given model).\n\nLet's train two more estimators first:\n\n```python\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\n\nlr = LogisticRegression(C=1.0)\ngnb = GaussianNB()\n\nclf_list = [lr, gnb]\n\nfor clf in clf_list:\n    clf.fit(X_train, y_train)\n```\n\nNow we can compare the different calibration plots and the probability distibutions:\n\n```python\nline_fig, hist_fig, ece_list = bc.calibration_plot_from_models(X = X_test, \n                                                     true_y = y_test, \n                                                     estimators = [cls, lr, gnb],\n                                                     estimator_names = [\"Random Forest\", \"Logistic\", \"Naive Bayes\"],\n                                                     n_bins = 10,           #default\n                                                     strategy = 'uniform',  #default\n                                                     ece_bins = 'fd'        #default\n                                                    )\n```\n\nHere the plots returned:\n\n```\nline_fig.show()\nhist_fig.show()\n```\n![Calibration plot from models](/resources/images/14-calibration-plot-from-models.png)\n\n\nAnd the ECEs:\n\n```python\n>>> ece_list \n[0.13359495868308954, 0.05032756223563597, 0.053718608412928796]\n```\n\nYou can find the complete code in the [sample notebook](/example-notebook/example_classification_model.ipynb) provided with the repository.\n\n## Content\n\n### Notebook:\n\n- **example-notebook/Example_classification_model.ipynb** \nExample of how to use the binclass-tools library.\n\n### Dependencies:\nIf you are interested in using _binclass-tools_ in your own code/notebooks, you'll just need these packages:\n- numpy\n- pandas\n- scikit-learn (>=0.22.1)\n- matplotlib\n- plolty\n- nbformat (>= 4.2.0)\n\n## Authors\n[Luca Zavarella](https://github.com/lucazav), [Greta Villa](https://github.com/GretaVilla)\n\n## Collaborators\n[Julio Cesar Cuaran Cuaran](https://github.com/JulioCesarCuaran)\n\n## License\nThis package is licensed under the [BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause) license.\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/lucazav/binclass-tools/",
    "keywords": "binary,classification,confusion,matrix,threshold,plot,precision,recall",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "binclass-tools",
    "package_url": "https://pypi.org/project/binclass-tools/",
    "platform": null,
    "project_url": "https://pypi.org/project/binclass-tools/",
    "project_urls": {
      "Homepage": "https://github.com/lucazav/binclass-tools/",
      "Source": "https://github.com/lucazav/binclass-tools/"
    },
    "release_url": "https://pypi.org/project/binclass-tools/1.1.2/",
    "requires_dist": [
      "numpy",
      "pandas",
      "scikit-learn (>=0.22.1)",
      "matplotlib",
      "plotly (>=5.5.0)",
      "nbformat (>=4.2.0)"
    ],
    "requires_python": ">=3.6",
    "summary": "A set of tools that facilitates the analysis of binary classification problems",
    "version": "1.1.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17274055,
  "releases": {
    "0.1.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "656c3ef5f50639c161f848635b41ec15147c30ae24ee4b6bab8efd6ccea31fd4",
          "md5": "be69a115e611d0c2e152e652afd2b34c",
          "sha256": "113ef7b0dacf76fe7691872a0f491b6276dff22db6e79ee83c2234b131e8861b"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.1.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "be69a115e611d0c2e152e652afd2b34c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 22336,
        "upload_time": "2022-06-07T15:29:14",
        "upload_time_iso_8601": "2022-06-07T15:29:14.714127Z",
        "url": "https://files.pythonhosted.org/packages/65/6c/3ef5f50639c161f848635b41ec15147c30ae24ee4b6bab8efd6ccea31fd4/binclass_tools-0.1.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "18bc199c4bfd6ac7a4e0c1c66d8a15b37c987c95369714e416ff7681f08192de",
          "md5": "83bec6e96690f26ee986d16cc36c7e88",
          "sha256": "ce30a318abf35ff5485b947fdf905f43152233b56427da48c9c307c249bb8244"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.1.7.tar.gz",
        "has_sig": false,
        "md5_digest": "83bec6e96690f26ee986d16cc36c7e88",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 29157,
        "upload_time": "2022-06-07T15:29:17",
        "upload_time_iso_8601": "2022-06-07T15:29:17.886866Z",
        "url": "https://files.pythonhosted.org/packages/18/bc/199c4bfd6ac7a4e0c1c66d8a15b37c987c95369714e416ff7681f08192de/binclass-tools-0.1.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d2657ffb7c902752f72c76bfae6fe070d8c9a6c6ced26e2daa3ac6affbf96527",
          "md5": "b3f02ddcebb3a9f72258881f452aafcc",
          "sha256": "7917df10913bf4196da4905784765be6917ad5508bb214ac065831ae497876f8"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.2.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b3f02ddcebb3a9f72258881f452aafcc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 26126,
        "upload_time": "2022-07-20T14:23:31",
        "upload_time_iso_8601": "2022-07-20T14:23:31.069158Z",
        "url": "https://files.pythonhosted.org/packages/d2/65/7ffb7c902752f72c76bfae6fe070d8c9a6c6ced26e2daa3ac6affbf96527/binclass_tools-0.2.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6b1fe8b0b2ecaf1a8c5a57cb3f1c5514a0b891a4132a4fb6d23273f15ccf8fab",
          "md5": "53d3957972f53824afd445d7468f6248",
          "sha256": "da89e665e6b65395dd5b6721ae40eeba6e684b2913750b93b29ece3b6fdbb000"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "53d3957972f53824afd445d7468f6248",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 33109,
        "upload_time": "2022-07-20T14:23:33",
        "upload_time_iso_8601": "2022-07-20T14:23:33.597789Z",
        "url": "https://files.pythonhosted.org/packages/6b/1f/e8b0b2ecaf1a8c5a57cb3f1c5514a0b891a4132a4fb6d23273f15ccf8fab/binclass-tools-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "34bd88ed44b7d74578dace3733d95aca214d76dbe8cea5cf2b72fc562960f34f",
          "md5": "d508dd9e4cab72c3380e6b7ed76f7f6d",
          "sha256": "856a6d454d83644c01d6c4dccb2c239e256e59948db367ee847bc03159ae7530"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.2.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "d508dd9e4cab72c3380e6b7ed76f7f6d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 26163,
        "upload_time": "2022-08-19T20:11:12",
        "upload_time_iso_8601": "2022-08-19T20:11:12.308626Z",
        "url": "https://files.pythonhosted.org/packages/34/bd/88ed44b7d74578dace3733d95aca214d76dbe8cea5cf2b72fc562960f34f/binclass_tools-0.2.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "506419ae75ef9f8847057d8beef8e28aceb047d98e92f96974aa3d814a3e99a2",
          "md5": "a1cb551b279b5f1fe03976fea8453c83",
          "sha256": "8a3df3232a74988bd39789cd8ff0a7f423bc4f8afd43861a3fb8aa3d46a67e0a"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "a1cb551b279b5f1fe03976fea8453c83",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 34173,
        "upload_time": "2022-08-19T20:11:15",
        "upload_time_iso_8601": "2022-08-19T20:11:15.316874Z",
        "url": "https://files.pythonhosted.org/packages/50/64/19ae75ef9f8847057d8beef8e28aceb047d98e92f96974aa3d814a3e99a2/binclass-tools-0.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d222ecfe9230c91e81cf1354c496e42861639931b65b4f70e98f25eea51e691b",
          "md5": "168d19a33548f4f3ac90583b9a57ff00",
          "sha256": "02fc4e9c0bb4fdaca83b545fe77bd68dac64869609ada42a7706764cc34e76e1"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "168d19a33548f4f3ac90583b9a57ff00",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 26310,
        "upload_time": "2022-08-29T13:30:15",
        "upload_time_iso_8601": "2022-08-29T13:30:15.759351Z",
        "url": "https://files.pythonhosted.org/packages/d2/22/ecfe9230c91e81cf1354c496e42861639931b65b4f70e98f25eea51e691b/binclass_tools-0.2.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c1301f915412dc8ac675dbbb415ed04fee0fc19efac4cca0d341ca218a38f8e0",
          "md5": "d96d09a6793aefdfa7506f7087366ff1",
          "sha256": "a61ce4b32e606440336f155579895d882edb15c5afca0c635242f4b03c1f526b"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "d96d09a6793aefdfa7506f7087366ff1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 34311,
        "upload_time": "2022-08-29T13:30:17",
        "upload_time_iso_8601": "2022-08-29T13:30:17.894366Z",
        "url": "https://files.pythonhosted.org/packages/c1/30/1f915412dc8ac675dbbb415ed04fee0fc19efac4cca0d341ca218a38f8e0/binclass-tools-0.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "19246bc44016851afb067c50fc20b7388be72a1b154a12049edeb9a7b9159b7e",
          "md5": "9fe6727999ee1d0f3600640c929d1d05",
          "sha256": "620307f92f5185661842799c34d22352520fbe2bcadb232e33686f5c23a92308"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.2.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9fe6727999ee1d0f3600640c929d1d05",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 26317,
        "upload_time": "2022-08-30T12:47:42",
        "upload_time_iso_8601": "2022-08-30T12:47:42.256361Z",
        "url": "https://files.pythonhosted.org/packages/19/24/6bc44016851afb067c50fc20b7388be72a1b154a12049edeb9a7b9159b7e/binclass_tools-0.2.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5a7a22f05083262018c2b3bcc8fda0fae9f39eb4e62ca749a373e723337cae43",
          "md5": "77d41dedf1c28e11689eee0e58d1fc40",
          "sha256": "c40a90b6d09868bfc1719a160bc762b459ec3cee66fcf63946c40f7c08c951d8"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "77d41dedf1c28e11689eee0e58d1fc40",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 34350,
        "upload_time": "2022-08-30T12:47:44",
        "upload_time_iso_8601": "2022-08-30T12:47:44.217207Z",
        "url": "https://files.pythonhosted.org/packages/5a/7a/22f05083262018c2b3bcc8fda0fae9f39eb4e62ca749a373e723337cae43/binclass-tools-0.2.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "052629bcd8fd79c9b3753e2d740debdc14b8de8aeb25461a59cea719808e98b8",
          "md5": "53183ac9dd4f2869d26ac6fd7ebc2d88",
          "sha256": "cd8f0f528832229fa156d5d2b0331aba75553a55bdb17710c152c3794f405f97"
        },
        "downloads": -1,
        "filename": "binclass_tools-0.3.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "53183ac9dd4f2869d26ac6fd7ebc2d88",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 28621,
        "upload_time": "2022-09-09T13:11:12",
        "upload_time_iso_8601": "2022-09-09T13:11:12.758961Z",
        "url": "https://files.pythonhosted.org/packages/05/26/29bcd8fd79c9b3753e2d740debdc14b8de8aeb25461a59cea719808e98b8/binclass_tools-0.3.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "446de1e8d5cc91211a93c72f117650d888d186200e7c0dff4eece7dcd8762483",
          "md5": "d65836720dd6a3cedb9955b7238d337a",
          "sha256": "af30fef4cf9f2308a585b58e7372c8fb4d0cf0edd6702fd145ebd1917f0c5592"
        },
        "downloads": -1,
        "filename": "binclass-tools-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d65836720dd6a3cedb9955b7238d337a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 37153,
        "upload_time": "2022-09-09T13:11:15",
        "upload_time_iso_8601": "2022-09-09T13:11:15.252863Z",
        "url": "https://files.pythonhosted.org/packages/44/6d/e1e8d5cc91211a93c72f117650d888d186200e7c0dff4eece7dcd8762483/binclass-tools-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ac0e1ccb68fac4157111446f4641ceb41b47abd482a041852cab67d0ccc843e9",
          "md5": "abc35a9324c387585efd0f4fdfcafa5a",
          "sha256": "a71e14190bda6aed522b5f036114796dfb9d4b5869841f1ab9394b73b80c74a6"
        },
        "downloads": -1,
        "filename": "binclass_tools-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "abc35a9324c387585efd0f4fdfcafa5a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 35535,
        "upload_time": "2023-02-28T16:24:38",
        "upload_time_iso_8601": "2023-02-28T16:24:38.719940Z",
        "url": "https://files.pythonhosted.org/packages/ac/0e/1ccb68fac4157111446f4641ceb41b47abd482a041852cab67d0ccc843e9/binclass_tools-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2201221b1eec9b6de9e590eba31e88b640df805d3ddd9c999e98fdd050b7356b",
          "md5": "1053e4e41317036da2ce92c9c46da110",
          "sha256": "8e6ded6e054b566e23f73e8597ce53f20cf6fd453c25fa73c86e0aae5d2ad332"
        },
        "downloads": -1,
        "filename": "binclass-tools-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "1053e4e41317036da2ce92c9c46da110",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 54687,
        "upload_time": "2023-02-28T16:24:40",
        "upload_time_iso_8601": "2023-02-28T16:24:40.727476Z",
        "url": "https://files.pythonhosted.org/packages/22/01/221b1eec9b6de9e590eba31e88b640df805d3ddd9c999e98fdd050b7356b/binclass-tools-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f7c983857f13d96ce5f3355e7eb376a6d23f530d7d81727b09a675578d1ed6a2",
          "md5": "9936c2cb9d9c4436c2ff013a012afd38",
          "sha256": "7319667d49fa6e43cbea5499affee915a064b3cc11fc39163cdde33efaacb2a9"
        },
        "downloads": -1,
        "filename": "binclass_tools-1.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "9936c2cb9d9c4436c2ff013a012afd38",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 36360,
        "upload_time": "2023-03-07T16:10:37",
        "upload_time_iso_8601": "2023-03-07T16:10:37.753200Z",
        "url": "https://files.pythonhosted.org/packages/f7/c9/83857f13d96ce5f3355e7eb376a6d23f530d7d81727b09a675578d1ed6a2/binclass_tools-1.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "16b40b6b2f97f2b51150f44759061cdeebfa01f319e7c0b7a445b7e9be620668",
          "md5": "c57eccba8e9bb438dce32662463b4f2a",
          "sha256": "bac5ccc56fdd41c31af37f9db53f7548d3ebda9b5a98bc51247fc338b65fbcef"
        },
        "downloads": -1,
        "filename": "binclass-tools-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c57eccba8e9bb438dce32662463b4f2a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 56505,
        "upload_time": "2023-03-07T16:10:39",
        "upload_time_iso_8601": "2023-03-07T16:10:39.790060Z",
        "url": "https://files.pythonhosted.org/packages/16/b4/0b6b2f97f2b51150f44759061cdeebfa01f319e7c0b7a445b7e9be620668/binclass-tools-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "61afd4dfddf961304c7401a185f42820b7a9f76924b509b3e6373c4de3c6cd6a",
          "md5": "acebf5dba38d21e150caba5e59e364dc",
          "sha256": "e9ad16ad1f9c8e9ad13edf739f57a3b1a7bc4288a91e33cb3604250a2d7fa2f4"
        },
        "downloads": -1,
        "filename": "binclass_tools-1.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "acebf5dba38d21e150caba5e59e364dc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 36387,
        "upload_time": "2023-03-09T15:15:53",
        "upload_time_iso_8601": "2023-03-09T15:15:53.708102Z",
        "url": "https://files.pythonhosted.org/packages/61/af/d4dfddf961304c7401a185f42820b7a9f76924b509b3e6373c4de3c6cd6a/binclass_tools-1.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "354edaed1ab06c01d5bd273870dc0ca379acc01a4681edca8cf8f674d6f81ca5",
          "md5": "b4febac04700eed01902728787fc0459",
          "sha256": "fc4f63f16313245298ea6a5ac31df993b81d1262a616e7b370ece51ca326f29a"
        },
        "downloads": -1,
        "filename": "binclass-tools-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b4febac04700eed01902728787fc0459",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 56602,
        "upload_time": "2023-03-09T15:15:55",
        "upload_time_iso_8601": "2023-03-09T15:15:55.746375Z",
        "url": "https://files.pythonhosted.org/packages/35/4e/daed1ab06c01d5bd273870dc0ca379acc01a4681edca8cf8f674d6f81ca5/binclass-tools-1.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "39032ac116d03e65c5270b8345dfad920328bbcdf89549f83214b930eb3a2221",
          "md5": "f7ba0d9fb4fb9902fdd2fae827753f50",
          "sha256": "67e3f1f2ae29a5e176ed951d8dae5d610840574786865ceae64d8856e777f18d"
        },
        "downloads": -1,
        "filename": "binclass_tools-1.1.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "f7ba0d9fb4fb9902fdd2fae827753f50",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 36391,
        "upload_time": "2023-03-13T16:53:37",
        "upload_time_iso_8601": "2023-03-13T16:53:37.325194Z",
        "url": "https://files.pythonhosted.org/packages/39/03/2ac116d03e65c5270b8345dfad920328bbcdf89549f83214b930eb3a2221/binclass_tools-1.1.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a9f3b9d7ff12c0ca9a987c18e93f0dfeaa8a00471cf95d7225cde3c0664c5d14",
          "md5": "ff665081875b5ec467e003aedb414ff9",
          "sha256": "066aa8f7999953ef1977e3cece8285206a71a7f90573db5705bd753393c8ebfa"
        },
        "downloads": -1,
        "filename": "binclass-tools-1.1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ff665081875b5ec467e003aedb414ff9",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 56608,
        "upload_time": "2023-03-13T16:53:39",
        "upload_time_iso_8601": "2023-03-13T16:53:39.473300Z",
        "url": "https://files.pythonhosted.org/packages/a9/f3/b9d7ff12c0ca9a987c18e93f0dfeaa8a00471cf95d7225cde3c0664c5d14/binclass-tools-1.1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "39032ac116d03e65c5270b8345dfad920328bbcdf89549f83214b930eb3a2221",
        "md5": "f7ba0d9fb4fb9902fdd2fae827753f50",
        "sha256": "67e3f1f2ae29a5e176ed951d8dae5d610840574786865ceae64d8856e777f18d"
      },
      "downloads": -1,
      "filename": "binclass_tools-1.1.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "f7ba0d9fb4fb9902fdd2fae827753f50",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 36391,
      "upload_time": "2023-03-13T16:53:37",
      "upload_time_iso_8601": "2023-03-13T16:53:37.325194Z",
      "url": "https://files.pythonhosted.org/packages/39/03/2ac116d03e65c5270b8345dfad920328bbcdf89549f83214b930eb3a2221/binclass_tools-1.1.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a9f3b9d7ff12c0ca9a987c18e93f0dfeaa8a00471cf95d7225cde3c0664c5d14",
        "md5": "ff665081875b5ec467e003aedb414ff9",
        "sha256": "066aa8f7999953ef1977e3cece8285206a71a7f90573db5705bd753393c8ebfa"
      },
      "downloads": -1,
      "filename": "binclass-tools-1.1.2.tar.gz",
      "has_sig": false,
      "md5_digest": "ff665081875b5ec467e003aedb414ff9",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 56608,
      "upload_time": "2023-03-13T16:53:39",
      "upload_time_iso_8601": "2023-03-13T16:53:39.473300Z",
      "url": "https://files.pythonhosted.org/packages/a9/f3/b9d7ff12c0ca9a987c18e93f0dfeaa8a00471cf95d7225cde3c0664c5d14/binclass-tools-1.1.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}