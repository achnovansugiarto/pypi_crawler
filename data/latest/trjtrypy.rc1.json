{
  "info": {
    "author": "Hamed Khaiiate Ajami, Hasan Pourmahmood-Aghababa, Jeff M. Phillips",
    "author_email": "goldenstarcodeteam@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Scientific/Engineering :: Mathematics",
      "Topic :: Scientific/Engineering :: Visualization"
    ],
    "description": "============\n**trjtrypy**\n============\n\n|pypi| |build| |MIT| |coverage|\n|quality|\n\n.. |pypi| image:: https://badge.fury.io/py/trjtrypy.svg\n    :target: https://badge.fury.io/py/trjtrypy\n\n.. |MIT| image:: https://img.shields.io/github/license/GoldenStarCode/trjtrypy   \n    :alt: GitHub license  \n    :target: https://github.com/GoldenStarCode/trjtrypy/blob/main/License.txt\n\n.. |build| image:: https://travis-ci.com/GoldenStarCode/trjtrypy.svg?branch=main\n    :target: https://travis-ci.com/GoldenStarCode/trjtrypy\n\n.. |coverage| image:: https://codecov.io/gh/GoldenStarCode/trjtrypy/branch/main/graph/badge.svg?token=LEKRIOIVOL\n      :target: https://codecov.io/gh/GoldenStarCode/trjtrypy\n    \n.. |quality| image:: https://img.shields.io/lgtm/grade/python/github/GoldenStarCode/trjtrypy?logo=lgtm   \n\n\n.. contents:: Table of Contents\n   :depth: 7\n\n\nIntroduction\n************\nIn this package three landmark-based distances and their \nfeature mappings, introduced in [1]_, [2]_, are implemented (for more details see Overview section). Moreover, it provides\naccess to fundamental functions used in calculating these distances.\n   \nOverview\n********\nMore details for understanding the functionality of the package: \n\n1. Feature mapping used in calculating d_Q\n============================================\n\nFirst, using a landmark set Q, an orientation-non-perserving (unsigned version) feature mapping, taken from [1]_, is provided to convert a trajectory to a vector of length \\|Q|\\.\n\nSecond, using a landmark set Q and a positive parameter sigma, an orientation-perserving (signed version) feature mapping, taken from [2]_, is provided to convert a trajectory to a vector of length \\|Q|\\  that cares about the direction of curves.\n\nIn this package these functionalities can be accessed by the implemented curve2vec function.\n\n2. d_Q distance of two trajecetories\n=====================================\n   \nThe d_Q distance of two trajectories is the normalized Euclidean distance between two vectorized trajectories via above feature mappings.\n\nIn this package this functionality is given by d_Q function.\n\n3. d_Q_pi distance of two trajectories\n=========================================\n  \nThis is the normalized l^p-distance of the associated argmin points on trajectories obtained by landmarks Q.\n\nIn this package this is provided by d_Q_pi function.\n\n4. Visualizations\n===================\n   \n4.1. Drawing landmarks and trajectories\n#######################################\n\nVisaulizing landmarks, trajectories and distances between landmarks and the given trajectory.\n\ndraw_landmarks_curve function in this package does this job.\n\n4.2. Color-coding\n#################\n\nVisaulizing the feature mappings in terms of color-coding.\n\ncolorcoding function in this package does this job.\n\n5. Curves, points and distances\n=================================\n\nBy taking the advantage of distance funcion in this package one can compute the followings:\n\n5.1. The minimum distance between a point and any (complicated) piecewise linear curve/curves\n##############################################################################################\n\nUsage: See [i]_.\n\nExample: \n\n.. image:: https://github.com/GoldenStarCode/test/blob/main/images/point_curve.jpeg?raw=true\n\nNote: The figure is drawn by *draw_landmarks_trajectory* function of this package.\n\nRemark: Notice argmin points are chosen by the smallest index if there is a tie.\n\n\n5.2. The minimum distance of all points in a set of points from a curve/curves simultaneously\n##############################################################################################\n\nUsage: See [ii]_.\n\nExample: \n\n.. image:: https://github.com/GoldenStarCode/tmg/blob/main/points_curve.jpeg?raw=true\n\nNote: The figure is drawn by *draw_landmarks_trajectory* function of this package.\n\nRemark: Notice argmin points are chosen by the smallest index if there is a tie.\n\n5.3. The minimum distance of a point/set of points from a line segment\n#######################################################################\n\nUsage: See [iii]_.\n\nExamples: \n\n.. image:: https://github.com/GoldenStarCode/tmg/blob/main/point_linesegment.jpeg?raw=true\n.. image:: https://github.com/GoldenStarCode/tmg/blob/main/points_linesegment.jpeg?raw=true\n\nNote: The figures are drawn by *draw_landmarks_trajectory* function of this package.\n\nAlso, this class helps in calculating:\n\n5.4. The closest curve from a set of curves to a given set of points\n#####################################################################\n\nThis is achievable by considering a cost function like the least mean square cost.\n\n5.5. The minimum distance between a set of points and a curve\n##############################################################\n\nThis is not equivalent to the part 5.2 But one can do as part 5.2 then take minimum.\n\n\nInstallation\n************\n\nFirst of all make sure that you have already installed Python from https://www.python.org. Then to install this package:\n\n\n**With pip**\n\n\n.. code-block::\n\n   $ pip install trjtrypy\n\n**With git**\n\n\n.. code-block::\n\n   $ git clone https://github.com/GoldenStarCode/trjtrypy.git\n   $ cd trjtrpy\n   $ python setup.py install\n\nDocumentation\n*************\n\ntrjtrypy.featureMappings.curve2vec\n======================================\ntrjtrypy.featureMappings.curve2vec(landmarks, trajectories, version='unsigned', sigma=1, segIndx=False, argPnts=False)\n\n   Maps each curve in curves to a vector of size len(landmarks) using the signed or unsigned\n   feature mapping introduced in the references.\n\n   * **Parameters**\n         * **landmarks: ndarray of shape (len(landmarks), 2)**\\\n                  An array of points in R^2 that their distances from trajectories should be\n                  measured.\n         * **trajectories: ndarray of shape (len(trajectories), )**\\\n                  Trajectories are piecewise linear curves in R^2 of shape (n, 2).\n                  version: str ('signed', 'unsigned'), default='unsigned'\n                  Determines which version of the feature mappings is utilized.\n\n         * **sigma: float, default=1**\\\n                  A positive real number specifying the Gaussian weight parameter employed \n                  in the definition of the signed feature mapping. So, it will be\n                  effective only when version='signed'.\n\n         * **segIndx: bool (True, False), default=False**\\\n                 Being True or False determines whether the function outputs the indices\n                 of segments selected by the landmarks.\n\n         * **argPnts: bool (True, False), default=False**\\\n                 Setting True or False specifies if the function outputs the  \n                 nearest points on trajectories to landmarks.\n   * **Returns**\n         * **ndarray**\\\n                  The array of mapped vectors under the signed/unsigned feature mapping. Moreover, when segIndx\n                  or argPnts are called an array of dictionaries including the feature mapping values,\n                  selected segments' indices or argmin points respectively for all trajectories.\n\n**Remark**\n\nNotice that when ``version='signed'``, the trajectories passed into the function must be semi-simple (i.e., countably many self crossings are allowed).\nHowever, the code will be run for any trajectory but it will possibly assign an incorrect sign to the values.\n\n**Examples**\n\n.. code-block:: python\n\n   >>> import numpy as np\n   >>> import trjtrypy as tt\n   \n\n.. code-block:: python\n\n   >>> trajectory1 = np.array([[0,0], [2,2], [5,-1], [7,0]])\n   >>> trajectory2 = np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0,1], [0,0], [0,-1], [0,-2], [-1,-1], [1,-1], [2,0]])\n   >>> trajectories = np.array([trajectory1, trajectory2], dtype=object) # or [trajectory1, trajectory2]\n   >>> landmarks = np.array([[2,-1], [3,3], [2,0]]) # or [[2,-1], [3,3], [2,0]]\n\nDefault (unsigned feature mapping):\n\n.. code-block:: python\n   \n   >>> fms = tt.featureMappings.curve2vec(landmarks, trajectories)\n   >>> fms # An array containing unsigned feature mapping of trajectories\n   array([[2.12132034e+00, 1.41421356e+00, 1.41421356e+00],\n         [7.07106781e-01, 2.82842712e+00, 3.14018492e-16]])\n   >>> fms[0] # Vectorized form of trajectory1 under curve2vec feature mapping\n   array([2.12132034e+00, 1.41421356e+00, 1.41421356e+00])\n   >>> fms[1] # Vectorized form of trajectory2 under curve2vec feature mapping\n   array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16])\n\nWhen ``version='signed'`` and sigma is given:\n\n.. code-block:: python\n\n   >>> signfms = tt.featureMappings.curve2vec(landmarks, trajectories, version='signed', sigma=2)\n   >>> signfms # An array containing signed feature mapping of trajectories\n   array([[-3.44345942e-01,  4.28881942e-01, -4.28881942e-01],\n       [-3.12009772e-01,  1.91392993e-01, -1.57009246e-16]])\n   >>> signfms[0] # Vectorized form of trajectory1 under curve2vec feature mapping\n   array([-3.44345942e-01,  4.28881942e-01, -4.28881942e-01])\n   >>> signfms[1] # Vectorized form of trajectory2 under curve2vec feature mapping\n   array([-3.12009772e-01,  1.91392993e-01, -1.57009246e-16])\n\nIn both signed and unsigned versions setting ``segIndx=True`` will return an array of dictionaries: \n\n.. code-block:: python\n\n   >>> segindxfms = tt.featureMappings.curve2vec(landmarks, trajectories, segIndx=True)\n   >>> segindxfms # See figure 1 and figure 2 \n   array([{'UnsignedCurve2Vec': array([2.12132034, 1.41421356, 1.41421356]), 'SelectedSegmentsIndex': array([0, 0, 0], dtype=int64)},\n       {'UnsignedCurve2Vec': array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16]), 'SelectedSegmentsIndex': array([12,  5, 12], dtype=int64)}],\n      dtype=object)\n   >>> segindxfms[0] # See figure 1\n   {'SelectedSegmentsIndex': array([0, 0, 0]),\n   'UnsignedCurve2Vec': array([2.12132034, 1.41421356, 1.41421356])}\n   >>> segindxfms[0]['SelectedSegmentsIndex'] # Output determines that which segments of trajectory1 are selected by the landmarks. As an example, first landmark has selected the first segment (0 index segment) of trajectory1.\n   array([0, 0, 0])\n   >>> segindxfms[0]['UnsignedCurve2Vec']  # Output determines landmarks unsigned distances from trajectory1. As an example, first landmark unsigned distance from trajectory1 is 2.12132034.\n   array([2.12132034, 1.41421356, 1.41421356])\n   >>> segindxfms[1]\n   {'UnsignedCurve2Vec': array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16]), 'SelectedSegmentsIndex': array([12,  5, 12], dtype=int64)}\n\nAlso, setting ``argPnts=True`` will return argmin points selected by landmarks:\n\n.. code-block:: python\n\n   >>> argminfms = tt.featureMappings.curve2vec(landmarks, trajectories, argPnts=True)\n   >>> argminfms # See figure 1 and figure 2 \n   array([{'UnsignedCurve2Vec': array([2.12132034, 1.41421356, 1.41421356]), \n           'ArgminPoints': array([[0.5, 0.5], [2. , 2. ], [1. , 1. ]])},\n       {'UnsignedCurve2Vec': array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16]), \n       'ArgminPoints': array([[ 1.50000000e+00, -5.00000000e-01], [ 1.00000000e+00,  1.00000000e+00], [ 2.00000000e+00, -2.22044605e-16]])}], dtype=object)\n   >>> argminfms[0] # See figure 1\n   {'ArgminPoints': array([[0.5, 0.5], [2. , 2. ], [1. , 1. ]]),\n   'UnsignedCurve2Vec': array([2.12132034, 1.41421356, 1.41421356])}\n   >>> argminfms[0]['ArgminPoints'] # Output determines which points of trajectory1 are selected by the landmarks. As an example, first landmark selects the point [0.5, 0.5] on trajectory1.\n   array([[0.5, 0.5], [2. , 2. ], [1. , 1. ]])\n   >>> argminfms[0]['UnsignedCurve2Vec']  # Output determines landmarks unsigned distances from trajectory1. As an example, first landmark unsigned distance from trajectory1 is 2.12132034.\n   array([2.12132034, 1.41421356, 1.41421356])\n   >>> argminfms[1]\n   {'UnsignedCurve2Vec': array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16]), \n   'ArgminPoints': array([[ 1.50000000e+00, -5.00000000e-01], [ 1.00000000e+00,  1.00000000e+00], [ 2.00000000e+00, -2.22044605e-16]])}\n\nFigure 1:\n   .. image:: https://github.com/GoldenStarCode/tmg/blob/main/detailtraj1.jpg?raw=true\n   \nRemark: Notice argmin points are chosen by the smallest index if there is a tie.\n       \nFigure 2: \n   .. image:: https://github.com/GoldenStarCode/tmg/blob/main/detailtraj2.jpg?raw=true\n\n\nA combination of above functionalities can also be used:\n\n.. code-block:: python\n\n   >>> tt.featureMappings.curve2vec(landmarks, trajectories, segIndx=True, argPnts=True)\n   array([{'UnsignedCurve2Vec': array([2.12132034, 1.41421356, 1.41421356]), \n           'SelectedSegmentsIndex': array([0, 0, 0], dtype=int64), \n           'ArgminPoints': array([[0.5, 0.5], [2. , 2. ], [1. , 1. ]])},\n       {'UnsignedCurve2Vec': array([7.07106781e-01, 2.82842712e+00, 3.14018492e-16]), \n        'SelectedSegmentsIndex': array([12,  5, 12], dtype=int64), \n        'ArgminPoints': array([[ 1.50000000e+00, -5.00000000e-01], [ 1.00000000e+00,  1.00000000e+00], [ 2.00000000e+00, -2.22044605e-16]])}], dtype=object)\n   >>> tt.featureMappings.curve2vec(landmarks, trajectories, version='signed', sigma=0.9, segIndx=True, argPnts=True)\n   array([{'SignedCurve2Vec': array([-0.00911206,  0.1330272 , -0.1330272 ]), \n           'SelectedSegmentsIndex': array([0, 0, 0], dtype=int64), \n           'ArgminPoints': array([[0.5, 0.5], [2. , 2. ], [1. , 1. ]])},\n       {'SignedCurve2Vec': array([-4.23798562e-01,  1.61426291e-04, -3.48909435e-16]), \n        'SelectedSegmentsIndex': array([12,  5, 12], dtype=int64), \n        'ArgminPoints': array([[ 1.50000000e+00, -5.00000000e-01], [ 1.00000000e+00,  1.00000000e+00], [ 2.00000000e+00, -2.22044605e-16]])}], dtype=object)\n\ntrjtrypy.distances.d_Q\n==========================\ntrjtrypy.distances.d_Q(landmarks, trajectory1, trajectory2, version='unsigned', sigma=1, p=2)\n\n   The landmark-based signed/unsigned distance d_Q according to the\n   definitions in the related references is computed. \n\n   * **Parameters**\n         * **landmarks: ndarray of shape (len(landmarks), 2)**\\\n                     An array containing coordinates of landmarks in each row. \n                  \n         * **trajectory1: ndarray of shape (len(trajectory1), 2)**\\\n                     An array that contains the waypoints of trajectory1\n                     consecutively.\n\n         * **trajectory2: ndarray of shape (len(trajectory2), 2)**\\\n                     An array that contains the waypoints of trajectory2\n                     consecutively.\n\n         * **version: str ('signed', 'unsigned'), default='unsigned'**\\\n                     Determines which version of the feature mappings is utilized.\n\n         * **sigma: float, default=1**\\\n                     A positive real number specifying the Gaussian weight parameter\n                     employed in the definition of the signed distance. So, it will\n                     be effective only when version='signed'.\n\n         * **p: float (1<=p<=infinity), default=2**\\\n                     Specifies the p-norm used in calculations.\n   * **Returns**\n         * **float**\n                     The d_Q distance of trajectory1 and trajectory2.\n\n**Examples**\n\n.. code-block:: python\n\n   >>> import numpy as np\n   >>> import trjtrypy as tt\n   \n.. code-block:: python\n\n   >>> trajectory1 = np.array([[0,0], [2,2], [5,-1], [7,0]])\n   >>> trajectory2 = np.array([[1,1], [2,2], [4,-2], [4,0]])\n   >>> trajectories = np.array([trajectory1, trajectory2], dtype=object) # or [trajectory1, trajectory2]\n   >>> landmarks = np.array([[2,-1], [3,3], [2,0]]) # or [[2,-1], [3,3], [2,0]]\n\n.. code-block:: python\n\n   >>> tt.distances.d_Q(landmarks, trajectory1, trajectory2)\n   0.5410108081367118\n   >>> tt.distances.d_Q(landmarks, trajectory1, trajectory2, p=5) # Using 5-norm to calculate distacne of two trajcetories.\n   0.641559854784373\n   >>> tt.distances.d_Q(landmarks, trajectory1, trajectory2, version='signed', sigma=0.1) # Using signed version of the feature mapping in computation (sigma is needed in this version).\n   9.320212490006313e-35\n   >>> tt.distances.d_Q(landmarks, trajectory1, trajectory2, version='signed', sigma=0.1, p=float('inf')) # Using infinity-norm for calculating distance of two trajectories.\n   1.614308157002897e-34\n\ntrjtrypy.distances.d_Q_pi\n============================\ntrjtrypy.distances.d_Q_pi(landmarks, trajectory1, trajectory2, p=1)\n\n   The landmark-based distance d_Q_pi according to the definition in the\n   related reference is computed. \n\n   * **Parameters**        \n         * **landmarks: ndarray of shape (len(landmarks), 2)**\\\n                       An array containing coordinates of landmarks in each row. \n                  \n         * **trajectory1: ndarray of shape (len(trajectory1), 2)**\\\n                          An array that contains the waypoints of trajectory1\n                          consecutively.\n\n         * **trajectory2: ndarray of shape (len(trajectory2), 2)**\\\n                          An array that contains the waypoints of trajectory2\n                          consecutively.\n\n         * **p: float (1<=p<=infinity), default=2**\\\n                Specifies the p-norm used in calculations.\n   * **Returns**\n         * **float**\\\n                The d_Q_pi distance of trajectory1 and trajectory2.\n\n**Examples**\n\n.. code-block:: python\n\n   >>> import numpy as np\n   >>> import trjtrypy as tt\n   \n.. code-block:: python\n\n   >>> trajectory1 = np.array([[0,0], [2,2], [5,-1], [7,0]])\n   >>> trajectory2 = np.array([[1,1], [2,2], [4,-2], [4,0]])\n   >>> trajectories = np.array([trajectory1, trajectory2], dtype=object) # or [trajectory1, trajectory2]\n   >>> landmarks = np.array([[2,-1], [3,3], [2,0]]) # or [[2,-1], [3,3], [2,0]]\n\n.. code-block:: python\n\n   >>> tt.distances.d_Q_pi(landmarks, trajectory1, trajectory2)\n   1.5811388300841898\n\ntrjtrypy.visualizations.draw_landmarks_trajectory\n=====================================================\ntrjtrypy.visualizations.draw_landmarks_trajectory(landmarks, trajectory, version='unsigned', trj=True, lndmarks=True, dists=True, argminpnts=True, zoom=None, figsize=(10,10))\n\n   An interactive visualization tool that allows the user to draw landmarks, \n   trajectory, distances and nearest points of trajectory to the landmarks.\n\n   * **Parameters**        \n         * **landmarks: ndarray of shape (len(landmarks), 2)**\\\n                        An array containing coordinates of landmarks in each row. \n                        \n         * **trajectory: ndarray of shape (len(trajectory), 2)**\\\n                        An array that contains the waypoints of the trajectory\n                        consecutively.\n\n         * **version: str ('signed', 'unsigned'), default='unsigned'**\\\n                        Determines which version of the feature mappings is utilized.\n\n\n         * **trj: bool (True, False), default=True**\\\n                        Being True or False specifies whether the trajectory should be drawn\n                        or not.\n\n         * **lndmarks: bool (True, False), default=True**\\\n                        Setting True or False determines whether landmarks should be drawn \n                        or not.\n\n         * **dists: bool (True, False), default=True**\\\n                        Setting True or False determines whether distances (segments connecting\n                        a landmark to the nearest point on trajectory to that landmark) should\n                        be drawn or not.\n\n         * **argminpnts: bool (True, False), default=True**\\\n                        Setting True or False specifies if the nearest points on \n                        trajectory to landmarks should be drawn or not.\n\n         * **zoom: float**\\\n                        A positive float number which determines zooming in or out in \n                        a fixed figure size.\n\n         * **figsize: tuple**\\\n                        A tuple consisting of horizontal and vertical lengths of the \n                        output figure.\n   * **Returns**\\\n         A figure that can include the trajectory, landmarks, distances, argmin points according\n         to the selected properties by the user.\n\n**Examples**\n\n.. code-block:: python\n\n   >>> import numpy as np\n   >>> import trjtrypy as tt\n   \n.. code-block:: python\n\n   >>> trajectory = np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0.5,1], [0,0], [0,-1], [0,-2], [-1,-1.5], [1,-1], [2,0]])\n   >>> landmarks = np.array([[-2.5,1.5], [-2.5,2], [-2.5,2.5], [-2,0], [-1.5,1], [-1.5,2.5], [-0.5,-0.5], [-0.5,0.5], [-0.5,1], [0,1.5], [0.5,-0.5], [0.5,1.5], [2,-1], [2,0.5], [2.5,0], [2.5,0.5]]) # or [[-2.5,1.5], [-2.5,2], [-2.5,2.5], [-2,0], [-1.5,1], [-1.5,2.5], [-0.5,-0.5], [-0.5,0.5], [-0.5,1], [0,1.5], [0.5,-0.5], [0.5,1.5], [2,-1], [2,0.5], [2.5,0], [2.5,0.5]]\n\n.. code-block:: python\n\n   >>> tt.visualizations.draw_landmarks_trajectory(landmarks, trajectory, version='unsigned', trj=True, lndmarks=True, dists=True, argminpnts=True, zoom=None, figsize=(5,10))\n   \n.. image:: https://github.com/GoldenStarCode/test/blob/main/images/traj2.jpeg?raw=true\n         :width: 600px\n         :height: 500px\n         \nRemark: Notice argmin points are chosen by the smallest index if there is a tie.\n\nIn signed version the trajectory will be drawn in a directed form. As mentioned in reference distances in end points of the trajectory is not 2-norm, so those distances are shown by dotted line segments in visualization:\n\n.. code-block:: python\n\n   >>>  tt.visualizations.draw_landmarks_trajectory(landmarks,trajectory,version='signed',trj=True,lndmarks=True,dists=True,argminpnts=True,zoom=None,figsize=(10,10))\n   \n.. image:: https://github.com/GoldenStarCode/test/blob/main/images/traj2direct.jpg?raw=true\n   :width: 600px\n   :height: 500px    \n\nRemark: Notice argmin points are chosen by the smallest index if there is a tie.\n\ntrjtrypy.visualizations.colorcoding\n=======================================\ntrjtrypy.visualizations.colorcoding(vectorizedfunc, trajectory, version='unsigned', zoom=None, dpi=50, figsize=(10,10))\n\n   Visualizing the specified feature mapping by color considering every point \n   on a rectangular region, that includes the trajectory, as a potential landmark. \n\n   * **Parameters**        \n      * **vectorizedfunc: A vectorized function**\\\n                   Vectorized form of the function that is used to get the\n                   feature mapping.\n\n      * **trajectory: ndarray of shape (len(trajectory), 2)**\\\n                   An array that contains the waypoints of the trajectory\n                   consecutively.\n\n      * **version: str ('signed', 'unsigned'), default='unsigned'**\\\n                   Determines which version of the feature mappings is utilized.\n                   For unsigned version the sequential colormap is used but for\n                   signed version the diverging colormap is employed.\n\n      * **zoom: float**\\\n                   A positive float number which determines zooming in or out in \n                   a fixed figure size.\n\n      * **dpi: int, default=50**\\\n                   Specifies the resolution of the figure.\n\n      * **figsize: tuple**\n                   A tuple consisting of horizontal and vertical lengths of the \n                   output figure.\n\n   * **Returns**\\\n         The color-coded visualization of a specified feature mapping.\n\n**Examples**\n\nColor-coding of the unsigned version of the feature mapping:\n\n.. code-block:: python\n\n   import numpy as np\n   import trjtrypy as tt\n\n\n   trajectory=np.array([[0,0], [2,2], [5,-1], [7,0]]) # or [[0,0], [2,2], [5,-1], [7,0]]\n   # define the feature mapping function as follows:\n   def fmfunc(x,y): \n      return tt.featureMappings.curve2vec([[x,y]], [trajectory])[0]\n   # vectorize above function with numpy vectorize function\n   fmfunc=np.vectorize(fmfunc)\n   # color-code\n   tt.visualizations.colorcoding(fmfunc, trajectory, figsize=(10,7), zoom=.4) # figure 3\n\nFigure 3:\n\n.. image:: https://github.com/GoldenStarCode/tmg/blob/main/colorcodeunsigned.jpeg?raw=true\n\nColor-coding of the signed version of the feature mapping:\n\n.. code-block:: python\n\n   import numpy as np\n   import trjtrypy as tt\n\n\n   trajectory=np.array([[0,0], [2,2], [5,-1], [7,0]]) # or [[0,0], [2,2], [5,-1], [7,0]]\n   # define the feature mapping function as follows:\n   def fmfunc(x,y): \n      return tt.featureMappings.curve2vec([[x,y]], [trajectory], version='signed')[0]\n   # vectorize above function with numpy vectorize function\n   fmfunc=np.vectorize(fmfunc)\n   # color-code\n   tt.visualizations.colorcoding(fmfunc, trajectory, version='signed', figsize=(10,7), zoom=.4) # figure 4\n\nFigure 4:\n\n.. image:: https://github.com/GoldenStarCode/tmg/blob/main/colorcodesigned.jpeg?raw=true\n\ntrjtrypy.basedists.distacne\n==============================\ndistance(points, curves, version='unsigned', segIndx=False, argPnts=False)\n\n   Calculates the distance of each point in points from each curve in curves\n   at the same time.\n\n   * **Parameters**\n      * **points: ndarray of shape (len(points),)**\\\n                             An array that contains coordinates of points\n                             in each row.\n                             \n      * **curves: ndarray of shape (len(curves),)**\\\n                             Piecewise linear curves in R^2 of shape (n, 2).\n                             Notice n can be different for each curve.\n                             \n      * **version: str ('unsigned', 'signed'), default='unsigned'**\\\n                             Determines unsigned or signed distance that is going\n                             to be computed.\n                             \n      * **segIndx: bool (True, False), default=False**\n                             Being True or False determines whether the\n                             function outputs the indices of segments selected\n                             by the points.\n\n      * **argPnts: bool (True, False), default=False**\n                             Setting True or False specifies if the function outputs\n                             the nearest points on curves to points.\n                                   \n                        \n   * **Returns**\n      * **ndarray**\n                  The array of unsigned/signed distances.\n                  Moreover, when segIndx or argPnts are called an array of dictionaries\n                  including the distance values, selected segments' indices or\n                  argmin points respectively for all curves is given.\n\n\n**Remark**\n\n* Note that the signed version implemented here is different from the signed version used in curve2vec feature mapping. Indeed, the signed distance that is computed by distance function here is unsigned distance value with sign according to the right hand rule considering the orientation of the curve.\n\n\n\n* Signed version of this function will give zero for points that their sign cannot be determined by the right hand rule. As an example consider the curve [ [0,0], [1,1] ] and point [-1,-1]. Then the value of the signed version is 0.\n\n**Examples**\n\n.. [i] The minimum distance between a point and any (complicated) piecewise linear curve/curves:\n\nThe minimum distance between a point and any (complicated) piecewise linear curve:\n\n.. code-block:: python\n\n   import numpy as np\n   import trjtrypy as tt\n\n\n   # define a point\n   apoint=np.array([[-0.5, -0.5]])\n   # define a curve\n   curve=np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0,1], [0,0], [0,-1], [0,-2], [-1,-1], [1,-1.5], [2,0]])\n\n   # make apoint and curve appropriate for distance function as inputs\n   points=apoint\n   curves=np.array([curve], dtype=object)\n\n   # compute unsigned distance \n   tt.basedists.distance(points, curves) # returns array([[0.5]])\n\n   # compute signed distance \n   tt.basedists.distance(points, curves, version='signed') # returns array([[-0.5]])\n\nThe minimum distance between a point and any (complicated) piecewise linear curves:\n\n.. code-block:: python\n\n   import numpy as np\n   import trjtrypy as tt\n\n\n   # define a point\n   apoint=np.array([[-0.5, -0.5]])\n   # define curve1\n   curve1=np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0,1], [0,0], [0,-1], [0,-2], [-1,-1], [1,-1.5], [2,0]])\n   # define curve2\n   curve2=np.array([[0,0], [2,2], [5,-1], [7,0]])\n\n   # make apoint, curve1 and curve2 appropriate for distance function as inputs\n   points=apoint\n   curves=np.array([curve1, curve2], dtype=object)\n\n   # compute unsigned distances\n   tt.basedists.distance(points, curves) # returns array([[0.5       ],\n                                         #                [0.70710678]])\n\n   # compute signed distances\n   tt.basedists.distance(points, curves, version='signed') # returns array([[-0.5],\n                                                           #                [ 0. ]]) this is zero because point [-0.5,-0.5] is positioned at the direction of the first segment of curve2\n\n.. [ii] The minimum distance of all points in a set of points from a curve/curves simultaneously:\n\nThe minimum distance of all points in a set of points from a curve simultaneously:\n\n.. code-block:: python\n\n   import numpy as np\n   from trjtrypy.basedists import distance\n\n\n   # define a set of points\n   setpoints=np.array([[-2.5,1.5], [-2.5,2], [-2.5,2.5], [-2,0], [-1.5,1], [-1.5,2.5], [-0.5,-0.5], [-0.5,0.5], [-0.5,1], [0,1.5], [0.5,-0.5], [0.5,1.5], [2,-1], [2,0.5], [2.5,0], [2.5,0.5]])\n   # define a curve\n   curve=np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0.5,1], [0,0], [0,-1], [0,-2], [-1,-1.5], [1,-1], [2,0]])\n\n\n   # make setpoints and curve usable for distance function as inputs\n   points=setpoints\n   curves=np.array([curve], dtype=object)\n\n   # compute unsigned distance \n   distance(points, curves) # returns array([[7.07106781e-01, 5.00000000e-01, 7.07106781e-01, 7.07106781e-01,\n                            #                 3.53553391e-01, 5.00000000e-01, 5.00000000e-01, 5.00000000e-01,\n                            #                 3.53553391e-01, 3.53553391e-01, 5.00000000e-01, 1.57009246e-16,\n                            #                 7.07106781e-01, 5.00000000e-01, 5.00000000e-01, 7.07106781e-01]])\n\n   # compute signed distance \n   distance(points, curves, version='signed') # returns array([[-7.07106781e-01,  0.00000000e+00,  7.07106781e-01,\n                                              #                 -7.07106781e-01,  3.53553391e-01,  5.00000000e-01,\n                                              #                 -5.00000000e-01, -5.00000000e-01, -3.53553391e-01,\n                                              #                 -3.53553391e-01,  5.00000000e-01, -1.57009246e-16,\n                                              #                 -7.07106781e-01,  5.00000000e-01, -5.00000000e-01,\n                                              #                  0.00000000e+00]])\n\nThe minimum distance of all points in a set of points from curves simultaneously:\n\n.. code-block:: python\n\n   import numpy as np\n   from trjtrypy.basedists import distance\n\n\n   # define a set of points\n   setpoints=np.array([[-2.5,1.5], [-2.5,2], [-2.5,2.5], [-2,0], [-1.5,1], [-1.5,2.5], [-0.5,-0.5], [-0.5,0.5], [-0.5,1], [0,1.5], [0.5,-0.5], [0.5,1.5], [2,-1], [2,0.5], [2.5,0], [2.5,0.5]])\n   # define curve1\n   curve1=np.array([[-2,2], [-1,2], [-2,1], [-1,0], [-1,1], [0,2], [1,1], [0.5,1], [0,0], [0,-1], [0,-2], [-1,-1.5], [1,-1], [2,0]])\n   # define curve2\n   curve2=np.array([[0,0], [2,2], [5,-1], [7,0]])\n\n   # make setpoints, curve1 and curve2 appropriate for distance function as inputs\n   points=setpoints\n   curves=np.array([curve1, curve2], dtype=object)\n\n   # compute unsigned distance \n   distance(points, curves) # returns array([[7.07106781e-01, 5.00000000e-01, 7.07106781e-01, 7.07106781e-01,\n                            #                 3.53553391e-01, 5.00000000e-01, 5.00000000e-01, 5.00000000e-01,\n                            #                 3.53553391e-01, 3.53553391e-01, 5.00000000e-01, 1.57009246e-16,\n                            #                 7.07106781e-01, 5.00000000e-01, 5.00000000e-01, 7.07106781e-01],\n                            #                [2.91547595e+00, 3.20156212e+00, 3.53553391e+00, 2.00000000e+00,\n                            #                 1.80277564e+00, 2.82842712e+00, 7.07106781e-01, 7.07106781e-01,\n                            #                 1.06066017e+00, 1.06066017e+00, 7.07106781e-01, 7.07106781e-01,\n                            #                 2.12132034e+00, 1.06066017e+00, 1.06066017e+00, 7.07106781e-01]])\n   \n   # compute signed distance \n   distance(points, curves, version='signed') # returns array([[-7.07106781e-01,  0.00000000e+00,  7.07106781e-01,\n                                              #                 -7.07106781e-01,  3.53553391e-01,  5.00000000e-01,\n                                              #                 -5.00000000e-01, -5.00000000e-01, -3.53553391e-01,\n                                              #                 -3.53553391e-01,  5.00000000e-01, -1.57009246e-16,\n                                              #                 -7.07106781e-01,  5.00000000e-01, -5.00000000e-01,\n                                              #                  0.00000000e+00],\n                                              #                [ 2.91547595e+00,  3.20156212e+00,  3.53553391e+00,\n                                              #                  2.00000000e+00,  1.80277564e+00,  2.82842712e+00,\n                                              #                  0.00000000e+00,  7.07106781e-01,  1.06066017e+00,\n                                              #                  1.06066017e+00, -7.07106781e-01,  7.07106781e-01,\n                                              #                  -2.12132034e+00, -1.06066017e+00, -1.06066017e+00,\n                                              #                  -7.07106781e-01]])\n\n.. [iii] The minimum distance of a point/set of points from a line segment:\n\nThe minimum distance of a point from a line segment:\n\n.. code-block:: python\n\n   import numpy as np\n   from trjtrypy.basedists import distance\n\n\n   # define a point\n   apoint = np.array([[-0.5, -0.5]])\n   # define a line segment\n   linesegment = np.array([[1,-1], [2,0]])\n\n   # make apoint and linesegment appropriate for distance function as inputs\n   points = apoint\n   curves = np.array([linesegment], dtype=object)\n\n   # compute unsigned distance \n   distance(points, curves) # array([[1.58113883]])\n\n   # compute signed distance \n   distance(points, curves) # array([[1.58113883]])\n   \n\n\nThe minimum distance of a set of points from a line segment:\n\n.. code-block:: python\n\n   import numpy as np\n   from trjtrypy.basedists import distance\n\n\n\n   #define a set of points\n   setpoints = np.array([[-2.5,1.5], [-2.5,2], [-2.5,2.5], [-2,0], [-1.5,1], [-1.5,2.5], [-0.5,-0.5], [-0.5,0.5], [-0.5,1], [0,1.5], [0.5,-0.5], [0.5,1.5], [2,-1], [2,0.5], [2.5,0], [2.5,0.5]])\n   # define a line segment\n   linesegment = np.array([[[1,-1], [2,0]]])\n\n   # make setpoints and linesegment applicable for distance function as inputs\n   points = setpoints\n   curves = linesegment\n\n \n   # compute unsigned distance \n   distance(points, curves) # array([[4.30116263, 4.60977223, 4.94974747, 3.16227766, 3.20156212,\n                            #         4.24264069, 1.58113883, 2.12132034, 2.47487373, 2.47487373,\n                            #         0.70710678, 2.12132034, 0.70710678, 0.5       , 0.5       ,\n                            #         0.70710678]])\n   # compute signed distance \n   distance(points, curves) # array([[4.30116263,  4.60977223,  4.94974747,  3.16227766,  3.20156212,\n                            #         4.24264069,  1.58113883,  2.12132034,  2.47487373,  2.47487373,\n                            #         0.70710678,  2.12132034, -0.70710678,  0.5       , -0.5       ,\n                            #         0.        ]])\n\n\n\n\n\n\n\nFurther applications\n********************\n\n1. Application for curves\n============================\nOne can approximate any continuous curve via trajectories with a sufficient accuracy, then apply this package functionalities for the resulted approximate version of the curve.\n\n2. Application for two dimensional times series\n=================================================\nBy connecting consecutive points in a 2d times series one can make a trajectory in order \nto use this package functionalities.\n\n3. Application in Machine Learning\n===================================\n* One of the biggest advantages of this package is enabling machine learning algorithms on trajectory datasets. In fact, using curve2vec featurization one can convert each trajectory to a vector and thus apply any machine learning algorithm. For instance, one can do classification tasks using machine learning or deep learning classifiers such as Support Vector Machine, Decision Tree, Random Forest, Neural Networks, etc. as it is done in the references [1]_, [2]_.\n\n* It is needless to say that using d_Q or d_Q_pi distances as similarity measures one may do Clustering or apply KNN (K-Nearest Neighborhood).\n\nData sets\n*********\n\nHere we include the link to several famous trajectory data sets:\n\n* Geolife trajectory dataset from Microsoft: https://msropendata.com/datasets/d19b353b-7483-4db7-a828-b130f6d1f035 \n* T-Drive trajectory dataset from Microsoft: https://www.microsoft.com/en-us/research/publication/t-drive-driving-directions-based-on-taxi-trajectories/\n* Car-Bus trajectory dataset from UCI Machine Learning Repository: https://archive.ics.uci.edu/ml/datasets/GPS+Trajectories\n* Character trajectories dataset from UCI Machine Learning Repository: https://archive.ics.uci.edu/ml/datasets/Character+Trajectories\n\nReferences\n**********\n\n.. [1]  Jeff M. Phillips and Pingfan Tang. Simple distances for trajectories via landmarks. In ACM GIS SIGSPATIAL, 2019.\n         https://dl.acm.org/doi/pdf/10.1145/3347146.3359098\n\n\n.. [2]  Jeff M. Phillips and Hasan Pourmahmood-Aghababa. Orientation-Preserving Vectorized Distance Between Curves. MSML21, August 2021.\n         https://arxiv.org/pdf/2007.15924\n\nCitation\n********\n\nIf you found this package or information helpful, please cite above references.\n\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/GoldenStarCode/trjtrypy",
    "keywords": "",
    "license": "MIT license",
    "maintainer": "",
    "maintainer_email": "",
    "name": "trjtrypy",
    "package_url": "https://pypi.org/project/trjtrypy/",
    "platform": "",
    "project_url": "https://pypi.org/project/trjtrypy/",
    "project_urls": {
      "Bug Reports": "https://github.com/GoldenStarCode/trjtrypy/issues",
      "Documentation": "https://github.com/GoldenStarCode/trjtrypy/blob/main/README.rst",
      "Homepage": "https://github.com/GoldenStarCode/trjtrypy",
      "Source": "https://github.com/GoldenStarCode/trjtrypy/"
    },
    "release_url": "https://pypi.org/project/trjtrypy/0.0.0/",
    "requires_dist": [
      "numpy (>=1.19.1)",
      "scipy (>=1.6.3)",
      "matplotlib (>=3.3.2)"
    ],
    "requires_python": ">=3.7",
    "summary": "Distance between trajectories",
    "version": "0.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10867719,
  "releases": {
    "0.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fdaeb63b576742b3239d55438a39ff0563d115214f896553fab8f629ace5718f",
          "md5": "85cb66ba82c55ea9d561243a315c7c40",
          "sha256": "e66030c9dc8021181aaeeb56af4e95fbde063d06456b0f482c9c2431e90a1142"
        },
        "downloads": -1,
        "filename": "trjtrypy-0.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "85cb66ba82c55ea9d561243a315c7c40",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 20700,
        "upload_time": "2021-07-08T22:04:06",
        "upload_time_iso_8601": "2021-07-08T22:04:06.525733Z",
        "url": "https://files.pythonhosted.org/packages/fd/ae/b63b576742b3239d55438a39ff0563d115214f896553fab8f629ace5718f/trjtrypy-0.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c553541d0743f4aeaaf45e2fc74eeb1f58db09840570c3419c6856017fc1f8b",
          "md5": "fc73c374f49363a01fe9de41e1833d13",
          "sha256": "d2a275640ac2b8de25adf1792eb68e522c81a15b56998e260f3203223b672ddc"
        },
        "downloads": -1,
        "filename": "trjtrypy-0.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "fc73c374f49363a01fe9de41e1833d13",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 31299,
        "upload_time": "2021-07-08T22:04:10",
        "upload_time_iso_8601": "2021-07-08T22:04:10.152858Z",
        "url": "https://files.pythonhosted.org/packages/8c/55/3541d0743f4aeaaf45e2fc74eeb1f58db09840570c3419c6856017fc1f8b/trjtrypy-0.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fdaeb63b576742b3239d55438a39ff0563d115214f896553fab8f629ace5718f",
        "md5": "85cb66ba82c55ea9d561243a315c7c40",
        "sha256": "e66030c9dc8021181aaeeb56af4e95fbde063d06456b0f482c9c2431e90a1142"
      },
      "downloads": -1,
      "filename": "trjtrypy-0.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "85cb66ba82c55ea9d561243a315c7c40",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 20700,
      "upload_time": "2021-07-08T22:04:06",
      "upload_time_iso_8601": "2021-07-08T22:04:06.525733Z",
      "url": "https://files.pythonhosted.org/packages/fd/ae/b63b576742b3239d55438a39ff0563d115214f896553fab8f629ace5718f/trjtrypy-0.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8c553541d0743f4aeaaf45e2fc74eeb1f58db09840570c3419c6856017fc1f8b",
        "md5": "fc73c374f49363a01fe9de41e1833d13",
        "sha256": "d2a275640ac2b8de25adf1792eb68e522c81a15b56998e260f3203223b672ddc"
      },
      "downloads": -1,
      "filename": "trjtrypy-0.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "fc73c374f49363a01fe9de41e1833d13",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 31299,
      "upload_time": "2021-07-08T22:04:10",
      "upload_time_iso_8601": "2021-07-08T22:04:10.152858Z",
      "url": "https://files.pythonhosted.org/packages/8c/55/3541d0743f4aeaaf45e2fc74eeb1f58db09840570c3419c6856017fc1f8b/trjtrypy-0.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}