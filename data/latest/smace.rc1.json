{
  "info": {
    "author": "Gianluigi Lopardo",
    "author_email": "Gianluigi.Lopardo@inria.fr",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python :: 3",
      "Topic :: Scientific/Engineering",
      "Topic :: Scientific/Engineering :: Artificial Intelligence"
    ],
    "description": "\n# SMACE --- Semi-Model-Agnostic Contextual Explainer\n\nPython code for [*SMACE: A New Method for the Interpretability of Composite Decision Systems*](https://arxiv.org/abs/2111.08749).\n\nThe code is stored in two main repositories: `smace` and `evaluation`. The first one contains the code behind the method (see below for **Usage**).\nThe `evaluation` folder contains a `notebooks` subfolder, where some simple example are given as [Jupyter Notebook](https://jupyter.org/).\nAggregated experiments are in the `experiments` folder and the results saved in the `results` subfolder.\n\n## Evaluation\nThe experiments in Section **5.1 Simple cases** of the paper are available as notebooks (in  `evaluation/notebooks`) :\n* `rule_only.ipynb` refers to **Rules only**\n* `hybrid_paper.ipynb` refers to **Symple hybrid system**\nThe folder also contains additional experiments.\n\nThe experiment in Section **5.2 Realistic use case** of the paper is generated by `telco.py` in  `evaluation/experiments`. The folder contains additional experiments with different decision-making systems on synthetic data.\nThese experiments should be performed individually, and when finished, the results will be available in the directory `evaluation/experiments/results`.\n\n\n## Usage\nFirst,  one must define the decision-making system,  _i.e._,  a  `DM`  object.  To define it,  you need a set of rules in JSON format,  a list of models,  and a  [pandas DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).\n\n### 1. Define your set of rules\nThe rules must be defined in a JSON object,  resulting in Python lists/dictionaries.  Each  `rule`  is a dictionary with two fields:  `conditions`  and  `decision`.  The latter is the output of the decision process,  if the rule is satisfied.  A condition is defined by the triple  `(name, operator, value)`:\n-   `name`  is the variable referred to;\n-   `operator`  can be  `geq`  ($\\geq$),  `gt`  ($>$),  `leq`  ($\\leq$),  `lt`  ($<$);\n-   `value`  is the cutoff.\n\nAs an example,  let us say our set of variables includes four features:  $x_1$,  $x_2$,  $x_3$,  $x_4$,  and two models:  `model_1`  and  `model_2`.  The JSON with two rules  `rule1`  and  `rule2`  can be as follow:\n\n```\n{\"rule1\": {\"conditions\": [{\"name\": \"x2\",\n                             \"operator\": \"geq\",\n                             \"value\": 0.6},\n                            {\"name\": \"x3\",\n                             \"operator\": \"geq\",\n                             \"value\": 0.25},\n                            {\"name\": \"model_1\",\n                             \"operator\": \"geq\",\n                             \"value\": 1},\n                            {\"name\": \"model_2\",\n                             \"operator\": \"leq\",\n                             \"value\": 50}],\n            \"decision\": \"decision1\"},\n\"rule2\": {\"conditions\": [{\"name\": \"x4\",\n                             \"operator\": \"geq\",\n                             \"value\": 0.1},\n                            {\"name\": \"model_1\",\n                             \"operator\": \"geq\",\n                             \"value\": 0.2},\n                            {\"name\": \"x1\",\n                             \"operator\": \"geq\",\n                             \"value\": 0.1},\n                            {\"name\": \"x4\",\n                             \"operator\": \"leq\",\n                             \"value\": 0.9}],\n            \"decision\": \"decision2\"}\n}\n\n```\n\nOnce defined,  to read a JSON file one can use the  `json`  ([docs here](https://docs.python.org/3/library/json.html))  to read it:\n\n```\nimport json\nwith open('rules.json', 'r') as fp:\n    rules_json = json.load(fp)\n\n```\n\n### 2. Define your list of models\n\nA model can be any function that works on a subset of the original data,  with a numerical output.  `DM`  needs a  `Model`  object initialized as  `Model(predictive_function, model_name, data)`,  where\n\n-   `predictive_function`  is the function that produces the output. In the case of a  `sklearn`  model  `m`  for regression (resp., for classification), for instance, it corresponds to  `m.predict`  (resp.,  `m.predict_proba`);\n-   `model_name`  is the name used in the rules to refer to the output of the model;\n-   `data`  is the  `pandas.DataFrame`  to which the model is applied.\n\nFor example,  assuming we have a dataset  `X`  and two targets  `y1`  and  `y2`,  we can proceed as follows:\n\n```\nfrom smace.models import Model\n\nlm = linear_model.LinearRegression()\nlm.fit(X,y1)\n\nxgb = xgboost.XGBClassifier()\nxgb.fit(X,y2)\n\nmodel_1 = Model(lm.predict, 'model_1', df)\nmodel_2 = Model(xgb.predict_proba, 'model_2', df)\n\nmodels_list = [model_1, model_2]\n\n```\n\n### 3. Define the  `DM`  object\n\nHaving the rules  `rules_json`,  the list of models  `models_list`  and the input dataset  `df`,  you can construct the  `DM`  object as\n\n```\nfrom smace.decisions import DM\ndm = DM(rules_json, models_list, df)\n\n```\n\nTo get the decision explicitly for an example,  we use the  `make_decision()`  function:\n\n```\nexample = np.random.rand(4)\ndecision = dm.make_decision(example, verbose=True)\n\n```\n\n```\nOutput:\n    Rule(s) ['rule1'] triggered.\n    Decision(s) ['decision1'] made.\n\n```\n\n### Apply SMACE\n\nOnce the configuration is complete,  you can use SMACE to explain the decisions of the defined system.\n\nLet us say we want to explain why for the example above  `rule2`  was not triggered:\n\n```\nfrom smace.explainer import Smace\nexplainer = Smace(dm)\n\nexplanation = explainer.explain(example, 'rule2')\n\n```\n\n`explanation`  contains all the information computed by SMACE.  The following methods can be applied:\n\n-   `explanation.table()`  and  `explanation.bar()`  to obtain the overall contributions of the input features as tables or bars, respectively;\n-   `explanation.rule_table()`  and  `explanation.rule_bar()`  to get the contributions of all variables in the rule as tables or bars, respectively;\n-   `explanation.model_table('mod')`  and  `explanation.model_bar('mod')`  to get the importance of input features to the model named  `'mod'`.\n\nIt is possible to specify the maximum number of variables to display through the  `num_features`  parameters.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/gianluigilopardo/smace",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "smace",
    "package_url": "https://pypi.org/project/smace/",
    "platform": null,
    "project_url": "https://pypi.org/project/smace/",
    "project_urls": {
      "Homepage": "http://github.com/gianluigilopardo/smace"
    },
    "release_url": "https://pypi.org/project/smace/0.0/",
    "requires_dist": [
      "numpy (==1.20.3)",
      "pandas (==1.2.5)",
      "cvxpy (==1.1.15)",
      "shap (==0.39.0)",
      "lime (==0.2.0.1)",
      "matplotlib (==3.4.3)",
      "xgboost (==1.4.2)",
      "scikit-learn (==0.24.2)",
      "scipy (==1.7.1)"
    ],
    "requires_python": ">=3.7",
    "summary": "Semi-Model-Agnostic Contextual Explainer library",
    "version": "0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15020384,
  "releases": {
    "0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3164bfacaab6ed7b5506529b369a937a3df6b83ed5badbcbf415e9131bcaaae8",
          "md5": "2a6939cc5e3632f5ba675f9cf96e7182",
          "sha256": "d73e00d57e8ace1d62822790b4a6ade600c09ae2f48d441887bca5e62b12ddfc"
        },
        "downloads": -1,
        "filename": "smace-0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "2a6939cc5e3632f5ba675f9cf96e7182",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 10703,
        "upload_time": "2022-09-07T15:02:46",
        "upload_time_iso_8601": "2022-09-07T15:02:46.315515Z",
        "url": "https://files.pythonhosted.org/packages/31/64/bfacaab6ed7b5506529b369a937a3df6b83ed5badbcbf415e9131bcaaae8/smace-0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3164bfacaab6ed7b5506529b369a937a3df6b83ed5badbcbf415e9131bcaaae8",
        "md5": "2a6939cc5e3632f5ba675f9cf96e7182",
        "sha256": "d73e00d57e8ace1d62822790b4a6ade600c09ae2f48d441887bca5e62b12ddfc"
      },
      "downloads": -1,
      "filename": "smace-0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "2a6939cc5e3632f5ba675f9cf96e7182",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 10703,
      "upload_time": "2022-09-07T15:02:46",
      "upload_time_iso_8601": "2022-09-07T15:02:46.315515Z",
      "url": "https://files.pythonhosted.org/packages/31/64/bfacaab6ed7b5506529b369a937a3df6b83ed5badbcbf415e9131bcaaae8/smace-0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}