{
  "info": {
    "author": "Nâmio Evangelista Cavalcante de Sousa",
    "author_email": "namio.sousa@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Environment :: Web Environment",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Natural Language :: English",
      "Natural Language :: Portuguese",
      "Natural Language :: Portuguese (Brazilian)",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "[![PyPI](https://img.shields.io/pypi/v/BRADocs4Py.svg)](https://pypi.org/project/bradocs4py/)\n[![GitHub top language](https://img.shields.io/github/languages/top/namio/BRADocs4Py.svg)](https://github.com/namio/BRADocs4Py.git)\n[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/BRADocs4Py.svg)](https://pypi.org/project/bradocs4py/)\n[![PyPI - Wheel](https://img.shields.io/pypi/wheel/BRADocs4Py.svg)](https://pypi.org/project/bradocs4py/)\n[![PyPI - Implementation](https://img.shields.io/pypi/implementation/BRADocs4Py.svg)](https://pypi.org/project/bradocs4py/)\n[![GitHub](https://img.shields.io/github/license/namio/BRADocs4Py.svg)](https://github.com/namio/BRADocs4Py/blob/master/LICENSE)\n[![GitHub last commit](https://img.shields.io/github/last-commit/namio/BRADocs4PY.svg)](https://github.com/namio/BRADocs4Py.git)\n[![Say Thanks!](https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg)](https://saythanks.io/to/namio)\n\n# BRADocs4Py\n\nBRADocs4Py é uma biblioteca que visa fornecer componentes para trabalhar com tipos de dados específicos da realidade brasileira.\n\nEsta biblioteca surgiu mediante a necessidade de se ter tipos específicos que possibilitem lidar com documentos de identificação próprios do Brasil, como é o caso do Cadastro de Pessoa Física (CPF) e do Cadastro Nacional de Pessoa Jurídica (CNPJ).\n\nAlém de conter classes que representam o modelo computacional dos principais documentos brasileiros, esta biblioteca também disponibiliza classes que permitem a validação e a geração de números válidos para estes documentos; sendo estas últimas disponibilizadas exclusivamente para fins de testes computacionais.\n\n> This software is coded and documented in portuguese only as it is intended to be used to generate the necessary files for the brazilian government regarding to digital bookkeeping.\n\n## Requisitos\n\n  * python\n\n## Como instalar\n\n    $ pip install bradocs4py\n\n## Objetivos do Projeto\n\nA ideia inicial do projeto e unificar em uma única biblioteca módulos que permitam representar computacionalmente e validar documentos brasileiros - inicialmente CPF e CNPJ, além de permitir a geração de números válidos para estes documentos.\n\n## Compatibilidade do Projeto\n\nO projeto inicialmente suportará apenas Python 3.6.5+.\n\nOutras linguagens de programação poderão ter versões especificas conforme minha disponibilidade de tempo.\n\n## Status do Projeto\n\nO projeto está em fase inicial de desenvolvimento.\n\n| Módulo                              |  Situação       |\n|:------------------------------------|:---------------:|\n| [DocumentoIdentificacao](#di)       |Funcional        |\n| [CPF](#cpf)                         |Funcional        |\n| [ValidadorCpf](#vcpf)               |Funcional        |\n| [GeradorCpf](#gcpf)                 |Funcional        |\n| [Cnpj](#cnpj)                       |Funcional        |\n| [ValidadorCnpj](#vcnpj)             |Funcional        |\n| [GeradorCnpj](#gcnpj)               |Funcional        |\n| [InscricaoEstadual](#ie)            |Funcional        |\n| [ValidadorInscricaoEstadual](#vie)  |Funcional        |\n| [GeradorInscricaoEstadual](#gie)    |Não implementado |\n| [InscricaoSuframa](#is)             |Funcional        |\n| [ValidadorSuframa](#vs)             |Funcional        |\n| [GeradorSuframa](#gs)               |Funcional        |\n| [ChaveAcessoNFe](#chave)            |Funcional        |\n| [ValidadorChaveAcessoNFe](#vchave)  |Funcional        |\n| [GeradorChaveAcessoNFe](#gchave)    |Funcional        |\n| [GTIN](#gtin)                       |Funcional        |\n| [ValidadorGTIN](#vgtin)             |Funcional        |\n| [GeradorGTIN](#ggtin)               |Funcional        |\n\n\n### <a name=\"di\"></a> DocumentoIdentificacao\n\nClasse abstrata, não podendo ser instanciada diretamente, serve como base para todas as classes que representam um documento de identificação ou qualquer outro documento brasileiro que necessite de validação.\n\n### <a name=\"cpf\"></a> CPF\n\nClasse usada para representar em código Pyhton um _Cadastro de Pessoa Física_ (CPF); permitindo representá-lo textualmente, com a devida formatação e identificar a sua validade.\n\n#### Utilização\n\n    >>> cpf = CPF('52513127765')\n    >>> cpf\n    '525.131.277-65'\n\n    >>> cpf.isValid\n    True\n\n    >>> cpf.rawValue\n    52513127765\n\n    >>> cpf = CPF('abcdefghijk')\n    >>> cpf.isValid\n    False\n\n    >>> print(cpf)\n    abcdefghijk\n\n    >>> print(cpf.rawValue)\n    abcdefghijk\n\n> Independente do conteúdo passado ao se criar uma instância de CPF, **sempre** obter-se-á uma instância deste. Caberá consultar a propriedade __isValid__ de uma instância de CPF para verificar se esta é válida ou não.\n\n> A representação textual de uma instância de CPF só será exibida caso esta instância contenha um número válido de CPF; ao contrário será exibida a _string_ utilizada para criá-la.\n\n> Para obter a _string_ utilizada ao instanciar um CPF, basta acessar a propriedade **rawValue** da instância criada.\n\n### <a name=\"vcpf\"></a> ValidadorCpf\n\nClasse responsável por validar uma instância de CPF ou uma _string_ contendo a representação numérica de um CPF.\n\n#### Utilização\n\n    >>> cpf = CPF('abcdefghijk')\n    >>> ValidadorCpf.validar(cpf)\n    False\n\n    >>> ValidadorCpf.validar('123.456.789-00')\n    False\n\n    Foi criado um CPF válido, porém foi digitado um caractere de separação diferente dos caracteres esperados (.-/ ). Mesmo assim, o validador informa tratar-se de um CPF correto\n    >>> cpf = CPF('508,697,212-40')\n    >>> ValidadorCpf.validar(cpf)\n    True\n\n### <a name=\"gcpf\"></a> GeradorCpf\n\nClasse responsável por gerar aleatoriamente um CPF válido.\n\n#### Utilização\n\n    >>> cpf = GeradorCpf.gerar()\n    >>> cpf.isValid\n    True\n\n### <a name=\"cnpj\"></a> Cnpj\n\nClasse usada para representar em código Pyhton um _Cadastro Nacional de Pessoa Jurídica_ (CNPJ); permitindo representá-lo textualmente, com a devida formatação e identificar a sua validade.\n\n#### Utilização\n\n\t>>> cnpj = Cnpj('abcdefghijklmn')\n\t>>> cnpj.isValid\n\tFalse\n\n\t>>> cnpj = Cnpj('12345678901234')\n\t>>> cnpj.isValid\n\tFalse\n\n\t>>> cnpj = Cnpj('19.658.147/0001-0O')\n\t>>> cnpj.isValid\n\tFalse\n\n\t>>> cnpj = Cnpj('19.658.147/0001-00')\n\t>>> cnpj.isValid\n\tTrue\n\n> Independente do conteúdo passado ao se criar uma instância de CNPJ, **sempre** obter-se-á uma instância deste. Caberá consultar a propriedade __isValid__ de uma instância de CNPJ para verificar se esta é válida ou não.\n\n> A representação textual de uma instância de CNPJ só será exibida caso esta instância contenha um número válido de CNPJ; ao contrário será exibida a _string_ utilizada para criá-la.\n\n> Para obter a _string_ utilizada ao instanciar um CNPJ, basta acessar a propriedade **rawValue** da instância criada.\n\n### <a name=\"vcnpj\"></a> ValidadorCnpj\n\nClasse responsável por validar uma instância de CNPJ ou uma _string_ contendo a representação numérica de um CNPJ.\n\n#### Utilização\n\n\t>>> cnpj = Cnpj('abcdefghijklmn')\n\t>>> ValidadorCnpj.validar(cnpj)\n\tFalse\n\n\t>>> cnpj = Cnpj('19.658.147/0001-0O')\n\t>>>ValidadorCnpj.validar(cnpj)\n\tFalse\n\n\t>>> ValidadorCnpj.validar('12345678901234')\n\tFalse\n\n\t>>> cnpj = Cnpj('34  633 423,0001/60')\n\t>>> ValidadorCnpj.validar(cnpj)\n\tTrue\n\n\t>>> ValidadorCnpj.validar('05.692.744/0001-38')\n\tTrue\n\n### <a name=\"gcnpj\"></a> GeradorCnpj\n\nClasse responsável por gerar aleatoriamente um CNPJ válido.\n\n#### Utilização\n\n    >>> cnpj = GeradorCnpj.gerar()\n    >>> cnpj.isValid\n    True\n\n### <a name=\"is\"></a> InscricaoSuframa\n\nRepresenta o número de inscrição na Superintendência da Zona Franca de Manaus (SUFRAMA)\n\n> A SUFRAMA mantém controle sobre as empresas com insentivo fiscal, identificando-as através do número de _Inscrição SUFRAMA_.\n\nA composição deste indicador é: _SS.NNNN.LLD_, onde:\n\n**SS** representa o __código do setor de atividade__ da empresa, conforme exemplo abaixo:\n\n| Código  | Descrição                   |\n| :----:  | :---------------------------|\n| 01 e 02 | Cooperativa                 |\n| 10 e 11 | Comércio                    |\n| 20      | Indústria com projeto pleno |\n| 60      | Serviços                    |\n\n**NNNN** número sequencial\n\n**LL** representa o código da licalidade da Unidade Administrativa da Suframa que habilitou a empresa, conforme exemplo abaixo:\n\n\n| Código | Descrição   |\n| :----: | :-----------|\n|   01   | Manaus      |\n|   10   | Boa Vista   |\n|   30   | Porto Velho |\n\n**D** dígito verificador\n\n#### Validação\n\n* Campo numérico com 9 posições (incluindo o dígito verificador).\n* Pode iniciar por 0 (zero), mas não pode iniciar por 00.\n* Dígito verificador calculado por [__módulo 11__](https://pt.wikipedia.org/wiki/D%C3%ADgito_verificador#Módulo_11 \"Método de cálculo do dígito verificador usando Módulo 11\"), pesos 2 a 9.\n\n#### Utilização\n\n    >>> x = InscricaoSuframa('01.1234.129')\n    >>> x.rawValue\n    '011234129'\n    >>> print(x)\n    01.1234.129\n    >>> x.isValid\n    False\n\n    >>> x = InscricaoSuframa('101580100')\n    >>> x.rawValue\n    '101580100'\n    >>> print(x)\n    10.1580.100\n    >>> x.isValid\n    True\n\n    >>> x = InscricaoSuframa('1015801OO')\n    >>> x.rawValue\n    '1015801OO'\n    >>> print(x)\n    1015801OO\n    >>> x.isValid\n    False\n\n### <a name=\"vs\"></a> ValidadorSuframa\n\nValida uma instância de InscricaoSuframa ou uma _string_ contendo a representação numérica de uma Inscrição Suframa.\n\n#### Utilização\n\n    # Validação de uma _string_ representando uma Inscrição Suframa:\n    >>> ValidadorSuframa.validar('101580100')\n    True\n\n    # Validação de uma _string_ representando uma Inscrição Suframa inválida (contendo caracteres não numéricos):\n    >>> ValidadorSuframa.validar('1015801OO')\n    False\n\n    # Validação de uma instância de InscriçãoSuframa:\n    >>> x = InscricaoSuframa('01.1234.129')\n    >>> ValidadorSuframa.validar(x)\n    False\n\n### <a name=\"gs\"></a> GeradorSuframa\n\nGera aleatoriamente uma Inscrição Suframa válida\n\n    >>> x = GeradorSuframa.gerar()\n    >>> x.isValid\n    True\n\n> **IMPORTANTE**: O __GeradorSuframa__ tem por objetivo ajudar estudantes, programadores, analistas de sistemas e testadores de código a gerar Inscrições Suframa válidas visando auxiliar as rotinas de testes de softwares em desenvolvimento.\n\n> A má utilização dos dados gerados pelo __GeradorSuframa__ é de **total responsabilidade do usuário** desta biblioteca.\n\n> As inscrições são geradas de forma aleatória, respeitando as leis de formação estabelecidas pela SUFRAMA.\n\n### <a name=\"ie\"></a> InscricaoEstadual\n\nRepresenta, em código Pyhton, uma _Inscrição Estadual_ (IE), ou o registro do contribuinte no cadastro do ICMS mantido pela Receita Estadual; permitindo representá-lo textualmente, com a devida formatação e identificar a sua validade.\n\n#### Utilização\n\n    >>> ie = InscricaoEstadual('613.855.219.926', 'SP')\n    >>> ie.isValid\n    True\n    >>> ie.rawValue\n    '613855219926'\n    >>> ie.UF\n    'SP'\n    >>> print(ie)\n    613.855.219.926\n\n### <a name=\"vie\"></a> ValidadorInscricaoEstadual\n\nValida a consistência de uma instância de InscricaoEstadual ou uma _string_ contendo a representação numérica de uma Inscrição Estadual para uma determinada Unidade da Federação, informada juntamente com a representação numérica da IE a qual se deseja validar.\n\n> A validação da Inscrição Estadual para cada Unidade da Federação brasileira, leva em consideração o disposto no [__Convênio 57/59__](http://www.sintegra.gov.br/conv_5795.html \"ConvênioICMS 57/59\"), como também as orientações e especificidades contidas na página [Conferências de Inscrições Estaduais](http://www.sintegra.gov.br/insc_est.html \"Conferência de Inscrições Estaduais\") do SINTEGRA.\n\n#### Utilização\n\n    >>> ie = InscricaoEstadual('613.855.219.926', 'SP')\n    >>> ValidadorInscricaoEstadual.validar(ie)\n    True\n\n    >>> ValidadorInscricaoEstadual.validarStr('207653461', 'RN')\n    True\n    >>> ValidadorInscricaoEstadual.validarStr('209564598', 'TO')\n    False\n\n> **NOTA**: Caso não se deseje utilizar o __ValidadorInscricaoEstadual__, pode-se utilizar o validador específico para uma determinada Unidade da Federação.\n<p>Cada Unidade da Federação brasileira possui o seu próprio validador, definido por: **Validador**XX, onde _XX_ deve ser substituído pela sigla da Unidade da Federação desejada.</p>\n<p>O Exemplo a seguir mostra como utilizar somente o validador específico para o Ceará, visando validar uma Inscrição Estadual deste Estado:</p>\n\n    >>> from bradocs4py.validadoresie import ValidadorCE\n    >>> ValidadorCE.validar('1234567')\n    False\n    >>> ValidadorCE.validar('50374156-6')\n    True\n\n> **IMPORTANTE**: Ao contrário de ValidadorInscricaoEstadual, os validadores específicos de cada UF validam somente uma cadeia de caracteres (_string_) contendo o número representativo da Inscrição Estadual a ser validada.\n\n### <a name=\"chave\"></a> ChaveAcessoNFe\n\nRepresenta a **Chave de Acesso** de uma Nota Fiscal Eletrônica.\n\n#### <a name=\"lfchave\"></a> Lei de formação de uma Chave de Acesso de NF-e\nA Chave de Acesso da Nota Fiscal Eletrônica é representada por uma sequência de 44 caracteres numéricos, devendo ser composta pelos seguintes campos que se encontram dispersos no Layout da NF-e:\n\n* UF - Código da UF do emitente do Documento Fiscal\n* AAMM - Ano e mês da emissão da NF-e\n* CNPJ - CNPJ do emitente do Documento Fiscal\n* Modelo - Modelo do Documento Fiscal\n* Série - Série do Documento Fiscal\n* Número - Número do Documento Fiscal\n* Forma Emissão - Forma de emissão do Documento Fiscal\n* Código Numérico - Código numérico que compõe a Chave de Acesso\n* DV - Dígito verificados\n\n| Código    |  UF  | AAMM | CNPJ | Modelo | Série | Número | Forma Emissão | Código Numérico |  DV  |\n| :--------:|:----:|:----:|:----:|:------:|:-----:|:------:|:-------------:|:---------------:|:----:|\n|Quantidade de caracteres |02    |04    |14    |02      |03     |09      |01             |08               |01    |\n\n\n#### Utilização\n\n    >>> ca = ChaveAcessoNFe('23 1811 06850713000120 55 001 001766829 1 11103011 2')\n    >>> ca\n    <BRADocs4Py.bradocs4py.chaveacessonfe.ChaveAcessoNFe('23181106850713000120550010017668291111030112')>\n    >>> print(ca)\n    2318 1106 8507 1300 0120 5500 1001 7668 2911 1103 0112\n    >>> ca.rawValue\n    '23181106850713000120550010017668291111030112'\n    >>> ca.isValid\n    True\n\n### <a name=\"vchave\"></a> ValidadorChaveAcessoNFe\n\nValida a consistência e a integridade de uma instância de [ChaveAcessoNFe](#chave) ou uma _string_ contendo a representação numérica de uma Chave de Acesso, através do cálculo de seu _dígito verificador_.\n\n> O **Dígito Verificador** (DV) visa garantir a integridade da Chave de Acesso, protegendo-a principalmente contra digitações erradas.\n\n#### Utilização\n\n    >>> chave = ChaveAcessoNFe(35181298957205000164667451830925015791400679)\n    >>> validarChaveAcessoNFe(chave)\n    True\n    >>> ValidadorChaveAcessoNFe.validar(52060433009911002506550120000007800267301615)\n    True\n    >>> ValidadorChaveAcessoNFe.validar('52060433009911002506550120000007800267301615')\n    True\n    >>> ValidadorChaveAcessoNFe.validar('52060433009911002506550120000007800267301625')\n    False\n\n    ou\n\n    >>> validarChaveAcessoNFe(52060433009911002506550120000007800267301615)\n    True\n    >>> validarChaveAcessoNFe('52060433009911002506550120000007800267301615')\n    True\n    >>> validarChaveAcessoNFe('52060433009911002506550120000007800267301625')\n    False\n    >>> validarChaveAcessoNFe(chave)\n    True\n\n\n#### <a name=\"dvchave\"></a> Cálculo do dígito verificador\n\nO dígito verificador da chave de acesso da NF-e é baseado em um cálculo do módulo 11. O módulo 11 de um número é calculado multiplicando-se cada algarismo pela sequência de multiplicadores 2,3,4,5,6,7,8,9,2,3, ..., posicionados da direita para a esquerda.\n\nA somatória dos resultados das ponderações dos algarismos é dividida por 11 e o DV (dígito verificador) será a diferença entre o divisor (11) e o resto da divisão:\n\nDV = 11 - (resto da divisão)\n\n> Quando o resto da divisão for 0 (zero) ou 1 (um), o DV deverá ser igual a 0 (zero).\n\nExemplo: consideremos a seguinte chave de acesso: _52060433009911002506550120000007800267301615_\n\nIsolando o _dígito verificador_, temos: _5206043300991100250655012000000780026730161_\n\n|**Chave** | 5 | 2 | 0 | 6 | 0 | 4 | 3 | 3 | 0 | 0 | 9 | 9 | 1 | 1 | 0 | 0 | 2 | 5 | 0 | 6 | 5 | 5 | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 | 0 | 7 | 8 | 0 | 0 | 2 | 6 | 7 | 3 | 0 | 1 | 6 | 1 |\n|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|**Pesos** | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 |\n|**Ponderação** |20 | 6 | 0 |54 | 0 |28 |18 |15 | 0 | 0 |18 |81 | 8 | 7 | 0 | 0 | 8 |15 | 0 |54 |40 |35 | 0 | 5 | 8 | 0 | 0 | 0 | 0 | 0 | 0 |35 |32 | 0 | 0 |18 |48 |49 |18 | 0 | 4 |18 | 2 |\n\n**Somatório das ponderações**: _644_\n\nDividindo o somatório das ponderações por **11**, temos: 644/11 = 58, restando **6**\n\nComo o dígito verificador (DV) = 11 - (resto da divisão), temos: **11 - 6 = 5**\n\nNeste caso o DV da chave de acesso da NF-e é igual a \"5\".\n\n#### <a name=\"consistenciachave\"></a> Verificação da _consistência_ da Chave de Acesso\n\nPor ter uma [lei de formação](#lfchave) peculiar, o _[ValidadorChaveAcessoNFe](#vchave)_ verifica a consistência de uma determinada chave de acesso, observando:\n\n* se os dois primeiros dígitos correspondem ao código, segundo o IBGE, de uma Unidade da Federação Brasileira;\n* Se a data de emissão (**mês** e **ano**) *ano* de emissão não é **posterior** à data (mês e ano) atual;\n* Se o *mês* de emissão, que corresponde ao terceiro par de dígitos, corresponde ao valor de um dos meses do ano;\n* Se o *CNPJ* do emitente corresponde a um número de CNPJ válido.\n\n> Desta forma, para que uma chave de acesso de NF-e seja válida, esta deverá passar pelo cálculo do Dígito Verificador e pelo teste de consistência.\n\n### <a name=\"gchave\"></a> GeradorChaveAcessoNFe\n\nGera uma [Chave de Acesso de NF-e](#chave) válida.\n\nA chave gerada pelo [GeradorChaveAcessoNFe](#gchave) obedece às [regras de consistência](#consistenciachave) anteriormente citadas.\n\n#### Utilização\n\n    >>> chave = GeradorChaveAcessoNFe.gerar()\n    >>> chave\n    <BRADocs4Py.bradocs4py.chaveacessonfe.ChaveAcessoNFe('25181230173834000160651227059459841838300521')>\n    >>> print(chave)\n    2518 1230 1738 3400 0160 6512 2705 9459 8418 3830 0521\n    >>> chave.rawValue\n    '25181230173834000160651227059459841838300521'\n    >>> chave.isValid\n    True\n\n    OU\n\n    >>> chave = gerarChaveAcessoNFe\n    >>> chave\n    <BRADocs4Py.bradocs4py.chaveacessonfe.ChaveAcessoNFe('11181205001709000125650428522143493956800409')>\n    >>> print(chave)\n    1118 1205 0017 0900 0125 6504 2852 2143 4939 5680 0409\n    >>> chave.rawValue\n    '11181205001709000125650428522143493956800409'\n    >>> chave.isValid\n    True\n\nÉ possível passar para o gerador qualquer um dos seguintes parâmetros, ou combinação deles:\n\n* UF - [Gera de uma chave de acesso para uma determinada Unidade da Federação](#gchaveUF) Brasileira\n* anoEmissao - [Gera uma chave de acesso para um determinado ano de emissão](#gchaveAno)\n* mesEmissao - [Gera uma chave de acesso para um determinado mês de emissão](#gchaveMes)\n* cnpjEmitente - [Gera uma chave de acesso informando o CNPJ do emitente](#gchaveCNPJ)\n* modelo - [Gera uma chame de acesso informando o modelo do documento fiscal](#gchaveModelo)\n* serie - [Gera uma chave de acesso informando a série do Documento Fiscal](#gchaveSerie)\n* numero - [Gera uma chave de acesso informando o núemro do Documento Fiscal](#gchaveNumero)\n* formaEmissao - [Gera uma chave de acesso informando o tipo de emissão da NF-e](#gchaveEmissao)\n\n##### <a name=\"gchaveUF\"></a> Gerar uma chave de acesso para uma determinada Unidade da Federação (23 - Ceará):\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(UF=23)\n    >>> chave.rawValue\n    '23181200840039000117652898295631409915000755'\n\n##### <a name=\"gchaveAno\"></a> Gerar uma chave de acesso para um determinado ano:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(anoEmissao=2015)\n    >>> chave.rawValue\n    '23151289106950000109651490922639616463100456'\n\n##### <a name=\"gchaveMes\"></a> Gerar uma chave de acesso para um determinado mês:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(mesEmissao=8)\n    >>> chave.rawValue\n    '15180853477826000102655678711686215463600041'\n\n##### <a name=\"gchaveMesAno\"></a> Gerar uma chave de acesso para uma determinada data (mês e ano) de emissão:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(anoEmissao=2015, mesEmissao=1)\n    >>> chave.rawValue\n    '29150139480855000100653317092547617382300904'\n\n##### <a name=\"gchaveCNPJ\"></a> Gerar uma chave de acesso informando o CNPJ do emitente:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(cnpjEmitente='64802611000136')\n    >>> chave.rawValue\n    '13181264802611000136651456599176257515300837'\n\n##### <a name=\"gchaveModelo\"></a> Gerar uma chave de acesso de uma NF-e, utilizada nas operações de venda no varejo (modelo de documento fiscal = 55)\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(modelo=55)\n    >>> chave.rawValue\n    '27181282761929000106555079534095503558300935'\n\n##### <a name=\"gchaveSerie\"></a> Gerar uma chave de acesso para uma NF-e que não possui série:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(serie=0)\n    >>> chave.rawValue\n    '13181202699369000160650006987155021599900654'\n\n> Nota: A série também pode ser informada como uma cadeia de caracteres numéricos. No exemplo acima, poderia ter sido informado **'000'** para _serie_.\n\n##### <a name=\"gchaveNumero\"></a> Gerar uma chave de acesso informando o número do documento fiscal:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(numero=1766829)\n    >>> chave.rawValue\n    '23181241761925000132652850017668297691400378'\n\n##### <a name=\"gchaveEmissao\"></a> Gerar uma chave de acesso para uma NF-e emitida com Contingência FS-IA, com impressão do DANFE em formulário de segurança (Tipo de emissã0 = 2)\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(formaEmissao=2)\n    >>> chave.rawValue\n    '51181278981604000153656457693627102018200143'\n\nIsto posto, desejando-se criar uma chave de acesso emitida no Ceará (Código IBGE=23) em Maio de 2016, para o CNPJ 64802611/0001-36, teríamos:\n\n    >>> chave = GeradorChaveAcessoNFe.gerar(formaEmissao=2, UF=23, anoEmissao=2016, mesEmissao=5, cnpjEmitente=64802611000136)\n    >>> chave.rawValue\n    '23160564802611000136554038699639442073100081'\n    >>> chave.isValid\n    True\n\n> **Atenção**: a forma abreviada do gerador _(gerarChaveAcessoNFe)_ não permite a passagem de parâmetros.\n\n### <a name=\"gtin\"></a>GTIN\n\nRepresenta um Número Global do Item Comercial - Global Trade Item Number (GTIN)\n\nO GTIN é um identificador para itens comerciais desenvolvido e controlado pela [GS1][gs1], antiga EAN/UCC. Os GTINs,\nanteriormente chamados de códigos EAN, são atribuídos para qualquer item (produto ou serviço) que pode ser\nprecificado, pedido ou faturado em qualquer ponto da cadeia de suprimentos. O GTIN é utilizado para recuperar\ninformação pré-definida e abrange desde as matérias primas até produtos acabados. GTIN é um termo “guarda-chuva”\npara descrever toda a família de identificação das estruturas de dados GS1 para itens comerciais (produtos e serviços).\nOs GTINs podem ter o tamanho de 8, 12, 13 ou 14 dígitos e podem ser construídos utilizando qualquer uma das quatro\nestruturas de numeração dependendo da aplicação. O GTIN-8 é codificado no código de barras EAN-8. O GTIN-12 é mais\nutilizado no código de barras UPC-A, o GTIN-13 é codificado no EAN-13 e o GTIN-14 no ITF-14.\n\n#### Utilização\n\n##### Criando uma instância de [GTIN](#gtin) a partir de um inteiro\n\n    >>> gtin = GTIN(6291041500213)\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-13 '6291041500213')>\n    >>> gtin.rawValue\n    '6291041500213'\n    >>> gtin.isValid\n    True\n\n##### Criando uma instância de [GTIN](#gtin) a partir de uma cadeia de caracteres numéricos\n\n    >>> gtin = GTIN('35723189')\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-8 '35723189')>\n    >>> gtin.rawValue\n    '35723189'\n    >>> gtin.isValid\n    True\n\n### <a name=\"vgtin\"></a> ValidadorGTIN\n\nValida uma instância de GTIN, um inteiro ou uma cadeia de caracteres numéricos que representa um GTIN, a partir do [cálculo de seu dígito verificador][calculo-digito-gtin], o qual assegura a sua integridade.\n\n> Nota: Muito embora o ValidadorGTIN valide uma instância de GTIN, a validação desta instância pode ser verificada através da sua propriedade _isValid_, conforme exemplos acima.\n\n#### Utilização\n\n    >>> gtin = GTIN('35723189')\n    >>> ValidadorGTIN.validar(gtin)\n    True\n    >>> ValidadorGTIN.validar('3572318')\n    False\n    >>> ValidadorGTIN.validar('35723189')\n    True\n    >>> ValidadorGTIN.validar(6291041500213)\n    True\n    >>> ValidadorGTIN.validar('62910415OO213')\n    False\n\n**OU**\n\n    >>> gtin = GTIN('35723189')\n    >>> validar_gtin(gtin)\n    True\n    >>> validar_gtin('3572318')\n    False\n    >>> validar_gtin('35723189')\n    True\n    >>> validar_gtin(6291041500213)\n    True\n    >>> validar_gtin('62910415OO213')\n    False\n\n### <a name=\"ggtin\"></a> GeradorGTIN\n\nGera uma instância de um [GTIN](#gtin) válido.\n\n>IMPORTANTE: Este gerador de GTIN tem como intenção ajudar estudantes, programadores, analistas e testadores de sistemas computacionais a gerar GTINs válidas. Normalmente necessárias parar testar seus softwares em desenvolvimento. A má utilização dos dados aqui gerados é de total responsabilidade do usuário. Os números são gerados de forma aleatória, respeitando as regras de criação de um GTIN.\n\n#### Utilização\n\n    >>> gtin = GeradorGTIN.gerar()\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-8 '93490399')>\n\n**ou**\n\n    >>> gtin = gerar_gtin()\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-8 '33409382')>\n\nÉ possível informar ao gerador o tipo de GTIN que se deseja gerar. Para isso, deve-se passar o _GeradorGTIN.TipoGTIN_ desejado.\n\n##### Para gerar um GTIN-8\n\n    >>> gtin = GeradorGTIN.gerar(GeradorGTIN.TipoGTIN.GTIN8)\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-8 '33409382')>\n\nTambém é possível gerar GTINs chamando diretamente _gerar_gtin_:\n\n    >>> gtin = gerar_gtin(GeradorGTIN.TipoGTIN.GTIN13)\n    >>> gtin\n    <BRADocs4Py.bradocs4py.gtin.GTIN(GTIN-13 '4332497941617')>\n\nUtilize:\n\n* GeradorGTIN.TipoGTIN.GTIN8 para gerar GTIN-8\n* GeradorGTIN.TipoGTIN.GTIN12 para gerar GTIN-12\n* GeradorGTIN.TipoGTIN.GTIN13 para gerar GTIN-13, ou\n* GeradorGTIN.TipoGTIN.GTIN14 para gerar GTIN-14\n\n> Se não for passado nenhum tipo para o gerador, este gerará sempre um GTIN-8.\n\n[gs1]: https://www.gs1br.org\n[calculo-digito-gtin]: https://www.gs1.org/services/how-calculate-check-digit-manually\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/namio/BRADocs4Py.git",
    "keywords": "cpf cnpj documentos brasileiros receita federal",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "bradocs4py",
    "package_url": "https://pypi.org/project/bradocs4py/",
    "platform": "",
    "project_url": "https://pypi.org/project/bradocs4py/",
    "project_urls": {
      "Homepage": "https://github.com/namio/BRADocs4Py.git"
    },
    "release_url": "https://pypi.org/project/bradocs4py/1.3.1.0/",
    "requires_dist": null,
    "requires_python": ">=3",
    "summary": "Implementa a funcionalidade validar_inscao_estadual.",
    "version": "1.3.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5673389,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8342e81a7463769a685a9ded8d3022880c2177de5bcfbeb2899ad342f947ce0c",
          "md5": "3c48049d997cda5c1a06dc6b544cca8e",
          "sha256": "e951c03ccf89b92efc32e119fe5eb769610fdf4bece728fe7f04b5af698df253"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3c48049d997cda5c1a06dc6b544cca8e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 28197,
        "upload_time": "2018-12-14T20:17:54",
        "upload_time_iso_8601": "2018-12-14T20:17:54.050589Z",
        "url": "https://files.pythonhosted.org/packages/83/42/e81a7463769a685a9ded8d3022880c2177de5bcfbeb2899ad342f947ce0c/bradocs4py-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "68a870cc5e407ff5a7af11214c737f79dbe81ebd8cb43dc12c2a03c259ef28ee",
          "md5": "c1ea1674576d591b69f237c69148c76d",
          "sha256": "74032e5154ef044715e23722934c9530c9e58b8e2aa5cefd12c1b783750ae0df"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c1ea1674576d591b69f237c69148c76d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 11796,
        "upload_time": "2018-12-14T20:17:55",
        "upload_time_iso_8601": "2018-12-14T20:17:55.986724Z",
        "url": "https://files.pythonhosted.org/packages/68/a8/70cc5e407ff5a7af11214c737f79dbe81ebd8cb43dc12c2a03c259ef28ee/bradocs4py-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3e561e035fb5294a3e7c83ab7c8de6e62faed793960c60ef198bd016e239681d",
          "md5": "5794568716d7ab498553fb65132ea718",
          "sha256": "d838717cffeb1c0bc239c8f3ea0764d064ea2d283244fe67f9a29ee86f45d290"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.1.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5794568716d7ab498553fb65132ea718",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 31264,
        "upload_time": "2018-12-17T18:13:30",
        "upload_time_iso_8601": "2018-12-17T18:13:30.350362Z",
        "url": "https://files.pythonhosted.org/packages/3e/56/1e035fb5294a3e7c83ab7c8de6e62faed793960c60ef198bd016e239681d/bradocs4py-1.1.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "51ab3a338a5fe8cafd9e4db56b5bac92e752f40e0f0dc47f2f7889ad72de6c09",
          "md5": "bc2fde8a944a1b92393364c2e8612716",
          "sha256": "a9732c560e80c28f8c87a75a566c0bfac8a510760882bd34aca363d62e56395e"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "bc2fde8a944a1b92393364c2e8612716",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 16518,
        "upload_time": "2018-12-17T18:13:33",
        "upload_time_iso_8601": "2018-12-17T18:13:33.612162Z",
        "url": "https://files.pythonhosted.org/packages/51/ab/3a338a5fe8cafd9e4db56b5bac92e752f40e0f0dc47f2f7889ad72de6c09/bradocs4py-1.1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c0287d438c6dde29bac5b2c85736a846a4196edab28e9a8edca0c54557d10bcd",
          "md5": "919d655c92ec6a8e5de19c8980041a14",
          "sha256": "305e54f52c2db65a77c99f072a9e056b9f141aae2808e07a3aac7de68adc3831"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "919d655c92ec6a8e5de19c8980041a14",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 40881,
        "upload_time": "2019-02-22T00:51:16",
        "upload_time_iso_8601": "2019-02-22T00:51:16.746994Z",
        "url": "https://files.pythonhosted.org/packages/c0/28/7d438c6dde29bac5b2c85736a846a4196edab28e9a8edca0c54557d10bcd/bradocs4py-1.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "65f03a84f764928911468cac6184b39e59dd6587510bee3c4dc7494aef9e0602",
          "md5": "65171fdc50bd5a024157a598a6c25693",
          "sha256": "590afb0f62d4eed1f67345bcdcd2e4e44dc73d5c6cf9df269f6d5d90d2534cb1"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "65171fdc50bd5a024157a598a6c25693",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 32401,
        "upload_time": "2019-02-22T00:51:19",
        "upload_time_iso_8601": "2019-02-22T00:51:19.430056Z",
        "url": "https://files.pythonhosted.org/packages/65/f0/3a84f764928911468cac6184b39e59dd6587510bee3c4dc7494aef9e0602/bradocs4py-1.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e872ac1fc61972209867f38a05473e9a31184efe10bd1d57adaa57d0bfd1555f",
          "md5": "6937547ee2b198840b682761d812f7e4",
          "sha256": "eff5d5a7aba6904f70ee5a1a87a0b8906e0045ba082d56788cbc77f0d1d8ab9c"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6937547ee2b198840b682761d812f7e4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 41089,
        "upload_time": "2019-06-06T20:09:49",
        "upload_time_iso_8601": "2019-06-06T20:09:49.227116Z",
        "url": "https://files.pythonhosted.org/packages/e8/72/ac1fc61972209867f38a05473e9a31184efe10bd1d57adaa57d0bfd1555f/bradocs4py-1.2.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4bedd21c163e896b26f4ad821d053cc2690a7eec3c94b2ab526599cefc058f2a",
          "md5": "9f98d9d69610cdf3f273c5e47aae13f6",
          "sha256": "a3c32d5292980a435549d95385ca03eda46cfe5106f917e774c5b902c17a63c0"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "9f98d9d69610cdf3f273c5e47aae13f6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 33415,
        "upload_time": "2019-06-06T20:09:55",
        "upload_time_iso_8601": "2019-06-06T20:09:55.910935Z",
        "url": "https://files.pythonhosted.org/packages/4b/ed/d21c163e896b26f4ad821d053cc2690a7eec3c94b2ab526599cefc058f2a/bradocs4py-1.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "473c1b5bf325fa56117ff67fc0fc6f5719ef85701da922a0301f090b5f6debf8",
          "md5": "39ee83dbd11877cd2d85d82829b4912d",
          "sha256": "a1b6d04c93f9960cb35d19da9c6f7aa8aa10475aac4475e08873dbebee4310c2"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "39ee83dbd11877cd2d85d82829b4912d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 41116,
        "upload_time": "2019-07-11T23:50:43",
        "upload_time_iso_8601": "2019-07-11T23:50:43.331371Z",
        "url": "https://files.pythonhosted.org/packages/47/3c/1b5bf325fa56117ff67fc0fc6f5719ef85701da922a0301f090b5f6debf8/bradocs4py-1.2.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4544290292292beb89e17cd3d32608df030dde14b4fa108b83ec0c72dff1c17b",
          "md5": "76001a7a8c296647e2b24edac580ce18",
          "sha256": "e6ca2afdc1334a5f0f416f565e0a413446ad6cc63e13348fc8691566a6fcb905"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "76001a7a8c296647e2b24edac580ce18",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 33399,
        "upload_time": "2019-07-11T23:50:51",
        "upload_time_iso_8601": "2019-07-11T23:50:51.508935Z",
        "url": "https://files.pythonhosted.org/packages/45/44/290292292beb89e17cd3d32608df030dde14b4fa108b83ec0c72dff1c17b/bradocs4py-1.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4b14082a3690daf27e5bc8d2310f015eea8d15af5e184140c9b35bc53e65b68b",
          "md5": "3636bc1e7f333b5a7112e8ec99c1a42d",
          "sha256": "e104fff1d2046a409b45fbfe85d96e77a0456c292e510e72909803fe29302dc6"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.3.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3636bc1e7f333b5a7112e8ec99c1a42d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 41132,
        "upload_time": "2019-07-18T13:58:10",
        "upload_time_iso_8601": "2019-07-18T13:58:10.763539Z",
        "url": "https://files.pythonhosted.org/packages/4b/14/082a3690daf27e5bc8d2310f015eea8d15af5e184140c9b35bc53e65b68b/bradocs4py-1.3.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b673d100d13fd512159f0dfd0279731f4c47df7d55c12b229c3e293b2412f100",
          "md5": "2fdd7f75fbbe791afca7c9b906e3170e",
          "sha256": "2551da137408870dc43079479f21e05c50ebb65ebbc2d6107ec3078302600474"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2fdd7f75fbbe791afca7c9b906e3170e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 33375,
        "upload_time": "2019-07-18T13:58:17",
        "upload_time_iso_8601": "2019-07-18T13:58:17.084371Z",
        "url": "https://files.pythonhosted.org/packages/b6/73/d100d13fd512159f0dfd0279731f4c47df7d55c12b229c3e293b2412f100/bradocs4py-1.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f851a01168758327283b94f4702f0c7d53b1e3a0c42127a6dd94d3f57c79cb11",
          "md5": "15455454133cb2732b2e1c9f690a5544",
          "sha256": "97cf170e40d322c21d605052f6d55e0814f5a6e44dc9399bff76228835f1e4f4"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.3.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "15455454133cb2732b2e1c9f690a5544",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 41196,
        "upload_time": "2019-08-13T20:00:25",
        "upload_time_iso_8601": "2019-08-13T20:00:25.978782Z",
        "url": "https://files.pythonhosted.org/packages/f8/51/a01168758327283b94f4702f0c7d53b1e3a0c42127a6dd94d3f57c79cb11/bradocs4py-1.3.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "55d0b448136daeec51703d557700540749d1ec7a4d734997b040c1d233e27ae1",
          "md5": "5cccc6d7c4ac21196106fa5e6e303a2c",
          "sha256": "6991508a3a9448a626318eb5d59a409cff4177815b6bad3f3244fb1810149029"
        },
        "downloads": -1,
        "filename": "bradocs4py-1.3.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5cccc6d7c4ac21196106fa5e6e303a2c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 33398,
        "upload_time": "2019-08-13T20:00:34",
        "upload_time_iso_8601": "2019-08-13T20:00:34.200478Z",
        "url": "https://files.pythonhosted.org/packages/55/d0/b448136daeec51703d557700540749d1ec7a4d734997b040c1d233e27ae1/bradocs4py-1.3.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f851a01168758327283b94f4702f0c7d53b1e3a0c42127a6dd94d3f57c79cb11",
        "md5": "15455454133cb2732b2e1c9f690a5544",
        "sha256": "97cf170e40d322c21d605052f6d55e0814f5a6e44dc9399bff76228835f1e4f4"
      },
      "downloads": -1,
      "filename": "bradocs4py-1.3.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "15455454133cb2732b2e1c9f690a5544",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3",
      "size": 41196,
      "upload_time": "2019-08-13T20:00:25",
      "upload_time_iso_8601": "2019-08-13T20:00:25.978782Z",
      "url": "https://files.pythonhosted.org/packages/f8/51/a01168758327283b94f4702f0c7d53b1e3a0c42127a6dd94d3f57c79cb11/bradocs4py-1.3.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "55d0b448136daeec51703d557700540749d1ec7a4d734997b040c1d233e27ae1",
        "md5": "5cccc6d7c4ac21196106fa5e6e303a2c",
        "sha256": "6991508a3a9448a626318eb5d59a409cff4177815b6bad3f3244fb1810149029"
      },
      "downloads": -1,
      "filename": "bradocs4py-1.3.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "5cccc6d7c4ac21196106fa5e6e303a2c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3",
      "size": 33398,
      "upload_time": "2019-08-13T20:00:34",
      "upload_time_iso_8601": "2019-08-13T20:00:34.200478Z",
      "url": "https://files.pythonhosted.org/packages/55/d0/b448136daeec51703d557700540749d1ec7a4d734997b040c1d233e27ae1/bradocs4py-1.3.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}