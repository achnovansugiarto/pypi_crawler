{
  "info": {
    "author": "['J. D. McEwen', 'C. R. G. Wallis', 'M. Buttner', 'B. Leistedt', 'Y. Wiaux']",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "# SSHT Python Documentation\n\nThis guide is intended to explain the python interface of SSHT. For a\ndescription of the workings of SSHT see\n[here](http://astro-informatics.github.io/ssht/ \"SSHT documentation\"). The\npython package also offers an interface to some of the functionality from\n[ducc0](https://pypi.org/project/ducc0/), including forward and inverse\ntransforms.\n\n## pyssht.forward\n\n~~~~{.python}\nflm = pyssht.forward(f, int L, Spin=0, Method='MW', Reality=False)\n~~~~\n\nPerforms the forward spherical harmonic transform.\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2. NB different for `'MW_pole'` sampling.\n* `L` the band limit of the signal, non-zero positive integer\n* `Spin` the spin of the signal, non-negative integer (default = 0)\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n* `Reality`  determines if the signal is real or complex, Boolean (default = False)\n* `backend` the backend that runs the transforms:\n    1. `'SSHT'` this package\n    2. `'ducc'` interface to [ducc0](https://pypi.org/project/ducc0/). \"MW_pole\"\n       is not available in this backend.\n* `nthreads`: number of threads when calling into the `'ducc'` backend. Ignored otherwise.\n\n#### Output\n\n`flm` the spherical harmonic transform of `f`, 1D `numpy.ndarray` type `complex`\n\n#### Note on `'MW_pole'` sampling\n\nThis is the same as the `'MW'` sampling however the south pole is expressed as a double only not a vector. Therefore the size of the array is one smaller on the \\(\\theta\\) direction. `f` is now a tuple containing either:\n\n* `(f_array, f_sp, phi_sp)` if complex transform\n* `(f_array, f_sp)` if real transform\n\n## pyssht.inverse\n\n~~~~{.python}\nf = pyssht.inverse(np.ndarray[ double complex, ndim=1, mode=\"c\"] f_lm not None, L, Spin=0, Method='MW', Reality=False)\n~~~~\n\nPerforms the inverse spherical harmonic transform.\n\n#### Inputs\n\n* `flm` the spherical harmonic transform of `f`, `numpy.ndarray` type `complex`, ndim 1\n* `L` the band limit of the signal, non-zero positive integer\n* `Spin` the spin of the signal, non-negative integer (default = 0)\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n* `Reality`  determines if the signal is real or complex, Boolean (default = False)\n* `backend` the backend that runs the transforms:\n    1. `'SSHT'` this package\n    2. `'ducc'` interface to [ducc0](https://pypi.org/project/ducc0/). \"MW_pole\"\n       is not available in this backend.\n* `nthreads`: number of threads when calling into the `'ducc'` backend. Ignored otherwise.\n\n#### Output\n\n`f` the signal on the sphere, 2D `numpy.ndarray` type `complex` or `real`. NB different for `'MW_pole'` sampling.\n\n#### Note on `'MW_pole'` sampling\n\nThis is the same as the `'MW'` sampling however the south pole is expressed as a double only not a vector. Therefore the size of the array is one smaller on the \\(\\theta\\) direction. `f` is now a tuple containing either:\n\n* `(f_array, f_sp, phi_sp)` if complex transform\n* `(f_array, f_sp)` if real transform\n\n## pyssht.forward_adjoint\n\n~~~~{.python}\nf = pyssht.forward_adjoint(np.ndarray[ double complex, ndim=1, mode=\"c\"] f_lm not None, L, Spin=0, Method='MW', Reality=False)\n~~~~\n\nPerforms the adjoint of the forward spherical harmonic transform.\n\n#### Inputs\n\n* `flm` the spherical harmonic transform of `f`, `numpy.ndarray` type `complex`, ndim 1\n* `L` the band limit of the signal, non-zero positive integer\n* `Spin` the spin of the signal, non-negative integer (default = 0)\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n* `Reality`  determines if the signal is real or complex, Boolean (default = False)\n* `backend` the backend that runs the transforms:\n    1. `'SSHT'` this package\n    2. `'ducc'` interface to [ducc0](https://pypi.org/project/ducc0/).\n* `nthreads`: number of threads when calling into the `'ducc'` backend. Ignored otherwise.\n\n#### Output\n\n`f` the signal on the sphere, 2D `numpy.ndarray` type `complex` or `real`.\n\n## pyssht.inverse_adjoint\n\n~~~~{.python}\nflm = pyssht.inverse_adjoint(f, int L, Spin=0, Method='MW', Reality=False)\n~~~~\n\nPerforms the adjoint of the inverse spherical harmonic transform.\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2.\n* `L` the band limit of the signal, non-zero positive integer\n* `Spin` the spin of the signal, non-negative integer (default = 0)\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n* `Reality`  determines if the signal is real or complex, Boolean (default = False)\n* `backend` the backend that runs the transforms:\n    1. `'SSHT'` this package\n    2. `'ducc'` interface to [ducc0](https://pypi.org/project/ducc0/).\n* `nthreads`: number of threads when calling into the `'ducc'` backend. Ignored otherwise.\n\n#### Output\n\n`flm` the spherical harmonic transform of `f`, 1D `numpy.ndarray` type `complex`\n\n## pyssht.elm2ind\n\n~~~~{.python}\nindex = pyssht.elm2ind( int el, int m)\n~~~~\n\nComputes the index in the `flm` array of a particular harmonic coefficient \\(\\ell \\) and \\(m\\).\n\n#### Inputs\n\n* `el` the scale parameter of the spherical harmonic coefficients, integer from \\(0\\) to \\(L-1\\), where \\(L\\) is the band limit.\n* `em` the azimuthal parameter, integer from -el to el.\n\n#### Output\n\nIndex of the coefficient in `flm` array, integer\n\n## pyssht.ind2elm\n\n~~~~{.python}\n(el, em) = pyssht.ind2elm(int ind)\n~~~~\n\nComputes harmonic coefficient \\(\\ell \\) and \\(m\\) from the index in the `flm` array.\n\n#### Inputs\n\n* `ind` index of the `flm` array\n\n#### Output\n\nTuple containing `(el, em)`\n\n* `el` the scale parameter of the spherical harmonic coefficients, integer from \\(0\\) to \\(L-1\\), where \\(L\\) is the band limit.\n* `em` the azimuthal parameter, integer from -el to el.\n\n## pyssht.theta_to_index\n\n~~~~{.python}\np = pyssht.theta_to_index(double theta, int L, str Method=\"MW\")\n~~~~\n\nOutputs the \\(\\theta\\) index (the first) in the 2 dimensional array used to store spherical images. The index returned is that of the closest \\(\\theta\\) sample smaller then the angle given on input.\n\n#### Inputs\n\n* `theta` the angle \\(\\theta\\)\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n\n#### Output\n\nInt `p` of corresponding to the angle \\(\\theta\\).\n\n## pyssht.phi_to_index\n\n~~~~{.python}\nq = pyssht.phi_to_index(double phi, int L, str Method=\"MW\")\n~~~~\n\nOutputs the \\(\\phi\\) index (the second) in the 2 dimensional array used to store spherical images. The index returned is that of the closest \\(\\phi\\) sample smaller then the angle given on input.\n\n#### Inputs\n\n* `phi` the angle \\(\\phi\\)\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n\n#### Output\n\nInt `q` of corresponding to the angle \\(\\phi\\).\n\n## pyssht.sample_length\n\n~~~~{.python}\nn = pyssht.sample_length(int L, Method = 'MW')\n~~~~\n\nOutputs a size of the array used for storing the data on the sphere for different sampling schemes.\n\n#### Inputs\n\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n\n#### Output\n\nInt `n` equal to the collapsed 1 dimensional size of the 2 dimensional array used to store data on the sphere.\n\n## pyssht.sample_shape\n\n~~~~{.python}\n(n_theta, n_phi) = pyssht.sample_shape(int L, Method='MW')\n~~~~\n\nOutputs a tuple with the shape of the array used for storing the data on the sphere for different sampling schemes.\n\n#### Inputs\n\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n\n#### Output\n\nTuple containing `(n_theta, n_phi)`\n\n* `n_theta` the number of samples in the \\(\\theta\\) direction, integer\n* `n_phi` the number of samples in the \\(\\phi\\) direction, integer\n\n## pyssht.sample_positions\n\n~~~~{.python}\n(thetas, phis) = pyssht.sample_positions(int L, Method = 'MW', Grid=False)\n~~~~\n\nComputes the positions on the sphere of the samples.\n\n#### Inputs\n\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n* `Grid` describes if the output is a vector of the sample positions or a 2D array the same shape as the signal on the sphere, default `False`\n\n#### Outputs\n\nTuple containing `(thetas, phis)`\n\n* `thetas` positions of the samples in the \\(\\theta\\) direction\n* `phis` positions of the samples in the \\(\\theta\\) direction\n\n## pyssht.s2_to_cart\n\n~~~~{.python}\n(x, y, z) = pyssht.s2_to_cart(theta, phi)\n~~~~\n\nComputes the \\(x\\), \\(y\\), and \\(z\\) coordinates from \\(\\theta\\) and \\(\\phi\\) on the sphere.\n\n#### Inputs\n\n* `theta` \\(\\theta\\) values, type `numpy.ndarray`\n* `phi` \\(\\phi\\) values, type `numpy.ndarray`\n\n#### Output\n\nTuple containing `(x, y, z)`\n\n* `x` the \\(x\\) coordinate of each point, type `numpy.ndarray`\n* `y` the \\(y\\) coordinate of each point, type `numpy.ndarray`\n* `z` the \\(z\\) coordinate of each point, type `numpy.ndarray`\n\n## pyssht.cart_to_s2\n\n~~~~{.python}\nthetas, phis = cart_to_s2(x, y, z)\n~~~~\n\nComputes the \\(\\theta\\) and \\(\\phi\\) on the coordinates on the sphere from \\(x\\), \\(y\\), and \\(z\\) coordinates.\n\n#### Inputs\n\n* `x` \\(x\\) values, type `numpy.ndarray`\n* `y` \\(y\\) values, type `numpy.ndarray`\n* `z` \\(z\\) values, type `numpy.ndarray`\n\n#### Output\n\nTuple containing `(theta, phi)`\n\n* `theta` the \\(\\theta\\) coordinate of each point, type `numpy.ndarray`\n* `phi` the \\(\\phi\\) coordinate of each point, type `numpy.ndarray`\n\n## pyssht.spherical_to_cart\n\n~~~~{.python}\n(x, y, z) = pyssht.spherical_to_cart(r, theta, phi)\n~~~~\n\nComputes the \\(x\\), \\(y\\), and \\(z\\) coordinates from the spherical coordinates \\(r\\), \\(\\theta\\) and \\(\\phi\\).\n\n#### Inputs\n\n* `r` \\(r\\) values, type `numpy.ndarray`\n* `theta` \\(\\theta\\) values, type `numpy.ndarray`\n* `phi` \\(\\phi\\) values, type `numpy.ndarray`\n\n#### Output\n\nTuple containing `(x, y, z)`\n\n* `x` the \\(x\\) coordinate of each point, type `numpy.ndarray`\n* `y` the \\(y\\) coordinate of each point, type `numpy.ndarray`\n* `z` the \\(z\\) coordinate of each point, type `numpy.ndarray`\n\n## pyssht.cart_to_spherical\n\n~~~~{.python}\nr, theta, phi = pyssht.cart_to_spherical(x, y, z)\n~~~~\n\nComputes the \\(\\r\\), \\(\\theta\\) and \\(\\phi\\) on the spherical coordinates from \\(x\\), \\(y\\), and \\(z\\) coordinates.\n\n#### Inputs\n\n* `x` \\(x\\) values, type `numpy.ndarray`\n* `y` \\(y\\) values, type `numpy.ndarray`\n* `z` \\(z\\) values, type `numpy.ndarray`\n\n#### Output\n\nTuple containing `(r, theta, phi)`\n\n* `r` the \\(r\\) coordinate of each point, type `numpy.ndarray`\n* `theta` the \\(\\theta\\) coordinate of each point, type `numpy.ndarray`\n* `phi` the \\(\\phi\\) coordinate of each point, type `numpy.ndarray`\n\n## pyssht.theta_phi_to_ra_dec\n\n~~~~{.python}\n(dec, ra) = pyssht.theta_phi_to_ra_dec(theta, phi, Degrees=False)\n~~~~\n\nComputes the Right Assension and declination from an array of \\(\\theta\\) and \\(\\phi\\) values.\n\n#### Inputs\n\n* `theta` \\(\\theta\\) values, type `numpy.ndarray`\n* `phi` \\(\\phi\\) values, type `numpy.ndarray`\n* `Degrees` defines if the output is in degrees or radians\n\n#### Output\n\nTuple containing `(dec, ra)`\n\n* `dec` the declination angle, `numpy.ndarray`\n* `ra` the Right Assension, `numpy.ndarray`\n\n## pyssht.ra_dec_to_theta_phi\n\n~~~~{.python}\n(theta, phi) = pyssht.ra_dec_to_theta_phi(ra, dec, Degrees=False)\n~~~~\n\nComputes the \\(\\theta\\) and \\(\\phi\\) values from an array of Right Assension and declination values.\n\n#### Inputs\n\n* `dec` the declination angle, `numpy.ndarray`\n* `ra` the Right Assension, `numpy.ndarray`\n* `Degrees` defines if the input is in degrees or radians, if degrees they are converted\n\n#### Output\n\nTuple containing `(theta, phi])`\n\n* `theta` \\(\\theta\\) values, type `numpy.ndarray`\n* `phi` \\(\\phi\\) values, type `numpy.ndarray`\n\n## pyssht.make_rotation_matrix\n\n~~~~{.python}\nrot_much = pyssht.make_rotation_matrix(list rot)\n~~~~\n\nComputes the 3 by 3 rotation matrix from the Euler angles given on input\n\n#### Inputs\n\n* `rot` List of length 3. Each element are the Euler angles `[alpha, beta, gamma]`\n\n#### Output\n\n3 by 3 `rot_matrix` the rotation matrix type `ndarray` dtype `float`\n\n## pyssht.rot_cart\n\n~~~~{.python}\nx_p, y_p, z_p = pyssht.rot_cart(x, y, z, list rot)\n~~~~\n\nComputes the rotations of the cartesian coordinates given a set of Euler angles. The inputs can be any shape `ndarray`s. For speed if the arrays are 1 or 2 dimensional it is recommended to use `pyssht.rot_cart_1D` or `pyssht.rot_cart_2D`.\n\n#### Inputs\n\n* `x` \\(x\\) values, type `numpy.ndarray`\n* `y` \\(y\\) values, type `numpy.ndarray`\n* `z` \\(z\\) values, type `numpy.ndarray`\n* `rot` List of length 3. Each element are the Euler angles `[alpha, beta, gamma]`\n\n#### Output\n\nTuple containing `(x_p, y_p, z_p)` the rotated coordinates the same shape and type as the inputs.\n\n## pyssht.rot_cart_1d and pyssht.rot_cart_2d\n\n~~~~{.python}\n(x_p, y_p, z_p) = pyssht.rot_cart_1d(np.ndarray[np.float_t, ndim=1] x, np.ndarray[np.float_t, ndim=1] y, np.ndarray[np.float_t, ndim=1] z, list rot)\n~~~~\n\n~~~~{.python}\n(x_p, y_p, z_p) = pyssht.rot_cart_2d(np.ndarray[np.float_t, ndim=2] x, np.ndarray[np.float_t, ndim=2] y, np.ndarray[np.float_t, ndim=2] z, list rot)\n~~~~\n\nComputes the rotations of the cartesian coordinates given a set of Euler angles. The inputs can be any shape `ndarray`s. Same as `pyssht.rot_cart` except optimised for arrays that are 1 or 2 dimensional.\n\n#### Inputs\n\n* `x` \\(x\\) values, type `numpy.ndarray`, dtype `float`, ndim 1 or 2\n* `y` \\(y\\) values, type `numpy.ndarray`, dtype `float`, ndim 1 or 2\n* `z` \\(z\\) values, type `numpy.ndarray`, dtype `float`, ndim 1 or 2\n* `rot` List of length 3. Each element are the Euler angles `[alpha, beta, gamma]`\n\n#### Output\n\nTuple containing `(x_p, y_p, z_p)` the rotated coordinates the same shape and type as the inputs.\n\n## pyssht.plot_sphere\n\n~~~~{.python}\npyssht.plot_sphere(\n    f, L, Method='MW', Close=True, Parametric=False,\n    Parametric_Scaling=[0.0,0.5], Output_File=None,\n    Show=True, Color_Bar=True, Units=None, Color_Range=None,\n    Axis=True\n)\n~~~~\n\nPlots data on to a sphere. It is really slow and not very good!\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2. NB different for `'MW_pole'` sampling.\n* `L` the band limit of the signal, non-zero positive integer\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MW_pole'`    [McEwen & Wiaux sampling with the south pole as a separate double.]\n    3. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    4. `'DH'`         [Driscoll & Healy sampling]\n    5. `'GL'`         [Gauss-Legendre sampling]\n* `Close` if true the full sphere is plotted (without a gap after the last \\(\\phi\\) position), default `True`\n* `Parametric` the radius of the object at a certain point is defined by the function (not just the color), default `False`\n* `Parametric_Saling` used if `Parametric=True`, defines the radius of the shape at a particular angle `r = norm(f)*Parametric_Saling[1] + Parametric_Saling[0]`, default `[0.0,0.5]`\n* `Output_File` if set saves the plot to a file of that name\n* `Show` if `True` shows you the plot, default `False`\n* `Color_Bar` if `True` shows the color bar, default `True`\n* `Units` is set puts a label on the color bar\n* `Color_Range` if set saturates the color bar in that range, else the function min and max is used\n* `Axis` if `True` shows the 3d axis, default `True`\n\n#### Outputs\n\nNone\n\n## pyssht.mollweide_projection\n\n~~~~{.python}\nf_plot, mask = pyssht.mollweide_projection(\n    f, L, resolution=500, rot=None,\n    zoom_region=[np.sqrt(2.0)*2,np.sqrt(2.0)],\n    Method=\"MW\"\n)\n~~~~\n\nCreates an `ndarray` of the mollweide projection of a spherical image and a mask array. This is useful for plotting results, not to be used for analysis on the plane. Elements in the signal `f` that are `NaN`s are marked in the mask. This allows one to plot these regions the color of their choice.\n\nHere is an example of using the function to plot real spherical data.\n\n~~~~{.python}\nf_plot, mask = pyssht.mollweide_projection(f, L, Method=\"MW\") # make projection\nplt.figure() # start figure\nimgplot = plt.imshow(f_real_plot,interpolation='nearest') # plot the projected image\nplt.colorbar(imgplot,fraction=0.025, pad=0.04) # plot color bar (these extra keywords make the bar a reasonable size)\nplt.imshow(mask_real, interpolation='nearest', cmap=cm.gray, vmin=-1., vmax=1.) # plot the NaN regions in grey\nplt.gca().set_aspect(\"equal\") # ensures the region is the correct proportions\nplt.axis('off') # removes axis (looks better)\nplt.show()\n~~~~\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2.\n* `L` the band limit of the signal, non-zero positive integer\n* `resolution` size of the projected image, default 500\n* `rot` If the image should be rotated before projecting, None. `rot` should be a list of length 1 or 3. If 1 then the image is rotated around the \\(z\\) axis by that amount. If 3 then the image is rotated by the Euler angles given in the list.\n* `zoom_region` the region of the sphere to be plotted, default `[np.sqrt(2.0)*2,np.sqrt(2.0)]` is the full sphere.\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    3. `'DH'`         [Driscoll & Healy sampling]\n    4. `'GL'`         [Gauss-Legendre sampling]\n\n#### Outputs\n\nIf the input is real:\n\nTuple containing:\n\n* `f_plot` the projection of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask` the projection of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\nIf the input is complex:\n\nTuple containing:\n\n* `f_plot_real` the projection of the real part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_real` the projection of the masked regions (`NaN`s in input `f.real`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_imag` the projection of the imaginary part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_imag` the projection of the masked regions (`NaN`s in input `f.imag`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\n## pyssht.equatorial_projection\n\n~~~~{.python}\nf_proj_real, mask_real, (f_proj_imag, mask_imag)\\\n            = pyssht.equatorial_projection(f, int L, int resolution=500,\\\n             rot=None, list zoom_region=[-1,-1], str Method=\"MW\", \\\n             str Projection=\"MERCATOR\", int Spin=0)\n~~~~\n\nCreates `ndarray`s of the projections of a spherical image and a mask array. This is useful for plotting results and performing analysis on the plane. All the spherical samples that fall in one planar pixel is averaged, if no samples fall in a pixel then the pixel is assigned the value of the closest spherical sample. Elements in the signal `f` that are `NaN`s are marked in the mask. This allows one to plot these regions the color of their choice.\n\nThere are two projections supported.\n\n1. The Mercator projection often used in maps.\n2. The Sinusoidal projection a simple equal area projection.\n\nHere is an example of using the function to plot real spherical data using the Mercator projection.\n\n~~~~{.python}\nf_proj, mask \\\n        = pyssht.equatorial_projection(f, L, resolution=500, Method=\"MW\", \\\n        Projection=\"MERCATOR\")\nplt.figure() # start figure\nimgplot = plt.imshow(f_proj,interpolation='nearest')# plot the projected image (north part)\nplt.colorbar(imgplot) # plot color bar\nplt.imshow(mask, interpolation='nearest', cmap=cm.gray, vmin=-1., vmax=1.) # plot the NaN regions in grey\nplt.axis('off') # removes axis\n\nplt.show()\n~~~~\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2.\n* `L` the band limit of the signal, non-zero positive integer\n* `resolution` size of the projected image, default 500\n* `rot` If the image should be rotated before projecting, None. `rot` should be a list of length 1 or 3. If 1 then the image is rotated around the \\(z\\) axis by that amount. If 3 then the image is rotated by the Euler angles given in the list.\n* `zoom_region` the region of the sphere to be plotted in radians. The first element is the angle left and right of the centre, default is `np.pi` for both projections. The second element is up and down of the equator, default is `np.pi/2` for the Sinusoidal projection and `7*np.pi/16` for the Mercator projection.\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    3. `'DH'`         [Driscoll & Healy sampling]\n    4. `'GL'`         [Gauss-Legendre sampling]\n* `Projection` string describing which of the projections to use. Use `\"MERCATOR\"` for the Mercator projection and `\"SINE\"` for the Sinusoidal projection, default is `\"MERCATOR\"`\n* `Spin` the spin of the signal. If the signal has non-zero spin then on projection the signal must be rotated to account for the changing direction of the definition of the signal. By setting this to a non-zero integer will ensure this rotation is performed.\n\n#### Outputs\n\nIf the input is real:\n\nTuple containing:\n\n* `f_plot` the projection of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask` the projection of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\nIf the input is complex:\n\nTuple containing:\n\n* `f_plot_real` the projection of the real part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_real` the projection of the real part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_imag` the projection of the imaginary part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_imag` the projection of the imaginary part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\n## pyssht.polar_projection\n\n~~~~{.python}\nf_proj_north_real, mask_north_real, f_proj_south_real, mask_south_real,\\\n(f_proj_north_imag, mask_north_imag, f_proj_south_imag, mask_south_imag\\ )\n        = pyssht.polar_projection(f, int L, int resolution=500, rot=None,\\\n        float zoom_region=-1, str Method=\"MW\", str Projection=\"OP\",int Spin=0):\n~~~~\n\nCreates an two `ndarray`s of the polar projection of a spherical image and a mask array. This is useful for plotting results and performing analysis on the plane. All the spherical samples that fall in one planar pixel is averaged, if no samples fall in a pixel then the pixel is assigned the value of the closest spherical sample. Elements in the signal `f` that are `NaN`s are marked in the mask. This allows one to plot these regions the color of their choice.\n\nAll the projections are centred around a pole. There are three projections supported.\n\n1. The Gnomic projection, defined by drawing a line from the centre of the circle trough the sphere on to the plane.\n2. The Stereographic projection, defined by drawing a line starting at the opposite pole through the sphere to the plane.\n3. The Orthographic, defined by a vertical projection on the plane.\n\nHere is an example of using the function to plot real spherical data.\n\n~~~~{.python}\nf_proj_north, mask_north, f_proj_south, mask_south \\\n        = pyssht.polar_projection(f, L, resolution=500, Method=\"MW\", \\\n        Projection=\"OP\")\nplt.figure() # start figure\nimgplot = plt.imshow(f_proj_north,interpolation='nearest')# plot the projected image (north part)\nplt.colorbar(imgplot) # plot color bar\nplt.imshow(mask_north, interpolation='nearest', cmap=cm.gray, vmin=-1., vmax=1.) # plot the NaN regions in grey\nplt.axis('off') # removes axis (looks better)\n\nplt.figure()\nimgplot = plt.imshow(f_proj_south,interpolation='nearest')# plot the projected image (south part)\nplt.colorbar(imgplot)\nplt.imshow(mask_south, interpolation='nearest', cmap=cm.gray, vmin=-1., vmax=1.)\nplt.title(\"orthographic projection south\")\nplt.axis('off')\nplt.show()\n~~~~\n\n#### Inputs\n\n* `f` the signal on the sphere, `numpy.ndarray` type `complex` or `real`, ndim 2.\n* `L` the band limit of the signal, non-zero positive integer\n* `resolution` size of the projected image, default 500\n* `rot` If the image should be rotated before projecting, default None. `rot` should be a list of length 1 or 3. If 1 then the image is rotated around the \\(z\\) axis by that amount. If 3 then the image is rotated by the Euler angles given in the list.\n* `zoom_region` the region of the sphere to be plotted in radians, default `np.pi/2` is the full half sphere for the orthographic and stereographic projections and `np.pi/4` for the gnomic projection as the equator is at infinity in this projection.\n* `Method` the sampling scheme used, string:\n    1. `'MW'`         [McEwen & Wiaux sampling (default)]\n    2. `'MWSS'`       [McEwen & Wiaux symmetric sampling]\n    3. `'DH'`         [Driscoll & Healy sampling]\n    4. `'GL'`         [Gauss-Legendre sampling]\n* `Projection` string describing which of the projections to use. Use `\"GP\"` for the Gnomic projection, `\"SP\"` for the Stereographic projection and `\"OP\"` for the Orthographic projection, default is `\"OP\"`\n* `Spin` the spin of the signal. If the signal has non-zero spin then on projection the signal must be rotated to account for the changing direction of the definition of the signal. By setting this to a non-zero integer will ensure this rotation is performed.\n\n#### Outputs\n\nIf the input is real:\n\nTuple containing:\n\n* `f_plot_north` the projection of the north part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_north` the projection of the north part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_south` the projection of the south part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_south` the projection of the south part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\nIf the input is complex:\n\nTuple containing:\n\n* `f_plot_north_real` the projection of the north part of the real part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_north_real` the projection of the north part of the real part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_south_real` the projection of the south part of the real part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_south_real` the projection of the south part of the real part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_north_imag` the projection of the north part of the imaginary part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_north_imag` the projection of the north part of the imaginary part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n* `f_plot_south_imag` the projection of the south part of the imaginary part of the image as a 2 dimensional `ndarray` of type `float`. Masked regions and regions not in the sphere are `NaN`s to make them clear when plotted\n* `mask_south_imag` the projection of the south part of the imaginary part of the masked regions (`NaN`s in input `f`) as a 2 dimensional `ndarray` of type `float`. Masked regions have a value `0.0` and regions not in the sphere are `NaN`s to make them clear when plotted.\n\n## pyssht.dl_beta_recurse\n\n~~~~{.python}\ndl = pyssht.dl_beta_recurse(np.ndarray[ double, ndim=2, mode=\"c\"] dl not None,\\\n            double beta, int L, int el, \\\n            np.ndarray[ double, ndim=1, mode=\"c\"] sqrt_tbl not None,\\\n            np.ndarray[ double, ndim=1, mode=\"c\"] signs not None)\n~~~~\n\nCompute the el-th plane of the Wigner small-d functions (from the (el-1)-th plane) using Risbo's method.\n\n#### Inputs\n\n* `dl` the Wigner plane for all m and n, indexed dl[m][n] of size (2*L-1)*(2*L-1)\n* `beta` angle to calculate Wigner D matrix at, type `double`\n* `L` the band limit of the signal, non-zero positive integer\n* `el` is the current harmonic degree (i.e. dl input should already be computed for el-1, and dl output will be computed for el)\n* `sqrt_tbl` precomputed square-roots from \\(0\\) to \\(2*(L-1)+1\\)\n* `signs` precomputed \\((-1)^m\\) signs from \\(m=0\\) to \\(L\\)\n\n#### Outputs\n\nNumpy ndarray `dl`, type `float_` of the Wigner plane for all m and n\n\n## pyssht.dln_beta_recurse\n\n~~~~{.python}\ndl = pyssht.dln_beta_recurse(np.ndarray[ double, ndim=1, mode=\"c\"] dl not None,\\\n            np.ndarray[ double, ndim=1, mode=\"c\"] dlm1 not None, double beta,\\\n            int L, int el, int n, np.ndarray[ double, ndim=1, mode=\"c\"] sqrt_tbl not None,\\\n            np.ndarray[ double, ndim=1, mode=\"c\"] signs not None)\n~~~~\n\nCompute the el-th line of the Wigner small-d functions for given n (from the (el-1)-th and (el-2)-th lines) using 3-term recursion of Kostelec.\n\n#### Inputs\n\n* `dl` the Wigner line for el for non-negative m and given n of size L\n* `dlm1` is the line for el-1 and dlp1 is the line computed for el+1\n* `beta` angle to calculate Wigner D matrix at, type `double`\n* `L` the band limit of the signal, non-zero positive integer\n* `el` el is the current harmonic degree\n* `n` the third index in Wigner D matrices\n* `sqrt_tbl` precomputed square-roots from \\(0\\) to \\(2*(L-1)+1\\)\n* `signs` precomputed \\((-1)^m\\) signs from \\(m=0\\) to \\(L\\)\n\n#### Outputs\n\nNumpy ndarray `dl`, type `float_` the Wigner line for el for non-negative m and given n of size\n\n## pyssht.generate_dl\n\n~~~~{.python}\ndl_array = pyssht.generate_dl(double beta, int L)\n~~~~\n\nGenerates the small Wigner D matrices up to a given band limit for a given \\(\\beta\\)\n\n#### Inputs\n\n* `beta` angle to calculate Wigner D matrix at, type `double`\n* `L` the band limit of the signal, non-zero positive integer\n\n#### Outputs\n\nNumpy ndarray `dl_array`, type `float_` of the small Wigner D matrices\n\n## pyssht.rotate_flms\n\n~~~~{.python}\nflm_rotated = pyssht.rotate_flms(\n                np.ndarray[ double complex, ndim=1, mode=\"c\"] f_lm not None,\\\n                double alpha, double beta, double gamma, int L, dl_array=None,\\\n                M=None, Axisymmetric=False, Keep_dl=False)\n~~~~\n\nFunction to rotate a set of spherical harmonic coefficients by the set of Euler angles \\(\\alpha, \\beta, \\gamma \\) using the \\(z,y,z\\) convention.\n\n#### Inputs\n\n* `flm` the spherical harmonic transform of `f`, `numpy.ndarray` type `complex`, ndim 1\n* `alpha` rotation angle \\(\\alpha\\), type `double`\n* `beta` rotation angle \\(\\beta\\), type `double`\n* `gamma` rotation angle \\(\\gamma\\), type `double`\n* `L` the band limit of the signal, non-zero positive integer\n* `dl_array` if set should be the precomputed small Wigner D matrix for angle \\(\\beta\\) and harmonic band limit `L`. If not set this is calculated in the function. (This parameter is ignored when using the `ducc` backend.)\n* `M` if set is the azimuthal band limit of the function to be rotated, default `M=L`.\n* `Axisymmetric` set if the function is axisymmetric and axisymmetric harmonic coefficients are parsed.\n* `Keep_dl` if set the output is changed to allow one to keep the computed `dl_array`. (This parameter is ignored when using the `ducc` backend.)\n* `backend` the backend that runs the transforms:\n    1. `'SSHT'` this package\n    2. `'ducc'` interface to [ducc0](https://pypi.org/project/ducc0/)\n\n#### Output\n\nIf `Keep_dl` is not set the output is the rotated set of spherical harmonic coefficients. If it is the output is a tuple `(flm_rotated, dl_array)`, ie the rotated harmonic coefficients and the small Wigner D matrix computed for that band limit and \\(\\alpha\\) value.\n\n## pyssht.guassian_smoothing\n\n~~~~{.python}\nfs_lm = pyssht.guassian_smoothing(np.ndarray[ double complex, ndim=1, mode=\"c\"] f_lm not None, int L, sigma_in=None, bl_in = None)\n~~~~\n\nSmooths a set of harmonic coefficients either with a precomputed smoothing kernel `bl` or with a Gaussian given on input.\n\n#### Inputs\n\n* `f_lm` the spherical harmonic transform of `f`, `numpy.ndarray` type `complex`, ndim 1\n* `L` the band limit of the signal, non-zero positive integer\n* `sigma_in` the input sigma of the Gaussian to smooth the signal with, default `None`\n* `bl_in` the smoothing kernel to smooth the signal with, default `None`\n\n#### Output\n\n`fs_lm` the smoothed harmonic coefficients.\n\n## pyssht.create_ylm\n\n~~~~{.python}\nylm = pyssht.create_ylm(thetas, phis, int L, int Spin=0, str recursion='Kostelec')\n~~~~\n\nComputes spherical harmonic functions for all el and all 0<=|m|<= el using various recursions.\n\n#### Inputs\n\n* `thetas` positions of the samples in the \\(\\theta\\) direction\n* `phis` positions of the samples in the \\(\\phi\\) direction\n* `L` the band limit of the signal, non-zero positive integer\n* `Spin` the spin of the signal, non-negative integer (default = 0)\n* `recursion` the recursion scheme used, string:\n    1. `'Kostelec'` [3-term recursion, e.g. Kostelec (default)]\n    2. `'Risbo'` [Risbo recursion]\n    3. `'NumericalRecipes'` [Numerical Recipes]\n\n#### Output\n\n`ylm` the spherical harmonics indexed `ylm[ind][theta][phi]`, where `ind = pyssht.elm2ind(el, m)`\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "http://astro-informatics.github.io/ssht/",
    "keywords": "",
    "license": "GPL-3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pyssht",
    "package_url": "https://pypi.org/project/pyssht/",
    "platform": null,
    "project_url": "https://pypi.org/project/pyssht/",
    "project_urls": {
      "Homepage": "http://astro-informatics.github.io/ssht/"
    },
    "release_url": "https://pypi.org/project/pyssht/1.5.2/",
    "requires_dist": [
      "numpy",
      "scipy",
      "setuptools ; extra == 'dev'",
      "wheel ; extra == 'dev'",
      "scikit-build ; extra == 'dev'",
      "cmake (>=3.12) ; extra == 'dev'",
      "ninja ; extra == 'dev'",
      "cython ; extra == 'dev'",
      "conan ; extra == 'dev'",
      "pip (!=20.0.0,!=20.0.1) ; extra == 'dev'",
      "pytest ; extra == 'dev'",
      "ducc0 (>=0.18) ; extra == 'dev'",
      "ducc0 (>=0.18) ; extra == 'ducc0'"
    ],
    "requires_python": "",
    "summary": "Fast spin spherical transforms",
    "version": "1.5.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17229963,
  "releases": {
    "1.3.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cd207b3096f7d1d477e457b8c4882adb108d711e2f7cd13b328137ef31356fe7",
          "md5": "b1d2fe86f2493ce57c8a3540fb589e92",
          "sha256": "d7c3e9dc38a863c58b43b4b9bca8d7e27ac106a6ec2ba104d07cd1a713d66024"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.2-cp38-cp38-macosx_10_12_x86_64.whl",
        "has_sig": false,
        "md5_digest": "b1d2fe86f2493ce57c8a3540fb589e92",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 997846,
        "upload_time": "2020-09-14T22:45:19",
        "upload_time_iso_8601": "2020-09-14T22:45:19.104569Z",
        "url": "https://files.pythonhosted.org/packages/cd/20/7b3096f7d1d477e457b8c4882adb108d711e2f7cd13b328137ef31356fe7/pyssht-1.3.2-cp38-cp38-macosx_10_12_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5ad10c3a25fb63d187fb1e28645208c247dc064c8487113ea15e5da87ef183a1",
          "md5": "5df1823ac310763ade4591ed9358ae1d",
          "sha256": "958b35adfb4030096a60e2c1a228c99688117766250c7fecf07167510e4eb803"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.2-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "5df1823ac310763ade4591ed9358ae1d",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1032158,
        "upload_time": "2020-10-06T09:34:39",
        "upload_time_iso_8601": "2020-10-06T09:34:39.262779Z",
        "url": "https://files.pythonhosted.org/packages/5a/d1/0c3a25fb63d187fb1e28645208c247dc064c8487113ea15e5da87ef183a1/pyssht-1.3.2-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eb907200888826960d63e1bd94dee0c6c6904ac4a5e98201ba3b9895b9037acf",
          "md5": "2d1ef000d5009c83b66e7ddfb8aa3a8a",
          "sha256": "c6a87a7977f9a24eb40b2c3ddb6220301d37f9934550350b10049ae16e4fa01c"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "2d1ef000d5009c83b66e7ddfb8aa3a8a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 2041504,
        "upload_time": "2020-09-14T22:45:22",
        "upload_time_iso_8601": "2020-09-14T22:45:22.559677Z",
        "url": "https://files.pythonhosted.org/packages/eb/90/7200888826960d63e1bd94dee0c6c6904ac4a5e98201ba3b9895b9037acf/pyssht-1.3.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6ed6282acdb1094765b6854089eeb3f0a4feee2e7a9c27c53a3644e659a84259",
          "md5": "56921a7c7bef7c20c84cd6c370f92c6a",
          "sha256": "9866981ce20dd509ce31f73f0b31b3daee8e0d20911b8fb8d7db182b6a549867"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.3-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "56921a7c7bef7c20c84cd6c370f92c6a",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1032159,
        "upload_time": "2020-10-07T22:20:34",
        "upload_time_iso_8601": "2020-10-07T22:20:34.474798Z",
        "url": "https://files.pythonhosted.org/packages/6e/d6/282acdb1094765b6854089eeb3f0a4feee2e7a9c27c53a3644e659a84259/pyssht-1.3.3-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aeb248d52562555a31a4159a53c67e44e02b41c3272ee44e94c894747b58ca34",
          "md5": "f658f7df67418182e5d16b33d54c2879",
          "sha256": "e3096880a99f2ecb9f05954aeee18757a42bc9dda0aacbfb73a5bee2676f5da3"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.3.tar.gz",
        "has_sig": false,
        "md5_digest": "f658f7df67418182e5d16b33d54c2879",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 75079,
        "upload_time": "2020-10-07T22:20:36",
        "upload_time_iso_8601": "2020-10-07T22:20:36.011436Z",
        "url": "https://files.pythonhosted.org/packages/ae/b2/48d52562555a31a4159a53c67e44e02b41c3272ee44e94c894747b58ca34/pyssht-1.3.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "92a7461f4e22588815462f1cba83e75c43945dba3a014753fccb08b0e779b6df",
          "md5": "5ef44bf7d3f0d0a0cc10b4d205ccaa80",
          "sha256": "c4bc173b6afd4f323e1eca8f534426afa1d4efd416b5ff12f60aaf7279d24ec5"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.4-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "5ef44bf7d3f0d0a0cc10b4d205ccaa80",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1011959,
        "upload_time": "2020-11-24T22:12:57",
        "upload_time_iso_8601": "2020-11-24T22:12:57.498843Z",
        "url": "https://files.pythonhosted.org/packages/92/a7/461f4e22588815462f1cba83e75c43945dba3a014753fccb08b0e779b6df/pyssht-1.3.4-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "803d381a17f51459b83f08681abcaa8ac9a7c855789f8db04f1647f6178dec3a",
          "md5": "0b11f78abff4043eb69df8f3dff448e0",
          "sha256": "19b2199108ee072fb1709dd95cf8deac423a17dd9b8bfd10993abbc397dbb293"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.4.tar.gz",
        "has_sig": false,
        "md5_digest": "0b11f78abff4043eb69df8f3dff448e0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 75276,
        "upload_time": "2020-11-24T22:12:58",
        "upload_time_iso_8601": "2020-11-24T22:12:58.695246Z",
        "url": "https://files.pythonhosted.org/packages/80/3d/381a17f51459b83f08681abcaa8ac9a7c855789f8db04f1647f6178dec3a/pyssht-1.3.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "609190b4dce0cd599bb59c5e82e89caf38955a2d1cde4bec0a04e393a00f2a2c",
          "md5": "ed77f9405c9f7565e348bc25f435af6a",
          "sha256": "c61f5e2b88dd0f2a6fa8cb1c5e7a3ff9a41cd4cab159d00fc7cc24fe1067cb15"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.5-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "ed77f9405c9f7565e348bc25f435af6a",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1012494,
        "upload_time": "2021-03-07T16:17:59",
        "upload_time_iso_8601": "2021-03-07T16:17:59.014856Z",
        "url": "https://files.pythonhosted.org/packages/60/91/90b4dce0cd599bb59c5e82e89caf38955a2d1cde4bec0a04e393a00f2a2c/pyssht-1.3.5-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f7b1c68bca696f4f82ccfe260c7656f6952a47f9f9101669e1effd221ee1aa75",
          "md5": "5aa23bcd5e29a747b1f3381983637992",
          "sha256": "ce558a23af9c3460d13c9141e2a5fc2d94dc11a18cf9bc1b6fd4f85b6d322757"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5aa23bcd5e29a747b1f3381983637992",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 75311,
        "upload_time": "2021-03-07T16:18:00",
        "upload_time_iso_8601": "2021-03-07T16:18:00.321938Z",
        "url": "https://files.pythonhosted.org/packages/f7/b1/c68bca696f4f82ccfe260c7656f6952a47f9f9101669e1effd221ee1aa75/pyssht-1.3.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6b11ea72fa699bb82e4bbb90c476672d66484e8cdc7e8eec123caf1dd24eea35",
          "md5": "fd6e2a85490a1c47ce0ad2285d18e48e",
          "sha256": "4e1f0d4fa4b895814f8a8b232855e280aa4526decedc254063e7852c25401aec"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.6-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "fd6e2a85490a1c47ce0ad2285d18e48e",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1011288,
        "upload_time": "2021-03-24T11:35:24",
        "upload_time_iso_8601": "2021-03-24T11:35:24.704347Z",
        "url": "https://files.pythonhosted.org/packages/6b/11/ea72fa699bb82e4bbb90c476672d66484e8cdc7e8eec123caf1dd24eea35/pyssht-1.3.6-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3f7deb444278c33c6682a849ecfc3f2f1429e93c297422bc160422ba85ac669c",
          "md5": "ff325be890b312f8a7ee4afe69d0935a",
          "sha256": "bc6c8c5f3edacd397bcc554e2babec2f3769d3cc0fd50c6b2e36c2b211acb958"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.6.tar.gz",
        "has_sig": false,
        "md5_digest": "ff325be890b312f8a7ee4afe69d0935a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 75096,
        "upload_time": "2021-03-24T11:35:25",
        "upload_time_iso_8601": "2021-03-24T11:35:25.980831Z",
        "url": "https://files.pythonhosted.org/packages/3f/7d/eb444278c33c6682a849ecfc3f2f1429e93c297422bc160422ba85ac669c/pyssht-1.3.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5327225fd9704457ed4142b6850e47fe5947d185352ead84e34b7274ed0e855e",
          "md5": "fbfaabfe8dc01a8c048e641c46ad8c0c",
          "sha256": "7af3450e013988a6c1a5d215eab5a75af9234453ceb47b8fcba40563d3f9f3fb"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.7-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "fbfaabfe8dc01a8c048e641c46ad8c0c",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1011316,
        "upload_time": "2021-03-24T17:15:03",
        "upload_time_iso_8601": "2021-03-24T17:15:03.506431Z",
        "url": "https://files.pythonhosted.org/packages/53/27/225fd9704457ed4142b6850e47fe5947d185352ead84e34b7274ed0e855e/pyssht-1.3.7-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f617d1e20808d64ac838527870a1d051d38c84a965d42a6cda8c6c43f73c554c",
          "md5": "1443f4ab2bfb0488d15265a12b9b9fb2",
          "sha256": "a9062d16633ed8496ba19633f1ecb09f162e69b217657da292dbe587aee5e5d3"
        },
        "downloads": -1,
        "filename": "pyssht-1.3.7.tar.gz",
        "has_sig": false,
        "md5_digest": "1443f4ab2bfb0488d15265a12b9b9fb2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 75265,
        "upload_time": "2021-03-24T17:15:04",
        "upload_time_iso_8601": "2021-03-24T17:15:04.982607Z",
        "url": "https://files.pythonhosted.org/packages/f6/17/d1e20808d64ac838527870a1d051d38c84a965d42a6cda8c6c43f73c554c/pyssht-1.3.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0597a55c1a2c7318cab5e40fed0fecb2213b49c0813d94d850d16d853e9c3c2b",
          "md5": "5bc8fad09d58786cc1f11f13124270d1",
          "sha256": "fb6ded769eb61e91223aa34a38cfcdf9bdfac068f07e51262ae3ed45387ba45b"
        },
        "downloads": -1,
        "filename": "pyssht-1.4.0-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "5bc8fad09d58786cc1f11f13124270d1",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1118744,
        "upload_time": "2021-07-14T12:02:21",
        "upload_time_iso_8601": "2021-07-14T12:02:21.598791Z",
        "url": "https://files.pythonhosted.org/packages/05/97/a55c1a2c7318cab5e40fed0fecb2213b49c0813d94d850d16d853e9c3c2b/pyssht-1.4.0-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d294d1b70f4f756ccdb0c136ecf228691ae28d7f477bd7f6a39ff044d23af4f2",
          "md5": "d4a9b0fc6a2bfc69e8ab1acbdd42b8e3",
          "sha256": "df3cae8aca50c81140244a2708a6ee3fbc8420a909349a5d7ff3f2549b70ec88"
        },
        "downloads": -1,
        "filename": "pyssht-1.4.0.tar.gz",
        "has_sig": false,
        "md5_digest": "d4a9b0fc6a2bfc69e8ab1acbdd42b8e3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 78522,
        "upload_time": "2021-07-14T12:02:23",
        "upload_time_iso_8601": "2021-07-14T12:02:23.297352Z",
        "url": "https://files.pythonhosted.org/packages/d2/94/d1b70f4f756ccdb0c136ecf228691ae28d7f477bd7f6a39ff044d23af4f2/pyssht-1.4.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "07d14d3f524aec6727c0e4888056aef71c921a717993d866151e2274192bb932",
          "md5": "d864f41492188f1f801e56b101203032",
          "sha256": "445c6f054607e7d71fab835ef42706b08f87af168d9ea9cffc08e5694dc981cf"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.0-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "d864f41492188f1f801e56b101203032",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1126634,
        "upload_time": "2021-07-26T13:26:25",
        "upload_time_iso_8601": "2021-07-26T13:26:25.152107Z",
        "url": "https://files.pythonhosted.org/packages/07/d1/4d3f524aec6727c0e4888056aef71c921a717993d866151e2274192bb932/pyssht-1.5.0-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b1044267b61aaa73d46712e4e1619dc24b25c1b10548140fb9b9228d2984c7a7",
          "md5": "e0db4112d8bbf3470dce6860a5b151ca",
          "sha256": "a15a2040fbba3607fc61a1f7a5f59cca1012e1b0d854372a5990829265c668f3"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e0db4112d8bbf3470dce6860a5b151ca",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 78581,
        "upload_time": "2021-07-26T13:26:26",
        "upload_time_iso_8601": "2021-07-26T13:26:26.460049Z",
        "url": "https://files.pythonhosted.org/packages/b1/04/4267b61aaa73d46712e4e1619dc24b25c1b10548140fb9b9228d2984c7a7/pyssht-1.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4b063d1e9d82643ab972441685256014a9ce15af25634fac3a032e33c942200d",
          "md5": "e45e091c20d3287d23b0f423854db8bd",
          "sha256": "f3dd89adb35db7a6b7c90db5542816042fdcbb76690524037533004a1737b6d3"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.1-cp38-cp38-macosx_10_15_x86_64.whl",
        "has_sig": false,
        "md5_digest": "e45e091c20d3287d23b0f423854db8bd",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1126472,
        "upload_time": "2021-10-14T15:26:43",
        "upload_time_iso_8601": "2021-10-14T15:26:43.478637Z",
        "url": "https://files.pythonhosted.org/packages/4b/06/3d1e9d82643ab972441685256014a9ce15af25634fac3a032e33c942200d/pyssht-1.5.1-cp38-cp38-macosx_10_15_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b0fe159c5f9d5b5566904f82817435cb7067269a158ba1eabec44c7eacbcd22e",
          "md5": "ffad356ef76c86fe213eb64026eef5bf",
          "sha256": "695eedf0352771866395cee189d6065ec1333c352be03ae9bc50344f4da41cb7"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.1.tar.gz",
        "has_sig": false,
        "md5_digest": "ffad356ef76c86fe213eb64026eef5bf",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 78544,
        "upload_time": "2021-10-14T15:26:46",
        "upload_time_iso_8601": "2021-10-14T15:26:46.121943Z",
        "url": "https://files.pythonhosted.org/packages/b0/fe/159c5f9d5b5566904f82817435cb7067269a158ba1eabec44c7eacbcd22e/pyssht-1.5.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a204e350089173e7d090602bcda66e3d03678f8f95ffbfa15670dfe6ab3d9269",
          "md5": "647aa8acb00c7c607c111ecc7c3b34ae",
          "sha256": "17ef7b917fbbfc970c03e1a6b60ebdca7db37d628d21c173f62a0b313e054aa9"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.2-cp38-cp38-macosx_10_16_x86_64.whl",
        "has_sig": false,
        "md5_digest": "647aa8acb00c7c607c111ecc7c3b34ae",
        "packagetype": "bdist_wheel",
        "python_version": "cp38",
        "requires_python": null,
        "size": 1175042,
        "upload_time": "2023-03-09T22:05:59",
        "upload_time_iso_8601": "2023-03-09T22:05:59.479737Z",
        "url": "https://files.pythonhosted.org/packages/a2/04/e350089173e7d090602bcda66e3d03678f8f95ffbfa15670dfe6ab3d9269/pyssht-1.5.2-cp38-cp38-macosx_10_16_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "338a5c2c6722a6070623c9ffdc333bbce7f401caf9eb05bbda33387925b9e830",
          "md5": "f2b0f5d6cc60a6163fea77edf13b0a7e",
          "sha256": "824942d5710c2bd4043687eef410303d8f3ba2dd481a24d2135863e4e49c0a26"
        },
        "downloads": -1,
        "filename": "pyssht-1.5.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f2b0f5d6cc60a6163fea77edf13b0a7e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 99635,
        "upload_time": "2023-03-09T22:06:01",
        "upload_time_iso_8601": "2023-03-09T22:06:01.818386Z",
        "url": "https://files.pythonhosted.org/packages/33/8a/5c2c6722a6070623c9ffdc333bbce7f401caf9eb05bbda33387925b9e830/pyssht-1.5.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a204e350089173e7d090602bcda66e3d03678f8f95ffbfa15670dfe6ab3d9269",
        "md5": "647aa8acb00c7c607c111ecc7c3b34ae",
        "sha256": "17ef7b917fbbfc970c03e1a6b60ebdca7db37d628d21c173f62a0b313e054aa9"
      },
      "downloads": -1,
      "filename": "pyssht-1.5.2-cp38-cp38-macosx_10_16_x86_64.whl",
      "has_sig": false,
      "md5_digest": "647aa8acb00c7c607c111ecc7c3b34ae",
      "packagetype": "bdist_wheel",
      "python_version": "cp38",
      "requires_python": null,
      "size": 1175042,
      "upload_time": "2023-03-09T22:05:59",
      "upload_time_iso_8601": "2023-03-09T22:05:59.479737Z",
      "url": "https://files.pythonhosted.org/packages/a2/04/e350089173e7d090602bcda66e3d03678f8f95ffbfa15670dfe6ab3d9269/pyssht-1.5.2-cp38-cp38-macosx_10_16_x86_64.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "338a5c2c6722a6070623c9ffdc333bbce7f401caf9eb05bbda33387925b9e830",
        "md5": "f2b0f5d6cc60a6163fea77edf13b0a7e",
        "sha256": "824942d5710c2bd4043687eef410303d8f3ba2dd481a24d2135863e4e49c0a26"
      },
      "downloads": -1,
      "filename": "pyssht-1.5.2.tar.gz",
      "has_sig": false,
      "md5_digest": "f2b0f5d6cc60a6163fea77edf13b0a7e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 99635,
      "upload_time": "2023-03-09T22:06:01",
      "upload_time_iso_8601": "2023-03-09T22:06:01.818386Z",
      "url": "https://files.pythonhosted.org/packages/33/8a/5c2c6722a6070623c9ffdc333bbce7f401caf9eb05bbda33387925b9e830/pyssht-1.5.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}