{
  "info": {
    "author": "Permuta Triangle",
    "author_email": "permutatriangle@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Education",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: BSD License",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Education",
      "Topic :: Scientific/Engineering :: Mathematics"
    ],
    "description": "Tilings\n=======\n\n.. image:: https://travis-ci.org/PermutaTriangle/Tilings.svg?branch=master\n    :alt: Travis\n    :target: https://travis-ci.org/PermutaTriangle/Tilings\n.. image:: https://coveralls.io/repos/github/PermutaTriangle/Tilings/badge.svg?branch=master\n    :alt: Coveralls\n    :target: https://coveralls.io/github/PermutaTriangle/Tilings?branch=master\n.. image:: https://img.shields.io/pypi/v/Tilings.svg\n    :alt: PyPI\n    :target: https://pypi.python.org/pypi/Tilings\n.. image:: https://img.shields.io/pypi/l/Tilings.svg\n    :target: https://pypi.python.org/pypi/Tilings\n.. image:: https://img.shields.io/pypi/pyversions/Tilings.svg\n    :target: https://pypi.python.org/pypi/Tilings\n.. image:: https://requires.io/github/PermutaTriangle/Tilings/requirements.svg?branch=master\n     :target: https://requires.io/github/PermutaTriangle/Tilings/requirements/?branch=master\n     :alt: Requirements Status\n.. image:: https://zenodo.org/badge/121506164.svg\n   :target: https://zenodo.org/badge/latestdoi/121506164\n\nThe ``tilings`` Python library contains code for working with gridded\npermutations and tilings, and in particular the ``TileScope`` algorithm, which\ncan be used to enumerate permutation classes.\n\nIf you are primarily interested in enumerating permutation classes, then you\nmay wish to skip ahead to the ``TileScope`` section, but note the installation\nwill be the same as for ``tilings``.\n\nIf this code is useful to you in your work, please consider citing it. To generate a\nBibTeX entry (or another format), click the \"DOI\" badge above and locate the \"Cite As\"\nsection.\n\nIf you need support, have a suggestion, or just want to be up to date with the\nlatest developments please join us on our\n`Discord server <https://discord.gg/ySJD6SV>`__ where we'd be happy to hear\nfrom you! To receive an email notification about major new releases,\nsend an email to `permutatriangle@gmail.com <mailto:permutatriangle@gmail.com>`_\n(but please direct all requests for assistance to the\n`Discord server <https://discord.gg/ySJD6SV>`__).\n\nInstalling\n----------\n\nTo install ``tilings`` on your system, run:\n\n.. code:: bash\n\n       pip install tilings\n\nIf you would like to edit the source code, you should install ``tilings`` in\ndevelopment mode by cloning the repository, running\n\n.. code:: bash\n\n       ./setup.py develop\n\nTo verify that your installation is correct, you can try to get a specification for\n`Av(12)` by running in your terminal:\n\n.. code:: bash\n\n        tilescope spec 12 point_placements\n\nYou should then be all set up to use ``tilings`` and the ``TileScope`` algorithm! The\n\"Performance\" section at the end of this document provides some more technical\ninformation.\n\nWhat are gridded permutations and tilings?\n------------------------------------------\n\nWe will be brief in our definitions here, for more details see\n`Christian Bean’s PhD thesis <https://opinvisindi.is/handle/20.500.11815/1184>`__.\n\nA ``gridded permutation`` is a pair ``(π, P)`` where ``π`` is a\npermutation and ``P`` is a tuple of cells, called the positions, that\ndenote the cells in which the points of ``π`` are drawn on a grid. Let\n``G`` denote the set of all gridded permutations. Containment of gridded\npermutations is defined the same as containment of permutations, except\nincluding the preservation of the cells.\n\nFor example, ``(284376915, ((0, 0), (0, 3), (1, 1), (1, 1), (2, 3), (2, 2), (3, 4), (3, 0), (4, 2))`` is drawn on the grid as follows.\n\n.. code:: python\n\n       +--+--+--+--+-+\n       |  |  |  |● | |\n       +--+--+--+--+-+\n       | ●|  |  |  | |\n       |  |  |● |  | |\n       +--+--+--+--+-+\n       |  |  | ●|  | |\n       |  |  |  |  |●|\n       +--+--+--+--+-+\n       |  |● |  |  | |\n       |  | ●|  |  | |\n       +--+--+--+--+-+\n       |● |  |  |  | |\n       |  |  |  | ●| |\n       +--+--+--+--+-+\n\n\nA ``tiling`` is a triple ``T = ((n, m), O, R)``, where ``n`` and ``m``\nare positive integers, ``O`` is a set of gridded permutations called\n``obstructions``, and ``R`` is a set of sets of gridded permutations\ncalled ``requirements``.\n\nWe say a gridded permutations avoids a set of gridded permutations if it\navoids all of the permutations in the set, otherwise it contains the\nset. To contain a set, therefore, means to contain at least one in the\nset. The set of gridded permutations on a tiling ``Grid(T)`` is the set\nof all gridded permutations in the ``n x m`` grid that avoid ``O`` and\ncontain each set ``r`` in ``R``.\n\nUsing tilings\n-------------\n\nOnce you’ve installed ``tilings``, it can be imported by a Python script\nor an interactive Python session, just like any other Python library:\n\n.. code:: python\n\n       >>> from tilings import *\n\nImporting ``*`` from it supplies you with the ``GriddedPerm`` and ``Tiling``\nclasses.\n\nAs above, a gridded permutation is a pair ``(π, P)`` where ``π`` is a\npermutation and ``P`` is a tuple of cells. The permutation is assumed to\nbe a ``Perm`` from the ``permuta`` Python library. Not every tuple of\ncells is a valid position for a given permutation. This can be checked\nusing the ``contradictory`` method.\n\n.. code:: python\n\n       >>> from permuta import Perm\n       >>> gp = GriddedPerm(Perm((0, 2, 1)), ((0, 0), (0, 0), (1, 0)))\n       >>> gp.contradictory()\n       False\n       >>> gp = GriddedPerm(Perm((0, 1, 2)), ((0, 0), (0, 1), (0, 0)))\n       >>> gp.contradictory()\n       True\n\nA ``Tiling`` is created with an iterable of obstructions and an\niterable of requirements (and each requirement is an iterable of gridded permutations).\nIt is assumed that all cells not mentioned in some obstruction or\nrequirement are empty. You can print the tiling to get an overview of the\ntiling created. In this example, we have a tiling that corresponds to\nnon-empty permutations avoiding\n``123``.\n\n.. code:: python\n\n       >>> obstructions = [GriddedPerm.single_cell(Perm((0, 1)), (1, 1)),\n       ...                 GriddedPerm.single_cell(Perm((1, 0)), (1, 1)),\n       ...                 GriddedPerm.single_cell(Perm((0, 1)), (0, 0)),\n       ...                 GriddedPerm.single_cell(Perm((0, 1, 2)), (2, 0)),\n       ...                 GriddedPerm(Perm((0, 1, 2)), ((0, 0), (2, 0), (2, 0)))]\n       >>> requirements = [[GriddedPerm.single_cell(Perm((0,)), (1, 1))]]\n       >>> tiling = Tiling(obstructions, requirements)\n       >>> print(tiling)\n       +-+-+-+\n       | |●| |\n       +-+-+-+\n       |\\| |1|\n       +-+-+-+\n       1: Av(012)\n       \\: Av(01)\n       ●: point\n       Crossing obstructions:\n       012: (0, 0), (2, 0), (2, 0)\n       Requirement 0:\n       0: (1, 1)\n\nThere are several properties of ``Tiling`` that you can use, e.g.,\n\n.. code:: python\n\n       >>> tiling.dimensions\n       (3, 2)\n       >>> sorted(tiling.active_cells)\n       [(0, 0), (1, 1), (2, 0)]\n       >>> tiling.point_cells\n       frozenset({(1, 1)})\n       >>> sorted(tiling.possibly_empty)\n       [(0, 0), (2, 0)]\n       >>> tiling.positive_cells\n       frozenset({(1, 1)})\n\nThose who have read ahead, or already started using tilings may have noticed\nthat a ``Tiling`` can also be defined with a third argument called ``assumptions``.\nThese can be used to keep track of occurrences of gridded permutations on\ntilings. These are still in development but are essential for certain\nparts of the ``TileScope`` algorithm. For simplicity we will not discuss\nthese again until the `Fusion` section.\n\nThere are a number of methods available on the tiling. You can generate\nthe gridded permutations satisfying the obstructions and requirements\nusing the ``gridded_perms_of_length`` method.\n\n.. code:: python\n\n       >>> for i in range(4):\n       ...     for gp in sorted(tiling.gridded_perms_of_length(i)):\n       ...         print(gp)\n       0: (1, 1)\n       01: (0, 0), (1, 1)\n       10: (1, 1), (2, 0)\n       021: (0, 0), (1, 1), (2, 0)\n       102: (0, 0), (0, 0), (1, 1)\n       120: (0, 0), (1, 1), (2, 0)\n       201: (1, 1), (2, 0), (2, 0)\n       210: (1, 1), (2, 0), (2, 0)\n\nThere are numerous other methods and properties. Many of these are specific\nto the ``TileScope`` algorithm, discussed in `Christian Bean’s PhD\nthesis <https://opinvisindi.is/handle/20.500.11815/1184>`__. For the remainder\nof this readme we will focus on the ``TileScope`` algorithm.\n\nThe TileScope algorithm\n=======================\n\n\nUsing TileScope\n---------------\n\nIf you've not installed ``tilings`` yet then go ahead and do this first by\npip installing ``tilings``:\n\n.. code:: bash\n\n       pip install tilings\n\nOnce done you can use the ``TileScope`` algorithm in two ways, either directly\nby importing from the ``tilings.tilescope`` module which we will discuss in\ngreater detail shortly, or by using the ``TileScope`` command line tool.\n\nThe command line tool\n---------------------\n\nFirst, check the help commands for more information about its usage.\n\n.. code:: bash\n\n       tilescope -h\n       tilescope spec -h\n\nTo search for a combinatorial specification use the subcommand\n``tilescope spec``, e.g.\n\n.. code:: bash\n\n       tilescope spec 231 point_placements\n\nBy default this command will try to solve for the generating function,\nalthough in some cases you will come across some not-yet-implemented features;\nfor more information please join us on our\n`Discord server <https://discord.gg/ySJD6SV>`__, where we'd be happy to talk\nabout it!\n\nThe ``point_placements`` argument above is a strategy pack, which we explain in\nmore detail in the ``StrategyPacks`` section.\n\nThe tilescope module\n--------------------\nTileScope can be imported in a interactive Python session from\n``tilings.tilescope``.\n\n.. code:: python\n\n       >>> from tilings.tilescope import *\n\nImporting ``*`` from ``tilings.tilescope`` supplies you with the ``TileScope``\nand ``TileScopePack`` classes. Running the ``TileScope`` is as simple as\nchoosing a class and a strategy pack. We'll go into more detail about the\ndifferent strategies\navailable shortly, but first let's enumerate our first permutation class. The\nexample one always learns first in permutation patterns is enumerating\nAv(231). There are many different packs that will succeed for this class,\nbut to get the most commonly described decomposition we can use\n``point_placements``. The basis can be given to TileScope in several\nformats: an iterable of permuta.Perm, a string where the permutations\nare separated by ``'_'`` (e.g. ``'231_4321'``), or as a ``Tiling``.\n\n.. code:: python\n\n       >>> pack = TileScopePack.point_placements()\n       >>> tilescope = TileScope('231', pack)\n\nOnce we have created our ``TileScope`` we can then use the ``auto_search``\nmethod which will search for a specification using the strategies given.\nIf successful it will return a CombinatorialSpecification.\n``TileScope`` uses ``logzero.logger`` to report information. If you wish to\nsuppress these prints, you can set ``logzero.loglevel``, which we have\ndone here for sake of brevity in this readme!\n\n.. code:: python\n\n       >>> import logzero; import logging; logzero.loglevel(logging.CRITICAL)\n       >>> spec = tilescope.auto_search()\n       >>> print(spec)\n       A combinatorial specification with 4 rules.\n       -----------\n       0 -> (1, 2)\n       insert 0 in cell (0, 0)\n       +-+            +-+     +-+\n       |1|         =  | |  +  |1|\n       +-+            +-+     +-+\n       1: Av(120)             1: Av+(120)\n                              Requirement 0:\n                              0: (0, 0)\n       -------\n       1 -> ()\n       is atom\n       +-+\n       | |\n       +-+\n       <BLANKLINE>\n       -----\n       2 = 3\n       placing the topmost point in cell (0, 0), then row and column separation\n       +-+                +-+-+-+                    +-+-+-+\n       |1|             =  | |●| |                 =  | |●| |\n       +-+                +-+-+-+                    +-+-+-+\n       1: Av+(120)        |1| |1|                    | | |1|\n       Requirement 0:     +-+-+-+                    +-+-+-+\n       0: (0, 0)          1: Av(120)                 |1| | |\n                          ●: point                   +-+-+-+\n                          Crossing obstructions:     1: Av(120)\n                          10: (0, 0), (2, 0)         ●: point\n                          Requirement 0:             Requirement 0:\n                          0: (1, 1)                  0: (1, 2)\n       ---------\n       3 -> (0,)\n       tiling is locally factorable\n       +-+-+-+            +-+\n       | |●| |         ↝  |1|\n       +-+-+-+            +-+\n       | | |1|            1: Av(120)\n       +-+-+-+\n       |1| | |\n       +-+-+-+\n       1: Av(120)\n       ●: point\n       Requirement 0:\n       0: (1, 2)\n\nThe locally factorable tiling in the rule `3 -> (0,)` could be further expanded\ndown to atoms and the root tiling.\nThis can be done using the `expand_verified` method.\n\n.. code:: python\n\n       >>> spec = spec.expand_verified()\n       >>> print(spec)\n       A combinatorial specification with 5 rules.\n       -----------\n       0 -> (1, 2)\n       insert 0 in cell (0, 0)\n       +-+            +-+     +-+\n       |1|         =  | |  +  |1|\n       +-+            +-+     +-+\n       1: Av(120)             1: Av+(120)\n                              Requirement 0:\n                              0: (0, 0)\n       -------\n       1 -> ()\n       is atom\n       +-+\n       | |\n       +-+\n       <BLANKLINE>\n       -----\n       2 = 3\n       placing the topmost point in cell (0, 0), then row and column separation\n       +-+                +-+-+-+                    +-+-+-+\n       |1|             =  | |●| |                 =  | |●| |\n       +-+                +-+-+-+                    +-+-+-+\n       1: Av+(120)        |1| |1|                    | | |1|\n       Requirement 0:     +-+-+-+                    +-+-+-+\n       0: (0, 0)          1: Av(120)                 |1| | |\n                          ●: point                   +-+-+-+\n                          Crossing obstructions:     1: Av(120)\n                          10: (0, 0), (2, 0)         ●: point\n                          Requirement 0:             Requirement 0:\n                          0: (1, 1)                  0: (1, 2)\n       --------------\n       3 -> (0, 4, 0)\n       factor with partition {(0, 0)} / {(1, 2)} / {(2, 1)}\n       +-+-+-+            +-+            +-+                +-+\n       | |●| |         =  |1|         x  |●|             x  |1|\n       +-+-+-+            +-+            +-+                +-+\n       | | |1|            1: Av(120)     ●: point           1: Av(120)\n       +-+-+-+                           Requirement 0:\n       |1| | |                           0: (0, 0)\n       +-+-+-+\n       1: Av(120)\n       ●: point\n       Requirement 0:\n       0: (1, 2)\n       -------\n       4 -> ()\n       is atom\n       +-+\n       |●|\n       +-+\n       ●: point\n       Requirement 0:\n       0: (0, 0)\n\nNow that we have a specification we can do a number of things. For example,\ncounting how many permutations there are in the class. This can be done using\nthe ``count_objects_of_size`` method on the CombinatorialSpecification.\n\n.. code:: python\n\n       >>> [spec.count_objects_of_size(i) for i in range(10)]\n       [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]\n\nOf course we see the Catalan numbers! We can also sample uniformly using the\n``random_sample_object_of_size`` method. This will return a ``GriddedPerm``.\nWe have used the ``ascii_plot`` method for us to visualise it.\nIf you want the underlying ``Perm``, this can be accessed with the ``patt``\nattribute. We also highlighted here the ``permuta.Perm.ascii_plot`` method for\nan alternative visualisation.\n\n.. code:: python\n\n       >>> gp = spec.random_sample_object_of_size(10)\n       >>> print(gp)  # doctest: +SKIP\n       9543102768: (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0)\n       >>> print(gp.ascii_plot())  # doctest: +SKIP\n       +----------+\n       |●         |\n       |         ●|\n       |       ●  |\n       |        ● |\n       | ●        |\n       |  ●       |\n       |   ●      |\n       |      ●   |\n       |    ●     |\n       |     ●    |\n       +----------+\n       >>> perm = gp.patt\n       >>> print(perm)  # doctest: +SKIP\n       9543102768\n       >>> print(perm.ascii_plot())  # doctest: +SKIP\n        | | | | | | | | | |\n       -●-+-+-+-+-+-+-+-+-+-\n        | | | | | | | | | |\n       -+-+-+-+-+-+-+-+-+-●-\n        | | | | | | | | | |\n       -+-+-+-+-+-+-+-●-+-+-\n        | | | | | | | | | |\n       -+-+-+-+-+-+-+-+-●-+-\n        | | | | | | | | | |\n       -+-●-+-+-+-+-+-+-+-+-\n        | | | | | | | | | |\n       -+-+-●-+-+-+-+-+-+-+-\n        | | | | | | | | | |\n       -+-+-+-●-+-+-+-+-+-+-\n        | | | | | | | | | |\n       -+-+-+-+-+-+-●-+-+-+-\n        | | | | | | | | | |\n       -+-+-+-+-●-+-+-+-+-+-\n        | | | | | | | | | |\n       -+-+-+-+-+-●-+-+-+-+-\n        | | | | | | | | | |\n\n\nYou can use the ``get_equations`` method which returns an iterator for the\nsystem of equations implied by the specification.\n\n.. code:: python\n\n       >>> list(spec.get_equations())\n       [Eq(F_0(x), F_1(x) + F_2(x)), Eq(F_1(x), 1), Eq(F_2(x), F_3(x)), Eq(F_3(x), F_0(x)**2*F_4(x)), Eq(F_4(x), x)]\n\nYou can also pass these directly to the ``solve`` method in ``sympy`` by using the\n``get_genf`` method. It will then return the solution which matches the initial\nconditions.\n\n.. code:: python\n\n       >>> spec.get_genf()\n       (1 - sqrt(1 - 4*x))/(2*x)\n\nThe ``sympy.solve`` method can be very slow, particularly on big systems. If\nyou are having troubles, then other softwares such as Mathematica and Maple are\noften better. You can also use the method `get_maple_equations` which will\nreturn a string containing Maple code for the equations.\n\n.. code:: python\n\n       >>> print(spec.get_maple_equations())\n       root_func := F[0, x]:\n       eqs := [\n       F[0, x] = (F[1, x] + F[2, x]),\n       F[1, x] = (1),\n       F[2, x] = F[3, x],\n       F[3, x] = ((F[0, x]**(2)) * F[4, x]),\n       F[4, x] = x\n       ]:\n       count := [1, 1, 2, 5, 14, 42, 132]:\n\nIf you have a system of equations you are unable to solve, then please feel\nfree to send them to our `Discord server <https://discord.gg/ySJD6SV>`__.\n\nA specification can be saved and loaded later by converting it to\n`JSON <https://realpython.com/python-json/>`__, a data storage format\nthat can be written to a file or copy-pasted elsewhere for safe keeping.\nThis functionality is built into `TileScope`. We can retrieve the JSON\nrepresentation of a specification and load the specificiation from said\nJSON string by doing the following:\n\n.. code:: python\n\n       >>> import json\n       >>> from comb_spec_searcher import CombinatorialSpecification\n\n       >>> json_string = json.dumps(spec.to_jsonable())\n       >>> reloaded_spec = CombinatorialSpecification.from_dict(json.loads(json_string))\n\n\nStrategyPacks\n=============\n\nWe have implemented a large number of structural decomposition strategies that\nwe will discuss a bit more in the strategies section that follows. One can use\nany subset of these strategies to search for a combinatorial specification.\nThis can be done by creating a ``TileScopePack``.\n\nWe have prepared a number of curated packs of strategies that we find to be\nrather effective. These can accessed as class methods on ``TileScopePack``.\nThey are:\n\n- ``point_placements``: checks if cells are empty or not and places extreme\n  points in cells\n- ``row_and_col_placements``: places the left or rightmost points in columns,\n  or the bottom or topmost points in rows\n- ``regular_insertion_encoding``: this pack includes the strategies required\n  for finding the specification corresponding to a regular insertion encoding\n- ``insertion_row_and_col_placements``: this pack places rows and columns as\n  above, but first ensures every active cell contains a point (this is in the\n  same vein as the \"slots\" of the regular insertion encoding)\n- ``insertion_point_placements``: places extreme points in cells, but first\n  ensures every active cell contains a point\n- ``pattern_placements``: inserts size one requirements into a tiling, and then\n  places points with respect to a pattern, e.g. if your permutation contains 123,\n  then place the leftmost point that acts as a 2 in an occurrence of 123\n- ``requirement_placements``: places points with respect to any requirement,\n  e.g. if your permutation contains {12, 21}, then place the rightmost point\n  that is either an occurrence of 1 in 12 or an occurrence of 2 in 21.\n- ``only_root_placements``: this is the same as ``pattern_placements`` except\n  we only allow inserting into 1x1 tilings, therefore making it a finite pack\n- ``all_the_strategies``: a pack containing (almost) all of the strategies\n\nEach of these packs have different parameters that can be set. You can view\nthis by using the help command e.g.,\n``help(TileScopePack.pattern_placements)``.\nIf you need help picking the right pack to enumerate your class join us on our\n`Discord server <https://discord.gg/ySJD6SV>`__ where we'd be happy to help.\n\nYou can make any pack use the fusion strategy by using the method\n``make_fusion``; for example, here is how to create the pack\n``row_placements_fusion``.\n\n.. code:: python\n\n       >>> pack = TileScopePack.row_and_col_placements(row_only=True).make_fusion()\n       >>> print(pack)\n       Looking for recursive combinatorial specification with the strategies:\n       Inferral: row and column separation, obstruction transitivity\n       Initial: rearrange assumptions, add assumptions, factor, tracked fusion\n       Verification: verify atoms, insertion encoding verified, one by one verification, locally factorable verification\n       Set 1: row placement\n\nThis particular pack can be used to enumerate ``Av(123)``.\n\n.. code:: python\n\n       >>> tilescope = TileScope('123', pack)\n       >>> spec = tilescope.auto_search(smallest=True)\n       >>> print(spec)  # doctest: +SKIP\n       A combinatorial specification with 10 rules.\n       -----------\n       0 -> (1, 2)\n       insert 0 in cell (0, 0)\n       +-+            +-+     +-+\n       |1|         =  | |  +  |1|\n       +-+            +-+     +-+\n       1: Av(012)             1: Av+(012)\n                              Requirement 0:\n                              0: (0, 0)\n       -------\n       1 -> ()\n       is atom\n       +-+\n       | |\n       +-+\n       -----------\n       3 -> (4, 5)\n       factor with partition {(0, 0), (0, 2)} / {(1, 1)}\n       +-+-+                           +-+                             +-+\n       |1| |                        =  |1|                          x  |●|\n       +-+-+                           +-+                             +-+\n       | |●|                           |\\|                             ●: point\n       +-+-+                           +-+                             Requirement 0:\n       |\\| |                           1: Av(012)                      0: (0, 0)\n       +-+-+                           \\: Av(01)\n       1: Av(012)                      Crossing obstructions:\n       \\: Av(01)                       012: (0, 0), (0, 1), (0, 1)\n       ●: point\n       Crossing obstructions:\n       012: (0, 0), (0, 2), (0, 2)\n       Requirement 0:\n       0: (1, 1)\n       ---------\n       3 -> (5,)\n       adding the assumption 'can count points in cell (0, 0)'\n       +-+-+                           +-+-+\n       |\\|1|                        ↣  |\\|1|\n       +-+-+                           +-+-+\n       1: Av(012)                      1: Av(012)\n       \\: Av(01)                       \\: Av(01)\n       Crossing obstructions:          Crossing obstructions:\n       012: (0, 0), (1, 0), (1, 0)     012: (0, 0), (1, 0), (1, 0)\n                                       Assumption 0:\n                                       can count points in cell (0, 0)\n       --------------\n       5 -> (1, 6, 7)\n       placing the topmost point in row 0\n       +-+-+                               +-+     +-+-+-+                                      +-+-+-+-+\n       |\\|1|                            =  | |  +  |●| | |                                   +  | | |●| |\n       +-+-+                               +-+     +-+-+-+                                      +-+-+-+-+\n       1: Av(012)                                  | |\\|1|                                      |\\|\\| |1|\n       \\: Av(01)                                   +-+-+-+                                      +-+-+-+-+\n       Crossing obstructions:                      1: Av(012)                                   1: Av(012)\n       012: (0, 0), (1, 0), (1, 0)                 \\: Av(01)                                    \\: Av(01)\n       Assumption 0:                               ●: point                                     ●: point\n       can count points in cell (0, 0)             Crossing obstructions:                       Crossing obstructions:\n                                                   012: (1, 0), (2, 0), (2, 0)                  01: (0, 0), (1, 0)\n                                                   Requirement 0:                               012: (0, 0), (3, 0), (3, 0)\n                                                   0: (0, 1)                                    012: (1, 0), (3, 0), (3, 0)\n                                                   Assumption 0:                                Requirement 0:\n                                                   can count points in cells (0, 1), (1, 0)     0: (2, 1)\n                                                                                                Assumption 0:\n                                                                                                can count points in cell (0, 0)\n       -----------\n       6 -> (8, 5)\n       factor with partition {(0, 1)} / {(1, 0), (2, 0)}\n       +-+-+-+                                      +-+                                 +-+-+\n       |●| | |                                   =  |●|                              x  |\\|1|\n       +-+-+-+                                      +-+                                 +-+-+\n       | |\\|1|                                      ●: point                            1: Av(012)\n       +-+-+-+                                      Requirement 0:                      \\: Av(01)\n       1: Av(012)                                   0: (0, 0)                           Crossing obstructions:\n       \\: Av(01)                                    Assumption 0:                       012: (0, 0), (1, 0), (1, 0)\n       ●: point                                     can count points in cell (0, 0)     Assumption 0:\n       Crossing obstructions:                                                           can count points in cell (0, 0)\n       012: (1, 0), (2, 0), (2, 0)\n       Requirement 0:\n       0: (0, 1)\n       Assumption 0:\n       can count points in cells (0, 1), (1, 0)\n       -------\n       8 -> ()\n       is atom\n       +-+\n       |●|\n       +-+\n       ●: point\n       Requirement 0:\n       0: (0, 0)\n       Assumption 0:\n       can count points in cell (0, 0)\n       -----------\n       7 -> (9, 4)\n       factor with partition {(0, 0), (1, 0), (3, 0)} / {(2, 1)}\n       +-+-+-+-+                           +-+-+-+                             +-+\n       | | |●| |                        =  |\\|\\|1|                          x  |●|\n       +-+-+-+-+                           +-+-+-+                             +-+\n       |\\|\\| |1|                           1: Av(012)                          ●: point\n       +-+-+-+-+                           \\: Av(01)                           Requirement 0:\n       1: Av(012)                          Crossing obstructions:              0: (0, 0)\n       \\: Av(01)                           01: (0, 0), (1, 0)\n       ●: point                            012: (0, 0), (2, 0), (2, 0)\n       Crossing obstructions:              012: (1, 0), (2, 0), (2, 0)\n       01: (0, 0), (1, 0)                  Assumption 0:\n       012: (0, 0), (3, 0), (3, 0)         can count points in cell (0, 0)\n       012: (1, 0), (3, 0), (3, 0)\n       Requirement 0:\n       0: (2, 1)\n       Assumption 0:\n       can count points in cell (0, 0)\n       ---------\n       9 -> (5,)\n       fuse columns 0 and 1\n       +-+-+-+                             +-+-+\n       |\\|\\|1|                          ↣  |\\|1|\n       +-+-+-+                             +-+-+\n       1: Av(012)                          1: Av(012)\n       \\: Av(01)                           \\: Av(01)\n       Crossing obstructions:              Crossing obstructions:\n       01: (0, 0), (1, 0)                  012: (0, 0), (1, 0), (1, 0)\n       012: (0, 0), (2, 0), (2, 0)         Assumption 0:\n       012: (1, 0), (2, 0), (2, 0)         can count points in cell (0, 0)\n       Assumption 0:\n       can count points in cell (0, 0)\n       -------\n       4 -> ()\n       is atom\n       +-+\n       |●|\n       +-+\n       ●: point\n       Requirement 0:\n       0: (0, 0)\n       >>> [spec.count_objects_of_size(i) for i in range(10)]\n       [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]\n\nIt is possible to make your own pack as well, but for that you should first\nlearn more about what the individual strategies do.\n\nThe strategies\n==============\n\nThe ``TileScope`` algorithm has in essence six different strategies that are\napplied in many different ways, resulting in very different universes in which\nto search for a combinatorial specification in. They are:\n\n- ``requirement insertions``: a disjoint union considering whether or not a tiling\n  contains a requirement\n- ``point placements``: places a uniquely defined point onto its own row and/or\n  column\n- ``factor``: when the obstructions and requirements become local to a set of\n  cells, we factor out the local subtiling\n- ``row and column separation``: if all of the points in a cell in a row must\n  appear below all of the other points in the row, then separate this onto its own\n  row.\n- ``obstruction inferral``: add obstructions that the requirements and\n  obstructions of a tiling imply must be avoided\n- ``fusion``: merge two adjacent rows or columns of a tiling, if it can be\n  viewed as a single row or column with a line drawn between\n\n\nRequirement insertions\n----------------------\n\nThe simplest of all the arguments when enumerating permutation classes is to\nsay, either a tiling is empty or contains a point. This can be viewed in\ntilings as either avoiding ``1: (0, 0)`` or containing ``1: (0, 0)``.\n\n.. code:: python\n\n       >>> from tilings.strategies import CellInsertionFactory\n       >>> strategy_generator = CellInsertionFactory()\n       >>> tiling = Tiling.from_string('231')\n       >>> for strategy in strategy_generator(tiling):\n       ...     print(strategy(tiling))\n       insert 0 in cell (0, 0)\n       +-+            +-+     +-+\n       |1|         =  | |  +  |1|\n       +-+            +-+     +-+\n       1: Av(120)             1: Av+(120)\n                              Requirement 0:\n                              0: (0, 0)\n\nThe same underlying principle corresponds to avoiding or containing any set of\ngridded permutations. There are many different variations of this strategy\nused throughout our ``StrategyPacks``.\n\n.. code:: python\n\n       >>> import tilings\n       >>> print(tilings.strategies.requirement_insertion.__all__)\n       ['CellInsertionFactory', 'RootInsertionFactory', 'RequirementExtensionFactory', 'RequirementInsertionFactory', 'FactorInsertionFactory', 'RequirementCorroborationFactory']\n\nPoint placements\n----------------\n\nThe core idea of this strategy is to place a uniquely defined point onto\nits own row and/or column. For example, here is a code snippet that\nshows the rules coming from placing the extreme (rightmost, topmost, leftmost,\nbottommost) points of a non-empty permutation avoiding ``231``.\n\n.. code:: python\n\n       >>> from tilings.strategies import PatternPlacementFactory\n       >>> strategy = PatternPlacementFactory()\n       >>> tiling = Tiling.from_string('231').insert_cell((0,0))\n       >>> for rule in strategy(tiling):\n       ...     print(rule)\n       placing the rightmost point in cell (0, 0)\n       +-+                +-+-+\n       |1|             =  |\\| |\n       +-+                +-+-+\n       1: Av+(120)        | |●|\n       Requirement 0:     +-+-+\n       0: (0, 0)          |1| |\n                          +-+-+\n                          1: Av(120)\n                          \\: Av(01)\n                          ●: point\n                          Crossing obstructions:\n                          120: (0, 0), (0, 2), (0, 0)\n                          Requirement 0:\n                          0: (1, 1)\n       placing the topmost point in cell (0, 0)\n       +-+                +-+-+-+\n       |1|             =  | |●| |\n       +-+                +-+-+-+\n       1: Av+(120)        |1| |1|\n       Requirement 0:     +-+-+-+\n       0: (0, 0)          1: Av(120)\n                          ●: point\n                          Crossing obstructions:\n                          10: (0, 0), (2, 0)\n                          Requirement 0:\n                          0: (1, 1)\n       placing the leftmost point in cell (0, 0)\n       +-+                +-+-+\n       |1|             =  | |1|\n       +-+                +-+-+\n       1: Av+(120)        |●| |\n       Requirement 0:     +-+-+\n       0: (0, 0)          | |1|\n                          +-+-+\n                          1: Av(120)\n                          ●: point\n                          Crossing obstructions:\n                          10: (1, 2), (1, 0)\n                          Requirement 0:\n                          0: (0, 1)\n       placing the bottommost point in cell (0, 0)\n       +-+                +-+-+-+\n       |1|             =  |\\| |1|\n       +-+                +-+-+-+\n       1: Av+(120)        | |●| |\n       Requirement 0:     +-+-+-+\n       0: (0, 0)          1: Av(120)\n                          \\: Av(01)\n                          ●: point\n                          Crossing obstructions:\n                          120: (0, 1), (2, 1), (2, 1)\n                          Requirement 0:\n                          0: (1, 0)\n\n\nOther algorithms used for automatically enumerating permutation classes have\nused variations of point placements. For example, enumeration schemes and the\ninsertion encoding essentially consider placing the bottommost point into the\nrow of a tiling. Here is a code snippet for calling a strategy that places\npoints into a row of a tiling.\n\n.. code:: python\n\n       >>> from permuta.misc import DIR_SOUTH\n       >>> from tilings.strategies import RowAndColumnPlacementFactory\n       >>> strategy = RowAndColumnPlacementFactory(place_row=True, place_col=False)\n       >>> placed_tiling = tiling.place_point_in_cell((0, 0), DIR_SOUTH)\n       >>> for rule in strategy(placed_tiling):\n       ...     print(rule)\n       placing the topmost point in row 1\n       +-+-+-+                         +-+                +-+-+-+-+                       +-+-+-+-+-+\n       |\\| |1|                      =  |●|             +  |●| | | |                    +  | | | |●| |\n       +-+-+-+                         +-+                +-+-+-+-+                       +-+-+-+-+-+\n       | |●| |                         ●: point           | |\\| |1|                       |\\| |1| |1|\n       +-+-+-+                         Requirement 0:     +-+-+-+-+                       +-+-+-+-+-+\n       1: Av(120)                      0: (0, 0)          | | |●| |                       | |●| | | |\n       \\: Av(01)                                          +-+-+-+-+                       +-+-+-+-+-+\n       ●: point                                           1: Av(120)                      1: Av(120)\n       Crossing obstructions:                             \\: Av(01)                       \\: Av(01)\n       120: (0, 1), (2, 1), (2, 1)                        ●: point                        ●: point\n       Requirement 0:                                     Crossing obstructions:          Crossing obstructions:\n       0: (1, 0)                                          120: (1, 1), (3, 1), (3, 1)     10: (0, 1), (4, 1)\n                                                          Requirement 0:                  10: (2, 1), (4, 1)\n                                                          0: (0, 2)                       120: (0, 1), (2, 1), (2, 1)\n                                                          Requirement 1:                  Requirement 0:\n                                                          0: (2, 0)                       0: (1, 0)\n                                                                                          Requirement 1:\n                                                                                          0: (3, 2)\n       placing the bottommost point in row 1\n       +-+-+-+                         +-+                +-+-+-+-+                       +-+-+-+-+-+\n       |\\| |1|                      =  |●|             +  |\\| | |1|                    +  |\\| |\\| |1|\n       +-+-+-+                         +-+                +-+-+-+-+                       +-+-+-+-+-+\n       | |●| |                         ●: point           | |●| | |                       | | | |●| |\n       +-+-+-+                         Requirement 0:     +-+-+-+-+                       +-+-+-+-+-+\n       1: Av(120)                      0: (0, 0)          | | |●| |                       | |●| | | |\n       \\: Av(01)                                          +-+-+-+-+                       +-+-+-+-+-+\n       ●: point                                           1: Av(120)                      1: Av(120)\n       Crossing obstructions:                             \\: Av(01)                       \\: Av(01)\n       120: (0, 1), (2, 1), (2, 1)                        ●: point                        ●: point\n       Requirement 0:                                     Crossing obstructions:          Crossing obstructions:\n       0: (1, 0)                                          120: (0, 2), (3, 2), (3, 2)     01: (0, 2), (2, 2)\n                                                          Requirement 0:                  120: (0, 2), (4, 2), (4, 2)\n                                                          0: (1, 1)                       120: (2, 2), (4, 2), (4, 2)\n                                                          Requirement 1:                  Requirement 0:\n                                                          0: (2, 0)                       0: (1, 0)\n                                                                                          Requirement 1:\n                                                                                          0: (3, 1)\n\n\n\nRow and column separation\n-------------------------\n\nEvery non-empty permutation in ``Av(231)`` can be written in the form αnβ where\n``α``, ``β`` are permutation avoiding ``231``, and all of the values in ``α``\nare below all of the values in ``β``. The tiling representing placing the\ntopmost point in ``Av(231)`` contains a crossing size 2 obstruction\n``10: (0, 0), (2, 0)``. This obstruction precisely says that the points in the\ncell ``(0, 0)`` must appear below the points in the cell ``(2, 0)``. The\n``RowColumnSeparationStrategy`` will try to separate the rows and columns as\nmuch as possible according to the size two crossing obstructions.\n\n.. code:: python\n\n       >>> from permuta.misc import DIR_NORTH\n       >>> from tilings.strategies import RowColumnSeparationStrategy\n       >>> strategy = RowColumnSeparationStrategy()\n       >>> placed_tiling = tiling.place_point_in_cell((0, 0), DIR_NORTH)\n       >>> rule = strategy(placed_tiling)\n       >>> print(rule)\n       row and column separation\n       +-+-+-+                    +-+-+-+\n       | |●| |                 =  | |●| |\n       +-+-+-+                    +-+-+-+\n       |1| |1|                    | | |1|\n       +-+-+-+                    +-+-+-+\n       1: Av(120)                 |1| | |\n       ●: point                   +-+-+-+\n       Crossing obstructions:     1: Av(120)\n       10: (0, 0), (2, 0)         ●: point\n       Requirement 0:             Requirement 0:\n       0: (1, 1)                  0: (1, 2)\n\n\nFactor\n------\n\nIf there are no crossing obstructions between two cells ``a`` and ``b`` on a\ntiling then the choice of points in ``a`` are independent from the choice\nof points in ``b``.\n\n.. code:: python\n\n       >>> separated_tiling = rule.children[0]\n       >>> from tilings.strategies import FactorFactory\n       >>> strategy_generator = FactorFactory()\n       >>> for strategy in strategy_generator(separated_tiling):\n       ...     print(strategy(separated_tiling))\n       factor with partition {(0, 0)} / {(1, 2)} / {(2, 1)}\n       +-+-+-+            +-+            +-+                +-+\n       | |●| |         =  |1|         x  |●|             x  |1|\n       +-+-+-+            +-+            +-+                +-+\n       | | |1|            1: Av(120)     ●: point           1: Av(120)\n       +-+-+-+                           Requirement 0:\n       |1| | |                           0: (0, 0)\n       +-+-+-+\n       1: Av(120)\n       ●: point\n       Requirement 0:\n       0: (1, 2)\n\nThe ``x`` in the printed above rule is used to denote Cartesian product.\nWe do this to signify that there is a size-preserving bijection between the\ngridded permutations on the left-hand side, to the set of 3-tuples coming from\nthe Cartesian product on the right-hand side, where the size of a tuple is the\nsum of the sizes of the parts. In particular, it implies that the enumeration\nof the gridded permutations on the left-hand side can be computed by applying the\nCauchy product to the enumerations of the three sets of gridded permutations on\nthe right-hand side.\n\nTo guarantee that these rules are always counted using the Cauchy product\nwe must also ensure any two cells on the same row or column are also contained\nin the same factor, otherwise when counting the left-hand side we have to\nconsider the possible interleavings going on.\n\n.. code:: python\n\n       >>> tiling = Tiling.from_string('231_132').insert_cell((0,0))\n       >>> placed_tiling = tiling.place_point_in_cell((0, 0), DIR_SOUTH)\n       >>> strategy_generator = FactorFactory()\n       >>> for strategy in strategy_generator(placed_tiling):\n       ...     print(strategy(placed_tiling))\n       factor with partition {(0, 1), (2, 1)} / {(1, 0)}\n       +-+-+-+            +-+-+         +-+\n       |\\| |/|         =  |\\|/|      x  |●|\n       +-+-+-+            +-+-+         +-+\n       | |●| |            /: Av(10)     ●: point\n       +-+-+-+            \\: Av(01)     Requirement 0:\n       /: Av(10)                        0: (0, 0)\n       \\: Av(01)\n       ●: point\n       Requirement 0:\n       0: (1, 0)\n\nUsing the setting ``all`` in ``FactorFactory`` will allow us to factor\naccording to only the obstructions and requirements.\n\n.. code:: python\n\n       >>> strategy_generator = FactorFactory('all')\n       >>> for strategy in strategy_generator(placed_tiling):\n       ...     print(strategy(placed_tiling))\n       interleaving factor with partition {(0, 1)} / {(1, 0)} / {(2, 1)}\n       +-+-+-+            +-+           +-+                +-+\n       |\\| |/|         =  |\\|        *  |●|             *  |/|\n       +-+-+-+            +-+           +-+                +-+\n       | |●| |            \\: Av(01)     ●: point           /: Av(10)\n       +-+-+-+                          Requirement 0:\n       /: Av(10)                        0: (0, 0)\n       \\: Av(01)\n       ●: point\n       Requirement 0:\n       0: (1, 0)\n\nWe instead use the symbol ``*`` to make us aware that this is not counted\nby the Cauchy product, but we must also count the possible interleavings.\n\n\nObstruction inferral\n--------------------\n\nThe presence of requirements alongside the obstructions on a tiling can\nsometimes be used to imply that all of the gridded permutations on a tiling also avoid\nsome additional obstruction. The goal of ``ObstructionInferral`` is to add these to\na tiling.\n\n.. code:: python\n\n       >>> from permuta.misc import DIR_NORTH\n       >>> tiling = Tiling.from_string('1234_1243_1423_4123')\n       >>> placed_tiling = tiling.partial_place_point_in_cell((0, 0), DIR_NORTH)\n       >>> from tilings.strategies import ObstructionInferralFactory\n       >>> strategy_generator = ObstructionInferralFactory(3)\n       >>> for strategy in strategy_generator(placed_tiling):\n       ...     print(strategy(placed_tiling))\n       added the obstructions {012: (0, 0), (0, 0), (0, 0)}\n       +-+                                      +-+\n       |●|                                   =  |●|\n       +-+                                      +-+\n       |1|                                      |1|\n       +-+                                      +-+\n       1: Av(0123, 0132, 0312, 3012)            1: Av(012)\n       ●: point                                 ●: point\n       Crossing obstructions:                   Requirement 0:\n       0123: (0, 0), (0, 0), (0, 0), (0, 1)     0: (0, 1)\n       0132: (0, 0), (0, 0), (0, 1), (0, 0)\n       0312: (0, 0), (0, 1), (0, 0), (0, 0)\n       3012: (0, 1), (0, 0), (0, 0), (0, 0)\n       Requirement 0:\n       0: (0, 1)\n\nIn the above code snippet, we have added the obstruction\n``gp = 012: (0, 0), (0, 0), (0, 0)``. In particular, the 4 crossing\nobstructions, and the 4 localised obstructions, all contained a copy of ``gp``,\nso we simplify the right-hand side by removing these from the tiling.\nThis simplification step happens automatically when creating a ``Tiling``.\n\nFusion\n------\n\nConsider the gridded permutations on the following tiling.\n\n.. code:: python\n\n       >>> tiling = Tiling([GriddedPerm(Perm((0, 1)), ((0, 0), (0, 0))), GriddedPerm(Perm((0, 1)), ((0, 0), (1, 0))), GriddedPerm(Perm((0, 1)), ((1, 0), (1, 0)))])\n       >>> print(tiling)\n       +-+-+\n       |\\|\\|\n       +-+-+\n       \\: Av(01)\n       Crossing obstructions:\n       01: (0, 0), (1, 0)\n       >>> for i in range(4):\n       ...     for gp in sorted(tiling.gridded_perms_of_length(i)):\n       ...         print(gp)\n       ε:\n       0: (0, 0)\n       0: (1, 0)\n       10: (0, 0), (0, 0)\n       10: (0, 0), (1, 0)\n       10: (1, 0), (1, 0)\n       210: (0, 0), (0, 0), (0, 0)\n       210: (0, 0), (0, 0), (1, 0)\n       210: (0, 0), (1, 0), (1, 0)\n       210: (1, 0), (1, 0), (1, 0)\n\nDue to the crossing ``01`` obstruction it is clear that all of the underlying\npermutations will be decreasing. Moreover, the transition between the left cell\nand the right cell can be between any of the points. In particular, this says\nthere are ``n + 1`` gridded permutations of size ``n`` on this tiling. We\ncapture this idea by fusing the two columns into a single column.\n\n.. code:: python\n\n       >>> from tilings.strategies import FusionFactory\n       >>> strategy_generator = FusionFactory()\n       >>> for rule in strategy_generator(tiling):\n       ...     print(rule)\n       fuse columns 0 and 1\n       +-+-+                      +-+\n       |\\|\\|                   ↣  |\\|\n       +-+-+                      +-+\n       \\: Av(01)                  \\: Av(01)\n       Crossing obstructions:     Assumption 0:\n       01: (0, 0), (1, 0)         can count points in cell (0, 0)\n\nWe use the symbol ``↣`` instead of ``=`` to remind us that the counts of the\ntwo sides are definitely not the same.\nNotice, the right-hand side tiling here also now requires that we can count the\nnumber of points in cell ``(0, 0)``. If there are ``k`` points in cell ``(0, 0)``\nin a gridded permutation then there will be ``k + 1`` gridded permutations that\nfuse to this gridded permutation. Of course, here the number of points in cell``(0, 0)``\nis going to be equal to the size of the gridded permutation, but in general,\nthe points that need to be counted might not cover the whole tiling. For\nexample, the following rule was used within specification to enumerate\n``Av(123)``.\n\n.. code:: python\n\n       >>> tiling = Tiling(\n       ...     [\n       ...         GriddedPerm(Perm((0, 1)), ((0, 0), (0, 0))),\n       ...         GriddedPerm(Perm((0, 1)), ((0, 0), (1, 0))),\n       ...         GriddedPerm(Perm((0, 1)), ((1, 0), (1, 0))),\n       ...         GriddedPerm(Perm((0, 1, 2)), ((0, 0), (2, 0), (2, 0))),\n       ...         GriddedPerm(Perm((0, 1, 2)), ((1, 0), (2, 0), (2, 0))),\n       ...         GriddedPerm(Perm((0, 1, 2)), ((2, 0), (2, 0), (2, 0))),\n       ...     ]\n       ... )\n       >>> for rule in strategy_generator(tiling):\n       ...     print(rule)\n       fuse columns 0 and 1\n       +-+-+-+                         +-+-+\n       |\\|\\|1|                      ↣  |\\|1|\n       +-+-+-+                         +-+-+\n       1: Av(012)                      1: Av(012)\n       \\: Av(01)                       \\: Av(01)\n       Crossing obstructions:          Crossing obstructions:\n       01: (0, 0), (1, 0)              012: (0, 0), (1, 0), (1, 0)\n       012: (0, 0), (2, 0), (2, 0)     Assumption 0:\n       012: (1, 0), (2, 0), (2, 0)     can count points in cell (0, 0)\n\nPerformance\n-----------\nThe `TileScope` algorithm can be resource-intensive in both time and memory. This\ncodebase is fully compatible with `PyPy <https://www.pypy.org/>`__, an alternative\nPython interpreter that usually runs `TileScope` 5x - 7x faster, at the cost of higher\nmemory usage (sometimes as high as 2x). This extra memory usage is largely caused by\nPyPy's approach to incremental garbage collection, and as a result can be partially\nmitigated by setting the environmental variables\n`described here <https://doc.pypy.org/en/latest/gc_info.html#environment-variables>`__.\nFor example, the configuration\n\n.. code::\n\n    PYPY_GC_MAJOR_COLLECT=1.1\n    PYPY_GC_MAX_DELTA=200MB\n    PYPY_GC_INCREMENT_STEP=10GB\n\ntends to improve memory usage at the cost of 30% - 50% extra time.\n\nIf memory usage, rather than time usage, is a bottleneck, then the default interpreter\n``CPython`` is preferred.\n\n=========\n\nFinally, we'd like to reiterate, if you need support, have a suggestion, or just\nwant to be up to date with the latest developments please join us on our\n`Discord server <https://discord.gg/ySJD6SV>`__ where we'd be happy to hear\nfrom you!\n\n\nCiting\n######\n\nIf you found this library helpful with your research and would like to cite us,\nyou can use the following `BibTeX`_ or go to `Zenodo`_ for alternative formats.\n\n.. _BibTex: https://zenodo.org/record/4944108/export/hx#.YMcq7y2l30o\n\n.. _Zenodo: https://doi.org/10.5281/zenodo.4944107",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/PermutaTriangle/Tilings",
    "keywords": "permutation perm gridded pattern tiling avoid containoccurrences grid class",
    "license": "BSD-3",
    "maintainer": "",
    "maintainer_email": "",
    "name": "tilings",
    "package_url": "https://pypi.org/project/tilings/",
    "platform": "",
    "project_url": "https://pypi.org/project/tilings/",
    "project_urls": {
      "Homepage": "https://github.com/PermutaTriangle/Tilings",
      "Source": "https://github.com/PermutaTriangle/Tilings",
      "Tracker": "https://github.com/PermutaTriangle/Tilings/issues"
    },
    "release_url": "https://pypi.org/project/tilings/3.1.0/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "A Python library for gridded permutations and tilings.",
    "version": "3.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12595861,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "274d5ebcb3fd6c5e905a15b53f847fbfb1ef12ea4bb88ab182dc2e85cff513d0",
          "md5": "9fda967e919515d1c16d7cbff495574e",
          "sha256": "f899f3b0414206258f67559ae8856442ece9939ae947387f12db6002bc34d8ff"
        },
        "downloads": -1,
        "filename": "tilings-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "9fda967e919515d1c16d7cbff495574e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 27602,
        "upload_time": "2019-06-04T23:44:25",
        "upload_time_iso_8601": "2019-06-04T23:44:25.244929Z",
        "url": "https://files.pythonhosted.org/packages/27/4d/5ebcb3fd6c5e905a15b53f847fbfb1ef12ea4bb88ab182dc2e85cff513d0/tilings-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d82f63a345a13fb35978a4d27c2ea7a5d008c0c62837e039320d577c0f7283de",
          "md5": "5091b4c95eb43704a08dc82a8ebce2f7",
          "sha256": "499d1182a785eb949342f1e2762c7b1a4fc62a322c4e5656074726c19c4f8b9a"
        },
        "downloads": -1,
        "filename": "tilings-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5091b4c95eb43704a08dc82a8ebce2f7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 27498,
        "upload_time": "2019-08-26T12:57:14",
        "upload_time_iso_8601": "2019-08-26T12:57:14.823554Z",
        "url": "https://files.pythonhosted.org/packages/d8/2f/63a345a13fb35978a4d27c2ea7a5d008c0c62837e039320d577c0f7283de/tilings-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8db4c81d9b939b5a2992bc24bcfbc6ac9e8235055cd7dc51664fa0574c825bb7",
          "md5": "2713a80701c581d04c6e666b04bf0674",
          "sha256": "70df46daab3409792b06b69682bde5f31bdea8521d624cb03046db7112a62109"
        },
        "downloads": -1,
        "filename": "tilings-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "2713a80701c581d04c6e666b04bf0674",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 27730,
        "upload_time": "2019-08-26T20:26:03",
        "upload_time_iso_8601": "2019-08-26T20:26:03.941534Z",
        "url": "https://files.pythonhosted.org/packages/8d/b4/c81d9b939b5a2992bc24bcfbc6ac9e8235055cd7dc51664fa0574c825bb7/tilings-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f97fcba749f0b75373d2b6c6a227c85a7d7ca1196266e0b675cea33191c0518c",
          "md5": "f929840cfcca68f0acc647b7afcbe1d0",
          "sha256": "afd7e8e36b388056bffb08bae8cb89733aa9f0f0cc7e37e713056cb1a2fd4bc3"
        },
        "downloads": -1,
        "filename": "tilings-1.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f929840cfcca68f0acc647b7afcbe1d0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.5",
        "size": 27735,
        "upload_time": "2020-03-31T12:49:15",
        "upload_time_iso_8601": "2020-03-31T12:49:15.753989Z",
        "url": "https://files.pythonhosted.org/packages/f9/7f/cba749f0b75373d2b6c6a227c85a7d7ca1196266e0b675cea33191c0518c/tilings-1.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b007e9a69ca4e370654a50cc197f4f58fb6aef2b8c610f3078f005c3dcd2d360",
          "md5": "4b29afd2ef101d98391b4d84e2c92989",
          "sha256": "d99a382b5f14bee9f108a427e73dde0750f002180ae72a05327d18df2e7a49e1"
        },
        "downloads": -1,
        "filename": "tilings-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "4b29afd2ef101d98391b4d84e2c92989",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 126431,
        "upload_time": "2020-06-17T11:36:36",
        "upload_time_iso_8601": "2020-06-17T11:36:36.043089Z",
        "url": "https://files.pythonhosted.org/packages/b0/07/e9a69ca4e370654a50cc197f4f58fb6aef2b8c610f3078f005c3dcd2d360/tilings-2.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "79a8bab593502a1e16f2f563036f0f896225535ab522c44e937477481582eb6c",
          "md5": "c005b58fcc18cdba82d15066768212b6",
          "sha256": "2ea77ae46ba191792b0c1e54c13210cc1c14d209d7b5589e3ac9803568a9c752"
        },
        "downloads": -1,
        "filename": "tilings-2.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c005b58fcc18cdba82d15066768212b6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 134126,
        "upload_time": "2020-06-29T20:33:56",
        "upload_time_iso_8601": "2020-06-29T20:33:56.790434Z",
        "url": "https://files.pythonhosted.org/packages/79/a8/bab593502a1e16f2f563036f0f896225535ab522c44e937477481582eb6c/tilings-2.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "70e1737ea1b2f0236072726a62a7a382d759b2a957bdc1a6b6a49ab7a44dc422",
          "md5": "f7f3ace3acb73ee8b57b7c107018e3fc",
          "sha256": "9752eefab85fdada85ede6d92eb9a6b32e9eacdf8240eee18d0eb41ba4c64929"
        },
        "downloads": -1,
        "filename": "tilings-2.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "f7f3ace3acb73ee8b57b7c107018e3fc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 132469,
        "upload_time": "2020-07-08T13:59:03",
        "upload_time_iso_8601": "2020-07-08T13:59:03.751590Z",
        "url": "https://files.pythonhosted.org/packages/70/e1/737ea1b2f0236072726a62a7a382d759b2a957bdc1a6b6a49ab7a44dc422/tilings-2.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f35f5326a78ce5ec0edb1968c3452e6a1e194b214c6c3e63f00e5a17015876d7",
          "md5": "7015d04ee2fb51f5596d596f082d2bb5",
          "sha256": "df39bed25d2b42d8d9a7033393583075016c7d56659dab6d01f2c8a342aca2b1"
        },
        "downloads": -1,
        "filename": "tilings-2.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7015d04ee2fb51f5596d596f082d2bb5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 139099,
        "upload_time": "2020-09-10T16:03:39",
        "upload_time_iso_8601": "2020-09-10T16:03:39.274011Z",
        "url": "https://files.pythonhosted.org/packages/f3/5f/5326a78ce5ec0edb1968c3452e6a1e194b214c6c3e63f00e5a17015876d7/tilings-2.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "941624827c0e40737333e1a112f47de327fc5d762c51040567ebdcc1d2c6b579",
          "md5": "8a057253ba460989039d5f4cd4d93bd6",
          "sha256": "9ee412436e679f6c3fa1efcb00913daa609f0a55772a60ebc254226a11c1ab97"
        },
        "downloads": -1,
        "filename": "tilings-2.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "8a057253ba460989039d5f4cd4d93bd6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 139077,
        "upload_time": "2020-09-11T12:58:19",
        "upload_time_iso_8601": "2020-09-11T12:58:19.119120Z",
        "url": "https://files.pythonhosted.org/packages/94/16/24827c0e40737333e1a112f47de327fc5d762c51040567ebdcc1d2c6b579/tilings-2.3.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.4.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8fb14372a572f7d6c3c3c50d011437abf22823266fd8723572d351f5e958421e",
          "md5": "6632049749eb4d423d62f0f1728c7fc2",
          "sha256": "0d66c430d287123f56f5b2679ecdb0c93c151fe12b7f693465c794ec2bb5f034"
        },
        "downloads": -1,
        "filename": "tilings-2.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "6632049749eb4d423d62f0f1728c7fc2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 148186,
        "upload_time": "2020-10-28T16:22:31",
        "upload_time_iso_8601": "2020-10-28T16:22:31.322780Z",
        "url": "https://files.pythonhosted.org/packages/8f/b1/4372a572f7d6c3c3c50d011437abf22823266fd8723572d351f5e958421e/tilings-2.4.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3befd3ce08628d8570de7a8e0736dcb3a3ec3e687d161a781004689c6c070906",
          "md5": "7e40033085632fe5b23b576f510a3ceb",
          "sha256": "ae8c07293154a241fe024027e65ef4fbe6891b86790097d4c7ef3d457766a5f0"
        },
        "downloads": -1,
        "filename": "tilings-2.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7e40033085632fe5b23b576f510a3ceb",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 149476,
        "upload_time": "2020-11-11T15:13:34",
        "upload_time_iso_8601": "2020-11-11T15:13:34.109226Z",
        "url": "https://files.pythonhosted.org/packages/3b/ef/d3ce08628d8570de7a8e0736dcb3a3ec3e687d161a781004689c6c070906/tilings-2.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5fb323513cdcb9bae48a16bd63376edeb388949627aa8ad3c45e570d636a6fdf",
          "md5": "e8f14045919d9ab66ae05c23bf30e028",
          "sha256": "aca9aba8b6f17ee14df74bbe20b5b026091c47c39ef988fafc5cceb1c2941c2a"
        },
        "downloads": -1,
        "filename": "tilings-3.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e8f14045919d9ab66ae05c23bf30e028",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 151248,
        "upload_time": "2021-06-14T19:58:54",
        "upload_time_iso_8601": "2021-06-14T19:58:54.724678Z",
        "url": "https://files.pythonhosted.org/packages/5f/b3/23513cdcb9bae48a16bd63376edeb388949627aa8ad3c45e570d636a6fdf/tilings-3.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2a3811292b19556e25d833eb12aa9c8de5f591015ce49556351dd63ef80a5403",
          "md5": "6feda1df3f9a9e8ea8bf01eb1040bf88",
          "sha256": "a141ab876c0545fd032d5d67beefce083d641e7c80b1011afa0e699e0a4aaf7c"
        },
        "downloads": -1,
        "filename": "tilings-3.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "6feda1df3f9a9e8ea8bf01eb1040bf88",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 153887,
        "upload_time": "2022-01-17T11:19:47",
        "upload_time_iso_8601": "2022-01-17T11:19:47.518940Z",
        "url": "https://files.pythonhosted.org/packages/2a/38/11292b19556e25d833eb12aa9c8de5f591015ce49556351dd63ef80a5403/tilings-3.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2a3811292b19556e25d833eb12aa9c8de5f591015ce49556351dd63ef80a5403",
        "md5": "6feda1df3f9a9e8ea8bf01eb1040bf88",
        "sha256": "a141ab876c0545fd032d5d67beefce083d641e7c80b1011afa0e699e0a4aaf7c"
      },
      "downloads": -1,
      "filename": "tilings-3.1.0.tar.gz",
      "has_sig": false,
      "md5_digest": "6feda1df3f9a9e8ea8bf01eb1040bf88",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 153887,
      "upload_time": "2022-01-17T11:19:47",
      "upload_time_iso_8601": "2022-01-17T11:19:47.518940Z",
      "url": "https://files.pythonhosted.org/packages/2a/38/11292b19556e25d833eb12aa9c8de5f591015ce49556351dd63ef80a5403/tilings-3.1.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}