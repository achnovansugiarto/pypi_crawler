{
  "info": {
    "author": "Quantastica",
    "author_email": "support@quantastica.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 4 - Beta",
      "Intended Audience :: Science/Research",
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Quantum Programming Studio API\n\nPython wrapper for [Quantum Programming Studio](https://quantum-circuit.com/) HTTP API.\n\n\n## Quick start\n\n**1. Install QPS API package:**\n\n```bash\npip install quantastica-qps-api\n```\n\n**2. Find your QPS API token:**\n\n[Login](https://quantum-circuit.com/login) to Quantum Programming Studio, go to [Profile -> API Access](https://quantum-circuit.com/user_settings/api) and copy your API token.\n\n**3. Configure QPS API package with your API token:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nQPS.save_account(\"YOUR_API_TOKEN\")\n\n```\n\nThat will create a local configuration file where your API token will be stored for future use.\n\n**Now you are ready to use QPS API.**\n\n**Quick start example:** find circuit from initial/final vector pairs using Quantum Algorithm Generator\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nvector_pairs = [\n[ [1, 0, 0, 0], [ 0.5+0j,  0.5+0j,  0.5+0j,  0.5+0j ] ],\n[ [0, 1, 0, 0], [ 0.5+0j,  0+0.5j, -0.5+0j,  0-0.5j ] ],\n[ [0, 0, 1, 0], [ 0.5+0j, -0.5+0j,  0.5+0j, -0.5+0j ] ],\n[ [0, 0, 0, 1], [ 0.5+0j,  0-0.5j, -0.5+0j,  0+0.5j ] ]\n]\n\njob_id = QPS.generator.circuit_from_vectors(vector_pairs, settings = { \"instruction_set\": [\"h\", \"cu1\", \"swap\"] })\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\n\n## Account management\n\n**QPS.save_account(api_token, api_url=None)**\n\n**Run this once** to setup your QPS REST API account. Method will create configuration file and your api token will be stored there for future use.\n\nIf needed, you can clear your token by running `QPS.save_account(\"\")` (or by deleting a configuration file).\n\nIf `api_url` is not provided then `https://quantum-circuit.com/api/` will be set as default.\n\n\n**QPS.config_path()**\n\nYou can get config file path by running `QPS.config_path()`.\n\nDefault configuration file path:\n\n- On Unix, directory is obtained from environment variable HOME if it is set; otherwise the current userâ€™s home directory is looked up in the password directory through the built-in module pwd.\n\n- On Windows, USERPROFILE will be used if set, otherwise a combination of HOMEPATH and HOMEDRIVE will be used.\n\n\n\n## Quantum Algorithm Generator API\n\n[Quantum Algorithm Generator](https://quantastica.com/#generator) is a tool based on machine learning which reverse engineers quantum circuits from state vectors (wave functions). Additionally, it can be used to find quantum algorithm for boolean function from truth table, to transpile circuits and to decompose unitary matrices.\n\n\n### Generator job management\n\nProblem sent to generator is called a \"job\". Each job has unique ID. As generator is resource intensive tool, it is configured to execute only one job at a time. While generator is solving a job, other jobs are queued. When generator finishes executing a job, it takes the next one from the queue.\n\nAPI provides functions for job manipulation: you can list all jobs (filtered by status), stop running job, cancel queued jobs, stop/cancel all jobs, start previously canceled (draft) job, etc.\n\n**QPS.generator.list_jobs(status_filter=None)**\n\nList all jobs, optionally filtered by status.\n\n- `status_filter` String, optional. Can be: `draft`, `queued`, `running`, `error`, `done`.\n\n\n**Example 1** - list all (unfiltered) generator jobs:\n\n```python\n\nfrom quantastica.qps_api import QPS\n\njobs = QPS.generator.list_jobs()\n\nprint(jobs)\n\n```\n\nExample output:\n\n```\n{\n\t\"list\": [\n\t\t{ \"_id\": \"r9LskFoLPQW5w7HTp\", \"name\": \"Bell state\", \"type\": \"vectors\", \"status\": \"done\" },\n\t\t{ \"_id\": \"R8tJH7XoZ233oTREy\", \"name\": \"4Q Gauss\", \"type\": \"vectors\", \"status\": \"queued\" },\n\t\t{ \"_id\": \"h7fzYbFz8MJvkNhiX\", \"name\": \"Challenge\", \"type\": \"unitary\", \"status\": \"draft\" },\n\t\t{ \"_id\": \"PC5PNXiGqhh2HmkX8\", \"name\": \"Experiment\", \"type\": \"vectors\", \"status\": \"error\"},\n\t\t{ \"_id\": \"SNhiCqSCT2WwRWKCd\", \"name\": \"Decompose\", \"type\": \"unitary\", \"status\": \"running\" }\n\t]\n}\n```\n\n**Example 2** - list `running` jobs:\n\n```python\n\nfrom quantastica.qps_api import QPS\n\njobs = QPS.generator.list_jobs(status_filter=\"running\")\n\nprint(jobs)\n\n```\n\nExample output:\n\n```\n{\n\t\"list\": [\n\t\t{ \"_id\": \"SNhiCqSCT2WwRWKCd\", \"name\": \"Decompose\", \"type\": \"unitary\", \"status\": \"running\" }\n\t]\n}\n```\n\n\n**QPS.generator.job_status(job_id)**\n\nGet job status.\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nstatus = QPS.generator.job_status(\"PC5PNXiGqhh2HmkX8\")\n\nprint(status)\n\n```\n\nExample output:\n\n```\n{ \"_id\": \"PC5PNXiGqhh2HmkX8\", \"name\": \"Experiment\", \"type\": \"vectors\", \"status\": \"error\", \"message\": \"connect ECONNREFUSED\" }\n```\n\n\n**QPS.generator.get_job(job_id, wait=True)**\n\nGet generator job referenced by ID. If `wait` argument is `True` (default), then function will wait for a job to finish (or fail) before returning. If `wait` is `False`, then job will be immediatelly returned even if it is still running (in which case it will not contain a solution).\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\njob = QPS.generator.get_job(\"r9LskFoLPQW5w7HTp\")\n\nprint(job)\n\n```\n\nExample output:\n\n```\n{\n\t\"_id\": \"r9LskFoLPQW5w7HTp\",\n\t\"name\": \"Bell\",\n\t\"type\": \"vectors\",\n\t\"source\": {\n\t\t\"vectors\": {\n\t\t\t\"text1\": \"[ 1, 0, 0, 0 ]\",\n\t\t\t\"text2\": \"[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]\",\n\t\t\t\"endianness1\": \"little\",\n\t\t\t\"endianness2\": \"little\"\n\t\t}\n\t},\n\t\"problem\": [\n\t\t{\n\t\t\t\"input\": [ 1, 0, 0, 0 ],\n\t\t\t\"output\": [ 0.7071067811865475, 0, 0, 0.7071067811865475 ]\n\t\t}\n\t],\n\t\"settings\": {\n\t\t\"max_diff\": 0.001,\n\t\t\"diff_method\": \"distance\",\n\t\t\"single_solution\": False,\n\t\t\"pre_processing\": \"\",\n\t\t\"allowed_gates\": \"u3,cx\",\n\t\t\"coupling_map\": [],\n\t\t\"min_gates\": 0,\n\t\t\"max_gates\": 0\n\t},\n\t\"status\": \"done\",\n\t\"output\": {\n\t\t\"circuits\": [\n\t\t\t{\n\t\t\t\t\"qubits\": 2,\n\t\t\t\t\"cregs\": [],\n\t\t\t\t\"diff\": 0,\n\t\t\t\t\"program\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"u3\",\n\t\t\t\t\t\t\"wires\": [ 0 ],\n\t\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\t\"params\": {\n\t\t\t\t\t\t\t\t\"theta\": -1.570796370506287,\n\t\t\t\t\t\t\t\t\"phi\": -3.141592741012573,\n\t\t\t\t\t\t\t\t\"lambda\": -5.327113628387451\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"cx\",\n\t\t\t\t\t\t\"wires\": [ 0, 1 ],\n\t\t\t\t\t\t\"options\": {}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"index\": 0,\n\t\t\t\t\"qasm\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\\ncx q[0], q[1];\\n\",\n\t\t\t\t\"qasmExt\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\\ncx q[0], q[1];\\n\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"qubits\": 2,\n\t\t\t\t\"cregs\": [],\n\t\t\t\t\"diff\": 0,\n\t\t\t\t\"program\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"u3\",\n\t\t\t\t\t\t\"wires\": [ 1 ],\n\t\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\t\"params\": {\n\t\t\t\t\t\t\t\t\"theta\": -1.570796370506287,\n\t\t\t\t\t\t\t\t\"phi\": -3.141592741012573,\n\t\t\t\t\t\t\t\t\"lambda\": -5.327113628387451\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"cx\",\n\t\t\t\t\t\t\"wires\": [ 1, 0 ],\n\t\t\t\t\t\t\"options\": {}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"index\": 1,\n\t\t\t\t\"qasm\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\\ncx q[1], q[0];\\n\",\n\t\t\t\t\"qasmExt\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\\ncx q[1], q[0];\\n\"\t\t\t\t\n\t\t\t}\n\t\t],\n\t\t\"error_code\": 0,\n\t\t\"message\": \"\",\n\t\t\"time_taken\": 0.002,\n\t\t\"version\": \"0.1.0\"\n\t},\n\t\"queuedAt\": \"2021-02-06T23:39:29.676Z\",\n\t\"startedAt\": \"2021-02-06T23:39:29.926Z\",\n\t\"finishedAt\": \"2021-02-06T23:39:30.383Z\"\n}\n```\n\n**QPS.generator.stop_job(job_id)**\n\nStop running or cancel queued job. Job will be put into `draft` state, and you can start it again later by calling `start_job()`.\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nresponse = QPS.generator.stop_job(\"SNhiCqSCT2WwRWKCd\")\n\nprint(response)\n\n```\n\nExample output:\n\n```\n{ _id: \"SNhiCqSCT2WwRWKCd\", message: \"OK\" }\n```\n\n\n**QPS.generator.stop_all_jobs(status_filter=None)**\n\nStop running job / cancel all queued jobs.\n\n- `status_filter` - you can stop only a running job by providing `status_filter=\"running\"` (after this, next job from the queue will be executed). Or, you can cancel all queued jobs by providing `status_filter=\"queued\"` (running job will not be affected - it will continue running).\n\n**Example 1** - stop running job and remove all jobs from queue:\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nstopped = QPS.generator.stop_all_jobs()\n\nprint(stopped)\n\n```\n\nExample output:\n\n```\n{\n\t\"stopped\": [ \n\t\t{ \"_id\": \"SNhiCqSCT2WwRWKCd\", \"name\": \"Decompose\", \"type\": \"unitary\" },\n\t\t{ \"_id\": \"R8tJH7XoZ233oTREy\", \"name\": \"4Q Gauss\", \"type\": \"vectors\" }\n\t]\n}\n```\n\n**Example 2** - stop only a running job. Next job from queue, if any, will start:\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nstopped = QPS.generator.stop_all_jobs(status_filter=\"running\")\n\nprint(stopped)\n\n```\n\nExample output:\n\n```\n{\n\t\"stopped\": [\n\t\t{ \"_id\": \"SNhiCqSCT2WwRWKCd\", \"name\": \"Decompose\", \"type\": \"unitary\" }\n\t]\n}\n```\n\n**Example 3** - cancel all queued jobs. Running job will not be affected:\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nstopped = QPS.generator.stop_all_jobs(status_filter=\"queued\")\n\nprint(stopped)\n\n```\n\nExample output:\n\n```\n{\n\t\"stopped\": [\n\t\t{ \"_id\": \"R8tJH7XoZ233oTREy\", \"name\": \"4Q Gauss\", \"type\": \"vectors\" }\n\t]\n}\n```\n\n\n**QPS.generator.start_job(job_id)**\n\nStart previously stopped/canceled job (can be any job with status `draft`).\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nresponse = QPS.generator.start_job(\"SNhiCqSCT2WwRWKCd\")\n\nprint(response)\n\n```\n\nExample output:\n\n```\n{ _id: \"SNhiCqSCT2WwRWKCd\", message: \"OK\" }\n```\n\n\n### Circuit from vectors\n\nFind quantum circuit from pairs of initial & final state vectors (wave functions).\n\n**QPS.generator.circuit_from_vectors(vector_pairs, endianness = \"little\", job_name=None, settings = {}, start_job=True)**\n\n- `vector_pairs` is list containing vector pairs. Each vector pair is list with 2 elements: initial vector and final vector. All vectors in all pairs must be of same length (same number of qubits).\n\n- `endianness` string. Orientation of bits in state vector (most significant bit/first qubit or least significant bit/first qubit). Can be `little` (like Qiskit) or `big`. Default is `little`.\n\n- `job_name` string is optional. You can give it a human readable name.\n\n- `settings` object is optional. Default is:\n\n```python\n\n{\n\t\"allowed_gates\": \"u3,cx\",\n\t\"max_diff\": 1e-3,\n\t\"diff_method\": \"distance\",\n\t\"single_solution\": True,\n\t\"pre_processing\": \"\"\n}\n\n```\n\nNote: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.\n\n- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.\n\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nvector_pairs = [\n[ [1, 0, 0, 0], [ 0.5+0j,  0.5+0j,  0.5+0j,  0.5+0j ] ],\n[ [0, 1, 0, 0], [ 0.5+0j,  0+0.5j, -0.5+0j,  0-0.5j ] ],\n[ [0, 0, 1, 0], [ 0.5+0j, -0.5+0j,  0.5+0j, -0.5+0j ] ],\n[ [0, 0, 0, 1], [ 0.5+0j,  0-0.5j, -0.5+0j,  0+0.5j ] ]\n]\n\njob_id = QPS.generator.circuit_from_vectors(vector_pairs, settings = { \"instruction_set\": [\"h\", \"cu1\", \"swap\"], \"single_solution\": False })\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\nswap q[0], q[1];\ncu1 (2.356194496154785) q[0], q[1];\nh q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\ncu1 (2.356194496154785) q[0], q[1];\nh q[0];\nswap q[0], q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\ncu1 (2.356194496154785) q[0], q[1];\nswap q[0], q[1];\nh q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nswap q[0], q[1];\nh q[0];\ncu1 (2.356194496154785) q[0], q[1];\nh q[1];\n```\n\n### State preparation\n\nGet circuit which will transform ground state (all qubits reset) to desired final state vector.\n\n**QPS.generator.state_preparation(final_vector, endianness = \"little\", job_name=None, settings = {}, start_job=True)**\n\n- `final_vector` is target vector.\n\n- `endianness` string. Orientation of bits in state vector (most significant bit/first qubit or least significant bit/first qubit). Can be `little` (like Qiskit) or `big`. Default is `little`.\n\n- `job_name` string is optional. You can give it a human readable name.\n\n- `settings` object is optional. Default: see `QPS.generator.circuit_from_vectors()`.\n\n- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.\n\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\ndesired_state = [0.5, 0.5, 0.5, 0.5]\n\njob_id = QPS.generator.state_preparation(desired_state, settings = { \"instruction_set\": [\"u3\", \"cx\"] })\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nu3 (1.570796370506287, 0, 1.217840194702148) q[0];\nu3 (1.570796370506287, 0, 0.621559917926788) q[1];\n```\n\n\n### Transpile\n\nTranspile circuit (change instruction set).\n\n**QPS.generator.transpile(input_qasm, method=\"replace_blocks\", method_options={}, job_name=None, settings = {}, start_job=True)**\n\n- `input_qasm` is string containing OpenQASM 2.0 code.\n\n- `method` is method name string. Can be one of: \"replace_circuit\", \"replace_blocks\", \"replace_gates\". Default: \"replace_blocks\".\n\n- `method_options` dict with following structure:\n\n\t- If method is `replace_blocks` then: `{ \"block_size\": 2, \"two_pass\": False }` (maximum block size is 4).\n\n\t- For other methods: no options (`method_options` is ignored)\n\n- `job_name` string is optional. You can give it a human readable name.\n\n- `settings` object is optional. Default is:\n\n```python\n\n{\n\t\"allowed_gates\": \"u3,cx\",\n\t\"max_diff\": 1e-3,\n\t\"diff_method\": \"distance\",\n\t\"single_solution\": True,\n\t\"pre_processing\": \"experimental1\"\n}\n\n```\n\nDefault `diff_method` is `distance`, which means that input and output circuit's global phase will match. That also means longer running time and possibly deeper output circuit (especially with new IBM's instruction set `id, x, sx, rz, cx`). If you are relaxed about global phase (like Qiskit's transpile method), then provide `\"diff_method\": \"ignorephase\"` in `settings`.\n\nNote: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.\n\n- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.\n\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\ninput_qasm = \"\"\"\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[0];\ncx q[0], q[1];\n\"\"\"\n\njob_id = QPS.generator.transpile(input_qasm, settings = { \"instruction_set\": [\"id\", \"x\", \"sx\", \"rz\", \"cx\"], \"diff_method\": \"ignorephase\" })\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nsx q[0];\nrz (1.570796370506287) q[0];\nsx q[0];\ncx q[0], q[1];\n```\n\n### Decompose matrix\n\nDecompose unitary matrix (find circuit from matrix).\n\n**QPS.generator.decompose_unitary(unitary, endianness = \"big\", job_name=None, settings = {}, start_job=True)**\n\n- `unitary` matrix operator.\n\n- `endianness` - orientation of the matrix. Can be `little` endian (like Qiskit) or `big` endian. Default is `big`. Note that default endianness of the matrix differs from default endianness of vectors in other methods. That's to be aligned with QPS. In Qiskit, both matrices and vectors are `little` endian. So, if you are solving unitary from Qiskit then provide `endianness = \"little\"` argument.\n\n- `job_name` string is optional. You can give it a human readable name.\n\n- `settings` object is optional. Default is:\n\n```python\n{\n\t\"allowed_gates\": \"u3,cx\",\n\t\"max_diff\": 1e-3,\n\t\"diff_method\": \"distance\",\n\t\"single_solution\": True,\n\t\"pre_processing\": \"\"\n}\n```\n\nNote: if `settings` argument is provided, it will overwrite default values, but only provided keys will be overwritten - not entire default settings object.\n\n- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.\n\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nunitary = [\n[ 0.5+0.0j,  0.5+0.0j,  0.5+0.0j,  0.5+0.0j],\n[ 0.5+0.0j,  0.5+0.0j, -0.5+0.0j, -0.5+0.0j],\n[ 0.5+0.0j, -0.5+0.0j,  0.0+0.5j,  0.0-0.5j],\n[ 0.5+0.0j, -0.5+0.0j,  0.0-0.5j,  0.0+0.5j]\n]\n\njob_id = QPS.generator.decompose_unitary(unitary, settings = { \"instruction_set\": [\"h\", \"cu1\", \"swap\"], \"single_solution\": False })\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\nswap q[0], q[1];\ncu1 (1.570796370506287) q[0], q[1];\nh q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\ncu1 (1.570796370506287) q[0], q[1];\nh q[0];\nswap q[0], q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nh q[1];\ncu1 (1.570796370506287) q[0], q[1];\nswap q[0], q[1];\nh q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nswap q[0], q[1];\nh q[0];\ncu1 (1.570796370506287) q[0], q[1];\nh q[1];\n```\n\n\n### Create algorithm from truth table\n\nCreate circuit which implements logical expression whose truth table is given.\n\n**QPS.generator.circuit_from_truth_table(truth_table_csv, column_defs, csv_delimiter=None, additional_qubits=1, job_name=None, settings={}, start_job=True)**\n\n- `truth_table_csv` is string containing truth table in CSV format\n\n- `column_defs` list of strings describing each column from truth table: `\"input\"`, `\"output\"` or `\"ignore\"`\n\n- `csv_delimiter` CSV column delimiter char: `None`, `\",\"` (comma) or `\"\\t\"` (tab). If delimiter is `None` (default) it will be automatically detected.\n\n- `additional_qubits` number of qubits to add (to displace input and output qubits).\n\n- `job_name` string is optional. You can give it a human readable name.\n\n- `settings` object is optional. Default is:\n\n```python\n{\n\t\"allowed_gates\": \"x,cx,ccx,swap\",\n\t\"max_diff\": 1e-3,\n\t\"diff_method\": \"distance\",\n\t\"single_solution\": True,\n\t\"pre_processing\": \"\"\n}\n```\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\ntruth_table = \"\"\"\nA,B,A_NAND_B\n0,0,1\n0,1,1\n1,0,1\n1,1,0\n\"\"\"\n\njob_id = QPS.generator.circuit_from_truth_table(truth_table, [\"input\", \"input\", \"output\"])\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\traise Exception(job_output[\"message\"])\nelse:\n\tif(len(job_output[\"circuits\"]) == 0):\n\t\traise Exception(\"No results.\")\n\telse:\n\t\tfor circuit in job_output[\"circuits\"]:\n\t\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[3];\nx q[2];\nccx q[0], q[1], q[2];\n```\n\n\n### Run problem file\n\nSolve problem provided in internal format used by generator.\n\n**QPS.generator.solve(problem, settings = {}, start_job=True)**\n\n- `problem` object - generator job exported to json from QPS.\n\n- `settings` argument is optional. If provided, it will overwrite keys in `problem.settings`. Note that only provided keys will be overwritten - not entire `problem.settings` object.\n\n- `start_job` if this argument is `True` (default) the job will be immediatelly sent to execution queue. If `start_job` is `False` then it will stay in `draft` state and you will be able to start it later by calling `start_job()` method.\n\n\n**Example:**\n\n```python\n\nfrom quantastica.qps_api import QPS\n\nproblem = {\n\t\"name\": \"Bell\",\n\t\"type\": \"vectors\",\n\t\"source\": {\n\t\t\"vectors\": {\n\t\t\t\"text1\": \"[ 1, 0, 0, 0 ]\",\n\t\t\t\"text2\": \"[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]\",\n\t\t\t\"endianness1\": \"little\",\n\t\t\t\"endianness2\": \"little\"\n\t\t}\n\t},\n\t\"problem\": [\n\t\t{\n\t\t\t\"input\": [\n\t\t\t\t1,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"output\": [\n\t\t\t\t0.7071067811865475,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0.7071067811865475\n\t\t\t]\n\t\t}\n\t],\n\t\"settings\": {\n\t\t\"allowed_gates\": \"u3,cx\",\n\t\t\"coupling_map\": [],\n\t\t\"min_gates\": 0,\n\t\t\"max_gates\": 0,\n\t\t\"max_diff\": 0.001,\n\t\t\"diff_method\": \"distance\",\n\t\t\"single_solution\": False,\n\t\t\"pre_processing\": \"\"\n\t}\n}\n\njob_id = QPS.generator.solve(problem)\n\njob = QPS.generator.get_job(job_id, wait=True)\n\njob_status = job[\"status\"]\njob_output = job[\"output\"]\n\nif(job_status == \"error\"):\n\tprint(job_output[\"message\"])\nelse:\n\tfor circuit in job_output[\"circuits\"]:\n\t\tprint(circuit[\"qasm\"])\n\n```\n\nExample output:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -2.675650835037231) q[0];\ncx q[0], q[1];\n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\nu3 (-1.570796370506287, -3.141592741012573, -2.675650835037231) q[1];\ncx q[1], q[0];\n```\n\n\n### Generator output format\n\nGenerator job object has following structure:\n\n```javascript\n{\n\t\"name\"       : String,\n\t\"type\"       : String,\n\t\"source\"     : Object,\n\t\"problem\"    : Array,\n\t\"settings\"   : Object,\n\t\"status\"     : String,\n\t\"output\"     : Object,\n\t\"queuedAt\"   : String,\n\t\"startedAt\"  : String,\n\t\"finishedAt\" : String\n}\n```\n\nKeys important to user are:\n\n- `name` String: name of the job\n\n- `status` String: can be `draft`, `queued`, `running`, `error`, `done`.\n\n- `output` Object with following structure:\n\n```javascript\n{\n\t\"error_code\" : Integer,\n\t\"message\"    : String,\n\t\"time_taken\" : Float,\n\t\"version\"    : String,\n\t\"circuits\"   : Array of Object\n}\n```\n\n- `error_code` Integer: 0 on success, non-zero on error\n\n- `message` String: error message if error code is non-zero\n\n- `time_taken` Float: number of seconds\n\n- `version` String: generator version\n\n- `circuits` Array: resulting circuits. Each is object with following structure:\n\n```javascript\n{\n\t\"qubits\"  : Integer,\n\t\"cregs\"   : Array,\n\t\"program\" : Array,\n\t\"diff\"    : Float,\n\t\"index\"   : Integer,\n\t\"qasm\"    : String,\n\t\"qasmExt\" : String\n}\n```\n\nKeys important to user are:\n\n- `qasm` OpenQASM 2.0 source code of the resulting circuit.\n\n- `qasmExt` OpenQASM 2.0 with extended instruction set (all gates supported by Quantum Programming Studio).\n\nDifference between `qasm` and `qasmExt`: if circuit contains gate supported by QPS but not directly supported by OpenQASM 2.0 then `qasm` will contain equivalent circuit transpiled to OpenQASM 2.0 instruction set, but `qasmExt` will contain gates as is.\n\nFor example if circuit contains IONQ native gate `gpi2(2.51678906856393)` on first qubit:\n\n`qasm` will be:\n\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[1];\nu3 (1.5707963267948966, 0.9459927417690333, -0.9459927417690333) q[0];\n```\n\n`qasmExt` will contain:\n```\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[1];\ngpi2 (2.51678906856393) q[0];\n```\n\n\n**Example job object with output:**\n\n```python\n{\n\t\"_id\": \"r9LskFoLPQW5w7HTp\",\n\t\"name\": \"Bell\",\n\t\"type\": \"vectors\",\n\t\"source\": {\n\t\t\"vectors\": {\n\t\t\t\"text1\": \"[ 1, 0, 0, 0 ]\",\n\t\t\t\"text2\": \"[ 1/sqrt(2), 0, 0, 1/sqrt(2) ]\",\n\t\t\t\"endianness1\": \"little\",\n\t\t\t\"endianness2\": \"little\"\n\t\t}\n\t},\n\t\"problem\": [\n\t\t{\n\t\t\t\"input\": [ 1, 0, 0, 0 ],\n\t\t\t\"output\": [ 0.7071067811865475, 0, 0, 0.7071067811865475 ]\n\t\t}\n\t],\n\t\"settings\": {\n\t\t\"max_diff\": 0.001,\n\t\t\"diff_method\": \"distance\",\n\t\t\"single_solution\": False,\n\t\t\"pre_processing\": \"\",\n\t\t\"allowed_gates\": \"u3,cx\",\n\t\t\"coupling_map\": [],\n\t\t\"min_gates\": 0,\n\t\t\"max_gates\": 0\n\t},\n\t\"status\": \"done\",\n\t\"output\": {\n\t\t\"circuits\": [\n\t\t\t{\n\t\t\t\t\"qubits\": 2,\n\t\t\t\t\"cregs\": [],\n\t\t\t\t\"diff\": 0,\n\t\t\t\t\"program\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"u3\",\n\t\t\t\t\t\t\"wires\": [ 0 ],\n\t\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\t\"params\": {\n\t\t\t\t\t\t\t\t\"theta\": -1.570796370506287,\n\t\t\t\t\t\t\t\t\"phi\": -3.141592741012573,\n\t\t\t\t\t\t\t\t\"lambda\": -5.327113628387451\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"cx\",\n\t\t\t\t\t\t\"wires\": [ 0, 1 ],\n\t\t\t\t\t\t\"options\": {}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"index\": 0,\n\t\t\t\t\"qasm\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\\ncx q[0], q[1];\\n\",\n\t\t\t\t\"qasmExt\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[0];\\ncx q[0], q[1];\\n\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"qubits\": 2,\n\t\t\t\t\"cregs\": [],\n\t\t\t\t\"diff\": 0,\n\t\t\t\t\"program\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"u3\",\n\t\t\t\t\t\t\"wires\": [ 1 ],\n\t\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\t\"params\": {\n\t\t\t\t\t\t\t\t\"theta\": -1.570796370506287,\n\t\t\t\t\t\t\t\t\"phi\": -3.141592741012573,\n\t\t\t\t\t\t\t\t\"lambda\": -5.327113628387451\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"cx\",\n\t\t\t\t\t\t\"wires\": [ 1, 0 ],\n\t\t\t\t\t\t\"options\": {}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"index\": 1,\n\t\t\t\t\"qasm\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\\ncx q[1], q[0];\\n\",\n\t\t\t\t\"qasmExt\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\nu3 (-1.570796370506287, -3.141592741012573, -5.327113628387451) q[1];\\ncx q[1], q[0];\\n\"\n\t\t\t}\n\t\t],\n\t\t\"error_code\": 0,\n\t\t\"message\": \"\",\n\t\t\"time_taken\": 0.002,\n\t\t\"version\": \"0.1.0\"\n\t},\n\t\"createdAt\": \"2021-02-06T23:39:29.108Z\",\n\t\"modifiedAt\": \"2021-02-06T23:39:30.383Z\",\n\t\"queuedAt\": \"2021-02-06T23:39:29.676Z\",\n\t\"startedAt\": \"2021-02-06T23:39:29.926Z\",\n\t\"finishedAt\": \"2021-02-06T23:39:30.383Z\"\n}\n```\n\n\n### Using Generator with Qiskit\n\nGenerator is using OpenQASM 2.0 format for input and output, so integration with Qiskit (and other frameworks that support QASM) is easy.\n\n**Example** transpile Qiskit circuit:\n\n```python\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit.random import random_circuit\nfrom qiskit.quantum_info import Operator\n\nfrom quantastica.qps_api import QPS\n\n# Generate random Qiskit circuit\nqc = random_circuit(5, 5, measure=False)\n\n# Get QASM code\ninput_qasm = qc.qasm()\n\n# Transpile with generator\njob_id = QPS.generator.transpile(input_qasm, settings = { \"instruction_set\": [\"id\", \"u3\", \"cx\"], \"diff_method\": \"ignorephase\" })\njob = QPS.generator.get_job(job_id, wait=True)\njob_status = job[\"status\"]\njob_output = job[\"output\"]\nif(job_status == \"error\"):\n    raise Exception(job_output[\"message\"])\n\ntranspiled_circuit = job_output[\"circuits\"][0]\n\n# Get QASM code\ntranspiled_qasm = transpiled_circuit[\"qasm\"]\n\n# Create Qiskit circuit\ntranspiled_qc = QuantumCircuit.from_qasm_str(transpiled_qasm)\n\n# Show circuit\nprint(\"Depth:\", transpiled_qc.depth())\nprint(\"Ops:\", sum(j for i, j in transpiled_qc.count_ops().items()))\ndisplay(transpiled_qc.draw(output=\"mpl\"))\n\n```\n\n\n## Quantum Language Converter API\n\n[Quantum Language Converter](https://quantastica.com/#converters) is a tool which converts quantum program between different quantum programming languages and frameworks. It is also available as a [q-convert](https://www.npmjs.com/package/q-convert) command line tool and as a web UI at [https://quantum-circuit.com/qconvert](https://quantum-circuit.com/qconvert).\n\nQPS has integrated quantum language converter API which you can access directly from python code:\n\n\n\n**QPS.converter.convert(input, source, dest)**\n\nConverts `input` quantum program given as string from `source` format into `dest` format.\n\n- `input` String. Program source code\n\n- `source` String. Input format:\n\n\t- `qasm` [OpenQASM 2.0](https://github.com/Qiskit/openqasm) source code\n\t- `quil` [Quil](https://arxiv.org/abs/1608.03355) source code\n\t- `qobj` [QObj](https://arxiv.org/abs/1809.03452)\n\t- `ionq` [IONQ](https://docs.ionq.com/) (json)\n\t- `quantum-circuit` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) object (json)\n\t- `toaster` [Qubit Toaster](https://quantastica.com/#toaster) object (json)\n\n- `dest` String. Output format:\n\n\t- `qiskit` [Qiskit](https://qiskit.org/documentation/)\n\t- `qasm` [OpenQASM 2.0](https://github.com/Qiskit/openqasm)\n\t- `qasm-ext` OpenQASM 2.0 with complete instruction set supported by QPS (and other Quantastica tools)\n\t- `qobj` [QObj](https://arxiv.org/abs/1809.03452)\n\t- `quil` [Quil](https://arxiv.org/abs/1608.03355)\n\t- `pyquil` [pyQuil](http://docs.rigetti.com/en/latest/index.html)\n\t- `braket` [Braket](https://docs.aws.amazon.com/braket/)\n\t- `cirq` [Cirq](https://github.com/quantumlib/Cirq)\n\t- `tfq` [TensorFlow Quantum](https://www.tensorflow.org/quantum)\n\t- `qsharp` [QSharp](https://docs.microsoft.com/en-us/quantum/language/index?view=qsharp-preview)\n\t- `quest` [QuEST](https://quest.qtechtheory.org/)\n\t- `js` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) (javascript)\n\t- `quantum-circuit` [quantum-circuit](https://www.npmjs.com/package/quantum-circuit) (json)\n\t- `toaster` [Qubit Toaster](https://quantastica.com/toaster/)\n\t- `svg` [SVG (standalone)](https://www.w3.org/Graphics/SVG/)\n\t- `svg-inline` [SVG (inline)](https://www.w3.org/Graphics/SVG/)\n\n\n\n**Example 1** - convert QASM 2.0 program to QUIL:\n\n```python\nfrom quantastica.qps_api import QPS\n\ninput_program = \"\"\"\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\ncreg c[2];\nh q[0];\ncx q[0], q[1];\nmeasure q[0] -> c[0];\nmeasure q[1] -> c[1];\n\"\"\"\n\noutput_program = QPS.converter.convert(input_program, \"qasm\", \"quil\")\n\nprint(output_program)\n\n```\n\nOutput:\n\n```\nDECLARE ro BIT[2]\nH 0\nCNOT 0 1\nMEASURE 0 ro[0]\nMEASURE 1 ro[1]\n```\n\n\n**Example 2** - convert QASM 2.0 program to circuit drawing as vector image:\n\n```python\nfrom quantastica.qps_api import QPS\n\ninput_program = \"\"\"\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[2];\ncreg c[2];\nh q[0];\ncx q[0], q[1];\nmeasure q[0] -> c[0];\nmeasure q[1] -> c[1];\n\"\"\"\n\noutput_svg = QPS.converter.convert(input_program, \"qasm\", \"svg\")\n\nopen(\"output.svg\", \"w\").write(output_svg)\n\n```\n\n\n## Utils API\n\n**QPS.utils.random_circuit(num_qubits=5, output_format=\"quantum-circuit\", options=None)**\n\nReturns random quantum circuit.\n\n- `num_qubits` Integer. Number of qubits. Default: `5`.\n\n- `format` String. Output format. The same as `QPS.converter.convert()` function's `dest` argument. Example: `\"qasm\"`. Default: `\"quantum-circuit\"`.\n\n- `options` Dict. Optional. Can contain following keys:\n\n\t- `instruction_set` List of gates to use. Example: `[\"u3\", \"cx\"]`. Default: `[ \"u3\", \"rx\", \"ry\", \"rz\", \"cx\", \"cz\" ]`.\n\t- `num_gates` Integer. Number of gates in the circuit. Default is `num_qubits * 8`.\n\t- `mid_circuit_measurement` Bool. Default: `False`.\n\t- `mid_circuit_reset` Bool. Default: `False`.\n\t- `classic_control` Bool. Default: `False`.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/quantastica/qps-api",
    "keywords": "",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "quantastica-qps-api",
    "package_url": "https://pypi.org/project/quantastica-qps-api/",
    "platform": null,
    "project_url": "https://pypi.org/project/quantastica-qps-api/",
    "project_urls": {
      "Homepage": "https://github.com/quantastica/qps-api"
    },
    "release_url": "https://pypi.org/project/quantastica-qps-api/0.9.9/",
    "requires_dist": [
      "configparser",
      "requests"
    ],
    "requires_python": "",
    "summary": "Quantastica Quantum Programming Studio API",
    "version": "0.9.9",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17349318,
  "releases": {
    "0.9.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "884ed96ffdd82d2bc6bb3ab649ec80b5028f03f86df8a3fdc708163313882a60",
          "md5": "3b0e4b59753c51b3cf99b3fda1234223",
          "sha256": "604d2fd9a11f9d93fbaed00295003f19a87ff9e80efa7f97277fa1580230add6"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3b0e4b59753c51b3cf99b3fda1234223",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13324,
        "upload_time": "2021-02-08T14:15:28",
        "upload_time_iso_8601": "2021-02-08T14:15:28.439768Z",
        "url": "https://files.pythonhosted.org/packages/88/4e/d96ffdd82d2bc6bb3ab649ec80b5028f03f86df8a3fdc708163313882a60/quantastica_qps_api-0.9.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "25c99f44fe991ff4bd9f9094e4c961f62d4fff98c5548078b224a7abd057a433",
          "md5": "e1d0c18cf8768e9125f8183f47ed88a0",
          "sha256": "74d44377dbf77f8c2b16c98258042103d9e35bff81b80460a5a32c672aaa66a4"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e1d0c18cf8768e9125f8183f47ed88a0",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18279,
        "upload_time": "2021-02-08T14:15:30",
        "upload_time_iso_8601": "2021-02-08T14:15:30.502341Z",
        "url": "https://files.pythonhosted.org/packages/25/c9/9f44fe991ff4bd9f9094e4c961f62d4fff98c5548078b224a7abd057a433/quantastica-qps-api-0.9.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fd9bef15dd2f9807c637dc3a6becb9aa52711e2a63541e64a31cb097384723d6",
          "md5": "5d7aa01fd5d782cf64d8feebe67652ce",
          "sha256": "2a3cfc213dc2bb35e5e45972aa991a47c6d1672718025fd279beddc750c521a4"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5d7aa01fd5d782cf64d8feebe67652ce",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 13312,
        "upload_time": "2021-02-08T14:21:19",
        "upload_time_iso_8601": "2021-02-08T14:21:19.088921Z",
        "url": "https://files.pythonhosted.org/packages/fd/9b/ef15dd2f9807c637dc3a6becb9aa52711e2a63541e64a31cb097384723d6/quantastica_qps_api-0.9.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "594e08d20091a45d26b55357be9dccf871264c9ff159edd0b7c2403d4d20a113",
          "md5": "4068327b569c611fcd269feb47a20558",
          "sha256": "65b51ce1b5f81be95619a0934f9a43522d0bd612e33495efe546fbec856603ac"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.1.tar.gz",
        "has_sig": false,
        "md5_digest": "4068327b569c611fcd269feb47a20558",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18253,
        "upload_time": "2021-02-08T14:21:20",
        "upload_time_iso_8601": "2021-02-08T14:21:20.952476Z",
        "url": "https://files.pythonhosted.org/packages/59/4e/08d20091a45d26b55357be9dccf871264c9ff159edd0b7c2403d4d20a113/quantastica-qps-api-0.9.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c838391b3402ccf62000d2f82d6b093d63499b60fe973be860ea9407419f7b9e",
          "md5": "46bc96762102a734ffd8973a7877e1b9",
          "sha256": "3c68b55ae629f95b9c1c15e68843d497d01e170753926f30b248ab1736c42a96"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "46bc96762102a734ffd8973a7877e1b9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 14377,
        "upload_time": "2021-07-25T23:32:52",
        "upload_time_iso_8601": "2021-07-25T23:32:52.683634Z",
        "url": "https://files.pythonhosted.org/packages/c8/38/391b3402ccf62000d2f82d6b093d63499b60fe973be860ea9407419f7b9e/quantastica_qps_api-0.9.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0f6f245cf7b0bf72021d5106671e250646394bb4b0d6735d683a0af46ba7e2b1",
          "md5": "9f7ca160bc264d60d0c9d590a780915e",
          "sha256": "32f673285c388ad243bcbaf9410781f824103cd2fa6dfff663dae2eec8d8aece"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.3.tar.gz",
        "has_sig": false,
        "md5_digest": "9f7ca160bc264d60d0c9d590a780915e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18059,
        "upload_time": "2021-07-25T23:32:54",
        "upload_time_iso_8601": "2021-07-25T23:32:54.909751Z",
        "url": "https://files.pythonhosted.org/packages/0f/6f/245cf7b0bf72021d5106671e250646394bb4b0d6735d683a0af46ba7e2b1/quantastica-qps-api-0.9.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e4551f3ad349775b358f8edaa3cc0939e8ff7389862f345653ed8e518bd5343d",
          "md5": "7adbd1fce6b01bc441cb235387bcf088",
          "sha256": "47f9b6cb80d1b337a5355d66531a7ec25ebba21c101f6d21d58f3dce59da1e07"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7adbd1fce6b01bc441cb235387bcf088",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 14819,
        "upload_time": "2021-07-26T09:12:49",
        "upload_time_iso_8601": "2021-07-26T09:12:49.124804Z",
        "url": "https://files.pythonhosted.org/packages/e4/55/1f3ad349775b358f8edaa3cc0939e8ff7389862f345653ed8e518bd5343d/quantastica_qps_api-0.9.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "db20747c91770048264fe7ea2b4721dd4d1a7fcafbc0be0a3cc2a071c24a1776",
          "md5": "dec2aca2b0c6fe15368ebcdd95db4340",
          "sha256": "7a018ff47e5f22b5c0b8bce4f5fa601bba65cb1a81b0fdffe4fb9fab0fe176c5"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.4.tar.gz",
        "has_sig": false,
        "md5_digest": "dec2aca2b0c6fe15368ebcdd95db4340",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18777,
        "upload_time": "2021-07-26T09:12:51",
        "upload_time_iso_8601": "2021-07-26T09:12:51.050817Z",
        "url": "https://files.pythonhosted.org/packages/db/20/747c91770048264fe7ea2b4721dd4d1a7fcafbc0be0a3cc2a071c24a1776/quantastica-qps-api-0.9.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ca0a63303851f499a5b4e4acbc7a3ce0ebeb2771b8cabffa3c6937544d1dd0ad",
          "md5": "56b353a534d1278223925029cb44b876",
          "sha256": "9d4a02a0880b6712162708f05a63e93c66193df5bad6568153c3281461732e82"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "56b353a534d1278223925029cb44b876",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 14967,
        "upload_time": "2021-07-28T22:20:17",
        "upload_time_iso_8601": "2021-07-28T22:20:17.113491Z",
        "url": "https://files.pythonhosted.org/packages/ca/0a/63303851f499a5b4e4acbc7a3ce0ebeb2771b8cabffa3c6937544d1dd0ad/quantastica_qps_api-0.9.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4467a0c2b5c3bdfce4e12415e2f3ed4b57fe36fff688f2e3e290be039d952b85",
          "md5": "250bc5f27cf105de98439b7d03ee6459",
          "sha256": "30ce6df13206e58ddaefe347af15f62f769af4859381c8edb32afcc88dba06fd"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.5.tar.gz",
        "has_sig": false,
        "md5_digest": "250bc5f27cf105de98439b7d03ee6459",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18958,
        "upload_time": "2021-07-28T22:20:20",
        "upload_time_iso_8601": "2021-07-28T22:20:20.016664Z",
        "url": "https://files.pythonhosted.org/packages/44/67/a0c2b5c3bdfce4e12415e2f3ed4b57fe36fff688f2e3e290be039d952b85/quantastica-qps-api-0.9.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "805aabf670331212e8fcdad3f6aa205c51b5f29fccafb15727dc3a9fd2058ab3",
          "md5": "c5c92e04da15ea4be874f31119ce810c",
          "sha256": "cb33bd2b7edbc561c9492c23d0633967d3534f7f052e01b7c0e923e0360cbe3e"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c5c92e04da15ea4be874f31119ce810c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 15157,
        "upload_time": "2021-08-19T06:13:30",
        "upload_time_iso_8601": "2021-08-19T06:13:30.001078Z",
        "url": "https://files.pythonhosted.org/packages/80/5a/abf670331212e8fcdad3f6aa205c51b5f29fccafb15727dc3a9fd2058ab3/quantastica_qps_api-0.9.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d3978645b2eb7f4d77560a8313fd15c9296b67691304575a50c12e0ff7c13a08",
          "md5": "0ca7c972d4d7810dc8557322f827cbee",
          "sha256": "a82fa6c86717bbc7613b128b0044f50f538830e077025862c9c0a6310c7801ec"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.6.tar.gz",
        "has_sig": false,
        "md5_digest": "0ca7c972d4d7810dc8557322f827cbee",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 19269,
        "upload_time": "2021-08-19T06:13:32",
        "upload_time_iso_8601": "2021-08-19T06:13:32.623579Z",
        "url": "https://files.pythonhosted.org/packages/d3/97/8645b2eb7f4d77560a8313fd15c9296b67691304575a50c12e0ff7c13a08/quantastica-qps-api-0.9.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "35710f569656b25026e2e924723c9d133e487109a230213e164128d3a61fd0c8",
          "md5": "7fc87b6079ddc3decb6e07369b750edd",
          "sha256": "c03647a9a21081004ca1267f257b245e4bfe8a319335f032baedc96605d75ede"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7fc87b6079ddc3decb6e07369b750edd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 16085,
        "upload_time": "2021-12-29T12:18:33",
        "upload_time_iso_8601": "2021-12-29T12:18:33.971059Z",
        "url": "https://files.pythonhosted.org/packages/35/71/0f569656b25026e2e924723c9d133e487109a230213e164128d3a61fd0c8/quantastica_qps_api-0.9.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "419ef59e6a27b93905be5172fe994c3d60ae745db78ded7c531264af0ad464da",
          "md5": "9d93383d1a644915cb183b41f1c5de9d",
          "sha256": "0246278a9ecc07efc10bac3a823408d5aa57434d0ad8230b4bad582e6516957d"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.7.tar.gz",
        "has_sig": false,
        "md5_digest": "9d93383d1a644915cb183b41f1c5de9d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 26382,
        "upload_time": "2021-12-29T12:18:36",
        "upload_time_iso_8601": "2021-12-29T12:18:36.358881Z",
        "url": "https://files.pythonhosted.org/packages/41/9e/f59e6a27b93905be5172fe994c3d60ae745db78ded7c531264af0ad464da/quantastica-qps-api-0.9.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e78689f1b2fdab100ccf12e4f4c183d14a1327226e0d23ec9ea6f4809b5dfc85",
          "md5": "a895c04d2f049bfe71062bad5e5c9895",
          "sha256": "d96390d6c85a3f9bb8d4bf16a41008a23e9c8833ddf76961e11b5c1551ddc2a7"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a895c04d2f049bfe71062bad5e5c9895",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 16800,
        "upload_time": "2023-03-17T00:47:42",
        "upload_time_iso_8601": "2023-03-17T00:47:42.198976Z",
        "url": "https://files.pythonhosted.org/packages/e7/86/89f1b2fdab100ccf12e4f4c183d14a1327226e0d23ec9ea6f4809b5dfc85/quantastica_qps_api-0.9.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0571032d761387c87fecb9fb5648863536bf2de25d14c3265a6f660a99db1836",
          "md5": "48cbbba06232eeeb93ccfe60c82c7710",
          "sha256": "05a04587031e5fef310d11cbe4ca769e36a9172a4aa142181493fb359de3b211"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.8.tar.gz",
        "has_sig": false,
        "md5_digest": "48cbbba06232eeeb93ccfe60c82c7710",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 27575,
        "upload_time": "2023-03-17T00:47:44",
        "upload_time_iso_8601": "2023-03-17T00:47:44.905651Z",
        "url": "https://files.pythonhosted.org/packages/05/71/032d761387c87fecb9fb5648863536bf2de25d14c3265a6f660a99db1836/quantastica-qps-api-0.9.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fd879d08d48c9c4d001b4ac1448b8382dbecc3278df03746040a17f2f028a3ec",
          "md5": "b7bfc8077cf8deddc46aad46491c3e32",
          "sha256": "0d97c74504693f364c76b7a6d924b56c03ecf6b8aac300ef4b8aa0b0e0251793"
        },
        "downloads": -1,
        "filename": "quantastica_qps_api-0.9.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b7bfc8077cf8deddc46aad46491c3e32",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 16817,
        "upload_time": "2023-03-18T22:50:12",
        "upload_time_iso_8601": "2023-03-18T22:50:12.026322Z",
        "url": "https://files.pythonhosted.org/packages/fd/87/9d08d48c9c4d001b4ac1448b8382dbecc3278df03746040a17f2f028a3ec/quantastica_qps_api-0.9.9-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2efa3d77c59dcb502536811933e182c9a14eeb20d12e91b3318d33e304392ac5",
          "md5": "4b8a76848117a1f92404ae98bf5a7398",
          "sha256": "4d69e54993651d9629ba07d843672409501a5e801337d3984a826d8596503bc8"
        },
        "downloads": -1,
        "filename": "quantastica-qps-api-0.9.9.tar.gz",
        "has_sig": false,
        "md5_digest": "4b8a76848117a1f92404ae98bf5a7398",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 27613,
        "upload_time": "2023-03-18T22:50:14",
        "upload_time_iso_8601": "2023-03-18T22:50:14.790006Z",
        "url": "https://files.pythonhosted.org/packages/2e/fa/3d77c59dcb502536811933e182c9a14eeb20d12e91b3318d33e304392ac5/quantastica-qps-api-0.9.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "fd879d08d48c9c4d001b4ac1448b8382dbecc3278df03746040a17f2f028a3ec",
        "md5": "b7bfc8077cf8deddc46aad46491c3e32",
        "sha256": "0d97c74504693f364c76b7a6d924b56c03ecf6b8aac300ef4b8aa0b0e0251793"
      },
      "downloads": -1,
      "filename": "quantastica_qps_api-0.9.9-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "b7bfc8077cf8deddc46aad46491c3e32",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 16817,
      "upload_time": "2023-03-18T22:50:12",
      "upload_time_iso_8601": "2023-03-18T22:50:12.026322Z",
      "url": "https://files.pythonhosted.org/packages/fd/87/9d08d48c9c4d001b4ac1448b8382dbecc3278df03746040a17f2f028a3ec/quantastica_qps_api-0.9.9-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "2efa3d77c59dcb502536811933e182c9a14eeb20d12e91b3318d33e304392ac5",
        "md5": "4b8a76848117a1f92404ae98bf5a7398",
        "sha256": "4d69e54993651d9629ba07d843672409501a5e801337d3984a826d8596503bc8"
      },
      "downloads": -1,
      "filename": "quantastica-qps-api-0.9.9.tar.gz",
      "has_sig": false,
      "md5_digest": "4b8a76848117a1f92404ae98bf5a7398",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 27613,
      "upload_time": "2023-03-18T22:50:14",
      "upload_time_iso_8601": "2023-03-18T22:50:14.790006Z",
      "url": "https://files.pythonhosted.org/packages/2e/fa/3d77c59dcb502536811933e182c9a14eeb20d12e91b3318d33e304392ac5/quantastica-qps-api-0.9.9.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}