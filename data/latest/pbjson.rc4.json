{
  "info": {
    "author": "Scott Maxwell",
    "author_email": "scott@codecobblers.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Academic Free License (AFL)",
      "License :: OSI Approved :: MIT License",
      "Programming Language :: Python",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.3",
      "Programming Language :: Python :: 3.4",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: Implementation :: CPython",
      "Programming Language :: Python :: Implementation :: PyPy",
      "Topic :: Software Development :: Libraries :: Python Modules"
    ],
    "description": "pbjson\n======\n\nPacked Binary JSON extension for Python\n\n``pbjson`` is a packed binary JSON encoder and decoder for Python 2.5+\nand Python 3.3+. It is pure Python code with no dependencies, but\nincludes an optional C extension for a serious speed boost.\n\n``pbjson`` can be used standalone or as an extension to the standard\n``json`` module or to ``simplejson``, from which code was heavily\nborrowed. The latest documentation for ``simplejson`` can be read online\nhere: http://simplejson.readthedocs.org/\n\nThe encoder can be specialized to provide serialization in any kind of\nsituation, without any special support by the objects to be serialized\n(somewhat like pickle). This is best done with the ``default`` kwarg to\ndumps.\n\nThe decoder can handle incoming JSON strings of any specified encoding\n(UTF-8 by default). It can also be specialized to post-process JSON\nobjects with the ``object_hook`` or ``object_pairs_hook`` kwargs. This\nis particularly useful for implementing protocols that have a richer\ntype system than JSON itself.\n\nWhat is Packed Binary JSON (``PBJSON``)\n---------------------------------------\n\nPacked Binary JSON is not the same as ``BSON``. ``BSON`` is a format\nused primarily in MongoDB and is meant for efficient parsing. ``PBJSON``\nis meant for efficient conversion from a dict or list, transmission and\nconversion back to a dict or list on the other end. ``BSON`` has\nexplicit support for several types not available in standard JSON.\nPBJSON supports only those types supported by normal JSON, plus binary\ndata blobs and set collections.\n\nUnlike ``BSON``, ``PBJSON`` is almost always smaller than the equivalent\nJSON. Like ``BSON``, ``PBJSON`` can be very quickly encoded and decoded\nsince all elements are length encoded.\n\nThere are two types of tokens in ``PBJSON``: data and key. Data tokens\ncan be zero length fundamental types (``false``, ``true``, ``null``),\nvariable length fundamental types (``int``, ``float``, ``string``,\n``binary``) or containers (``set``, ``array``, ``dict``).\n\nThe type for the data token is generally stored in the top 3 bits (bits\n5-7). Type zero is a special type to represent the zero length\nfundamental types. The lower bits indicate the actual value. These are:\n\nZero-length Data Types:\n\n-  00 - false\n-  01 - true\n-  02 - null\n\nAll other types are variable length. If the length is between 0 and 15,\nthat length is stored in bits 0-3. For lengths in the 16-2047 range, bit\n4 is set and bits 0-2 are combined with the next byte to make an 11-bit\nlength. If bits 4 and 3 are both set, then the value in bits 0-2 are\ncombined with the next 2 bytes to create a 19-bit length. However, if\nbits 4-0 are all set, this indicates that the following 4 bytes are\nsimply used as a size. So the token plus length is, one byte (length of\n0-15), two bytes (16-2047), three bytes (2048-458751) or five bytes\n(458876-4294967295).\n\nVariable-length Data types:\n\n-  2x - int (bytes stored big endian with leading zero bytes removed)\n-  4x - negative int (bytes stored big endian as a positive number with\n   leading zero bytes removed)\n-  6x - float (stored as big endian double precision with trailing zero\n   bytes removed)\n-  8x - string\n-  Ax - binary\n\nCollection types: (length is number of elements)\n\n-  Cx - array\n-  Ex - object\n-  0C - terminated array\n-  0F - terminator\n\nThe final entry, the \"terminated array\" works a bit differently. This is\nfor use when the length is not known when writing begins. Instead, a\nterminator (0F) is written to the stream when the last element of the\narray has been written.\n\nObject keys must be text and are a maximum of 127 bytes in length. They\nare stored as a (7-bit length, followed by the actual key. The first 128\nkeys are remembered by index. If the same key is used again, it can be\nrepresented as a single byte consisting of the high bit and the index\nnumber of the key.\n\nIn other words, if the recurring key is \"toast\", it should be encoded as\n05 toast. The next time the key \"toast\" is needed, it can be encoded as\nsimply 80, since it was the first key.\n\nHere is an example of a simple structure:\n\n.. code:: javascript\n\n   {\n       \"toast\": true,\n       \"burned\": false,\n       \"name\": \"the best\",\n       \"toppings\": [\"jelly\",\"jam\",\"butter\"],\n       \"dimensions\": {\n           \"thickness\": 0.7,\n           \"width\": 4.5\n       }\n   }\n\n::\n\n   E5 05 'toast' 01 06 'burned' 00 04 'name' 88 'the best'\n   08 'toppings' C3 85 'jelly' 83 'jam' 86 'butter'\n   0A 'dimensions' E2 09 'thickness' 68 3FE6666666666666 05 'width' 62 4012\n\nLet’s break that out:\n\n-  00: E5 - dict with 5 elements\n-  01: 05 - key with 5 characters\n-  02-06: toast\n-  07: 01 - true\n-  08: 06 - key with 6 characters\n-  09-0E: burned\n-  0F: 00 - false\n-  10: 04 - key with 4 characters\n-  11-14: name\n-  15: 88 - string with 8 characters\n-  16-1D: the best\n-  1E: 08 - key with 8 bytes\n-  1F-26: toppings\n-  27: C3 - array with 3 elements\n-  28: 85 - string with 5 characters\n-  29-2D: jelly\n-  2E: 83 - string with 3 characters\n-  2F-31: jam\n-  32: 86 - string with 6 characters\n-  33-38: butter\n-  39: 0A - key with 10 bytes\n-  3A-43: dimensions\n-  44: E3 - dict with 2 elements\n-  45: 09 - key with 9 characters\n-  46-4E: thickness\n-  4F: 68 - float with 8 bytes\n-  50-57: IEEE representation of .7\n-  58: 05 - key with 5 characters\n-  59-5D: width\n-  5E: 62 - float with 2 bytes\n-  5F-60: first 2 bytes of IEEE representation of 4.5. Remaining 6 bytes\n   were all zeros.\n\nTotal 97 bytes. The tightest ``JSON`` representation requires 126 bytes.\nMarshal takes 153 bytes. Pickle takes 184 bytes. BSON takes 145 bytes.\n\nNow here is an example with repeating data:\n\n.. code:: javascript\n\n   {\n       \"region\": 3,\n       \"countries\": [\n           {\"code\": \"us\", \"name\": \"United States\"},\n           {\"code\": \"ca\", \"name\": \"Canada\"},\n           {\"code\": \"mx\", \"name\": \"Mexico\"}\n       ]\n   }\n\n::\n\n   E2 06 region 21 03 09 countries C3\n   E2 04 code 82 us 04 name 8D United States\n   E2 82 82 ca 83 86 Canada\n   E2 82 82 mx 83 86 Mexico\n\nThis breaks down thus:\n\n-  00: E2 - dict with 2 elements\n-  01: 06 - key with 6 characters\n-  02-07: region\n-  08: 21 - int with 1 byte\n-  09: 03 - the int for 3. Only a single byte is required.\n-  0A: 09 - key with 9 bytes\n-  0B-13: countries\n-  14: C3 - array with 3 elements\n-  15: E2 - dict with 2 elements\n-  16: 04 - key with 4 characters\n-  17-1A: code\n-  19: 82 - string with 2 characters\n-  1A-1B: us\n-  1C: 04 - key with 4 characters\n-  1E-21: name\n-  22: 8D - string with 13 characters\n-  23-2F: United States\n-  30: E2 - dict with 2 elements\n-  31: 82 - recurring key 2. Since ‘code’ was the 3rd key, it has an\n   index of 2.\n-  32: 82 - string with 2 characters\n-  33-34: ca\n-  35: 83 - recurring key 3\n-  36: 86 - string with 6 characters\n-  37-3C: Canada\n-  3D: E2 - dict with 2 elements\n-  3E: 82 - recurring key 0\n-  3F: 82 - string with 2 characters\n-  40-41: mx\n-  42: 83 - recurring key 1\n-  43: 86 - string with 6 characters\n-  44-49: Mexico\n\nTotal 74 bytes. The tightest ``JSON`` representation requires 123 bytes.\nMarshal takes 158 bytes and Pickle takes 162. BSON takes 154 bytes.\n\n``Packed Binary JSON`` is available now in the ``pbjson`` Python module.\nThat module includes a command line utility to convert between normal\n``JSON`` files and ``PBJSON``.",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/scottkmaxwell/pbjson",
    "keywords": "",
    "license": "MIT License",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pbjson",
    "package_url": "https://pypi.org/project/pbjson/",
    "platform": "any",
    "project_url": "https://pypi.org/project/pbjson/",
    "project_urls": {
      "Homepage": "https://github.com/scottkmaxwell/pbjson"
    },
    "release_url": "https://pypi.org/project/pbjson/1.15/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Packed Binary JSON encoder/decoder for Python",
    "version": "1.15",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 5204703,
  "releases": {
    "1.12": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d93b3e2e103472c5ba57b7c694461bb3066c4230ab1d4ae90816472b32e03e31",
          "md5": "e4934642f846e48bcf668e709d5d193d",
          "sha256": "de636888b677ad4fa075ca907c94bf5b9825458ea2e769ea2d7bfc187e84e71f"
        },
        "downloads": -1,
        "filename": "pbjson-1.12.tar.gz",
        "has_sig": false,
        "md5_digest": "e4934642f846e48bcf668e709d5d193d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38122,
        "upload_time": "2019-04-29T17:11:52",
        "upload_time_iso_8601": "2019-04-29T17:11:52.095076Z",
        "url": "https://files.pythonhosted.org/packages/d9/3b/3e2e103472c5ba57b7c694461bb3066c4230ab1d4ae90816472b32e03e31/pbjson-1.12.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.13": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9f59efd7668c60df21d25acba05b5d510d7cc2d4c97b13dbd35bdfac19418b3a",
          "md5": "a3aed4c30ede2a139e67173d57253000",
          "sha256": "c8b163f9cd2662dc40d55c64ee48753128ec97ab8c56c46718ba8cbcfa4dae95"
        },
        "downloads": -1,
        "filename": "pbjson-1.13.tar.gz",
        "has_sig": false,
        "md5_digest": "a3aed4c30ede2a139e67173d57253000",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39556,
        "upload_time": "2019-04-29T17:49:12",
        "upload_time_iso_8601": "2019-04-29T17:49:12.163767Z",
        "url": "https://files.pythonhosted.org/packages/9f/59/efd7668c60df21d25acba05b5d510d7cc2d4c97b13dbd35bdfac19418b3a/pbjson-1.13.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.14": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ce69cf74681c2fb485793b27f101f70a2bb249b1b556229c86c42a137858e7a0",
          "md5": "d18b108bfa64093f6cb80f052fb400a3",
          "sha256": "24936c8ee5b7b0d5559d9d38560d1a28561e57e64905f0c4b96ec55bb9f07877"
        },
        "downloads": -1,
        "filename": "pbjson-1.14.tar.gz",
        "has_sig": false,
        "md5_digest": "d18b108bfa64093f6cb80f052fb400a3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39572,
        "upload_time": "2019-04-29T17:51:40",
        "upload_time_iso_8601": "2019-04-29T17:51:40.822018Z",
        "url": "https://files.pythonhosted.org/packages/ce/69/cf74681c2fb485793b27f101f70a2bb249b1b556229c86c42a137858e7a0/pbjson-1.14.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.15": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a9faa301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb",
          "md5": "e26626df18806ed7e82af76c6142f08c",
          "sha256": "eb9c239afd8cc2465ed2a04074e0fd71fb9380815b83a402ed71442549c0982f"
        },
        "downloads": -1,
        "filename": "pbjson-1.15.tar.gz",
        "has_sig": false,
        "md5_digest": "e26626df18806ed7e82af76c6142f08c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 39540,
        "upload_time": "2019-04-29T19:53:39",
        "upload_time_iso_8601": "2019-04-29T19:53:39.454546Z",
        "url": "https://files.pythonhosted.org/packages/a9/fa/a301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb/pbjson-1.15.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a9faa301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb",
        "md5": "e26626df18806ed7e82af76c6142f08c",
        "sha256": "eb9c239afd8cc2465ed2a04074e0fd71fb9380815b83a402ed71442549c0982f"
      },
      "downloads": -1,
      "filename": "pbjson-1.15.tar.gz",
      "has_sig": false,
      "md5_digest": "e26626df18806ed7e82af76c6142f08c",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 39540,
      "upload_time": "2019-04-29T19:53:39",
      "upload_time_iso_8601": "2019-04-29T19:53:39.454546Z",
      "url": "https://files.pythonhosted.org/packages/a9/fa/a301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb/pbjson-1.15.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}