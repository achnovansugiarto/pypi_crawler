{
  "info": {
    "author": "Mazlum TOSUN",
    "author_email": "mazlum.tosun@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "![Logo](asgarde_logo_small.gif)\n\n# Asgarde\n\nThis module allows simplifying error handling with Apache Beam Python.\n\n## Versions compatibility between Beam and Asgarde\n\n| Asgarde      | Beam |\n| -----------  | ----------- |\n| 0.16.0       | \\>= 2.37.0   |\n\n## Installation of project\n\nThe project is hosted on PyPi repository.\\\nYou can install it with all the build tools compatibles with PyPi and pip.\n\n#### PyPi\n\n##### Example with pip command line from bash\n\n```bash\npip install asgarde==0.16.0\n```\n\n##### Example with requirements.txt\n\nrequirements.txt file\n\n```text\nasgarde==0.16.0\n```\n\n```bash\npip install -r requirements.txt\n```\n\n##### Example with Pipenv\n\nPipFile\n\n```text\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\nasgarde = \"==0.16.0\"\n\n[requires]\npython_version = \"3.8\"\n```\n\n```bash\npipenv shell\n\npipenv install\n```\n\n- pipenv shell creates a virtual env \n- `pipenv install` installs all the packages specified in the Pipfile\n- A PipFile.lock is generated with a hash on installed packages\n\nhttps://pipenv.pypa.io/en/latest/\n\n\n## Example of native error handling with Beam\n\nThe following example shows error handling in each step with usual Beam code.\n\n```python\n@dataclass\nclass TeamInfo:\n    name: str\n    country: str\n    city: str\n\n@dataclass\nclass Failure:\n    pipeline_step: str\n    input_element: str\n    exception: Exception\n\nteam_names = [\n    'PSG',\n    'OL',\n    'Real',\n    'ManU'\n]\n\nteam_countries = {\n    'PSG': 'France',\n    'OL': 'France',\n    'Real': 'Spain',\n    'ManU': 'England'\n}\n\nteam_cities = {\n    'PSG': 'Paris',\n    'OL': 'France',\n    'Real': 'Madrid',\n    'ManU': 'Manchester'\n}\n\nclass MapToTeamWithCountry(DoFn):\n\n    def process(self, element, *args, **kwargs):\n        try:\n            team_name: str = element\n\n            yield TeamInfo(\n                name=team_name,\n                country=team_countries[team_name],\n                city=''\n            )\n        except Exception as err:\n            failure = Failure(\n                pipeline_step=\"Map 1\",\n                input_element=element,\n                exception=err\n            )\n\n            yield pvalue.TaggedOutput(FAILURES, failure)\n\n\nclass MapToTeamWithCity(DoFn):\n\n    def process(self, element, *args, **kwargs):\n        try:\n            team_info: TeamInfo = element\n            city: str = team_cities[team_info.name]\n\n            yield TeamInfo(\n                name=team_info.name,\n                country=team_info.country,\n                city=city\n            )\n        except Exception as err:\n            failure = Failure(\n                pipeline_step=\"Map 2\",\n                input_element=element,\n                exception=err\n            )\n\n            yield pvalue.TaggedOutput(FAILURES, failure)\n\n\nclass FilterFranceTeams(DoFn):\n\n    def process(self, element, *args, **kwargs):\n        try:\n            team_info: TeamInfo = element\n\n            if team_info.country == 'France':\n                yield element\n        except Exception as err:\n            failure = Failure(\n                pipeline_step=\"Filter France teams\",\n                input_element=element,\n                exception=err\n            )\n\n            yield pvalue.TaggedOutput(FAILURES, failure)\n\n# In Beam pipeline.\ninput_teams: PCollection[str] = p | 'Read' >> beam.Create(team_names)\n\noutputs_map1, failures_map1 = (input_teams | 'Map to team with country' >> ParDo(MapToTeamWithCountry())\n                               .with_outputs(FAILURES, main='outputs'))\n\noutputs_map2, failures_map2 = (outputs_map1 | 'Map to team with city' >> ParDo(MapToTeamWithCity())\n                               .with_outputs(FAILURES, main='outputs'))\n\noutputs_filter, failures_filter = (outputs_map2 | 'Filter France teams' >> ParDo(FilterFranceTeams())\n                                   .with_outputs(FAILURES, main='outputs'))\n\nall_failures = (failures_map1, failures_map2, failures_filter) | 'All Failures PCollections' >> beam.Flatten()\n```\n\nThis example starts with an input `PCollection` containing team names.\\\nThen 3 operations and steps are applied : 2 maps and 1 filter.\n\nFor each operation a custom `DoFn` class is proposed and must override `process` function containing the \ntransformation logic.\\\nA `try except bloc` is added to catch all the possible errors.\\\nIn the `Except` bloc a `Failure` object is built with input element and current exception. This object is then added on \na `tuple tag` dedicated to errors.\\\nThis `tag` mechanism allows having multi sink in the pipeline and a dead letter queue for failures.\n\nThere are some inconveniences : \n- We have to repeat many technical codes and same logic like `try except bloc`, `tuple tags`, \n`failure logic` and all this logic can be centralized.\n- If we want to intercept all the possible errors in the pipeline, we have to repeat the recovery of output and failure in each step.\n- All the failures `PCollection` must be concatenated at end.\n- The code is verbose.\n\nThe repetition of technical codes is error-prone and less maintainable.\n\n\n## Example of error handling using Asgarde library\n\n```python\n# Beam pipeline with Asgarde library.\ninput_teams: PCollection[str] = p | 'Read' >> beam.Create(team_names)\n\nresult = (CollectionComposer.of(input_teams)\n            .map('Map with country', lambda tname: TeamInfo(name=tname, country=team_countries[tname], city=''))\n            .map('Map with city', lambda tinfo: TeamInfo(name=tinfo.name, country=tinfo.country, city=team_cities[tinfo.name]))\n            .filter('Filter french team', lambda tinfo: tinfo.country == 'France'))\n\nresult_outputs: PCollection[TeamInfo] = result.outputs\nresult_failures: PCollection[Failure] = result.failures\n```\n\n### CollectionComposer class\n\nAsgarde proposes a `CollectionComposer` wrapper class instantiated from a `PCollection`.\n\n### Operators exposed by CollectionComposer class\n\nThe `CollectionComposer` class exposes the following operators : `map`, `flatMap` and `filter`.\n\nThese classical operators takes a function, the implementation can be : \n- A `lambda expression`\n- A `method` having the same signature of the expected `function`\n\n### Failure object exposed by Asgarde\n\nBehind the scene, for each step the `CollectionComposer` class adds `try except` bloc and `tuple tag logic` with output\nand failure `sinks`.\n\nThe bad sink is based on a `Failure` object proposed by the library : \n\n```python\n@dataclass\nclass Failure:\n    pipeline_step: str\n    input_element: str\n    exception: Exception\n```\n\nThis object contains the current pipeline step name, input element with string form and current exception.\n\nInput element on Failure object are built following these rules :\n- If the current element in the `PCollection` is a `dict`, the Json string form of this `dict` is retrieved\n- For all others types, the `string` form of object is retrieved. If developers want to bring their own serialization\nlogic, they have to override `__str__` method in the object, example for a `dataclass` : \n\n```python\nimport dataclasses\nimport json\nfrom dataclasses import dataclass\n\n@dataclass\nclass Team:\n    name: str\n\n    def __str__(self) -> str:\n        return json.dumps(dataclasses.asdict(self))\n```\n\n### Result of CollectionComposer flow\n\nThe `CollectionComposer` class after applying and chaining different operations, returns a `tuple` with : \n- Output `PCollection`\n- Failures `PCollection`\n\n```python\nresult = (CollectionComposer.of(input_teams)\n            .map('Map with country', lambda tname: TeamInfo(name=tname, country=team_countries[tname], city=''))\n            .map('Map with city', lambda tinfo: TeamInfo(name=tinfo.name, country=tinfo.country, city=team_cities[tinfo.name]))\n            .filter('Filter french team', lambda tinfo: tinfo.country == 'France'))\n\nresult_outputs: PCollection[TeamInfo] = result.outputs\nresult_failures: PCollection[Failure] = result.failures\n```\n\n### Example of a flow with side inputs\n\n`Asgarde` allows applying transformations with error handling and passing `side inputs`.\\\nThe syntax is the same as usual Beam pipeline with `AsDict` or `AsList` passed as function parameters.\n\n```python\ndef to_team_with_city(self, team_name: str, team_countries: Dict[str, str]) -> TeamInfo:\n    return TeamInfo(name=team_name, country=team_countries[team_name], city='')\n\nteam_countries = {\n    'PSG': 'France',\n    'OL': 'France',\n    'Real': 'Spain',\n    'ManU': 'England'\n}\n\n# Side inputs.\ncountries_side_inputs = p | 'Countries' >> beam.Create(team_countries)\n\n# Beam Pipeline.\nresult = (CollectionComposer.of(input_teams)\n            .map('Map with country', self.to_team_with_city, team_countries=AsDict(countries_side_inputs))\n            .map('Map with city', lambda ti: TeamInfo(name=ti.name, country=ti.country, city=team_cities[ti.name]))\n            .filter('Filter french team', lambda ti: ti.country == 'France'))\n\nresult_outputs: PCollection[str] = result.outputs\nresult_failures: PCollection[Failure] = result.failures\n```\n\n### Asgarde and error handling with Beam DoFn lifecyle\n\n`Asgarde` allows interacting with `DoFn` lifecycle while chaining transformation with error handling, example : \n\n```python\n(CollectionComposer.of(input_teams)\n     .map('Map to Team info',\n          input_element_mapper=lambda team_name: TeamInfo(name=team_name, country='test', city='test'),\n          setup_action=lambda: print('Setup action'),\n          start_bundle_action=lambda: print('Start bundle action'),\n          finish_bundle_action=lambda: print('Finish bundle action'),\n          teardown_action=lambda: print('Teardown action'))\n     )\n```\n\nThe `map` and `flat_map` methods of `CollectionComposer` class propose the following functions to interact with \n`DoFn` lifecycle :\n- setup_action\n- start_bundle_action\n- finish_bundle_action\n- teardown_action\n\nThese functions take a `function` without input parameter and return `None`, it corresponds to an action executed \nin the dedicated lifecycle method : \n\nhttps://beam.apache.org/documentation/transforms/python/elementwise/pardo/\n\n### Advantage of using Asgarde\n\n`Asgarde` presents the following advantages :\n- Simplifies error handling with less code and more expressive and concise code\n- No need to repeat same technical code for error handling like `try except` bloc, `tuple tags` and concatenation of all the pipeline failures\n- Allows interacting with Beam lifecycle while chaining the transformation and error handling\n\n\n\n\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/tosun-si/pasgarde",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "asgarde",
    "package_url": "https://pypi.org/project/asgarde/",
    "platform": null,
    "project_url": "https://pypi.org/project/asgarde/",
    "project_urls": {
      "Homepage": "https://github.com/tosun-si/pasgarde"
    },
    "release_url": "https://pypi.org/project/asgarde/0.16.0/",
    "requires_dist": null,
    "requires_python": ">=3.6.10",
    "summary": "Allows simplifying error handling with Apache Beam",
    "version": "0.16.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14211377,
  "releases": {
    "0.16.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6f21dc0bd3fdc4b82f781c91d1408e2692e5adbc02ed94a860cb8128c55d824d",
          "md5": "a8e3908a409a2d989b8d404f46172de6",
          "sha256": "549079a2762eb57b6a8e4482dd066c4a71da491687f34a9f9da592ce9f2c75ea"
        },
        "downloads": -1,
        "filename": "asgarde-0.16.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a8e3908a409a2d989b8d404f46172de6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6.10",
        "size": 12100,
        "upload_time": "2022-06-22T12:34:05",
        "upload_time_iso_8601": "2022-06-22T12:34:05.032548Z",
        "url": "https://files.pythonhosted.org/packages/6f/21/dc0bd3fdc4b82f781c91d1408e2692e5adbc02ed94a860cb8128c55d824d/asgarde-0.16.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d37d45c833f26b70591708019fdd8725f1c13279e486ffe1b0576e47deac39d7",
          "md5": "bc807bd0f078fdf681c44d16114afb51",
          "sha256": "d42a475ac421bee34034689678198d11ab0dd636ffa39f09d71272c1a468c9cb"
        },
        "downloads": -1,
        "filename": "asgarde-0.16.0.tar.gz",
        "has_sig": false,
        "md5_digest": "bc807bd0f078fdf681c44d16114afb51",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6.10",
        "size": 13209,
        "upload_time": "2022-06-22T12:34:07",
        "upload_time_iso_8601": "2022-06-22T12:34:07.613122Z",
        "url": "https://files.pythonhosted.org/packages/d3/7d/45c833f26b70591708019fdd8725f1c13279e486ffe1b0576e47deac39d7/asgarde-0.16.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "6f21dc0bd3fdc4b82f781c91d1408e2692e5adbc02ed94a860cb8128c55d824d",
        "md5": "a8e3908a409a2d989b8d404f46172de6",
        "sha256": "549079a2762eb57b6a8e4482dd066c4a71da491687f34a9f9da592ce9f2c75ea"
      },
      "downloads": -1,
      "filename": "asgarde-0.16.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "a8e3908a409a2d989b8d404f46172de6",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6.10",
      "size": 12100,
      "upload_time": "2022-06-22T12:34:05",
      "upload_time_iso_8601": "2022-06-22T12:34:05.032548Z",
      "url": "https://files.pythonhosted.org/packages/6f/21/dc0bd3fdc4b82f781c91d1408e2692e5adbc02ed94a860cb8128c55d824d/asgarde-0.16.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "d37d45c833f26b70591708019fdd8725f1c13279e486ffe1b0576e47deac39d7",
        "md5": "bc807bd0f078fdf681c44d16114afb51",
        "sha256": "d42a475ac421bee34034689678198d11ab0dd636ffa39f09d71272c1a468c9cb"
      },
      "downloads": -1,
      "filename": "asgarde-0.16.0.tar.gz",
      "has_sig": false,
      "md5_digest": "bc807bd0f078fdf681c44d16114afb51",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6.10",
      "size": 13209,
      "upload_time": "2022-06-22T12:34:07",
      "upload_time_iso_8601": "2022-06-22T12:34:07.613122Z",
      "url": "https://files.pythonhosted.org/packages/d3/7d/45c833f26b70591708019fdd8725f1c13279e486ffe1b0576e47deac39d7/asgarde-0.16.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}