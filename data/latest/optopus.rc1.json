{
  "info": {
    "author": "Monty Hindman",
    "author_email": "mhindman@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 3 - Alpha",
      "Environment :: Console",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Software Development"
    ],
    "description": "\n# Optopus\n\n## Because Python needs a better command-line argument parser\n\nTo varying degrees of success, command-line argument parsing libraries do a\nmostly adequate job handling the common use cases. They are able to parse\ngarden-variety command-line inputs and provide help text to end users. Some\nlibraries take partial steps to support a larger set of features: basic\nconversion and validation; varying numbers of optional parameters or positional\narguments; mutually exclusive options; subcommand-style programs like git; and\noccasionally a small amount of help text customization or the ability to\ncontrol error handling.\n\nBut why settle at such low expectations? Every year thousands of command-line\nscripts are written in Python using argument parsers that are just OK: they are\nless intuitive, more verbose, and more hemmed in by restrictions than they need\nto be.\n\nOptopus will change that by providing a library that is easy and efficient to\nconfigure; powerful when needed for complex, specialized, unusual, or merely\nparticular situations; and designed with an eye toward customization and\nflexibility. At every level of program complexity — ranging from throwaway\nscripts to the next-big-thing — Optopus will offer a superior approach to\nhandling command-line arguments.\n\nThe library is under active development and a alpha release has been published.\nThe purpose of that release was mainly to reserve the project name in\n[PyPI][pypi_optopus] but it already provides one small bit of useful\nfunctionality, one not currently available in other libraries — namely,\nno-configuration parsing, which is handy for temporary or experimental scripts\nthat require nothing more than open-ended support for options and positionals.\n\n```bash\n# Install the library in the usual way.\n\n$ pip install optopus\n```\n\n```python\n# Write almost no code to parse arguments.\n\nfrom optopus import Parser\n\np = Parser()\nopts = p.parse()\n\n# Check out the returned data object.\n\nprint(opts)\nprint(opts.bar)               # Attribute access.\nprint(opts['bar'])            # Key access.\nprint('bar' in opts)          # Membership testing.\nfor dest, val in opts:        # Direct iteration.\n    print((dest, val))\n```\n\n```bash\n# Demo usage.\n\n$ python demo.py Z1 Z2 --bar B1 B2 -x -y Y1 -- Z3\nResult(positionals=['Z1', 'Z2', 'Z3'], bar=['B1', 'B2'], x=True, y='Y1')\n['B1', 'B2']\n['B1', 'B2']\nTrue\n('positionals', ['Z1', 'Z2', 'Z3'])\n('bar', ['B1', 'B2'])\n('x', True)\n('y', 'Y1')\n```\n\n## Optopus vs. the competition\n\nRather than starting with my opinions about the state of command-line argument\nparsers in Python, Ruby, and, from an earlier era, Perl, a more compelling case\ncan be made by starting with something concrete: side-by-side comparisons\nacross a spectrum of program types.\n\nI will use [argparse][py_argparse] in the comparisons, but not because it is a\nbad library. To the contrary, it is better than the vast majority of\nalternatives. Argparse is a dream to use compared to its predecessor,\n[optparse][py_optparse], and it is easier to configure than the argument parser\nbuilt into [Ruby][rb_optparse]. Basically, argparse is among the best of a\nbarely-adequate bunch.\n\n#### Example 1\n\nThe comparisons will start with a minimal script: a bare-bones grep clone that\nwill allow us to use Python regular expressions rather than whatever grep ships\nwith. Schematically, we want to handle this usage:\n\n    pgrep [-i] [-v] <rgx> <path>\n\nHere is the argparse configuration:\n\n```python\nap = argparse.ArgumentParser(prog = 'pgrep')\nap.add_argument('-i', action = 'store_true')\nap.add_argument('-v', action = 'store_true')\nap.add_argument('rgx')\nap.add_argument('path')\n```\n\nThe equivalent Optopus configuration dispenses with all of that hassle.\nInstead, it relies on the conventions that most programmers already know\nregarding command-line usage syntax — the same syntax you just read and\nunderstood a few paragraphs above. That syntax, along with a small number of\nsensible additions, will allow Optopus to reduce developer hassle significantly\nwhile also providing a more powerful and flexible argument parser. The\ndifference between the two configurations is striking.\n\n```python\np = Parser('pgrep :: [-i] [-v] <rgx> <path>')\n```\n\n#### Example 2\n\nAs a second comparison, we will take the same script and make it more\nfleshed-out with some help text and the ability to support zero or more file\npaths.\n\n```python\nap = argparse.ArgumentParser(prog = 'pgrep')\nap.add_argument('-i', '--ignore-case', action = 'store_true', help = 'Ignore case')\nap.add_argument('-v', '--invert-match', action = 'store_true', help = 'Select non-matching lines')\nap.add_argument('rgx', help = 'Python regular expression')\nap.add_argument('path', nargs = '*', help = 'Path(s) to input')\n```\n\nThe Optopus configuration is more efficient (48% the size of argparse), more\nreadable, and requires less API knowledge. You just type what you want and have\nto remember little more than a mostly already-known syntax. Note that [Example\n1](#example-1) used what Optopus calls a usage-variant syntax: it expressed the\nfull command-line grammar in schematic form. Example 2 uses a closely related\nsyntax, called opt-help syntax. Each line configures a single Opt (a\nconfiguration object representing a positional argument or option) using the\nsame syntax seen in the first example, optionally accompanied by one or more\naliases and help text. Because the opt-help syntax is more featureful at the\nlevel of individual Opts (it can declare aliases and help text), it is often\nthe easiest mechanism to use for non-trivial scripts that do not have any\nspecial grammatical needs.\n\n```python\np = Parser('''pgrep\n    <rgx> : Python regular expression\n    [<path>...] : Path(s) to input\n    [-i --ignore-case] : Ignore case\n    [-v --invert-match] : Select non-matching lines\n''')\n```\n\n#### Example 3\n\nThe next step in the script's evolution might be to add some more options,\nalong with conversion and validation of the inputs. The argparse code starts to\nget a bit heavy.\n\n```python\nap = argparse.ArgumentParser(prog = 'pgrep')\nap.add_argument('rgx', metavar = '<rgx>', type = re.compile, help = 'Python regular expression')\nap.add_argument('path', metavar = '<path>', type = pathlib.Path, nargs = '*', help = 'Path(s) to input')\nap.add_argument('--ignore-case', '-i', action = 'store_true', help = 'Ignore case')\nap.add_argument('--invert-match', '-v', action = 'store_true', help = 'Select non-matching lines')\nap.add_argument('--max-count', '-m', metavar = '<n>', type = int, help = 'Stop searching after N matches')\nap.add_argument('--context', '-C', metavar = '<n>', type = int, help = 'Print N lines of before/after context')\nap.add_argument('--color', metavar = '<col>', choices = ('red', 'green', 'blue'), help = 'Highlight matching text: red, green, blue')\n```\n\nBy comparison, the Optopus configuration remains compact (67% the size of\nargparse), intuitive, and easy to scan. If you want to spiff it up further you\ncan have your editor line everything up on the colon separators. Also notice\nthe two phases of configuration: most of the work is done in the text syntax\n(called a parser `spec`, short for specification); and then extra configuration\nis applied via a programmatic API. Notice also that the API emphasizes simple\nconveniences: if any Opts share configuration parameters (options `-m` and `-C`\nin our example), they can be handled jointly in a single `config()` call. The\nlast `config()` call is not required, but it helps to clean up the help text,\nwhich we will examine shortly. In spite of its brevity, the Optopus\nconfiguration actually does more validation (in the example, `isfile` and\n`ispositive` are assumed to be callables defined by the user).\n\n```python\np = Parser('''pgrep\n    <rgx> : Python regular expression\n    [<path>...] : Path(s) to input\n    [-i --ignore-case] : Ignore case\n    [-v --invert-match] : Select non-matching lines\n    [-m --max-count <n>] : Stop searching after N matches\n    [-C --context <n>] : Print N lines of before/after context\n    [--color red|green|blue] : Highlight matching text\n''')\n\np.config('rgx', convert = re.compile)\np.config('path', convert = pathlib.Path, validate = isfile)\np.config('m C', convert = int, validate = ispositive)\np.config(kind = 'option', sym = 'options')\n```\n\n#### Example 3 help text\n\nBefore looking at the final code comparison, we can also consider the\ndifferences in help text between the two libraries. The output from argparse is\nfamiliar and reasonable, if a bit awkward at times. It is also mildly annoying\nif you are among those who care about finer details related to capitalization,\nspacing, and overall readability.\n\n```\nusage: pgrep [-h] [--ignore-case] [--invert-match] [--max-count <n>]\n             [--context <n>] [--color <col>] <rgx> [<path> ...]\n\npositional arguments:\n  <rgx>                 Python regular expression\n  <path>                Path(s) to input\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --ignore-case, -i     Ignore case\n  --invert-match, -v    Select non-matching lines\n  --max-count <n>, -m <n>\n                        Stop searching after N matches\n  --context <n>, -C <n>\n                        Print N lines of before/after context\n  --color <col>         Highlight matching text: red, green, blue\n```\n\nThe Optopus help text is cleaner and easier to read. Those gains mostly come\nfrom a couple of alternative techniques that Optopus supports but does not\nrequire: first, the ability to flexibly summarize groups of options\nsymbolically in the usage text (as `[options]` in this example, which was done\nin the last `p.config()` call above); and second, the separation of option help\nfrom an alias listing.\n\n```\nUsage:\n  pgrep [options] <rgx> [<path>...]\n\nPositionals:\n  <rgx>                  Python regular expression\n  <path>                 Path(s) to input\n\nOptions:\n  --help                 Print help text and exit\n  --ignore-case          Ignore case\n  --invert-match         Select non-matching lines\n  --max-count <n>        Stop searching after N matches\n  --context <n>          Print N lines of before/after context\n  --color <col>          Highlight matching text: red, green, blue\n\nAliases:\n  --help                 -h\n  --ignore-case          -i\n  --invert-match         -v\n  --max-count            -m\n  --context              -C\n```\n\n#### Example 4\n\nAs a final comparison, we will expand beyond grepping into a suite of\nregex-based text wrangling utilities: grep (search for matching lines), sub\n(search and replace), and search (search and grab). For this script, we will\nneed to use argparse subparsers, which makes the configuration even heavier and\nharder to read or scan. It requires users to learn and remember even more API.\nTo avoid code repetition for options shared across the subcommands, the user\nhas to take some care in defining a secondary data structure (`argconf` in this\nexample). And if you work with colleagues who frown on long lines (as they\nprobably should, for readability reasons well-understood for decades by the\npublishing industry) you will have to expand the code footprint further by\nwrapping the lines sensibly or by extracting help text into a separate data\nstructure to de-bulk the main configuration code.\n\n```python\nap = argparse.ArgumentParser(prog = 'wrangle')\n\nsps = ap.add_subparsers(dest = 'task', help = 'Task to perform', metavar = '<task>')\nsp1 = sps.add_parser('grep', help = 'Emit lines matching pattern')\nsp2 = sps.add_parser('sub', help = 'Search for pattern and replace')\nsp3 = sps.add_parser('search', help = 'Emit text matching pattern')\n\nargconf = {\n    'rgx': dict(metavar = '<rgx>', type = re.compile, help = 'Python regular expression'),\n    'path': dict(metavar = '<path>', type = pathlib.Path, nargs = '*', help = 'Path(s) to input'),\n    '-i': dict(action = 'store_true', help = 'Ignore case'),\n}\n\nsp1.add_argument('--ignore-case', '-i', **argconf['-i'])\nsp1.add_argument('--invert-match', '-v', action = 'store_true', help = 'Select non-matching lines')\nsp1.add_argument('--max-count', '-m', metavar = '<n>', type = int, help = 'Stop searching after N matches')\nsp1.add_argument('--context', '-C', metavar = '<n>', type = int, help = 'Print N lines of before/after context')\nsp1.add_argument('--color', metavar = '<col>', choices = ('red', 'green', 'blue'), help = 'Highlight matching text: red, green, blue')\nsp1.add_argument('rgx', **argconf['rgx'])\nsp1.add_argument('path', **argconf['path'])\n\nsp2.add_argument('--ignore-case', '-i', **argconf['-i'])\nsp2.add_argument('--nsubs', '-n', metavar = '<n>', type = int, help = 'N of substitutions')\nsp2.add_argument('rgx', **argconf['rgx'])\nsp2.add_argument('rep', metavar = '<rep>', help = 'Replacement text')\nsp2.add_argument('path', **argconf['path'])\n\nsp3.add_argument('--ignore-case', '-i', **argconf['-i'])\nsp3.add_argument('--group', '-g', metavar = '<n>', type = int, help = 'Emit just capture group N [0 for all]')\nsp3.add_argument('--delim', '-d', metavar = '<s>', help = 'Delimeter for capture groups [tab]')\nsp3.add_argument('--para', '-p', action = 'store_true', help = 'Emit capture groups one-per-line, paragraph-style')\nsp3.add_argument('rgx', **argconf['rgx'])\nsp3.add_argument('path', **argconf['path'])\n```\n\nOnce again, the comparison with Optopus is striking. Even with subcommands, the\nOptopus configuration remains intuitive and compact (60% the size of argparse).\nThe user does have to learn a few additional syntax rules (the double-colon as\na section marker, and the syntax for positional usage variants like\n`<task=grep>`), but the API burden remains low. A Python programmer unfamiliar\nwith the library could quickly infer the basic intent even without knowing the\nall of the rules. This example illustrates both syntax styles mentioned above:\nusage-variant syntax to define the subcommand-style grammar that our program\nneeds in the first section (for convenience, this section can refer to the Opts\nvia their short aliases); followed by another section using opt-help syntax to\nconfigure the individual Opts more fully. Finally, notice that this\nconfiguration does more than the argparse example: it defines the `-d` and `-p`\noptions as alternatives (mutually exclusive). That behavior is achievable in\nargparse, at the cost of looking up even more API. Optopus simply builds on a\nusage syntax already known to many developers: a pipe to delimit alternatives.\n\n```python\np = Parser('''wrangle ::\n    <task=grep>   [-i] [-v] [-m] [-C]\n                  [--color <red|green|blue>]\n                  <rgx> [<path>...]\n    <task=sub>    [-i] [-n] <rgx> <rep> [<path>...]\n    <task=search> [-i] [-g] [-d | -p] <rgx> [<path>...]\n\n    ::\n\n    <task>             : Task to perform\n    <task=grep>        : Emit lines matching pattern\n    <task=sub>         : Search for pattern and replace\n    <task=search>      : Emit text matching pattern\n    <rgx>              : Python regular expression\n    <path>             : Path(s) to input\n    <rep>              : Replacement text\n    -i --ignore-case   : Ignore case\n    -v --invert-match  : Select non-matching lines\n    -m --max-count <n> : Stop searching after N matches\n    -C --context <n>   : Print N lines of before/after context\n    --color <>         : Highlight matching text\n    -n --nsubs <n>     : N of substitutions\n    -g --group <n>     : Emit just capture group N [0 for all]\n    -d --delim <s>     : Delimeter for capture groups [tab]\n    -p --para          : Emit capture groups one-per-line, paragraph-style\n''')\n\np.config('rgx', convert = re.compile)\np.config('path', convert = pathlib.Path, validate = isfile)\np.config('m C n', convert = int, validate = ispositive)\np.config('g', convert = int, validate = nonnegative)\n```\n\n#### Example 4 help text\n\nThe help text comparison for the last example further highlights the awkward\nadequacy of argparse: yes it works, but no more than that. Here are the outputs\nfrom four uses of `--help` (generally and for each of the three subcommands).\n\n```\nusage: wrangle [-h] <task> ...\n\npositional arguments:\n  <task>      Task to perform\n    grep      Emit lines matching pattern\n    sub       Search for pattern and replace\n    search    Emit text matching pattern\n\noptional arguments:\n  -h, --help  show this help message and exit\n```\n\n```\nusage: wrangle grep [-h] [--ignore-case] [--invert-match] [--max-count <n>]\n                    [--context <n>] [--color <col>]\n                    <rgx> [<path> ...]\n\npositional arguments:\n  <rgx>                 Python regular expression\n  <path>                Path(s) to input\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --ignore-case, -i     Ignore case\n  --invert-match, -v    Select non-matching lines\n  --max-count <n>, -m <n>\n                        Stop searching after N matches\n  --context <n>, -C <n>\n                        Print N lines of before/after context\n  --color <col>         Highlight matching text: red, green, blue\n```\n\n```\nusage: wrangle sub [-h] [--ignore-case] [--nsubs <n>] <rgx> <rep> [<path> ...]\n\npositional arguments:\n  <rgx>                Python regular expression\n  <rep>                Replacement text\n  <path>               Path(s) to input\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --ignore-case, -i    Ignore case\n  --nsubs <n>, -n <n>  N of substitutions\n```\n\n```\nusage: wrangle search [-h] [--ignore-case] [--group <n>] [--delim <s>]\n                      <rgx> [<path> ...]\n\npositional arguments:\n  <rgx>                Python regular expression\n  <path>               Path(s) to input\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --ignore-case, -i    Ignore case\n  --group <n>, -g <n>  Emit just capture group N [0 for all]\n  --delim <s>, -d <s>  Delimeter for capture groups [tab]\n  --para, -p           Emit capture groups one-per-line, paragraph-style\n```\n\nThe Optopus help text is cleaner, easier to read, and more compact. It is also\nunified rather than separate (everything from a single usage of `--help`). If\nneeded, the parser can be easily configured to support use cases that need\nseparate help text for different usage variants (many programs do not).\n\n```\nUsage:\n  wrangle grep [-h] [-i] [-v] [-m <n>] [-C <n>]\n          [--color <red|green|blue>] <rgx> [<path>...]\n  wrangle sub [-h] [-i] [-n <n>] <rgx> <rep> [<path>...]\n  wrangle search [-h] [-i] [-g <n>] [-d <s>] <rgx> [<path>...]\n\nPositionals: task:\n  grep                   Emit lines matching pattern\n  sub                    Search for pattern and replace\n  search                 Emit text matching pattern\n\nPositionals: other:\n  <rgx>                  Python regular expression\n  <path>                 Path(s) to input\n\nOptions:\n  --help                 Print help text and exit\n  --ignore-case          Ignore case\n  --invert-match         Select non-matching lines\n  --max-count <n>        Stop searching after N matches\n  --context <n>          Print N lines of before/after context\n  --color <>             Highlight matching text: red, green, blue\n  --nsubs <n>            N of substitutions\n  --group <n>            Emit just capture group N [0 for all]\n  --delim <s>            Delimeter for capture groups [tab]\n\nAliases:\n  --help                 -h\n  --ignore-case          -i\n  --invert-match         -v\n  --max-count            -m\n  --context              -C\n  --nsubs                -n\n  --group                -g\n  --delim                -d\n```\n\n## Powerful grammars built from simple parts\n\nMost argument parsing libraries start from the a basic model of command-line\nusage: an ordered sequence of positionals along with an unordered set of short\nand long options that can be freely mixed among the positionals and that can\ntake zero or more ordered parameters.\n\nThe argparse library is a representative example in this vein: it does a\nreasonable job for common use cases but struggles with command lines that\nrequire a grammar falling beyond the typical. On [Stack Overflow][stack_home]\nand the [Python bug tracker][py_bugs], for example, one can find a variety of\ndesired and generally sensible use cases that argparse cannot support at all or\ncan support only partially after some uncomfortable hackery.\n\nThe most frequently desired grammatical features seem to fall into the\nfollowing buckets:\n\n**Mutual exclusion beyond the simplest case**. The argparse library supports\nmutual exclusion among options considered individually. But it cannot apply\nthat type of requirement to groups of options (for example, `-x` OR `-y` `-z`).\nSee [here][grammar_ex01] or [here][grammar_ex02].\n\n**Conditional requirements or exclusions**. The argparse library does offer\nsubparsers as one mechanism to apply conditional requirements, but this can be\na heavy device for what are often fairly simple grammatical needs (for example,\nif `-x` then require either `-y` or `-z`; or if `-a` then disallow `-b`). See\n[here][grammar_ex03], [here][grammar_ex04], [here][grammar_ex05], or\n[here][grammar_ex06].\n\n**Flexible specification of alternatives**. Again, argparse supports this\npartially (via subparsers or mutually exclusive options), but it lacks a\nsimple, general-purpose mechanism for alternatives (for example, either `-a` OR\n`-b` OR `-a` `-b`). See [here][grammar_ex07], [here][grammar_ex08], or\n[here][grammar_ex09].\n\n**Flexible quantification**. The argparse library supports four basic\nquantifiers (`N`, `?` `*`, and `+`), but it lacks support for regex-style\nranges (e.g., `{1,3}`), which can arise in a variety of plausible uses cases.\nThere is no strong reason not to support them. See [here][grammar_ex10],\n[here][grammar_ex15], or [here][grammar_ex16].\n\n**More complex repetition**. The argparse library can apply quantifiers to\nindividual options or positionals, but not to groups (for example, two\npositionals, `<x> <y>`, repeatable in pairs). Sometimes the group that needs to\nbe repeated is the full command-line grammar. In fact, after Optopus, my next\nproject involves such a program: a Python tool for quick text transformation\npipelines in the spirit of sed/awk/perl one-liners, but with more intuitive\nusage, a built-in set of core utilities, and an easy mechanism for users to\ndefine their own. Because the tool is literally a pipeline for text running\nthrough various conversion and computation stages, it makes sense to model the\ncommand-line grammar as repeatable. This use case is mostly supportable by\ncobbling together multiple argparse parsers, but it is awkward and requires a\nbit of special logic. Optopus will support a use case like that with almost no\nextra API-learning cost for the user. See [here][grammar_ex11],\n[here][grammar_ex12], or [here][grammar_ex13].\n\n**Parameter or argument independence**. When an option has multiple parameters\nor a positional has multiple arguments, most argument parsers force them to be\nconfigured identically. But sometimes independence makes sense (for example,\n`-a <A|B|C> <X|Y>`, where each parameter has different choices). See\n[here][grammar_ex14].\n\nThe deeper problem with most argument parsing libraries is that they rest on a\nweak foundation. Perhaps a bit uncharitably, one could say that they started\nwith the simplest model of command-line grammar (described at the start of this\nsection). Then they tacked on additional features to meet some of the more\ncommon usage patterns: if users occasionally need subcommand-style programs,\nadd a new API to create and configure subparsers; if users occasionally need\nsimple mutual exclusion, add a new API to handle it; and so forth until the\nlibrary reaches the technical limits of the weak foundation.\n\nA better model is to look to related domains for a small number of general,\ncomposable concepts: elements (in this case, positionals, options, and their\nparameters), groups, alternatives, usage variants, and quantifiers. At least\nfor most developers, those concepts are frequently observed in regular\nexpressions and in the related set of conventions observed in technical\ndocumentation for command-line programs — namely, their usage syntax. By\nresting on these composable ideas, Optopus will be able to achieve both\nsimplicity and greater power.\n\nIn more schematic terms, Optopus supports a wide variety of command-line\ngrammars by combining a few core ideas:\n\n- Groups enclosed either by parentheses (if required) or square brackets (if\n  optional). Groups as first-class citizens is one of the crucial missing\n  ingredients in most libraries.\n\n- Angle brackets for any kind of variable end-user input, whether it be\n  positionals (`<foo>`) or option parameters (`--point <x> <y>`). The universe of\n  command-line programs lacks a consistent convention on how to represent\n  variable inputs. There are four main styles relying on different bracketing\n  conventions (angle, square, or curly) and different capitalization schemes\n  (all uppercase, all lower, or mixed). For a variety of technical and\n  practical reasons, Optopus mimics Git and some other tools in using angle\n  brackets consistently.\n\n- Pipes to separate alternatives — a ubiquitous convention both in usage text\n  and regex.\n\n- Quantifiers that can applied to single elements or groups. This is another\n  one of the crucial missing ingredients in most parsers. Optopus relies\n  primarily on the quantifiers from usage-syntax conventions: `...` for\n  one-or-more and square brackets to convey optionality. To those it adds the\n  regex `{m,n}` syntax for quantity ranges.\n\n- Like regular expressions, grammar elements and parsing itself are greedy by\n  default. This policy decision is necessary to resolve a variety of parsing\n  ambiguities that can arise. Optopus also follows regex in using `?` as the\n  device to make a quantifier non-greedy.\n\n- The ability to name elements or groups symbolically both for display in usage\n  text and for the purpose of naming things in the parsed result. This behavior\n  is important not for grammatical reasons but in order to be able to organize\n  the parsed data in usable ways, especially for more complex grammars.\n\nExamples of most of those grammatical features have already been shown, but\nanother might help to make things more explicit. The example below defines a\ngrammar for a program with two usage variants (named Add and Delete) triggered\nby the value of the `<task>` positional (add or delete), along with a third\nvariant (named Examples) that allows the user to request some help text showing\nexamples. Note that usage variants can have explicit names (as shown below) or\nnot (the more common case); if defined, a variant name is mainly useful as a\nconvenient label/handle when using the Parser's configuration API.\n\n```python\np = Parser('''::\n    Add      : <task=add> (<name> <id>)...\n    Delete   : <task=delete> <id>{1,5} [--archive [--json [--indent] | --xml]]\n    Examples : --examples\n''')\n```\n\nEach usage variant above has something noteworthy.\n\n- The Add variant requires the `<name>` and `<id>` positionals to come in pairs.\n\n- The Delete variant uses a regex-style quantifier for `<id>`, and the `--archive`\n  option is configured so that it can be accompanied by other options in\n  different combinations (either `--xml` or `--json` plus an optional `--indent`).\n\n- The Examples variant takes an entirely different form from the\n  subcommand-style of the other two variants. It illustrates the general point\n  noted above: if you start with a narrow vision for command-line grammars and\n  then tack on a subparser API, you can support typical subcommand-style\n  programs, but nothing else; however, if you start with composable concepts\n  you can support subcommand-style programs and all kinds of other needs as\n  well — with almost no additional API burden on users.\n\nDefining command-line grammar via a configuration syntax based on usage text is\nnot a new idea. While most argument parsing libraries are like argparse in\nconfiguring the parser's grammar via a programmatic API, some libraries take a\ndifferent approach: the user writes the usage and help text (sometimes enhanced\nwith special syntax elements), the parser is derived from that text, and the\ntext (minus any special syntax) is used as the literal usage and help text\npresented to end users. Examples include [docopt][docopt_url] in Python or\n[Getopt::Long::Descriptive][getopt_long_desc], [Getopt::Euclid][getopt_euclid],\nand [Getopt::Declare][getopt_declare] in Perl.\n\nI believe my first exposure to such ideas came in the early 2000s from Damian\nConway, a great programming educator and the initial author of Getopt::Euclid.\nHe is arguably the inspiration for this library: I have been thinking, on and\noff, about how to make a better argument parser since then. A second debt is\nowed to Vladimir Keleshev, the primary author of Python's docopt. That library,\nin my view, has unfortunate and signficant limitations, but it is based on some\ncompelling ideas. The 2012 PyCon [video][docopt_vid] promoting the library is\nentertaining and wonderfully polemical in the best sense of the word — well\nworth the time of anyone interested in the subject. Watching the video in the\nearly 2010s rekindled my interest in the Optopus project and helped me refine\nideas I had been mulling over for a long time.\n\nIn spite of those intellectual debts to this alternative tradition in argument\nparsers, my experiments with many libraries convinced me that both approaches\n— API-driven configuration and usage-syntax-driven configuration — have their\nstrengths and weaknesses. Optopus aims to build on the strengths of each:\n\n**Usage-syntax to define the core**. Optopus encourages the use of text as the\nprimary mechanism to configure the command-line grammar and the logical\nrelationships among the elements, along with the names to be used when\nreferring to options, parameters, positionals, groups, and usage variants. It\nalso encourages the text syntax for defining option aliases and the help text\nfor individual positionals and options. Those are the areas where the\ntext-driven approach shines, either because the configuration is unavoidably\ntextual (for example, help text for individual Opts) or because text is simply\na more efficient and intuitive configuration mechanism than API calls (the\ngrammatical relationships among the elements). Consider the example grammar\nshown above: it conveys a lot of information very efficiently and intuitively\nwhen compared against what most API-driven libraries would require of the user\n(and none of them could fully support the example). In spite of the benefits of\ntext-based configuration, most programmers do not want to handcraft the\nend-user-facing usage and help text if a computer program can do it\nconsistently and well (not to mention dynamically responding to terminal width\nor to runtime configurations). That is why Optopus takes substantial\ninspiration from, but does not fully adopt, the ideas motivating the\ntext-driven parsers like Getopt::Euclid and docopt. Optopus treats the text\nprimarily as a configuration syntax, not literal usage text. Naturally, it does\nprovide an easy mechanism for that syntax to include blocks of literal text.\n\n**Programmatic API for the rest**. To apply other configurations (defaults,\nconversion, validation, and various other details), Optopus builds on the\nstrength of the API approach and adds some additional conveniences to keep the\ndeveloper burden low. Although it is theoretically possible to configure some\nof those things via a text syntax, the approach has rapidly diminishing\nreturns, because each feature addition requires increasingly baroque syntactic\nfeatures. Optopus takes a hybrid approach, combining the benefits of each\nconfiguration style.\n\nFinally, it should be noted that all of the library's behaviors will be\nconfigurable via the API, including the grammar — not merely to satisfy\ntraditionalists, but because, at least for simpler use cases, configuring the\nparser's grammar via the API also works well. Note also that even the API\nconfiguration can leverage as much or little of the grammar syntax as desired.\nTo illustrate, the following configurations achieve the same thing: an optional\n`--dim` having an alias and taking 2 to 3 parameters. I suspect that many\ndevelopers will prefer the efficiency and intuitiveness of the syntax, but that\nopinion is not enforced by the library. Users can freely operate at any point\nthey prefer along the text-to-API spectrum.\n\n```python\n# All text syntax.\nOpt('[-d --dim <> <> [<>]]')\n\n# Hybrid.\nOpt('-d --dim', nparams = (2,3), ntimes = (0,1))\n\n# All API.\nOpt(dest = 'dim', kind = 'option', nparams = (2,3), ntimes = (0,1), aliases = 'd')\n```\n\n## Designed for flexibility\n\nIn addition to having an insufficiently powerful grammatical foundation,\nexisting argument parsers tend to be inflexible in their design and thus not\nopen to very much customization. Two areas are particularly noteworthy.\n\n**Help and error text**. Most libraries offer only limited control over the\nformatting, arrangement, and style of help and error text. Argparse, for\nexample, offers a few subclasses that adjust help text in small ways or allow\nthe user to supply regular text blocks that will be presented as-is rather than\nwrapped. But the underlying `HelpFormatter` class is not friendly to\ncustomization generally. Some of its stylistic choices seem non-standard or\ninelegant to my eye and I have never found ways to adjust them without awkward\nhacks. More fundamentally, argparse is not prepared to handle bigger changes,\nranging from fairly standard needs (for example, help text in man-page format)\nto more innovative approaches. Optopus will offer some of those approaches\ndirectly with the aim of giving programmers the ability to lighten-up and\nimprove the readability of help text.\n\n**Side effects**. Many argument parsers, including argparse until Python 3.9,\nare rigid in response to invalid input. They start with sensible default\nbehavior: in the face of bad input, print brief usage text and an error\nmessage, then exit. But they turn that default into a requirement by providing\nno good way to prevent the side effects from occurring. By good way, I mean one\nwhere the library would include sufficient contextual data about the error,\nrather than just providing the error text as a string. That default behavior\nworks in the most common cases, but sometimes programs have other needs.\nArgument parsing libraries should follow ordinary best practices by giving the\nuser the ability to bypass major side effects like printing and exiting.\nImagine any other data oriented library imposing such effects without easy\ndisabling.\n\nTo the extent that the existing libraries do allow customization, the\nmechanisms for doing that are often awkward. Argparse is an apt example: many\nsuggested workarounds to user difficulties with the library involve\nsubclassing, but most argparse classes do not appear to be well-designed for\ninheritance (and some of their docstrings seem to discourage it outright). At a\nminimum, one a can say that the library does not provide authoritative guidance\non which classes are amenable to subclassing, if any, and what users should do\nor avoid when doing so.\n\nOptopus will be built with an eye toward flexibility and customization. To the\nextent feasible, all controllable parameters governing the generation of text\nwill be adjustable. And for dynamic configuration needs — whether related to\nhelp text, error text, side effects, or parsing — the library will support\nthem via hooks rather than subclassing. Developers needing special behavior\nwill not have to worry whether they have implemented a method override robustly\nenough in the face of edge cases or future evolution of the library. Instead,\nthey will just have to write an ordinary hook function based on a documented\nAPI.\n\n## Reducing the burden on developers\n\nFlexibility and customization are aimed not only at a small minority of\ndevelopers with strong opinions about technical documentation and page layout.\nThey also have practical ramifications. Developers want to build tools that\nusers can easily understand. Without that, those developers face higher\nshort-term and long-term support costs.\n\nThe broad theme connecting such matters is to reduce developer hassle as it\nrelates to argument handling. Some examples on the Optopus roadmap.\n\n#### Efficient Opt configuration API\n\nWhen a program needs more than a few Opts, it is not uncommon for some them to\nhave similar configuration needs. Optopus includes a simple, minimal-hassle API\nto query for one or more grammar elements (mainly Opts, but sometimes Variants\nor Groups) and apply supplemental configurations to all elements contained in\nthe query result. Those configurations are applied to the Opts in an additive\nfashion, making it possible to configure many Opts very efficiently. This was\ndemonstrated briefly in a few in the examples above, where multiple Opts were\nconfigured in one call to accept only positive integers.\n\n#### Handy utilities for exiting and error messages\n\nArgument parsers are all used in the same general context and such programs\nhave many common needs during the early phase of execution when arguments are\nparsed and validated — namely, printing different types of help or error text\nand sometimes exiting. Those behaviors can be implemented haphazardly or\nrobustly and well (for example, exiting with a proper status code, emitting\nerror messages to stderr rather than stdout, or even adding color to error\noutput). Even when done well, such utilities need to be reimplemented (or\ncopy-pasted) from script to script, because it is not necessarily worth the\ntrouble to package them as a separate library.\n\nOptopus is fundamentally an argument parser and will not stray too far from\nthat focus, but it will provide commonly needed functionality related to\nargument handling, help text selection and printing, error message creation,\nand proper exiting.\n\n#### Composable data conversion and validation\n\nArgument parsing is very much concerned with the problem of data conversion and\nvalidation: for example, a command-line grammar can include validation-adjacent\nconcepts, such as choices for positionals or option parameters.\n\nOptopus will not attempt to become a data conversion and validation library --\nthat falls beyond the scope of the project. But Opts (and possibly Variants)\nwill have `convert` and `validate` attributes that can be set to one or more\ncallables. That approach is not a revolutionary idea, of course, but it is an\narrangement well-suited to easy composition of functionality that the user\nmight already have at-hand, either from Python itself (`int`, `float`,\n`re.compile`, `os.path.isdir`, and so forth), from user-written functions or\nclasses, and from third-party libraries.\n\n#### Convenient dispatching\n\nJust as argument parsing is closely linked to conversion and validation, its\nultimate purpose is dispatch: most command-line scripts take arguments, execute\none or more functions in response, and then exit.\n\nOptopus will include convenient mechanisms to do that type of thing. One\ninvolves the concept of usage variants. As already discussed, variants provide\na powerful means of expressing a command-line grammar and conveying its usage\ntext. But variants also work well as a dispatch device. Both Opts and Variants\ncan be configured with one or more dispatch functions, which will be called\nwith the parsed result, along with any other args/kwargs the user specifies.\n\n#### Readable usage text, via symbolic grouping\n\nAs illustrated in a few of the examples above, a program's usage text can be\nmade more readable and helpful to end-users by condensing groups of options (or\ngroups of choices) with symbolic names. Such techniques are sometimes seen in\ncommand-line programs with large numbers of options — so large than an\nexhaustive listing in the usage text actively undermines usability because it\noverwhelms user attention and patience. For example, this simplified snippet of\nusage text from `git diff` illustrates the technique.\n\n```\ngit diff [options] [<commit>] [<path>...]\ngit diff [options] --cached [<commit>] [<path>...]\n```\n\nBecause Optopus treats groups as first-class citizens in command-line grammar,\nand because it will also offer flexible query/configuration APIs allowing\ndevelopers to organize options into meaningful arrangements with symbolic\nnames, developers working on larger scripts (or really any script that could\nbenefits from such devices) will have flexible mechanisms to generate effective\nusage text that actually helps end-users rather than exhaustively \"correct\"\nusage text churned out by a rigid algorithm.\n\n#### Flexible help text, without API burden\n\nMost command-line programs are sufficiently documented simply by listing all\narguments and options, each with a line of help text. Sometimes, however, a\ndifferent approach works better, such as organizing options into labeled\nsections or simply interspersing blocks of text or sub-headings in between\nvarious groupings of the listed options. Argparse mostly supports those needs\nvia argument groups — even more API to learn.\n\nBecause Optopus configuration rests on a textual foundation, providing users\nwith more flexibility and control over the structuring of help text is easy to\naccommodate. To illustrate, consider [Example 4](#example-4) (the wrangle\nscript) and imagine that the developer wanted to organize the help text by\nsubcommand, with various chunks of literal text and sub-headings mixed in. That\ncan probably be achieved with argparse using multiple argument groups per\nsubparser, but most developers would not bother with the hassle. With Optopus,\ndevelopers will be able to directly type what is wanted (provided that a few\nsimple syntax rules are followed). Here is an illustration of what the grep\nsection of that help text might look like. Admittedly, this presentation is too\nelaborate for the script at hand, but the main point is just to illustrate the\nease of organizing help text as needed.\n\n```\ngrep::\n\n    ```\n    The grep command emits input lines matching (or not\n    matching) the regular expression.\n\n    Positionals:\n    ```\n\n        <rgx> : Python regular expression\n        <path> : Path(s) to input\n\n    ```\n    Search options:\n    ```\n\n        -i --ignore-case : Ignore case\n        -v --invert-match : Select non-matching lines\n        -m --max-count <n> : Stop searching after N matches\n\n    ```\n    Output options:\n    ```\n\n        -C --context <n> : Print N lines of before/after context\n        --color <> : Highlight matching text\n```\n\nFinally, to reiterate a point noted above, the configuration syntax is not\nprimarily literal help text: for example, the blocks of regular text (marked by\ntriple back-quotes above) will still be paragraph-wrapped to proper width by\nOptopus, while preserving the intended indentation level. And of course, that\nwrapping behavior can be turned off globally, by section, or at the level of\nindividual text blocks, if needed.\n\n#### More helpful help, via high-precedence Opts\n\nMost users of command-line programs have had the experience of assembling a\nfairly large command line of positionals and options only to be greeted by a\nusage error message. What happens next? Ideally, the user would hit the up\narrow to recall the shell command and simply add `--help` to the end of the\ncommand line. But most argument parsers, including argparse, insist on griping\nrather than helping. Instead of printing relevant help (which should be easy to\nsupport since `'--help' in sys.argv` is true), they doggedly report the same\nusage error.\n\nOptopus will address that issue via a mechanism call high-precedence options:\nif a high-precedence option is present among the arguments, its dispatch\nbehavior will be triggered. Every Opt can have its dispatch attribute set with\none or more callables that will be invoked when the option is seen. Normally,\ndispatch occurs only after a successful parse. But if such configuration is\ncombined with a high-precedence setting for an Opt, its dispatch functions are\ncalled even in the face of end-user error. This feature is envisioned mainly\nfor help-related scenarios, but it is not limited to any specific use case.\n\n#### Dynamically hidden Opts\n\nSometimes the development or debugging process can be helped by having the\nability to include hidden Opts, meaning that they work but are never mentioned\nin the usage or help text. A related need is for Opts that apply only under\nspecific conditions that must be determined at runtime. Although the latter is\nachievable via argparse — just wrap parts of the argparse setup code in the\nneeded conditional logic — Optopus will support such behaviors via simple API\nconfigurations.\n\n#### Relaxed parsing modes\n\nExisting libraries either ignore or support only small number of parsing modes.\nArgparse, for example, has long supported a [parse-known\nmode][py_argparse_known] and in Python 3.7 it added a [parse-intermixed\nmode][py_argparse_intermixed], which allows positionals and options to be\nintermixed a bit more flexibly on the command line.\n\nStandard argument parsing in Optopus will be similar to the flexibility\nexhibited by the argparse intermixed mode. That behavior is basically the\nlogical result of applying the core concepts defining the grammar syntax, along\nwith a default greedy policy as it relates to parsing and the interpretation of\nthe syntax itself.\n\nIn addition, Optopus will support a feature that allows the user to create a\nset of related parsing modes that relax one or more requirements. These modes\ncan be combined as needed.\n\n- Allow-unknown: similar to parse-known behavior in argparse.\n\n- Allow-unconverted: overlook data-conversion problems.\n\n- Allow-unvalidated: overlook data-validation problems.\n\nThe intended use case for relaxed parsing is either to parse the known part of\nthe input and leave the rest to be handled differently, or to parse as much of\nthe input as possible (even in the face of some end-user errors) in order to\nglean more information about end-user intent, perhaps with an eye toward\nproviding more specific help.\n\n#### No-configuration parsing\n\nOptopus will support no-configuration parsing that will parse any input based\non standard rules. The purpose is to support low-stakes or temporary scripts\nthat could benefit from a few command-line options, but are not important\nenough to warrant much configuration work.\n\nIn addition to the default no-config parsing, demonstrated in the introduction,\nthe library will include a simple mechanism to achieve a few different flavors\nof almost-no-config parsing. Those flavors relate to the number of parameters\nthat options will bind to. By default, no-config parsing is greedy, both for\nconsistency with the rest of the library and also because greedy binding\nprovides the most flexibility to the end-user. That parameter-binding behavior\ncan be configured with a quantifier to achieve different results.\n\n```python\nParser()                # Default: greedy.\nParser(noconf = '0')    # Flag style.\nParser(noconf = '1')    # Key-value style.\nParser(noconf = '2,')   # 2+ parameters.\n```\n\nThose examples blur the line between config and no-config, of course, and the\nlast two violate the spirit of no-config by imposing some validation\nrequirements on the arguments. But they are consistent with the spirit of\nOptopus, which is to make it easy to parse arguments under a variety of\nsituations with minimal hassle.\n\n#### Good cooperation with configuration files and environment variables\n\nSome command-line programs are substantial enough that developers want to allow\nusers to declare some preferences in configuration files or environment\nvariables. The typical relationship of those mechanisms to argument parsing is\nin the area of default setting, usually in this order:\n\n- Persistent settings in a configuration file.\n\n- Somewhat less persistent settings in environment variables. A setting here\n  can override the value from a configuration file.\n\n- Just-in-time settings from the command-line arguments. These setting override\n  everything else.\n\nThat order of operations implies that the data from configuration files and\nenvironment variables is mainly used to dynamically influence the default\nvalues for Opts. Additionally, when an Opt acquires a default value from an\nupstream source, its status can change from being required on the command line\nto optional. In the abstract, `--foo` might be a required option, but it should\nnot be required if its value is already defined elsewhere.\n\nOptopus will not try to support direct integration with configuration parsing\nlibraries: the universe of config files types and config parsing libraries is\ntoo large for that.\n\nInstead, Optopus will allow users to combine configuration data, environment\nvariables, and command-line arguments with minimal hassle via a general policy\nand a few convenience utilities.\n\nThe policy is to ensure that all parser configurations are exportable and\nimportable as an ordinary data structure. If needed, users can partially\nconfigure a parser, export its data, apply any modifications to that data based\non information from config files or environment variables, and then use the new\ndata to create the desired parser. That is the worst-case scenario for unusual\nor complex situations.\n\nMore commonly, users will simply leverage some convenience utilities to augment\nOpt configurations. The API details for this behavior are still under\nconsideration, but this example illustrates one possible approach.\n\n```python\nfrom optopus import Parser, defkeys\nimport os\n\n# Read a config file into a data structure.\nconfig = ...\n\n# Setup the parser from Example 2, but this time with a defaults\n# setting to tell Optopus where to obtain upstream default values,\n# and in which order.\n\np = Parser('''pgrep\n    <rgx> : Python regular expression\n    [<path>...] : Path(s) to input\n    [-i --ignore-case] : Ignore case\n    [-v --invert-match] : Select non-matching lines\n    ''',\n    defaults = [config, os.environ],\n)\n\n# Configure defaults for Opts by telling Optopus which key(s)\n# to use to obtain needed values from those upstream sources.\n\np.config('i', default = defkeys('ignore_case', 'pgrep_ignore_case'))\np.config('v', default = defkeys('invert_match', 'pgrep_invert_match'))\n```\n\n--------\n\n[docopt_url]: http://docopt.org/\n[docopt_vid]: https://www.youtube.com/watch?v=pXhcPJK5cMc\n[getopt_declare]: https://metacpan.org/pod/Getopt::Declare\n[getopt_euclid]: https://metacpan.org/pod/Getopt::Euclid\n[getopt_long_desc]: https://metacpan.org/pod/Getopt::Long::Descriptive\n[grammar_ex01]: https://stackoverflow.com/questions/18025646\n[grammar_ex02]: http://bugs.python.org/issue10984\n[grammar_ex03]: https://stackoverflow.com/questions/4466197\n[grammar_ex04]: https://stackoverflow.com/questions/25626109\n[grammar_ex05]: http://bugs.python.org/issue11588\n[grammar_ex06]: https://stackoverflow.com/questions/11455218\n[grammar_ex07]: http://bugs.python.org/issue10984\n[grammar_ex08]: https://stackoverflow.com/questions/27258173\n[grammar_ex09]: https://stackoverflow.com/questions/4692556\n[grammar_ex10]: https://stackoverflow.com/questions/5257403\n[grammar_ex11]: https://stackoverflow.com/questions/27681718\n[grammar_ex12]: https://stackoverflow.com/questions/19114652\n[grammar_ex13]: https://stackoverflow.com/questions/62524681\n[grammar_ex14]: https://stackoverflow.com/questions/28660992\n[grammar_ex15]: https://stackoverflow.com/questions/4194948\n[grammar_ex16]: https://bugs.python.org/issue11354\n[py_argparse]: https://docs.python.org/3/library/argparse.html\n[py_argparse_intermixed]: https://docs.python.org/3/library/argparse.html#intermixed-parsing\n[py_argparse_known]: https://docs.python.org/3/library/argparse.html#partial-parsing\n[py_bugs]: https://bugs.python.org/\n[py_optparse]: https://docs.python.org/3/library/optparse.html\n[pypi_optopus]: https://pypi.org/project/optopus/\n[rb_optparse]: https://ruby-doc.org/stdlib-3.0.1/libdoc/optparse/rdoc/OptionParser.html\n[stack_home]: https://stackoverflow.com/\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/hindman/optopus",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "optopus",
    "package_url": "https://pypi.org/project/optopus/",
    "platform": "",
    "project_url": "https://pypi.org/project/optopus/",
    "project_urls": {
      "Homepage": "https://github.com/hindman/optopus"
    },
    "release_url": "https://pypi.org/project/optopus/0.2.0/",
    "requires_dist": [
      "attrs",
      "short-con",
      "invoke ; extra == 'dev'",
      "ipython ; extra == 'dev'",
      "pycodestyle ; extra == 'dev'",
      "twine ; extra == 'dev'",
      "virtualenv ; extra == 'dev'",
      "virtualenvwrapper ; extra == 'dev'",
      "pytest-cov ; extra == 'test'",
      "tox ; extra == 'test'"
    ],
    "requires_python": "",
    "summary": "Command line arguments done right",
    "version": "0.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10229579,
  "releases": {
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a7e5d18f5500cef53106e6fde3fab1125dcd80e4d15206017fae7b8118f8ac07",
          "md5": "87879ca09f21da8814cea2d943b8ea38",
          "sha256": "4dad115b95049ed77ef852cb0ea56390b48a20d62e76db1a06641f2b732a601a"
        },
        "downloads": -1,
        "filename": "optopus-0.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "87879ca09f21da8814cea2d943b8ea38",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 40272,
        "upload_time": "2021-05-01T19:56:37",
        "upload_time_iso_8601": "2021-05-01T19:56:37.773506Z",
        "url": "https://files.pythonhosted.org/packages/a7/e5/d18f5500cef53106e6fde3fab1125dcd80e4d15206017fae7b8118f8ac07/optopus-0.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c22e865f94edaf136b63d4157e0bd6832d21b91b5ba6801f920233acef1810c9",
          "md5": "589b80230472604a0fbc87758d5b0e71",
          "sha256": "45a36ed12bc78e8f1b5bf28223f94657611f0e514870ec156909083b9488e5a8"
        },
        "downloads": -1,
        "filename": "optopus-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "589b80230472604a0fbc87758d5b0e71",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 69657,
        "upload_time": "2021-05-01T19:56:39",
        "upload_time_iso_8601": "2021-05-01T19:56:39.230337Z",
        "url": "https://files.pythonhosted.org/packages/c2/2e/865f94edaf136b63d4157e0bd6832d21b91b5ba6801f920233acef1810c9/optopus-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a7e5d18f5500cef53106e6fde3fab1125dcd80e4d15206017fae7b8118f8ac07",
        "md5": "87879ca09f21da8814cea2d943b8ea38",
        "sha256": "4dad115b95049ed77ef852cb0ea56390b48a20d62e76db1a06641f2b732a601a"
      },
      "downloads": -1,
      "filename": "optopus-0.2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "87879ca09f21da8814cea2d943b8ea38",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 40272,
      "upload_time": "2021-05-01T19:56:37",
      "upload_time_iso_8601": "2021-05-01T19:56:37.773506Z",
      "url": "https://files.pythonhosted.org/packages/a7/e5/d18f5500cef53106e6fde3fab1125dcd80e4d15206017fae7b8118f8ac07/optopus-0.2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c22e865f94edaf136b63d4157e0bd6832d21b91b5ba6801f920233acef1810c9",
        "md5": "589b80230472604a0fbc87758d5b0e71",
        "sha256": "45a36ed12bc78e8f1b5bf28223f94657611f0e514870ec156909083b9488e5a8"
      },
      "downloads": -1,
      "filename": "optopus-0.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "589b80230472604a0fbc87758d5b0e71",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 69657,
      "upload_time": "2021-05-01T19:56:39",
      "upload_time_iso_8601": "2021-05-01T19:56:39.230337Z",
      "url": "https://files.pythonhosted.org/packages/c2/2e/865f94edaf136b63d4157e0bd6832d21b91b5ba6801f920233acef1810c9/optopus-0.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}