{
  "info": {
    "author": "Charles Baynham",
    "author_email": "charles.baynham@npl.co.uk",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 2 - Pre-Alpha",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8"
    ],
    "description": "Generic SCPI driver\n===================\n\n.. image:: https://img.shields.io/pypi/pyversions/generic-scpi-driver\n   :alt: PyPI - Python Version\n\nA generic driver generator for devices controlled via (virtual) COM ports using SCPI commands.\nCreates a python class for controlling your device. \n\nThis class is compatible with the ARTIQ experimental control system and,\nif desired, a network ARTIQ controller is also generated. \n\nInstallation\n------------\n\nInstall the package and its dependancies with::\n\n    pip install generic-scpi-driver\n\n\nIf you'd like to use the ARTIQ network controller generation, instead install with::\n\n    pip install generic-scpi-driver[artiq]\n\nUsage\n-----\n\nBasics\n######\n\nTo make a driver, simply inherit from the GenericDriver class. To define commands, call\n`_register_query` on the class (not on objects of the class). For example:\n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver\n\n    class SimpleDriver(GenericDriver):\n        '''A driver for my simple SCPI device'''\n\n    SimpleDriver._register_query(\"get_identity\", \"*IDN\")\n\nThis creates a class called ``SimpleDriver`` which has a constuctor ``__init__``, a ``close()`` method\nand a new method called ``get_identity()`` which takes no parameters and returns a string. You could open a connection to your device like this:\n\n.. code-block:: python\n\n    dev = SimpleDriver(\n        id=\"COM10\",\n        baud_rate=57600\n    )\n\n    # This sends the command \"*IDN\\n\" to the device and returns the response\n    identity = dev.get_identity()\n\nParameters\n##########\n\nFor more complex commands, you can specify parameters for the command:\n\n.. code-block:: python\n\n    SimpleDriver._register_query(\n        \"set_voltage\",\n        \"VOLT\",\n        args=[\n            GenericDriver.Arg(name=\"channel\"),\n            GenericDriver.Arg(name=\"voltage\"),\n        ]\n    )\n\nThis would allow you to call:\n\n.. code-block:: python\n\n    # Using positional arguments\n    dev.set_voltage(0, 5.4)\n\n    # ...or keyword arguments\n    dev.set_voltage(channel=0, voltage=5.4)\n\nParameters can be validated by passing a custom function (which may accept any\nsingle parameter and must return a string to be sent to the device, or throw an error):\n\n.. code-block:: python\n\n    def check_voltage_in_limits(v):\n        voltage = float(v)\n        if voltage > 10:\n            raise ValueError(\"Voltage too high\")\n        return str(voltage)\n\n    SimpleDriver._register_query(\n        \"set_voltage\",\n        \"VOLT\",\n        args=[\n            GenericDriver.Arg(name=\"channel\", validator=lambda: str(int(x))),\n            GenericDriver.Arg(name=\"voltage\", validator=check_voltage_in_limits, default=0.0,\n        ]\n    )\n\nReturn values\n#############\n\nReturn values are, by default, the string returned by the SCPI device in response to your command. \nIf you'd prefer to process these, you can pass a ``response_parser`` function:\n\n.. code-block:: python\n\n    SimpleDriver._register_query(\n        \"count_foobars\",\n        \"COUN\",\n        response_parser=int,\n    )\n\n    SimpleDriver._register_query(\n        \"list_foobars\",\n        \"LIST\",\n        response_parser=lambda x: x.split(\",\"),\n    )\n\nIf your device doesn't give any response at all, you can set\n``response_parser=None`` and the driver won't attempt to listen for a respose. \n\nError checking\n##############\n\nYou can also add error checking to your commands. Pass a function as\n``response_validator`` and it will be called with the output from the device\n(not the parsed output of ``response_parser``) as its input. The\n``response_validator``'s return value will be ignored: it's only job is to raise\nan exception if needed. E.g.\n\n.. code-block:: python\n\n    def check_for_error(s):\n        if \"error\" in s.lower():\n            raise RuntimeError(\"Error returned by device: {}\".format(s))\n    \n    SimpleDriver._register_query(\n        \"do_something\",\n        \"DOOO\",\n        response_validator=check_for_error,\n    )\n\nAsyncronous operation\n#####################\n\nBy default, all methods are syncronous. If you'd prefer async operation, pass ``coroutine=True`` \nto ``_register_query``. This creates a new thread for the serial call and returns an ``asyncio``\ncoroutine. Note that you have to call these using an async loop which is a whole topic of python\nprogramming. This is particularly useful for ARTIQ drivers, since ARTIQ handles coroutines\nautomatically. \n\nCustom methods\n##############\n\nThe method generation is intended to be quite flexible, but if you really need custom logic there's\nnothing to stop you writing your own methods. You can use ``self.instr`` to access the\n``pyvisa.Resource`` for your device. Use the wrappers ``with_handler`` to cause the driver to issue a\nVISA ``.flush()`` if an error occurs and ``with_lock`` to ensure that only one method access the device\nat a time (only relevant in multi-threaded applications). \n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver, with_lock, with_handler\n\n    class SimpleDriver(GenericDriver):\n        '''A driver for my simple SCPI device'''\n\n        @with_handler\n        @with_lock\n        def do_complex_thing(self):\n            '''Do something complex'''\n            response = self.instr.query(\"COMP 1 2 3\")\n            return int(response) + 5\n\nStartup checking\n################\n\nIt can be useful to check on startup if communicatio with a device has been\nestablished successfully. To do this, define a method in the class called\n``check_connection``. Return value is ignored, but this method will be called\nwhen the object is constucted and has the chance to raise an exception. Example:\n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver, with_lock, with_handler\n\n    class SimpleDriver(GenericDriver):\n        '''A driver for my simple SCPI device'''\n\n        def check_connection(self):\n            idn = self.get_identity()\n            if idn != \"My device\":\n                raise RuntimeError(f\"Bad device identity: got '{idn}'\")\n\n    # Note that it's fine to define functions later which get used in methods\n    # defined previously\n    SimpleDriver._register_query(\"get_identity\", \"*IDN\")\n\nSimulation mode\n###############\n\nThe constuctor accepts a keyword parameter ``simulation=True`` to return a simulation device, for running\noffline unit tests. This won't work unless you also register a simulator device with a method ``query`` which\ntakes a string and returns a string. For example:\n\n.. code-block:: python\n\n    class Simulator:\n        def query(s):\n            if s == \"*IDN\":\n                return \"Simulator device\"\n            else:\n                return \"ERROR\"\n\n    class SimpleDriver(GenericDriver):\n        pass\n\n    SimpleDriver._register_simulator(Simulator)\n    SimpleDriver._register_query(\"get_identity\", \"*IDN\")\n\n    dev = SimpleDriver(id=\"fake\", simulation=True)\n\n    dev.get_identity()  # returns \"Simulator device\"\n\nARTIQ Controllers\n#################\n\nTo get a network controller for use by the ARTIQ controller manager, just make a python module like:\n\n.. code-block:: python\n\n    from generic_scpi_driver import get_controller_func\n\n    from .my_driver import SimpleDriver\n\n    # Makes a controller called \"SimpleDriver\" which listens to port 3300 by default\n    main = get_controller_func(\"SimpleDriver\", 3300, SimpleDriver)\n\n\n    if __name__ == \"__main__\":\n        main()\n\nRegister this ``main`` function in your ``setup.py`` like so:\n\n.. code-block:: python\n\n    setup(\n        ...\n        entry_points={\n            \"console_scripts\": [\n                \"artiq_simple_device=my_driver_package.my_driver_controller:main\",\n            ]\n        },\n    )\n\nAfter installing your package using `pip install -e .` as normal, you should be able to call\n``artiq_simple_device`` on the command line to launch a controller for your device. \n\nDevelopment\n-----------\n\nFor developing the package, you'll need a few more packages. Install with::\n\n    pip install -e .[dev,artiq]\n\nAuthors\n-------\n\n`generic_scpi_driver` was written by `Charles Baynham <charles.baynham@npl.co.uk>`_.",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/charlesbaynham/GenericSCPIDriver",
    "keywords": "",
    "license": "None",
    "maintainer": "",
    "maintainer_email": "",
    "name": "generic-scpi-driver",
    "package_url": "https://pypi.org/project/generic-scpi-driver/",
    "platform": "",
    "project_url": "https://pypi.org/project/generic-scpi-driver/",
    "project_urls": {
      "Homepage": "https://github.com/charlesbaynham/GenericSCPIDriver"
    },
    "release_url": "https://pypi.org/project/generic-scpi-driver/1.3.2/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "A generic template for creating python object-based drivers for SCPI hardware devices which communicate via VISA. Compatible with ARTIQ if installed with [artiq] modifier",
    "version": "1.3.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9783320,
  "releases": {
    "1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "195e6bca288eb4d9911c70269451bb4074ede8b30767e6170cdab7df611b6b6e",
          "md5": "b33f1fd4af46d6c4476b613bb410ee05",
          "sha256": "98e751e2777e8a0252a1fdd459daa29a14e0a2dd7059d71890cb3745d9879e32"
        },
        "downloads": -1,
        "filename": "generic_scpi_driver-1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "b33f1fd4af46d6c4476b613bb410ee05",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 30000,
        "upload_time": "2021-02-26T19:10:59",
        "upload_time_iso_8601": "2021-02-26T19:10:59.059500Z",
        "url": "https://files.pythonhosted.org/packages/19/5e/6bca288eb4d9911c70269451bb4074ede8b30767e6170cdab7df611b6b6e/generic_scpi_driver-1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "422edde0e60308437b94d5e97fba4d31680a9b635570b67929b2f62b7387d82f",
          "md5": "c318dd4238af2a241475e67a66dc2137",
          "sha256": "ae6054befa825169d45e5a260808fb9e0c035fc71753fcad6511279945b5fd4c"
        },
        "downloads": -1,
        "filename": "generic_scpi_driver-1.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "c318dd4238af2a241475e67a66dc2137",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 29997,
        "upload_time": "2021-02-26T19:28:44",
        "upload_time_iso_8601": "2021-02-26T19:28:44.928260Z",
        "url": "https://files.pythonhosted.org/packages/42/2e/dde0e60308437b94d5e97fba4d31680a9b635570b67929b2f62b7387d82f/generic_scpi_driver-1.3.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f8f0543bae7f5f3d1dc33d96e222d5908ae0026051f98883197d20f750662e7e",
          "md5": "c1b2ef48be210b9df298842703802726",
          "sha256": "c5faa06dbd8f666241d7d3a98ef8ea6d0787c912279bc8f6a99092928ee338c0"
        },
        "downloads": -1,
        "filename": "generic_scpi_driver-1.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "c1b2ef48be210b9df298842703802726",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 30234,
        "upload_time": "2021-03-16T11:11:31",
        "upload_time_iso_8601": "2021-03-16T11:11:31.155484Z",
        "url": "https://files.pythonhosted.org/packages/f8/f0/543bae7f5f3d1dc33d96e222d5908ae0026051f98883197d20f750662e7e/generic_scpi_driver-1.3.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f8f0543bae7f5f3d1dc33d96e222d5908ae0026051f98883197d20f750662e7e",
        "md5": "c1b2ef48be210b9df298842703802726",
        "sha256": "c5faa06dbd8f666241d7d3a98ef8ea6d0787c912279bc8f6a99092928ee338c0"
      },
      "downloads": -1,
      "filename": "generic_scpi_driver-1.3.2.tar.gz",
      "has_sig": false,
      "md5_digest": "c1b2ef48be210b9df298842703802726",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 30234,
      "upload_time": "2021-03-16T11:11:31",
      "upload_time_iso_8601": "2021-03-16T11:11:31.155484Z",
      "url": "https://files.pythonhosted.org/packages/f8/f0/543bae7f5f3d1dc33d96e222d5908ae0026051f98883197d20f750662e7e/generic_scpi_driver-1.3.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}