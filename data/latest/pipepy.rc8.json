{
  "info": {
    "author": "Konstantinos Bairaktaris",
    "author_email": "ikijob@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "A Python library for invoking and interacting with shell commands.\n\n[![Build](https://github.com/kbairak/pipepy/workflows/Test%20suite/badge.svg)](https://github.com/kbairak/pipepy/actions)\n\n## Table of contents\n\n<!--ts-->\n* [Table of contents](#table-of-contents)\n* [Why? Comparison with other similar frameworks](#why-comparison-with-other-similar-frameworks)\n* [Installation and testing](#installation-and-testing)\n* [Intro, basic usage](#intro-basic-usage)\n* [Customizing commands](#customizing-commands)\n* [Laziness](#laziness)\n   * [Background commands](#background-commands)\n* [Redirecting output from/to files](#redirecting-output-fromto-files)\n* [Pipes](#pipes)\n* [Interacting with background processes](#interacting-with-background-processes)\n* [Altering the behavior of commands](#altering-the-behavior-of-commands)\n* [Miscellaneous](#miscellaneous)\n* [pymake](#pymake)\n* [TODOs](#todos)\n\n<!-- Added by: kbairak, at: Sun Mar 14 11:07:26 PM EET 2021 -->\n\n<!--te-->\n\n## Why? Comparison with other similar frameworks\n\n1. **[Xonsh](https://xon.sh/)**: Xonsh allows you to combine shell and Python\n   and enables very powerful scripting and interactive sessions. This library\n   does the same to a limited degree. However, Xonsh introduces a new language\n   that is a superset of Python. The main goal of this library that sets it\n   apart is that it is intended to be a pure Python implementation, mainly\n   aimed at scripting.\n\n2. **[sh](https://github.com/amoffat/sh)** and\n   **[pieshell](https://github.com/redhog/pieshell)**: These are much closer to\n   the current library in that they are pure Python implementations. The\n   current library, however, tries to improve on the following aspects:\n\n   - It tries to apply more syntactic sugar to make the invocations feel more\n     like shell invocations.\n\n   - It tries to offer ways to have shell commands interact with python code in\n     powerful and intuitive ways.\n\n## Installation and testing\n\n```sh\npython -m pip install pipepy\n\n```\n\nOr, if you want to modify the code while trying it out:\n\n```sh\ngit clone https://github.com/kbairak/pipepy\ncd pipepy\npython -m pip install  -e .\n```\n\nTo run the tests, you need to first install the testing requirements:\n\n```sh\npython -m pip install -r test_requirements.txt\n\npymake test\n# or\npytest\n```\n\nThere are a few more `pymake` targets to assist with testing during\ndevelopment:\n\n- `covtest`: Produces and opens a coverage report\n- `watchtest`: Listens for changes in the source code files and reruns the\n  tests automatically\n- `debugtest`: Runs the tests without capturing their output so that you can\n  insert a debug statement\n\n_`pymake` is a console script that is part of `pipepy` that aims to be a\nreplacement for GNU `make`, with the difference that the `Makefile`s are\nwritten in Python. More on this [below](#pymake)._\n\n## Intro, basic usage\n\n```python\nfrom pipepy import ls, grep\n\nprint(ls)  # prints contents of current folder\nif ls | grep('info.txt'):\n      print('info.txt found')\n```\n\nMost shell commands are importable straight from the `pipepy` module. Dashes in\ncommands' names are converted to underscore (`docker-compose` →\n`docker_compose`). Commands that cannot be found automatically can be created\nwith the PipePy constructor:\n\n```python\nfrom pipepy import PipePy\n\ncustom_command = PipePy('./bin/custom')\npython_script = PipePy('python', 'script.py')\n```\n\n## Customizing commands\n\nCalling a command with non empty arguments will return a modified unevaluated\ncopy. So the following are equivalent:\n\n```python\nfrom pipepy import PipePy\nls_l = PipePy('ls', '-l')\n# Is equivalent to\nls_l = PipePy('ls')('-l')\n```\n\nThere is a number of other ways you can customize a command:\n\n- **Globs**: globbing will be applied to all positional arguments:\n\n  ```python\n  from pipepy import echo\n  print(echo('*'))  # Will print all files in the current folder\n  ```\n\n  You can use `glob.escape` if you want to avoid this functionality:\n\n  ```python\n  import glob\n  from pipepy import ls, echo\n\n  print(ls)\n  # <<< **a *a *aa\n\n  print(echo('*a'))\n  # <<< **a *a *aa\n\n  print(echo(glob.escape('*a')))\n  # <<< *a\n  ```\n\n- **Keyword arguments**:\n\n  ```python\n  from pipepy import ls\n  ls(sort=\"size\")     # Equivalent to ls('--sort=size')\n  ls(I=\"files.txt\")   # Equivalent to ls('-I', 'files.txt')\n  ls(sort_by=\"size\")  # Equivalent to ls('--sort-by=size')\n  ls(escape=True)     # Equivalent to ls('--escape')\n  ls(escape=False)    # Equivalent to ls('--no-escape')\n  ```\n\n  Since keyword arguments come after positional arguments, if you want the\n  final command to have a different ordering you can invoke the command\n  multiple times:\n\n  ```python\n  from pipepy import ls\n  ls('-l', sort=\"size\")  # Equivalent to ls('-l', '--sort=size')\n  ls(sort=\"size\")('-l')  # Equivalent to ls('--sort=size', '-l')\n  ```\n\n- **Attribute access**:\n\n  ```python\n  from pipepy import git\n  git.push.origin.bugfixes  # Equivalent to git('push', 'origin', 'bugfixes')\n  ```\n\n- **Minus sign**:\n\n  ```python\n  from pipepy import ls\n  ls - 'l'        # Equivalent to ls('-l')\n  ls - 'default'  # Equivalent to ls('--default')\n  ```\n\n  This is to enable making the invocations look more like the shell:\n\n  ```python\n  from pipepy import ls\n  l, t = 'l', 't'\n  ls -l -t  # Equivalent to ls('-l', '-t')\n  ```\n\n  You can call `pipepy.overload_chars(locals())` in your script to assign all\n  ascii letters to variables of the same name.\n\n  ```python\n  import pipepy\n  from pipepy import ls\n  pipepy.overload_chars(locals())\n  ls -l -t  # Equivalent to ls('-l', '-t')\n  ```\n\n\n## Laziness\n\nCommands are evaluated lazily. For example, this will not actually do anything:\n\n```python\nfrom pipepy import wget\nwget('http://...')\n```\n\nInvoking a `PipePy` instance with non-empty arguments will return an\n**unevaluated** copy supplied with the extra arguments. A command will be\nevaluated when its output is used. This can be done with the following ways:\n\n- Accessing the `returncode`, `stdout` and `stderr` properties:\n\n   ```python\n   from pipepy import echo\n   command = echo(\"hello world\")\n   command.returncode\n   # <<< 0\n   command.stdout\n   # <<< 'hello world\\n'\n   command.stderr\n   # <<< ''\n   ```\n\n- Evaluating the command as a string object\n\n  ```python\n  from pipepy import ls\n  result = str(ls)\n  # or\n  print(ls)\n  ```\n\n  Converting a command to a `str` returns its `stdout`.\n\n- Evaluating the command as a boolean object:\n\n  ```python\n  from pipepy import ls, grep\n  command = ls | grep('info.txt')\n\n  bool(command)\n  # <<< True\n\n  if command:\n      print(\"info.txt found\")\n  ```\n\n  The command will be truthy if its `returncode` is 0.\n\n- Invoking the `.as_table()` method:\n\n  ```python\n  from pipepy import ps\n  ps.as_table()\n  # <<< [{'PID': '11233', 'TTY': 'pts/4', 'TIME': '00:00:01', 'CMD': 'zsh'},\n  # ...  {'PID': '17673', 'TTY': 'pts/4', 'TIME': '00:00:08', 'CMD': 'ptipython'},\n  # ...  {'PID': '18281', 'TTY': 'pts/4', 'TIME': '00:00:00', 'CMD': 'ps'}]\n  ```\n\n- Iterating over a command object:\n\n  ```python\n  from pipepy import ls\n  for filename in ls:\n      print(filename.upper)\n  ```\n\n  `command.iter_words()` iterates over the words of the command's `stdout`:\n\n  ```python\n  from pipepy import ps\n  list(ps.iter_words())\n  # <<< ['PID', 'TTY', 'TIME', 'CMD',\n  # ...  '11439', 'pts/5', '00:00:00', 'zsh',\n  # ...  '15532', 'pts/5', '00:00:10', 'ptipython',\n  # ...  '15539', 'pts/5', '00:00:00', 'ps']\n  ```\n\n- Redirecting the output to something else (this will be further explained\n  below):\n\n  ```python\n  from pipepy import ls, grep\n  ls > 'files.txt'\n  ls >> 'files.txt'\n  ls | grep('info.txt')  # `ls` will be evaluated, `grep` will not\n  ls | lambda output: output.upper()\n  ```\n\nIf you are not interested in the output of a command but want to evaluate it\nnevertheless, you can call it with empty arguments. So, this will actually\ninvoke the command (and wait for it to finish).\n\n```python\nfrom pipepy import wget\nwget('http://...')()\n```\n\n### Background commands\n\nCalling `.delay()` on a `PipePy` instance will return a copy that, although not\nevaluated, will have started running in the background (taking inspiration from\nCelery's [`.delay()`](https://docs.celeryproject.org/en/stable/reference/celery.app.task.html#celery.app.task.Task.delay)\nmethod for the name). Again, if you try to access its output, it will perform\nthe rest of the evaluation process, which is simply to wait for it to finish:\n\n```python\nfrom pipepy import wget\nurls = [...]\n\n# All downloads will happen in the background simultaneously\ndownloads = [wget(url).delay() for url in urls]\n\n# You can do something else here in Python while the downloads are working\n\n# This will call __bool__ on all downloads and thus wait for them\nif not all(downloads):\n   print(\"Some downloads failed\")\n```\n\nIf you are not interested in the output of a background command, you should\ntake care at some point to call `.wait()` on it. Otherwise its process will not\nbe waited for and if the parent Python process ends, it will kill all the\nbackground processes:\n\n```python\nfrom pipepy import wget\ndownload = wget('...').delay()\n# Do something else\ndownload.wait()\n```\n\nYou can supply the optional `timeout` argument to `wait`. If the timeout is\nset, it expires and the process hasn't finished, a `TimeoutExpired` exception\nwill be raised. (This is the same `TimeoutExpired` exception class from the\n`subprocess` module but you can import it from the `pipepy` module too)\n\n```python\nfrom pipepy import sleep\ncommand = sleep(100).delay()\ncommand.wait(5)\n# <<< TimeoutExpired: Command '['sleep', '30']' timed out after 5 seconds\n```\n\nAt any point, you can call `pipepy.jobs()` to get a list of non-waited-for\ncommands. In case you want to do some cleaning up, there is also a\n`pipepy.wait_jobs()` function. This should be used with care however as, if any\nof the background jobs aren't finished or are stuck, `wait_jobs()` may hang for\nan unknown amount of time. `wait_jobs` also accepts the optional `timeout`\nargument.\n\n## Redirecting output from/to files\n\nThe `>`, `>>` and `<` operators work similar to how they work in a shell:\n\n```python\nls               >  'files.txt'  # Will overwrite files.txt\nls               >> 'files.txt'  # Will append to files.txt\ngrep('info.txt') <  'files.txt'  # Will use files.txt as input\n```\n\nThese also work with file-like objects:\n\n```python\nimport os\nfrom pipepy import ls, grep\n\nbuf = io.StringIO()\nls > buf\nls('subfolder') >> buf\n\nbuf.seek(0)\ngrep('filename') < buf\n```\n\nIf you want to combine input and output redirections, you have to put the first\nredirection inside parentheses because of how python likes to deal with\ncomparison chains:\n\n```python\nfrom pipepy import gzip\ngzip = gzip(_text=False)\ngzip < 'uncompressed.txt' > 'uncompressed.txt.gz'    # Wrong!\n(gzip < 'uncompressed.txt') > 'uncompressed.txt.gz'  # Correct!\n```\n\n## Pipes\n\nThe `|` operator is used to customize where a command gets its input from and\nwhat it does with its output. Depending on the types of the operands, different\nbehaviors will emerge:\n\n### 1. Both operands are `PipePy` instances\n\nIf both operands are commands, the result will be as similar as possible to\nwhat would have happened in a shell:\n\n```python\nfrom pipepy import git, grep\nif git.diff(name_only=True) | grep('readme.txt'):\n      print(\"readme was changed\")\n```\n\nIf the left operand was previously evaluated, then it's output (`stdout`) will\nbe passed directly as input to the right operand. Otherwise, both commands will\nbe executed in parallel and `left`'s output will be streamed into `right`.\n\n### 2. Left operand is any kind of iterable (including string)\n\nIf the left operand is any kind of iterable, its elements will be fed to the\ncommand's stdin one by one:\n\n```python\nimport random\nfrom pipepy import grep\n\nresult = [\"John is 18 years old\\n\", \"Mary is 25 years old\"] | grep(\"Mary\")\nprint(result)\n# <<< Mary is 25 years old\n\ndef my_stdin():\n      for _ in range(500):\n            yield f\"{random.randint(1, 100)}\\n\"\n\nresult = my_stdin() | grep(17)\nprint(result)\n# <<< 17\n# ... 17\n# ... 17\n# ... 17\n# ... 17\n```\n\nIf it's a string, it will be fed all at once\n\n```python\nresult = \"John is 18 years old\\nMary is 25 years old\" | grep(\"Mary\")\n\n# Equivalent to\n\nresult = [\"John is 18 years old\\nMary is 25 years old\"] | grep(\"Mary\")\n```\n\nIn both cases, ie in all cases where the right operand is a `PipePy` object,\nthe return value of the pipe operation will be an **unevaluated** copy, which\nwill be evaluated when we try to access its output. This means that we can take\nadvantage of our usual background functionality:\n\n```python\nfrom pipepy import find, xargs\ncommand = find('.') | xargs.wc\ncommand = command.delay()\n\n# Do something else in the meantime\n\nfor line in command:  # Here we wait for the command to finish\n    linecount, wordcount, charcount, filename = line.split()\n    # ...\n```\n\nIt also means that the left operand, if it's an iterable, will be consumed when\nthe command is evaluated.\n\n```python\nfrom pipepy import grep\n\niterable = (line for line in [\"foo\\n\", \"bar\\n\"])\ncommand = iterable | grep(\"foo\")\ncommand.stdout\n# <<< 'foo\\n'\nlist(iterable)\n# <<< []\n\niterable = (line for line in [\"foo\\n\", \"bar\\n\"])\ncommand = iterable | grep(\"foo\")\nlist(iterable)  # Lets consume the iterable prematurely\n# <<< [\"foo\\n\", \"bar\\n\"]\ncommand.stdout\n# <<< ''\n```\n\nAlso, if you prefer an invocation style that resembles a function call more\nthan a shell pipe operation, ie if you want to pass a command's input as an\nargument, you can use the `_input` keyword argument:\n\n```python\nfrom pipepy import grep, ls\n\ngrep('setup', _input=ls)\n# Is equivalent to\nls | grep('setup')\n```\n\nor use the square-bracket notation:\n\n```python\nfrom pipepy import grep, ls\n\ngrep('setup')[ls]\n# Is equivalent to\nls | grep('setup')\n```\n\n_(We use parentheses for arguments and square brackets for input because\nparentheses allow us to take advantage of keyword arguments which are a good\nfit for command-line options)_\n\nThis works both for inputs that are iterables and commands.\n\n### 3. Right operand is a function\n\nThe function's arguments need to either be:\n\n- a subset of `returncode`, `output`, `errors` or\n- a subset of `stdout`, `stderr`\n\nThe ordering of the arguments is irrelevant since the function's signature will\nbe inspected to assign the proper values.\n\nIn the first case, the command will be waited for and its evaluated output will\nbe made available to the function's arguments.\n\n```python\nfrom pipepy import wc\n\ndef lines(output):\n    for line in output.splitlines():\n        try:\n            lines, words, chars, filename = line.split()\n        except ValueError:\n            continue\n        print(f\"File {filename} has {lines} lines, {words} words and {chars} \"\n              \"characters\")\n\nwc('*') | lines\n# <<< File demo.py has 6 lines, 15 words and 159 characters\n# ... File main.py has 174 lines, 532 words and 4761 characters\n# ... File interactive2.py has 10 lines, 28 words and 275 characters\n# ... File interactive.py has 12 lines, 34 words and 293 characters\n# ... File total has 202 lines, 609 words and 5488 characters\n```\n\nIn the second case, the command and the function will be executed in parallel\nand the command's `stdout` and `stderr` streams will be made available to the\nfunction.\n\n```python\nimport re\nfrom pipepy import ping\n\ndef mean_ping(stdout):\n    pings = []\n    for line in stdout:\n        match = re.search(r'time=([\\d\\.]+) ms$', line.strip())\n        if not match:\n            continue\n        time = float(match.groups()[0])\n        pings.append(time)\n        if len(pings) % 10 == 0:\n            print(f\"Mean time is {sum(pings) / len(pings)} ms\")\n\nping('-c', 30, \"google.com\") | mean_ping\n# >>> Mean time is 71.96000000000001 ms\n# ... Mean time is 72.285 ms\n# ... Mean time is 72.19666666666667 ms\n```\n\nIf the command ends before the function, then `next(stdout)` will raise a\n`StopIteration`. If the function ends before the command, the command's `stdin`\nwill be closed.\n\nThe return value of the pipe operation will be the return value of the\nfunction. The function can even include the word `yield` and thus return a\ngenerator that can be piped into another command.\n\nPutting all of this together, we can do things like:\n\n```python\nfrom pipepy import cat, grep\n\ndef my_input():\n    yield \"line one\\n\"\n    yield \"line two\\n\"\n    yield \"line two\\n\"\n    yield \"something else\\n\"\n    yield \"line three\\n\"\n\ndef my_output(stdout):\n    for line in stdout:\n        yield line.upper()\n\nprint(my_input() | cat | grep('line') | my_output | grep(\"TWO\"))\n# <<< LINE TWO\n# ... LINE TWO\n```\n\n### 4. Right operand is a generator\n\nThis is one of the more exotic forms of piping. Here we take advantage of\nPython's\n[passing values into a generator](https://docs.python.org/3/howto/functional.html?highlight=sending%20generator#passing-values-into-a-generator)\nfunctionality. The original generator must send and receive data with the\n`a = (yield b)` syntax. The result of the pipe operation will be another\ngenerator that will yield whatever the original generator yields while, in the\noriginal generator, the return value of each `yield` command will be the next\nnon-empty line of the `PipePy` instance:\n\n```python\nfrom pipepy import echo\n\ndef upperize():\n    line = yield\n    while True:\n        line = (yield line.upper())\n\n# Remember, `upperize` is a function, `upperize()` is a generator\nlist(echo(\"aaa\\nbbb\") | upperize())\n# <<< [\"AAA\\n\", \"BBB\\n\"]\n```\n\nAnd, since the return value of the pipe operation is a generator, it can be\npiped into another command:\n\n```python\nprint(echo(\"aaa\\nbbb\") | upperize() | grep(\"AAA\"))\n# <<< AAA\n```\n\n## Interacting with background processes\n\nThere are 3 ways to interact with a background process: _read-only_,\n_write-only_ and _read/write_. We have already covered _read-only_ and\n_write-only_:\n\n### 1. Incrementally sending data to a command\n\nThis is done by piping from an iterable to a command. The command actually runs\nin in parallel with the iterable and the iterable's data is fed to the command\nas it becomes available. We will slightly modify the previous example to better\ndemonstrate this:\n\n```python\nimport random\nimport time\nfrom pipepy import grep\n\ndef my_stdin():\n    start = time.time()\n    for _ in range(500):\n        time.sleep(.01)\n        yield f\"{time.time() - start} {random.randint(1, 100)}\\n\"\n\ncommand = my_stdin() | grep('-E', r'\\b17$', _stream_stdout=True)\ncommand()\n# <<< 0.3154888153076172 17\n# ... 1.5810892581939697 17\n# ... 1.7773401737213135 17\n# ... 2.8303775787353516 17\n# ... 3.4419643878936768 17\n# ... 4.511774301528931  17\n```\n\nHere, `grep` is actually run in in parallel with the generator and matches are\nprinted as they are found since the command's output is being streamed to the\nconsole, courtesy of the `_stream_stdout` argument (more on this\n[below](#streaming-to-console)).\n\n### 2. Incrementally reading data from a command\n\nThis can be done either by piping the output of a command to a function with a\nsubset of `stdin`, `stdout` and `stderr` as its arguments, or a generator, as\nwe demonstrated [before](#3-right-operand-is-a-function), or by iterating over\na command's output:\n\n```python\nimport time\nfrom pipepy import ping\n\nstart = time.time()\nfor line in ping('-c', 3, 'google.com'):\n    print(time.time() - start, line.strip().upper())\n# <<< 0.15728354454040527 PING GOOGLE.COM (172.217.169.142) 56(84) BYTES OF DATA.\n# ... 0.1574106216430664  64 BYTES FROM SOF02S32-IN-F14.1E100.NET (172.217.169.142): ICMP_SEQ=1 TTL=103 TIME=71.8 MS\n# ... 1.1319730281829834  64 BYTES FROM 142.169.217.172.IN-ADDR.ARPA (172.217.169.142): ICMP_SEQ=2 TTL=103 TIME=75.3 MS\n# ... 2.1297826766967773  64 BYTES FROM 142.169.217.172.IN-ADDR.ARPA (172.217.169.142): ICMP_SEQ=3 TTL=103 TIME=73.4 MS\n# ... 2.129857063293457\n# ... 2.129875659942627   --- GOOGLE.COM PING STATISTICS ---\n# ... 2.1298911571502686  3 PACKETS TRANSMITTED, 3 RECEIVED, 0% PACKET LOSS, TIME 2004MS\n# ... 2.129910707473755   RTT MIN/AVG/MAX/MDEV = 71.827/73.507/75.253/1.399 MS\n```\n\nAgain, the `ping` command is actually run in parallel with the body of the\nfor-loop and each line is given to the body of the for-loop as it becomes\navailable.\n\n### 3. Reading data from and writing data to a command\n\nLets assume we have a command that makes the user take a math quiz. A normal\ninteraction with this command would look like this:\n\n```\n→ math_quiz\n3 + 4 ?\n→ 7\nCorrect!\n8 + 2 ?\n→ 12\nWrong!\n→ Ctrl-d\n```\n\nUsing python to interact with this command in a read/write fashion can be done\nwith a `with` statement:\n\n```python\nfrom pipepy import math_quiz\n\nresult = []\nwith math_quiz as (stdin, stdout, stderr):\n    stdout = (line.strip() for line in stdout if line.strip())\n    try:\n        for _ in range(3)\n            question = next(stdout)\n            a, _, b, _ = question.split()\n            answer = str(int(a) + int(b))\n            stdin.write(answer + \"\\n\")\n            stdin.flush()\n            verdict = next(stdout)\n            result.append((question, answer, verdict))\n    except StopIteration:\n        pass\n\nresult\n# <<< [('10 + 7 ?', '17', 'Correct!'),\n# ...  ('5 + 5 ?', '10', 'Correct!'),\n# ...  ('5 + 5 ?', '10', 'Correct!')]\n```\n\n`stdin`, `stdout` and `stderr` are the open file streams of the background\nprocess. When the body of the `with` block finishes, an EOF is sent to the\nprocess and it is waited for.\n\nYou need to remember to end lines fed to `stdin` with a newline character if\nthe command expects it. Also, don't forget to call `stdin.flush()` every now\nand then.\n\nYou can call `with` on a pipe expression that involves `PipePy` objects. In\nthat case, each `PipePy` object's `stdout` will be connected to the next one's\n`stdin`, the `stdin` offered to the body of the `with` block will be the\n`stdin` of the leftmost command and the `stdout` and `stderr` offered to the\nbody of the `with` block will be the `stdout` and `stderr` of the rightmost\ncommand:\n\n```python\nfrom pipepy import cat, grep\n\ncommand = cat | grep(\"foo\") | cat | cat | cat  # We might as well keep going\nwith command as (stdin, stdout, stderr):\n    stdin.write(\"foo1\\n\")\n    stdin.write(\"bar2\\n\")\n    stdin.write(\"foo3\\n\")\n    stdin.close()\n    assert next(stdout).strip() == \"foo1\"\n    assert next(stdout).strip() == \"foo3\"\n```\n\n## Altering the behavior of commands\n\n### Binary mode\n\nAll commands are executed in text mode, which means that they deal with `str`\nobjects. This can cause problems. For example:\n\n```python\nfrom pipepy import gzip\nresult = \"hello world\" | gzip\nprint(result.stdout)\n# <<< Traceback (most recent call last):\n# ... ...\n# ... UnicodeDecodeError: 'utf-8' codec can't decode byte 0x8b in position 1: invalid start byte\n```\n\n`gzip` cannot work in text mode because its output is binary data that cannot\nbe utf-8-decoded. When text mode is not desirable, a command can be converted\nto binary mode setting its `_text` parameter to `False`:\n\n```python\nfrom pipepy import gzip\ngzip = gzip(_text=False)\nresult = \"hello world\" | gzip\nprint(result.stdout)\n# <<< b'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xcbH\\xcd\\xc9\\xc9W(\\xcf/\\xcaI\\xe1\\x02\\x00-;\\x08\\xaf\\x0c\\x00\\x00\\x00'\n```\n\nInput and output will be converted from/to binary by using the 'UTF-8'\nencoding. In the previous example, our input's type was `str` and was\nutf-8-encoded before being fed into `gzip`. You can change the encoding with\nthe `_encoding` keyword argument:\n\n```python\nfrom pipepy import gzip\ngzip = gzip(_text=False)\nresult = \"καλημέρα\" | gzip\nprint(result.stdout)\n# <<< b'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x01\\x10\\x00\\xef\\xff\\xce\\xba\\xce\\xb1\\xce\\xbb\\xce\\xb7\\xce\\xbc\\xce\\xad\\xcf\\x81\\xce\\xb1\"\\x15g\\xab\\x10\\x00\\x00\\x00'\nresult = \"καλημέρα\" | gzip(_encoding=\"iso-8859-7\")\nprint(result.stdout)\n# <<< b'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03{\\xf5\\xf0\\xf5\\xf37w?>\\x04\\x00\\x1c\\xe1\\xc0\\xf7\\x08\\x00\\x00\\x00'\n```\n\n### Streaming to console\n\nDuring invocation, you can set the `_stream_stdout` and `_stream_stderr`\nkeyword arguments to `True`. This means that the respective stream will not be\ncaptured by the result, but streamed to the console. This allows the user to\ninteract with interactive commands. Consider the following 2 examples:\n\n1. **[fzf](https://github.com/junegunn/fzf)** works like this:\n\n   1. It gathers a list of choices from its `stdin`\n   2. It displays the choices on `stderr`, constantly refreshing it depending\n      on what the user inputs\n   3. It starts directly capturing keystrokes on the keyboard, bypassing\n      `stdin`, to allow the user to make their choice.\n   4. When the user presses Enter, it prints the choice to its `stdout`\n\n   Taking all this into account, we can do the following:\n\n   ```python\n   from pipepy import fzf\n   fzf = fzf(_stream_stderr=True)\n\n   # This will open an fzf session to let us choose between \"John\" and \"Mary\"\n   print(\"John\\nMary\" | fzf)\n   # <<< Mary\n   ```\n\n2. **[dialog](https://invisible-island.net/dialog/)** works similar to `fzf`,\n   but swaps `stdout` with `stderr`:\n\n   1. It gathers a list of choices from its arguments\n   2. It displays the choices on `stdout`, constantly refreshing it depending\n      on what the user inputs\n   3. It starts directly capturing keystrokes on the keyboard, bypassing\n      `stdin`, to allow the user to make their choice.\n   4. When the user presses Enter, it prints the choice to its `stderr`\n\n   Taking all this into account, we can do the following:\n\n   ```python\n   from pipepy import dialog\n   dialog = dialog(_stream_stdout=True)\n\n   # This will open a dialog session to let us choose between \"John\" and \"Mary\"\n   result = dialog(checklist=True)('Choose name', 30, 110, 0,\n                                   \"John\", '', \"on\",\n                                   \"Mary\", '', \"off\")\n   print(result.stderr)\n   # <<< John\n   ```\n\nAlso, during a script, you may not be interested in capturing the output of a\ncommand but may want to stream it to the console to show the command's output\nto the user. You can force a command sto stream its whole output by setting the\n`_stream` parameter:\n\n```python\nfrom pipepy import wget\n\nwget('https://...', _stream=True)()\n```\n\nWhile `stdout` and `stderr` will not be captured, `returncode` will and thus\nyou can still use the command in boolean expressions:\n\n```python\nfrom pipepy import wget\n\nif wget('https://...', _stream=True):\n     print(\"Download succeeded\")\nelse:\n     print(\"Download failed\")\n```\n\nYou can call `pipepy.set_always_stream(True)` to make streaming to the console\nthe default behavior. This may be desirable in some situations, like Makefiles\n(see [below](#pymake)).\n\n```python\nimport pipepy\nfrom pipepy import ls\npipepy.set_always_stream(True)\nls()  # Alsost equivalent to `ls(_stream=True)()`\npipepy.set_always_stream(False)\n```\n\nSimilarly to how setting `_stream=True` forces a command to stream its output\nto the console, setting `_stream=False` forces it to capture its output even if\n`set_always_stream` has been called:\n\n```python\nimport pipepy\nfrom pipepy import ls\n\npipepy.set_always_stream(True)\nls()                 # Will stream its output\nls(_stream=False)()  # Will capture its output\npipepy.set_always_stream(False)\n```\n\n### Exceptions\n\nYou can call `.raise_for_returncode()` on an **evaluated** result to raise an\nexception if its returncode is not 0 (think of\n[requests's `.raise_for_status()`](https://requests.readthedocs.io/en/master/api/#requests.Response.raise_for_status)):\n\n```python\nfrom pipepy import ping, PipePyError\nresult = ping(\"asdf\")()  # Remember, we have to evaluate it first\n\nresult.raise_for_returncode()\n# <<< PipePyError: (2, '', 'ping: asdf: Name or service not known\\n')\n\ntry:\n    result.raise_for_returncode()\nexcept PipePyError as exc:\n    print(exc.returncode)\n    # <<< 2\n    print(exc.stdout)\n    # <<< \"\"\n    print(exc.stderr)\n    # <<< ping: asdf: Name or service not known\n```\n\nYou can call `pipepy.set_always_raise(True)` to have **all** commands raise an\nexception if their returncode is not zero.\n\n```python\nimport pipepy\nfrom pipepy import ping\npipepy.set_always_raise(True)\nping(\"asdf\")()\n# <<< PipePyError: (2, '', 'ping: asdf: Name or service not known\\n')\n```\n\nIf \"always raise\" is set, you can still force a command to suppress its\nexception by setting `_raise=False`:\n\n```python\nimport pipepy\nfrom pipepy import ping\npipepy.set_always_raise(True)\ntry:\n    ping(\"asdf\")()  # Will raise an exception\nexcept Exception as exc:\n    print(exc)\n# <<< PipePyError: (2, '', 'ping: asdf: Name or service not known\\n')\n\ntry:\n    ping(\"asdf\", _raise=False)()  # Will not raise an exception\nexcept Exception as exc:\n    print(exc)\n```\n\n### \"Interactive\" mode\n\nWhen \"interactive\" mode is set, the `__repr__` method will simply return\n`self.stdout + self.stderr`. This enables some very basic functionality for the\ninteractive python shell. To set interactive mode, run\n`pipepy.set_interactive(True)`:\n\n```python\nimport pipepy\nfrom pipepy import ls, overload_chars\npipepy.set_interactive(True)\nls\n# <<< demo.py\n# ... interactive2.py\n# ... interactive.py\n# ... main.py\n\noverload_chars(locals())\nls -l\n# <<< total 20\n# ... -rw-r--r-- 1 kbairak kbairak  159 Feb  7 22:05 demo.py\n# ... -rw-r--r-- 1 kbairak kbairak  275 Feb  7 22:04 interactive2.py\n# ... -rw-r--r-- 1 kbairak kbairak  293 Feb  7 22:04 interactive.py\n# ... -rw-r--r-- 1 kbairak kbairak 4761 Feb  8 20:42 main.py\n```\n\n### Making alterations \"permanent\"\n\nSince `PipePy` objects treat their list of arguments as list of strings simply\npassed onto the `subprocess.Popen` function, and since there is no special\nsignificance to the first argument even though it is technically the command\nbeing executed, you can crete `PipePy` instances with the alterations we\ndiscussed and use them as templates for commands that will inherit these\nalterations:\n\n```python\nstream_sh = PipePy(_stream=True)\nstream_sh\n# <<< PipePy()\nstream_sh._stream\n# <<< True\n\nstream_sh.ls\n# <<< PipePy('ls')\nstream_sh.ls._stream\n# <<< True\n\nr = stream_sh.ls()\n# <<< check_tag.py  Makefile.py     setup.cfg  tags\n# ... htmlcov       pyproject.toml  setup.py   test_requirements.txt\n# ... LICENSE       README.md       src\n\nr.stdout\n# <<< None\n\nr.returncode\n# <<< 0\n```\n\n```python\nraise_sh = PipePy(_raise=True)\nraise_sh\n# <<< PipePy()\nraise_sh.false\n# <<< PipePy('false')\nraise_sh.false()\n# <<< Traceback (most recent call last):\n# ... ...\n# ... pipepy.exceptions.PipePyError: (1, '', '')\n```\n\nThis can work as a more contained alternative to `set_always_stream` and\n`set_always_raise`.\n\n## Miscellaneous\n\n`.terminate()`, `.kill()` and `.send_signal()` simply forward the method call\nto the underlying\n[`Popen`](https://docs.python.org/3/library/subprocess.html#popen-objects)\nobject.\n\nHere are some utilities implemented within `pipepy` that don't make use of\nshell subprocesses, but we believe are useful for scripting.\n\n### `cd`\n\nIn its simplest form, `pipepy.cd` is an alias to `os.chdir`:\n\n```python\nfrom pipepy import cd, pwd\n\nprint(pwd())\n# <<< /foo\n\ncd('bar')\nprint(pwd())\n# <<< /foo/bar\n\ncd('..')\nprint(pwd())\n# <<< /foo\n```\n\nBut it can also be used as a context processor for temporary directory changes:\n\n```python\nprint(pwd())\n# <<< /foo\n\nwith cd(\"bar\"):\n    print(pwd())\n# <<< /foo/bar\n\nprint(pwd())\n# <<< /foo\n```\n\n### `export`\n\nIn its simplest form, `pipepy.export` is an alias to `os.environ.update`:\n\n```python\nimport os\nfrom pipepy import export\n\nprint(os.environ['HOME'])\n# <<< /home/foo\n\nexport(PATH=\"/home/foo/bar\")\nprint(os.environ['HOME'])\n# <<< /home/foo/bar\n```\n\nBut it can also be used as a context processor for temporary environment\nchanges:\n\n```python\nprint(os.environ['HOME'])\n# <<< /home/foo\n\nwith export(PATH=\"/home/foo/bar\"):\n    print(os.environ['HOME'])\n# <<< /home/foo/bar\n\nprint(os.environ['HOME'])\n# <<< /home/foo\n```\n\nIf an environment variable is further modified within the body of the `with`\nblock, it is not reverted upon exit:\n\n```python\nwith export(PATH=\"/home/foo/bar\"):\n    export(PATH=\"/home/foo/BAR\")\n\nprint(os.environ['HOME'])\n# <<< /home/foo/BAR\n```\n\n### `source`\n\nThe `source` function runs a bash script, extracts the resulting environment\nvariables that have been set in the script and saves them on the current\nenvironment. Similarly to `export`, it can be used as a context processor (in\nfact, it uses `export` internally):\n\n```bash\n# env\nexport AAA=aaa\n```\n\n```python\nimport os\nfrom pipepy import source\n\nwith source('env'):\n    print(os.environ['AAA'])\n# <<< aaa\n'AAA' in os.environ\n# <<< False\n\nsource('env')\nprint(os.environ['AAA'])\n# <<< aaa\n```\n\nThe following keyword-only arguments are available to `source`:\n\n- **recursive** (boolean, defaults to `False`): If set, all files with the same\n  name in the current directory and all its parents will be sourced, in reverse\n  order. This allows nesting of environment variables:\n\n  ```\n  - /\n    |\n    + - home/\n        |\n        - kbairak/\n          |\n          + - env:\n          |     export COMPOSE_PROJECT_NAME=\"pipepy\"\n          |\n          + - project/\n              |\n              + - env:\n                    export COMPOSE_FILE=\"docker-compose.yml:docker-compose-dev.yml\"\n  ```\n\n  ```python\n  from pipepy import cd, source, docker_compose\n  cd('/home/kbairak/project')\n  source('env', recursive=True)\n  # Now I have both `COMPOSE_PROJECT_NAME` and `COMPOSE_FILE`\n  ```\n\n  The files `/home/kbairak/env` and `/home/kbairak/project/env` were sourced,\n  in that order.\n\n- **quiet** (boolean, defaults to `True`): If the sourced file fails, `source`\n  will usually skip its sourcing without complaint and move on to the next one\n  (if `recursive` is set). With `quiet=False`, an exception will be raised and\n  the environment will not be updated.\n\n- **shell** (string, defaults to `'bash'`): The shell command used to perform\n  the sourcing.\n\n## pymake\n\nBundled with this library there is a command called `pymake` which aims to\nreplicate the syntax and behavior of GNU `make` as much as possible, but in\nPython. A `Makefile.py` file looks like this (this is actually part of the\nMakefile of the current library):\n\n```python\nimport pipepy\nfrom pipepy import python, rm\n\npipepy.set_always_stream(True)\npipepy.set_always_raise(True)\n\ndef clean():\n    rm('-rf', \"build\", \"dist\")()\n\ndef build(clean):\n    python('-m', \"build\")()\n\ndef publish(build):\n    python('-m', \"twine\").upload(\"dist/*\")()\n```\n\nYou can now run `pymake publish` to run the `publish` make target, along with\nits dependencies. The names of the functions' arguments are used to define the\ndependencies, so `clean` is a dependency of `build` and `build` is a dependency\nof `publish`.\n\n_(You don't have to use `pipepy` commands inside `Makefile.py`, but admittedly\nit's a very good fit)_\n\nThe arguments hold any return values of the dependency targets:\n\n```python\ndef a():\n    return 1\n\ndef b():\n    return 2\n\ndef c(a, b):\n    print(a + b)\n```\n\n```sh\n→ pymake c\n# ← 3\n```\n\nEach dependency will be executed at most once, even if it's used as a\ndependency more than once:\n\n```python\ndef a():\n    print(\"pymake target a\")\n\ndef b(a):\n    print(\"pymake target b\")\n\ndef c(a, b):\n    print(\"pymake target c\")\n```\n\n```sh\n→ pymake c\n# ← pymake target a\n# ← pymake target b\n# ← pymake target c\n```\n\nYou can set the `DEFAULT_PYMAKE_TARGET` global variable to define the default\ntarget.\n\n```python\nfrom pipepy import pytest\n\nDEFAULT_PYMAKE_TARGET = \"test\"\n\ndef test():\n    pytest(_stream=True)()\n```\n\n### `pymake` variables\n\nApart from dependencies, you can use function arguments to define variables\nthat can be overridden by the invocation of `pymake`. This can be done in 2\nways:\n\n1. Using the function's keyword arguments:\n\n   ```python\n   # Makefile.py\n\n   def greeting(msg=\"world\"):\n       print(f\"hello {msg}\")\n   ```\n\n   ```sh\n   → pymake greeting\n   # ← hello world\n   \n   → pymake greeting msg=Bill\n   # ← hello Bill\n   ```\n\n2. Using global variables defined in `Makefile.py`:\n\n   ```python\n   # Makefile.py\n\n   msg = \"world\"\n\n   def greeting():\n       print(f\"hello {msg}\")\n   ```\n\n   ```sh\n   → pymake greeting\n   # ← hello world\n   \n   → pymake greeting msg=Bill\n   # ← hello Bill\n   ```\n\n### Shell completion for `pymake`\n\n`pymake` supports shell completion for bash and zsh.\n\nIn bash, run:\n\n```sh\neval $(pymake --setup-bash-completion)\n```\n\nThen you will be able to see things like (example taken from `pipepy`'s\nMakefile):\n\n```\n[kbairak@kbairakdelllaptop pipepy]$ pymake <TAB><TAB>\nbuild      clean      debugtest  publish    watchtest\nchecks     covtest    html       test\n```\n\nIn zsh, run:\n\n```sh\neval $(pymake --setup-zsh-completion)\n```\n\nThen you will be able to see things like (example taken from `pipepy`'s\nMakefile):\n\n```\n(pipepy) ➜  pipepy git:(master) ✗ pymake <TAB>\nbuild      -- Build package\nchecks     -- Run static checks on the code (flake8, isort)\nclean      -- Clean up build directories\ncovtest    -- Run tests and produce coverge report\ndebugtest  -- Run tests without capturing their output. This makes using an interactive debugger possible\nhtml       -- Run tests and open coverage report in browser\npublish    -- Publish package to PyPI\ntest       -- Run tests\nwatchtest  -- Automatically run tests when a source file changes\n```\n\nThe descriptions are taken from the `pymake` targets' docstrings.\n\nYou can put the `eval` statements in your `.bashrc`/`.zshrc`.\n\n\n## TODOs\n\n- [x] Timeout for wait\n- [x] Redirect input/output from/to file-like objects\n- [ ] Stream and capture at the same time (wrapper class for file-like object?)\n- [ ] `with` blocks where PipePy invocations forward to the context's stdin, eg:\n\n  ```python\n  from pipepy import ssh\n  with ssh(\"some-host\") as host:\n      r = host.ls()  # Will actually send 'ls\\n' to ssh's stdin\n  ```\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/kbairak/pipepy",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pipepy",
    "package_url": "https://pypi.org/project/pipepy/",
    "platform": null,
    "project_url": "https://pypi.org/project/pipepy/",
    "project_urls": {
      "Homepage": "https://github.com/kbairak/pipepy"
    },
    "release_url": "https://pypi.org/project/pipepy/0.0.11/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "A Python library for invoking and interacting with shell commands",
    "version": "0.0.11",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15156008,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ceaa3f8cdb78280853f2934a90bb8abe7e2a6048add239ddc240a504fefd9834",
          "md5": "e5d9e0fd0ed37f1d07427f9ec33e0afc",
          "sha256": "d2eebfdee8f983ae951d027c4fde13b4ab7ef341ad8b1f87bd8226f81de576fb"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "e5d9e0fd0ed37f1d07427f9ec33e0afc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 26069,
        "upload_time": "2021-02-09T12:35:47",
        "upload_time_iso_8601": "2021-02-09T12:35:47.151994Z",
        "url": "https://files.pythonhosted.org/packages/ce/aa/3f8cdb78280853f2934a90bb8abe7e2a6048add239ddc240a504fefd9834/pipepy-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "85e51f874230b31d4a4710fba0b7146169245980c38976aeb68a958b79edc7ba",
          "md5": "69a7baff753130c0222944daf095e45c",
          "sha256": "96ac569840a3a2e4c8d939960739e1434520ef534a9bc10a7fe65cd067c9841c"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "69a7baff753130c0222944daf095e45c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 21329,
        "upload_time": "2021-02-09T12:35:49",
        "upload_time_iso_8601": "2021-02-09T12:35:49.826481Z",
        "url": "https://files.pythonhosted.org/packages/85/e5/1f874230b31d4a4710fba0b7146169245980c38976aeb68a958b79edc7ba/pipepy-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "795e5597c3e0f89748d8dc366be907979809d0248e62e6fb98e5165fcbf6f73a",
          "md5": "0fd2d33d75d9f66c324b55f08d167a9b",
          "sha256": "33982df15b974fa59a23a0efcc5daa7aede3fdd88b124791886c47bbbae1c398"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.10-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0fd2d33d75d9f66c324b55f08d167a9b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 38128,
        "upload_time": "2021-08-16T20:32:24",
        "upload_time_iso_8601": "2021-08-16T20:32:24.013018Z",
        "url": "https://files.pythonhosted.org/packages/79/5e/5597c3e0f89748d8dc366be907979809d0248e62e6fb98e5165fcbf6f73a/pipepy-0.0.10-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c10688bcd2131e776fc67d8cc384e0af3d896ff626c458bf22b1631c584c2086",
          "md5": "f4798e3594809581ff5576b891d534b5",
          "sha256": "12f611a9efb3b1791f5a7e23fe184e649a79fe838e1f85190aefa5970327c019"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.10.tar.gz",
        "has_sig": false,
        "md5_digest": "f4798e3594809581ff5576b891d534b5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 60337,
        "upload_time": "2021-08-16T20:32:26",
        "upload_time_iso_8601": "2021-08-16T20:32:26.121788Z",
        "url": "https://files.pythonhosted.org/packages/c1/06/88bcd2131e776fc67d8cc384e0af3d896ff626c458bf22b1631c584c2086/pipepy-0.0.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dbda5b15748bacea1c3a92a4a484d7f57a956f54b4b61eb1c995db3de7e13eda",
          "md5": "17ed153ec2c7e60a90c844f15f5fd45b",
          "sha256": "0ea7f1642103c10d549f97dd6226d43fb9b44f396920c8cbf330017d14ed0e4a"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.11-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "17ed153ec2c7e60a90c844f15f5fd45b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 44989,
        "upload_time": "2022-09-20T15:38:44",
        "upload_time_iso_8601": "2022-09-20T15:38:44.744613Z",
        "url": "https://files.pythonhosted.org/packages/db/da/5b15748bacea1c3a92a4a484d7f57a956f54b4b61eb1c995db3de7e13eda/pipepy-0.0.11-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ad2644fed51cd16e9fd56a028a51c3ee84d27a2dc88998e58a759a77b6beecb0",
          "md5": "17e585cef21a3134fc5e26bfaa4b8edd",
          "sha256": "34fc109f21db01b7c47cbb2cc752b62a514b93b209f3979186ea21c7ce890cf9"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.11.tar.gz",
        "has_sig": false,
        "md5_digest": "17e585cef21a3134fc5e26bfaa4b8edd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 65246,
        "upload_time": "2022-09-20T15:38:46",
        "upload_time_iso_8601": "2022-09-20T15:38:46.816774Z",
        "url": "https://files.pythonhosted.org/packages/ad/26/44fed51cd16e9fd56a028a51c3ee84d27a2dc88998e58a759a77b6beecb0/pipepy-0.0.11.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f6f6d8b8e818f4ff4ce09e22db2ee457a4ac39979f8a17e330b3707318d528fb",
          "md5": "a85b052e4918a82f17d922378d255438",
          "sha256": "21cd7243f7911b42ebd970a6b9753e98c3dc180d53bdc833fe3f3fb6cb30ad10"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.5-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a85b052e4918a82f17d922378d255438",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 26891,
        "upload_time": "2021-02-10T21:47:09",
        "upload_time_iso_8601": "2021-02-10T21:47:09.560110Z",
        "url": "https://files.pythonhosted.org/packages/f6/f6/d8b8e818f4ff4ce09e22db2ee457a4ac39979f8a17e330b3707318d528fb/pipepy-0.0.5-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d23800a89739c8dde82cf6b838825bea9853a5c3dabd83168ba0a030fb6c2498",
          "md5": "cc8e46958e725a80173377bcc36b82b3",
          "sha256": "2ce1c08db6a3eb180d671286d2c91242bc5207f601df8a62f18527ebe3964547"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.5.tar.gz",
        "has_sig": false,
        "md5_digest": "cc8e46958e725a80173377bcc36b82b3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 23897,
        "upload_time": "2021-02-10T21:47:11",
        "upload_time_iso_8601": "2021-02-10T21:47:11.029314Z",
        "url": "https://files.pythonhosted.org/packages/d2/38/00a89739c8dde82cf6b838825bea9853a5c3dabd83168ba0a030fb6c2498/pipepy-0.0.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "77aa342fad3342bac6e505fe18dd92b360c3f8bd7558ed739c1409cf765053cb",
          "md5": "595a52683cd89a70d10cbaa033afe5d3",
          "sha256": "99d1587030a927e99f4946168966784e83b135f1c805f1192c4a59849963a68d"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.6-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "595a52683cd89a70d10cbaa033afe5d3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 29735,
        "upload_time": "2021-02-11T20:16:42",
        "upload_time_iso_8601": "2021-02-11T20:16:42.131381Z",
        "url": "https://files.pythonhosted.org/packages/77/aa/342fad3342bac6e505fe18dd92b360c3f8bd7558ed739c1409cf765053cb/pipepy-0.0.6-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "38bbf6c8ad7aaa25efa3a675e4e564023c41ab71a0940fca65078c9860d2e0eb",
          "md5": "8273c196256db11770bf707e8b5cab99",
          "sha256": "ef3222e418b7e67cc04817c9a36ca27e7c0602e5a8861bcbd71a2ea5b36308e8"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.6.tar.gz",
        "has_sig": false,
        "md5_digest": "8273c196256db11770bf707e8b5cab99",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 30380,
        "upload_time": "2021-02-11T20:16:43",
        "upload_time_iso_8601": "2021-02-11T20:16:43.670400Z",
        "url": "https://files.pythonhosted.org/packages/38/bb/f6c8ad7aaa25efa3a675e4e564023c41ab71a0940fca65078c9860d2e0eb/pipepy-0.0.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6c825cffdcecc1dc340bbe933f9793065f322c5d1cb29e10ba2ec67d711614fd",
          "md5": "37f8e1d9cd1bffe4bef706bf3f991e72",
          "sha256": "b2f49315c07c15a34dfd78528a846e53387a759a10954237c208a204f2ca5a11"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.7-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "37f8e1d9cd1bffe4bef706bf3f991e72",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 33813,
        "upload_time": "2021-02-16T22:19:24",
        "upload_time_iso_8601": "2021-02-16T22:19:24.661600Z",
        "url": "https://files.pythonhosted.org/packages/6c/82/5cffdcecc1dc340bbe933f9793065f322c5d1cb29e10ba2ec67d711614fd/pipepy-0.0.7-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6fa5443695a5a9854d34ca20ea6a8e92751a1e9648884c8c089396d7539caa4d",
          "md5": "7f83039e343addf0a09059de7a0ba4ec",
          "sha256": "e6c2e0983abd340c65e47d4ee0b26e1055e95f30e5105cc4118b1018a4e831e8"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.7.tar.gz",
        "has_sig": false,
        "md5_digest": "7f83039e343addf0a09059de7a0ba4ec",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 40967,
        "upload_time": "2021-02-16T22:19:26",
        "upload_time_iso_8601": "2021-02-16T22:19:26.251941Z",
        "url": "https://files.pythonhosted.org/packages/6f/a5/443695a5a9854d34ca20ea6a8e92751a1e9648884c8c089396d7539caa4d/pipepy-0.0.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.8": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "64a5cfc0d892cefe9f2d0d8808947a1008e41fdd8acbed0b75c07a17fcc94780",
          "md5": "474b63ebed22d6d0cf1dc11bcf8575ff",
          "sha256": "dcef574f89c5af8b5e5e9d78d0eb8f4211d2a9440af9018e3d3eb6ff99113ecf"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.8-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "474b63ebed22d6d0cf1dc11bcf8575ff",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 37955,
        "upload_time": "2021-02-27T13:24:23",
        "upload_time_iso_8601": "2021-02-27T13:24:23.140276Z",
        "url": "https://files.pythonhosted.org/packages/64/a5/cfc0d892cefe9f2d0d8808947a1008e41fdd8acbed0b75c07a17fcc94780/pipepy-0.0.8-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7cfb88aa6825c40c467a56ab681586ab9cb493622ab3090aebbd4d0448d17903",
          "md5": "61c608591fbe0c193a6460198bd13afa",
          "sha256": "22021237540aa739c75a4db0a1902e3886071758c699a7653ca0d69972120826"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.8.tar.gz",
        "has_sig": false,
        "md5_digest": "61c608591fbe0c193a6460198bd13afa",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 49568,
        "upload_time": "2021-02-27T13:24:25",
        "upload_time_iso_8601": "2021-02-27T13:24:25.362080Z",
        "url": "https://files.pythonhosted.org/packages/7c/fb/88aa6825c40c467a56ab681586ab9cb493622ab3090aebbd4d0448d17903/pipepy-0.0.8.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.9": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2229ddb3a74954c5691181ef5a937529efee254d5ef41ff73c78725e0e97db7c",
          "md5": "a257908cf964866f32ba984a4ddb4cc6",
          "sha256": "23ac4eea0ce3810a4a0675b80cb3fa0301f0c715f7f65b5a7298e7d892891d4d"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.9-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "a257908cf964866f32ba984a4ddb4cc6",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 38086,
        "upload_time": "2021-03-14T21:16:21",
        "upload_time_iso_8601": "2021-03-14T21:16:21.492808Z",
        "url": "https://files.pythonhosted.org/packages/22/29/ddb3a74954c5691181ef5a937529efee254d5ef41ff73c78725e0e97db7c/pipepy-0.0.9-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9aadb422df461ccef3e00e9862eb92c36702e855f482b4103d1e79d8d49160b1",
          "md5": "24806a345b44d3e12a0d4c5816864e5e",
          "sha256": "5ad50a7684a3f0fbc5e0d8b2ce0f1c5a00eccf996337120211375985de7ac4de"
        },
        "downloads": -1,
        "filename": "pipepy-0.0.9.tar.gz",
        "has_sig": false,
        "md5_digest": "24806a345b44d3e12a0d4c5816864e5e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 49966,
        "upload_time": "2021-03-14T21:16:22",
        "upload_time_iso_8601": "2021-03-14T21:16:22.924655Z",
        "url": "https://files.pythonhosted.org/packages/9a/ad/b422df461ccef3e00e9862eb92c36702e855f482b4103d1e79d8d49160b1/pipepy-0.0.9.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "dbda5b15748bacea1c3a92a4a484d7f57a956f54b4b61eb1c995db3de7e13eda",
        "md5": "17ed153ec2c7e60a90c844f15f5fd45b",
        "sha256": "0ea7f1642103c10d549f97dd6226d43fb9b44f396920c8cbf330017d14ed0e4a"
      },
      "downloads": -1,
      "filename": "pipepy-0.0.11-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "17ed153ec2c7e60a90c844f15f5fd45b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 44989,
      "upload_time": "2022-09-20T15:38:44",
      "upload_time_iso_8601": "2022-09-20T15:38:44.744613Z",
      "url": "https://files.pythonhosted.org/packages/db/da/5b15748bacea1c3a92a4a484d7f57a956f54b4b61eb1c995db3de7e13eda/pipepy-0.0.11-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ad2644fed51cd16e9fd56a028a51c3ee84d27a2dc88998e58a759a77b6beecb0",
        "md5": "17e585cef21a3134fc5e26bfaa4b8edd",
        "sha256": "34fc109f21db01b7c47cbb2cc752b62a514b93b209f3979186ea21c7ce890cf9"
      },
      "downloads": -1,
      "filename": "pipepy-0.0.11.tar.gz",
      "has_sig": false,
      "md5_digest": "17e585cef21a3134fc5e26bfaa4b8edd",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 65246,
      "upload_time": "2022-09-20T15:38:46",
      "upload_time_iso_8601": "2022-09-20T15:38:46.816774Z",
      "url": "https://files.pythonhosted.org/packages/ad/26/44fed51cd16e9fd56a028a51c3ee84d27a2dc88998e58a759a77b6beecb0/pipepy-0.0.11.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}