{
  "info": {
    "author": "Qensus",
    "author_email": "venafi.oss@qensus.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Venafi CodeSign Protect: Gitlab integration\n\nThis product integrates [Venafi CodeSign Protect](https://www.venafi.com/platform/code-signing) with Gitlab-based CI/CD processes.\n\nVenafi CodeSign Protect is a solution for securing machines against attacks and exploits, by signing executables, libraries and other machine runtime artifacts with digital signatures. Unlike naive methods of code signing, Venafi CodeSign Protect is more secure, by storing and securing the signing key separately from the CI/CD infrastructure (perhaps even in a Hardware Security Module) and by providing access control to signing keys. It also provides important insights to security teams, such as how and when signing keys are used.\n\nThis product allows one to sign and verify files through Venafi CodeSign Protect. The following signing tools are currently supported:\n\n * Jarsigner (Java)\n * Signtool (Windows)\n\n**Table of contents**\n\n - [Usage overview](#usage-overview)\n - [Setting up executor hosts (shell and SSH executors only)](#setting-up-executor-hosts-shell-and-ssh-executors-only)\n - [Compatibility](#compatibility)\n - [Usage](#usage)\n   - [Sign with Jarsigner](#sign-with-jarsigner)\n     - [Docker executor](#docker-executor)\n     - [Shell or SSH executor](#shell-or-ssh-executor)\n     - [Variables](#variables)\n   - [Verify with Jarsigner](#verify-with-jarsigner)\n     - [Docker executor](#docker-executor-1)\n     - [Shell or SSH executor](#shell-or-ssh-executor-1)\n     - [Variables](#variables-1)\n   - [Sign with Signtool](#sign-with-signtool)\n     - [Docker executor](#docker-executor-2)\n     - [Shell or SSH executor](#shell-or-ssh-executor-2)\n     - [Variables](#variables-2)\n   - [Verify with Signtool](#verify-with-signtool)\n     - [Docker executor](#docker-executor-3)\n     - [Shell or SSH executor](#shell-or-ssh-executor-3)\n     - [Variables](#variables-3)\n - [Docker images](#docker-images)\n     - [List of published Docker image tags](#list-of-published-docker-image-tags)\n     - [Image versioning policy](#image-versioning-policy)\n - [Signtool caveats](#signtool-caveats)\n - [Contribution & development](#contribution-development)\n\n## Usage overview\n\nYou must already have access to one or more Venafi Trust Protection Platforms™ (TPPs). This Gitlab integration product requires you to specify TPP address and authentication details.\n\nYou use this Gitlab integration product by defining, inside your Gitlab CI YAML, steps that perform signing or verification. These steps consume artifacts generated by previous steps (such as unsigned .jar files), and may output artifacts that you can use in later steps (such as signed .jar files).\n\n## Setting up executor hosts (shell and SSH executors only)\n\nIf you plan on using this Gitlab integration product in combination with the shell and SSH executors, then you must install the following software on the hosts on which those executors operate. This Gitlab integration product does not take care of installing these prerequisites for you.\n\n * Install Venafi CodeSign Protect client tools (see [Compatibility](#compatibility) to learn which versions are supported)\n    - You do *not* need to *configure* the client tools (i.e. they don't need to be configured with a TPP address or credentials). They just need to be installed. This Gitlab integration product will take care of configuring the client tools with specific TPPs.\n * Install one or more signing tools, e.g. [Jarsigner](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html) (part of the JDK) or [Signtool](https://docs.microsoft.com/en-us/dotnet/framework/tools/signtool-exe) (part of the Windows 10 SDK).\n * Install Python >= 3.8. Ensure that it's in PATH.\n * Install our Gitlab integration package: `pip install venafi-codesigning-gitlab-integration`\n\n## Compatibility\n\nThis product is compatible with:\n\n * Trust Protection Platform 20.2 or later.\n * Venafi CodeSign Protect client tools 20.2 or later.\n\nThis product supports the following Gitlab runner executors:\n\n * Shell\n * SSH\n * Docker\n\nExecutor support differs per OS:\n\n| Signer    | OS      | Shell | SSH | Docker |\n|-----------|---------|-------|-----|--------|\n| Jarsigner | Linux   | ✅    | ✅  | ✅     |\n| Jarsigner | Windows | ✅    | ❌  | ❌     |\n| Signtool  | Linux   | ❌    | ❌  | ❌     |\n| Signtool  | Windows | ✅    | ❌  | ✅     |\n\n## Usage\n\n### Sign with Jarsigner\n\nThis section shows how to sign one or more files with Java's [Jarsigner](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html) tool. It assumes that jarsigner is in PATH.\n\n#### Docker executor\n\n * Define a job that calls `venafi-sign-jarsigner`.\n * Ensure the job operates within the image `quay.io/venafi-gitlab-integration/codesigning-jarsigner:<TAG>`.\n    - Select a tag based on the Venafi client tools version that you require. See [Docker images](#docker-images).\n * Set the `INPUT_PATH` or `INPUT_GLOB` variable to the file(s) that you wish to sign.\n * Set other required variables too. See the variables reference below.\n\n~~~yaml\nstages:\n  - build\n  - sign\n\n# Build a 'foo.jar' and pass it as an artifact to the 'sign' stage.\nbuild_jar:\n  stage: build\n  script:\n    - echo 'public class Foo { public static void main() { } }' > Foo.java\n    - javac Foo.java\n    - jar -cf foo.jar Foo.class\n  artifacts:\n    paths:\n      - foo.jar\n\n# Sign the 'foo.jar' that was generated by the 'build' stage,\n# then store the signed jar as an artifact.\nsign_jarsigner:\n  stage: sign\n  image: quay.io/venafi-gitlab-integration/codesigning-jarsigner:latest-x86_64\n  script:\n    - venafi-sign-jarsigner\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: foo.jar\n    CERTIFICATE_LABEL: my label\n  artifacts:\n    paths:\n      - foo.jar\n~~~\n\n#### Shell or SSH executor\n\n * Define a job that calls `venafi-sign-jarsigner`.\n * Set the `INPUT_PATH` or `INPUT_GLOB` variable to the file(s) that you wish to sign.\n * Set other required variables too. See the variables reference below.\n\n~~~yaml\nstages:\n  - build\n  - sign\n\n# Build a 'foo.jar' and pass it as an artifact to the 'sign' stage.\nbuild_jar:\n  stage: build\n  script:\n    - echo 'public class Foo { public static void main() { } }' > Foo.java\n    - javac Foo.java\n    - jar -cf foo.jar Foo.class\n  artifacts:\n    paths:\n      - foo.jar\n\n# Sign the 'foo.jar' that was generated by the 'build' stage,\n# then store the signed jar as an artifact.\nsign_jarsigner:\n  stage: sign\n  script:\n    - venafi-sign-jarsigner\n  variables:\n    TPP_AUTH_URL: https://my-tpp/auth\n    TPP_HSM_URL: https://my-tpp/hsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: foo.jar\n    CERTIFICATE_LABEL: my label\n  artifacts:\n    paths:\n      - foo.jar\n~~~\n\n#### Variables\n\nRequired:\n\n * `TPP_AUTH_URL`: The TPP's authorization URL.\n * `TPP_HSM_URL`: The TPP's Hardware Security Module (HSM) backend URL.\n * `TPP_USERNAME`: A login username for the TPP.\n * `TPP_PASSWORD` or `TPP_PASSWORD_BASE64`: The password associated with the login username. You can specify it normally, or in Base64 format. The latter is useful for storing the password in a Gitlab variable, in masked form, because Gitlab can only mask variables whose content only consists of Base64 characters.\n * `INPUT_PATH` or `INPUT_GLOB`: Specifies the file(s) to sign, either through a single filename, or a glob.\n * `CERTIFICATE_LABEL`: The label of the certificate (inside the TPP) to use for code signing. You can obtain a list of labels with `pkcs11config listcertificates`.\n\nOptional:\n\n * `TIMESTAMPING_SERVERS`: Specifies one or more timestamping authority servers to use during signing. Specifying this is strongly recommended, because it allows signed files to be usable even after the original signing certificate has expired.\n\n    If you specify more than one server, then a random one will be used.\n\n    Example:\n\n    ~~~\n    TIMESTAMPING_SERVERS: http://server1,http://server2\n    ~~~\n\n    **Tip:** here are some public timestamping authorities that you can use:\n\n     - http://timestamp.digicert.com\n     - http://timestamp.globalsign.com\n     - http://timestamp.comodoca.com/authenticode\n     - http://tsa.starfieldtech.com\n\n * `EXTRA_ARGS`: Specifies extra custom CLI arguments to pass to Jarsigner. The arguments are comma-separated.\n\n    These arguments will be _appended_ to the Jarsigner CLI invocation, and take precedence over any arguments implicitly passed by this plugin.\n\n    Example:\n\n    ~~~\n    EXTRA_ARGS: -arg1,-arg2\n    ~~~\n\n * `EXTRA_TRUSTED_TLS_CA_CERTS` (only applicable when using Docker): Allows registering extra TLS CA certificates into the truststore. This is useful if your TPP's TLS certificate is not recognized by the TLS trust store in our Docker image.\n\n   Set the value to the path of a .pem file that contains one or more certificates to add to the trust store.\n\n   The certificates are added to the truststore during execution of `venafi-sign-jarsigner`. So the recommended way to use this feature, is by adding an additional command — prior to the execution of `venafi-sign-jarsigner` — to fetch the CA certificate file and to place it at the expected location. Example:\n\n   ~~~yaml\n   sign_jarsigner:\n     image: quay.io/venafi-gitlab-integration/codesigning-jarsigner:latest-x86_64\n     script:\n       - wget -O /downloaded-ca.crt https://internal.company.url/path-to-your-ca-chain.crt\n       - venafi-sign-jarsigner\n     variables:\n       TPP_AUTH_URL: https://my-tpp/vedauth\n       TPP_HSM_URL: https://my-tpp/vedhsm\n       TPP_USERNAME: my_username\n       # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n       INPUT_PATH: foo.jar\n       CERTIFICATE_LABEL: my label\n       EXTRA_TRUSTED_TLS_CA_CERTS: /downloaded-ca.crt\n   ~~~\n\n * `VENAFI_CLIENT_TOOLS_DIR`: Specifies the path to the directory in which Venafi CodeSign Protect client tools are installed. If not specified, it's autodetected as follows:\n\n     - Linux: /opt/venafi/codesign\n     - macOS: /Library/Venafi/CodeSigning\n     - Windows: autodetected from the registry, or (if that fails): C:\\Program Files\\Venafi CodeSign Protect\n\n### Verify with Jarsigner\n\nThis section shows how to verify one or more files with Java's [Jarsigner](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html) tool. It assumes that jarsigner is in PATH.\n\n#### Docker executor\n\n * Define a job that calls `venafi-verify-jarsigner`.\n * Ensure the job operates within the image `quay.io/venafi-gitlab-integration/codesigning-jarsigner:<TAG>`.\n    - Select a tag based on the Venafi client tools version that you require. See [Docker images](#docker-images).\n * Set the `INPUT_PATH` or `INPUT_GLOB` variable to the file(s) that you wish to verify.\n * Set other required variables too. See the variables reference below.\n\n~~~yaml\nstages:\n  - fetch\n  - verify\n\n# Fetch a signed 'signed.jar' and pass it as an artifact to the 'verify' stage.\nfetch_jar:\n  stage: fetch\n  script:\n    - wget https://internal.lan/signed.jar\n  artifacts:\n    paths:\n      - signed.jar\n\n# Verify 'signed.jar' that was fetched by the 'fetch' stage.\nverify_jarsigner:\n  stage: verify\n  image: quay.io/venafi-gitlab-integration/codesigning-jarsigner:latest-x86_64\n  script:\n    - venafi-verify-jarsigner\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: signed.jar\n    CERTIFICATE_LABEL: my label\n~~~\n\n#### Shell or SSH executor\n\n * Define a job that calls `venafi-verify-jarsigner`.\n * Set the `INPUT_PATH` or `INPUT_GLOB` variable to the file(s) that you wish to verify.\n * Set other required variables too. See the variables reference below.\n * *Note*: the host which performs the verification does not need to have pre-installed the certificate against which to verify. We'll will fetch the certificate from the TPP, which is why it requires a certificate label.\n\n~~~yaml\nstages:\n  - fetch\n  - verify\n\n# Fetch a signed 'signed.jar' and pass it as an artifact to the 'verify' stage.\nfetch_jar:\n  stage: fetch\n  script:\n    - wget https://internal.lan/signed.jar\n  artifacts:\n    paths:\n      - signed.jar\n\n# Verify 'signed.jar' that was fetched by the 'fetch' stage.\nverify_jarsigner:\n  stage: verify\n  script:\n    - venafi-verify-jarsigner\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: signed.jar\n    CERTIFICATE_LABEL: my label\n~~~\n\n#### Variables\n\nRequired:\n\n * `TPP_AUTH_URL`: The TPP's authorization URL.\n * `TPP_HSM_URL`: The TPP's Hardware Security Module (HSM) backend URL.\n * `TPP_USERNAME`: A login username for the TPP.\n * `TPP_PASSWORD` or `TPP_PASSWORD_BASE64`: The password associated with the login username. You can specify it normally, or in Base64 format. The latter is useful for storing the password in a Gitlab variable, in masked form, because Gitlab can only mask variables whose content only consists of Base64 characters.\n * `INPUT_PATH` or `INPUT_GLOB`: Specifies the file(s) to verify, either through a single filename, or a glob.\n * `CERTIFICATE_LABEL`: The label of the certificate (inside the TPP) that was used for signing the file(s). You can obtain a list of labels with `pkcs11config listcertificates`.\n\nOptional:\n\n * `EXTRA_TRUSTED_TLS_CA_CERTS` (only applicable when using Docker): Allows registering extra TLS CA certificates into the truststore. This is useful if your TPP's TLS certificate is not recognized by the TLS trust store in our Docker image.\n\n   Set the value to the path of a .pem file that contains one or more certificates to add to the trust store.\n\n   The certificates are added to the truststore during execution of `venafi-verify-jarsigner`. So the recommended way to use this feature, is by adding an additional command — prior to the execution of `venafi-verify-jarsigner` — to fetch the CA certificate file and to place it at the expected location. Example:\n\n   ~~~yaml\n   verify_jarsigner:\n     image: quay.io/venafi-gitlab-integration/codesigning-jarsigner:latest-x86_64\n     script:\n       - wget -O /downloaded-ca.crt https://internal.company.url/path-to-your-ca-chain.crt\n       - venafi-verify-jarsigner\n     variables:\n       TPP_AUTH_URL: https://my-tpp/vedauth\n       TPP_HSM_URL: https://my-tpp/vedhsm\n       TPP_USERNAME: my_username\n       # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n       INPUT_PATH: signed.jar\n       CERTIFICATE_LABEL: my label\n       EXTRA_TRUSTED_TLS_CA_CERTS: /downloaded-ca.crt\n   ~~~\n\n * `VENAFI_CLIENT_TOOLS_DIR`: Specifies the path to the directory in which Venafi CodeSign Protect client tools are installed. If not specified, it's autodetected as follows:\n\n     - Linux: /opt/venafi/codesign\n     - macOS: /Library/Venafi/CodeSigning\n     - Windows: autodetected from the registry, or (if that fails): C:\\Program Files\\Venafi CodeSign Protect\n\n### Sign with Signtool\n\nThis section shows how to sign one or more files with Microsoft's [Signtool](https://docs.microsoft.com/en-us/dotnet/framework/tools/signtool-exe) tool.\n\n#### Docker executor\n\nUsage instructions:\n\n * Define a job that calls `venafi-sign-signtool`.\n * Ensure that this job runs on a Windows-based runner, by setting the proper tags.\n * Ensure this job operates within the image `quay.io/venafi-gitlab-integration/codesigning-signtool:<TAG>`.\n    - Select a tag based on the Venafi client tools version that you require. See [Docker images](#docker-images).\n * Set the `INPUT_PATH` variable to a filename or a glob that you wish to sign.\n * Set other required variables too. See the variables reference below.\n\n*Notes*:\n\n - Our image uses x64 signtool by default. If you wish to use a different architecture's signtool, then set `SIGNTOOL_PATH` to `C:\\winsdk\\<arch>\\signtool`.\n - We use 'sha256' as the default signature digest algorithm, unlike Signtool's default ('sha1'). You may want to override this if you care about compatibility with older Windows versions that didn't support SHA-256.\n - Please read the [Signtool caveats](#signtool-caveats).\n\n~~~yaml\nstages:\n  - build\n  - sign\n\n# Build a 'foo.exe' and pass it as an artifact to the 'sign' stage.\nbuild_exe:\n  stage: build\n  image: quay.io/venafi-gitlab-integration/codesigning-signtool:latest-x86_64\n  tags:\n    - windows\n  script:\n    - copy C:\\Windows\\System32\\Notepad.exe foo.exe\n  artifacts:\n    paths:\n      - foo.exe\n\n# Sign the 'foo.exe' that was generated by the 'build' stage,\n# then store the signed exe as an artifact.\nsign_signtool:\n  stage: sign\n  image: quay.io/venafi-gitlab-integration/codesigning-signtool:latest-x86_64\n  tags:\n    - windows\n  script:\n    - venafi-sign-signtool\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: foo.exe\n    CERTIFICATE_SUBJECT_NAME: mydomain.com\n  artifacts:\n    paths:\n      - foo.exe\n~~~\n\n#### Shell or SSH executor\n\nUsage instructions:\n\n * Define a job that calls `venafi-sign-signtool`.\n * Ensure that this job runs on a Windows-based runner, by setting the proper tags.\n * Set the `INPUT_PATH` variable to a filename or a glob that you wish to sign.\n * Set other required variables too. See the variables reference below.\n\n*Notes*:\n\n - We assume that signtool.exe is in PATH, unless you explicitly specify its path with `SIGNTOOL_PATH`.\n - We use 'sha256' as the default signature digest algorithm, unlike Signtool's default ('sha1'). You may want to override this if you care about compatibility with older Windows versions that didn't support SHA-256.\n - Please read the [Signtool caveats](#signtool-caveats).\n\n~~~yaml\nstages:\n  - build\n  - sign\n\n# Build a 'foo.exe' and pass it as an artifact to the 'sign' stage.\nbuild_exe:\n  stage: build\n  tags:\n    - windows\n  script:\n    - copy C:\\Windows\\System32\\Notepad.exe foo.exe\n  artifacts:\n    paths:\n      - foo.exe\n\n# Sign the 'foo.exe' that was generated by the 'build' stage,\n# then store the signed exe as an artifact.\nsign_signtool:\n  stage: sign\n  tags:\n    - windows\n  script:\n    - venafi-sign-signtool\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: foo.exe\n    CERTIFICATE_SUBJECT_NAME: mydomain.com\n  artifacts:\n    paths:\n      - foo.exe\n~~~\n\n#### Variables\n\nRequired:\n\n * `TPP_AUTH_URL`: The TPP's authorization URL.\n * `TPP_HSM_URL`: The TPP's Hardware Security Module (HSM) backend URL.\n * `TPP_USERNAME`: A login username for the TPP.\n * `TPP_PASSWORD` or `TPP_PASSWORD_BASE64`: The password associated with the login username. You can specify it normally, or in Base64 format. The latter is useful for storing the password in a Gitlab variable, in masked form, because Gitlab can only mask variables whose content only consists of Base64 characters.\n * `INPUT_PATH`: A path or a glob that specifies the file(s) to be signed.\n * `CERTIFICATE_SUBJECT_NAME` or `CERTIFICATE_SHA1`: Specifies the certificate (inside the TPP) to use for signing.\n\n   You can either specify the certificate's Common Name (\"Issued to\" or \"CN\"), or its SHA-1 hash.\n\n   You can obtain a list of Common Names with `cspconfig listcertificates` and checking what comes after `CN=`.\n\n   Specifying the SHA-1 hash is useful if there are multiple certificates with the same Common Name.\n\nOptional:\n\n * `TIMESTAMPING_SERVERS`: Specifies one or more timestamping authority servers to use during signing. Specifying this is strongly recommended, because it allows signed files to be usable even after the original signing certificate has expired.\n\n    If you specify more than one server, then a random one will be used.\n\n    Example:\n\n    ~~~\n    TIMESTAMPING_SERVERS: http://server1,http://server2\n    ~~~\n\n    **Tip:** here are some public timestamping authorities that you can use:\n\n     - http://timestamp.digicert.com\n     - http://timestamp.globalsign.com\n     - http://timestamp.comodoca.com/authenticode\n     - http://tsa.starfieldtech.com\n\n * `SIGNATURE_DIGEST_ALGOS`: The digest algorithm(s) to use to creating signatures.\n\n    If none specified, 'sha256' is used as the default algorithm. This is very secure, but may not be compatible with older Windows versions. If you need compatibility with older Windows versions, you should specify 'sha1,sha256' (in that order).\n\n    When multiple digest algorithms are specified, they are applied in the order specified.\n\n    Example:\n\n    ~~~\n    SIGNATURE_DIGEST_ALGOS=sha1,sha256\n    ~~~\n\n * `APPEND_SIGNATURES` (boolean): If the target file(s) already have signatures, then append a new signature instead of overwriting the existing signatures.\n\n   Defaults to `false`.\n\n * `EXTRA_ARGS`: Specifies extra custom CLI arguments to pass to Signtool. The arguments are comma-separated.\n\n    These arguments will be _appended_ to the Signtool CLI invocation. If they overlap with any arguments implicitly passed by this plugin,\n    then Signtool will raise an error.\n\n    Example:\n\n    ~~~\n    EXTRA_ARGS: /arg1,/arg2\n    ~~~\n\n * `EXTRA_TRUSTED_TLS_CA_CERTS` (only applicable when using Docker): Allows registering extra TLS CA certificates into the truststore. This is useful if your TPP's TLS certificate is not recognized by the TLS trust store in our Docker image.\n\n   Set the value to the path of a PEM or DER file that contains one or more certificates to add to the trust store.\n\n   The certificates are added to the truststore during execution of `venafi-sign-signtool`. So the recommended way to use this feature, is by adding an additional command — prior to the execution of `venafi-sign-signtool` — to fetch the CA certificate file and to place it at the expected location. Example:\n\n   ~~~yaml\n   sign_signtool:\n     script:\n       - powershell -Command \"Invoke-WebRequest -Uri 'https://internal.company.url/path-to-your-ca-chain.crt' -OutFile 'C:\\downloaded-ca.crt'\"\n       - venafi-sign-signtool\n     variables:\n       TPP_AUTH_URL: https://my-tpp/vedauth\n       TPP_HSM_URL: https://my-tpp/vedhsm\n       TPP_USERNAME: my_username\n       # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n       INPUT_PATH: foo.exe\n       CERTIFICATE_SUBJECT_NAME: mydomain.com\n       EXTRA_TRUSTED_TLS_CA_CERTS: C:\\downloaded-ca.crt\n   ~~~\n\n * `SIGNTOOL_PATH`: The full path to signtool.exe. If not specified, we assume that it's in PATH.\n\n * `VENAFI_CLIENT_TOOLS_DIR`: Specifies the path to the directory in which Venafi CodeSign Protect client tools are installed. If not specified, it's autodetected from the registry. If that fails, we fallback to C:\\Program Files\\Venafi CodeSign Protect.\n\n * `MACHINE_CONFIGURATION` (boolean): Whether to load CSP configuration from the machine registry hive instead of the user registry hive. Defaults to false.\n\n### Verify with Signtool\n\nThis section shows how to verify one or more files with Microsoft's [Signtool](https://docs.microsoft.com/en-us/dotnet/framework/tools/signtool-exe) tool.\n\n#### Docker executor\n\nUsage instructions:\n\n * Define a job that calls `venafi-verify-signtool`.\n * Ensure that this job runs on a Windows-based runner, by setting the proper tags.\n * Ensure this job operates within the image `quay.io/venafi-integration/codesigning-signtool:<TAG>`.\n    - Select a tag based on the Venafi client tools version that you require. See [Docker images](#docker-images).\n * Set the `INPUT_PATH` variable to a filename or a glob that you wish to verify.\n * Set other required variables too. See the variables reference below.\n\n*Notes*:\n\n - Our image uses x64 signtool by default. If you wish to use a different architecture's signtool, then set `SIGNTOOL_PATH` to `C:\\winsdk\\<arch>\\signtool`.\n - Please read the [Signtool caveats](#signtool-caveats).\n\n~~~yaml\nstages:\n  - fetch\n  - verify\n\n# Fetch a signed 'signed.exe' and pass it as an artifact to the 'verify' stage.\nfetch_exe:\n  stage: fetch\n  image: quay.io/venafi-gitlab-integration/codesigning-signtool:latest-x86_64\n  tags:\n    - windows\n  script:\n    - powershell -Command \"Invoke-WebRequest -Uri 'https://internal.lan/signed.exe' -OutFile 'C:\\signed.exe'\"\n  artifacts:\n    paths:\n      - C:\\signed.exe\n\n# Verify 'signed.exe' that was fetched by the 'fetch' stage.\nverify_signtool:\n  stage: sign\n  image: quay.io/venafi-gitlab-integration/codesigning-signtool:latest-x86_64\n  tags:\n    - windows\n  script:\n    - venafi-verify-signtool\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: signed.exe\n~~~\n\n#### Shell or SSH executor\n\nUsage instructions:\n\n * Define a job that calls `venafi-verify-signtool`.\n * Ensure that this job runs on a Windows-based runner, by setting the proper tags.\n * Set the `INPUT_PATH` variable to a filename or a glob that you wish to verify.\n * Set other required variables too. See the variables reference below.\n\n*Notes*:\n\n - We assume that signtool.exe is in PATH, unless you explicitly specify its path with `SIGNTOOL_PATH`.\n - Please read the [Signtool caveats](#signtool-caveats).\n\n~~~yaml\nstages:\n  - fetch\n  - verify\n\n# Fetch a signed 'signed.exe' and pass it as an artifact to the 'verify' stage.\nfetch_exe:\n  stage: fetch\n  tags:\n    - windows\n  script:\n    - powershell -Command \"Invoke-WebRequest -Uri 'https://internal.lan/signed.exe' -OutFile 'C:\\signed.exe'\"\n  artifacts:\n    paths:\n      - C:\\signed.exe\n\n# Verify 'signed.exe' that was fetched by the 'fetch' stage.\nverify_signtool:\n  stage: sign\n  tags:\n    - windows\n  script:\n    - venafi-verify-signtool\n  variables:\n    TPP_AUTH_URL: https://my-tpp/vedauth\n    TPP_HSM_URL: https://my-tpp/vedhsm\n    TPP_USERNAME: my_username\n    # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n    INPUT_PATH: signed.exe\n~~~\n\n#### Variables\n\nRequired:\n\n * `TPP_AUTH_URL`: The TPP's authorization URL.\n * `TPP_HSM_URL`: The TPP's Hardware Security Module (HSM) backend URL.\n * `TPP_USERNAME`: A login username for the TPP.\n * `TPP_PASSWORD` or `TPP_PASSWORD_BASE64`: The password associated with the login username. You can specify it normally, or in Base64 format. The latter is useful for storing the password in a Gitlab variable, in masked form, because Gitlab can only mask variables whose content only consists of Base64 characters.\n * `INPUT_PATH`: A path or a glob that specifies the file(s) to verify.\n\nOptional:\n\n * `EXTRA_TRUSTED_TLS_CA_CERTS` (only applicable when using Docker): Allows registering extra TLS CA certificates into the truststore. This is useful if your TPP's TLS certificate is not recognized by the TLS trust store in our Docker image.\n\n   Set the value to the path of a PEM or DER file that contains one or more certificates to add to the trust store.\n\n   The certificates are added to the truststore during execution of `venafi-verify-signtool`. So the recommended way to use this feature, is by adding an additional command — prior to the execution of `venafi-verify-signtool` — to fetch the CA certificate file and to place it at the expected location. Example:\n\n   ~~~yaml\n   verify_signtool:\n     script:\n       - powershell -Command \"Invoke-WebRequest -Uri 'https://internal.company.url/path-to-your-ca-chain.crt' -OutFile 'C:\\downloaded-ca.crt'\"\n       - venafi-verify-signtool\n     variables:\n       TPP_AUTH_URL: https://my-tpp/vedauth\n       TPP_HSM_URL: https://my-tpp/vedhsm\n       TPP_USERNAME: my_username\n       # TPP_PASSWORD or TPP_PASSWORD_BASE64 should be set in the UI, with masking enabled.\n\n       INPUT_PATH: signed.exe\n       EXTRA_TRUSTED_TLS_CA_CERTS: C:\\downloaded-ca.crt\n   ~~~\n\n * `TRUSTED_CHAIN_LABEL` (only applicable when using Docker): Allows registering a chain in the TPP, into the truststore. This is useful if you want to verify files, that are signed with a chain that's not already in the container's default truststore.\n\n   Set the value to the label of the certificate (inside the TPP) for which its chain you want to trust. You can obtain a list of labels with `cspconfig listcertificates`.\n\n * `SIGNTOOL_PATH`: The full path to signtool.exe. If not specified, we assume that it's in PATH.\n\n * `VENAFI_CLIENT_TOOLS_DIR`: Specifies the path to the directory in which Venafi CodeSign Protect client tools are installed. If not specified, it's autodetected from the registry. If that fails, we fallback to C:\\Program Files\\Venafi CodeSign Protect.\n\n## Docker images\n\nWe supply a number of Docker images, for the purpose of using this Gitlab integration product with Gitlab CI's Docker executor. These images include the Venafi client tools.\n\nImages have the following address format:\n\n~~~\nquay.io/venafi-gitlab-integration/codesigning-<SIGNING TOOL>:<TAG>\n~~~\n\nWhere:\n\n * `SIGNING TOOL` is either `jarsigner` or `signtool`.\n * `TAG` specifies the version components and architecture that you want to use. This is in the format of:\n\n    - Specify the `latest-<ARCHITECTURE>` tag if you want to use the latest version of this Gitlab integration product, in combination with the latest version of the Venafi client tools that we support.\n\n      Note that older TPPs may not be compatible with newer client tools. We therefore do not recommend using `latest`.\n\n    - Specify `<PRODUCT VERSION>-<VENAFI CLIENT TOOLS VERSION>-<ARCHITECTURE>` as tag, if you want to have more control.\n\n       - `PRODUCT VERSION` is the major + minor version of this Gitlab integration product. See [the releases list](https://github.com/labs/venafi-codesigning-gitlab-integration/releases) to learn which versions are available.\n\n         We only provide images for the latest tiny version, which is why you can't specify the tiny version number in the tag. So for example, if only product versions 1.0.0 and 1.0.1 exist, we only provide an image for 1.0 (which contains product version 1.0.1).\n\n       - `VENAFI CLIENT TOOLS VERSION` is the version of the Venafi client tools that you wish to use, for example `22.3`.\n\n    - `ARCHITECTURE` is the architecture of the node on which you plan to run the container. Currently, only `x86_64` is available.\n\nExample: product version 1.2 + Venafi client tools 22.3, for use with Jarsigner on x86\\_64:\n\n~~~\nquay.io/venafi-gitlab-integration/codesigning-jarsigner:1.2-22.3-x86_64\n~~~\n\nExample: latest product version + latest Venafi client tools, for use with Signtool on x86\\_64:\n\n~~~\nquay.io/venafi-gitlab-integration/codesigning-signtool:latest-x86_64\n~~~\n\n### List of published Docker image tags\n\nYou can see the available tags on Quay.io:\n\n * [codesigning-jarsigner](https://quay.io/repository/venafi-gitlab-integration/codesigning-jarsigner?tab=tags)\n * [codesigning-signtool](https://quay.io/repository/venafi-gitlab-integration/codesigning-signtool?tab=tags)\n\n### Image versioning policy\n\n * We always supply the latest version of Signtool.\n * We always supply the latest version of Jarsigner, as is installable via the base image's package manager.\n    - Our Jarsigner images are currently based on RockyOS 8, so we always supply the latest Jarsigner as is provided by RockyOS 8's YUM repository.\n * We supply the last minor versions of the Venafi client tools, though no earlier than 21. (for example: 22.3 and 21.4).\n    - For each Venafi client tools minor version, we always supply the latest patch version.\n\n## Signtool caveats\n\nWhen using Signtool, you must ensure that all your TPP environments disable the option \"Include Certificate Chain\". You must do this for *all* TPP environments that the authenticated user account has access to: not just the ones to be used together with Signtool.\n\nIf you do not do this, then Signtool will trigger a confirmation dialog box, in which Windows asks for approval to import root certificates. Signtool can't continue until a human manually clicks \"Yes\".\n\nThis is especially problematic when using Signtool in a container, because there is no user interface, so it's impossible to click on anything.\n\n## Gitlab Runner caveats\n\nWhen using the Signtool Docker image (which is based on Windows ltsc2019) you may have to ensure that the `shell` have to be set to `powershell` in the runner configuration, because since [Gitlab Runner 14 and later](https://docs.gitlab.com/runner/shells/) the default behavior changed. The default shell is now set to `pwsh`.\n\nThe following error can occur when the shell is not set correctly.\n\n```\nFileNotFoundError: [WinError 2] The system cannot find the file specified\n```\n\n# Git caveats\n\nWhen using the Signtool Docker image you may get ownership errors due to recent Git restrictions. You can solve this by adding a `pre_clone_script` and `post_clone_script` to the runner configuration that\nincludes the git command to configure safe directories like `git config --global --add safe.directory '*'`. You may want to change the '*' to a specific directory.\n\nThe following error can occur when dubious ownership is detected.\n```\nfatal: detected dubious ownership in repository at\n```\n\n## Contribution & development\n\nSee the [contribution guide](CONTRIBUTING.md).",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/qensus-labs/venafi-codesigning-gitlab-integration",
    "keywords": "",
    "license": "Apache 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "venafi-codesigning-gitlab-integration",
    "package_url": "https://pypi.org/project/venafi-codesigning-gitlab-integration/",
    "platform": "any",
    "project_url": "https://pypi.org/project/venafi-codesigning-gitlab-integration/",
    "project_urls": {
      "Homepage": "https://github.com/qensus-labs/venafi-codesigning-gitlab-integration"
    },
    "release_url": "https://pypi.org/project/venafi-codesigning-gitlab-integration/1.2.0/",
    "requires_dist": null,
    "requires_python": ">=3.8",
    "summary": "Venafi CodeSign Protect: Gitlab integration",
    "version": "1.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16239018,
  "releases": {
    "0.9.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4267d6b6679eafdf2f68332dd5362d5b2c60e1a7a802b3014ea8ea1330a4b0d1",
          "md5": "402d48b45a279238d185f16a303b64b8",
          "sha256": "c537d0153fd043021f7a99c48d26dab4f85dc811e5375e261f5f0830968aa945"
        },
        "downloads": -1,
        "filename": "venafi-codesigning-gitlab-integration-0.9.0.tar.gz",
        "has_sig": false,
        "md5_digest": "402d48b45a279238d185f16a303b64b8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 28508,
        "upload_time": "2021-03-19T12:28:23",
        "upload_time_iso_8601": "2021-03-19T12:28:23.705107Z",
        "url": "https://files.pythonhosted.org/packages/42/67/d6b6679eafdf2f68332dd5362d5b2c60e1a7a802b3014ea8ea1330a4b0d1/venafi-codesigning-gitlab-integration-0.9.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.9.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "63be5d999d9164c9ebeaeb2a3f91bc3eae699367245cc8a6ca9ecd7d5ca0c91d",
          "md5": "aafb8f0739a48c2df594d628ce8aabbf",
          "sha256": "9e3e7fd0a080d54754f0149cc056ed17d75506e8869ec325d12ffbb3f3550a25"
        },
        "downloads": -1,
        "filename": "venafi-codesigning-gitlab-integration-0.9.1.tar.gz",
        "has_sig": false,
        "md5_digest": "aafb8f0739a48c2df594d628ce8aabbf",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 28837,
        "upload_time": "2021-04-09T13:25:12",
        "upload_time_iso_8601": "2021-04-09T13:25:12.295758Z",
        "url": "https://files.pythonhosted.org/packages/63/be/5d999d9164c9ebeaeb2a3f91bc3eae699367245cc8a6ca9ecd7d5ca0c91d/venafi-codesigning-gitlab-integration-0.9.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "75c9bb431ce0b7af1dc0ae6ddc3fb7005ea7c3fb67daf04c02f300d258255aaf",
          "md5": "ab8874296ccabbe9634ebf68c4be59c3",
          "sha256": "86c08504229000b1e0b69665bab86dd0596999a7ecd5c5629390cbf0ee48f765"
        },
        "downloads": -1,
        "filename": "venafi-codesigning-gitlab-integration-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "ab8874296ccabbe9634ebf68c4be59c3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 28842,
        "upload_time": "2021-04-09T13:38:47",
        "upload_time_iso_8601": "2021-04-09T13:38:47.961732Z",
        "url": "https://files.pythonhosted.org/packages/75/c9/bb431ce0b7af1dc0ae6ddc3fb7005ea7c3fb67daf04c02f300d258255aaf/venafi-codesigning-gitlab-integration-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c9bf0892f6887518edcb650a27c56af3151e63f13b94da81229c6b405a356515",
          "md5": "0fc54a77f494d277e13c75da4393b06e",
          "sha256": "a825ac8241fb7a093b2c4ff3c4355e1ed9ed1dd7cbbb2c6a067a5d4e4f78afc1"
        },
        "downloads": -1,
        "filename": "venafi-codesigning-gitlab-integration-1.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "0fc54a77f494d277e13c75da4393b06e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 29248,
        "upload_time": "2021-08-02T09:54:49",
        "upload_time_iso_8601": "2021-08-02T09:54:49.122008Z",
        "url": "https://files.pythonhosted.org/packages/c9/bf/0892f6887518edcb650a27c56af3151e63f13b94da81229c6b405a356515/venafi-codesigning-gitlab-integration-1.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9b4f4243e7bd9807e85b1a9ee5807a69eb643f9c07194870d6e78a88337f1a81",
          "md5": "71cff3e154c708db40a93ffc4ee9647d",
          "sha256": "b8a06ad0afb544a82f3a4738644ec19cfcce2e889db92907e3bc5e6f1e802bc5"
        },
        "downloads": -1,
        "filename": "venafi-codesigning-gitlab-integration-1.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "71cff3e154c708db40a93ffc4ee9647d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 30432,
        "upload_time": "2022-12-28T14:03:00",
        "upload_time_iso_8601": "2022-12-28T14:03:00.676905Z",
        "url": "https://files.pythonhosted.org/packages/9b/4f/4243e7bd9807e85b1a9ee5807a69eb643f9c07194870d6e78a88337f1a81/venafi-codesigning-gitlab-integration-1.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9b4f4243e7bd9807e85b1a9ee5807a69eb643f9c07194870d6e78a88337f1a81",
        "md5": "71cff3e154c708db40a93ffc4ee9647d",
        "sha256": "b8a06ad0afb544a82f3a4738644ec19cfcce2e889db92907e3bc5e6f1e802bc5"
      },
      "downloads": -1,
      "filename": "venafi-codesigning-gitlab-integration-1.2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "71cff3e154c708db40a93ffc4ee9647d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 30432,
      "upload_time": "2022-12-28T14:03:00",
      "upload_time_iso_8601": "2022-12-28T14:03:00.676905Z",
      "url": "https://files.pythonhosted.org/packages/9b/4f/4243e7bd9807e85b1a9ee5807a69eb643f9c07194870d6e78a88337f1a81/venafi-codesigning-gitlab-integration-1.2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}