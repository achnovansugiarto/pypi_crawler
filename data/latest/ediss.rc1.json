{
  "info": {
    "author": "origamizyt",
    "author_email": "zhaoyitong18@163.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# EDISS - Curve25519 Security Scheme\n\nRepository: https://gitee.com/origamizyt/ediss.git\n\nLike ECIES (Elliptic-curve integrated encryption scheme), EDISS (Edwards-curve integrated security scheme) provides public interfaces for key agreement, message authentication, digital signature and symmetric encryption using curve25519.\n\n## Installation\n\nThis module is available via pip:\n```\n$ pip install ediss\n```\n\nYou can also clone the repository and install yourself:\n```\n$ git clone https://gitee.com/origamizyt/ediss.git\n$ cd ediss\n$ python setup.py install\n```\n\nIf you want to use the source code, you should download the cryptography module as a dependency.\n```\n$ pip install cryptography\n```\n\n## Basic Usage\n\nFor the most basic usage, the public apis are defined in the `EdsScheme` class. Use the `generate` static method to initialize schemes with generated keys. Use the `privateKey` and `publicKey` attributes to access keys.\n```py\n>>> from ediss import EdsScheme\n>>> es1 = EdsScheme.generate()\n>>> es2 = EdsScheme.generate()\n```\n\nFor private and public keys, you can create an key export using the `exportKey`, `exportJson` and `exportBinary` method. Each of them receives an optional password as the material to derive the key used for wrapping. \n\n```py\n>>> es1.privateKey.exportKey() # no wrapping\n{'salt': None, 'x25519': b'...', 'ed25519': b'...'}\n>>> es1.publicKey.exportJson()\n'{\"salt\": null, \"x25519\": \"...\", \"ed25519\": \"...\"}'\n>>> es2.publicKey.exportBinary()\nb'...'\n>>> es2.privateKey.exportKey(b'password') # PBKDF2 + AES\n{'salt': b'...', 'x25519': b'...', 'ed25519': b'...'}\n```\n\n> NOTE: The key export is incompatible with other serialization formats, such as DER or PEM.\n\nTo receive public keys from peer, use the corresponding `receiveKey`, `receiveJson`, and `receiveBinary` methods. If you specified password during key export, you need to specify it as a parameter during receiving too.\n\n```py\n>>> es2.receiveBinary(es1.exportBinary())\n>>> es1.receiveJson(es2.exportJson(b'MyPassword'), b'MyPassword')\n```\n\n> NOTE: You cannot receive public key more than once. Attempts to call receiving methods twice will raise the `RemoteKeyExists` error.\n\nAfter receiving the remote keys, the signature and encipherment methods should now be available.\n\n> NOTE: To be more accurate, the `sign` and `decrypt` method is always available, as they only uses the private key.\n\nUse the `sharedSecret` property to acquire the negotiated secret between two schemes:\n```py\n>>> es1.sharedSecret == es2.sharedSecret\nTrue\n```\n\nYou can use the shared secret to perform HMAC or other symmetric operations. To sign a message, simply use the `sign` method. Call `verify` on the other side to verify the message. The generated signature is 64 bytes long.\n```py\n>>> data = b'my secret message'\n>>> signature = es1.sign(data)\n>>> es2.verify(data, signature)\nTrue\n>>> es2.verify(data, b'We are under attack!')\nFalse\n```\n\nTo encrypt the message, use the `encrypt` method and decrypt via the `decrypt` method. The enciphered length is the original length + 80.\n```py\n>>> message = es2.encrypt(b'dark secrets')\n>>> es1.decrypt(message)\nb'dark secrets'\n>>> from ediss import Error\n>>> try:\n...     es1.decrypt(b'We are under attack!')\n... except Error as e:\n...     print('malformed!')\n...\nmalformed!\n```\n\n> NOTE: Actually, the method raises a `ediss.cipher.MalformedCiphertext` error, which is a subclass of `ediss.Error`.\n\n## More Usage\n\n### Local scheme\n\nTo use EDISS locally rather than remotely, use the `LocalScheme` class.\n```py\n>>> from ediss import LocalScheme\n>>> s = LocalScheme.generate()\n```\n\nThe public apis are the same as `EdsScheme` without key receiving methods. The only difference is that the `verify` and `decrypt` method now works on signature and ciphertext generated by yourself rather than the other side.\n\nTo load schemes from private key exports, use the `fromPrivateKey`, `fromPrivateJson` and `fromPrivateBinary` static methods.\n```py\n>>> s2 = LocalScheme.fromPrivateKey(s.privateKey.exportKey())\n>>> s.privateKey.exportBinary() == s2.privateKey.exportBinary()\nTrue\n```\n\n> NOTE: If you want to store the scheme in your local disk, make sure you encrypt the keys properly.\n\n### Incremental signers / verifiers\n\nIf your data is too large to sign in one chunk, you can use the `getSigner` method to acquire an incremental signer.\n```py\n>>> from ediss import EdsScheme\n>>> e = EdsScheme.generate()\n>>> s = e.getSigner()\n>>> s.update(b'A chunk of data')\n>>> s.update(b'Another chunk of data')\n>>> signature = s.finalize()\n```\n\nIncremental verifiers are also available:\n```py\n>>> e2 = EdsScheme.generate()\n>>> e2.receiveKey(e.exportKey())\n>>> v = e2.getVerifier()\n>>> v.update(b'A chunk of data')\n>>> v.update(b'Another chunk of data')\n>>> v.finalize(signature)\nTrue\n```\n\nThese two methods also work on `LocalScheme`.\n\n### Socket patching\n\nAs most users take advantage of this module to secure their socket connections, there's an special submodule called `ediss.patch` for you to conveniently wrap your socket with the security scheme.\n\nTheir are four patch approaches as listed below:\n\n| Method Name | Method Description |\n|--|--|\n| PmHmac | Use shared secret to generate mac code, send along with message |\n| PmSign | Use ed25519 to generate digital signature, send along with message\n| PmCiph | Use shared secret to encrypt the message |\n| PmFull | PmSign combined with PmCiph |\n\nTo patch your socket, simply pass it as an argument to `SocketPatch`. Specify one method as the second argument. Call the `negotiate` method to perform key agreement:\n\nClient:\n```py\n>>> from ediss.patch import *\n>>> import socket\n>>> s = socket.socket()\n>>> # initialize the socket\n>>> s = SocketPatch(s, PatchMethod.PmSign)\n>>> s.negotiate(True)\n```\n\nServer:\n```py\n>>> from ediss.patch import *\n>>> import socket\n>>> s = socket.socket()\n>>> # initializes the socket\n>>> c = SocketPatch(s.accept()[0], PatchMethod.PmSign)\n>>> c.negotiate(False)\n```\n\n> NOTE: You certainly can specify true for server and false for client, as long as they are different.\n\nNow you can use the `send` and `recv` method with patch enabled. Make sure you catches the `PacketDropped` exception when unauthorized packet is received.\n```py\ns.send(b'some data to be signed')\ntry:\n    d = s.recv(1024)\n    print(d)\nexcept PacketDropped:\n    print('received unauthorized packet')\n```\n\nOnly `send` and `recv` are patched. Other attribute acquisition requests are directly propagated to the socket object itself.\n\n## Mechanism\n\nThe curve25519 consists of two different deriviations - x25519 and ed25519. Each of the private and public keys contains two components - the x25519 key and ed25519 key. The x25519 key is used for key agreement, symmetric encryption, while the ed25519 key is used for EdDSA (Edwards-curve Digital Signature Algorithm).\n\n### Key agreement\n\nThe x25519 diffie-hellman is similar with ECDH (Elliptic-curve Diffie-Hellman), when two parties calculates the same shared secret according to the base point and their private keys. After agreeing with the same key, the module then derives a new key using the `CONCATKDF-SHA512` algorithm specified in the NIST document.\n\n### Message Encipherment\n\nAs curve25519 does not provide a encryption scheme, the module uses `AES-256-GCM` to encrypt the message. The symmetric key is derived using `HKDF-SHA512` with the shared secret. As the shared secret generated by the keys is a constant value, it does not provide enough forward secrecy. To solve this, the module uses ephemeral keys, which means every time when a message is encrypted, a new random key is generated and performed DH with remote key. Then the public bytes of the ephemeral key is sent with the message and negotiates with the remote private key to produce the same shared secret. As the `HKDF-SHA512` algorithm uses a random salt, the message has two random elements, making it difficult to crack. The encrypted message is 80 bytes longer than the plain text.\n\n| EphemeralKey | HKDFSalt | GcmNonce | Ciphertext | GcmTag | Total |\n|--|--|--|--|--|--|\n| 32 bytes | 16 bytes | 16 bytes | N bytes | 16 bytes | 80+N bytes |\n\n> NOTE: This mechanism does **NOT** prevent you from MITM attacks. You need to certificate your server.\n\n### Digital Signature\n\nThe ed25519 curve provides a signature scheme called EdDSA (Edwards-curve Digital Signature Algorithm). The module signs the SHA-384 result of the message, producing a signature of 64 bytes. To crack the signature you'll need to find an efficient way to solve the DLP (Discrete Logarithm Problem) on curve25519.\n\n## Backend\n\nThis module uses the [pyca/cryptography](https://github.com/pyca/cryptography) module as backend. It is a package designed to expose cryptographic primitives and recipes to Python developers.\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://gitee.com/origamizyt/ediss",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "ediss",
    "package_url": "https://pypi.org/project/ediss/",
    "platform": "",
    "project_url": "https://pypi.org/project/ediss/",
    "project_urls": {
      "Homepage": "https://gitee.com/origamizyt/ediss"
    },
    "release_url": "https://pypi.org/project/ediss/1.0.0/",
    "requires_dist": [
      "cryptography"
    ],
    "requires_python": ">=3",
    "summary": "Integrated security scheme for curve25519.",
    "version": "1.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 11136857,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f0ab8a758c0a1319447cbb70f67f8e453bb9788578425c7d2e55924f55cf7129",
          "md5": "7954c59ee7558829faa477fec1c8f93d",
          "sha256": "5ba1622627986eeb728cfdbe275aed85873bafc7e9db3b94cdc579c00d5d2697"
        },
        "downloads": -1,
        "filename": "ediss-1.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7954c59ee7558829faa477fec1c8f93d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3",
        "size": 12118,
        "upload_time": "2021-08-10T05:38:27",
        "upload_time_iso_8601": "2021-08-10T05:38:27.497069Z",
        "url": "https://files.pythonhosted.org/packages/f0/ab/8a758c0a1319447cbb70f67f8e453bb9788578425c7d2e55924f55cf7129/ediss-1.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "399606532a4b596c82d6cd7178ad215771816bf598280b357acd0721c5e4da20",
          "md5": "7fcfbac5f25fd57d416c53d44b641d07",
          "sha256": "4d1147141d3672251d4e559f8dfe147bda126cd06226b96ce6775c0441bacccf"
        },
        "downloads": -1,
        "filename": "ediss-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7fcfbac5f25fd57d416c53d44b641d07",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3",
        "size": 13370,
        "upload_time": "2021-08-10T05:38:29",
        "upload_time_iso_8601": "2021-08-10T05:38:29.950786Z",
        "url": "https://files.pythonhosted.org/packages/39/96/06532a4b596c82d6cd7178ad215771816bf598280b357acd0721c5e4da20/ediss-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "f0ab8a758c0a1319447cbb70f67f8e453bb9788578425c7d2e55924f55cf7129",
        "md5": "7954c59ee7558829faa477fec1c8f93d",
        "sha256": "5ba1622627986eeb728cfdbe275aed85873bafc7e9db3b94cdc579c00d5d2697"
      },
      "downloads": -1,
      "filename": "ediss-1.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "7954c59ee7558829faa477fec1c8f93d",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3",
      "size": 12118,
      "upload_time": "2021-08-10T05:38:27",
      "upload_time_iso_8601": "2021-08-10T05:38:27.497069Z",
      "url": "https://files.pythonhosted.org/packages/f0/ab/8a758c0a1319447cbb70f67f8e453bb9788578425c7d2e55924f55cf7129/ediss-1.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "399606532a4b596c82d6cd7178ad215771816bf598280b357acd0721c5e4da20",
        "md5": "7fcfbac5f25fd57d416c53d44b641d07",
        "sha256": "4d1147141d3672251d4e559f8dfe147bda126cd06226b96ce6775c0441bacccf"
      },
      "downloads": -1,
      "filename": "ediss-1.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "7fcfbac5f25fd57d416c53d44b641d07",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3",
      "size": 13370,
      "upload_time": "2021-08-10T05:38:29",
      "upload_time_iso_8601": "2021-08-10T05:38:29.950786Z",
      "url": "https://files.pythonhosted.org/packages/39/96/06532a4b596c82d6cd7178ad215771816bf598280b357acd0721c5e4da20/ediss-1.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}