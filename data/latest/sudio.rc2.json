{
  "info": {
    "author": "",
    "author_email": "mrzahaki@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Sudio\r\n\r\n \r\n`sudio` is a `powerful`, `Open-source`, `fast and `easy-to-use` digital audio processing library featuring both a **real-time**, **non-real-time** mix/edit platform. \r\n\r\n## Abstract\r\n\r\nAudio signal processing is a highly active research field where digital signal processing theory meets human sound perception and real-time programming requirements. It has a wide range of applications in computers, gaming, and music technology, to name a few of the largest areas. Successful applications include for example perceptual audio coding, digital music synthesizers, and music recognition software. \r\n\r\n#### Real-time audio processing\r\n\r\nFor live digital audio systems with high-resolution multichannel functionalities, it is desirable to have accurate latency control and estimation over all the stages of digital audio processing chain. \r\n\r\nThe sudio is written flexible can used for high level audio processing algorithm and other system factors, which might cause the latency effects. It also can estimate the synchronization and delay of multiple channels.\r\n\r\n#### Non-Realtime processing:\r\n\r\nSudio is a comprehensive library for mixing, editing, and recording audio content.\r\n\r\n\r\n#### Audio data maintaining process:\r\n\r\nThe sudio used additional cached files to reduce dynamic memory usage and improve performance, meaning that audio data storage methods could have different execution times based on the stored files. Thanks to that, \r\nSudo can manage various audio streams from audio files or operating systems without any size limitation.\r\n\r\n<!--\r\n<a href=\"https://www.buymeacoffee.com/mrzahakiU\" target=\"_blank\"><img src=\"https://cdn.buymeacoffee.com/buttons/default-orange.png\" alt=\"Buy Me A Coffee\" height=\"41\" width=\"174\"></a>\r\n-->\r\n ---\r\n\r\n## Table of contents:\r\n\r\n- [Sudio](#sudio)\r\n  - [Abstract](#abstract)\r\n      - [Real-time audio processing](#real-time-audio-processing)\r\n      - [Non-Realtime processing:](#non-realtime-processing)\r\n      - [Audio data maintaining process:](#audio-data-maintaining-process)\r\n  - [Table of contents:](#table-of-contents)\r\n  - [Installation](#installation)\r\n        - [Latest PyPI stable release](#latest-pypi-stable-release)\r\n        - [Latest development release on GitHub](#latest-development-release-on-github)\r\n  - [Quick start](#quick-start)\r\n      - [Audio playback](#audio-playback)\r\n      - [Audio slicing](#audio-slicing)\r\n        - [Time domain](#time-domain)\r\n          - [simple slicing](#simple-slicing)\r\n          - [slice & merge](#slice--merge)\r\n        - [Frequency domain](#frequency-domain)\r\n          - [LPF 100Hz](#lpf-100hz)\r\n          - [HPF 1KHz](#hpf-1khz)\r\n          - [BPF 500Hz - 1KHz](#bpf-500hz---1khz)\r\n        - [Complex Slicing](#complex-slicing)\r\n      - [Audio Streaming](#audio-streaming)\r\n    - [Examples and Advanced Usage](#examples-and-advanced-usage)\r\n      - [Short-time Fourier transform](#short-time-fourier-transform)\r\n        - [prerequisites](#prerequisites)\r\n  - [API Documentation](#api-documentation)\r\n    - [Master](#master)\r\n      - [Parameters](#parameters)\r\n      - [Notes](#notes)\r\n      - [Methods](#methods)\r\n        - [add_file](#add_file)\r\n        - [add](#add)\r\n        - [start](#start)\r\n        - [recorder](#recorder)\r\n        - [load_all](#load_all)\r\n        - [load](#load)\r\n        - [get_record_info](#get_record_info)\r\n        - [get_exrecord_info](#get_exrecord_info)\r\n        - [syncable](#syncable)\r\n        - [sync](#sync)\r\n        - [del_record](#del_record)\r\n        - [save_as](#save_as)\r\n        - [save](#save)\r\n        - [save](#save-1)\r\n        - [save_all](#save_all)\r\n        - [get_exrecord_names](#get_exrecord_names)\r\n        - [get_record_names](#get_record_names)\r\n        - [get_nperseg](#get_nperseg)\r\n        - [get_nchannels](#get_nchannels)\r\n        - [get_sample_rate](#get_sample_rate)\r\n        - [stream](#stream)\r\n        - [mute](#mute)\r\n        - [unmute](#unmute)\r\n        - [echo](#echo)\r\n        - [wrap](#wrap)\r\n        - [clean_cache](#clean_cache)\r\n        - [add_pipeline](#add_pipeline)\r\n        - [set_pipeline](#set_pipeline)\r\n        - [set_window](#set_window)\r\n    - [StreamControl](#streamcontrol)\r\n      - [Methods](#methods-1)\r\n        - [isready](#isready)\r\n        - [is_streaming](#is_streaming)\r\n        - [start](#start-1)\r\n        - [resume](#resume)\r\n        - [stop](#stop)\r\n        - [pause](#pause)\r\n        - [enable_loop](#enable_loop)\r\n        - [disable_loop](#disable_loop)\r\n      - [Properties](#properties)\r\n        - [time](#time)\r\n          - [Getter](#getter)\r\n          - [Setter](#setter)\r\n    - [WrapGenerator](#wrapgenerator)\r\n      - [Methods](#methods-2)\r\n        - [get_sample_format](#get_sample_format)\r\n        - [get_sample_width](#get_sample_width)\r\n        - [get_master](#get_master)\r\n        - [get_size](#get_size)\r\n        - [get_cache_size](#get_cache_size)\r\n        - [get_nchannels](#get_nchannels-1)\r\n        - [get_frame_rate](#get_frame_rate)\r\n        - [get_duration](#get_duration)\r\n        - [join](#join)\r\n      - [Magic methods](#magic-methods)\r\n        - [getitem](#getitem)\r\n        - [del](#del)\r\n        - [str](#str)\r\n        - [mul](#mul)\r\n        - [truediv](#truediv)\r\n        - [pow](#pow)\r\n        - [add](#add-1)\r\n        - [sub](#sub)\r\n        - [call](#call)\r\n    - [Wrap](#wrap-1)\r\n      - [Methods](#methods-3)\r\n        - [get_sample_format](#get_sample_format-1)\r\n        - [get_sample_width](#get_sample_width-1)\r\n        - [get_master](#get_master-1)\r\n        - [get_size](#get_size-1)\r\n        - [get_frame_rate](#get_frame_rate-1)\r\n        - [get_nchannels](#get_nchannels-2)\r\n        - [get_duration](#get_duration-1)\r\n        - [join](#join-1)\r\n        - [unpack](#unpack)\r\n        - [get_data](#get_data)\r\n        - [is_packed](#is_packed)\r\n        - [get](#get)\r\n        - [set_data](#set_data)\r\n      - [Magic methods](#magic-methods-1)\r\n        - [del](#del-1)\r\n        - [str](#str-1)\r\n        - [getitem](#getitem-1)\r\n        - [mul](#mul-1)\r\n        - [truediv](#truediv-1)\r\n        - [pow](#pow-1)\r\n        - [add](#add-2)\r\n        - [sub](#sub-1)\r\n    - [Pipeline](#pipeline)\r\n      - [Parameters](#parameters-1)\r\n      - [Methods](#methods-4)\r\n        - [clear](#clear)\r\n        - [run](#run)\r\n        - [insert](#insert)\r\n          - [Parameters](#parameters-2)\r\n          - [Reterns](#reterns)\r\n        - [append](#append)\r\n        - [sync](#sync-1)\r\n        - [aasync](#aasync)\r\n        - [delay](#delay)\r\n        - [set_timeout](#set_timeout)\r\n        - [get_timeout](#get_timeout)\r\n        - [put](#put)\r\n        - [get](#get-1)\r\n      - [Magic methods](#magic-methods-2)\r\n        - [call](#call-1)\r\n        - [delitem](#delitem)\r\n        - [len](#len)\r\n        - [getitem](#getitem-2)\r\n  - [LICENCE](#licence)\r\n\r\n\r\n## Installation\r\n\r\n\r\n##### Latest PyPI stable release\r\n\r\n    pip install sudio\r\n\r\n##### Latest development release on GitHub\r\n\r\nPull and install pre-release `main` branch:\r\n\r\n    pip install git+https://github.com/MrZahaki/sudio.git\r\n\r\n\r\n## Quick start\r\n\r\n#### Audio playback\r\n\r\n```python\r\nimport sudio\r\n\r\nsu = sudio.Master()\r\nsu.add('baroon.mp3')\r\nsu.echo('baroon')\r\n``` \r\n\r\nthe record with the name of baroon will be played on the stdout audio stream. \r\n\r\n#### Audio slicing\r\n\r\n##### Time domain\r\n\r\n###### simple slicing\r\n\r\nThe following example is used to play the audio record with the name of baroon from 12 to 27.66 seconds on the stdout audio stream.\r\n\r\n```python\r\nsu = sudio.Master()\r\nbaroon = su.add('baroon.mp3')\r\nsu.echo(baroon[12: 27.66])\r\n```\r\n\r\n###### slice & merge\r\n\r\n\r\n```python\r\nsu = sudio.Master()\r\nrec = su.add('baroon.mp3')\r\n\r\n# method 1\r\nsu.echo(rec[12: 27.66, 65: 90])\r\n\r\n# method 2\r\nsu.echo(rec[12: 27.66] + rec[65: 90])\r\n```\r\n\r\nThe audio record is split into two parts, the first one 12-27.66 seconds, and the last one 65-90 seconds, then the sliced records are merged and played in the stream.\r\n\r\n\r\n##### Frequency domain\r\n\r\n###### LPF 100Hz\r\n\r\n```python\r\nsu = sudio.Master()\r\nbaroon = su.add('baroon.mp3')\r\nsu.echo(baroon[: '100'])\r\n```\r\n\r\n###### HPF 1KHz\r\n\r\n```python\r\nsu = sudio.Master()\r\nbaroon = su.add('baroon.mp3')\r\nsu.echo(baroon['1000':])\r\n```\r\n\r\n###### BPF 500Hz - 1KHz\r\n\r\n```python\r\nsu = sudio.Master()\r\nbaroon = su.add('baroon.mp3')\r\nsu.echo(baroon['500':'1000'])\r\n```\r\n\r\n##### Complex Slicing\r\n\r\n```python\r\nsu = sudio.Master()\r\nbaroon = su.add('baroon.mp3')\r\nsu.echo(baroon[5:10, :'1000', 10: 20, '1000': '5000'])\r\n```\r\n\r\nIn the example above, a low-pass filter with a cutoff frequency of 1 kHz is applied to the record from 5 to 10 seconds, then a band-pass filter is applied from 10 to 20 seconds, and finally they are merged.\r\n\r\n\r\n\r\n#### Audio Streaming\r\n\r\n\r\n```python\r\nsu = sudio.Master()\r\n\r\n# start sudio kernel\r\nsu.start()\r\n\r\nrecord = su.add('baroon.mp3')\r\nstream = su.stream(record)\r\n\r\n# enable stdout\r\nsu.echo()\r\n\r\n# start streaming\r\nstream.start()\r\n\r\n# wait for 10 seconds  \r\ntime.sleep(10)\r\n\r\n# stop streaming\r\nstream.stop()\r\n```\r\n\r\n\r\n### [Examples and Advanced Usage](#examples-and-advanced-usage)\r\n\r\n<br />\r\n\r\n#### Short-time Fourier transform\r\n\r\nThe [Short-time Fourier transform (STFT)](./examples/STFT/), is a Fourier-related transform used to determine the sinusoidal frequency and phase content of local sections of a signal as it changes over time. In practice, the procedure for computing STFTs is to divide a longer time signal into shorter segments of equal length and then compute the Fourier transform separately on each shorter segment. This reveals the Fourier spectrum on each shorter segment. One then usually plots the changing spectra as a function of time, known as a spectrogram or waterfall plot, such as commonly used in Software Defined Radio (SDR) based spectrum displays. \r\n\r\n\r\n##### prerequisites\r\n\r\n```py\r\npip install sudio\r\npip install kivy\r\n```\r\n\r\n<br />\r\n\r\n![Graphical STFT image](./img/stft.png)\r\n\r\n\r\n<br />\r\n\r\n<!--\r\n### [Usage](#usage)\r\n\r\n### Prerequisites\r\n\r\nSudio has written in the python language, you can see the python documentation from this link. \r\nThis library used scientific computing packages to manipulate data like the numpy and scipy.\r\n-->\r\n\r\n## API Documentation\r\n\r\n### Master\r\n\r\n```py\r\nsudio.Master\r\n```\r\n\r\n\r\n#### Parameters\r\n\r\n- **std_input_dev_id**: int, optional\r\n    os standard input device id. If not given, then the input device id will be selected automatically(ui_mode=False) or manually by the user(ui_mode=True)\r\n\r\n    <br />\r\n    \r\n- **std_output_dev_id**: int, optional\r\n    os standard output device id. If not given, then the output device id will\r\n    be selected automatically(ui_mode=False) or manually by the user(ui_mode=True)\r\n\r\n- **frame_rate**:  int, optional\r\n    Input channel sample rate. If std_input_dev_id is selected as None, the value will be selected automatically.\r\n\r\n    <br />\r\n    \r\n- **nchannels**: int, optional\r\n    The number of audible perspective directions or dimensions.    \r\n    If std_input_dev_id is selected as None, the value will be selected automatically.\r\n\r\n    <br />\r\n    \r\n- **data_format**: SampleFormat\r\n    Specifies the audio bit depths. Supported data format (from sudio):\r\n    **formatFloat32**, **formatInt32**, **formatInt24**, **formatInt16** (default), **formatInt8**, **formatUInt8**\r\n\r\n    <br />\r\n    \r\n- **mono_mode**: bool, optional\r\n    If True, then all the input channels will be mixed into one channel.\r\n\r\n- **ui_mode**: bool, optional\r\n    If Enabled then user interface mode will be activated.\r\n\r\n    <br />\r\n    \r\n- **nperseg**: int,optional\r\n    number of samples per each data frame (in one channel)\r\n\r\n    <br />\r\n    \r\n- **noverlap**: int, default None\r\n\r\n    The noverlap defines the number of overlap between defined windows. If not given then it's value will be selected as\r\n    \r\n    ```math\r\n    SE = \\frac{nperseg}{2}.\r\n    ```\r\n\r\n    When the length of a data set to be transformed is larger than necessary to provide the desired frequency resolution, a common practice is to subdivide it into smaller sets and window them individually.\r\n\r\n    To mitigate the \"loss\" at the edges of the window, the individual sets may overlap in time.\r\n\r\n    \r\n\r\n    <br />\r\n    \r\n- **NOLA_check**: bool, optional\r\n    Check whether the Nonzero Overlap Add (NOLA) constraint is met.(If true)\r\n\r\n    <br />\r\n    \r\n- **IO_mode**: str, optional\r\n    Input/Output processing mode that can be:\r\n    \r\n    <br />\r\n    \r\n    - \"**stdInput2stdOutput**\":(default)\r\n        default mode; standard input stream (system audio or any other windows defined streams) to standard defined output stream (system speakers).\r\n\r\n    - \"**usrInput2usrOutput**\":\r\n        user defined input stream (callback function defined with input_dev_callback) to  user defined output stream (callback function defined with output_dev_callback).\r\n\r\n    - \"**usrInput2stdOutput**\":\r\n        user defined input stream (callback function defined with input_dev_callback) to  user defined output stream (callback function defined with output_dev_callback).\r\n\r\n    - \"**stdInput2usrOutput**\":\r\n        standard input stream (system audio or any other windows defined streams) to  user defined output stream (callback function defined with output_dev_callback).\r\n\r\n    <br />\r\n    \r\n- **input_dev_callback**: callable;\r\n    user input callback; default None; \r\n    this function used in \"**usrInput2usrOutput**\" and \"**usrInput2stdOutput**\" IO modes and called by the sudio core every 1/frame_rate second and must returns frame data as a numpy array with the dimensions of the (Number of channels, Number of data per segment).\r\n    <br />\r\n\r\n    Format: \r\n    \r\n    ```py\r\n    :inputs:    frame_count, time_info, status\r\n    :outputs:   Numpy N-channel data frame in  (Number of channels, Number of data per segment)\r\n                dimensions.\r\n    ```                \r\n    :memo: **Note:** The data frame in single channel mode has the shape of (Number of data per segment, ).\r\n\r\n    <br />\r\n    \r\n- **output_dev_callback**: callable;\r\n\r\n    User input callback; default None;\r\n    This function used in \"**usrInput2usrOutput**\" and \"**stdInput2usrOutput**\" IO modes and called by the sudio core every 1 / frame_rate second after processing frames and takes the frame data as a numpy array in (Number of channels, Number of data per segment) dimensions numpy array.\r\n\r\n    format: \r\n    \r\n    ```py\r\n    :inputs:    Numpy N-channel data frame in  (Number of channels, Number of data per segment) dimensions.\r\n    :outputs: customized audio stream.\r\n    ```\r\n\r\n    :memo: **Note:** The data frame in single channel mode has the shape of (Number of data per segment, ).\r\n\r\n    <br />\r\n    \r\n- **master_mix_callback**: callable, optional\r\n    This callback is used before the main-processing stage in the master for controlling and mixing all slave channels to a ndarray of shape (master.nchannels, 2, master.nperseg).\r\n\r\n    If this parameter is not defined, then the number of audio channels in all slaves must be the same as the master.\r\n\r\n    <br />\r\n    \r\n- **window**:  string, float, tuple, ndarray, optional\r\n    The type of window, to create(string) or pre designed window in numpy array format. use None to disable windowing process.\r\n    Default (\"**hann**\") Hanning function.\r\n\r\n#### Notes\r\n    \r\n-    **If** the window function requires no parameters, then `window` can be a string otherwise the `window` must be a tuple with the first argument the string name of the window, and the next\r\n    arguments the needed parameters.\r\n    <br />\r\n    If `window` is a floating point number, it is interpreted as the beta parameter of the `kaiser` window.\r\n    Each of the window types listed above is also the name of a function that can be called directly to create a window of that type.\r\n    <br />\r\n    window types:\r\n        ```py\r\n        boxcar, triang , blackman, hamming, hann(default), bartlett, flattop, parzen, bohman, blackmanharris\r\n        nuttall, barthann, cosine, exponential, tukey, taylor, kaiser (needs beta),\r\n        gaussian (needs standard deviation), general_cosine (needs weighting coefficients),\r\n        general_gaussian (needs power, width), general_hamming (needs window coefficient),\r\n        dpss (needs normalized half-bandwidth), chebwin (needs attenuation)\r\n        ```\r\n -   \"**nonzero** overlap add\" (NOLA):\r\n    This ensures that the normalization factors in the denominator of the overlap-add inversion equation are not zero. Only very pathological windows will fail the NOLA constraint.\r\n\r\n\r\n#### Methods\r\n\r\n<br />\r\n     \r\n##### add_file\r\n\r\n```py\r\nsudio.Master.add_file(  self, filename: str, sample_format: SampleFormat = SampleFormat.formatUnknown, \r\n                        nchannels: int = None, sample_rate: int = None ,safe_load=True)\r\n```\r\n\r\nThe add_file method used to Add an audio file to the local database. None value for the parameters means that they are automatically selected based on the properties of the audio file.\r\n\r\n- **parameters**:\r\n\r\n    - **filename**: path/name of the audio file\r\n    - **sample_format**: optional; sample format (refer to the SampleFormat data field).\r\n    - **nchannels**: optional;  number of audio channels\r\n    - **sample_rate**: optional;  sample rate\r\n    - **safe_load**: optional;  load an audio file and modify it according to the 'Master' attributes. (sample rate, sample format, number of channels, etc).\r\n\r\n- **returns** WrapGenerator object\r\n\r\n\r\n:memo: **Note:** supported files format: WAV, FLAC, VORBIS, MP3\r\n\r\n:memo: **Note:** The audio data maintaining process has additional cached files to reduce dynamic memory usage and improve performance, meaning that, The audio data storage methods can have different execution times based on the cached files.\r\n\r\n\r\n<br />\r\n\r\n##### add\r\n\r\n```py\r\nsudio.Master.add(self, record, safe_load=True)\r\n```\r\n\r\nAdd new record to the local database.\r\n\r\n- **parameters**:\r\n\r\n    - **record**: can be an wrapped record, Record object or an audio file in mp3, WAV, FLAC or VORBIS format.\r\n    - **safe_load**: optional; load an audio file and modify it according to the 'Master' attributes.\r\n\r\n- **returns** Wrapped(WrapGenerator) object\r\n\r\n:memo: **Note:** The name of the new record can be changed with the following tuple that is passed to the function: (record object, new name of ), otherwise automatically generated.\r\n\r\n:memo: **Note:** The audio data maintaining process has additional cached files to reduce dynamic memory usage and improve performance, meaning that, The audio data storage methods can have different execution times based on the cached files.\r\n\r\n\r\n<br />\r\n\r\n##### start\r\n\r\nstart audio streaming, must be called before audio streaming process. \r\n**returns** master object.\r\n\r\n\r\n\r\n\r\n\r\n<br />\r\n\r\n##### recorder\r\n\r\n```py\r\n   sudio.Master.recorder(self,\r\n                        record_duration: Union[int, float] = 10,\r\n                        name: str=None,\r\n                        enable_compressor: bool=False,\r\n                        noise_sampling_duration: Union[int, float]=1,\r\n                        enable_ui: bool=False,\r\n                        play_recorded: bool=False,\r\n                        catching_precision: float=0.1,\r\n                        echo_mode: bool=False,\r\n                        on_start_callback: callable=None,\r\n                        on_sampling_callback: callable=None)\r\n```\r\n\r\nrecord from main stream for a while.\r\n\r\n\r\n- **parameters**:\r\n\r\n    - **record_duration**: determines duration of the recording process.\r\n    - **name**: optional; name of new record.\r\n    - **enable_compressor**: optional; enable to compress the recorded data. The compressor deletes part of the signal that has lower energy than the sampled noise.\r\n    - **noise_sampling_duration**: optional; noise sampling duration used by the compressor(if enabled).\r\n    - **enable_ui**: optional; user inteface mode (need to install tqdm module)\r\n    - **play_recorded**: optional; Determines whether the recorded file will be played after the recording process.\r\n    - **catching_precision**: optional; Signal compression accuracy, more accuracy can be achieved with a smaller number (default 0.1).\r\n    - **echo_mode**: It can disable the mainstream's echo mode, when the recorder is online.\r\n    - **on_start_callback**: called after noise sampling. \r\n        ```py\r\n        parameters: master object, sampled noise level, record duration time. \r\n        return true to continiue recording.\r\n        ```\r\n- **returns** Wrapped(WrapGenerator) object\r\n\r\n\r\n\r\n<br />\r\n\r\n##### load_all\r\n\r\n```py\r\n   sudio.Master.load_all(self, safe_load=True)\r\n```\r\n\r\nload all of the saved records from the external database(static memory) to the local database(dynamic memory).\r\n\r\n\r\n- **parameters**:\r\n\r\n    - **safe_load**: if safe load is enabled then load function tries to load a record in the local database based on the master settings, like the frame rate and etc.\r\n        ```\r\n- **returns** None\r\n\r\n<br />\r\n\r\n##### load\r\n\r\n```py\r\n   sudio.Master.load(self, name: str, load_all: bool=False, safe_load: bool=True,\r\n                    series: bool=False) -> Union[WrapGenerator, Record])\r\n```\r\n\r\nThe load method used to load a predefined recoed from the external database (static memoty) to\r\nthe local database(dynamic memory). Trying to load a record that was previously loaded, outputs a wrapped version of the named record.\r\n\r\n\r\n- **parameters**:\r\n\r\n  - **name**: The name of the predefined record.\r\n  - **load_all**: used to load all of the saved records from the external database to the local database.\r\n  - **safe_load**: if safe load is enabled this method tries to load a record in the local database, based on the master settings, like the frame rate and etc.\r\n  - **series**: If enabled, attempting to load a record that has already been loaded will output the data series of the named record.\r\n\r\n- **returns** optional; Wrapped object, Record obejct.\r\n\r\n<br />\r\n\r\n\r\n##### get_record_info\r\n\r\n```py\r\n   sudio.Master.get_record_info(self, name: str) -> Record\r\n```\r\n\r\nget extra info about the record \r\n\r\n\r\n- **parameters**:\r\n\r\n  - **name**: name of the registered record on the local or external \r\n\r\n- **returns** information about saved record ['noiseLevel' 'frameRate'  'sizeInByte' 'duration' 'nchannels' 'nperseg' 'name'].\r\n\r\n<br />\r\n\r\n\r\n##### get_exrecord_info\r\n\r\n```py\r\n   sudio.Master.get_exrecord_info(self, name: str) -> Record\r\n```\r\n\r\nget extra info about the record \r\n\r\n\r\n- **parameters**:\r\n\r\n  - **name**: name of the registered record on the external database(if exists).\r\n\r\n- **returns** information about saved record ['noiseLevel' 'frameRate'  'sizeInByte' 'duration' 'nchannels' 'nperseg' 'name'].\r\n\r\n\r\n\r\n\r\n##### syncable\r\n\r\n```py\r\n   sudio.Master.syncable(self,\r\n                        * target,\r\n                        nchannels: int = None,\r\n                        sample_rate: int = None,\r\n                        sample_format: SampleFormat = SampleFormat.formatUnknown)\r\n```\r\n\r\nDetermines whether the wrapped record/s can be synced with specified properties.\r\n\r\n- **parameters**:\r\n\r\n  - **target**: target: wrapped record\\s.(regular records)\r\n\r\n  - **nchannels**: number of channels; if the value is None, the target will be compared to the 'self' properties.\r\n\r\n  - **sample_rate**: sample rate; if the value is None, the target will be compared to the 'self' properties.\r\n\r\n  - **sample_format**: if the value is None, the target will be compared to the 'self' properties.\r\n  - \r\n- **returns** returns only objects that need to be synchronized.\r\n\r\n<br />\r\n\r\n##### sync\r\n\r\n```py\r\n   sudio.Master.sync(self,\r\n                    * targets,\r\n                    nchannels: int=None,\r\n                    sample_rate: int=None,\r\n                    sample_format: SampleFormat=SampleFormat.formatUnknown,\r\n                    output='wrapped')\r\n```\r\n\r\nThis method used to Synchronize wrapped record/s with the specified properties.\r\n\r\n\r\n- **parameters**:\r\n\r\n  - **targets**: wrapped records\\s. \r\n  - **nchannels**: number of channels; if the value is None, the target will be synced to the 'self' properties.\r\n  - **sample_rate**: if the value is None, the target will be synced to the 'self' properties.\r\n  - **sample_format**: if the value is None, the target will be synced to the 'self' properties.\r\n  - **output**: can be 'wrapped'(regular records), 'series'(dict type) or 'ndarray_data'\r\n-  **returns** returns synchronized objects.\r\n\r\n\r\n<br />\r\n\r\n##### del_record\r\n\r\n```py\r\nsudio.Master.del_record(self, name: str, deep: bool=False)\r\n\r\n```\r\n\r\nThe del_record method used to delete a record from the internal/external database.\r\n\r\n\r\n- **parameters**:\r\n\r\n- **name** str: the name of preloaded record.\r\n- **deep** bool: deep delete mode is used to remove the record  and its corresponding caches from the external database.\r\n-  **returns** None\r\n\r\n<br />\r\n\r\n##### save_as\r\n\r\n```py\r\nsudio.Master.save_as(self, record: Union[str, Record, Wrap, WrapGenerator], file_path: str=SAVE_PATH)\r\n```\r\nConvert the record to the wav audio format.\r\n\r\n- **Parameters**:\r\n   - **record**: name of the registered (wrapped) record, a 'Record' object or a (customized) wrapped record.\r\n   - **file_path**: The name or path of the wav file.\r\n        A new name for the record to be converted can be placed at the end of the address.\r\n-  **returns** None\r\n\r\n\r\n<br />\r\n\r\n##### save\r\n\r\n```py\r\nsudio.Master.save(self, name: str='None', save_all: bool=False)\r\n```\r\nSave the preloaded record to the external database.\r\n\r\n- **Parameters**:\r\n   - **name**: name of the preloaded record\r\n    - **save_all**: if true then it's tries to save all of the preloaded records\r\n-  **returns** None\r\n\r\n<br />\r\n\r\n##### save\r\n\r\n```py\r\nsudio.Master.save(self, name: str='None', save_all: bool=False)\r\n```\r\nSave the preloaded record to the external database.\r\n\r\n- **Parameters**:\r\n   - **name**: name of the preloaded record\r\n    - **save_all**: if true then it's tries to save all of the preloaded records\r\n-  **returns** None\r\n    \r\n<br />\r\n\r\n##### save_all\r\n\r\n```py\r\nsudio.Master.save_all(self)\r\n```\r\n\r\nSave all of the preloaded records to the external database\r\n-  **returns** None    \r\n\r\n<br />\r\n\r\n##### get_exrecord_names\r\n\r\n```py\r\nsudio.Master.get_exrecord_names(self) -> list\r\n```\r\n\r\n:return: list of the saved records in the external database\r\n\r\n\r\n<br />\r\n\r\n##### get_record_names\r\n\r\n```py\r\nsudio.Master.get_record_names(self, local_database: bool=True) -> list\r\n```\r\n\r\n**param** local_database: if false then external database will be selected\r\n**returns**: a list of the saved records in the external or internal database\r\n\r\n<br />\r\n\r\n##### get_nperseg\r\n\r\n```py\r\nsudio.Master.get_nperseg(self)\r\n```\r\n\r\n**returns**:  number of samples per each data frame (single channel)\r\n\r\n<br />\r\n\r\n##### get_nchannels\r\n\r\n```py\r\nsudio.Master.get_nchannels(self)\r\n```\r\n\r\n Returns the number of audible perspective directions or dimensions of the current wrapped record.\r\n\r\n\r\n<br />\r\n\r\n##### get_sample_rate\r\n\r\n```py\r\nsudio.Master.get_sample_rate(self)\r\n```\r\n\r\n**returns**: current master sample rate\r\n\r\n\r\n<br />\r\n\r\n##### stream\r\n\r\n\r\n```py\r\nsudio.Master.stream(self, \r\n                    record: Union[str, Wrap, Record, WrapGenerator],\r\n                    block_mode: bool=False,\r\n                    safe_load: bool=False,\r\n                    on_stop: callable=None,\r\n                    loop_mode: bool=False,\r\n                    use_cached_files=True,\r\n                    stream_mode:StreamMode = StreamMode.optimized\r\n                    ) -> StreamControl\r\n```\r\n'Record' playback on the mainstream.\r\n\r\n\r\n- **Parameters**:\r\n\r\n  - **record**: predefined record name, (customized) wrapped record, or a 'Record' object.\r\n  - **block_mode**: This can be true, in which case the current thread will be\r\n      blocked as long as the stream is busy.\r\n  - **safe_load**: load an audio file and modify it according to the 'Master' attributes(like the frame rate, number oof channels, etc).\r\n  - **on_stop**: An optional callback is called at the end of the streaming process.\r\n  - **loop_mode**: playback continuously.\r\n  - **use_cached_files**: enable additional cache maintaining process.\r\n  - **stream_mode**: (see StreamMode enum).\r\n\r\n-  **returns** StreamControl object\r\n    \r\n\r\n\r\n:memo: **Note:** The recorder can only capture normal streams(Non-optimized streams)\r\n\r\n\r\n<br />\r\n\r\n##### mute\r\n\r\n```py\r\nsudio.Master.mute(self)\r\n```\r\nmute the stdin stream (default)\r\n\r\n\r\n<br />\r\n\r\n##### unmute\r\n\r\n```py\r\nsudio.Master.unmute(self)\r\n```\r\ndisable mute mode of the stdin stream\r\n\r\n\r\n\r\n<br />\r\n\r\n##### echo\r\n\r\n\r\n```py\r\nsudio.Master.echo(  self, \r\n                    record: Union[Wrap, str, Record, WrapGenerator]=None,\r\n                    enable: bool=None, \r\n                    main_output_enable: bool=False)\r\n```\r\nstart to play \"Record\" on the operating system's default audio output.          \r\n\r\n- **Parameters**:\r\n\r\n  - **record**: optional, default None;\r\n      It could be a predefined record name, a wrapped record,\r\n      or a 'Record' object.\r\n\r\n  - **enable**: optional, default None(trigger mode)\r\n      determines that the standard output of the master is enable or not.\r\n\r\n  - **main_output_enable**:\r\n      when the 'record' is not None, controls the standard output activity of the master\r\n\r\n-  **returns** self object\r\n    \r\n\r\n:memo: **Note:** If the 'record' argument takes the value None, the method controls the standard output activity of the master with the 'enable' argument.\r\n\r\n:memo: **Note:** If the 'record' argument takes the value None, the kernel starts streaming the std input to the std output.\r\n\r\n\r\n\r\n<br />\r\n\r\n##### wrap\r\n\r\n```py\r\nsudio.Master.wrap(self, record: Union[str, Record])\r\n```\r\n\r\nCreate a Wrap object.\r\n\r\n**param** record: preloaded record or a Record object\r\n**returns**: Wrap object\r\n\r\n<br />\r\n\r\n##### clean_cache\r\n\r\n```py\r\nsudio.Master.clean_cache(self)\r\n```\r\n\r\nThe audio data maintaining process has additional cached files to reduce dynamic memory usage and improve performance, meaning that, The audio data storage methods can have different execution times based on the cached files. This function used to clean additional cached files.\r\n\r\n**returns**: self object\r\n\r\n<br />\r\n\r\n##### add_pipeline\r\n\r\n```py\r\nsudio.Master.add_pipeline(  self, \r\n                            name: str, \r\n                            pip: Union[Pipeline, list],\r\n                            process_type: str='main', \r\n                            channel: int=None)\r\n\r\n```\r\n\r\nAdd a new process pipeline to the master object.\r\n\r\n- **Parameters**:\r\n\r\n  - **name**: string; represents the new pipeline\r\n     <br/>\r\n  \r\n  - **pip**: obj; Pipeline object/s\r\n             In the multi_stream process type, this argument must be a list of the defined pipelines, with the size equal to the nchannel.\r\n     <br/>\r\n\r\n  - **process_type**: string; 'main', 'branch', 'multi_stream'\r\n     The sudio kernel inject audio data to the activated pipeline[if exist] and all of the branch type pipelines then takes output from the primary one.\r\n     \r\n     <br />\r\n\r\n     :memo: **Note:** Use set_pipeline to activate a main branch or a multi_stream one.\r\n     <br />\r\n\r\n     :memo: **Note:** A branch pipeline is used for data monitoring(GUI) purposes.\r\n\r\n     <br/>\r\n        \r\n\r\n  - **channel**: obj; None or [0 to nchannel]; just activated in branched pipelines;\r\n\r\n     The input  data passed to a pipeline can be an numpy array with the shape of the (number of the audio channels, 2 [number of the windows per each frame], nperseg) (in mono mode (2, self._nperseg)).\r\n     <br/>\r\n\r\n:memo: **Note:** the  pipeline used to process data and return it to the kernel with the  dimensions as same as the input.\r\n\r\n:memo: **Note:** Each pipeline used to process data in different threads, so the the performance will be improved. \r\n\r\n<br />\r\n\r\n##### set_pipeline\r\n\r\n```py\r\nsudio.Master.set_pipeline(self, name: str, enable: bool=True)\r\n```\r\n\r\nactivate the registered pipeline on the process stream. \r\n\r\n- **Parameters**:\r\n\r\n  - **name**: string; A name that represents the new pipeline\r\n  - **enable**: bool; state of the primary pipeline.\r\n\r\n:memo: **Note:** Only multi_stream and main branches are allowed for activation.\r\n\r\n<br />\r\n\r\n##### set_window\r\n\r\n\r\n```py\r\nsudio.Master.set_window(self,\r\n                        window: object = 'hann',\r\n                        noverlap: int = None,\r\n                        NOLA_check: bool = True)\r\n```\r\n      \r\nchange type of the current processing window.\r\n\r\n- **Parameters**:\r\n\r\n  - **window**: string, float, tuple, ndarray, optional\r\n    The type of window, to create (string) or pre designed window in numpy array format. use None to disable windowing process.\r\n    Default (\"**hann**\") Hanning function.\r\n\r\n  - **noverlap**: int, default None\r\n\r\n    The noverlap defines the number of overlap between defined windows. If not given then it's value will be selected as\r\n    \r\n    ```math\r\n    SE = \\frac{nperseg}{2}.\r\n    ```\r\n\r\n    When the length of a data set to be transformed is larger than necessary to provide the desired frequency resolution, a common practice is to subdivide it into smaller sets and window them individually.\r\n\r\n    To mitigate the \"loss\" at the edges of the window, the individual sets may overlap in time.\r\n\r\n  - **NOLA_check**: bool, optional\r\n    Check whether the Nonzero Overlap Add (NOLA) constraint is met.(If true)\r\n\r\n\r\n<br />\r\n\r\n### StreamControl\r\n\r\n```py\r\nsudio.Master.StreamControl\r\n```\r\n\r\nThe StreamControl class used to control data flow of an audio record (live control on audio streaming).\r\n\r\n<br />\r\n\r\n#### Methods\r\n\r\n\r\n\r\n<br />\r\n\r\n##### isready\r\n\r\n```py\r\nsudio.Master.StreamControl.isready()\r\n```\r\ncheck current stream compatibility with the Master object and return true on ready to streaming.\r\n\r\n\r\n<br />\r\n\r\n##### is_streaming\r\n\r\n```py\r\nsudio.Master.StreamControl.is_streaming()\r\n```\r\n\r\nreturn true if current stream was started before. \r\n\r\n<br />\r\n\r\n##### start\r\n\r\n```py\r\nsudio.Master.StreamControl.start()\r\n```\r\n\r\ncheck current stream compatibility with the Master object and start to streaming.\r\n\r\n<br />\r\n\r\n##### resume\r\n\r\n```py\r\nsudio.Master.StreamControl.resume()\r\n```\r\n\r\nresume current streaming if current stream was paused.\r\n\r\n<br />\r\n\r\n##### stop\r\n\r\n```py\r\nsudio.Master.StreamControl.stop()\r\n```\r\nstop current streaming if current stream is activated.\r\n\r\n\r\n<br />\r\n\r\n##### pause\r\n\r\n```py\r\nsudio.Master.StreamControl.pause()\r\n```\r\n\r\npause current streaming if current stream is activated.\r\n\r\n\r\n<br />\r\n\r\n##### enable_loop\r\n\r\n```py\r\nsudio.Master.StreamControl.enable_loop()\r\n```\r\n\r\nenable to restart at the end of streaming. \r\n\r\n<br />\r\n\r\n##### disable_loop\r\n\r\n```py\r\nsudio.Master.StreamControl.disable_loop()\r\n```\r\n\r\ndisable audio streaming loop mode.\r\n\r\n<br />\r\n\r\n\r\n#### Properties\r\n\r\n\r\n\r\n<br />\r\n\r\n##### time\r\n\r\n```py\r\nsudio.Master.StreamControl.time\r\n```\r\n\r\n###### Getter\r\n\r\nused to retrive elapsed time of the current streamed record.\r\n\r\n###### Setter\r\n\r\nSet the current time of streamed record.\r\n\r\n\r\n<br />\r\n<br />\r\n\r\n### WrapGenerator\r\n\r\n```py\r\nsudio.WrapGenerator(self, master: Master, record: Union[str, pd.Series])\r\n```\r\n\r\nGenerates a Wrap object, which wraps the raw record.\r\n\r\n\r\n<br />\r\n\r\n#### Methods\r\n\r\n\r\n\r\n##### get_sample_format\r\n\r\n```py\r\nsudio.WrapGenerator.get_sample_format(self) -> SampleFormat\r\n```\r\n Returns sample format of the current generator.\r\n\r\n<br />\r\n\r\n##### get_sample_width\r\n\r\n```py\r\nsudio.WrapGenerator.get_sample_width(self) -> int\r\n```\r\n Returns sample width of the current wrapped record.\r\n\r\n\r\n<br />\r\n\r\n##### get_master\r\n\r\n```py\r\nsudio.WrapGenerator.get_master(self) -> Master\r\n```\r\n\r\n Returns the Master object of the current generator.\r\n\r\n\r\n<br />\r\n\r\n##### get_size\r\n\r\n```py\r\nsudio.WrapGenerator.get_size(self) -> int\r\n```\r\n\r\nReturns size of the currently processed record on non-volatile memory.\r\n\r\n\r\n:memo: **Note:** Wrapped objects normally stored statically, so all of the calculations need additional IO read/write time, This decrese dynamic memory usage specically for big audio data.\r\n\r\n<br />\r\n\r\n##### get_cache_size\r\n\r\n```py\r\nsudio.WrapGenerator.get_cache_size(self) -> int\r\n```\r\n\r\nReturns size of cached file on non-volatile memory.\r\n\r\n\r\n:memo: **Note:** Wrapped objects normally stored statically, so all of the calculations need additional IO read/write time, This decrese dynamic memory usage specically for big audio data.\r\n\r\n<br />\r\n\r\n##### get_nchannels\r\n\r\n```py\r\nsudio.WrapGenerator.get_nchannels(self) -> int\r\n```\r\n\r\n Returns the number of audible perspective directions or dimensions of the current wrapped record.\r\n\r\n<br />\r\n\r\n##### get_frame_rate\r\n\r\n```py\r\nsudio.WrapGenerator.get_frame_rate(self) -> int\r\n```\r\n\r\nReturns frame rate of the current warpped record.\r\n\r\n<br />\r\n\r\n##### get_duration\r\n\r\n```py\r\nsudio.WrapGenerator.get_duration(self) -> float\r\n```\r\n\r\nReturns the duration of the provided audio record.\r\n\r\n<br />\r\n\r\n##### join\r\n\r\n```py\r\nsudio.WrapGenerator.join(self,\r\n                        *other: Union[Wrap, WrapGenerator],\r\n                        sync_sample_format: SampleFormat = None,\r\n                        sync_nchannels: int = None,\r\n                        sync_sample_rate: int = None,\r\n                        safe_load: bool = True\r\n                        ) -> Wrap\r\n```\r\n\r\nReturns a new wrapped record by joining and synchronizing all the elements of the 'other' iterable (Wrap, WrapGenerator), separated by the given separator.\r\n\r\n- **parameters**:\r\n\r\n  - **other**: wrapped record\\s. \r\n  - **sync_nchannels**: number of channels; if the value is None, the target will be synced \r\n  - **sync_sample_format**: if the value is None, the target will be synced to the master properties.\r\n  - **sync_sample_rate**: sample rate; if the value is None, the target will be compared to the master properties.\r\n  - **safe_load**: load an audio file and modify it according to the 'Master' attributes(like the frame rate, number oof channels, etc).\r\n-  **returns** new Wrap object.\r\n\r\n<br />\r\n\r\n\r\n\r\n#### Magic methods\r\n\r\n\r\n\r\n\r\n##### getitem\r\n\r\n```py\r\nsudio.WrapGenerator.__getitem__(self, item) -> Wrap\r\n```\r\n\r\n**Slicing** : \r\nThe Wrapped object can be sliced using the standard Python x[start: stop: step] syntax, where x is the wrapped object.\r\n\r\n  Slicing the **time domain**:  \r\n\r\n  The basic slice syntax is \r\n  ```math\r\n  [i: j: k, i(2): j(2): k(2), i(n): j(n): k(n)] \r\n  ```\r\n  \r\n  where i is the start time, j is the stop time in integer or float types and k is the step(negative number for inversing).\r\n  This selects the nXm seconds with index times \r\n  ```py\r\n  i, i+1, i+2, ..., j, i(2), i(2)+1, ..., j(2), i(n), ..., j(n)\r\n  j where m = j - i (j > i).\r\n  ```\r\n\r\n  :memo: **Note:** for i < j, i is the stop time and j is the start time, means that audio data read inversely.\r\n\r\n  **Filtering** (Slicing the frequency domain):  \r\n\r\n  The basic slice syntax is \r\n  \r\n  \r\n  ```py\r\n  ['i': 'j': 'filtering options', 'i(2)': 'j(2)': 'options(2)', ..., 'i(n)': 'j(n)': 'options(n)']\r\n  ```\r\n\r\n  where i is the starting frequency and j is the stopping frequency with type of string in the same units as fs that fs is 2 half-cycles/sample.\r\n  This activates n number of iir filters with specified frequencies and options.\r\n\r\n  For the slice syntax [x: y: options] we have:\r\n  - x= None, y= 'j': low pass filter with a cutoff frequency of the j\r\n  - x= 'i', y= None: high pass filter with a cutoff frequency of the i\r\n  - x= 'i', y= 'j': bandpass filter with the critical frequencies of the i, j\r\n  - x= 'i', y= 'j', options='scale=[Any negative number]': bandstop filter with the critical frequencies of the i, j\r\n\r\n  **Filtering** options:\r\n  - ftype: optional; The type of IIR filter to design:\\n\r\n    - Butterworth : â€˜butterâ€™(default)\r\n    - Chebyshev I : â€˜cheby1â€™\r\n    - Chebyshev II : â€˜cheby2â€™\r\n    - Cauer/elliptic: â€˜ellipâ€™\r\n    - Bessel/Thomson: â€˜besselâ€™\r\n  - rs: float, optional:\\n\r\n    For Chebyshev and elliptic filters, provides the minimum attenuation in the stop band. (dB)\r\n  - rp: float, optional:\\n\r\n    For Chebyshev and elliptic filters, provides the maximum ripple in the passband. (dB)\r\n  - order: The order of the filter.(default 5)\r\n  - scale: [float, int] optional; The attenuation or Amplification factor,\r\n    that in the bandstop filter must be a negative number.\r\n\r\n  **Complex** slicing:\r\n  The basic slice syntax is \r\n  \r\n  ```py\r\n  [a: b, 'i': 'j': 'filtering options', ..., 'i(n)': 'j(n)': 'options(n)', ..., a(n): b(n), 'i': 'j': 'options', ..., 'i(n)': 'j(n)': 'options(n)'] \r\n  ```\r\n\r\n  or\r\n\r\n  ```py\r\n  [a: b, [Filter block 1)], a(2): b(2), [Filter block 2]  ... , a(n): b(n), [Filter block n]]\r\n  ```\r\n\r\n  Where i is the starting frequency, j is the stopping frequency, a is the starting time and b is the stopping time in seconds. This activates n number of filter blocks [described in the filtering section] that each of them operates within a predetermined time range.\r\n\r\nnote:\r\n  The sliced object is stored statically so calling the original wrapped returns The sliced object.\r\n\r\n\r\n<br />\r\n\r\n##### del\r\n\r\n```py\r\nsudio.WrapGenerator.__del__(self)\r\n```\r\n\r\nDelete the current object and its dependencies (cached files, etc.)\r\n\r\n<br />\r\n\r\n##### str\r\n\r\n```py\r\nsudio.WrapGenerator.__str__(self)\r\n```\r\n\r\nReturns string representation of the current object\r\n\r\n\r\n<br />\r\n\r\n##### mul\r\n\r\n```py\r\nsudio.WrapGenerator.__mul__(self, scale) -> Wrap\r\n```\r\n\r\nReturns a new Wrap object, scaling the data of the current record.\r\n\r\n<br />\r\n\r\n##### truediv\r\n\r\n```py\r\nsudio.WrapGenerator.__truediv__(self, scale)\r\n```\r\n\r\nReturns a new Wrap object, dividing the data of the current record.\r\n\r\n\r\n\r\n<br />\r\n\r\n##### pow\r\n\r\n```py\r\nsudio.WrapGenerator.__pow__(self, power, modulo=None)\r\n```\r\n\r\nReturns a new Wrap object, scaling the data of the current record.\r\n\r\n\r\n<br />\r\n\r\n##### add\r\n\r\n```py\r\nsudio.WrapGenerator.__add__(self, other:Union[Wrap, WrapGenerator, int, float])\r\n```\r\n\r\nif the 'other' parameter is a WrapGenerator or a Wrap object this method joins the current object to the other one, otherwise this method used to  Return a new Wrap object, scaling the data of the current record. \r\n\r\n\r\n<br />\r\n\r\n##### sub\r\n\r\n```py\r\nsudio.WrapGenerator.__sub__(self, other: Union[float, int])\r\n```\r\nReturns a new Wrap object, subtracting the data of the current record. \r\n\r\n\r\n<br />\r\n\r\n##### call\r\n\r\n```py\r\nsudio.WrapGenerator.__call__(self,\r\n                            *args,\r\n                            sync_sample_format_id: int = None,\r\n                            sync_nchannels: int = None,\r\n                            sync_sample_rate: int = None,\r\n                            safe_load: bool = True\r\n                            ) -> Wrap\r\n```\r\nSynchronize the current object with the master (optional) and create a new Wrap object.\r\n\r\n- **parameters**:\r\n\r\n  - **sync_nchannels**: number of channels; if the value is None, the target will be synced \r\n  - **sync_sample_format_id**: if the value is None, the target will be synced to the master properties.\r\n  - **sync_sample_rate**: sample rate; if the value is None, the target will be compared to the master properties.\r\n  - **safe_load**: load an audio file and modify it according to the 'Master' attributes(like the frame rate, number oof channels, etc).\r\n-  **returns** new Wrap object.\r\n\r\n:memo: **Note:** Wrapped objects normally stored statically, so all of the calculations need additional IO read/write time, This decrese dynamic memory usage specically for big audio data.\r\n\r\n\r\n<br />\r\n<br />\r\n\r\n### Wrap\r\n\r\n```py\r\nsudio.Wrap(self, master: Master, record: pd.Series, generator: WrapGenerator)\r\n```\r\n\r\n<br />\r\n\r\n\r\n#### Methods\r\n\r\n##### get_sample_format\r\n\r\n```py\r\nsudio.Wrap.get_sample_format(self) -> SampleFormat\r\n```\r\n\r\n Returns sample format of the current warpped record.\r\n\r\n<br />\r\n\r\n##### get_sample_width\r\n\r\n```py\r\nsudio.Wrap.get_sample_width(self) -> int\r\n```\r\n\r\n Returns sample width.\r\n\r\n<br />\r\n\r\n##### get_master\r\n\r\n```py\r\nsudio.Wrap.get_master(self) -> Master\r\n```\r\n\r\n Returns the Master object.\r\n\r\n<br />\r\n\r\n##### get_size\r\n\r\n```py\r\nsudio.Wrap.get_size(self) -> int\r\n```\r\n\r\nReturns size of the currently processed record on non-volatile memory.\r\n\r\n:memo: **Note:** Wrapped objects normally stored statically, so all of the calculations need additional IO read/write time, This decrese dynamic memory usage specically for big audio data.\r\n\r\n<br />\r\n\r\n##### get_frame_rate\r\n\r\n```py\r\nsudio.Wrap.get_frame_rate(self) -> int\r\n```\r\n\r\nReturns frame rate of the current warpped record.\r\n\r\n\r\n<br />\r\n\r\n##### get_nchannels\r\n\r\n```py\r\nsudio.Wrap.get_nchannels(self) -> int\r\n```\r\n\r\n Returns the number of audible perspective directions or dimensions of the current wrapped record.\r\n\r\n<br />\r\n\r\n##### get_duration\r\n\r\n```py\r\nsudio.Wrap.get_duration(self) -> float\r\n```\r\n\r\nReturns the duration of the provided audio record.\r\n\r\n\r\n<br />\r\n\r\n##### join\r\n\r\n```py\r\nsudio.Wrap.join(self, *other) -> Wrap\r\n```\r\n\r\nReturns a new wrapped record by joining and synchronizing all the elements of the 'other' iterable (Wrap, WrapGenerator), separated by the given separator.\r\n\r\n\r\n<br />\r\n\r\n##### unpack\r\n\r\n```py\r\n@contextmanager\r\nsudio.Wrap.unpack(self, reset=False) -> np.ndarray\r\n```\r\n\r\nUnpack audio data  from cached files to the dynamic memory.\r\n\r\n:memo: **Note:**  All calculations in the unpacked block are performed on the precached files (not the original audio data).\r\n\r\n\r\n- **parameters**:\r\n  - **reset**: Reset the audio pointer to time 0 (Equivalent to slice '[:]').\r\n-  **Returns** audio data in ndarray format with shape of (number of audio channels, block size).\r\n\r\n```py\r\nmaster = Master()\r\nwrap = master.add('file.mp3')\r\nwith wrap.unpack() as data:\r\n    wrap.set_data(data * .7)\r\nmaster.echo(wrap)\r\n```\r\n<br />\r\n\r\n##### get_data\r\n\r\n```py\r\nsudio.Wrap.get_data(self) -> Union[pd.Series, numpy.ndarray]\r\n```\r\nif the current object is unpacked:\r\n- Returns the audio data in a ndarray format with shape of (number of audio channels, block size).\r\n\r\notherwise:\r\n- Returns the current record.\r\n\r\n\r\n<br />\r\n\r\n##### is_packed\r\n\r\n```py\r\nsudio.Wrap.is_packed(self) -> bool\r\n```\r\n\r\nReturns true if the Wrap object is packed.\r\n\r\n<br />\r\n\r\n##### get\r\n\r\n```py\r\n@contextmanager\r\nsudio.Wrap.get(self, offset=None, whence=None)\r\n```\r\n\r\n Returns the audio data as a _io.BufferedRandom IO file.\r\n\r\n<br />\r\n\r\n##### set_data\r\n\r\n```py\r\nsudio.Wrap.set_data(self, data: numpy.ndarray)\r\n```\r\n\r\nSet audio data for current wrapped record (object must be unpacked to the volatile memory).\r\n\r\n<br />\r\n\r\n\r\n\r\n\r\n#### Magic methods\r\n\r\n##### del\r\n\r\n```py\r\nsudio.Wrap.__del__(self)\r\n```\r\n\r\nDelete the current object and its dependencies (cached files, etc.)\r\n\r\n<br />\r\n\r\n##### str\r\n\r\n```py\r\nsudio.Wrap.__str__(self)\r\n```\r\n\r\nReturns string representation of the current object\r\n\r\n\r\n<br />\r\n\r\n\r\n##### getitem\r\n\r\n```py\r\nsudio.Wrap.__getitem__(self, item) -> self\r\n```\r\n\r\n\r\n**Slicing** : \r\nThe Wrapped object can be sliced using the standard Python x[start: stop: step] syntax, where x is the wrapped object.\r\n\r\n  Slicing the **time domain**:  \r\n\r\n  The basic slice syntax is \r\n  ```math\r\n  [i: j: k, i(2): j(2): k(2), i(n): j(n): k(n)] \r\n  ```\r\n  \r\n  where i is the start time, j is the stop time in integer or float types and k is the step(negative number for inversing).\r\n  This selects the nXm seconds with index times \r\n  ```py\r\n  i, i+1, i+2, ..., j, i(2), i(2)+1, ..., j(2), i(n), ..., j(n)\r\n  j where m = j - i (j > i).\r\n  ```\r\n\r\n  :memo: **Note:** for i < j, i is the stop time and j is the start time, means that audio data read inversely.\r\n\r\n  **Filtering** (Slicing the frequency domain):  \r\n\r\n  The basic slice syntax is \r\n  \r\n  \r\n  ```py\r\n  ['i': 'j': 'filtering options', 'i(2)': 'j(2)': 'options(2)', ..., 'i(n)': 'j(n)': 'options(n)']\r\n  ```\r\n\r\n  where i is the starting frequency and j is the stopping frequency with type of string in the same units as fs that fs is 2 half-cycles/sample.\r\n  This activates n number of iir filters with specified frequencies and options.\r\n\r\n  For the slice syntax [x: y: options] we have:\r\n  - x= None, y= 'j': low pass filter with a cutoff frequency of the j\r\n  - x= 'i', y= None: high pass filter with a cutoff frequency of the i\r\n  - x= 'i', y= 'j': bandpass filter with the critical frequencies of the i, j\r\n  - x= 'i', y= 'j', options='scale=[Any negative number]': bandstop filter with the critical frequencies of the i, j\r\n\r\n  **Filtering** options:\r\n  - ftype: optional; The type of IIR filter to design:\\n\r\n    - Butterworth : â€˜butterâ€™(default)\r\n    - Chebyshev I : â€˜cheby1â€™\r\n    - Chebyshev II : â€˜cheby2â€™\r\n    - Cauer/elliptic: â€˜ellipâ€™\r\n    - Bessel/Thomson: â€˜besselâ€™\r\n  - rs: float, optional:\\n\r\n    For Chebyshev and elliptic filters, provides the minimum attenuation in the stop band. (dB)\r\n  - rp: float, optional:\\n\r\n    For Chebyshev and elliptic filters, provides the maximum ripple in the passband. (dB)\r\n  - order: The order of the filter.(default 5)\r\n  - scale: [float, int] optional; The attenuation or Amplification factor,\r\n    that in the bandstop filter must be a negative number.\r\n\r\n  **Complex** slicing:\r\n  The basic slice syntax is \r\n  \r\n  ```py\r\n  [a: b, 'i': 'j': 'filtering options', ..., 'i(n)': 'j(n)': 'options(n)', ..., a(n): b(n), 'i': 'j': 'options', ..., 'i(n)': 'j(n)': 'options(n)'] \r\n  ```\r\n\r\n  or\r\n\r\n  ```py\r\n  [a: b, [Filter block 1)], a(2): b(2), [Filter block 2]  ... , a(n): b(n), [Filter block n]]\r\n  ```\r\n\r\n  Where i is the starting frequency, j is the stopping frequency, a is the starting time and b is the stopping time in seconds. This activates n number of filter blocks [described in the filtering section] that each of them operates within a predetermined time range.\r\n\r\nnote:\r\n  The sliced object is stored statically so calling the original wrapped returns The sliced object.\r\n\r\n\r\n\r\n<br />\r\n\r\n##### mul\r\n\r\n```py\r\nsudio.Wrap.__mul__(self, scale) -> Wrap\r\n```\r\n\r\nReturns current object, dividing the data of the current record.\r\n\r\n\r\n<br />\r\n\r\n##### truediv\r\n\r\n```py\r\nsudio.Wrap.__truediv__(self, scale)\r\n```\r\n\r\nReturns current object, dividing the data of the current record.\r\n\r\n\r\n<br />\r\n\r\n##### pow\r\n\r\n```py\r\nsudio.Wrap.__pow__(self, power, modulo=None)\r\n```\r\n\r\nReturns a new Wrap object, scaling the data of the current record.\r\n\r\n<br />\r\n\r\n##### add\r\n\r\n```py\r\nsudio.Wrap.__add__(self, other:Union[Wrap, WrapGenerator, int, float])\r\n```\r\n\r\nif the 'other' parameter is a WrapGenerator or a Wrap object this method joins the current object to the other one, otherwise this method used to  Return a current object, scaling the data of the current record. \r\n\r\n<br />\r\n\r\n##### sub\r\n\r\n```py\r\nsudio.Wrap.__sub__(self, other: Union[float, int])\r\n```\r\n\r\nReturns current object, subtracting the data of the current record. \r\n\r\n<br />\r\n\r\n\r\n\r\n\r\n<br />\r\n<br />\r\n\r\n### Pipeline\r\n\r\nA pipeline is a system of pipes used to transport data, each pipe is a method that processes data and pass it to the next one.  \r\n\r\nPipeline helps the audio processing algorithms to break the complexity into smaller blocks, and the use of threading techniques improves the overall performance of the system.\r\n\r\n```py\r\nsudio.Pipeline\r\n```\r\n\r\n```mermaid \r\n  graph LR;\r\n      A(Input Queue)-->B(Pipe 0);\r\n      B-->C(Pipe 1);\r\n      C-->D(...);\r\n      D-->E(Output Queue);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### Parameters\r\n\r\n\r\n\r\n- **max_size**: int, optional\r\n    Maximum number of callable per Pipeline object \r\n\r\n    <br />\r\n    \r\n- **io_buffer_size**: int, optional\r\n    Maximum size of the I/O queues.\r\n\r\n- **on_busy**:  [float, str], optional\r\n    Determines the behavior of the pipeline after the I/O queues are full. (busy state).\r\n\r\n    Please use:\r\n    -  \"drop\" to drop old data from the output queue and allocate new space for new ones.\r\n    -  \"block\" to block the pipeline until the last data arrives.\r\n    -  timeout in float type to block the pipeline until the end time.\r\n\r\n  <br />\r\n    \r\n- **list_dispatch**: bool, optional\r\n    dispatch the input list type, to the arguments of the first pipe.\r\n\r\n    <br />\r\n\r\n\r\n#### Methods\r\n\r\n\r\n##### clear\r\n\r\n\r\n```py\r\nsudio.Pipeline.clear(self)\r\n```\r\n      \r\nRemove all of the items from the I/O queues in block mode.\r\n\r\n<br />\r\n\r\n\r\n##### run\r\n\r\n```py\r\nsudio.Pipeline.run(self)\r\n```\r\n\r\nStart data injection into pipeline. \r\n\r\n<br />\r\n\r\n\r\n##### insert\r\n\r\n```py\r\nsudio.Pipeline.insert(self,\r\n                      index: int,\r\n                      *func: callable,\r\n                      args: Union[list, tuple, object] = (),\r\n                      init: Union[list, tuple, callable] = ())\r\n```\r\n\r\nInsert callable/s before index.\r\n\r\n###### Parameters\r\n\r\n\r\n\r\n- **index**: int\r\n  \r\n    index value.\r\n\r\n    <br />\r\n    \r\n- **func**: callable\r\n- \r\n    Pipeline callable element/s.\r\n\r\n  <br />\r\n\r\n- **args**:  (tuple, list, object), optional\r\n  \r\n    the static argument/s, will be passed to the pipeline element/s.\r\n\r\n    example:\r\n    - multiple arguments for multiple callables\r\n\r\n      ```py\r\n      def f0(arg0, arg1, data):\r\n        return data\r\n\r\n      def f1(arg, data):\r\n        return data\r\n\r\n      pip = sudio.Pipeline()\r\n      pip.insert(2, f0, f1, args=(['arg0 for f0', 'arg1 for f0'], 'single arg for f1'))\r\n      ```\r\n\r\n    - single argument for multiple callables\r\n\r\n      ```py\r\n      \r\n      def f0(arg, data):\r\n        return data\r\n\r\n      def f1(arg, data):\r\n        return data\r\n\r\n      pip = sudio.Pipeline()\r\n      pip.insert(2, f0, f1, args='single arg for all')\r\n      ```\r\n      \r\n      ```py\r\n      def f0(data):\r\n        return data\r\n\r\n      def f1(arg, data):\r\n        return data\r\n\r\n      pip = sudio.Pipeline()\r\n      pip.insert(2, f0, f1, args=(None, 'single arg for f1'))\r\n      ```\r\n\r\n    - single argument for single callable\r\n\r\n      ```py\r\n      \r\n      def f0(arg, data):\r\n        return data\r\n\r\n      pip = sudio.Pipeline()\r\n      pip.insert(2, f0, args='single arg for f0')\r\n      ```\r\n\r\n  <br />\r\n    \r\n- **init**: (list, tuple, callable), optional\r\n \r\n    single or multiple callables suggested for access to the pipeline's shared memory, that called after starting pipeline thread execution.\r\n\r\n\r\n###### Reterns\r\n\r\n  - self object\r\n\r\n\r\n<br />\r\n\r\n\r\n##### append\r\n\r\n```py\r\nsudio.Pipeline.append(self,\r\n                      *func: callable,\r\n                      args: Union[list, tuple, object] = (),\r\n                      init: Union[list, tuple, callable] = ())\r\n```\r\n\r\nAppend callable/s to the end of the pipeline.\r\nFor more detailes Please refer to the  sudio.Pipeline.insert method.\r\n\r\n<br />\r\n\r\n##### sync\r\n\r\n```py\r\nsudio.Pipeline.sync(self, barrier: threading.Barrier)\r\n```\r\nSynchronize current pipeline with others using a barrier.\r\n\r\n\r\n<br />\r\n\r\n##### aasync\r\n\r\n```py\r\nsudio.Pipeline.aasync(self)\r\n```\r\n\r\nDisable pipeline synchronization.\r\n\r\n<br />\r\n\r\n##### delay\r\n\r\n```py\r\nsudio.Pipeline.delay(self)\r\n```\r\n\r\nused to retrive pipeline execution delay in us.\r\n\r\n<br />\r\n\r\n##### set_timeout\r\n\r\n```py\r\nsudio.Pipeline.set_timeout(self, t: Union[float, int])\r\n```\r\nDetermines the blocking timeout of the pipeline after the I/O queues are full.\r\n\r\n<br />\r\n\r\n##### get_timeout\r\n\r\n```py\r\nsudio.Pipeline.get_timeout(self)\r\n```\r\n\r\nused to retrive the blocking timeout of the pipeline after the I/O queues are full.\r\n\r\n\r\n<br />\r\n\r\n##### put\r\n\r\n```py\r\nsudio.Pipeline.put(self, data)\r\n```\r\n\r\nInject new data into the pipeline object \r\n\r\n<br />\r\n\r\n\r\n##### get\r\n\r\n```py\r\nsudio.Pipeline.get(self, block=True, timeout=None):\r\n```\r\n\r\nRemove and return an item from the output queue.\r\n\r\nIf optional args 'block' is true and 'timeout' is None (the default), block if necessary until an item is available. If 'timeout' is a non-negative number, it blocks at most 'timeout' seconds and raises\r\nthe Empty exception if no item was available within that time.\r\nOtherwise ('block' is false), return an item if one is immediately available, else raise the Empty exception ('timeout' is ignored in that case).\r\n\r\n<br />\r\n\r\n#### Magic methods\r\n\r\n\r\n<br />\r\n\r\n##### call\r\n\r\n```py\r\nsudio.Pipeline.__call__(self, data)\r\n```\r\n\r\nThe __ call __ magic method used to Inject data into the current pipeline object \r\n\r\n\r\n<br />\r\n\r\n##### delitem\r\n\r\n```py\r\nsudio.Pipeline.__delitem__(self, key)\r\n```\r\n\r\nDelete self[key].\r\n\r\n<br />\r\n\r\n##### len\r\n\r\n```py\r\nsudio.Pipeline.__len__(self)\r\n```\r\n\r\nReturn len(self).\r\n\r\n<br />\r\n\r\n##### getitem\r\n\r\n```py\r\nsudio.Pipeline.__getitem__(self, key)\r\n```\r\n\r\nReturn self[key].\r\n\r\n<br />\r\n\r\n\r\n\r\nLICENCE\r\n-------\r\n\r\nOpen Source (OSI approved): Apache License 2.0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/MrZahaki/sudio",
    "keywords": "",
    "license": "Apache License 2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "sudio",
    "package_url": "https://pypi.org/project/sudio/",
    "platform": null,
    "project_url": "https://pypi.org/project/sudio/",
    "project_urls": {
      "Homepage": "https://github.com/MrZahaki/sudio"
    },
    "release_url": "https://pypi.org/project/sudio/1.0.9.3/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Audio Processing Platform",
    "version": "1.0.9.3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15354118,
  "releases": {
    "1.0.9.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4a3ff9e089850c05cc7f4a5eae1dae1363272a51932897579b18755833537581",
          "md5": "559d4750ac9f433e2037e751246c3f7e",
          "sha256": "8f80fc6613c54cac592722853ba256456f83609e7369ab3fc18847633a50990f"
        },
        "downloads": -1,
        "filename": "sudio-1.0.9.2.tar.gz",
        "has_sig": false,
        "md5_digest": "559d4750ac9f433e2037e751246c3f7e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 79343,
        "upload_time": "2022-10-03T20:16:29",
        "upload_time_iso_8601": "2022-10-03T20:16:29.504305Z",
        "url": "https://files.pythonhosted.org/packages/4a/3f/f9e089850c05cc7f4a5eae1dae1363272a51932897579b18755833537581/sudio-1.0.9.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.9.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c4abc4649eea3c1bbba6fd5a9ee7e159dd5c3ee8bfc96ba76cba2c6ee8d0f9d9",
          "md5": "91853f966fa3fa8aa1c000a83cfc4615",
          "sha256": "16727468ff9e3d755526aac21e20d6e3d4f0e2cb9a2562830d8a7241c220a5af"
        },
        "downloads": -1,
        "filename": "sudio-1.0.9.3.tar.gz",
        "has_sig": false,
        "md5_digest": "91853f966fa3fa8aa1c000a83cfc4615",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 80216,
        "upload_time": "2022-10-09T20:38:08",
        "upload_time_iso_8601": "2022-10-09T20:38:08.508252Z",
        "url": "https://files.pythonhosted.org/packages/c4/ab/c4649eea3c1bbba6fd5a9ee7e159dd5c3ee8bfc96ba76cba2c6ee8d0f9d9/sudio-1.0.9.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c4abc4649eea3c1bbba6fd5a9ee7e159dd5c3ee8bfc96ba76cba2c6ee8d0f9d9",
        "md5": "91853f966fa3fa8aa1c000a83cfc4615",
        "sha256": "16727468ff9e3d755526aac21e20d6e3d4f0e2cb9a2562830d8a7241c220a5af"
      },
      "downloads": -1,
      "filename": "sudio-1.0.9.3.tar.gz",
      "has_sig": false,
      "md5_digest": "91853f966fa3fa8aa1c000a83cfc4615",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 80216,
      "upload_time": "2022-10-09T20:38:08",
      "upload_time_iso_8601": "2022-10-09T20:38:08.508252Z",
      "url": "https://files.pythonhosted.org/packages/c4/ab/c4649eea3c1bbba6fd5a9ee7e159dd5c3ee8bfc96ba76cba2c6ee8d0f9d9/sudio-1.0.9.3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}