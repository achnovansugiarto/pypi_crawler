{
  "info": {
    "author": "Luis A. González Rivas",
    "author_email": "lagor55@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# `dataskema`\nData schema validation for python\n\nv1.6.7\n- Bug fixed in @dataskema.flask_url\n\nv1.6.6\n- Schemas for 'dict' types fields\n- 'max-size' and 'min-size' are valid for 'int' and 'float' types\n\nv1.6.5\n- Bug fixed \n\nv1.6.4\n- New feature for 'str_list', 'date', 'time' and 'datetime' types \n\nv1.6.3\n- Security validation compliant\n  - CWE-20: Improper Input Validation\n- Avoid injections:\n  - OWASP Top 10: A03:2021 – Injection \n- Validate types, formats, sizings, lines, etc. of incoming parameters\n- Customizable types for own aplications\n- Customizable validation messages\n- Multi-language support for labels and messages\n- Easy to use, intuitive and minimum code using decorators\n- Now supporting date, time and datetime types with theirs formats\n- New feature: 'format' to format numeric and string types\n- New feature: 'cast' to cast types in other type validating scheme\n- New features for 'list' type: 'iempty' to ignore empty items and 'iduplicated' to ignore duplicated items\n- New feature for 'str' types: 'join' to join an input list to a concatenated output string \n- New feature: 'optional()' method to overwrite and disable mandatory option\n\n## Content  index\n\n1. [How to use dataskema](##How to use `dataskema`)\n2. [Data types definition](##Data types definition)\n3. [Default data types](##Default data types)\n4. [Inline keyword override](##Inline keyword override)\n\n\n## How to use `dataskema`\n\n1) First, define your own data schema using `dataskema` default data types (`dataskema.data_types.py`) or using your own data types. For example (`mydatatypes.py`):\n\n\n    from dataskema.data_types import DataTypes as t\n\n    class MyDataTypes(t):\n\n        address = t.type(t.title, {\n            'label': 'Address',\n            'regexp': '^[a-zA-Z0-9\\\\.\\\\@\\\\+\\\\-\\\\_]+$',\n        })\n        phone_number = t.str({\n            'max-size: 20,\n            'regexp': '^[0-9\\\\-]+]+$',\n        })\n        ...\n\n2) Now, import your data schema and use it with `dataskema` validation decorators. Look that `t.name` is inherited from default data types of `dataskema.data_types.DataTypes` class. Default data types are methods that creates default types permitting add more properties, but you can use as it is. The `@dataskema.args` decorator validate method arguments. Look how use it.\n\n\nImport `dataskema` package and our data types python file: \n\n\n    import dataskeme\n    from mydatatypes import MyDataTypes as t\n\n\nPrint validated contact data: \n\n\n    @dataskeme.args(name=t.name(), address=t.address, phone_number=t.phone_number)\n    def print_contact_data(name: str, address: str, phone_numer: str):\n        print(f\"Name: {name}\"\n        print(f\"Address: {address}\"\n        print(f\"Phone number: {phone_number}\"\n\n\nPass contact data for validate and print: \n\n\n    def service_print_contact():\n        name = 'Lorenzo'\n        addresss = 'C/ Costa Rica, 32'\n        phone_number = '999-845-321'\n        try:\n            print_contact_data(name, address, phone_number)\n        except SchemaValidationResult as res:\n            print(res.get_message())\n\n\n3) In the above example, before printing contact data, it is validated with own data schema. If the data are correct, no error will be shown. But if we modify `mydatatypes.py` to force a validation error, then:  \n\n\n    phone_number = t.str({\n        'max-size: 20,\n        'regexp': '^[0-9]+$',\n    })\n    ...\n\n\nNow, we are not permitting phone numbers with minus symbols. The error will be: \n\n\n    'phone_number' has an invalid format\n\n\n4) We can specify label for this paramente to show a better message:  \n\n\n    phone_number = t.str({\n        'label': 'Phone number',\n        'max-size: 20,\n        'regexp': '^[0-9]+$',\n    })\n    ...\n\n\nThe error will be: \n\n\n    'Phone number' has an invalid format\n\n\n5) We can specify our own format error message too:  \n\n\n    phone_number = t.str({\n        'label': 'Phone number',\n        'max-size: 20,\n        'regexp': '^[0-9]+$',\n        'message': '{name} has an invalid phone number format' \n    })\n    ...\n\n\nThe error will be: \n\n\n    'Phone number' has an invalid phone number format\n    \n\n6) Other test: Empty `name` value and change `name` type as mandatory using inline type change. Look `t.mandatory()` method in the decorator:\n\n\n    @dataskeme.args(name=t.mandatory(t.name()), address=t.address, phone_number=t.phone_number)\n    def print_contact_data(name: str, address: str, phone_numer: str):\n        ...\n\n\nThe error will be: \n\n\n    'name' is mandatory\n    ...and 1 error more\n\n\n7) Want you see all errors? Change `dataskeme.MAX_VALIDATION_MESSAGES = 10` to see the 10 first validation messages o `dataskeme.MAX_VALIDATION_MESSAGES = 0` to see all\n\n\n    'name' is mandatory\n    'Phone number' has an invalid phone number format\n\n\n8) Now, 'name' is a field name it is not a known name. Then, use t.label() to assign a new label o modify your data scheme to assign a label to this type.   \n\n\n    @dataskeme.args(name=t.label(t.mandatory(t.name()), 'Contact name'), address=t.address, phone_number=t.phone_number)\n    def print_contact_data(name: str, address: str, phone_numer: str):\n        ...\n\n\nor create data type directly in your data schema. It's really better:\nIn `mydatatypes.py`:\n\n\n    contact_name = t.name({\n        'label': 'Contact name',\n        'required': True,\n    })\n    ...\n\n\nIn my test file:\n\n\n    @dataskeme.args(name=t.contact_name, address=t.address, phone_number=t.phone_number)\n    def print_contact_data(name: str, address: str, phone_numer: str):\n        ...\n\n\nThis will show the next error:\n\n\n    'Contact name' is mandatory\n    'Phone number' has an invalid phone number format\n\n\n9) \"Well, but I want to show errors in each formulary field. Is this possible?\" Yes, it is. Validation exception (`SchemaValidationResult`) has a method to return validation info by field: `get_result_of(field_name)`. This method returns this data structure by each field:\n\n    {\n        'valid': <boolean to indicate if this field was validated with positive result or not>\n        'message': <validation message only if valid=False>\n        'label': <label assigned to field only if valid=False>\n    }\n\n\nThe method `get_results()` returns all validation results in a dict whose keys are the field names. The method `get_message()` returns all validation messages. In own example, the returning would be:\n\n\n    get_results():\n    {\n        'name': {\n            'valid': False,\n            'message': 'It is mandatory',\n            'label': 'Contact name'\n        },\n        'address': {\n            'valid': True\n        },\n        'phone_number': {\n            'valid': False,\n            'message': 'It has an invalid phone number format',\n            'label': 'Phone number'\n        },\n    }\n\n    get_message():\n    \"'Contact name' is mandator\\n'Phone number' has an invalid phone number format\",\n\n\n10) `dataskema` supports Spanish and English messages. Use `dataskema.lang.DEFAULT = dataskema.lang.ES` to show Spanish language. You can specify your own format error messages and your own labels in multilanguage. Look this example: \n\n\n    from dataskema.lang import ES, EN\n\n\n    phone_number = t.str({\n        'label': {\n          ES: 'Teléfono',\n          EN: 'Phone number',\n        },\n        'max-size: 20,\n        'regexp': '^[0-9]+$',\n        'message': {\n          ES: '{name} es un número teléfono no válido',\n          EN: '{name} has an invalid phone number format', \n        })\n    ...\n\n\nYou can use any language using this definition way. ES and EN are strings 'es' and 'es' respectively. You can use another languages:\n\n\n    FR = 'fr'\n\n    phone_number = t.str({\n        'label': {\n          ES: 'Teléfono',\n          EN: 'Phone number',\n          FR: 'Téléphone',\n        },\n        'max-size: 20,\n        'regexp': '^[0-9]+$',\n        'message': {\n          ES: '{name} es un número teléfono no válido',\n          EN: '{name} has an invalid phone number format', \n          FR: '{name} c'est un numéro de téléphone invalide', \n        })\n    ...\n\n\n11) \"Fine, but solution that I search is for Flask endpoints and its incoming parameters\". No problem, `dataskema` is the solution. For example, look that Flask endpoint. Look that `user_id` parameter passed as `argument` for the next method.\n\n\n    @flask_app.route('/api/user/<user_id>', methods=['PUT'])\n    def update_user(user_id: str):\n        json_data = request.get_json()\n        ...\n\n\nThis example not validate `user_id` neither `json_data`. Now, we will use our decorators and our data schema (`mydatatypes.py`). Look as `update_user` method includes the json params that we need us. This params are defined by above decorator `flask_json`. If the incoming params not validate then a `SchemaValidationResult` will be raised. Look how `user_id` is validated with `arg` decorator. \n\n\n    @flask_app.route('/api/user/<user_id>', methods=['PUT'])\n    @dataskema.args(user_id=t.user_id)\n    @dataskema.flask_json(name=t.contact_name, address.t.address, phone_number=t.phone_number)\n    def update_user(user_id: str, name: str, address: str, phone_number: str):\n        ...\n\n\n14) \"But, What happes if my GET method not contains JSON data because the data is in the query string?\" Easy. Use `flask_query` decorator in the same way.\n\n\n    @flask_app.route('/api/user/<user_id>', methods=['GET'])\n    @dataskema.args(user_id=t.user_id)\n    @dataskema.flask_query(name=t.contact_name, address.t.address, phone_number=t.phone_number)\n    def update_user(user_id: str, name: str, address: str, phone_number: str):\n        ...\n\n\n15) \"And now, how catch the decorator exception to process validation result?\" Use your own decorator (for example, `@my_json_result`) to catch this result and response with JSON data as this example is shown:\n\n\n    @flask_app.route('/api/user/<user_id>', methods=['PUT'])\n    @my_json_result()\n    @dataskema.args(user_id=t.user_id)\n    @dataskema.flask_json(name=t.name, address.t.address, phone_number=t.phone_number)\n    def update_user(user_id: str, name: str, address: str, phone_number: str):\n        ...\n\nThe code of `@my_json_result` could be something as this:\n\n\n    def my_json_result():\n        def inner_function(function):\n            @functools.wraps(function)\n            def wrapper(*args, **kwargs):\n                try:\n                    return function(*args, **kwargs)\n                except SchemaValidationResult as ve:\n                    return {\n                      'result': 'ERR',\n                      'reason': ve.get_message(),\n                      'errors': ve.get_results()\n                    }\n            return wrapper\n        return inner_function\n\n\n15) \"All of this is bored for me. I hate decorators\". Well, if you want to use the code for validate parameters in the traditional way, look this examples:\n\n\n    @flask_app.route('/api/user/<user_id>', methods=['PUT'])\n    def update_user(user_id):\n        try:\n            args_validator = Args({'user_id': user_id})\n            args_validator.validate({'user_id': t.user_id})\n            json_validator = JSON() # --> load JSON data: name, address & phone_number \n            json_validator.validate({'name': t.name, 'address': t.address, 'phone_number': t.phone_number})\n            return {result: 'OK'}\n        raise SchemaValidatorResult as ex:\n            error_msg = ex.get_message()\n            errors = ex.get_result()\n            return {result: 'ERR', reason: error_msg, errors: errors}\n\n    \nIt's really worse, less elegant and too much bored code...\n            \n        \n## Data types definition\nYou can define your struct data types with some of that keywords. \n\n### All types\nThat keywords are for all types:\n\n#### `'type': <keyword>`\nType of data. Possible types are: `'int'`, `'float'`, `'str'`, `'bool'`, `'list'`, `'dict'`, `'date'`, `'time'`, `'datetime'`, `'any'`.\n\nIf the data value cannot cast with the defined type then a format error message will be raised. This default message could be overriden using the `message` keyword. By default, the type will be `str`. If `default` keyword is defined, the default value type will be the type of this default value especified.\n\n#### `'default': <any>`\nDefault value for the data when it is not passed.\n\n#### `'mandatory': <bool>`\nThe data must be mandatory. If `type=str` the data will be empty if only had blank characters.\n\n#### `'message': <str> or <dict>`\nOverride the default message for format errors. You can to use `{name}` to specify the data name. If you want to specify some languages, you can use a dict with the keys EN or ES for english or spanish languages respectively.    \n\n#### `'label': <str>`\nBy default, the data name is the incoming paramenter name. You can overwrite using this keyword for better understanding.\n\n#### `'cast': <schema>`\nCast to other type using the same definition schema of types\n\n\n### For `'type': 'str'`\nKeywords only for type specified as `'str'` are:\n\n#### `'white-list': [...]`\nlist of valid values for the data\n\n#### `'icase': <bool>`\nignore case for matching the `white-list` \n\n#### `'regexp': <str>`\nRegular expression to match de data value. The default format error message could be overriden using the `message` keyword.\n\n#### `'min-size': <int>`\nLimit the minimum number of characters for the data. Valid for 'str', 'int' and 'float' types\n\n#### `'max-size': <int>`\nLimit the maximum number of characters for the data. Valid for 'str', 'int' and 'float' types\n\n#### `'max-lines': <int>`\nLimit the maximum number of lines for the data. Valid for 'str' types\n\n#### `'to': <keywords>`\nTranformation string functions. Several functions can be applied separating them by commas.\nPossible values are:\n- `'upper'`: Convert string to uppercase.\n- `'lower'`: Convert string to lowercase.\n- `'no-trim'`: No trim the string. By default, all strings are trimmed by both sides. \n- `'trim'`: Force trim (by default)\n\n#### `'format': <str>`\nFormat output string using format python string method.\nIf input object is a date, time o datetime then this format must be a valid date, time o datetime format. \nIf input object is an int or float then this format must be a valid number format. \n\n#### `'join': <str>`\nIf input data es a list, join items as a string list with the 'join' separator between items.\n\n\n### Only for `'type': 'int' or 'float'`\nKeywords only for type specified as `'int' or 'float'` are:\n\n#### `'min-value': <int>`\nLimit the minimum value for the data.\n\n#### `'max-value': <int>`\nLimit the maximum value for the data.\n\n\n### For `'type': 'list'`\nKeywords only for type specified as `'list'` are:\n\n#### `'schema': <dict>`\nSchema of data for list items. This data schema must be validated for each item list. The schema format\nis the same of this schema and use the same keyword and constraints.\n\n#### `'iempty': <bool>`\nIgnore empty list item. Por defecto es `True`\n\n#### `'iduplicated': <bool>`\nIgnore duplicated list items. Por defecto es `True` \n\n\n### For `'type': 'date', 'time' or 'datetime'`\nKeywords only for types specified as `'date'`, `'time'` or `'datetime'` are:\n\n#### `'format': <str>`\nFormat to parse string date, time or datetime in an object correctly\n\n\n### For `'type': 'dict'`\nKeywords only for type specified as `'dict'` are:\n\n#### `'schema': <dict>`\nSchema of data for dict items. Collection of keys that matches with incoming keys of dict parameter. Each key schema define the schema of its value\n\n### For `'type': 'bool' or 'any'`\nThat types have no specific keywords:\n\n\n## Default data types \nThat are the default data types defined by `dataskema` by the class `DataTypes` in `data_types.py` file. It's very illustrative as an example because create default methods that define types permitting extends its properties with more keywords:\n\n            \n\n## Inline keyword override  \nThe class `DataTypes` define static methods to ease add keywords in a default type without modify the type. That methods are:\n- `label(type, label)`: include a label for the type\n- `default(type, default_value)`: include a default value for the type\n- `upper(type)`: force incoming value to be uppercase\n- `lower(type)`: force incoming value to be lowercase\n- `mandatory(type)`: the value must be mandatory\n- `type(type, newtype)`: One way to redefine inline a complex type. Useful for define our own data types using `DataTypes` class\n- `str(extended_properties)`: Define a `'type': 'str'` permitting extends more keywords.\n- `int(extended_properties)`: Define a `'type': 'int'` permitting extends more keywords.\n- `float(extended_properties)`: Define a `'type': 'float'` permitting extends more keywords.\n- `bool(extended_properties)`: Define a `'type': 'bool'` permitting extends more keywords.\n- `list(extended_properties)`: Define a `'type': 'list'` permitting extends more keywords.\n- `dict(extended_properties)`: Define a `'type': 'dict'` permitting extends more keywords.\n- `date(extended_properties)`: Define a `'type': 'date'` permitting extends more keywords.\n- `time(extended_properties)`: Define a `'type': 'time'` permitting extends more keywords.\n- `datetime(extended_properties)`: Define a `'type': 'datetime'` permitting extends more keywords.\n- `str_list(schema, extended_properties)`: Define a `'type': 'str'` as string item list comma-separated\n- `white_list(list, extended_properties)`: Define a `'type': 'str'` including a white-list and more keywords.\n- `positive(extended_properties)`: Define a `'type': 'int'` including its constraints for be a positive number.\n- `zero_positive(extended_properties)`: Define a `'type': 'int'` including its constraints for be a zero o positive number.\n- `negative(extended_properties)`: Define a `'type': 'int'` including its constraints for be a negative number.\n- `url(extended_properties)`: Define a `'type': 'str'` including its constraints for url format.\n- `email(extended_properties)`: Define a `'type': 'str'` including its constraints for email format.\n- `password(extended_properties)`: Define a `'type': 'str'` including its constraints for password \n- `decimal(extended_properties)`: Define a `'type': 'str'` including its constraints for a decimal format.\n- `hexadecimal(extended_properties)`: Define a `'type': 'str'` including its constraints for hexadecimal format.\n- `base64(extended_properties)`: Define a `'type': 'str'` including its constraints for base64 format.\n- `alfanumeric(extended_properties)`: Define a `'type': 'str'` including its constraints only for alfanumeric characters.\n- `short_id(extended_properties)`: Define a `'type': 'str'` with `'max-size': 20`.\n- `long_id(extended_properties)`: Define a `'type': 'str'` with `'max-size': 40`.\n- `name(extended_properties)`: Define a `'type': 'str'` with `'max-size': 100`.\n- `title(extended_properties)`: Define a `'type': 'str'` with `'max-size': 200`.\n- `summary(extended_properties)`: Define a `'type': 'str'` with `'max-size': 2000`.\n- `text(extended_properties)`: Define a `'type': 'str'` with `'max-size': 500000` and `'max-lines': 10000`.\n- `version(extended_properties)`: Define a `'type': 'str'` with a valid version format.\n- `search(extended_properties)`: Define a `'type': 'str'` for search strings.\n\n\nExamples:\n\nImporting `dataskema.data_types.DataTypes as t`:\n\n`t.name()` is not a mandatory type but `t.mandatory(t.name())`, yes\n\n`t.name()` name by default will be 'name' but `t.label(t.name(),'Contact')` will be named 'Contact' \n\n\nFor define own our types in a custom class:\n\n    from dataskema.data_types import DataTypes as t\n\n    class MyDataTypes(t):\n    \n        contact_name = t.mandatory(t.label(t.name, 'Contact'))\n        contact_email = t.label(t.email(), 'Contact e-mail')\n        address = t.label(t.title(), 'Address')\n        postal_code = t.numeric({\n            'label': 'Postal code'\n            'mandatory': true,\n            'min-size': 5,\n            'max-size': 5,\n        })\n\n        contact = t.dict({\n            'label': 'Contact info',\n            'schema': {\n                'contact_name': t.contact_name,\n                'contact_email': t.contact_email,\n                'address': t.address,\n                'postal_code': t.postal_code,\n            }\n        })\n        ...",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/lagor-github/dataskema",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dataskema",
    "package_url": "https://pypi.org/project/dataskema/",
    "platform": null,
    "project_url": "https://pypi.org/project/dataskema/",
    "project_urls": {
      "Homepage": "https://github.com/lagor-github/dataskema"
    },
    "release_url": "https://pypi.org/project/dataskema/1.6.7/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "Data schema to validate parameters easily, quickly and with minimal code",
    "version": "1.6.7",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 14136877,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "070724aea91137d23fc9901e5b8afa28de4c8e7562c4222e141f8371f37c76b1",
          "md5": "f0766c85ab51ba70a370fd452764ea19",
          "sha256": "f05020edbcf79c16a3d1c92a627afe073ddfae107fb18d60ac4788d38bb83062"
        },
        "downloads": -1,
        "filename": "dataskema-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f0766c85ab51ba70a370fd452764ea19",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 5209,
        "upload_time": "2022-04-04T17:26:16",
        "upload_time_iso_8601": "2022-04-04T17:26:16.727218Z",
        "url": "https://files.pythonhosted.org/packages/07/07/24aea91137d23fc9901e5b8afa28de4c8e7562c4222e141f8371f37c76b1/dataskema-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ce699559859a4866db31f1aea539581eb6aaa0abc38ccb234713c9fd045083d4",
          "md5": "f95618c69401b2f78d5535836aab6fc3",
          "sha256": "066f5e0915400ef50a931a77e7e015ee2b102b7aaff6da7193a6265e89fae3a9"
        },
        "downloads": -1,
        "filename": "dataskema-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f95618c69401b2f78d5535836aab6fc3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 5685,
        "upload_time": "2022-04-04T17:49:44",
        "upload_time_iso_8601": "2022-04-04T17:49:44.381822Z",
        "url": "https://files.pythonhosted.org/packages/ce/69/9559859a4866db31f1aea539581eb6aaa0abc38ccb234713c9fd045083d4/dataskema-0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "eafa842159f5c2c2ac8fc371f41b4fc7f702a0328f97e60974c2a40214357e8a",
          "md5": "a000eb5c2af557d725511da0d343f871",
          "sha256": "f18671abfaadab1b532744bf8692f66368adf62d6a668ab04bbc106bf1d26ea4"
        },
        "downloads": -1,
        "filename": "dataskema-0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "a000eb5c2af557d725511da0d343f871",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13641,
        "upload_time": "2022-04-17T19:20:52",
        "upload_time_iso_8601": "2022-04-17T19:20:52.023888Z",
        "url": "https://files.pythonhosted.org/packages/ea/fa/842159f5c2c2ac8fc371f41b4fc7f702a0328f97e60974c2a40214357e8a/dataskema-0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6f54f61eb0664fe07b07968a4eaaee97a450680d33ff8d9a203011aa1f4a7bb7",
          "md5": "092f951d9f7fb2e4bd91d9243443802c",
          "sha256": "a3fed2d34e63587660498f42510c53a79d91b0399984d093fa0b256aacb61318"
        },
        "downloads": -1,
        "filename": "dataskema-0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "092f951d9f7fb2e4bd91d9243443802c",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 13899,
        "upload_time": "2022-04-18T06:11:04",
        "upload_time_iso_8601": "2022-04-18T06:11:04.466547Z",
        "url": "https://files.pythonhosted.org/packages/6f/54/f61eb0664fe07b07968a4eaaee97a450680d33ff8d9a203011aa1f4a7bb7/dataskema-0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0ad8fb6df07fdf27bf1bfa8dd570e4be558d4dd2e4d041ec7fb3836f753bc339",
          "md5": "29785c381f05bb0121a315943a06742e",
          "sha256": "fc6a339f46b3d5a05fd896722a26955b6bc67f3c34a0584a54c47af846b674f2"
        },
        "downloads": -1,
        "filename": "dataskema-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "29785c381f05bb0121a315943a06742e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18268,
        "upload_time": "2022-04-18T11:27:55",
        "upload_time_iso_8601": "2022-04-18T11:27:55.408401Z",
        "url": "https://files.pythonhosted.org/packages/0a/d8/fb6df07fdf27bf1bfa8dd570e4be558d4dd2e4d041ec7fb3836f753bc339/dataskema-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "35e0e9bb118ef00b11831f86daa8b6b4b649a9235148c7345c870da6570d7ddb",
          "md5": "e8b2544f0edaa178e54fa5f7d3ea7fad",
          "sha256": "29b17aa4adf888f4a12defc3bbfea851fae8275c10d593597095b9a89f764dab"
        },
        "downloads": -1,
        "filename": "dataskema-1.1.tar.gz",
        "has_sig": false,
        "md5_digest": "e8b2544f0edaa178e54fa5f7d3ea7fad",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18313,
        "upload_time": "2022-04-20T10:04:01",
        "upload_time_iso_8601": "2022-04-20T10:04:01.694405Z",
        "url": "https://files.pythonhosted.org/packages/35/e0/e9bb118ef00b11831f86daa8b6b4b649a9235148c7345c870da6570d7ddb/dataskema-1.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "47dd19f5c984fc5e112284b8f051f921a8ca9618ddf66a8d85ca08991bb3eb7a",
          "md5": "fc3ca3ab1f0052428318d09f226e3cf5",
          "sha256": "9a4ff8133116f0f7f069cb80b42baac67f46a00a64c1e69eeb69850911d80403"
        },
        "downloads": -1,
        "filename": "dataskema-1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "fc3ca3ab1f0052428318d09f226e3cf5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18320,
        "upload_time": "2022-04-20T16:06:37",
        "upload_time_iso_8601": "2022-04-20T16:06:37.369146Z",
        "url": "https://files.pythonhosted.org/packages/47/dd/19f5c984fc5e112284b8f051f921a8ca9618ddf66a8d85ca08991bb3eb7a/dataskema-1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ae26056508247061a3451e76502f3ce5ec6cb89983bd5fa523482117ceee6b5a",
          "md5": "69db383136be4f9c73087aba4b8376c8",
          "sha256": "4e19d346e8c027e1461421bf920730daaffbf07cd8569d1a9d1f5192bb9ccf20"
        },
        "downloads": -1,
        "filename": "dataskema-1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "69db383136be4f9c73087aba4b8376c8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18565,
        "upload_time": "2022-04-21T09:10:54",
        "upload_time_iso_8601": "2022-04-21T09:10:54.268520Z",
        "url": "https://files.pythonhosted.org/packages/ae/26/056508247061a3451e76502f3ce5ec6cb89983bd5fa523482117ceee6b5a/dataskema-1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f3e708d1786b74cbccb201461aa0ec2e4b0dce18cb305be0e7185e03c8cb7c5e",
          "md5": "f113ad2ee4fb48b671569d84e7344c35",
          "sha256": "497be1aa8212a0a007fc6bb16697213687792457f64590c8af1d8b16a1416606"
        },
        "downloads": -1,
        "filename": "dataskema-1.3.1.tar.gz",
        "has_sig": false,
        "md5_digest": "f113ad2ee4fb48b671569d84e7344c35",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18564,
        "upload_time": "2022-04-21T11:07:29",
        "upload_time_iso_8601": "2022-04-21T11:07:29.284319Z",
        "url": "https://files.pythonhosted.org/packages/f3/e7/08d1786b74cbccb201461aa0ec2e4b0dce18cb305be0e7185e03c8cb7c5e/dataskema-1.3.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cf8030e862abcd071b10c55e96727ff49c628b88fea0ffd0d15fc9107a074d4a",
          "md5": "9bda76309731eeccab8e9e75e334ed5e",
          "sha256": "7586ec6e5eef1c8a4f699bef65a46e01ba2f5bd11f9b7d8f1684888199565fbf"
        },
        "downloads": -1,
        "filename": "dataskema-1.3.2.tar.gz",
        "has_sig": false,
        "md5_digest": "9bda76309731eeccab8e9e75e334ed5e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 18555,
        "upload_time": "2022-04-21T17:58:24",
        "upload_time_iso_8601": "2022-04-21T17:58:24.334369Z",
        "url": "https://files.pythonhosted.org/packages/cf/80/30e862abcd071b10c55e96727ff49c628b88fea0ffd0d15fc9107a074d4a/dataskema-1.3.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b0e45c58a5fa88a2cecd6026f6b715199b53f3dc8940adc26647ba9cd7a8cc18",
          "md5": "3316e7b31db444b33c6b29b4601b469a",
          "sha256": "95531d5adf353a9e484d617067fc89a3f87e210c4c7f2f5159dcf87820716532"
        },
        "downloads": -1,
        "filename": "dataskema-1.4.tar.gz",
        "has_sig": false,
        "md5_digest": "3316e7b31db444b33c6b29b4601b469a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 19665,
        "upload_time": "2022-04-23T12:41:35",
        "upload_time_iso_8601": "2022-04-23T12:41:35.768592Z",
        "url": "https://files.pythonhosted.org/packages/b0/e4/5c58a5fa88a2cecd6026f6b715199b53f3dc8940adc26647ba9cd7a8cc18/dataskema-1.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.4.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "420aa2461640a6ec13f5726db69a7e06b90be4661b8650d41b94ad0cce3951cf",
          "md5": "20e85d44f3aac19abfd3bc66003971f2",
          "sha256": "d95955f47e494f9d79bf674520915cc5b0de7f56cc10da34529278d4dda7743c"
        },
        "downloads": -1,
        "filename": "dataskema-1.4.1.tar.gz",
        "has_sig": false,
        "md5_digest": "20e85d44f3aac19abfd3bc66003971f2",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 19181,
        "upload_time": "2022-04-23T13:18:24",
        "upload_time_iso_8601": "2022-04-23T13:18:24.132377Z",
        "url": "https://files.pythonhosted.org/packages/42/0a/a2461640a6ec13f5726db69a7e06b90be4661b8650d41b94ad0cce3951cf/dataskema-1.4.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.5.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4a052324dc079d212e0a5bb6b05129f90c0a615793e8810366ea841ab0a70d46",
          "md5": "42b9898b4c3a400e53ba7fd052eb5b93",
          "sha256": "b8b412c2a0ddc1a8099e332a07de6da1a4d9947fa7e8d630cf6d6136aaa3c4ba"
        },
        "downloads": -1,
        "filename": "dataskema-1.5.0.tar.gz",
        "has_sig": false,
        "md5_digest": "42b9898b4c3a400e53ba7fd052eb5b93",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 19202,
        "upload_time": "2022-04-27T11:54:38",
        "upload_time_iso_8601": "2022-04-27T11:54:38.765839Z",
        "url": "https://files.pythonhosted.org/packages/4a/05/2324dc079d212e0a5bb6b05129f90c0a615793e8810366ea841ab0a70d46/dataskema-1.5.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4d24376ca0bb65cc11f0a3b49aeb9bbbc8d0e863a8b2ccc5254d8ae56fa66c56",
          "md5": "adeda7a47203a90471b5d61e867d9750",
          "sha256": "a262ae107c39a720e3ce9494b4246d4cbce9d657c6e38a2e543fab5afab4479a"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.0.tar.gz",
        "has_sig": false,
        "md5_digest": "adeda7a47203a90471b5d61e867d9750",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 22560,
        "upload_time": "2022-04-30T12:40:58",
        "upload_time_iso_8601": "2022-04-30T12:40:58.354721Z",
        "url": "https://files.pythonhosted.org/packages/4d/24/376ca0bb65cc11f0a3b49aeb9bbbc8d0e863a8b2ccc5254d8ae56fa66c56/dataskema-1.6.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "41bd3f4fb28d70ceb35d55cc6314ba68c2c3b8078e12026cbe23221101100a98",
          "md5": "7ced2baaa35407843f3fd9a9b1eb7dbe",
          "sha256": "3a271267d174dab43680b93db56b53742fcf65db4a633d409f55a53f0f0ac013"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.1.tar.gz",
        "has_sig": false,
        "md5_digest": "7ced2baaa35407843f3fd9a9b1eb7dbe",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 22923,
        "upload_time": "2022-05-01T10:38:03",
        "upload_time_iso_8601": "2022-05-01T10:38:03.463836Z",
        "url": "https://files.pythonhosted.org/packages/41/bd/3f4fb28d70ceb35d55cc6314ba68c2c3b8078e12026cbe23221101100a98/dataskema-1.6.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8ed31ec53da3fd9ef4dad2347a59edea692558aeb41381df908dfcd97dbe7aae",
          "md5": "8e4f5bb85e567d9e3ce27efe03066c3b",
          "sha256": "9da2ace7f9bf80b2fc0cdb3251c0f662073e3c3a25f5804b906b2eaedbb70969"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.2.tar.gz",
        "has_sig": false,
        "md5_digest": "8e4f5bb85e567d9e3ce27efe03066c3b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 22927,
        "upload_time": "2022-05-01T10:40:32",
        "upload_time_iso_8601": "2022-05-01T10:40:32.272110Z",
        "url": "https://files.pythonhosted.org/packages/8e/d3/1ec53da3fd9ef4dad2347a59edea692558aeb41381df908dfcd97dbe7aae/dataskema-1.6.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "649d78b8b7f9ef0b706223b0baa1c3b44c6cef78361e7838e2e38b11d50cf468",
          "md5": "0ed1e23d55beb0324894ff308f239565",
          "sha256": "cd8daf5e63461a2232891ef7e58af1d22e3cb8194204e327ccfed6ca9e7861b1"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0ed1e23d55beb0324894ff308f239565",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23008,
        "upload_time": "2022-05-01T11:08:06",
        "upload_time_iso_8601": "2022-05-01T11:08:06.366275Z",
        "url": "https://files.pythonhosted.org/packages/64/9d/78b8b7f9ef0b706223b0baa1c3b44c6cef78361e7838e2e38b11d50cf468/dataskema-1.6.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a045d7ff282f5a645dd000785c3cf25ef91ce8b9df4acc50d05481bd52717626",
          "md5": "cac9d90a3032cfe55a948402af9f188d",
          "sha256": "0e530be3d7e209fc4f55fb253c611c92eed5969de504c7d32876c33cfd3cbbfc"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.4.tar.gz",
        "has_sig": false,
        "md5_digest": "cac9d90a3032cfe55a948402af9f188d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23117,
        "upload_time": "2022-06-07T06:15:31",
        "upload_time_iso_8601": "2022-06-07T06:15:31.162649Z",
        "url": "https://files.pythonhosted.org/packages/a0/45/d7ff282f5a645dd000785c3cf25ef91ce8b9df4acc50d05481bd52717626/dataskema-1.6.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4a1412cf46aea3355bed1b0e57caed572f4fb5d8f0792ffce1053b0e88e94800",
          "md5": "c12a2de1ceaa4da5e4fc8f4978621494",
          "sha256": "0adac3d03f08e89f278a9ac3b6dd96da4e513f0526439fd0bdd69834518b802b"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.5.tar.gz",
        "has_sig": false,
        "md5_digest": "c12a2de1ceaa4da5e4fc8f4978621494",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23254,
        "upload_time": "2022-06-08T14:37:32",
        "upload_time_iso_8601": "2022-06-08T14:37:32.047555Z",
        "url": "https://files.pythonhosted.org/packages/4a/14/12cf46aea3355bed1b0e57caed572f4fb5d8f0792ffce1053b0e88e94800/dataskema-1.6.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "15bb65dddfa2479883df4c72aba78c1daac6f6b55534c0329d82979498529d5f",
          "md5": "85e94fd59f06736ede64b0b856784640",
          "sha256": "ffe10b601436ffe898cb89029bf661951b00b5807cd5c7c232abd22d052f31a6"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.6.tar.gz",
        "has_sig": false,
        "md5_digest": "85e94fd59f06736ede64b0b856784640",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23844,
        "upload_time": "2022-06-13T15:46:59",
        "upload_time_iso_8601": "2022-06-13T15:46:59.311859Z",
        "url": "https://files.pythonhosted.org/packages/15/bb/65dddfa2479883df4c72aba78c1daac6f6b55534c0329d82979498529d5f/dataskema-1.6.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a09cae8579c6635b5af53f52284f83cea5b7270ce20f7b7e8ec19089ec2f9bbe",
          "md5": "4ec790d9a9e43b557cef45c9cec6253d",
          "sha256": "dedc7eb874e22f3111ef21c4191f09176c10f166ea6c7148349d7bc4d7b21e6e"
        },
        "downloads": -1,
        "filename": "dataskema-1.6.7.tar.gz",
        "has_sig": false,
        "md5_digest": "4ec790d9a9e43b557cef45c9cec6253d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 23875,
        "upload_time": "2022-06-15T07:57:27",
        "upload_time_iso_8601": "2022-06-15T07:57:27.231579Z",
        "url": "https://files.pythonhosted.org/packages/a0/9c/ae8579c6635b5af53f52284f83cea5b7270ce20f7b7e8ec19089ec2f9bbe/dataskema-1.6.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "a09cae8579c6635b5af53f52284f83cea5b7270ce20f7b7e8ec19089ec2f9bbe",
        "md5": "4ec790d9a9e43b557cef45c9cec6253d",
        "sha256": "dedc7eb874e22f3111ef21c4191f09176c10f166ea6c7148349d7bc4d7b21e6e"
      },
      "downloads": -1,
      "filename": "dataskema-1.6.7.tar.gz",
      "has_sig": false,
      "md5_digest": "4ec790d9a9e43b557cef45c9cec6253d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 23875,
      "upload_time": "2022-06-15T07:57:27",
      "upload_time_iso_8601": "2022-06-15T07:57:27.231579Z",
      "url": "https://files.pythonhosted.org/packages/a0/9c/ae8579c6635b5af53f52284f83cea5b7270ce20f7b7e8ec19089ec2f9bbe/dataskema-1.6.7.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}