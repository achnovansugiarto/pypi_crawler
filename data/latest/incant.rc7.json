{
  "info": {
    "author": "",
    "author_email": "Tin Tvrtkovic <tinchester@gmail.com>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: Apache Software License"
    ],
    "description": "incantðŸª„: a little magic for your functions\n===========================================\n\n.. image:: https://img.shields.io/pypi/v/incant.svg\n        :target: https://pypi.python.org/pypi/incant\n\n.. image:: https://github.com/Tinche/incant/workflows/CI/badge.svg\n        :target: https://github.com/Tinche/incant/actions?workflow=CI\n\n.. image:: https://codecov.io/gh/Tinche/incant/branch/main/graph/badge.svg?token=9IE6FHZV2K\n       :target: https://codecov.io/gh/Tinche/incant\n\n.. image:: https://img.shields.io/pypi/pyversions/incant.svg\n        :target: https://github.com/Tinche/incant\n        :alt: Supported Python versions\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/psf/black\n\n----\n\n**incant** is a Python open source library for composing and invoking functions.\nGoing by the old, humorous adage that dependency injection is simply passing arguments to functions, `incant` is a toolkit that is well suited to that use case.\n\n`incant` includes support for:\n\n* matching dependencies by anything in ``inspect.Parameter``, including the parameter name, type annotation and default value\n* convenient APIs for matching by parameter name and type annotation\n* sync and async functions and dependencies\n* sync and async context manager dependencies\n* no global state\n* attaching arbitrary external dependencies to functions (``forced dependencies``), commonly used for side-effects\n\n`incant` has a very lean API surface, the core API being:\n\n* a single class, ``incant.Incanter``, for keeping state (dependency rules)\n* a method for registering dependencies: ``Incanter.register_hook()``, and a number of higher level, more user-friendly aliases\n* methods for invoking arbitrary functions while injecting dependencies: ``Incanter.invoke()`` and its async variant, ``Incanter.ainvoke()``\n* methods for invoking arbitrary functions while picking and forwarding any required arguments: ``Incanter.incant`` and its async variant, ``Incanter.aincant``\n\n`incant` is able to leverage runtime type annotations, but is also capable of functioning without them.\n`incant` is also fully type-annotated for use with Mypy and smart editors.\n\nThe tutorial section below contains a walkthough and some real-life use cases of `incant`.\n\nAn easy way to remember the difference between ``invoke`` and ``incant`` - ``incant`` is more magical, like a magical incantation.\n\nIf you're coming from a `pytest` background, `incant` dependency factories are roughly equivalent to `pytest` fixtures.\n\nInstallation\n------------\n\nTo install `incant`, simply:\n\n.. code-block:: bash\n\n    $ pip install incant\n\nTutorial\n--------\n\nThis section contains a long, narrative-style guide to `incant`.\nThere is a *Usage* section below with a more focused description of the library API.\n\nLet's demonstrate the use of `incant` with a number of hypothetical scenarios.\nWhile working for a tech company, you've been given an assignment: create a powerful, easy-to-use (yes, both) web framework for other developers in your company to use.\nYou don't have to do it from scratch though, so you choose (essentially at random) an existing framework: Quart (Quart is an async version of Flask).\nPretty much any other framework (sync or async) would have also worked; other implementations are left as an exercise to the reader.\nYou decide to call this framework `QuickAPI`.\n\nSimple Quart handlers are very easy to write, so your colleagues are quick to get started:\n\n.. code-block:: python\n\n    from quart import App\n\n    app = App(__name__)\n\n    @app.get(\"/\")\n    async def index():\n        return \"OK\"\n\nSimple Dependencies\n~~~~~~~~~~~~~~~~~~~\n\nAfter a while, your colleague says they require the IP address of the incoming request.\nYou explain the Quart API for this (``request.remote_addr``), but your colleague is adamant about following best practices (avoiding global variables) - they want it as an argument to their handler.\nThey also want it as an instance of Python's ``ipaddress.IPv4Address``. Their handler looks like this:\n\n.. code-block:: python\n\n    @app.get(\"/ip\")\n    async def ip_address_handler(source_ip: IPv4Address) -> str:\n        return f\"Your address is {source_ip}\"\n\nWell, looks like you've got your work cut out for you.\n\nAt the top of the file, you import and prepare an ``incant.Incanter`` instance.\n\n.. code-block:: python\n\n    from incant import Incanter\n\n    incanter = Incanter()\n\nYou decide to write a function to get the address from the request, and to register it with your Incanter to be matched by type.\n\n.. code-block:: python\n\n    from ipaddress import IPv4Address\n    from quart import request\n\n    @incanter.register_by_type\n    def get_ip_address() -> IPv4Address:\n        # In Quart (like in Flask), the request is accessed through a global proxy\n        return IPv4Address(request.remote_addr)\n\nThis means any function invoked through the `Incanter` will have any parameters annotated as ``IPv4Address`` satisfied by calling the ``get_ip_address`` dependency factory.\n\nYou contemplate how to get this information to the ``ip_address_handler``, and choose to write a simple decorator (yay Python!).\nYour colleague agrees, but (citing consistency) wants the decorator to be applied to all handlers going forward.\n\n(You could solve this more elegantly by subclassing the ``quart.Quart`` class but forgo this as this is an `incant` tutorial, not a Quart one.)\n\nYou rub your hands and mutter \"Let's roll\" to yourself.\n\n.. code-block:: python\n\n    from functools import wraps\n\n    def quickapi(handler):\n        @wraps(handler)\n        async def wrapper():\n            return await incanter.ainvoke(handler)\n\n        return wrapper\n\n``incanter.ainvoke`` (the async version of ``invoke``) does what you want - invokes the coroutine you give it while satisfying its arguments from its internal dependency factories.\n\nThen you just apply the decorators to both existing handlers.\n\n.. code-block:: python\n\n    @app.get(\"/ip\")\n    @quickapi\n    async def ip_address_handler(source_ip: IPv4Address) -> str:\n        return f\"Your address is {source_ip}\"\n\nPassing in Dependencies from the Outside\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome time later, another colleague approaches you asking for path variables to be provided to their handler.\nTheir handler needs to look like this:\n\n.. code-block:: python\n\n    @app.get(\"/even-or-odd/<int:integer>\")\n    @quickapi\n    async def even_or_odd_handler(integer: int) -> str:\n        return \"odd\" if integer % 2 != 0 else \"even\"\n\nQuart provides path parameters like this to handlers as ``kwargs``, so you modify the ``quickapi`` decorator a little:\n\n.. code-block:: python\n\n    def quickapi(handler):\n        @wraps(handler)\n        async def wrapper(**kwargs):\n            return await incanter.ainvoke(handler, **kwargs)\n\n        return wrapper\n\nThe decorator simply receives them and passes them along to the handler.\nThis works because `incant` will use arguments provided to `invoke` if it cannot satisfy a parameter using its internal dependency factories.\n\nAnother day of earning your keep!\n\nThe Magic of ``incant``\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSome time later, another colleague approaches you asking for a logger to be provided to their handler.\nThey want to use structured logging, and they want the logger to already be bound with the name of the handler.\nYou think the proposal is well-thought-out and want to use the logger yourself to log every request.\n\nHere's what they want their handler to look like:\n\n.. code-block:: python\n\n    @app.get(\"/log\")\n    @quickapi\n    async def logging_handler(log: BoundLogger) -> str:\n        log.info(\"Hello from the log handler\")\n        return \"Response after logging\"\n\nYou reach for the trusty `structlog` library and set it up.\n\n.. code-block:: python\n\n    from structlog.stdlib import BoundLogger, get_logger\n\n    logger = get_logger()  # Useful to have a module-scoped one first.\n\nYou change the ``quickapi`` decorator to create and use a logger with the current handler name:\n\n.. code-block:: python\n\n    def quickapi(handler):\n        log = logger.bind(handler=handler.__name__)\n\n        @wraps(handler)\n        async def wrapper(**kwargs):\n            log.info(\"Processing\")\n            return await incanter.ainvoke(handler, **kwargs)\n\n        return wrapper\n\nYou can't make the logger a dependency within the ``Incanter`` though, since it depends on handler-specific data.\n(You could have a separate incanter for each handler, but that's inefficient.)\n\nIf the incanter cannot find a dependency to fulfil a parameter, you need to provide it yourself - just like with the path parameters.\nSince the ``index`` and ``ip_address_handler`` don't require the logger, we can keep invoking them as before.\nHowever, the ``logging_handler`` handler requires it. Without changes, invoking the handler will let you know:\n\n.. code-block:: python\n\n    TypeError: invoke_logging_handler() missing 1 required positional argument: 'log'\n\nYou change the ``quickapi`` decorator to use ``Incanter.aincant`` (the async version of ``Incanter.incant``) and always pass in the logger instance.\n``incant`` is meant for cases like this, forwarding the parameters if they are needed and skipping them otherwise.\nSince ``incant`` doesn't itself call ``invoke``, you prepare it yourself beforehand.\n\n.. code-block:: python\n\n    def quickapi(handler):\n        log = logger.bind(handler=handler.__name__)\n\n        prepared = incanter.prepare(handler)\n\n        @wraps(handler)\n        async def wrapper(**kwargs):\n            log.info(\"Processing\")\n            return await incanter.aincant(prepared, log=log, **kwargs)\n\n        return wrapper\n\nSince you're passing in the logger using ``kwargs``, it will match (after trying name+type) any parameter named ``log``.\n\nNested Dependencies\n~~~~~~~~~~~~~~~~~~~\n\nA colleague is working on an authentication system for your product.\nThey have a function that takes a cookie (named ``session_token``) and produces an instance of your user model.\n\n.. code-block:: python\n\n    from attrs import define\n\n    @define\n    class User:\n        \"\"\"The user model.\"\"\"\n        username: str\n\n    async def current_user(session_token: str) -> User:\n        # Complex black magic goes here, immune to timing attacks.\n        return User(\"admin\")\n\nThey want to be able to use this user model in their handler.\n\n.. code-block:: python\n\n    @app.get(\"/user\")\n    @quickapi\n    async def user_handler(user: User, log) -> str:\n        log.info(\"Chilling here\", user=repr(user))\n        return \"After the user handler\"\n\nYou can use their ``current_user`` coroutine directly as a dependency factory:\n\n.. code-block:: python\n\n    incanter.register_by_type(current_user)\n\nbut this still leaves the issue of getting the cookie from somewhere.\nYou define a dependency factory for the session token cookie:\n\n.. code-block:: python\n\n    # We're using a lambda, so we pass in the `name` explicitly.\n    incanter.register_by_name(lambda: request.cookies['session_token'], name=\"session_token\")\n\nBecause of how ``request.cookies`` works on Quart, this handler will respond with ``400`` if the cookie is not present, or run the handler otherwise.\nBut only for the handlers that require the ``User`` dependency.\n\nPretty cool!\n\nAsync Context Managers\n~~~~~~~~~~~~~~~~~~~~~~\n\nA colleague of yours has heard of this newfangled concept of structured concurrency, and insists on trying it out.\nYou offer to let them use TaskGroups from the ``quattro`` library.\n\nTheir handler looks like this:\n\n.. code-block:: python\n\n    from quattro import TaskGroup\n\n    @app.get(\"/taskgroup\")\n    @quickapi\n    async def taskgroup_handler(tg: TaskGroup, log: BoundLogger) -> str:\n        async def inner():\n            log.info(\"Using structured concurrency, not leaking tasks\")\n\n        tg.create_task(inner())\n        return \"nice\"\n\nYou don't feel particularly challenged, as ``incant`` support async context managers out of the box and the only thing you need to do is:\n\n.. code-block:: python\n\n    incanter.register_by_type(TaskGroup, is_context_manager=\"async\")\n\nForced Dependencies\n~~~~~~~~~~~~~~~~~~~\n\nYesterday you've had an outage due to being featured by an influencer on a popular social media site!\nYou decide to start working on making your services more robust.\nYour plan is to apply a limit to how long your service will process each request.\nThe timeout should default to one second, or it can be provided from the calling service via a header.\n\nYou decide to again use the `quattro` library; it has a useful ``fail_after`` context manager that should do the trick.\n\nSince `incant` supports context managers as dependencies, your path is clear:\n\n.. code-block:: python\n\n    from quattro import fail_after\n\n    def apply_timeout(timeout: Header = Header(\"1.0\")) -> ContextManager[CancelScope]:\n        return fail_after(float(timeout))\n\nHowever, our usual approach would require refactoring all our handlers to require this dependency.\nInstead, we will make this a *forced dependency*, which means ``incant`` will run it for all handlers.\nSince no handler needs the return value of any forced dependency (since they are unaware of them), they are mostly used for side-effects.\nWe change the ``quickapi`` decorator thusly:\n\n.. code-block:: python\n\n    def quickapi(handler):\n        log = logger.bind(handler=handler.__name__)\n\n        prepared = incanter.prepare(handler, forced_deps=[(apply_timeout, \"sync\")])\n\n        @wraps(handler)\n        async def wrapper(**kwargs):\n            log.info(\"Processing\")\n            return await incanter.aincant(prepared, log=log, **kwargs)\n\n        return wrapper\n\n.. NOTE::\n    Since it's not possible to accurately autodetect whether a forced dependency is or isn't a context manager,\n    if it *is* a context manager you have to be explicit about it and supply a tuple like in the example.\n\nComplex Rules\n~~~~~~~~~~~~~\n\nAnother day, another feature request.\n\nA colleague wants to receive instances of `attrs` classes, deserialized from JSON in the request body.\nAn example:\n\n.. code-block:: python\n\n    @define\n    class SamplePayload:\n        field: int\n\n    @app.post(\"/payload\")\n    @quickapi\n    async def attrs_handler(payload: SamplePayload, log) -> str:\n        log.info(\"Received payload\", payload=repr(payload))\n        return \"After payload\"\n\nThey want this to work for *any* `attrs` class.\nYou know you can reach for the `cattrs` library to load an attrs class from JSON, but the dependency hook is a little more complex.\nBecause the dependency hook needs to work for *any* `attrs` class, you need to use ``incanter.register_hook_factory``, the most powerful but lowest level hook registration method.\n\n``incanter.register_hook_factory`` is for, like the name says, factories of dependency hooks.\nIt will produce a different dependency hook for each `attrs` class we encounter, which is what we need.\n\n.. code-block:: python\n\n    from attrs import has\n    from cattrs import structure\n    from werkzeug.exceptions import BadRequest\n\n    def make_attrs_payload_factory(attrs_cls: type):\n        async def attrs_payload_factory():\n            json = await request.get_json(force=True)\n            try:\n                return structure(json, attrs_cls)\n            except Exception as e:\n                raise BadRequest() from e\n\n        return attrs_payload_factory\n\n\n    incanter.register_hook_factory(\n        lambda p: has(p.annotation), lambda p: make_attrs_payload_factory(p.annotation)\n    )\n\nThis will also return a ``400`` status code if the payload cannot be properly loaded.\n\nBecause of how `incant` evaluates dependency rules (newest first), this hook factory needs to be registered before the ``current_user`` dependency factory.\nOtherwise, since our ``User`` model is also an `attrs` class, `incant` would try loading it from the request body instead of getting it from the ``current_user`` dependency factory.\n\nComplex Rules Pt 2: Electric Boogaloo\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA colleague wants to receive HTTP headers in their handler.\nThey also want these parameters to be able to have default values.\nYou decide to create a simple string subclass called ``Header`` and have your colleague annotate their parameters with it.\nTheir header looks like this:\n\n.. code-block:: python\n\n    from typing import NewType\n\n    Header = NewType(\"Header\", str)\n\n    @app.get(\"/header\")\n    @quickapi\n    async def a_header_handler(content_type: Header = Header(\"none\"), log=logger) -> str:\n        return f\"The header was: {content_type}\"\n\nSince each header parameter needs separate logic, you once again reach for hook factories.\nYou remember kebab-case is more commonly used than snake_case for headers, so you apply a small transformation - a parameter named ``content_type`` will get the value of the ``content-type`` header field.\n\nYou write the necessary instructions:\n\n.. code-block:: python\n\n    def make_header_factory(name: str, default):\n        if default is Parameter.empty:\n            return lambda: request.headers[name.replace(\"_\", \"-\")]\n        else:\n            return lambda: request.headers.get(name.replace(\"_\", \"-\"), default)\n\n    incanter.register_hook_factory(\n        lambda p: p.annotation is Header, lambda p: make_header_factory(p.name, p.default)\n    )\n\nThe complete source code of this mini-project can be found at https://github.com/Tinche/incant/blob/main/tests/quickapi.py.\n\nUsage\n-----\n\nThis section contains a quick usage guide to `incant`.\n\nState (in the form of dependency factories) is kept in an instance of ``incant.Incanter``.\n\n.. code-block:: python\n\n    from incant import Incanter\n\n    incanter = Incanter()\n\nThe ``incanter`` can now be used to call functions (``invoke``) and coroutines (``ainvoke``).\nSince there are no dependency factories registered yet, ``incanter.invoke(fn, a, b, c)`` is equivalent to ``fn(a, b, c)``.\n\n.. code-block:: python\n\n    def my_function(my_argument):\n        print(f\"Called with {my_argument}\")\n\n    incanter.invoke(my_function, 1)\n    'Called with 1'\n\nThe simplest way to register a dependency factory is by name:\n\n.. code-block:: python\n\n    @incanter.register_by_name\n    def my_argument():\n        return 2\n\nThe result of this dependency factory will be substituted when we invoke a function that has an argument named ``my_argument``.\n\n.. code-block:: python\n\n    incanter.invoke(my_function)\n    'Called with 2'\n\nAnother simple way to register a dependency factory is by its return type:\n\n.. code-block:: python\n\n    @incanter.register_by_type\n    def another_factory(my_argument) -> int:\n        return my_argument + 1\n\n    def another_function(takes_int: int):\n        print(f\"Called with {takes_int}\")\n\n    incanter.invoke(another_function)\n    'Called with 3'\n\nDependency factories may themselves have dependencies provided to them, as shown in the above example.\n``incant`` performs a depth-first pass of gathering nested dependencies.\n\n``incanter.invoke`` uses ``incanter.prepare`` internally.\n``prepare`` does the actual heavy lifting of creating and caching a wrapper with the dependencies processed and wired.\nIt's useful for getting the wrappers for caching or inspection - the wrappers support ordinary Python introspection using the standard library `inspect` module.\n\n``prepare`` also allows customizing the wrapper without adding hooks to the actual ``Incanter``.\n\n.. code-block:: python\n\n    from incant import Hook\n\n    @incanter.register_by_name\n    def my_argument():\n        return 2\n\n    def my_function(my_argument):\n        print(f\"Called with {my_argument}\")\n\n    >>> incanter.invoke(my_function)\n    2\n\n    >>> incanter.prepare(lambda: my_argument)()  # Equivalent.\n    2\n\n    >>> incanter.prepare(lambda: my_argument, [Hook.for_name(\"my_argument\", lambda: 1)])()\n    1\n\nThe hook argument is a sequence of hooks, which are a predicate function and dependency factory.\nAlso be aware that since in Python lambdas don't play well with caching, if you're preparing functions with hook overrides often you will want to store the actual overrides somewhere and reuse them.\n\n.. code-block:: python\n\n    # Inefficient:\n    >>> incanter.prepare(lambda: my_argument, [Hook.for_name(\"my_argument\", lambda: 1)])()\n\n    # Efficient:\n    >>> additional_hooks = [Hook.for_name(\"my_argument\", lambda: 1)] # Store this and reuse it.\n\n    >>> incanter.prepare(lambda: my_argument, additional_hooks)()  # Now uses the cache.\n\nIncanter instances also have a helper method, ``incanter.incant`` (and ``incanter.aincant``), that serves as a smart helper for calling functions.\n``incanter.incant`` filters out unnecessary arguments before calling the given function, and is a useful tool for building generic components.\n``incanter.incant`` also composes nicely with ``prepare``, where you can prepare a function in advance (to inject dependencies) and incant it with proper parameters.\n\n``register_by_name`` and ``register_by_type`` delegate to ``incanter.register_hook``.\n``register_hook`` takes a predicate function and a dependency factory.\nWhen determining if a depency factory can be used for a parameter, ``incant`` will try predicate functions (from newest to oldest) until one matches and use that dependency.\nPredicate functions take an ``inspect.Parameter`` and return a ``bool``, so they can match using anything present in ``Parameter``.\n\n``register_hook`` delegates to ``register_hook_factory``, which takes a predicate function and a factory of depedendency factories.\nThis outer factory takes an ``inspect.Parameter`` and returns a depedency factory, enabling generic depedendency factories.\n\nChangelog\n---------\n22.2.2 (2022-12-31)\n~~~~~~~~~~~~~~~~~~~\n* Fix an optimization for explicitly sync functions.\n* Fix an issue incanting unnecessary positional arguments.\n* Support ``__future__`` annotations (PEP 563) on Python 3.10+.\n\n22.2.1 (2022-12-27)\n~~~~~~~~~~~~~~~~~~~\n* Fix an issue when wrapping a sync function with an async one.\n\n22.2.0 (2022-12-26)\n~~~~~~~~~~~~~~~~~~~\n* Python 3.11 support.\n* Fix ``unbound local error`` while generating code.\n  (`#4 <https://github.com/Tinche/incant/issues/4>`_)\n* Avoid using local variables in generated code when possible.\n* When ``incant.prepare`` cannot do anything for a function, return the original function for efficiency.\n\n22.1.0 (2022-09-02)\n~~~~~~~~~~~~~~~~~~~\n* *Breaking change*: due to limitations in autodetecting context managers (both sync and async), context manager dependencies must be explicitly registered by passing ``is_context_manager=\"sync\"`` (or ``async``) to the registration functions.\n* Injection can be customized on a per-parameter basis by annotating a parameter with ``Annotated[type, incant.Override(...)]``.\n* Implement support for forced dependencies.\n* Sync context managers may now be dependencies.\n* ``incanter.a/incant()`` now handles unfulfilled parameters with defaults properly.\n* Switched to CalVer.\n\n0.3.0 (2022-02-03)\n~~~~~~~~~~~~~~~~~~\n* Properly set the return type annotation when preparing a function.\n* A hook override can now force a dependency to be promoted to a parameter (instead of being satisfied) by setting ``Hook.factory`` to ``None``.\n* Parameters with defaults are now supported for ``incanter.prepare`` and ``incanter.a/invoke``.\n* ``incanter.a/incant`` no longer uses ``invoke`` under the hood, to allow greater customization. Previous behavior can be replicated by ``incant(prepare(fn))``.\n* Optional arguments of dependencies can now be propagated to final function arguments. Keyword-only arguments of dependencies are still filtered out.\n\n0.2.0 (2022-01-13)\n~~~~~~~~~~~~~~~~~~\n* Introduce ``incanter.prepare``, and make ``incanter.a/invoke`` use it. ``prepare`` just generates the prepared injection wrapper for a function and returns it, without executing it.\n* Remove ``incanter.parameters``, since it's now equivalent to ``inspect.signature(incanter.prepare(fn)).parameters``.\n* Add the ability to pass hook overrides to ``incanter.prepare``, and introduce the ``incanter.Hook`` class to make it more usable.\n\n0.1.0 (2022-01-10)\n~~~~~~~~~~~~~~~~~~\n* Initial release.\n\n",
    "description_content_type": "text/x-rst",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "incant",
    "package_url": "https://pypi.org/project/incant/",
    "platform": null,
    "project_url": "https://pypi.org/project/incant/",
    "project_urls": {
      "Home": "https://github.com/Tinche/incant"
    },
    "release_url": "https://pypi.org/project/incant/22.2.2/",
    "requires_dist": [
      "typing_extensions; python_version == '3.8'",
      "black==22.12.0 ; extra == \"dev\"",
      "cattrs==22.2.0 ; extra == \"dev\"",
      "coverage==7.0.1 ; extra == \"dev\"",
      "flake8==6.0.0 ; extra == \"dev\"",
      "httpx==0.23.1 ; extra == \"dev\"",
      "isort==5.11.4 ; extra == \"dev\"",
      "mypy==0.991 ; extra == \"dev\"",
      "pytest-asyncio==0.20.3 ; extra == \"dev\"",
      "pytest==7.2.0 ; extra == \"dev\"",
      "quart==0.18.3 ; extra == \"dev\"",
      "quattro==0.3 ; extra == \"dev\"",
      "rich==12.6.0 ; extra == \"dev\"",
      "structlog==22.3.0 ; extra == \"dev\"",
      "uvicorn==0.20.0 ; extra == \"dev\""
    ],
    "requires_python": ">=3.8",
    "summary": "Magical function composition",
    "version": "22.2.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16263049,
  "releases": {
    "0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8ba3665e2047c778bfb9158820b0efd815a012bfd3dae45966ea64ef2aad85c1",
          "md5": "deca32359780f197e8352d312326fdcc",
          "sha256": "effe9dffad0ec992c035771b90ccf47f0036abd408d05a20eebfc6896a8a8487"
        },
        "downloads": -1,
        "filename": "incant-0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "deca32359780f197e8352d312326fdcc",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 15002,
        "upload_time": "2022-01-10T00:46:03",
        "upload_time_iso_8601": "2022-01-10T00:46:03.499026Z",
        "url": "https://files.pythonhosted.org/packages/8b/a3/665e2047c778bfb9158820b0efd815a012bfd3dae45966ea64ef2aad85c1/incant-0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9eb60f90d2fdce46a023de5215ddc4f8e150d164bc9f836977666cb8c4644a38",
          "md5": "921e009298b87bc0ccf68bc8b38a046b",
          "sha256": "e43d20d31205424d3c2956891c54a99af58e7db06e25d7a733cd9563f891e4ce"
        },
        "downloads": -1,
        "filename": "incant-0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "921e009298b87bc0ccf68bc8b38a046b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 25017,
        "upload_time": "2022-01-10T00:46:10",
        "upload_time_iso_8601": "2022-01-10T00:46:10.093764Z",
        "url": "https://files.pythonhosted.org/packages/9e/b6/0f90d2fdce46a023de5215ddc4f8e150d164bc9f836977666cb8c4644a38/incant-0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "41285803cfef744c73aaf198a84775046f534d1cae3d76ce185eb059d6b276cd",
          "md5": "028d65534a3ca4d96e53db3ea5c8d72d",
          "sha256": "03f2babbd366472e272d12db8bf12ab4ae8d5cb286918cab5685b627baa3bd47"
        },
        "downloads": -1,
        "filename": "incant-0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "028d65534a3ca4d96e53db3ea5c8d72d",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 15716,
        "upload_time": "2022-01-13T00:31:57",
        "upload_time_iso_8601": "2022-01-13T00:31:57.163620Z",
        "url": "https://files.pythonhosted.org/packages/41/28/5803cfef744c73aaf198a84775046f534d1cae3d76ce185eb059d6b276cd/incant-0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dbf75f9853f2f9809a8db86a5d1cb4b7f840bef3c556af9f9b5f888059e99824",
          "md5": "ba7c74e9811c5bb5f26078a6feb87ade",
          "sha256": "ad0bcb5c708b31a86f3c84a5d0f1ad863239d6668e1d9ffe5ebec19b4783b3ab"
        },
        "downloads": -1,
        "filename": "incant-0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "ba7c74e9811c5bb5f26078a6feb87ade",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 26501,
        "upload_time": "2022-01-13T00:32:02",
        "upload_time_iso_8601": "2022-01-13T00:32:02.182213Z",
        "url": "https://files.pythonhosted.org/packages/db/f7/5f9853f2f9809a8db86a5d1cb4b7f840bef3c556af9f9b5f888059e99824/incant-0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "87fd384469bbdaa258a3ba20b1b90a3727cc2d1ff1fe326b3ed471aa47e7f924",
          "md5": "40184a39269dd5d9a5db21296f3a506c",
          "sha256": "772821c458be6808c196486c4a66f4bbc9386a1db5a981d64c31a175c3cc7351"
        },
        "downloads": -1,
        "filename": "incant-0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "40184a39269dd5d9a5db21296f3a506c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 16415,
        "upload_time": "2022-02-03T03:09:50",
        "upload_time_iso_8601": "2022-02-03T03:09:50.863298Z",
        "url": "https://files.pythonhosted.org/packages/87/fd/384469bbdaa258a3ba20b1b90a3727cc2d1ff1fe326b3ed471aa47e7f924/incant-0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a339cd536f2699f057ae55db07e931520165a1c4101fabf2f54d20139be968d9",
          "md5": "01fd79559067ff2d2328e2ceee09f764",
          "sha256": "8552d0de74544133eb2038b9fbe42422bcfade6684d92ce68231d2cf9064bcf4"
        },
        "downloads": -1,
        "filename": "incant-0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "01fd79559067ff2d2328e2ceee09f764",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 27841,
        "upload_time": "2022-02-03T03:09:57",
        "upload_time_iso_8601": "2022-02-03T03:09:57.611870Z",
        "url": "https://files.pythonhosted.org/packages/a3/39/cd536f2699f057ae55db07e931520165a1c4101fabf2f54d20139be968d9/incant-0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "22.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "524363898905afdfadafbc39f5aa545e3f863428cde25ebfa8718eaa94239f7d",
          "md5": "38c8c957e1046b88e8cce4d2d94fd2dd",
          "sha256": "ebedc6cdb852cdd7b4eb254eba7143053da2b8909fd7eacb8272be33052510dc"
        },
        "downloads": -1,
        "filename": "incant-22.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "38c8c957e1046b88e8cce4d2d94fd2dd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 18734,
        "upload_time": "2022-09-02T10:01:20",
        "upload_time_iso_8601": "2022-09-02T10:01:20.697762Z",
        "url": "https://files.pythonhosted.org/packages/52/43/63898905afdfadafbc39f5aa545e3f863428cde25ebfa8718eaa94239f7d/incant-22.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b13fab288983456c2f6a6010820a699cee0ce376f393076bc6aeaf8a18c01e84",
          "md5": "c179a1eea49cca8ab8f3dcdd5e9f066f",
          "sha256": "6af53d626ca6d8102dab8abb2b54e853c7fcd2064e6746e4ce07a976af847402"
        },
        "downloads": -1,
        "filename": "incant-22.1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "c179a1eea49cca8ab8f3dcdd5e9f066f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 31859,
        "upload_time": "2022-09-02T10:01:22",
        "upload_time_iso_8601": "2022-09-02T10:01:22.436845Z",
        "url": "https://files.pythonhosted.org/packages/b1/3f/ab288983456c2f6a6010820a699cee0ce376f393076bc6aeaf8a18c01e84/incant-22.1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "22.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fa4c2681faadaf0a07a56deb12ab4919bb0f3a7cb3b7aac69f566d37fb1151c0",
          "md5": "819a2902e3e39098c30eab775a264e46",
          "sha256": "371f4685b1089be33280577914fcb461e7f7876f4cd58dfb1b7f342478b0c886"
        },
        "downloads": -1,
        "filename": "incant-22.2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "819a2902e3e39098c30eab775a264e46",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 16070,
        "upload_time": "2022-12-26T01:08:12",
        "upload_time_iso_8601": "2022-12-26T01:08:12.521066Z",
        "url": "https://files.pythonhosted.org/packages/fa/4c/2681faadaf0a07a56deb12ab4919bb0f3a7cb3b7aac69f566d37fb1151c0/incant-22.2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "77261e3c823ae07a911de7ca5bbd1c9e390ea3d302c5a033a9fa6fd414a92a0a",
          "md5": "2676a208a5d131e510b7995cc285e0cc",
          "sha256": "c19cc8710ed050e4633a048658cce314028a1654e8facd79f43674bfd8e1c198"
        },
        "downloads": -1,
        "filename": "incant-22.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "2676a208a5d131e510b7995cc285e0cc",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 22295,
        "upload_time": "2022-12-26T01:08:14",
        "upload_time_iso_8601": "2022-12-26T01:08:14.248180Z",
        "url": "https://files.pythonhosted.org/packages/77/26/1e3c823ae07a911de7ca5bbd1c9e390ea3d302c5a033a9fa6fd414a92a0a/incant-22.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "22.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "77b4ccfbdaeac6c99219e2ee0f27f44207b3d8775461d193ac31b0e84d86786d",
          "md5": "ceefa912a70385e0668161a62d54bf50",
          "sha256": "14b642eb04477b23f85ae02530a71338df067be3510ad9725b0fd9b764d5d10d"
        },
        "downloads": -1,
        "filename": "incant-22.2.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "ceefa912a70385e0668161a62d54bf50",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 16128,
        "upload_time": "2022-12-27T01:06:02",
        "upload_time_iso_8601": "2022-12-27T01:06:02.872633Z",
        "url": "https://files.pythonhosted.org/packages/77/b4/ccfbdaeac6c99219e2ee0f27f44207b3d8775461d193ac31b0e84d86786d/incant-22.2.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "10a2835158c2679d71ec21015e57df78910c153ff5fe2a119e37c4edccfc5b49",
          "md5": "890d373acd9f9dfec52e0230b76f3093",
          "sha256": "6f153e68b6d2b8155ccbf146a5b41d2f949afad50bd652a1eb89612b7a1beb9e"
        },
        "downloads": -1,
        "filename": "incant-22.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "890d373acd9f9dfec52e0230b76f3093",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 22316,
        "upload_time": "2022-12-27T01:06:04",
        "upload_time_iso_8601": "2022-12-27T01:06:04.429245Z",
        "url": "https://files.pythonhosted.org/packages/10/a2/835158c2679d71ec21015e57df78910c153ff5fe2a119e37c4edccfc5b49/incant-22.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "22.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "da1f327adf05d2ea34d52c40a1676d378fc026f92cfa2bfd87bdc7cd406ddb15",
          "md5": "bc9c28c06d3dbee77fc9b8e929aca237",
          "sha256": "2461d814bb8866418e46ac48d75afdd3425631010f5efbc1ece897895d9752db"
        },
        "downloads": -1,
        "filename": "incant-22.2.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "bc9c28c06d3dbee77fc9b8e929aca237",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 16353,
        "upload_time": "2022-12-30T23:30:53",
        "upload_time_iso_8601": "2022-12-30T23:30:53.752425Z",
        "url": "https://files.pythonhosted.org/packages/da/1f/327adf05d2ea34d52c40a1676d378fc026f92cfa2bfd87bdc7cd406ddb15/incant-22.2.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7c762f13ff09211142a3264a8a6cdc7fc6b4101e3faae74dfc76d69065797383",
          "md5": "4ccc037313d12c6887e341ed0e66fa6e",
          "sha256": "d28ee8819634176f2e8781886c6c8910336c96ef6c893cfe42a4ac1dc466bead"
        },
        "downloads": -1,
        "filename": "incant-22.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "4ccc037313d12c6887e341ed0e66fa6e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 22703,
        "upload_time": "2022-12-30T23:30:55",
        "upload_time_iso_8601": "2022-12-30T23:30:55.698854Z",
        "url": "https://files.pythonhosted.org/packages/7c/76/2f13ff09211142a3264a8a6cdc7fc6b4101e3faae74dfc76d69065797383/incant-22.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "da1f327adf05d2ea34d52c40a1676d378fc026f92cfa2bfd87bdc7cd406ddb15",
        "md5": "bc9c28c06d3dbee77fc9b8e929aca237",
        "sha256": "2461d814bb8866418e46ac48d75afdd3425631010f5efbc1ece897895d9752db"
      },
      "downloads": -1,
      "filename": "incant-22.2.2-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "bc9c28c06d3dbee77fc9b8e929aca237",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 16353,
      "upload_time": "2022-12-30T23:30:53",
      "upload_time_iso_8601": "2022-12-30T23:30:53.752425Z",
      "url": "https://files.pythonhosted.org/packages/da/1f/327adf05d2ea34d52c40a1676d378fc026f92cfa2bfd87bdc7cd406ddb15/incant-22.2.2-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "7c762f13ff09211142a3264a8a6cdc7fc6b4101e3faae74dfc76d69065797383",
        "md5": "4ccc037313d12c6887e341ed0e66fa6e",
        "sha256": "d28ee8819634176f2e8781886c6c8910336c96ef6c893cfe42a4ac1dc466bead"
      },
      "downloads": -1,
      "filename": "incant-22.2.2.tar.gz",
      "has_sig": false,
      "md5_digest": "4ccc037313d12c6887e341ed0e66fa6e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 22703,
      "upload_time": "2022-12-30T23:30:55",
      "upload_time_iso_8601": "2022-12-30T23:30:55.698854Z",
      "url": "https://files.pythonhosted.org/packages/7c/76/2f13ff09211142a3264a8a6cdc7fc6b4101e3faae74dfc76d69065797383/incant-22.2.2.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}