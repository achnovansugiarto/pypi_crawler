{
  "info": {
    "author": "Nachuan Xiao, Lei Wang, Bin Gao, Xin Liu, and Ya-xiang Yuan",
    "author_email": "stmopt@foxmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "# PySTOP\n\n## Introduction\n\nThe STOP toolbox is designed for **optimization problems on the Stiefel manifold**, which could be expressed as \n$$\n\\begin{aligned}\n\t\\min_{X \\in \\mathbb{R}^{n\\times p}} ~ &f(X)\\\\\n\t\\text{s. t.}~& X^\\top X = I_p,\n\\end{aligned}\n$$\nwhere $I_p$ refers to the $p$-th order identity matrix, $X$ is a matrix with $n$ rows and $p$ columns. The feasible set of this optimization problem \n$$\n\\mathcal{S}_{n,p} := \\left\\{X \\in \\mathbb{R}^{n\\times p}: X^\\top X = I_p \\right\\},\n$$\ncan be regarded as a Riemannian manifold in $\\mathbb{R}^{n\\times p}$, and we also call it as **Stiefel manifold**.  \n\nThis document describes the python version of SLPG solver. \n\n## Installation\n\nThe source code of those solvers can be found from [the website](https://gitee.com/stmopt/STOP) or directly from [this link](STOP_release.zip). Besides, it supports direct installation from `pip`:\n\n```shell\npip install --user pystop\n```\n\n\n\n## Example\n\n### Problem formulation\n\nIn this section, we consider the following nonlinear eigenvalue problem\n$$\n\\min_{X \\in \\mathcal{S}_{n, p}} ~ \\frac{1}{2}\\mathrm{tr}(X^\\top L X) + \\frac{\\alpha}{4} \\rho^\\top L^{\\dagger} \\rho,\n$$\nwhere $\\rho = \\mathrm{Diag}(XX^\\top)$, and $L^{\\dagger}$ denotes the pseudo-inverse of the positive definite matrix $L$, i.e. $L^{\\dagger}LL^{\\dagger} = L^{\\dagger}$, $LL^{\\dagger}L = L$.  Here we uses $\\mathrm{Diag}(M)$ to denote the vector that is composed of diagonal entries of the square matrix $M$, while $\\mathrm{diag}(v)$ refers to a diagonal matrix with $v$ to be its diagonal entries. Then the cost function and its **Euclidean gradient** can be expressed as\n$$\n\\begin{aligned}\n\t f(X) ={}& \\frac{1}{2}\\mathrm{tr}(X^\\top L X) + \\frac{\\alpha}{4} \\rho^\\top L^{\\dagger} \\rho,\\\\\n\t\\nabla f(X) ={}& LX + \\alpha \\mathrm{diag}(L^{\\dagger}\\rho)X.\n\\end{aligned}\n$$\n\n\nIn this example, we choose $L$ as a tri-diagonal matrix generated by `L = gallery('tridiag',n,-1,2,-1)`. Noting that $L$ is full-rank, then we can conclude that $L^{\\dagger} = L^{-1}$ in this case. We solve this simple optimization problem using solvers in STOP to illustrate the most basic usage of the STOP toolbox. For additional theory, readers are recommended to refer the papers in the about page. \n\n```python\n# Import packages \nimport numpy as np\nimport scipy as sp\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\n# Import manifolds and solvers\nfrom manifold import Stiefel\nfrom Solver.SLPG import SLPG_smooth\n\n\n# Set parameters\nn = 1000\np = 10\nalpha = 1\nM = Stiefel(n,p)\n\n# Defining objective function\nL = diags(np.array([-1, 2, -1]), np.array([1, 0, -1]), shape = (n,n)).tocsc()\ndef obj_fun(X):\n    LX = L@X\n    rho = np.sum(X * X, 1)\n    Lrho = spsolve(L, rho)\n    fval = 0.5*np.sum(X* LX) + (alpha /4) * np.sum(rho * Lrho)\n    grad = LX + alpha * Lrho[: ,np.newaxis] * X\n    return  fval, grad\n\n# Execute the solver\nX, out_dict = SLPG_smooth(obj_fun, M)\n\n```\n\n\n\nLet us review the code step by step. First, we specify the dimension of the problem and specify the Stiefel manifold. In `pySTOP` package, we need to specify the dimension of the Stiefel manifold before executing the solver. The Stiefel manifold should be specified as the *STOP manifold class*, for example,  \n\n```python\n# Set parameters\nn = 1000\np = 10\nalpha = 1\n# Specify the Stiefel manifold\nM = Stiefel(n,p)\n```\n\nHere `pystop.manifold.stiefel` is a build-in function to specify the Stiefel manifold and hence provides essential tools for the algorithm. \n\nThen we generate the data (matrix $L$) for the optimization problem by the following code,\n\n~~~python\nL = diags(np.array([-1, 2, -1]), np.array([1, 0, -1]), shape = (n,n)).tocsc()\n~~~\n\nHere we utilize `SciPy.sparse` to create a sparse representation of $L$ . Therefore, in each step  we could use the `scipy.sparse.linalg.spsolve` function to compute . \n\nThen we specify the cost function and its gradient in the following function\n\n~~~python\n# Defin objective function\ndef obj_fun(X):\n    LX = L@X\n    rho = np.sum(X * X, 1)\n    Lrho = spsolve(L, rho)\n    fval = 0.5*np.sum(X* LX) + (alpha /4) * np.sum(rho * Lrho)\n    grad = LX + alpha * Lrho[: ,np.newaxis] * X\n    return fval, grad\n~~~\n\nCurrently, in STOP toolbox, we require the function return the function value and its gradient simultaneously. Usually, computing the function value and gradient simultaneously is much faster than compute them separately, even when cache techniques are involved. To achieve a better performance, we strongly suggest to compute the function value and gradient in a single function. \n\nThen we call a solver to solve the nonlinear eigenvalue problem, \n\n```python\n# Execute the solver\nX, out_dict = SLPG_smooth(obj_fun, M)\n```\n\n\n\n\n\n## Solvers\n\nThe `PySTOP` solver classes provide the solvers for optimization. Once we specify the Stiefel manifold and define the objective function, the `PySTOP` solver can be executed by \n\n```\nX, out_dict = SLPG_smooth(obj_fun, M)\n```\n\nHere `X` is the final output of the problem, and `out_dict` is a dictionary that contains the log information. \n\n| Name                                     | Comment                                                      | Call               |\n| ---------------------------------------- | ------------------------------------------------------------ | ------------------ |\n| [SLPG_smooth](./manual/SLPG_smooth.html) | Penalty-free first-order method for smooth problems          | `SLPG_smooth(...)` |\n| [SLPG](./manual/SLPG.html)               | Penalty-free first-order method for nonsmooth problems       | `SLPG(...)`        |\n| [SLPG_l21](./manual/SLPG_l21.html)       | Penalty-free first-order method for $\\ell_{2,1}$-norm regularized problems | `SLPG_l21(...)`    |\n\n\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://stmopt.gitee.io/",
    "keywords": "optimization,manifold optimization,Stiefel manifold",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pystmopt",
    "package_url": "https://pypi.org/project/pystmopt/",
    "platform": "",
    "project_url": "https://pypi.org/project/pystmopt/",
    "project_urls": {
      "Homepage": "https://stmopt.gitee.io/"
    },
    "release_url": "https://pypi.org/project/pystmopt/0.1.0/",
    "requires_dist": [
      "numpy (>=1.16)",
      "scipy"
    ],
    "requires_python": ">=3.6",
    "summary": "A Toolbox for Stiefel Manifold Optimization",
    "version": "0.1.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12082120,
  "releases": {
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "354a4349c9f64491be154f4e11b8b1487e5cb34953b80896d02a1ce4a254f4e1",
          "md5": "0f46ba25532e5b04cf1dc982fee549b9",
          "sha256": "bf26bed8a7ecc3bcc3a6ecba08274eec6def9235a85fa7818935b9d751a15f2f"
        },
        "downloads": -1,
        "filename": "pystmopt-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "0f46ba25532e5b04cf1dc982fee549b9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 22763,
        "upload_time": "2021-11-21T10:20:10",
        "upload_time_iso_8601": "2021-11-21T10:20:10.623084Z",
        "url": "https://files.pythonhosted.org/packages/35/4a/4349c9f64491be154f4e11b8b1487e5cb34953b80896d02a1ce4a254f4e1/pystmopt-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "37562ddf0101aeadb27373ac367261c6d14d9d5cf14c03e8dff2f5da65ec9366",
          "md5": "8de8c02256990e2603477cc72982526f",
          "sha256": "e1f046f98a039f79fbd92bdc8898fae4ee358a0e080b34e9ea5d01c672cbface"
        },
        "downloads": -1,
        "filename": "pystmopt-0.1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "8de8c02256990e2603477cc72982526f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 22762,
        "upload_time": "2021-11-21T10:21:27",
        "upload_time_iso_8601": "2021-11-21T10:21:27.908839Z",
        "url": "https://files.pythonhosted.org/packages/37/56/2ddf0101aeadb27373ac367261c6d14d9d5cf14c03e8dff2f5da65ec9366/pystmopt-0.1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "37562ddf0101aeadb27373ac367261c6d14d9d5cf14c03e8dff2f5da65ec9366",
        "md5": "8de8c02256990e2603477cc72982526f",
        "sha256": "e1f046f98a039f79fbd92bdc8898fae4ee358a0e080b34e9ea5d01c672cbface"
      },
      "downloads": -1,
      "filename": "pystmopt-0.1.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "8de8c02256990e2603477cc72982526f",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 22762,
      "upload_time": "2021-11-21T10:21:27",
      "upload_time_iso_8601": "2021-11-21T10:21:27.908839Z",
      "url": "https://files.pythonhosted.org/packages/37/56/2ddf0101aeadb27373ac367261c6d14d9d5cf14c03e8dff2f5da65ec9366/pystmopt-0.1.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}