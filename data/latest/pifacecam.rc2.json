{
  "info": {
    "author": "Kwong Cheong, Yee",
    "author_email": "yee.kwong.cheong@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "License :: Freeware",
      "Natural Language :: English",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: Python :: 3.7"
    ],
    "description": "\n## PiFaceCam\n### Facial Recognition for Raspberry Pi\n#### Overview\nPiFaceCam is a facial recognition API for Raspberry Pi4 (Tested on Pi4 Model B-4GB. Pi4 2GB should be able to run as the RAM usage was estimated to peak around 860MB). \n\n\n**Main Features:**\n1. Run efficiently on Raspberry Pi4.\n2. Ease of use. Cameras management, face ids creation, facial-recognition and video creation/streaming are all handled automatically by pifacecam.\n3. Flexible to implement. Important facial-recognition information can be retrieve via a callback-function for any post recognition actions.\n4. Powerful. On top of basic facial-recognition (faces are identified against pre-stored facial ids.), pifacecam can run in \"verification server\" mode where a client can upload photos for verification against the person infront of camera.\n5. Stereo cameras setup option for defense against attack of placing a photo infront of camera.\n6. Able to recognised faces that are partially covered by face-masks.\n\n\n**PiFaceCam's LFW benchmark:**\n[Category: Unrestricted, Labeled Outside Data](http://vis-www.cs.umass.edu/lfw/results.html#UnrestrictedLb)\n\n|Mode|Accuracy(%)|\n|:--|:--:|\n|High Precision|99.50 +/-0.38|\n|Standard|99.13 +/-0.56|\n\n*[Human performance](http://vis-www.cs.umass.edu/lfw/results.html#Human) = 97.53 %.<br/>\n\n\n**Prerequisites (Software):**\n1. Raspbian Buster OS with desktop (Tested on kernel version: 5.10.17).\n2. Python 3.5 (and above)\n3. Numpy\n4. Tensorflow 1.15\n5. OpenCV for python\n6. Scikit-learn\n7. Pycryptodomex\n\n\n**Installation:**\n1. Python 3.5 (and above): Raspberry Pi OS should have Python3.7 preinstalled.\n2. Numpy: Raspberry Pi OS should have Numpy preinstalled.\n3. Tensorflow 1.15: Follow Katsuya Hyodo's procedures at <https://github.com/PINTO0309/Tensorflow-bin>(Choose option \"tensorflow-1.15.0-cp37-cp37m-linux_armv7l.whl\")\n4. OpenCV: Follow Emmet's procedures at <https://pimylifeup.com/raspberry-pi-opencv/> (Note: If you are using Pi4 4GB, you can skip the \"increase the swap space\" portion.)\n5. Scikit-learn: Run `sudo apt-get install python3-sklearn`\n6. Pycryptodomex: Run `sudo pip3 install pycryptodomex`\n7. PiFaceCam: Run `sudo pip3 install pifacecam`\n\n\n**Hardware requirement / setup:**\n1. Raspberry Pi4 (Tested on Pi4 Model B-4GB. Pi4 2GB should be able to run as the RAM usage was estimated to peak around 860MB). \n2. Picamera or USB camera.(Note: For stereo camera setup, you will need 1 Picamera + 1 USB camera. PiFaceCam does not support 2 USB cameras)\n3. A LED connected to GPIO19 (pin number can be changed later) via a resistor as system status indicator.The LED will blinks during system loading and ON continuously when system is ready. LED blinks indefinitely signify error has occurred.\n4. GPIO26 (pin number can be changed later) connected to ground via a resistor. It will trigger program exit when connect to high.\n5. As facial-recognition is computationally heavy, proper heat management is required. Standard cooling fan with heat sink on CPU was tested to be sufficient.\n\n\n**Quick run:**\n- In terminal, run the following lines.<br/>\n```\n$ sudo python3\n>>>from pifacecam import pifacecam\n>>>pifacecam.run()\n```\nYou should see something like the following print out.<br/>\n```\n1) Checking for attached Picamera.\n2) Picamera found.\n3) Checking for attached USB camera.\n4) USB camera found at index[1].\n```\n(Note: In some version of OpenCV, you may see bunch of warning messages, but so far we haven't encounter any problem during operation despite of these warning messages.)<br/>\nThe status LED will blinks during system loading and turn ON continuously when system is ready.<br/> Once system is ready, open a browser and goto URL `http://[ipaddress of RPI]:9090/video` you should able to view the camera feeds with some facial recognition information.\n<br/><br/>\n\n**The 'run()' function:**\n\nTo use PiFaceCam, you call the run() function. This run() function is a blocking function. It will only return when the run process terminates. This can only happen the shutdown pin is triggered or when an exception has occurred. It will then returns an integer that indicates the reason for the return. More details can be found in the log file or the output to the terminal.\n<br/>\n\n|Returned integer|Description|\n|:--:|:--|\n|1|Shutdown pin triggered.|\n|2|Error encountered while reading USB camera.|\n|3|USB camera is required but none detected.|\n|4|Error encountered while reading Picamera.|\n|5|Picamera is required but none detected.|\n|6|Error encountered while processing embedding.|\n|7|Error encountered in callback function.|\n|8|Error encountered while setting up video streaming server.|\n|9|Error encountered while setting up status/shutdown gpios.|\n|10|Error encountered while setting up verification server.|\n\n\n**Parameters:**\n\nThe run() function can receive many parameters. Description of each parameter are listed below.\n<br/>\n\n|Parameter|Type|Default Value|Description|\n|:--:|:--|:--|:--|\n|callback_function|Function|None|[1]Callback function to retrieve facial recognition data and perform post recognition activities.| \n|faceids_folder_pathname|String|None|[2]Path to where images of each id are stored.| \n|device_id|String|\"CAM001\"|Name of device. Will be displayed at the bottom left of video screen.Maximum length allowed is 10 characters.| \n|cam_setup|String|\"MONO_PICAM\"|Defining the camera setup to use. Available options are  \"MONO_PICAM\"=Single Picamera; \"MONO_USB\"=Single USB camera; \"STEREO_USB+PICAM\"=1 USB + 1 Pi cameras; \"NOCAM\"=No camera.|\n|stereo_left_cam_type|String|\"USB\"|Left camera type for stereo setup. Available options are  \"PICAM\" and \"USB\".|\n|stereo_right_cam_type|String|\"PICAM\"|Right camera type for stereo setup. Available options are  \"PICAM\" and \"USB\".|\n|detect_conf_percent|Int/Float|95.0|Minimum confident percentage required to identify a person.|\n|status_pin_num|Int|19|GPIO pin number to use as output for status LED. Value has to be between 2 and 27 (or -1 to disable) and different from shutdown_pin_num.|\n|shutdown_pin_num|Int|26|GPIO pin number to use for trigger program exit. Value has to be between 2 and 27 (or -1 to disable) and different from status_pin_num.|\n|full_face_only|Boolean|False|[3]When set to true, will force pifacecam to use whole face for recognition.|\n|high_precision_mode|Boolean|False|When set to true, will use a more accurate model for recogniton.|\n|max_num_for_hp_mode|Int|4|The maximum number of faces to detect each time in high precision mode. Setting a lower number will reduce lagging when there are too many faces to process. Setting a value N will mean only the N most prominent faces will be recognised. This value has to be between 1 and 4. Note: Max face detected is 1 in stereo camera setup.|\n|max_num_for_std_mode|Int|6|The maximum number of faces to detect each time in standard mode. This value has to be between 1 and 6. Note: Max face detected is 1 in stereo camera setup.|\n|show_bbox|Boolean|True|Whether to show bounding boxes around detected faces during video streaming.|\n|show_faceid|Boolean|True|Display the person's id below each identified face during video streaming.|\n|show_camid|Boolean|True|Display the device's id during video streaming.|\n|show_fps|Boolean|True|Whether to display the frames per second during video streaming.|\n|show_measurements|Boolean|True|For stereo cameras setting only. Display the delta face angle, delta bbox dimensions between left and right cameras during video streaming.|\n|show_positioning_guides|Boolean|False|Display the window borders and min/max detectable face size during video streaming.|\n|show_conf_percentage|Boolean|True|Display the recognition confidence percentage above each identified face during video streaming.|\n|show_precision_mode|Boolean|True|Display the word \"HP\" beside the device id if high precision mode is ON or \"STD\" if OFF.|\n|stereo_max_delta_bbox_w_percent|Int/Float|50|[4]For stereo cameras setting only. Max delta percentage between left and right camera bbox width. Value has to be between 0 and 100.|\n|stereo_max_delta_bbox_h_percent|Int/Float|50|[4]For stereo cameras setting only. Max delta percentage between left and right camera bbox height. Value has to be between 0 and 100.|\n|stereo_min_delta_face_angle|Int/Float|20|[5]For stereo cameras setting only. Min delta percentage between left and right face angle. Value has to be between 0 and 100, and smaller than stereo_max_delta_face_angle.|\n|stereo_max_delta_face_angle|Int/Float|60|[5]For stereo cameras setting only. Max delta percentage between left and right face angle. Value has to be between 0 and 100, and larger than stereo_min_delta_face_angle.|\n|in_verification_server_mode|Boolean|False|[6]Run as facial verification server.|\n|verification_server_port_no|Int|9990|[6]Port number of verification server.|\n|verification_server_token|String|None|[6]If set, will use to validate client's request.|\n|usb_cam_zoom_ratio|Int/Float|1.0|Zoom ratio of image from USB camera.|\n|picam_cam_zoom_ratio|Int/Float|1.0|Zoom ratio of image from Picamera.|\n|usb_cam_rotation|Int/Float|0|Rotation degree of USB camera. Value can be either 0 or 180|\n|picam_cam_rotation|Int/Float|0|Rotation degree of Picamera. Value can be either 0 or 180|\n<br/>\n\n**Details:**\n\n**[1] callback_function:** This function will receive a dictionary containing facial recognition information \"data_dict\". This function will be called once every frame. Ideally, any processing activities in this function should be able to complete before the next frame arrives or else the next frame will be ignored. Listed below are the available dictionary keys. <br/>\n\n|Key|Description|\n|:--:|:--|\n|\"image\"|BGR image in uint8 numpy array format (HeightxWidthxDepth).|\n|\"face_id_list\"|List of face ids. For faces that not meeting the \"detect_conf_percent\" will be identified as \"UNREGISTERED\".|\n|\"face_confidence_percentage_list\"|List of confidence percentage for all detected faces.|\n|\"face_is_dimensional_check_passed_list\"|List of booleans indicating if the face passed dimensional check.|\n|\"face_is_masked_list\"|List of booleans indicating if mouth is covered (face-mask for example).|\n|\"face_bbox_minXminYmaxXmaxY_list\"|List of bounding box \"left, top, right, bottom\" coordinates for each detected face.|\n\nBelow is an example of callback function.\n```\ndef example_callback_function(data_dict):\n    returned_image_np  = data_dict[\"image\"]\n    returned_faceID_list = data_dict[\"face_id_list\"]\n    returned_face_confidence_percentage_list= data_dict[\"face_confidence_percentage_list\"]\n    returned_face_is_dimensional_check_passed_list = data_dict[\"face_is_dimensional_check_passed_list\"]\n    returned_face_is_masked_list = data_dict[\"face_is_masked_list\"]\n    returned_face_abs_minXminYmaxXmaxY_list = data_dict[\"face_bbox_minXminYmaxXmaxY_list\"]\n\n    no_of_faces_passed_dimensional_check = 0\n    for this_face_is_dimensional_check_passed in returned_face_is_dimensional_check_passed_list:\n        if this_face_is_dimensional_check_passed:\n            no_of_faces_passed_dimensional_check += 1\n\n    print(\"Returned image shape :\", returned_image_np.shape)\n    print(\"No of face detected :\", len(returned_faceID_list))\n    print(\"No of faces passed dimensional check :\", no_of_faces_passed_dimensional_check)\n\n    for face_idx in range(len(returned_faceID_list)):\n        print(\"This face id :\", returned_faceID_list[face_idx])\n        print(\"This face confidence percentage :\", returned_face_confidence_percentage_list[face_idx])\n        print(\"This face's mouth is covered :\", returned_face_is_masked_list[face_idx])\n        print(\"This face's bbox minXminYmaxXmaxY :\", returned_face_abs_minXminYmaxXmaxY_list[face_idx])\n\n    # Perform post recognition task here....\n\n```\n**[2] faceids_folder_pathname:** This is the path to the folder where you store images for each person. Pifacecam will scan this folder for any new images and generate the face ids for facial recognition. In the example below, faceids_folder_pathname will be path to \"imagefolder\" and pifacecam will create face ids for Adam, Lisa and James.<br/>\nThis process may takes several minutes depending on how many ids and images are available. This process will only run once for each id when there is any change to the id folder.<br/>\n```\nimagefolder\n|-- Adam\n|   |-- image01.jpg\n|   |-- image02.jpg\n|   |-- image03.jpg\n|\n|-- Lisa\n|   |-- image01.jpg\n|   |-- image02.jpg\n|\n|-- James\n    |-- image01.jpg\n```\n**[3] full_face_only:** By default, this parameter is set to false, meaning PiFaceCam will automatically use the whole face for recognition if no facemask is detected. If facemask is detected, it will only use the eyes area for recognition. In situation where accuracy is critical and you do not want recognition to be based only on eyes area, you can force PiFaceCam to use the whole face for recognition all the time by setting parameter full_face_only to true.<br/><br/>\n**[4] stereo_max_delta_bbox_w_percent/ stereo_max_delta_bbox_h_percent:** In stereo cameras setting the size of face will varies as the person move towards the left or right camera. You can limit the acceptable difference for facial recognition.<br/><br/>\n**[5] stereo_min_delta_face_angle/ stereo_min_delta_face_angle:** \n\n![Stereo cameras layout](https://raw.githubusercontent.com/tensorfactory/PiFaceCam/master/images/stereo_cameras_layout.JPG)\n\nTo defense against attack using photo, you can use stereo cameras setup. It works by detecting the face angles from the left and right camera, -alpha & beta. The difference of these angles (beta -(-alpha) = beta + alpha) should be about the same as the angle between the left and right camera.\nFor this example, the left and right cameras were placed 40deg apart, beta - (-alpha) will be close to 40deg. However, if a photo (instead of a 3D face) was placed in front of both cameras, both cameras will measure the same face angle and beta - (-alpha) will be close to 0deg. You can set a minimum and maximum acceptable face angle (beta + alpha). Both values should be between 0deg and 100deg.<br/><br/>\n**[6] in_verification_server_mode/ verification_server_port_no/ verification_server_token:** In verification mode, you need to provide the port number for the server and if a verification token is also provides, it will be used by the client during request for validation.\nOnce setup, the raspberry pi will act as a verification server. Any client can send to it a reference image for verification. The verification server will return if the person currently in front of the camera matches the person in the reference image. <br/><br/>\n***Information to server:***<br/>\nTo request for verification, the client needs to send the reference image, the token, and a boolean indicating if a returned image is required, in JSON format to server.\n\n|Element|Key|Value|\n|:--|:--:|:--:|\n|Token|\"token\"|String|\n|Image|\"image\"|Reference image (base64 string)|\n|If need to return image|\"need_return_image\"|Boolean|\n\nThe image bytes have to be converted to base64 string (see below example). The length of this JSON bytes needs to be included at the beginning of the packet when send to verification server. The length value is encoded in a big-endian ordering 4 bytes.\n```\n# --------Load image bytes from file-------- \nimg_filestream = open(image_file_pathname, \"rb\") \nori_image_bytes = img_filestream.read() \nimg_filestream.close() \n\n# --------Convert to base64 string-------- \nori_image_base64 = base64.b64encode(ori_image_bytes) \nori_image_base64_str = ori_image_base64.decode('utf-8') \n\n# --------Compose JSON packet----------- \nJSON_dict = {\"token\": server_token, \n             \"image\": ori_image_base64_str, \n             \"need_return_image\": need_return_image} \nJSON_str = json.dumps(JSON_dict) \n\n# --------Convert to binary string and add length of packet------------ \nJSON_bytes = JSON_str.encode(\"utf-8\") \nlen_of_packet = len(JSON_bytes) \nlen_of_packet_bytes = pack('>I', len_of_packet)\n\n# ------------Send packet to verification server---------------- \nserver_address = (server_ipaddress, server_port) \nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) \nsock.connect(server_address) \nsock.sendall(total_bytes)\n```\n\n<br/>\n\n***Information returned from server:***<br/>\nReturned JSON object from verification server to client.\n\n|Key|Value|\n|:--|:--|\n|\"isSuccessful\"|True / False|\n|\"errMessage\"|Error message if isSuccessful is False|\n|\"noOfFaces\"|Number of faces detected. Only faces that passed the dimensional constrain check.|\n|\"imageWidth\"|Width of the image from verification server.|\n|\"imageHeight\"|Height of the image from verification server.|\n|\"faces\"|List of faces detected. Only faces that passed the dimensional constrain check.|\n|\"returnImage\"|Returned image (base64 string)|\n\n<br/>\n\n***Faces list:***\n\n|Key|Value|\n|:--|:--|\n|\"top\"|Top y-coordinate of face bounding box.|\n|\"left\"|Left x-coordinate of face bounding box.|\n|\"width\"|Width of face bounding box.|\n|\"height\"|Height of face bounding box.|\n|\"confPercentage\"|Confidence level (%) of face matches image sent.|\n<br/>\nSimilarly, the first 4 bytes of the returned packet indicates the length of packet.\n\n```\n# -------------Receive reply from server----------------- \nlen_of_packet_bytes = sock.recv(4) \nlen_of_packet_int = unpack('>I', len_of_packet_bytes)[0] \nreceived_data = b'' \nwhile len(received_data) < len_of_packet_int: \n    packet = sock.recv(len_of_packet_int - len(received_data)) \n\tif not packet: \n\t    break \n\treceived_data += packet sock.close() \n\n#------------Decode received binary string to JSON object--------- \nreceived_data_string = received_data.decode(\"utf-8\")\nreceived_data_JSON_obj = json.loads(received_data_string) \n\n# -------------Retrieve verification results--------------- \nisSuccessful = received_data_JSON_obj.get(\"isSuccessful\") \nif isSuccessful: \n    noOfFaces = received_data_JSON_obj.get(\"noOfFaces\") \n\timageWidth = received_data_JSON_obj.get(\"imageWidth\") \n\timageHeight = received_data_JSON_obj.get(\"imageHeight\") \n\t\n\tif noOfFaces > 0: \n\t    faces = received_data_JSON_obj.get(\"faces\") \n\t\tfor face_idx, face in enumerate(faces): \n\t\t    face_top = face[\"top\"] \n\t\t\tface_left = face[\"left\"] \n\t\t\tface_width = face[\"width\"] \n\t\t\tface_height = face[\"height\"] \n\t\t\tconfPercentage = face[\"confPercentage\"] \n\t\t\t\n\t\t\tprint(\"Face {}: confident {:.2f}%\".format(face_idx, confPercentage)) \n\telse: \n\t    print(\"No face detected.\") \n\t\t\n\tif need_return_image: \n\t    returned_image_base64_str = received_data_JSON_obj.get(\"returnImage\")\n\t\treturned_image_base64 = returned_image_base64_str.encode(\"utf-8\")\n\t\treturned_image_bytes = base64.b64decode(returned_image_base64)\n\t\treturned_image_array = np.frombuffer(returned_image_bytes, np.uint8)\n\t\treturned_image_np = cv2.imdecode(returned_image_array, cv2.IMREAD_COLOR) \n\t\t\n\t\tcv2.imshow(\"Returned image\", returned_image_np) cv2.waitKey(0)\n\t\tcv2.destroyAllWindows() else: print(\"Server return error message :\" +\n\t\treceived_data_JSON_obj.get(\"errMessage\"))\n\nelse: \n\tprint(\"Server return error message :\" + received_data_JSON_obj.get(\"errMessage\"))\n```\n\n<br/>\n\n***Guidelines for preparing reference image:***\n\n![Face guidelines](https://raw.githubusercontent.com/tensorfactory/PiFaceCam/master/images/face_guidelines.JPG)\n\nThe reference image used for verification has to meet the following guidelines, failing which may affect the accuracy or getting rejected by the verification server.\n1) The face (green box) has to be at the center of the image.\n2) The image has to be square (W = H).\n3) The margin (m) between face and border of image has to be within 10~25 % of the\nimage size (H). (Example, if the image size is 500pixels x 500pixels, then m has to be\nwithin the range of 50 to 125pixels.)\n4) Image size (W and H) has to be within the range of 320 to 512 pixels.\n\n<br/>\n\n***Advanced discussions:***<br/>\n- Events happened during the current run can be retrieved from info_log.txt file stored in the module folder. This file will be overided each time pifacecam startd.\n- Any parameters set in the run function will be verified before accepted. If rejected, the error message will be print out and logged in info_log.txt file. If accepted, they will overide the default values. These values (except for \"faceids_folder_pathname\"),  will persist even if you subsequently remove(not set) the parameter in the \"run\" function. \n- To reset all settings to the default values, you need to delete the settings.dat file in the module folder.\n- During face id processing [2], images with face not facing front, belongs to different person, partially obstructed or too blur will be rejected. These rejected images will be moved to a \"rejected\" folder created within the original folder.\n- Once face ids are created, they are stored as encrypted files (faceids_image_cache.dat & data.dat).You can subsequently choose to remove all images from \"faceids_folder_pathname\" TOGETHER with the id folders. \n- To removing a saved face id, you create an empty folder for the face id. PiFaceCam will remove the id when it detect an empty folder for the id during start. To remove all saved ids at once, just delete both faceids_image_cache.dat & data.dat files.<br/><br/>\n\n**Revisions:**<br/>\n1) (ver:1.0.103) - Sept 2020.\n* First release to pypi.org\n\n2) (ver:1.2.002) - July 2021.\n* Add option to disable shutdown and/or status gpios.\n* Run() function to return an integer when shutdown pin is triggered or a fatal error has occurred. The value of the returned integer will also indicate the reason for the return.\n* Add option to rotate camera by 180 degrees.\n* Fixed bug of data_dict[\"face_confidence_percentage_list\"] of callback function not return correct values.<br/><br/>\n\n\n**Terms and conditions:**<br/>\nThis is the PiFaceCam License Agreement<br/>\n1) Introduction\n* 1.1 The PiFaceCam (referred to in the License Agreement as the \"PFC\") is licensed to you subject to the terms of the License Agreement. The License Agreement forms a legally binding contract between you and TensorFactory in relation to your use of the PFC.\n* 1.2 \"TensorFactory\" means TensorFactory Enterprise and its owner.\n\n2) Accepting this License Agreement\n* 2.1 By downloading, accessing or using the PFC, you agree to be bound by this License Agreement. If you do not accept the License Agreement, you must immediately discontinue your use of PFC. Continued use of the PFC will constitute acceptance of the License Agreement.\n* 2.2 If you are agreeing to be bound by the License Agreement on behalf of your employer or other entity, you represent and warrant that you have full legal authority to bind your employer or such entity to the License Agreement. If you do not have the requisite authority, you may not accept the License Agreement or use the PFC on behalf of your employer or other entity.\n\n3) PFC License from TensorFactory\n* 3.1 Subject to the terms of the License Agreement, TensorFactory grants you a limited, worldwide, royalty-free, non-assignable, non-exclusive, and non-sublicensable license to use the PFC.\n* 3.2 You agree that TensorFactory own all legal right, title and interest in and to the PFC, including any Intellectual Property Rights that subsist in the PFC. \"Intellectual Property Rights\" means any and all rights under patent law, copyright law, trade secret law, trademark law, and any and all other proprietary rights. TensorFactory reserves all rights not expressly granted to you.\n* 3.3 You may not use the PFC for any purpose not expressly permitted by the License Agreement. You may not modify, decompile, reverse engineer or disassemble any part of the PFC.\n* 3.4 You agree that the form and nature of the PFC that TensorFactory provides may change without prior notice to you and that future versions of the PFC may be incompatible with files generated on previous versions of the PFC.\n* 3.5\tNothing in the License Agreement gives you a right to use any of TensorFactory's trade names, trademarks, service marks, logos, domain names, or other distinctive brand features.\n\n4) Use of the PFC by You\n* 4.1 You agree to use the PFC only for purposes that are permitted by (a) the License Agreement and (b) any applicable law, regulation or generally accepted practices or guidelines in the relevant jurisdictions.\n* 4.2 You agree that if you use the PFC on general public persons, you will protect the privacy and legal rights of those persons.\n* 4.3 You agree that you are solely responsible for (and that TensorFactory has no responsibility to you or to any third party for) any data, content, or resources that you create, transmit or display through PFC, and for the consequences of your actions (including any loss or damage which TensorFactory may suffer) by doing so.\n* 4.4 You agree that you are solely responsible for (and that TensorFactory has no responsibility to you or to any third party for) any breach of your obligations under the License Agreement, any applicable third party contract or Terms of Service, or any applicable law or regulation, and for the consequences (including any loss or damage which TensorFactory or any third party may suffer) of any such breach.\n\n5) DISCLAIMER OF WARRANTIES\n* 5.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT YOUR USE OF THE PFC IS AT YOUR SOLE RISK AND THAT THE APPLICATION IS PROVIDED \"AS IS\" AND \"AS AVAILABLE\" WITHOUT WARRANTY OF ANY KIND FROM TENSORFACTORY.\n* 5.2 YOUR USE OF THE PFC IS AT YOUR OWN DISCRETION AND RISK AND YOU ARE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM OR OTHER DEVICE OR LOSS OF DATA THAT RESULTS FROM SUCH USE.\n* 5.3 TENSORFACTORY FURTHER EXPRESSLY DISCLAIMS ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES AND CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.\n\n6) LIMITATION OF LIABILITY\n* 6.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT TENSORFACTORY SHALL NOT BE LIABLE TO YOU UNDER ANY THEORY OF LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES THAT MAY BE INCURRED BY YOU, INCLUDING ANY LOSS OF DATA, WHETHER OR NOT TENSORFACTORY HAVE BEEN ADVISED OF OR SHOULD HAVE BEEN AWARE OF THE POSSIBILITY OF ANY SUCH LOSSES ARISING.\n\n7) Indemnification\n* 7.1 To the maximum extent permitted by law, you agree to defend, indemnify and hold harmless TensorFactory from and against any and all claims, actions, suits or proceedings, as well as any and all losses, liabilities, damages, costs and expenses (including reasonable attorneys fees) arising out of or accruing from (a) your use of the PFC that infringes any copyright, trademark, trade secret, trade dress, patent or other intellectual property right of any person or defames any person or violates their rights of publicity or privacy, and (b) any non-compliance by you with the License Agreement.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/tensorfactory/PiFaceCam",
    "keywords": "facial recognition,raspberry pi",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pifacecam",
    "package_url": "https://pypi.org/project/pifacecam/",
    "platform": "",
    "project_url": "https://pypi.org/project/pifacecam/",
    "project_urls": {
      "Homepage": "https://github.com/tensorfactory/PiFaceCam"
    },
    "release_url": "https://pypi.org/project/pifacecam/1.2.2/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Facial Recognition for Raspberry Pi",
    "version": "1.2.2",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10884835,
  "releases": {
    "1.0.103": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9ecddebf836f9c570940582a3812451917955cf0e8c1c34309a8d36795b44bc8",
          "md5": "a6103f1cdc673fed27151fc84e7b8c1d",
          "sha256": "412e6516d11b0476aa814e6b868917fa452ca8ec5ed23d81ef83a948d69bc4bf"
        },
        "downloads": -1,
        "filename": "pifacecam-1.0.103-cp37-cp37m-linux_armv7l.whl",
        "has_sig": false,
        "md5_digest": "a6103f1cdc673fed27151fc84e7b8c1d",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": ">=3.7",
        "size": 70676426,
        "upload_time": "2020-09-21T08:23:57",
        "upload_time_iso_8601": "2020-09-21T08:23:57.337228Z",
        "url": "https://files.pythonhosted.org/packages/9e/cd/debf836f9c570940582a3812451917955cf0e8c1c34309a8d36795b44bc8/pifacecam-1.0.103-cp37-cp37m-linux_armv7l.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "4d8a49a2c2769e5b9c44b825330ea2720e4a5b21245ddcba62564e601cc2a2a3",
          "md5": "d8d39f36379beb7e2d8679869888d23d",
          "sha256": "415d4252cc20056bb62c60feecc94d7c97aee95a8bfe385474ffce36764122a5"
        },
        "downloads": -1,
        "filename": "pifacecam-1.2.2-cp37-abi3-linux_armv7l.whl",
        "has_sig": false,
        "md5_digest": "d8d39f36379beb7e2d8679869888d23d",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": ">=3.7",
        "size": 70688626,
        "upload_time": "2021-07-12T13:22:16",
        "upload_time_iso_8601": "2021-07-12T13:22:16.933053Z",
        "url": "https://files.pythonhosted.org/packages/4d/8a/49a2c2769e5b9c44b825330ea2720e4a5b21245ddcba62564e601cc2a2a3/pifacecam-1.2.2-cp37-abi3-linux_armv7l.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "4d8a49a2c2769e5b9c44b825330ea2720e4a5b21245ddcba62564e601cc2a2a3",
        "md5": "d8d39f36379beb7e2d8679869888d23d",
        "sha256": "415d4252cc20056bb62c60feecc94d7c97aee95a8bfe385474ffce36764122a5"
      },
      "downloads": -1,
      "filename": "pifacecam-1.2.2-cp37-abi3-linux_armv7l.whl",
      "has_sig": false,
      "md5_digest": "d8d39f36379beb7e2d8679869888d23d",
      "packagetype": "bdist_wheel",
      "python_version": "cp37",
      "requires_python": ">=3.7",
      "size": 70688626,
      "upload_time": "2021-07-12T13:22:16",
      "upload_time_iso_8601": "2021-07-12T13:22:16.933053Z",
      "url": "https://files.pythonhosted.org/packages/4d/8a/49a2c2769e5b9c44b825330ea2720e4a5b21245ddcba62564e601cc2a2a3/pifacecam-1.2.2-cp37-abi3-linux_armv7l.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}