{
  "info": {
    "author": "FlightAware",
    "author_email": "notnow@flightaware.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Intended Audience :: Developers",
      "Intended Audience :: System Administrators",
      "License :: OSI Approved :: BSD License",
      "Operating System :: MacOS :: MacOS X",
      "Operating System :: POSIX",
      "Operating System :: POSIX :: BSD",
      "Operating System :: POSIX :: BSD :: FreeBSD",
      "Operating System :: POSIX :: Linux",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Tcl",
      "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
      "Topic :: Software Development",
      "Topic :: Software Development :: Interpreters",
      "Topic :: Software Development :: Libraries :: Tcl Extensions"
    ],
    "description": "# tohil\n\n[![Linux CI](https://github.com/flightaware/tohil/actions/workflows/linux-ci.yml/badge.svg)](https://github.com/flightaware/tohil/actions/workflows/linux-ci.yml)\n\n<img src=\"https://github.com/flightaware/tohil/blob/main/graphics/237px-Quetzalcoatl_feathered_serpent.png\">\n\nTohil a feathered serpent, aims to provide a delightful integration between python, the serpent, and TCL, the feather.\n\nTohil is simultaneously a Python extension and a TCL extension that makes it possible to effortlessly call bidirectionally between Tcl and Python, targeting Tcl 8.6+ and Python 3.6+\n\nTohil is open source software, available for free including for profit and/or for redistribution, under the permissive 3-clause BSD license (see \"LICENSE.txt\").\n\ntohil is based on, and is completely inspired by and exists because of, libtclpy, by Aidan Hobson Sayers available at https://github.com/aidanhs/libtclpy/.\n\nTohil is pronounced as, your choice, toe-heel, or toe-hill.\n\nTohil is currently on version 3 ([release notes](TOHIL-3.md)).\n\n## Usage\n\nYou can import tohil into either a Tcl or Python parent interpreter. Doing so will create and initialise an interpreter for the corresponding language and define tohil's functions in both.\n\nUsing tohil, Python code can call Tcl code at any time, and vice versa, and they can call \"through\" each other, i.e. Python can call Tcl code that calls Python code that calls Tcl code, limited only by your machine's memory and your sanity (and the (settable) Python and Tcl recursion limits).\n\n### Accessing TCL From Python\n\nTo use Python to do things in Tcl, you invoke functions defined by the tohil module that gets created when you import tohil into your Python interpreter.\n\nTohil:\n\n* ...provides several routines to evaluate tcl code, passing it data using common and familiar python objects such as strs, bools, ints, floats, lists, dicts, tuples, etc, and producing those types from tcl results as well.\n* ...defines a new python data type, [tohil.tclobj](TCLOBJECTS.md), that allows the direct and efficient manipulation of Tcl lists, dicts, etc, passing them around, using them as arguments in calls to tcl functions, and receiving them from function results as well.\n* ...creates shadow dictionaries, a python dictionary-type object that accesses and manipulate Tcl arrays as python dictionaries\n* ...provides a [TclProc class](TCLPROCS.md) that creates callable python object-functions that will call their corresponding tcl procs and C commands and return the results to python, optionally with a specified python type that the returned data should be converted to.\n* ...provides a TclNamespace class that has the ability to import all the Tcl procs and C commands found there as methods of the namespace class, and recursively descend child namespaces, creating new TclNamespaces objects, binding them to their parent objects, and importing all the procs found within them as well.  See also the tohil 3 [release notes](TOHIL-3.md).\n\n```python\nimport tohil\n```\n\n#### tohil.eval\n\n - `tohil.eval(evalstring, to=type)`\n   - takes: string of valid Tcl code\n   - returns: the final return value\n   - side effects: executes code in the Tcl interpreter\n   - *Do not use with untrusted substituted input*\n   - `evalString` may be any valid Tcl code, including semicolons for single line statements or multiline blocks\n   - uncaught tcl errors tracing back all the way to the the tohil membrane are raised as a python exception\n\nBy default the results of the Tcl code evaluated (if there wasn't an exception) is returned to the caller, as a string.\n\nThe optional \"to\" named parameter allows you to specify one of a number of data types that will cause tohil to convert the return into a native Python data type.\n\nThe types supported are str, int, bool, float, list, set, dict, tuple, and tohil.tclobj.\n\n```python\n>>> tohil.eval('set a [list a 1 b 2 c 3]')\n'a 1 b 2 c 3'\n>>> tohil.eval('return $a', to=list)\n['a', '1', 'b', '2', 'c', '3']\n>>> tohil.eval('return $a',to=dict)\n{'a': '1', 'b': '2', 'c': '3'}\n\n>>> a, b, c = tohil.eval(\"list 1 2 3\", to=tuple)\n>>> c\n'3'\n```\n\nNote that currently for list, set, dict, and tuple, the values constructed therein will be strings.  We already have code that can recognize and convert a few types and could use that, or perhaps we will create a way to specify desired type conversions within compound types.\n\n#### tohil.call\n\n - `tohil.call(command, arg1, arg2, arg3, to=type)`\n   - takes: single Tcl command name plus zero or more arguments, and an optional data type to convert the return to\n   - returns: whatever tcl returned\n   - side effects: executes code in the Tcl interpreter\n   - uncaught tcl errors tracing back all the way to the the tohil interface are raised as a python exception\n\nAs it can be tricky to invoke Tcl using eval and not getting possibly unwanted side effects if arguments (such as data!) contain tcl metadata such as square brackets and dollar signs, a direct argument-for-argument *tohil.call* is provided where tcl will not do variable and command substitution on its arguments and thus help keep funny business to a minimum.\n\n```python\n>>> import tohil\n>>> clock = 1616182348\n>>> tohil.call('clock', 'format', clock, '-locale', 'fr')\n'ven. mars 19 19:32:28 UTC 2021'\n```\n\nThe above example is trivial and not really an example of something that might be unsafe to use eval for.  But imagine if you were submitting arbitrary data as arguments to Tcl commands.  It would be difficult to examine it in python to be sure tcl will execute it as you intended.\n\n#### tohil.getvar and tohil.setvar\n\nPython has direct access TCL variables and arrays using tohil.getvar.  Likewise, tohil.setvar can set them.\n\n```\n>>> import tohil\n>>> tohil.setvar(\"foo\", \"bar\")\n>>> tohil.getvar(\"foo\")\n'bar'\n>>> tohil.setvar(var=\"happy\", value=\"lamp\")\n>>> tohil.getvar(\"happy\")\n'lamp'\n\n>>> tohil.eval(\"array set x [list a 1 b 2 c 3 d 4]\")\n''\n>>> tohil.getvar('x(a)')\n'1'\n>>> tohil.getvar('x(a)', to=int)\n1\n>>> tohil.getvar(var='x(b)', to=float)\n2.0\n>>> tohil.getvar(\"x(e)\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: can't read \"x(e)\": no such element in array\n```\n\nAs you can see, it's an error to try to get a variable or array element that isn't there.  You can use tohil.exists to see if the variable is there, or trap the python exception, or possibly make use of tohil.getvar's handy \"default\" keyword-only argument.\n\n```\n>>> tohil.getvar(\"x(e)\", default=\"0\")\n'0'\n>>> tohil.getvar(\"x(e)\", default=0, to=int)\n0\n>>> tohil.getvar(\"x(d)\", default=0, to=int)\n4\n```\n\n#### tohil.incr\n\ntohil.incr takes a tcl variable name or array element and attempts to increment it.\n\nIf the contents of the variable preclude it being used as an int, a python\nTypeError exception is thrown.\n\nAn optional position argument specifies an increment amount.  The default increment is 1.\nNegative increments are permitted.  The increment amount can also be specified as\na keyword argument, using \"incr\".\n\n```\ntohil.incr('var')\ntohil.incr('var',2)\ntohil.incr('var',incr=-1)\n```\n\n\n#### tohil.exists\n\nSince it is an error to try to getvar a variable that doesn't exist, you can trap the request from python and handle the exception, or use tohil.exists to see if the var or array element exist.\n\n```\n>>> tohil.eval(\"array set x [list a 1 b 2 c 3 d 4]\")\n''\n>>> tohil.exists(\"x(c)\")\nTrue\n>>> tohil.exists(\"x(e)\")\nFalse\n>>>\n>>> tohil.exists(\"banana\")\nFalse\n```\n\n#### tohil.unset\n\nTohil can be used to unset variables, array elements, and even entire arrays in the Tcl interpreter.\n\nUnsetting an array element uses the subscrit notation, for example `x(e)`.\n\nUnsetting an array by name with a subscript will unset the entire array.\n\nIt is not an error to attempt to unset a variable that doesn't exist.\n\n```\n>>> tohil.setvar(\"x(e)\", \"5\")\n>>> tohil.getvar(\"x(e)\")\n'5'\n>>> tohil.unset(\"x(e)\")\n>>> tohil.getvar(\"x(e)\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: can't read \"x(e)\": no such element in array\n```\n\n\n#### tohil.expr\n\nYou can also evaluate tcl expressions from python using tohil.expr.  As with many other tohil functions, to= can be used to request conversion to a specific python datatype.\n\n```\n>>> tohil.expr('5+5')\n'10'\n>>> tohil.expr('5**5')\n'3125'\n>>> tohil.expr('1/3')\n'0'\n>>> tohil.expr('1/3.')\n'0.3333333333333333\n>>> tohil.expr('1/3.',to=float)\n0.3333333333333333\n>>> tohil.expr('[clock seconds] % 86400')\n'25571'\n>>> tohil.expr('[clock seconds] % 86400',to=int)\n25571\n```\n\nRemember that, like eval, tohil.expr evaluates its arguments and will do $-substition and execute square-bracketed code embedded in the passed expression.\n\n#### tohil.convert\n\nTohil.convert will convert some python thing passed to it, into a tcl object, and then back to some other python type, a string by default, but any type supported in accordance with the to= argument.\n\nIt's an easy way to get a tclobj object `(t = tohil.convert(5, to=tohil.tclobj)`, but in that case it's easier to do `t = tohil.tclobj(5)`.\n\nPass a python object to tohil.convert and get back a string by default, or use the same to=\n\n#### tohil.subst\n\nTcl's *subst* command is pretty cool.  By default it performs Tcl backslash, command and variable substitutions, but doesn't evaluate the final result, like eval would.  So it's nice to generate some kind of string but with embedded $-substitution and square bracket evaluation.\n\n\n```\n>>> import tohil\n>>> tohil.eval(\"set name karl\")\n'karl'\n>>> tohil.subst(\"hello, $name\")\n'hello, karl'\n```\n\nThe \"to=\" way of requesting a type conversion is supported.  Although you might not care about converting to int or float or something, you might want a tohil.tclobj for your efforts, anirite?\n\n#### tohil.interact\n\nRun the Tcl interactive command loop on stdin, hopefully a terminal, until you send an EOF, at which point you'll be returned to the python command line.  See also tohil::interact.\n\n#### python tclobj datatype\n\nTohil 2 introduced a new python data type called tclobj, aka tohil.tclobj.\n\nIt's a python-wrapped Tcl object and it's very useful for generating and manipulating, passing to and receiving from, tcl routines, tcl lists, .  See [TCLOBJECTS.md](TCLOBJECTS.md) for more.\n\n#### Shadow Dictionaries\n\nShadow Dictionaries, aka ShadowDicts, create a python dict-like object that shadows a Tcl array.\n\nTcl arrays are basically the Tcl equivalent of Python's dicts, by the way.\n\nAnyway, let's assume we have an array \"x\" in Tcl that we want to shadow as\na dictionary \"x\" in Python, we would write `x = tohil.ShadowDict(\"x\")`.\n\nIf you just specify a variable name without any namespace qualifiers, the\narray references the current tcl execution frame, like if a tcl proc had\ncalled python and in our python we did the x equals thing for a shadow dict\nthen the \"x\" array would exist in the proc's frame.\n\nIf we're invoking it not from tcl code called from python, just from python\nor the top level or python or whatever, then x is in the global (\"::\")\nnamespace.  You can always provide namespace qualifiers to identify the\nglobal or some subordinate namespace, like \"::cryptolib::x\"\n\nOnce created, shadowdict elements can be gotten as a string using str() or print(), etc.\n\nElements can be read form the python side using dictionary notation, for example `x['d']`, set in a standard way (`x['e'] = '5'`), and deleted using del (`del x['e']`).  Also you can iterate on the keys as with dicts.\n\nChanges made from the Python side occur on the Tcl side, and all accesses, traversals, etc, are made using the Tcl array.  In other words, ShadowDicts never cache values from the Tcl array on the python side.\n\nIn the example below we set up a Tcl array, create a ShadowDict of it in python, get a string representation of the dict, read from the dict, insert into it, delete from it, and demonstrate that the changes we made are present on the Tcl side.  Finally, it iterates over the shadow dict, showing the same keys from python that tcl was shown to have.\n\n```\n>>> tohil.eval(\"array set x [list a 1 b 2 c 3 d 4]\")\n''\n>>> x = tohil.ShadowDict(\"x\", to=int)\n>>> x\n{'d': '4', 'e': '5', 'a': '1', 'b': '2', 'c': '3'}\n>>> x['d']\n4\n>>> x['e'] = '5'\n>>> x['e']\n5\n>>> del x['d']\n>>> tohil.eval(\"parray x\")\nx(a) = 1\nx(b) = 2\nx(c) = 3\nx(e) = 5\n''\n>>> for i in x:\n...     print(i)\n...\na\nb\nc\ne\n```\n\nShadowDict support many of the capables of regular python dicts.  For example,\nlen(x) will return the length of the shadow dict i.e. the size of the\nshadowed tcl array.\n\nx.keys() return the keys, x.values() returns, and x.items() returns the\nkeys and items as a list of two-element tuples.  However, unlike\nregular python dicts, they are not mutable, i.e. if you have captured\na reference to x.keys() the contents of x.keys() does not change when\nthe corresponding dict is changed.\n\nx.get(key) will return the element of the array indexed by key, if it\nexists, else it will raise a KeyError exception.  However if a named\nparameter, \"default\", is specified with a value, in the event key is\nnot found in x, the default value will be returned instead.\n\nFinally the to= named parameter can be used to specify a python return\ntype such as list, set, dict, int, float, str, tohil.tclobj, tohil.tcldict,\netc.\n\nx.pop(key), if key is in the shadow dictionary, removes it and returns\nit.  A default value can be specified as an optional second argument.\nIf a default is not specified and the key is not in the dictionary,\na KeyError exception is raised.  As with so many other functions, the\nto= named parameter can be specified to state what return type you\nwant back to python.\n\n#### Examples using tohil from Python\n\n```python\n>>> import tohil\n>>> a = tohil.eval('list 1 [list 2 4 5] 3')\n>>> print(a)\n1 {2 4 5} 3\n\n>>> import tohil\n>>> tohil.eval('set a(99) goof')\n'goof'\n>>> tohil.eval('set a(5) foo')\n'foo'\n>>> tohil.getvar('a','99')\n'goof'\n>>> tohil.getvar(array='a',var='5')\n'foo'\n>>> tohil.getvar(array='a',var='16')\n\n\n>>> tohil.eval('set a [list a 1 b 2 c 3]')\n'a 1 b 2 c 3'\n>>> tohil.subst(\"$a\")\n'a 1 b 2 c 3'\n>>> tohil.eval('return $a')\n'a 1 b 2 c 3'\n>>> tohil.eval('return $a',to=list)\n['a', '1', 'b', '2', 'c', '3']\n>>> tohil.eval('return $a',to=dict)\n{'a': '1', 'b': '2', 'c': '3'}\n\n>>> tohil.eval(to=list,tcl_code=\"return [list 1 2 3 4]\")\n['1', '2', '3', '4']\n\n```\n\nCheck this out, converting expected results to python datatypes:\n\n```python\n>>> import tohil\n>>> tohil.eval(\"clock seconds\")\n'1616053828'\n>>> tohil.eval(\"clock seconds\",to=int)\n1616053834\n>>> tohil.eval(\"clock seconds\",to=float)\n1616053838.0\n>>> tohil.eval(\"clock seconds\",to=bool)\nTrue\n>>> tohil.eval(\"clock seconds\",to=list)\n['1616053849']\n```\n\nNow eval with to=set option to return a set from a list...\n\n```python\n>>> tohil.eval('return [list 1 2 3 4 4 3]',to=set)\n{'3', '4', '2', '1'}\n```\n\n### Accessing Python From TCL\n\nFrom Tcl, tohil provides access to Python through several commands and some procs.\n\nProbably the most important commands are `tohil::eval`, `tohil::exec` and `tohil::call`.  The first two commands correspond closely to python's `eval` and `exec`.\n\nGeneral notes:\n - All commands are run in the context of a single interpreter session. Imports, function definitions and variables persist.\n - Uncaught exceptions in the python interpreter resulting from code invoked from Tcl using tohil will propagate a TCL error including a stack trace of the python code that was executing. As the exception continues up the stack, the tcl stack trace will be appended to it.\n - The Tcl error code is set to a list comprising \"PYTHON\", the class name of the exception, and the base error message.  This is experimental but likely to continue.  I would like to add the class arguments, though.\n - Such Python errors may be caught (as per tcl stack traces) with Tcl's catch or try, the same as any other TCL error.\n\n```tcl\npackage require tohil\n```\n\nTohil provides new commands for interacting with the python interpreter, via the ::tohil namespace.\n\n#### tohil::eval\n\ntohil::eval evaluates the code passed to it as if with native python's eval.  So the argument has to be an expression, some kind of simple call, etc, i.e. it is an error if you try to define a function with it, or even set the value of a variable.\n\nAnything returned by python from the eval is returned to to the caller of tohil::eval.\n\n#### tohil::exec\n\ntohil::exec evaluates the code passed to it as if with python's exec.  Nothing is returned.  If the python code prints anything, it goes to stdout using python's I/O subsystem.  However you can easily redirect python's output to go to a string, or whatever, in the normal python manner.  tohil::run, in fact, provides a way to do this.\n\n#### tohil::run\n\ntohil::run evaluates the code passed to it as if with python's exec, but unlike tohil::exec, anything emitted by the python code to python's stdout (print, etc) is captured by tohil::run and returned to the caller.\n\n#### tohil::call\n\ntohil::call provides a way to invoke one python function, with zero or more arguments, without having to pass it through Python's eval or exec and running the risk that python metacharacters appearing in the data will cause quoting problems, accidental code execution, etc.\n\n#### tohil::import\n\ntohil::import provides a way to import python modules, although I'm not sure that it's much different from doing a tohil::exec \"import module\"\n\n#### tohil::interact\n\nTake tohil to eleven.  You're on ten here... all the way up... You're on ten on your guitar... where can you go from there?  Where?  Nowhere.  Exactly.  What we do is if we need that extra... push over the cliff... you know what we do?\n\nWe run tohil::interact from tcl and enter the python interactive loop.  When we're done, we send end of file (^D) to end the python loop and return to the tcl one.\n\n```\ntcl % tohil::interact\n>>> def foo():\n...   print(\"bar\")\n...\n>>> ^D\ntcl % tohil::eval foo()\nbar\n```\n\n#### Reference\n\n - `tohil::eval evalString`\n   - takes: string of valid python code\n   - returns: the result of the eval\n   - side effects: executes code in the python interpreter\n   - `evalString` may be any valid python expression\n - `tohil::call ?obj.?func ?arg ...?`\n   - takes: name of a python function\n   - returns: return value of function with the first appropriate conversion applied from the list below:\n     - `None` is converted to an empty string\n     - `True` and `False` are converted to a Tcl boolean object with a corresponding value\n     - Python *str objects* are converted to Tcl byte arrays\n     - Python *unicode objects* are converted to Tcl unicode strings\n     - Python *number objects* are converted I think to text numbers NB this is probably improvable\n     - Python *mapping objects* (supporting key-val mapping, e.g. python dicts) are converted to tcl dicts\n     - Python *sequence objects* (supporting indexing, e.g. python lists) are converted to tcl lists\n     - Otherwise, the str function is applied to the python object and that's set into the corresponding Tcl object\n   - side effects: executes function\n   - `func` may be a dot qualified name (i.e. object or module method)\n - `tohil::exec execString`\n   - `takes: string of valid python code`\n   - `returns: the result of the python exec`\n   - `side effects: executes code in the python interpreter`\n   - **Do not use with substituted input**\n   - `execString` may be any valid python code, including semicolons for single line statements or (non-indented) multiline blocks with indentions, etc.\n   - errors reaching the python interpreter top level (i.e. not caught tcl-side or python-side by application code) are printed to stderr\n - `tohil::import module`\n   - takes: name of a python module\n   - returns: nothing\n   - side effects: imports named module into globals of the python interpreter\n   - the name of the module may be of the form module.submodule\n   - You can do the same thing using exec and, currently, exercise more control.  For example `tohil::exec \"from io import StringIO\"`\n\n\n#### Examples using tohil from Tcl\n\n```\n% package require tohil\n% tohil::exec {divide = lambda x: 1.0/int(x)}\n% set d [tohil::call divide 16]\n0.0625\n% list [catch {tohil::call divide 0} err] $err\n1 {ZeroDivisionError: float division by zero\n  File \"<string>\", line 1, in <lambda>\n----- tcl -> python interface -----}\n%\n% tohil::import json\n% tohil::exec {\ndef jobj(*args):\n    d = {}\n    for i in range(len(args)/2):\n        d[args[2*i]] = args[2*i+1]\n    return json.dumps(d)\n}\n% set e [dict create]\n% dict set e {t\"est} \"11{24\"\nt\\\"est 11\\{24\n% dict set e 6 5\nt\\\"est 11\\{24 6 5\n% set e [py call jobj {*}$e]\n{\"t\\\"est\": \"11{24\", \"6\": \"5\"}\n%\n% tohil::import sqlite3\n% tohil::eval {b = sqlite3.connect(\":memory:\").cursor()}\n% tohil::eval {def exe(sql, *args): b.execute(sql, args)}\n% tohil::call exe \"create table x(y integer, z integer)\"\n% tohil::call exe \"insert into x values (?,?)\" 1 5\n% tohil::call exe \"insert into x values (?,?)\" 7 9\n% tohil::call exe \"select avg(y), min(z) from x\"\n% tohil::call b.fetchone\n4.0 5\n% tohil::call exe \"select * from x\"\n% set f [tohil::call b.fetchall]\n{1 5} {7 9}\n%\n% puts \"a: $a, b: $b, c: $c, d: $d, e: $e, f: $f\"\na: , b: 15, c: someinput, d: 0.0625, e: {\"t\\\"est\": \"11{24\", \"6\": \"5\"}, f: {1 5} {7 9}\n```\n\nThis might bake your noodle...\n\n```\n>>> tohil.eval('tohil::eval \"2 ** 32 - 1\"')\n'4294967295'\n```\n\n### Using tohil from Rivet\n\nFrom a Rivet page, in some of your Tcl code, invoke `package require tohil`.\n\nIf you run tohil_rivet it will plug tohil's python interpreter such that everything it writes to stdout using print, or whatever, will go through Tcl's stdout and thereby into your Rivet page.\n\n```\n<?\n\npackage require tohil; tohil_rivet\n\nputs \"calling out to python to add 5 + 5: [::tohil::eval \"5 + 5\"]\"\n\ntohil::exec {\nprint('hello, world')\nprint(\"<hr>\")\n}\n\n?>\n```\n\n###  Building tohil on Unix, Linux, FreeBSD and the Mac\n\ntohil builds with the familiar GNU autoconf build system.  \"autoreconf\" will produce a configure script based on the configure.in.  The tooling used is the standard Tcl Extension Architecture (TEA) approach, which is pretty evolved and fairly clean considering it's autoconf.\n\nIt is assumed that you\n - have got the repo (either by `git clone` or a tar.gz from the releases page).\n\nThe build process fairly simple:\n - run the configure script\n - make\n - sudo make install\n\nWe're using setuptools to build the python module, so the Makefile.in/Makefile is basically doing\n\n```\npython3 setup.py build\npython3 setup.py install\n```\n\n...to build and install the python module.\n\nNow try it out:\n\n\t$ TCLLIBPATH=. tclsh\n\t% package require tohil\n\t1.0.0\n\t% tohil::import random\n\t% tohil::call random.random\n\t0.507094977417\n\n### tests\n\nRun the tests with\n\n\t$ make test\n\n### gotchas\n\n1. Be very careful when putting unicode characters into a inside a `tohil.eval`\nor `tohil.exec` call - they are decoded by the tcl parser and passed as literal bytes\nto the python interpreter. So if we directly have the character \"à² \", it is\ndecoded to a utf-8 byte sequence and becomes u\"\\xe0\\xb2\\xa0\" (where the \\xXY are\nliteral bytes) as seen by the Python interpreter.\n2. Escape sequences (e.g. `\\x00`) inside py eval may be interpreted by tcl - use\n{} quoting to avoid this.\n\nYou need to build the library without stubs for python to be able to use it.\n\nOn FreeBSD at least i have to change -ltclstub86 to -ltcl86 in Makefile after\nit is created -- this needs to be done properly\n\nOn the Mac the python3 setup.tcl thing builds a shared library but it doesn't properly link it to the tcl library so you get a runtime error when you try to import tohil.\n\ncopy the .dylib file that make built to the .so file where make install sent the python module and it will work.\n\nsomething like (on the mac, using pyenv)\n\nsudo cp tohil1.0.0.dylib ~/.pyenv/versions/3.8.2/lib/python3.8/site-packages/tohil.cpython-38-darwin.so\n\nor\n\ncp tohil1.0.0.dylib build/lib.macosx-10.6-x86_64-3.8/tohil.cpython-38-darwin.so\n\n### To Do\n\n* a way to pass kwargs thought tohil::eval - done\n* if python is the parent, register a tcl panic handler and invoke Py_FatalError if tcl panics.\n* the reverse of the above if tcl is the parent if python has a panic-type function with a registerable callback\n* python tclobj and tcldict types have worked out pretty well.  what might we do with a tcl type that encapsulates a python object?\n\nBelow is the old list.  Some of this stuff has been done.  We probably don't have the same priorities.  Will update over time.\n\nIn order of priority:\n\n - allow compiling on Windows\n - `py call -types [list t1 ...] func ?arg ...? : ?t1 ...? -> multi`\n   (polymorphic args, polymorphic return)\n - unicode handling (exception messages, fn param, returns from calls...AS\\_STRING is bad)\n - allow statically compiling python into tohil\n   - http://pkaudio.blogspot.co.uk/2008/11/notes-for-embedding-python-in-your-cc.html\n   - https://github.com/albertz/python-embedded\n   - https://github.com/zeha/python-superstatic\n   - http://www.velocityreviews.com/forums/t741756-embedded-python-static-modules.html\n   - http://christian.hofstaedtler.name/blog/2013/01/embedding-python-on-win32.html\n   - http://stackoverflow.com/questions/1150373/compile-the-python-interpreter-statically\n - allow statically compiling\n - check threading compatibility\n - `py import ?-from module? module : -> nil`\n - return the short error line in the catch err variable and put the full stack trace in errorInfo\n - py call of non-existing function says raises attribute err, should be a NameError\n - make `py call` look in the builtins module - http://stackoverflow.com/a/11181607\n - all TODOs\n\n### notes\n\n[pyman](http://chiselapp.com/user/gwlester/repository/pyman/home) is a Tcl package that provides a higher level of abstraction on top of tclpy.  It will need to be updated for tohil but bears examination and hopefully the participation of its author, Gerald Lester.\n\n### geek notes\n\nThe same tohil shared library created by building this software can be\nloaded both by Python and Tcl, which is pretty cool.  It used to be\nnecessary so that tohil could work at all.\n\nHowever since there are different\nbuild pipelines for tcl extensions (based on autoconf via the tcl extension\narchitecture) and python (based on python setuptools), we\nchanged tohil's implementation to be able to work ok even with two different\nshared libraries by moving the critical piece of shared data, the tcl\ninterpreter pointer, formerly held statically by the shared library itself,\ninto the python interpreter via python's capsule stuff, allowing both shared\nlibraries to be able to find the interpreter.\n\n### what magic is this\n\n```\ntohil.call(\"set\", \"mydict\", tohil.call(\"dict\", \"create\", *itertools.chain(*d.items())))\n```\n\nAww that's old stuff, with TclProcs we can do\n\n```\nl = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\nt = tohil.import_tcl()\nt.set(\"mydict\", t.dict(\"create\", *itertools.chain(*l.items())))\nt.dict(\"get\", t.set(\"mydict\"), \"c\", to=int)\n```\n\nthat's a little gross, still.\n\nWith tclobjs we can do\n\n```\no = tohil.tclobj({'a': 1, 'b': 2, 'c': 3, 'd': 4})\nt.set(\"mydict\", o)\no.td_get('c', to=int)\n```\n\n\n### formatting\n\nthis needs to be built into the makefile or something\n\nclang-format -style=file -i generic/tohil.c\n\n### debugging tohil internals\n\nhttps://pythonextensionpatterns.readthedocs.io/en/latest/debugging/debug_python.html#debug-version-of-python-memory-alloc-label\n\n\nbuild and install python with something like\n\nmkdir linux\ncd linux\n../configure --with-pydebug --without-pymalloc --with-valgrind --enable-shared\n\nnot sure about the enable shared\n\nbuild tohil\n\n./configure --prefix=/usr/local --exec-prefix=/usr/local --with-python-version=3.9d\n\nnote 3.9d instead of just 3.9\n\n### image attribution\n\nDo you like the tohil logo?  It's from a creative commons-licensed image of the Mayan deity Quetzalcoatl (also known in some cultures as Tohil), from the Codex Telleriano-Remensis, from the 16th century.\n\nA scan of the image can be found here https://commons.wikimedia.org/wiki/File:Quetzalcoatl_telleriano.jpg.  A wikimedia user, https://commons.wikimedia.org/wiki/User:Di_(they-them), made an SVG file of it, available here https://commons.wikimedia.org/wiki/File:Quetzalcoatl_feathered_serpent.svg\n\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/flightaware/tohil",
    "keywords": "tcl,programming,deity",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "tohil",
    "package_url": "https://pypi.org/project/tohil/",
    "platform": "",
    "project_url": "https://pypi.org/project/tohil/",
    "project_urls": {
      "Bug Reports": "https://github.com/flightaware/tohil/issues",
      "Funding": "https://donate.pypi.org",
      "Homepage": "https://github.com/flightaware/tohil",
      "Say Thanks!": "http://saythanks.io/to/example",
      "Source": "https://github.com/flightaware/tohil/"
    },
    "release_url": "https://pypi.org/project/tohil/3.2.0/",
    "requires_dist": [
      "check-manifest ; extra == 'dev'",
      "coverage ; extra == 'test'"
    ],
    "requires_python": ">=3.6, <4",
    "summary": "tohil, a feathered serpent, binds together the serpent, python, with the feather, tcl",
    "version": "3.2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 10421636,
  "releases": {
    "3.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c5cc973e540a30c4e98ad824c2ef4321fd3995cb874fb0542b6f51b5525fa96",
          "md5": "99c429f8b2eeb920e5987029202315ad",
          "sha256": "88bdde889e4a5e5eaba4b37351c634cf59b68ab7a82c91761b4ae5e5acda26d2"
        },
        "downloads": -1,
        "filename": "tohil-3.2.0-cp37-cp37m-linux_armv7l.whl",
        "has_sig": false,
        "md5_digest": "99c429f8b2eeb920e5987029202315ad",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": ">=3.6, <4",
        "size": 125431,
        "upload_time": "2021-05-20T21:59:57",
        "upload_time_iso_8601": "2021-05-20T21:59:57.772707Z",
        "url": "https://files.pythonhosted.org/packages/8c/5c/c973e540a30c4e98ad824c2ef4321fd3995cb874fb0542b6f51b5525fa96/tohil-3.2.0-cp37-cp37m-linux_armv7l.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "8c5cc973e540a30c4e98ad824c2ef4321fd3995cb874fb0542b6f51b5525fa96",
        "md5": "99c429f8b2eeb920e5987029202315ad",
        "sha256": "88bdde889e4a5e5eaba4b37351c634cf59b68ab7a82c91761b4ae5e5acda26d2"
      },
      "downloads": -1,
      "filename": "tohil-3.2.0-cp37-cp37m-linux_armv7l.whl",
      "has_sig": false,
      "md5_digest": "99c429f8b2eeb920e5987029202315ad",
      "packagetype": "bdist_wheel",
      "python_version": "cp37",
      "requires_python": ">=3.6, <4",
      "size": 125431,
      "upload_time": "2021-05-20T21:59:57",
      "upload_time_iso_8601": "2021-05-20T21:59:57.772707Z",
      "url": "https://files.pythonhosted.org/packages/8c/5c/c973e540a30c4e98ad824c2ef4321fd3995cb874fb0542b6f51b5525fa96/tohil-3.2.0-cp37-cp37m-linux_armv7l.whl",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}