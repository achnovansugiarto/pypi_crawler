{
  "info": {
    "author": "lojack5",
    "author_email": "",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: BSD License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3 :: Only",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.9",
      "Typing :: Typed"
    ],
    "description": "![tests](https://github.com/lojack5/structured/actions/workflows/tests.yml/badge.svg)\r\n[![License](https://img.shields.io/badge/License-BSD_3--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)\r\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\r\n\r\n\r\n# structured - creating classes which pack and unpack with Python's `struct` module.\r\nThis is a small little library to let you leverage type hints to define classes which can also be packed and unpacked using Python's `struct` module.  The basic usage is almost like a dataclass:\r\n\r\n```python\r\nclass MyClass(Structured):\r\n  file_magic: char[4]\r\n  version: uint8\r\n\r\na = MyClass(b'', 0)\r\n\r\nwith open('some_file.dat', 'rb') as ins:\r\n  a.unpack_read(ins)\r\n```\r\n\r\n# Contents\r\n\r\n1. [Hint Types](#hint-types): For all the types you can use as type-hints.\r\n    - [Basic Types](#basic-types)\r\n    - [Complex Types](#complex-types)\r\n    - [Custom Types](#custom-types)\r\n2. [The `Structured` class](#the-structured-class)\r\n3. [Generics](#generics)\r\n4. [Serializers](#serializers)\r\n\r\n\r\n# Hint Types\r\nIf you just want to use the library, these are the types you use to hint your instance variables to\r\nmake them detected as serialized by the packing/unpacking logic. I'll use the term **serializable**\r\nto mean a hinted type that results in the variable being detected by the `Structured` class as being\r\nhandled for packing and unpacking. They're broken up into two basic\r\ncatergories:\r\n- Basic Types: Those with direct correlation to the `struct` format specifiers, needing no extra\r\n  logic.\r\n- Complex Types: Those still using `struct` for packing and unpacking, but requiring extra logic\r\n  so they do not always have the same format specifier.\r\n- Custom Types: You can use your own custom classes and specify how they should be packed and\r\n  unpacked.\r\n\r\n\r\nAlmost all types use `typing.Annotated` under the hood to just add extra serialization information\r\nto the type they represent. For example `bool8` is defined as\r\n`Annotated[bool8, StructSerializer('?')]`, so type-checkers will properly see it as a `bool`.\r\n\r\nThere are four exceptions to this.  For these types, almost everything should pass inspection by a\r\ntype-checker, except for assignment.  These are:\r\n- `char`: subclassed from `bytes`.\r\n- `pascal`: subclassed from `bytes`.\r\n- `unicode`: subclassed from `str`.\r\n- `array`: subclassed from `list`.\r\n\r\nIf you want to work around this, you can use `typing.Annotated` yourself to appease the\r\ntype-checker:\r\n\r\n```python\r\nclass MyStruct1(Structured):\r\n  name: unicode[100]\r\n\r\nitem = MyStruct('Jane Doe')\r\nitem.name = 'Jessica'   # Type-checker complains about \"str incompatible with unicode\".\r\n\r\nclass MyStruct2(Structured):\r\n  name: Annotated[str, unicode[100]]\r\n\r\nitem = MyStruct('Jane Doe')\r\nitem.name = 'Jessica'   # No complaint from the type-checker.\r\n```\r\n\r\n\r\n## Basic Types\r\nAlmost every format specifier in `struct` is supported as a type:\r\n\r\n| `struct` format | structured type | Python type | Notes |\r\n|:---------------:|:---------------:|-------------|:-----:|\r\n| `x`             | `pad`           |             |(1)(3) |\r\n| `c`             | equivalent to `char[1]` | `bytes` with length 1 | |\r\n| `?`             | `bool8`         | `int`       |       |\r\n| `b`             | `int8`          | `int`       |       |\r\n| `B`             | `uint8`         | `int`       |       |\r\n| `h`             | `int16`         | `int`       |       |\r\n| `H`             | `uint16`        | `int`       |       |\r\n| `i`             | `int32`         | `int`       |       |\r\n| `I`             | `uint32`        | `int`       |       |\r\n| `q`             | `int64`         | `int`       |       |\r\n| `Q`             | `uint64`        | `int`       |       |\r\n| `n`             | not supported   |             |       |\r\n| `N`             | not supported   |             |       |\r\n| `e`             | `float16`       | `float`     |  (2)  |\r\n| `f`             | `float32`       | `float`     |       |\r\n| `d`             | `float64`       | `float`     |       |\r\n| `s`             | `char`          | `bytes`     |  (1)  |\r\n| `p`             | `pascal`        | `bytes`     |  (1)  |\r\n| `P`             | not supported   |             |       |\r\n\r\nNotes:\r\n 1. These type must be indexed to specify their length.  For a single byte `char` for example\r\n    (`'s'`), use `char[1]`.\r\n 2. The 16-bit float type is not supported on all platforms.\r\n 3. Pad variables are skipped and not actually assigned when unpacking, nor used when packing. There\r\n    is a special metaclass hook to allow you to name all of your pad variables `_`, and they still\r\n    **all** count towards the final format specifier.  If you want to be able to override their\r\n    type-hint in subclasses, choose a name other than `_`.\r\n\r\nConsecutive variables with any of these type-hints will be combined into a single `struct` format\r\nspecifier.  Keep in mind that Python's `struct` module may insert extra padding bytes *between*\r\n(but never before or after) format specifiers, depending on the Byte Order specification used.\r\n\r\nExample:\r\n\r\n```python\r\nclass MyStruct(Structured):\r\n  a: int8\r\n  b: int8\r\n  c: uint32\r\n  _: pad[4]\r\n  d: char[10]\r\n  _: pad[2]\r\n  e: uint32\r\n```\r\nIn this example, all of the instance variables are of the \"basic\" type, so the final result will be\r\nas if packing or unpacking with `struct` using a format of `2bI4x10s2xI`.  Note we took advantage of\r\nthe `Structured` metaclass to specify the padding using the same name `_`.\r\n\r\n\r\n### Byte Order\r\nAll of the specifiers are supported, the default it to use no specifier:\r\n| `struct` specifier | `ByteOrder` |\r\n|:------------------:|:-----------:|\r\n| `<`                | `LITTLE_ENDIAN` (or `LE`) |\r\n| `>`                | `BIG_ENDIAN` (or `BE`) |\r\n| `=`                | `NATIVE_STANDARD` |\r\n| `@`                | `NATIVE_NATIVE` |\r\n| `!`                | `NETWORK`   |\r\n\r\nTo specify a byte order, pass `byte_order=ByteOrder.<option>` to the `Structured` sub-classing\r\nmachinery, like so:\r\n\r\n```python\r\nclass MyStruct(Structured, byte_order=ByteOrder.NETWORK):\r\n  a: int8\r\n  b: uint32\r\n```\r\nIn this example, the `NETWORK` (`!`) specifier was used, so `struct` will not insert any padding\r\nbytes between variables `a` and `b`, and multi-byte values will be unpacked as Big Endian numbers.\r\n\r\n\r\n## Complex Types\r\nAll other types fall into the \"complex\" category.  They currently consist of:\r\n- `tuple`: Fixed length tuples of serializable objects.\r\n- `array`: Lists of a single type of serializable object.\r\n- `char`: Although `char[3]` (or any other integer) is considered a basic type, `char` also supports\r\n  variable length strings.\r\n- `unicode`: A wrapper around `char` to add automatic encoding on pack and decoding on unpack.\r\n- `unions`: Unions of serializable types are supported as well.\r\n- `Structured`-derived types: You can use any of your `Structured`-derived classes as a type-hint,\r\n  and the variable will be serialized as well.\r\n\r\n\r\n### Tuples\r\nBoth the `tuple` and `Tuple` type-hints are supported, including `TypeVar`s (see: `Generics`). To be\r\ndetected as serializable, the `tuple` type-hint must be for a fixed sized `tuple` (so no elipses\r\n`...`), and each type-hint in the `tuple` must be a serializable type.\r\n\r\nExample:\r\n```python\r\nclass MyStruct(Structured):\r\n  position: tuple[int8, int8]\r\n  size: tuple[int8, int8]\r\n```\r\n\r\n### Arrays\r\nArrays are `list`s of one kind of serializable type. You do need to specify how `Structured` will\r\ndetermine the *length* of the list when unpacking, and how to write it when packing. To do this,\r\nyou chose a `Header` type. The final type-hint for your list then becomes\r\n`array[<header_type>, <item_type>]`. Arrays also support `TypeVar`s.\r\n\r\nHere are the header types:\r\n- `Header[3]` (or any other positive integer): A fixed length array. No length byte is packed or\r\n  unpacked, just the fixed number of items. When packing, if the list doesn't contain the fixed\r\n  number of elements specified, a `ValueError` is raised.\r\n- `Header[uint32]` (or any other `uint*`-type): An array with the length stored as a `uint32` (or\r\n  other `uint*`-type) just before the items.\r\n- `Header[uint32, uint16]`: An array with two values stored just prior to the items. The first\r\n  value (in this case a `uint32`) is the length of the array. The second value (in this case a\r\n  `uint16`) denotes how many bytes of data the array items takes up. When unpacking, this size is\r\n  checked against how many bytes were actually required to unpack that many items. In the case of a\r\n  mismatch, a `ValueError` will be raises.\r\n\r\nExample:\r\n```python\r\nclass MyItem(Structured):\r\n  name: unicode[100]\r\n  age: uint8\r\n\r\nclass MyStruct(Structured):\r\n  students: array[Header[uint32], MyItem]\r\n```\r\n\r\n\r\n### `char`\r\nFor unpacking bytes other than with a fixed length, you have a few more options with `char`:\r\n- `char[uint8]` (or any other `uint*` type): This indicates that a value (a `uint8` in this case)\r\n  will be packed/unpack just prior to the `bytes`.  The value holds the number of `bytes` to pack or\r\n  unpack.\r\n- `char[b'\\0']` (or any other single bytes): This indicates a terminated byte-string. For\r\n  unpacking, bytes will be read until the terminator is encountered (the terminator will be\r\n  discarded). For packing, the `bytes` will be written, and a terminator will be written at the end\r\n  if not already written.  The usual case for this is NULL-terminated byte-strings, so a quick alias\r\n  for that is provided: `null_char`.\r\n\r\n\r\n### `unicode`\r\nFor cases where you want to read a byte-string and treat it as text, `unicode` will automatically\r\nencode/decode it for you.  The options are the same as for `char`, but with an optional second\r\nargument to specify how to encode/decode it.  The second option can either be a string indicating\r\nthe encoding to use (defaults to `utf8`), or for more complex solutions you may provide an\r\n`EncoderDecoder` class.  Similar to `char`, we provide `null_unicode` as an alias for\r\n`unicode[b'\\0', 'utf8']`.\r\n\r\n```python\r\nclass MyStruct(Structured):\r\n  name: null_unicode\r\n  description: unicode[255, 'ascii']\r\n  bio: unicode[uint32, MyEncoderDecoder]\r\n```\r\n\r\nTo write a custom encoder-decoder, you must subclass from `EncoderDecoder` and implement the two\r\nclass methods `encode` and `decode`:\r\n\r\n```python\r\nclass MyEncoderDecoder(EncoderDecoder):\r\n  @classmethod\r\n  def encode(text: str) -> bytes: ...\r\n\r\n  @classmethod\r\n  def decode(bytestring: bytes) -> str: ...\r\n```\r\n\r\n\r\n### Unions\r\nSometimes, the data structure you're packing/unpacking depends on certain conditions.  Maybe a\r\n`uint8` is used to indicate what follows next.  In cases like this, `Structured` supports unions in\r\nits typehints.  To hint for this, you need to do three things:\r\n1. Every type in your union must be a serializable type.\r\n2. You need create a *decider* which will perform the logic on deciding how to unpack the data.\r\n3. Use `typing.Annotated` to indicate the decider to use for packing/unpacking.\r\n\r\n#### Deciders\r\nAll deciders provide some method to take in information and produce a value to be used to make a\r\ndecision. The decision is made with a \"decision map\", which is a mapping of value to serializable\r\ntypes. You can also provide a default serializable type, or `None` if you want an error to be raised\r\nif your decision method doesn't produce a value in the decision map.\r\n\r\nThere are currently two deciders.  In addition to the decision map and default, you will need to\r\nprovide a few more things for each:\r\n- `LookbackDecider`: You provide a method that accepts the object to be packed/unpacked and produces\r\n  a decision value.  Commonly, `operator.attrgetter` is used here.  A minor detail: for unpacking\r\n  operations, the object sent to your method will not be the actual unpacked object, merely a proxy\r\n  with the values unpacked so far set on it.\r\n- `LookaheadDecider`: For packing, this behaves just like `LookbackDecider`.  For unpacking, you\r\n  need to specify a serializable type which is unpacked first and used as the the value to look up\r\n  in the decision map.  After this first value is unpacked, the data-stream is rewound back for\r\n  unpacking the object.\r\n\r\nHere are a few examples:\r\n```python\r\nclass MyStruct(Structured):\r\n  a_type: uint8\r\n  a: Annotated[uint32 | float32 | char[4], LookbackDecider(attrgetter('a_type'), {0: uint32, 1: float32}, char[4])]\r\n```\r\nThis example first unpacks a `uint8` and stores it in `a_type`. The union `a` polls that value with\r\n`attrgetter`, if the value is 0 it unpacks a `uint32`, if it is 1 it unpacks a `float32`, and if it\r\nis anything else it unpacks just 4 bytes (raw data), storing whatever was unpacked in `a`.\r\n\r\n```python\r\nclass IntRecord(Structured):\r\n  sig: char[4]\r\n  value: int32\r\n\r\nclass FloatRecord(Structured):\r\n  sig: char[4]\r\n  value: float32\r\n\r\nclass MyStruct(Structured):\r\n  record: Annotated[IntRecord | FloatRecord, LookaheadDecider(char[4], attrgetter('record.sig'), {b'IIII': IntRecord, 'FFFF': FloatRecord}, None)]\r\n```\r\nFor unpacking, this example first reads in 4 bytes (`char[4]`), then looks up that value in the\r\ndictionary. If it was `b'IIII'` then it rewinds and unpacks an `IntRecord` (note: `IntRecord`'s\r\n`sig` attribute will be set to `char[4]`). If it was `b'FFFF'` it rewinds and unpacks a\r\n`FloatRecord`, and if was neither it raises an exception.\r\n\r\nFor packing, this example uses `attrgetter('record.sig')` on the object to decide how to pack it.\r\n\r\n\r\n### Structured\r\nYou can also type-hint with one of your `Structured` derived classes, and the value will be unpacked\r\nand packed just as expected.  `Structured` doesn't *fully* support `Generic`s, so make sure to read\r\nthe section on that to see how to hint properly with a `Generic` `Structured` class.\r\n\r\nExample:\r\n```python\r\nclass MyStruct(Structured):\r\n  a: int8\r\n  b: char[100]\r\n\r\nclass MyStruct2(Structured):\r\n  magic: char[4]\r\n  item: MyStruct\r\n```\r\n\r\n\r\n## Custom Types\r\nWhen the above are not enough, and your problem is fairly simple, you can use `SerializeAs` to tell\r\nthe `Structured` class how to pack and unpack your custom type. To do so, you choose one of the\r\nabove \"basic\" types to use as its serialization method, then type-hint with `typing.Annotated` to\r\nprovide that information via a `SerializeAs` object.\r\n\r\nFor example, say you have a class that encapsulates an integer, providing some custom functionality.\r\nYou can tell your `Structured` class how to pack and unpack it. Say the value will be stored as a\r\n4-byte unsigned integer:\r\n\r\n```python\r\nclass MyInt:\r\n  _wrapped: int\r\n\r\n  def __init__(self, value: int) -> None:\r\n    self._wrapped = value\r\n\r\n  def __index__(self) -> int:\r\n    return self._wrapped\r\n\r\nclass MyStruct(Structured):\r\n  version: Annotated[MyInt, SerializeAs(uint32)]\r\n```\r\n\r\nIf you use your type a lot, you can use a `TypeAlias` to make things easier:\r\n\r\n```python\r\nMyInt32: TypeAlias = Annotated[MyInt, SerializeAs(int32)]\r\n\r\nclass MyStruct(Structured):\r\n  version: MyInt32\r\n```\r\n\r\nNote a few things required for this to work as expected:\r\n- Your class needs to accept a single value as its initializer, which is the value unpacked by the\r\n  serializer you specified in `SerializeAs`.\r\n- Your class must be compatible with your chosen type for packing as well.  This means:\r\n  - for integer-like types, it must have an `__index__` method.\r\n  - for float-like types, it must have a `__float__` method.\r\n\r\nFinally, if the `__init__` requirement is too constraining, you can supply a factory method for\r\ncreating your objects from the single unpacked value, and use `SerializeAs.with_factory` instead.\r\nThe factory method must accept the single unpacked value, and return an instance of your type.\r\n\r\n\r\n## The `Structured` class\r\nThe above examples should give you the basics of defining your own `Structured`-derived class, but\r\nthere are a few details and you probably want to know, and *how* to use it to pack and unpack your\r\ndata.\r\n\r\n\r\n### dunders\r\n- `__init__`: By default, `Structured` generates an `__init__` for your class which requires an\r\n  initializer for each of the serializable types in your definition. You can block this generated\r\n  `__init__` by passing `init=False` to the subclassing machinery. Keep in mind, whatever you\r\n  decide the final class's `__init__` must be compatible with being initialized in the original way\r\n  (one value provided for each serializable member). Otherwise your class cannot be used as a\r\n  type-hint or as the item type for `array`.\r\n- `__eq__`: `Structured` instance can be compared for equality / inequality.  Comparison is done by\r\n  comparing each of the instance variables that are serialized.  You can of course override this\r\n  in your subclass to add more checks, and allow `super().__eq__` to handle the serializable types.\r\n- `__str__`: `Structured` provides a nice string representation with the values of all its\r\n  serializable types.\r\n- `__repr__`: The repr is almost identical to `__str__`, just with angled brackets (`<>`).\r\n\r\n### Class variables\r\nThere are three public class variables associated with your class:\r\n- `.serializer`: This is the **serializer** (see: Serializers) used for packing and unpacking the\r\n  instance variables of your class.\r\n- `.byte_order`: This is a `ByteOrder` enum value showing the byte order and alignment option used\r\n  for your class.\r\n- `.attrs`: This is a tuple containing the names of the attributes which are serialized for you, in\r\n  the order they were detected as serializable.  This can be helpful when troubleshooting why your\r\n  class isn't working the way you intended.\r\n\r\n### Packing methods\r\nThere are three ways you might pack the data contained in your class, two should be familiar from\r\nPython's `struct` library:\r\n- `pack() -> bytes`: This just packs your data into a bytestring and returns it.\r\n- `pack_into(buffer, offset = 0) -> None`: This packs your data into an object supporting the\r\n  [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html), starting at the given offset.\r\n- `pack_write(writable) -> None`: This packs your data, writing to the file-like object `writable`\r\n  (which should be open in binary mode).\r\n\r\n\r\n### Unpacking methods\r\nSimilar to packing, there are three methods for unpacking data into an already existing instance of\r\nyour class. There are also three similar class methods for creating a new object from freshly\r\nunpacked data:\r\n- `unpack(buffer) -> None`: Unpacks data from a bytes-like buffer, assigning values to the instance.\r\n- `unpack_from(buffer, offset=0) -> None`: Like `unpack`, but works with an object supporting the\r\n  [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html).\r\n- `unpack_read(readable)`: Reads data from a file-like object (which should be open in binary mode),\r\n  unpacking until all instance variables are unpacked.\r\n- `create_unpack(buffer) -> instance`: Class method that unpacks from a bytes-like buffer to create\r\n  a new instance of your class.\r\n- `create_unpack_from(buffer, offset=0) -> instance`: Class method that unpacks from a buffer\r\n  supporting the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html) to create a new\r\n  instance of your class.\r\n- `create_unpack_read(readable) -> instance`: Class method that reads data from a file-like object\r\n  until enough data has been processed to create a new instance of your class.\r\n\r\n\r\n### Subclassing\r\nSubclassing from your `Structured`-derived class is very straight-forward. New members are inserted\r\nafter previous one in the serialization order. You can redefine the type of a super-class's member\r\nand it will not change the order. For example, you could remove a super-class's serializable member\r\nentirely from serialization, by redefining its type-hint with `None`.\r\n\r\nMultiple inheritance from `Structured` classes is not supported (so no diamonds). By default, your\r\nsub-class must also use the same `ByteOrder` option as its super-class. This is to prevent\r\nunintended serialization errors, so if you really want to change the `ByteOrder`, you can pass\r\n`byte_order_mode=ByteOrderMode.OVERRIDE` to the sub-classing machinery.\r\n\r\n\r\nAn example of using a different byte order than the super-class:\r\n```python\r\nclass MyStructLE(Structured, byte_order=ByteOrder.LE):\r\n  a: int8\r\n  b: int32\r\n\r\nclass MyStructBE(MyStructLE, byte_order=ByteOrder.BE, byte_order_mode=ByteOrderMode.OVERRIDE):\r\n  pass\r\n```\r\n\r\nA simple example of extending:\r\n```python\r\nclass MyStructV1(Structured):\r\n  size: uint32\r\n  a: int8\r\n  b: char[100]\r\n\r\nclass MyStructV2(MyStructV2):\r\n  c: float32\r\n```\r\nHere, the sub-class will pack and unpack equivalent to the `struct` format `'Ib100sf'`.\r\n\r\nA an example of removing a member from serialization:\r\n```python\r\nclass MyStruct(Structured):\r\n  a: int8\r\n  b: uint32\r\n  c: float32\r\n\r\nclass DerivedStruct(MyStruct):\r\n  b: None\r\n```\r\nHere, the sub-class will pack and unpack equivalent to the `struct` format `'bf'`.\r\n\r\n\r\n### Generics\r\n`Structured` classes can be used with `typing.Generic`, and most things will work the way you want\r\nwith an extra step. In order for your specializations to detect the specialized `TypeVar`s, you must\r\nsubclass the specialization. After doing so, you have a concrete class which should serialize as you\r\nexpect.\r\n\r\nHere's an example:\r\n```python\r\nclass MyGeneric(Generic[T], Structured):\r\n  a: int32\r\n  b: T\r\n```\r\nThis generic class is equivalent to the `struct` format `i`, since it hasn't been specialized yet.\r\nTo make a concrete version, subclass:\r\n\r\n```python\r\nclass MyGenericUint32(MyGeneric[uint32]):\r\n  pass\r\n```\r\nThis subclass now is equivalent to the `struct` format `iI`.\r\n\r\nYou can also use `TypeVar`s in `tuple`s, `array`s, `char`s, and `unicode`s, but  similarly you will\r\nhave to sub-class in order to get the concrete implementation of your class.\r\n\r\nNOTE: This means using your generic `Structured` class as the element type of `array` or `tuple`\r\nwon't work as expected unless you first sub-class to make the concrete version of it.\r\n\r\n\r\n## Serializers\r\nFor those more interested in what goes on under the hood, or need more access to implement\r\nserialization of a custom type, read on to learn about what **serializers** are and how they work!\r\n\r\nSerializers are use `typing.Generic` and `typing.TypeVarTuple` in their class heirarchy, so if you\r\nwant to include the types the serializer unpacks this *could* help find errors.  For example:\r\n\r\n```python\r\nclass MySerializer(Serializer[int, int, float]):\r\n  ...\r\n```\r\nwould indicate that this serializer packs and unpacks three items, an `(int, int float)`.\r\n\r\n### The API\r\nThe `Serializer` class exposes a public API very similar to that of `struct.Struct`. All of these\r\nmethods must be implemented (unless noted otherwise) in order to work fully.\r\n\r\n#### Attributes\r\n- `.num_values: int`: In most cases this can just be a class variable, this represents the number of\r\n  items unpacked or packed by the serializer.  For example, a `StructSerializer('2I')` has\r\n  `num_values == 2`.  Note that `array` has `num_values == 1`, since it unpacks a *single* list.\r\n- `.size`: This is similar to `struct.Struct.size`.  It holds the number of bytes required for a\r\n  pack or unpack operation. However unlike `struct.Struct`, the serializer may not know this size\r\n  until the item(s) have been fully packed or unpacked. For this reason, the `.size` attribute is\r\n  only required to be up to date with the most recently completed pack or unpack call.\r\n\r\n#### Packing methods\r\n- `.prepack(self, partial_object) -> Serializer` (**not required**): This will be called just prior\r\n  to any of the pack methods of the `Serializer`, with a (maybe proxy of) the `Structured` object to\r\n  be packed. This is to allow union serializers (for example) to make decisions based on the state\r\n  of the object to be packed.  This method should return an appropriate serializer to be used for\r\n  packing, based on the information contained in `partial_object`.  In most cases, the default\r\n  implementation will do just fine, which just returns itself unchanged.\r\n- `.pack(self, *values) -> bytes`: Pack the values according to this serializer's logic. The number\r\n  of items in `values` must be `.num_values`.  Return the values in packed `bytes` form.\r\n- `.pack_into(self, buffer, offset, *values) -> None`: Pack the values into an object supporting the\r\n  [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html), at the given offset.\r\n- `.pack_write(self, writable, *values) -> None`: Pack the values and write them to the file-like\r\n  object `writable`.\r\n\r\n#### Unpacking methods\r\n- `.preunpack(self, partial_object) -> Serializer` (**not required**): This will be called just\r\n  prior to any of the unpack methods of the `Serializer`, with a (maybe proxy of) the `Structured`\r\n  object to be unpacked. This means the only attributes guaranteed to exist on the object are\r\n  those that were serialized *before* those handled by this serializer. Again, in most cases the\r\n  default implementation should work fine, which just returns itself unchanged.\r\n- `.unpack(self, byteslike) -> Iterable`: Unpack from the bytes-like object, returning the values in\r\n  an iterable. In most cases, just returning the values in a tuple should be fine. Iterables are\r\n  supported so that the partial-proxy objects can have their attributes set more easily during\r\n  unpacking.  Note: the number of values in the iterable must be `.num_values`. NOTE: unlike\r\n  `struct.unpack`, the byteslike object is not required to be the *exact* length needed for\r\n  unpacking, only *at least* as long as required.\r\n- `.unpack_from(self, buffer, offset=0) -> Iterable`: Like `.unpack`, but from an object supporting\r\n  the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html), at the given offset.\r\n- `.unpack_read(self, readable) -> Iterable`: Like `.unpack`, but reading the data from the\r\n  file-like object `readable`.\r\n\r\n#### Other\r\n- `.with_byte_order(self, byte_order: ByteOrder) -> Serializer)`: Return a (possibly new) serializer\r\n  configured to use the `ByteOrder` specified.  The default implementation returns itself unchanged,\r\n  but in most cases this should be overridden with a correct implementation.\r\n- `.__add__(self, other) -> Serailzer` (**not required**): The final serializer used for a\r\n `Structured` class is determined by \"adding\" all of the individual serializers for each attribute\r\n together.  In most cases the default implementation will suffice.  You can provide your own\r\n implementation if optimizations can be made (for example, see `StructSerializer`'s implementation).\r\n\r\n\r\n### The \"building\" Serializers\r\nThere are a few basic serializers used for building others:\r\n- `NullSerializer`: This is a serializer that packs and unpacks nothing. This will be the serializer\r\n  used by a `Structured` class if *no* serializable instance variables are detected. It is also used\r\n  as the starting value to `sum(...)` when generating the final serializer for a `Structured` class.\r\n- `CompoundSerializer`: This is a generic \"chaining\" serializer. Most serializers don't have an\r\n  easy way to combine their logic, so `CompoundSerializer` handles the logic of calling the packing\r\n  and unpacking methods one after another. This is a common serializer to see as the final\r\n  serializer for a `Structured` class. This is also an interesting example to see how to handle\r\n  variable `.size`, and handling `.preunpack` and `.prepack`.\r\n\r\n\r\n### Specific Serializers\r\nThe rest of the Serializer classes are for handling specific serialization types.  They range from\r\nvery simple, to quite complex.\r\n\r\n- `StructSerializer`: For packing/unpacking types which can be directly related to a constant\r\n  `struct` format string.  For example, `uint32` is implemented as\r\n  `Annotated[int, StructSerializer('I')]`.\r\n- `StructActionSerializer`: This is the class used for `StructSerializer`-able custom types, but\r\n  need to perform a custom callable on the result(s) to convert them to their final type.  It is\r\n  almost identical to `StructSerializer`, but calls an `action` on each value unpacked.\r\n- `TupleSerializer`: A fairly simple serializer that handles the `tuple` type-hints.\r\n- `AUnion`: The base for both union serializers.\r\n- `LookbackDecider`: The union serializer which allows for reading attributes already unpacked on\r\n  the object to make a decision.\r\n- `LookaheadDecider`: The union serializer which unpacks a little data then rewinds, using the\r\n  unpacked value to make a decision.\r\n- `StructuredSerializer`: A fairly simple serializer to handle translating the `Structured` class\r\n  methods into the `Serializer` API.\r\n- `DynamicCharSerializer`: The serializer used to handle `char[uint*]` type-hints.\r\n- `TerminatedCharSerializer`: The serializer used to handle `char[b'\\x00']` type-hints.\r\n- `UnicodeSerializer`: A wrapper around one of the `char[]` serializers to handle encoding on\r\n  packing and decoding on unpacking.\r\n\r\n\r\n### Type detection\r\nThis is a very internal-level detail, but may be required if you write your own `Serializer` class.\r\n\r\nAlmost all of the typehints use `typing.Annotated` to specify the `Serializer` instance to use for\r\na hint. In most cases, it's as simple as creating your serializer, then defining a type using this.\r\nSee all of the \"basic\" types for example.  In some more complicated examples, which are configured\r\nvia the `__class_getitem__` method, these return `Annotated` objects with the correct serializer.\r\n\r\nIn any case, the `Structured` class detects the serializers by inspecting the `Annotated` objects\r\nfor serializers.  To support things like `a: Annotated[int, int8]`, it even recursively looks inside\r\nnested `Annotated` objects. For most of this work, `structured` internally uses a singleton object\r\n`structured.type_checking.annotated` to help extract this information. There is a step to perform\r\nextra transformations on these `Annotated` extras, that a new `Serializer` you implement might need\r\nto work.  Check out for example, `TupleSerializer` and `StructuredSerializer` on where that might\r\nbe necessary.\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "BSD 3-Clause",
    "maintainer": "",
    "maintainer_email": "",
    "name": "structured-classes",
    "package_url": "https://pypi.org/project/structured-classes/",
    "platform": null,
    "project_url": "https://pypi.org/project/structured-classes/",
    "project_urls": {
      "Bug Tracker": "https://github.com/lojack5/structured/issues",
      "Homepage": "https://github.com/lojack5/structured"
    },
    "release_url": "https://pypi.org/project/structured-classes/3.0.0/",
    "requires_dist": [
      "typing-extensions (~=4.4.0) ; python_version < \"3.11\""
    ],
    "requires_python": ">=3.9",
    "summary": "Annotated classes that pack and unpack C structures.",
    "version": "3.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16431368,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f96f616481944476921f22d89330963aa6e2bf6fdf5990a9b8daa0febc17fcb7",
          "md5": "162262f1c108bd2e12e20aee65c31319",
          "sha256": "b4bd2a90bf546534eb90f0ad900ad89bd9fcf6e7704354bfc283ad62ac269b76"
        },
        "downloads": -1,
        "filename": "structured_classes-1.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "162262f1c108bd2e12e20aee65c31319",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 11285,
        "upload_time": "2022-08-12T21:43:06",
        "upload_time_iso_8601": "2022-08-12T21:43:06.015037Z",
        "url": "https://files.pythonhosted.org/packages/f9/6f/616481944476921f22d89330963aa6e2bf6fdf5990a9b8daa0febc17fcb7/structured_classes-1.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a8e16238e634ae68694c0a84224433d71f1f6c75ef9ca11c892fc0b412cc212e",
          "md5": "a33a3817569954f208841548130d4629",
          "sha256": "3182f56182994415b8a85124d7746832afcaa4e1b3814cfbfe2c1d01960d7c45"
        },
        "downloads": -1,
        "filename": "structured_classes-1.0.tar.gz",
        "has_sig": false,
        "md5_digest": "a33a3817569954f208841548130d4629",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 13709,
        "upload_time": "2022-08-12T21:43:07",
        "upload_time_iso_8601": "2022-08-12T21:43:07.734663Z",
        "url": "https://files.pythonhosted.org/packages/a8/e1/6238e634ae68694c0a84224433d71f1f6c75ef9ca11c892fc0b412cc212e/structured_classes-1.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d4f2e391c9049142810fdc1560d595b3a67af760e6ca6de73e3c14e83236cd0b",
          "md5": "7e3d886494a3f97524a95f83f5cdf2f9",
          "sha256": "a195fa12ba7678aaa857c206b5e2f7d5a1916ed7ca6844d1d7da6e9e00f9b2a9"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "7e3d886494a3f97524a95f83f5cdf2f9",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 26744,
        "upload_time": "2022-09-07T03:25:25",
        "upload_time_iso_8601": "2022-09-07T03:25:25.581707Z",
        "url": "https://files.pythonhosted.org/packages/d4/f2/e391c9049142810fdc1560d595b3a67af760e6ca6de73e3c14e83236cd0b/structured_classes-2.0-py3-none-any.whl",
        "yanked": true,
        "yanked_reason": "improper packaging"
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "38b7bfafda0a5b4b2f409e4caa23e4f0747722f709aeb8eb40cffa9dd095fe5c",
          "md5": "abc54c3d68c77825028e6aa184eb0dd8",
          "sha256": "7dc44867aac2c4a60ecaafb485bcca5c5c2d9ac63297eb66c51c8b966a462903"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "abc54c3d68c77825028e6aa184eb0dd8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 27797,
        "upload_time": "2022-09-07T03:25:26",
        "upload_time_iso_8601": "2022-09-07T03:25:26.845731Z",
        "url": "https://files.pythonhosted.org/packages/38/b7/bfafda0a5b4b2f409e4caa23e4f0747722f709aeb8eb40cffa9dd095fe5c/structured_classes-2.0.tar.gz",
        "yanked": true,
        "yanked_reason": "improper packaging"
      }
    ],
    "2.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e3fe5476a930b5c80c04569f80f1a1ffe9f45c8a0bad134d06c90c50caa60cfb",
          "md5": "876cb901be7b7c3d06991b986616f5ce",
          "sha256": "726a72f440d4fc1662b6aa2815a9d1f4f229e1a12679b1f5d07b355e7cb7718d"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "876cb901be7b7c3d06991b986616f5ce",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 26942,
        "upload_time": "2022-09-07T03:56:28",
        "upload_time_iso_8601": "2022-09-07T03:56:28.016332Z",
        "url": "https://files.pythonhosted.org/packages/e3/fe/5476a930b5c80c04569f80f1a1ffe9f45c8a0bad134d06c90c50caa60cfb/structured_classes-2.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "dbbb2647ade4cabf94797d1fa0f5b46f7470a48022cd0aacaff87a12956d2fb2",
          "md5": "b42b59309d99bde0b3502b7c7846e3b5",
          "sha256": "08f487a42d0adfd2bdc4a390bb0706a65135bfc007333de19fff90080c86fbd7"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b42b59309d99bde0b3502b7c7846e3b5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 27738,
        "upload_time": "2022-09-07T03:56:29",
        "upload_time_iso_8601": "2022-09-07T03:56:29.570337Z",
        "url": "https://files.pythonhosted.org/packages/db/bb/2647ade4cabf94797d1fa0f5b46f7470a48022cd0aacaff87a12956d2fb2/structured_classes-2.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "acdb7dd6941ce342880a17afbeef9763095c60d82addfe5f8e6598fd56b511ca",
          "md5": "74f215c526572939ece0cad06744938f",
          "sha256": "bf5e057abd4262277c9155df66f28485dead736228e01fd2e5ff0ea4db89bdce"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "74f215c526572939ece0cad06744938f",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 28533,
        "upload_time": "2022-09-16T21:05:34",
        "upload_time_iso_8601": "2022-09-16T21:05:34.395483Z",
        "url": "https://files.pythonhosted.org/packages/ac/db/7dd6941ce342880a17afbeef9763095c60d82addfe5f8e6598fd56b511ca/structured_classes-2.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "641c4cb7cacd5d3fc0604fc27e2970c5d3eb0c4bf31315e9587074839d4e8c2f",
          "md5": "50840176c8c2b70460d0ae550207ef6d",
          "sha256": "e60ca1abea97c5f00448be79161b8822461ab2685f1b1beba38b7ef71225019c"
        },
        "downloads": -1,
        "filename": "structured_classes-2.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "50840176c8c2b70460d0ae550207ef6d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 29453,
        "upload_time": "2022-09-16T21:05:35",
        "upload_time_iso_8601": "2022-09-16T21:05:35.980245Z",
        "url": "https://files.pythonhosted.org/packages/64/1c/4cb7cacd5d3fc0604fc27e2970c5d3eb0c4bf31315e9587074839d4e8c2f/structured_classes-2.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "3.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c416d2aecb3d9e1b251ed789c2bf559d5bfceed881e808d6e2a4d61794d31298",
          "md5": "768dd19eaf0ab9b1df19ed1c2564d290",
          "sha256": "ae9adc15eb348be16fc7ae6cccccbbd5de67c1d07d43d72b48eef0b957c3f044"
        },
        "downloads": -1,
        "filename": "structured_classes-3.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "768dd19eaf0ab9b1df19ed1c2564d290",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.9",
        "size": 44216,
        "upload_time": "2023-01-14T21:43:15",
        "upload_time_iso_8601": "2023-01-14T21:43:15.089749Z",
        "url": "https://files.pythonhosted.org/packages/c4/16/d2aecb3d9e1b251ed789c2bf559d5bfceed881e808d6e2a4d61794d31298/structured_classes-3.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3298968b53b5a668b76f1d0e1f43ea0bf682ab83aca64002c40e823581f2c1df",
          "md5": "afb192edde6994bd94951ecec82bdd22",
          "sha256": "49aa8d4051d683b8e947d41917ede0ec226926712f481fabcd2343f4d16b080f"
        },
        "downloads": -1,
        "filename": "structured_classes-3.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "afb192edde6994bd94951ecec82bdd22",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.9",
        "size": 48104,
        "upload_time": "2023-01-14T21:43:17",
        "upload_time_iso_8601": "2023-01-14T21:43:17.390272Z",
        "url": "https://files.pythonhosted.org/packages/32/98/968b53b5a668b76f1d0e1f43ea0bf682ab83aca64002c40e823581f2c1df/structured_classes-3.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "c416d2aecb3d9e1b251ed789c2bf559d5bfceed881e808d6e2a4d61794d31298",
        "md5": "768dd19eaf0ab9b1df19ed1c2564d290",
        "sha256": "ae9adc15eb348be16fc7ae6cccccbbd5de67c1d07d43d72b48eef0b957c3f044"
      },
      "downloads": -1,
      "filename": "structured_classes-3.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "768dd19eaf0ab9b1df19ed1c2564d290",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.9",
      "size": 44216,
      "upload_time": "2023-01-14T21:43:15",
      "upload_time_iso_8601": "2023-01-14T21:43:15.089749Z",
      "url": "https://files.pythonhosted.org/packages/c4/16/d2aecb3d9e1b251ed789c2bf559d5bfceed881e808d6e2a4d61794d31298/structured_classes-3.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3298968b53b5a668b76f1d0e1f43ea0bf682ab83aca64002c40e823581f2c1df",
        "md5": "afb192edde6994bd94951ecec82bdd22",
        "sha256": "49aa8d4051d683b8e947d41917ede0ec226926712f481fabcd2343f4d16b080f"
      },
      "downloads": -1,
      "filename": "structured_classes-3.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "afb192edde6994bd94951ecec82bdd22",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.9",
      "size": 48104,
      "upload_time": "2023-01-14T21:43:17",
      "upload_time_iso_8601": "2023-01-14T21:43:17.390272Z",
      "url": "https://files.pythonhosted.org/packages/32/98/968b53b5a668b76f1d0e1f43ea0bf682ab83aca64002c40e823581f2c1df/structured_classes-3.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}