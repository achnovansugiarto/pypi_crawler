{
  "info": {
    "author": "A K M Aminul Islam",
    "author_email": "aminul71bd@gmail.com",
    "bugtrack_url": null,
    "classifiers": [],
    "description": "## upmath-2.0.0 (universal precision mathematics)\r\n\r\n**Description:** This python package contains a number class that supports \r\nhigh precision calculation and various number-bases like **2**, **8**, **10**, **16**, \r\n**32** and **64**. Numbers are correct to the precision level (significant digits) set \r\nby the user. Numbers of different bases are equivalent and interconvertible. \r\nConverting a number to a higher base saves memory space and reduces load on network traffic \r\nwhen a number is sent from one machine to another over the computer network.\r\n\r\nBoth the integers and floating point numbers are supported by all the numbers of \r\nmentioned bases. Since these numbers support binary, octal, denary, hexadecimal, base-32 \r\nand base-64 numbers equivalently, that's why, they are called *'universal'* precisional\r\n numbers. \r\n\r\nAll the standard mathematical functions are rewritten to support the high precision\r\ncalculations. Mathematical operators are also redefined accordingly. That's why, this package \r\nis called universal precision mathematics (upmath).\r\n\r\nThe latest package (version 2.0.0) is more faster and efficient.\r\n\r\n### Features of upmath-2.0.0\r\n1. Very fast and accurate calculations upto the set precision\r\n2. Floating point binary, octal, hexadecimal, base32 and base64 numbers are supported\r\n3. Mixed fractional numbers are also supported\r\n4. Supported Math Operators: \r\n```python\r\n   +(add), -(subtract), *(multiply), /(division), //(floor division), %(modulus \r\n   or remainder operation), **(power operation), ~(invertion), ==(equal to),\r\n   !=(not equal to), >(greater than), >=(greater than or equal to), <(less than), \r\n   <(less than or equal to), +(unart positive), -(unary negative), +=(add and assign), \r\n   -=(subtract and assign), *=(multiply and assign), /=(divide and assign), \r\n   //=(floor division and assign), %=(find remainder and assign), **=(find power, \r\n   then assign) \r\n```\r\n5. **Recurring decimals** can be converted to fractions quickly and automatically\r\n6. Mathematical Constants: **E**, **PI**, **INF**, **ZERO**, **ONE** and **UNDEFINED**\r\n7. Common Mathematical Functions: \r\n```python\r\n\t\tfact(n), nCr(n,r), nPr(n,r), ln(x,prec), logE(x,y), lg(x,prec), log10(x,prec), \r\n\t\texp(x,prec), power(x,y,prec), sqrt(x,prec)\r\n```\r\n8. Trigonometric Functions:  \r\n```python\r\n    sin(x,prec), cos(x,prec), tan(x,prec), cot(x,prec), sec(x,prec), csc(x,prec),\r\n    cosec(x,prec), asin(x,prec), acos(x,prec), atan(x,prec), acot(x,prec), asec(x,prec), \r\n\tacsc(x,prec), acosec(x,prec)\r\n```\r\n9. Hyperbolic Functions:  \r\n```python\r\n        sinh(x,prec), cosh(x,prec), tanh(x,prec), coth(x,prec), sech(x,prec),\r\n        csch(x,prec), cosech(x,prec), asinh(x,prec), acosh(x,prec), atanh(x,prec), \r\n\t\tacoth(x,prec), asech(x,prec), acsch(x,prec), acosech(x,prec)\r\n```\r\n10. Other Standard Functions: \r\n```python\r\ngamma(x,prec), beta(x,y,prec), erf(x,prec), erfc(x,prec)```\r\n```\r\n11. Precision calculation of E and PI:\r\n```python\r\ngetE(prec), getPI(prec)\r\n```\r\n12. Numbers of Number Theory: \r\n```python \r\neulerNumber(n), bernoilliNumber(n), tangentNumber(n)\r\n```\r\n13. Methods and properties of upnumber (universal precision number)\r\n```python\r\n>>>\r\n>>> a=lib.Number('11001.101',base=2)\r\n>>> a;print(a)\r\nb10:25.625\r\nb02:11001.101\r\n>>> dir(a)\r\n['_Number__base', '_Number__base10_prec', '_Number__is_accurate', '_Number__is_numeric', \r\n'_Number__max_prec', '_Number__modify', '_Number__normal_prec', '_Number__num', \r\n'_Number__parseddict', '_Number__prec', '_Number__ultra_modify', '__abs__', '__add__', \r\n'__ceil__', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', \r\n'__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', \r\n'__getstate__', '__gt__', '__hash__', '__iadd__', '__ifloordiv__', '__imod__', '__imul__', \r\n'__init__', '__init_subclass__', '__int__', '__invert__', '__ipow__', '__isub__', \r\n'__itruediv__', '__le__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', \r\n'__neg__', '__new__', '__pos__', '__pow__', '__radd__', '__reduce__', '__reduce_ex__', \r\n'__repr__', '__req__', '__rfloordiv__', '__rge__', '__rgt__', '__rle__', '__rlt__', \r\n'__rmod__', '__rmul__', '__rne__', '__round__', '__rpow__', '__rsub__', '__rtruediv__', \r\n'__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', \r\n'__weakref__', 'addBase64Form', 'ceil', 'copy', 'createNewNumber', 'denaryFPtoFRMode', \r\n'displayInFPMode', 'floor', 'forceResetPrecision', 'getAccuracy', 'getBase', \r\n'getBase10Part', 'getBase10Precision', 'getBase10frPart', 'getBase32Form', 'getBase64Form', \r\n'getBinaryForm', 'getDenaryForm', 'getDenominator', 'getDict', 'getExponent', \r\n'getFloatingPart', 'getHexadecimalForm', 'getInputMode', 'getIntegerPart', \r\n'getMaxPrecision', 'getNormalPrecision', 'getNormalizedForm', 'getNormalizedPart', \r\n'getNumerator', 'getOctalForm', 'getOriginal', 'getPrecision', 'getScientificForm', \r\n'getSign', 'isAbs', 'isAccurate', 'isBase32Number', 'isBase64Number', 'isBinary', 'isDenary', \r\n'isFloat', 'isFractional', 'isHexadecimal', 'isInteger', 'isNegative', 'isNumeric', \r\n'isOctal', 'isPositive', 'isPrime', 'isRecurring', 'limitFloatingDigits', 'modify', \r\n'setMaxPrecision', 'toDenaryInteger', 'ultraModify']\r\n>>>\r\n```\r\n---\r\n---\r\n# Examples \r\n### Numeric digits of UPNumber and Random number generation\r\n```python\r\n>>> \r\n>>> import upmath\r\n>>> upmath.version\r\n'2.0.0'\r\n>>> import upmath.lib as lib\r\n>>>\r\n>>> lib.base2digits\r\n('0', '1')\r\n>>> lib.base8digits\r\n('0', '1', '2', '3', '4', '5', '6', '7')\r\n>>> lib.base10digits\r\n('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')\r\n>>> lib.base16digits\r\n('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f')\r\n>>> lib.base32digits\r\n('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', \r\n'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v')\r\n>>> lib.base64digits\r\n('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', \r\n'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', \r\n'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', \r\n'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '!', '@')\r\n>>>\r\n>>> lib.digitIndex('m',base=64)\r\n22\r\n>>> lib.digitChar(22,base=64)\r\n'm'\r\n>>>\r\n>>> print(lib.randomInteger(length=40,base=2))\r\nb02:1011100010110100111001111100100001100001\r\n>>> print(lib.randomInteger(length=40,base=8))\r\nb08:1443453462141027362365304051756402002661\r\n>>> print(lib.randomInteger(length=40,base=10))\r\nb10:4308311625313438552071180617956698018059\r\n>>> print(lib.randomInteger(length=40,base=16))\r\nb16:5bb28ee5df6640da35cc98d47b62d9536f2ac341\r\n>>> print(lib.randomInteger(length=40,base=32))\r\nb32:c82366mes4lpg58klcvoij0nrrihmala55qglqrf\r\n>>> print(lib.randomInteger(length=40,base=64))\r\nb64:fgX3IFNOXzE1c2cSn9Tw5ioIReXncSnueRQbgM4Z\r\n>>>\r\n>>> print(lib.randomFloat(length=50,base=2))\r\nb02:1001011110111.1010001101101111100001111111000110011\r\n>>> print(lib.randomFloat(length=50,base=8))\r\nb08:635245411407012165217532161135752452566051445237.17\r\n>>> print(lib.randomFloat(length=50,base=10))\r\nb10:6555.7875474885111908514201013999991057580008396989\r\n>>> print(lib.randomFloat(length=50,base=16))\r\nb16:6b2ee2921bf8a9b576.b084f6b729bb4339d66479b08cec487d\r\n>>> print(lib.randomFloat(length=50,base=32))\r\nb32:b2k81.87vpfgbr5dsvks06d8lppc5dt28iitnmiiu8lmmh94a1e\r\n>>> print(lib.randomFloat(length=50,base=64))\r\nb64:lstJQpE2LYKkpho!SEwZtH.QlavtOy1DsF85Nyy94DwPffdbCak\r\n>>>\r\n\r\n```\r\n\r\n### Universal precision numbers (lib.Number) are accurate to the given precision. Default precision is 36.\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>>\r\n>>> dir(lib)\r\n['E', 'INF', 'Number', 'ONE', 'PI', 'UND', 'UNDEFINED', 'ZERO', '__builtins__', '__cached__', \r\n'__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '__version__', \r\n'acos', 'acosec', 'acosech', 'acosh', 'acot', 'acoth', 'acsc', 'acsch', 'asec', 'asech', \r\n'asin', 'asinh', 'atan', 'atanh', 'base10digits', 'base16digits', 'base2digits', \r\n'base32digits', 'base64digits', 'base8digits', 'bernoulliNumber', 'beta', 'cos', 'cosec', \r\n'cosech', 'cosh', 'cot', 'coth', 'csc', 'csch', 'dataType', 'digitChar', 'digitIndex', \r\n'digits', 'e', 'erf', 'erfc', 'eulerNumber', 'exp', 'fact', 'gamma', 'getE', 'getPI', \r\n'inv', 'lg', 'ln', 'log10', 'logE', 'mypi', 'nCr', 'nPr', 'pe', 'pi', 'power', 'psmf', \r\n'randomFloat', 'randomInteger', 'randomNumberString', 'randomString', 'sec', 'sech', 'sin', \r\n'sinh', 'sqrt', 'tan', 'tangentNumber', 'tanh', 'upn', 'version']\r\n>>>\r\n>>>\r\n>>> lib.e\r\nb10:2.718281828459045235360287471352662497\r\n>>>\r\n>>> lib.getE(prec=300)\r\nb10:2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457\r\n13821785251664274274663919320030599218174135966290435729003342952605956307381323286279434\r\n90763233829880753195251019011573834187930702154089149934884167509244761460668082264800168\r\n47741185374234544243710753907774499207\r\n>>>\r\n>>> lib.PI\r\nb10:3.141592653589793238462643383279502884\r\n>>>\r\n>>> lib.getPI(prec=300)\r\nb10:3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862\r\n80348253421170679821480865132823066470938446095505822317253594081284811174502841027019385\r\n21105559644622948954930381964428810975665933446128475648233786783165271201909145648566923\r\n46034861045432664821339360726024914127\r\n>>>\r\n>>> a=lib.getE(prec=300)\r\n>>> type(a)\r\n<class 'upmath.src.upnumber.Number'>\r\n>>> a.__sizeof__()\r\n24\r\n>>>\r\n>>> b=lib.getPI(prec=300)\r\n>>> type(b)\r\n<class 'upmath.src.upnumber.Number'>\r\n>>> b.__sizeof__()\r\n24\r\n>>>\r\n**So, an upnumber carrying 300 digits requires only 24B memory space**\r\n```\r\n### Mathematical operations are able to create the numbers correct to the given precision.\r\n```python\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('998001',prec=500)\r\n>>>\r\n>>> lib.inv(a)\r\nb10:0.00000100200300400500600700800901001101201301401501601701801902002102202302402502602\r\n70280290300310320330340350360370380390400410420430440450460470480490500510520530540550560\r\n57058059060061062063064065066067068069070071072073074075076077078079080081082083084085086\r\n08708808909009109209309409509609709809910010110210310410510610710810911011111211311411511\r\n61171181191201211221231241251261271281291301311321331341351361371381391401411421431441451\r\n4614714814915015115215315415515615715815916016116216316416516616\r\n>>>\r\n```\r\n### All numbers are returned and manipulated in **string** format. It can handle integer and floating point numbers of any base from 2,8,10,16,32,64. This package can process any number from ultra small to ultra large level.\r\n```ptthon\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('-1.6e-2020')\r\n>>> b=lib.Number('4.85e+2020')\r\n>>> print(a)\r\nb10:-1.6e-2020\r\n>>> print(b)\r\nb10:4.85e+2020\r\n>>>\r\n>>> a+1\r\nb10:0.9999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\r\n984\r\n>>>\r\n>>> b+1\r\nb10:4850000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n0000000000000000000000000000000000000000000000000000000000000000001\r\n>>>\r\n```\r\n### The central number system is binary and denary. Numbers of bases 8,16,32 and 64 are converted efficiently through binary. Arithmetic and other mathematical operations are performed by denary (base10) operations. \r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('hello.world',64)\r\n>>>\r\n>>> a;print(a)\r\nb10:288970072.505963635630905628204345703125\r\nb64:hello.world\r\n>>>\r\n>>> a.getDenaryForm()\r\n'b10:288970072.505963635630905628204345703125'\r\n>>> \r\n>>> a.getBinaryForm()\r\n'b02:10001001110010101010101011000.100000011000011011010101001101'\r\n>>>\r\n>>> a.getOctalForm()\r\n'b08:2116252530.4030332515'\r\n>>>\r\n>>> a.getHexadecimalForm()\r\n'b16:11395558.8186d534'\r\n>>>\r\n>>> a.getBase32Form()\r\n'b32:8jilao.g63dad'\r\n>>> \r\n```\r\n\r\n---\r\n<!-- table -->\r\n| Base | Number System | Example | Digits |\r\n| --- | --- | --- | --- |\r\n| Base=2 | Binary | b02:-11001.011p600 | 0,1 |\r\n| Base=8 | Octal | b08:-4572.0273p-600 | 0-7 |\r\n| Base=10 | Denary | b10:-9078.0412p40 | 0-9 |\r\n| Base=16 | Hexadecimal | b16:-f04d.32abp70 | 0-9a-fA-F |\r\n| Base=32 | DuoTrigesimal | b32:-vV0o.25f9p+147 | 0-9a-vA-V |\r\n| Base=64 | Base-64 | b64:-zXo0.a4Btp-250 | 0-9a-zA-Z!@ |\r\n\r\n\r\n\r\n### Number input modes:'fp' and 'fr'\r\n    fp' (floating point) mode means numbers with floating digits.\r\n        Like:b02:-11110001.11p-10,b10:92.45e33\r\n    'fr' (fractional) mode which displays number as mixed or proper fraction.\r\n        Like:b02:-11110001 11/100p+17, b10:92 9/20e+23.\r\n    Difference: 'fp' numbers contain '.', but 'fr' numbers have '/'.\r\n\r\n### Valid Input Format:\r\n```pytohn\r\n(fp)11110.101,'11110.101p+34','11110.101p34','11110.101p-23','-0.1101p-45'\r\n(fr) '-1101 11/1101', \"-1101 11/1101p+7\", \"-1101 11/1101p7\", '-1101 11/1101p-17'\r\n```\r\n### Default base is 10. If base is not given in the number definition, it automatically assumes 10.\r\n```python\r\n>>>\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('24 5/7p-5')\r\n>>> a;print(a)\r\nb10:0.0002471428571428571428571428571428571428571\r\nb10:24 5/7e-5\r\n>>>\r\n>>> a+1\r\nb10:1.0002471428571428571428571428571428571428571\r\n>>> a*1\r\nb10:0.0002471428571428571428571428571428571428571\r\n>>> \r\n```\r\n\r\n### UPNumbers are stored internally as a dictionary. For example,\r\n```python\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('15.27')\r\n>>>\r\n>>> a.getDict()\r\n{'base': 10, 'input_mode': 'fp', 'sign': '+', 'ipart': '15', 'fpart': '27', 'exp': 0, \r\n'prec': 4, 'is_accurate': True, 'normalized': {'sign': '+', 'ipart': '15', 'fpart': '27', \r\n'is_accurate': True}, 'is_integer': False, 'is_float': True, 'normal_prec': 4, \r\n'max_prec': 36, 'base10': {'sign': '+', 'ipart': '15', 'fpart': '27', 'is_accurate': True}, \r\n'base10_prec': 36}\r\n>>>\r\n>>>\r\n>>> b=lib.Number('111001.11011',base=2)\r\n>>> b.getDict()\r\n{'base': 2, 'input_mode': 'fp', 'sign': '+', 'ipart': '111001', 'fpart': '11011', 'exp': 0, \r\n'prec': 11, 'is_accurate': True, 'normalized': {'sign': '+', 'ipart': '111001', \r\n'fpart': '11011', 'is_accurate': True}, 'is_integer': False, 'is_float': True, \r\n'normal_prec': 11, 'max_prec': 36, 'base10': {'sign': '+', 'ipart': '57', 'fpart': '84375', \r\n'is_accurate': True}, 'base10_prec': 7}\r\n>>>\r\n>>> c=lib.Number('45 21/33',base=8)\r\n>>> c;print(c)\r\nb10:37.62962962962962962962962962962962768943353750619202951397777635888803465791241364\r\n9683003313839435577392578125\r\nb08:45 21/33\r\n>>> c.getDict()\r\n{'base': 8, 'input_mode': 'fr', 'sign': '+', 'ipart': '45', 'numerator': '21', 'deno': '33', \r\n'exp': 0, 'prec': 6, 'is_accurate': True, 'base10fr': {'sign': '+', 'ipart': '37', \r\n'numerator': '17', 'deno': '27', 'is_accurate': True}, 'max_prec': 38, \r\n'normalized': {'sign': '+', 'ipart': '45', 'fpart': '502275502275502275502275502275502275', \r\n'is_accurate': False}, 'is_integer': False, 'is_float': True, 'normal_prec': 38, \r\n'base10': {'sign': '+', 'ipart': '37', 'fpart': '629629629629629629629629629629627689433537\r\n506192029513977776358888034657912413649683003313839435577392578125', 'is_accurate': False}, \r\n'base10_prec': 110}\r\n>>>\r\n```\r\n\r\n### Builtin Functions: int(), float(), round() on the UPNumber (universal precision number)\r\n```python\r\n>>>\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('111001.11011',base=2)\r\n>>> a;print(a)\r\nb10:57.84375\r\nb02:111001.11011\r\n>>> b=lib.Number('111001',base=2)\r\n>>> b;print(b)\r\nb10:57\r\nb02:111001\r\n>>> int(a)\r\n57\r\n>>> float(b)\r\n57.0\r\n>>> round(a,4)\r\n57.8438\r\n>>> round(a,2)\r\n57.84\r\n>>> round(a,3)\r\n57.844\r\n>>>\r\n```\r\n### math.floor() and math.ceil() functions on UPNumber (universal precision number)\r\n```python\r\n>>>\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('111001.11011',base=2)\r\n>>> b=lib.Number('-25.7124',base=8)\r\n>>> a;print(a)\r\nb10:57.84375\r\nb02:111001.11011\r\n>>> b;print(b)\r\nb10:-21.8955078125\r\nb08:-25.7124\r\n>>>\r\n>>> import math\r\n>>> math.ceil(a)\r\n58\r\n>>> math.floor(a)\r\n57\r\n>>> math.ceil(b)\r\n-21\r\n>>> math.floor(b)\r\n-22\r\n>>>\r\n```\r\n\r\n### If a floating or fractional number is recurring, upnumber can handle it very efficiently just by setting modify or ultraModify argument 'True'. modify() method and ultraModify() method also do the same job. These methods or arguments can also convert the improper fractions to proper fraction with necessary simplifications.\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('245.20451045104510451',modify=True)\r\n>>> print(a)\r\nb10:245 1859/9090\r\n>>> \r\n>>> a=lib.Number('245.20451045104510451')\r\n>>> a\r\nb10:245.20451045104510451\r\n>>> a.modify()\r\n>>> a;print(a)\r\nb10:245.20451045104510451\r\nb10:245 1859/9090\r\n>>>\r\n>>> b=lib.Number('245/37',modify=True)\r\n>>> b;print(b)\r\nb10:6.62162162162162162162162162162162162162\r\nb10:6 23/37\r\n>>>\r\n>>> c=lib.Number('-30 245/35',modify=True)\r\n>>> c;print(c)\r\nb10:-37\r\nb10:-37\r\n>>>\r\n>>> d=lib.Number('-30 245/45',modify=True)\r\n>>> d;print(d)\r\nb10:-35.44444444444444444444444444444444444444\r\nb10:-35 4/9\r\n>>> \r\n```\r\n\r\n## Arithmetic operations\r\n### Addition(+), subtraction(-), multiplication(*), division(/), floor division(//), remainder or mod operation(%), power operation(**) etc. can be done very easily.\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('12.45')     #denary number\r\n>>> b=lib.Number('-2 3/5')    #denary number\r\n>>> c=lib.Number('1101.11',2) #binary number\r\n>>> d=lib.Number('2 3/5',8)   #octal number\r\n>>> a+b\r\nb10:9.85\r\n>>> a+2.45\r\nb10:14.9\r\n>>> 10-a\r\nb10:-2.45\r\n>>> print(5+b)\r\nb10:2 2/5\r\n>>> c*2.5\r\nb10:34.375\r\n>>> 30/a\r\nb10:2.409638554216867469879518072289156626506\r\n>>> a/0\r\nb10:<INF>\r\n>>> b/0\r\nb10:<-INF>\r\n>>> 30//a\r\nb10:2\r\n>>> 30%a\r\nb10:5.1\r\n>>> lib.power(a,2.5)\r\nb10:546.919462835080042646792227676322546\r\n>>> a**2.5\r\nb10:546.919462835080042646792227676322546\r\n>>> 5**a\r\nb10:503705338.789256548289543848618036647\r\n>>> lib.power(b,-2.5)\r\nb10:<UNDEFINED>\r\n>>> b**-2.5\r\nb10:<UNDEFINED>\r\n>>> c**2.5\r\nb10:701.062513233261888120374289325692407\r\n>>> 2.5**c\r\nb10:296261.433052663007815877972404231589\r\n>>> lib.power(c,-2.5)\r\nb10:0.00142640632058338821552976539808037757\r\n>>> c**-2.5\r\nb10:0.00142640632058338821552976539808037757\r\n>>> 2.5**lib.Number('4.5')\r\nb10:61.7632355501636588281033895397015339\r\n>>> 2**lib.Number('-4.5')\r\nb10:0.044194173824159220275052772631553065\r\n>>> \r\n```\r\n\r\n## Logical operations\r\n### Logical operations like equal-to(==), not-equal-to(!=), greater-than(>), less-than(<), greater-than-or-equal-to(>=) and less-than-or-equal-to(<=) can be performed on universal precision number objects as simple as done with the normal numbers. 'True' or 'False' are returned.\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('-2.5')\r\n>>> b=lib.Number('-10.1',2)\r\n>>> c=lib.Number('ab c/d',16)\r\n>>> d=lib.Number('f.10z',64)\r\n>>> \r\n>>> a==b\r\nTrue\r\n>>> a>b\r\nFalse\r\n>>> c<d\r\nFalse\r\n>>> d>b\r\nTrue\r\n>>> a!=b\r\nFalse\r\n>>> c>a\r\nTrue\r\n>>> a>=b\r\nTrue\r\n>>> a<10\r\nTrue\r\n>>> 10>a\r\nTrue\r\n>>> 20>=c\r\nFalse\r\n>>> 20>=d\r\nTrue\r\n>>> \r\n>>> \r\n```\r\n\r\n## In-Place assignment operations\r\n### In-place assignment operations like +=, -=, *=, /=, //=, %= are also supported in this number system.\r\n\r\n<!-- table -->\r\n| operator | operation |\r\n| --- | --- |\r\n| += | Operands are added first, then the result is assigned to the left operand |\r\n| -= | Right Operand is subtracted from the left, then the result is assigned to the left operand |\r\n| *= | Operands are multiplied first, then the result is assigned to the left operand |\r\n| **= | Left operands are raised to the power of the right operand and the value is assigned to the left |\r\n| /= | Left operand is divided by the right one, then the result is assigned to the left operand |\r\n| //= | Left operand is divided by the right one, then the floor value of quotient is assigned to the left operand |\r\n| %= |Left operand is divided by the right one, then the remainder is assigned to the left operand |\r\n\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('-2.5')\r\n>>> b=lib.Number('10.75')\r\n>>> c=lib.Number('13.25',8)\r\n>>> \r\n>>> a+=b\r\n>>> a\r\nb10:8.25\r\n>>> \r\n>>> a-=b\r\n>>> a\r\nb10:-2.5\r\n>>> \r\n>>> a*=c\r\n>>> a\r\nb10:-28.3203125\r\n>>> b/=c\r\n>>> b\r\nb10:0.9489655172413793103448275862068965517\r\n>>> \r\n>>> b=lib.Number('10.75')\r\n>>> c//=b\r\n>>> c\r\nb10:1\r\n>>> c=lib.Number('13.25',8)\r\n>>> c%=b\r\n>>> c\r\nb10:0.578125\r\n>>> \r\n```\r\n\r\n# Standard mathematical operations\r\n### (Logarithmic, exponential, trigonometric, hyperbolic, gamma, beta and error functions are executed efficiently with this upnumber number system)\r\n---\r\n## Inverse, factorial, logarithmic, exponential, square-root and power operations\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('-2.5')\r\n>>> lib.inv(a)\r\nb10:-0.4\r\n>>> b=lib.Number('7')\r\n>>> lib.fact(b)\r\nb10:5040\r\n>>> \r\n>>> lib.ln(a)\r\nb10:<UNDEFINED>\r\n>>> \r\n>>> a=lib.Number('3 4/7')\r\n>>> lib.ln(a)\r\nb10:1.27296567581288744409616592300919555\r\n>>> lib.ln(a,prec=50)\r\nb10:1.2729656758128874440961659230091955494141179789552\r\n>>> \r\n>>> a=lib.Number('-2.5')\r\n>>> b=lib.Number('4.75')\r\n>>> lib.ln(b)        # logE(b)\r\nb10:1.5581446180465498411745631889715004\r\n>>> lib.lg(b)        #log10(b)\r\nb10:0.676693609624866571108855686307943263\r\n>>> \r\n>>> lib.exp(a)       #e^a\r\nb10:0.0820849986238987951695286744671598078\r\n>>> lib.exp(b)       #e^b\r\nb10:115.584284527187658133414267136529079lib.sqrt()\r\n>>> \r\n>>> lib.power(a,b)    #a^b\r\nb10:<UNDEFINED>\r\n>>> lib.power(b,a)    #b^a\r\nb10:0.020336020730908522185680627421418239\r\n>>> \r\n>>> lib=upn.Number('-2 1/2')\r\n>>> b=upn.Number('4 3/4')\r\n>>> lib.sqrt(b)\r\nb10:<UNDEFINED>\r\n>>> lib.sqrt(b)\r\nb10:2.17944947177033677611849099192980783\r\n>>> \r\n>>> lib.power(a,b)\r\nb10:<UNDEFINED>\r\n>>> lib.power(b,a)\r\nb10:0.020336020730908522185680627421418239\r\n>>> \r\n```\r\n\r\n## Trigonometric and inverse trigonometric functions\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('0')\r\n>>> b=lib.Number('390')\r\n>>> c=lib.Number('-405')\r\n>>> d=lib.Number('540')\r\n>>> e=lib.Number('-90')\r\n>>> \r\n>>> lib.sin(a)\r\nb10:0\r\n>>> lib.sin(b)\r\nb10:0.5\r\n>>> lib.sin(c)\r\nb10:-0.707106781186547524400844362104849039\r\n>>> d.sin(d)\r\nb10:0\r\n>>> lib.sin(e)\r\nb10:-1\r\n>>> \r\n>>> lib.tan(a)\r\nb10:0\r\n>>> lib.tan(c)\r\nb10:-1\r\n>>> lib.tan(d)\r\nb10:0\r\n>>> lib.tan(e)\r\nb10:<-INF>\r\n>>> lib.cosec(c)\r\nb10:-1.41421356237309504880168872420969808\r\n>>> lib.sec(d)\r\nb10:-1\r\n>>> lib.cot(e)\r\nb10:0\r\n>>> \r\n>>> a=lib.Number('0')\r\n>>> b=lib.Number('1')\r\n>>> c=lib.Number('-1')\r\n>>> \r\n>>> lib.asin(a)\r\nb10:0\r\n>>> lib.acos(a)\r\nb10:90\r\n>>> \r\n>>> lib.asin(b)\r\nb10:90\r\n>>> lib.acos(b)\r\nb10:0\r\n>>> \r\n>>> lib.acot(b,unit='rad')\r\nb10:0.785398163397448309615660845819875721\r\n>>> lib.acot(b,unit='d')\r\nb10:45\r\n>>> \r\n>>> lib.acot(c)\r\nb10:-45\r\n>>> lib.atan(c)\r\nb10:-45\r\n>>> \r\n```\r\n\r\n## Hyperbolic and inverse hyperbolic functions\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('2')\r\n>>> b=lib.Number('-2')\r\n>>> c=lib.Number('0')\r\n>>> \r\n>>> lib.sinh(a)\r\nb10:3.6268604078470187676682139828012617\r\n>>> lib.cosh(a)\r\nb10:3.76219569108363145956221347777374611\r\n>>> lib.tanh(b)\r\nb10:-0.96402758007581688394641372410092315\r\n>>> c.coth()\r\nb10:0\r\n>>> lib.sech(a)\r\nb10:0.265802228834079692120862739819888972\r\n>>> lib.cosech(b)\r\nb10:-0.275720564771783207758351482163027121\r\n>>> \r\n>>> a=lib.Number('2')\r\n>>> b=lib.Number('0.5')\r\n>>> c=lib.Number('0')\r\n>>> \r\n>>> lib.asinh(a)\r\nb10:1.44363547517881034249327674027310527\r\n>>> lib.acosh(a)\r\nb10:1.31695789692481670862504634730796844\r\n>>> lib.atanh(b)\r\nb10:0.549306144334054845697622618461262852\r\n>>> lib.atanh(c)\r\nb10:0\r\n>>> lib.acoth(a)\r\nb10:0.549306144334054845697622618461262852\r\n>>> lib.asech(b)\r\nb10:1.31695789692481670862504634730796844\r\n>>> lib.acosech(c)\r\nb10:<INF>\r\n>>>\r\n```\r\n\r\n## Gamma, beta and error functions\r\n### (Gamma and beta functions give accurate answers for positive whole numbers and approximate values for floating point numbers.)\r\n\r\n```python\r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('-1')\r\n>>> b=lib.Number('2')\r\n>>> c=lib.Number('0')\r\n>>> \r\n>>> lib.gamma(b)\r\nb10:1\r\n>>> d=lib.Number('2.5')\r\n>>> lib.gamma(d)\r\nb10:1.32934038817913766044178571868836165\r\n>>> lib.beta(b)\r\nb10:0.5\r\n>>> lib.beta(c)\r\nb10:<INF>\r\n>>> \r\n>>> lib.erf(a)\r\nb10:-0.842700792949714869341220635082609259\r\n>>> lib.erfc(a)\r\nb10:1.84270079294971486934122063508260926\r\n>>> lib.erfc(b)\r\nb10:0.00467773498104726583793074363274707222\r\n>>> lib.erf(b)\r\nb10:0.995322265018952734162069256367252928\r\n>>> lib.erf(c)\r\nb10:0\r\n>>> lib.erfc(c)\r\nb10:1\r\n>>> lib.erf(d)\r\nb10:0.999593047982555041060435784260025087\r\n>>> lib.erfc(d)\r\nb10:0.000406952017444958939564215739974912563\r\n>>> \r\n```\r\n\r\n## Euler, Bernoulli and Tangent numbers. \r\n### For odd positive integers, these numbers return zero.\r\n\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> a=lib.Number('2')\r\n>>> b=lib.Number('3')\r\n>>> c=lib.Number('7')\r\n>>> d=lib.Number('8')\r\n>>> e=lib.Number('9')\r\n>>> \r\n>>> lib.eulerNumber(a)\r\nb10:-1\r\n>>> lib.eulerNumber(b)\r\nb10:0\r\n>>> lib.eulerNumber(c)\r\nb10:0\r\n>>> lib.eulerNumber(d)\r\nb10:1385\r\n>>> lib.eulerNumber(e)\r\nb10:0\r\n>>> \r\n>>> lib.bernoulliNumber(a)\r\nb10:1/6\r\n>>> lib.bernoulliNumber(b)\r\nb10:0\r\n>>> lib.bernoulliNumber(c)\r\nb10:0\r\n>>> lib.bernoulliNumber(d)\r\nb10:-1/30\r\n>>> lib.bernoulliNumber(e)\r\nb10:0\r\n>>> \r\n>>> lib.tangentNumber(a)\r\nb10:1\r\n>>> lib.tangentNumber(b)\r\nb10:0\r\n>>> lib.tangentNumber(c)\r\nb10:0\r\n>>> lib.tangentNumber(d)\r\nb10:272\r\n>>> lib.tangentNumber(e)\r\nb10:0\r\n>>> \r\n```\r\n\r\n### UPNumber (universal precision number) is a class instance. PSM functions can take the integer and floating point denary numbers directly.\r\n```python\r\n>>> \r\n>>> import upmath.lib as lib\r\n>>> lib.nCr(10,7)\r\nb10:120\r\n>>> lib.fact(15)\r\nb10:1307674368000\r\n>>> \r\n>>> lib.power(2,10)\r\nb10:1024\r\n>>> \r\n>>> lib.e\r\nb10:2.7182818284590452353602874713526625\r\n>>> lib.E\r\nb10:2.7182818284590452353602874713526625\r\n>>> lib.PI\r\nb10:3.14159265358979323846264338327950288\r\n>>> \r\n```\r\n---\r\n# Public Properties and Methods of upnumber (universal precision number)\r\n#### (prec = precision = number of siginificant digits)\r\n<!-- table -->\r\n| **Property** | **Description** |\r\n| --- | --- |\r\n| __base | private property to hold the base of the upnumber |\r\n| __base10prec | private property to hpld the prec of converted numbers of other bases |\r\n| __is_accurate | private boolean property; True means the number is accurate within the given precision |\r\n| __is_numeric | private boolean property; True means it is a valid upnumber |\r\n| __max_prec | private property to hold the maximum prec value of the set prec and the number's prec |\r\n| __modify | private boolen property; True means the number will be modified during creation by simplification |\r\n| __normal_prec | private property to hold the prec value of the normalized number |\r\n| __num | private property to hold the user's number value |\r\n| __parseddict | private property to hold the **parsed dictionary** of the given upnumber |\r\n| __prec | private property to hold the user's precision to the upnumber |\r\n| __ultra_modify | private boolen property; True means super simplification done during creation of the upnumber |\r\n\r\n---\r\n### Magic Methods of UPNumber (universal precision number)\r\n#### (a,b  = upnumbers; prec = precision = number of siginificant digits)\r\n<!-- table -->\r\n| **Magic Method** | **Arguments** | **Description** |\r\n| --- | --- | --- |\r\n| \\_\\_repr\\_\\_(self) | --- | repr(a) returns the denary equivalent normalized form of the upnumber,a |\r\n| \\_\\_str\\_\\_(self) | --- | str(a) or print(a) returns the string representation of the upnumber,a |\r\n| \\_\\_pos\\_\\_(self) | --- | +a returns positive value of the upnumber,a; if 'a' is negative, negative 'a' returned |\r\n| \\_\\_neg\\_\\_(self) | --- | -a returns negative value of the upnumber,a; if 'a' is negative, positive 'a' returned |\r\n| \\_\\_abs\\_\\_(self) | --- | abs(a) returns positive value of the upnumber, a |\r\n| \\_\\_invert\\_\\_(self) | --- | ~a returns the inverted value (1/a) of the upnumber, a |\r\n| \\_\\_int\\_\\_(self) | --- | int(a) returns the integer value of the upnumber, a |\r\n| \\_\\_float\\_\\_(self) | --- | float(a) returns the floating point value of the upnumber, a |\r\n| \\_\\_round\\_\\_(self,n) | n = positive integer | round(a) returns the rounded value of the upnumber, a at nth decimal point |\r\n| \\_\\_add\\_\\_(self,right) | right | returns an upnumber carrying value of additions like a+10, a+3.5, a+b |\r\n| \\_\\_radd\\_\\_(self,left) | left | returns an upnumber carrying value of additions like 10+a, 3.5+a, b+a |\r\n| \\_\\_sub\\_\\_(self,right) | right | returns an upnumber carrying value of subtractios like a-10, a-3.5, a-b |\r\n| \\_\\_rsub\\_\\_(self,left) | left | returns an upnumber carrying value of subtractions like 10-a, 3.5-a, b-a |\r\n| \\_\\_mul\\_\\_(self,right) | right | returns an upnumber carrying value of multiplications like a\\*10, a\\*3.5, a\\*b |\r\n| \\_\\_rmul\\_\\_(self,left) | left | returns an upnumber carrying value of multiplications like 10\\*a, 3.5\\*a, b\\*a |\r\n| \\_\\_pow\\_\\_(self,right) | right | returns an upnumber carrying value of power operations like a\\*\\*10, a\\*\\*3.5, a**b |\r\n| \\_\\_rpow\\_\\_(self,left) | left | returns an upnumber carrying value of power operations like 10\\*\\*a, 3.5\\*\\*a, b**a |\r\n| \\_\\_truediv\\_\\_(self,right) | right | returns an upnumber carrying value of divisions like a/10, a/3.5, a/b |\r\n| \\_\\_rtruediv\\_\\_(self,left) | left | returns an upnumber carrying value of divisions like 10/a, 3.5/a, b/a |\r\n| \\_\\_floordiv\\_\\_(self,right) | right | returns an upnumber carrying value of floor divisions like a//10, a//3.5, a//b |\r\n| \\_\\_rfloordiv\\_\\_(self,left) | left | returns an upnumber carrying value of floor divisions like 10//a, 3.5//a, b//a |\r\n| \\_\\_mod\\_\\_(self,right) | right | returns an upnumber carrying value of remainder in division like a%10, a%3.5, a%b |\r\n| \\_\\_rmod\\_\\_(self,left) | left | returns an upnumber carrying value of remainder in division like 10%a, 3.5%a, b%a |\r\n| \\_\\_iadd\\_\\_(self,right) | right | returns an upnumber carrying the addition value of the right and the number itself; a+=10, a+=3.5, a+=b |\r\n| \\_\\_isub\\_\\_(self,right) | right | returns an upnumber carrying the subtraction value of the right from the number itself; a-=10, a-=3.5, a-=b |\r\n| \\_\\_imul\\_\\_(self,right) | right | returns an upnumber carrying the multiplication value of the right and the number itself; a*=10, a*=3.5, a*=b |\r\n| \\_\\_itruediv\\_\\_(self,right) | right | returns an upnumber carrying the division value of the right and the number itself; a/=10, a/=3.5, a/=b |\r\n| \\_\\_ifloordiv\\_\\_(self,right) | right | returns an upnumber carrying the floor division value of the right and the number itself; a//=10, a//=3.5, a//=b |\r\n| \\_\\_ipow\\_\\_(self,right) | right | returns an upnumber carrying the value of power operation between the right and the number itself like a**=10, a**=3.5, a**=b |\r\n| \\_\\_imod\\_\\_(self,right) | right | returns an upnumber carrying the remainder value of division between the right and the number itself; a%=10, a%=3.5, a%=b |\r\n| \\_\\_eq\\_\\_(self,right) | right | returns **True** or **False**; True returned when the operands are equal like a==10, a==3.5, a==b |\r\n| \\_\\_req\\_\\_(self,left) | left | returns **True** or **False**; True returned when the operands are equal like 10==a, 3.5==a, b==a |\r\n| \\_\\_ne\\_\\_(self,right) | right | returns**True** or **False**; True returned when the operands are not equal like a!=10, a!=3.5, a!=b |\r\n| \\_\\_rne\\_\\_(self,left) | left | returns **True** or **False**; True returned when the operands are not equal like 10!=a, 3.5!=a, b!=a |\r\n| \\_\\_gt\\_\\_(self,right) | right | returns **True** or **False**; True returned when the upnumber,a is greater than the right operand like a>10, a>3.5, a>b |\r\n| \\_\\_rgt\\_\\_(self,left) | left | returns **True** or **False**; True returned when the left operand is greater than the upnumber,a like 10>a, 3.5>a, b>a |\r\n| \\_\\_lt\\_\\_(self,right) | right | returns **True** or **False**; True returned when the upnumber,a is less than the right operand like a<10, a<3.5, a<b |\r\n| \\_\\_rlt\\_\\_(self,left) | left | returns **True** or **False**; True returned when the left operand is less than the upnumber,a like 10<a, 3.5<a, b<a |\r\n| \\_\\_ge\\_\\_(self,right) | right | returns **True** or **False**; True returned when the upnumber,a is greater than or equal to the right operand like a>=10, a>=3.5, a>=b |\r\n| \\_\\_rge\\_\\_(self,left) | left | returns **True** or **False**; True returned when the left operand is greater than or equal to the upnumber,a like 10>=a, 3.5>=a, b>=a |\r\n| \\_\\_le\\_\\_(self,right) | right | returns **True** or **False**; True returned whenthe upnumber,a is less than or equal to the right operand like a<=10, a<=3.5, a<=b |\r\n| \\_\\_rle\\_\\_(self,left) | left | returns **True** or **False**; True returned when the left operand is less than or equal to the upnumber,a like 10<=a, 3.5<=a, b<=a |\r\n\r\n---\r\n### Instance Methods of UPNumber (universal precision number)\r\n#### (a,b  = upnumbers; calling style: a.method_name(); prec = precision = number of siginificant digits)\r\n<!-- table -->\r\n| **Instance Method** | **Arguments** | **Description** |\r\n| --- | --- | --- |\r\n| ceil(self) | --- | returns the ceiling value (an integer) of the number instance |\r\n| floor(self) | --- | returns the floor value (an integer) of the number instance |\r\n| copy(self) | --- | returns the copy of the number instance |\r\n| modify(self) | --- | modify the given fractional number by simplification |\r\n| ultraModify(self) | --- | modify the given fractional number by as much simplification as possible |\r\n| isAccurate(self) | --- | returns **True** or **False**; True means the number is correct to the digits, displayed |\r\n| isNumeric(self) | --- | returns **True** or **False**; True means the upnumber is not undefined |\r\n| isInteger(self) | --- | returns **True** or **False**; True means the upnumber is an integer |\r\n| isFloat(self) | --- | returns **True** or **False**; True means the upnumber is a floating point number |\r\n| isFractional(self) | --- | returns **True** or **False**; True means the upnumber is a fractional number |\r\n| isRecurring(self) | --- | returns **True** or **False**; True means the upnumber is a recurring denary |\r\n| isPositive(self) | --- | returns **True** or **False**; True means the upnumber is greater than zero |\r\n| isNegative(self) | --- | returns **True** or **False**; True means the upnumber is less than zero |\r\n| isPrime(self) | --- | returns **True** or **False**; True means the upnumber is a prime |\r\n| isBinary(self) | --- | returns **True** or **False**; True means the upnumber is a valid binary number |\r\n| isOctal(self) | --- | returns **True** or **False**; True means the upnumber isa valid octal number |\r\n| isDenary(self) | --- | returns **True** or **False**; True means the upnumber is a valid denary number |\r\n| isHexadecimal(self) | --- | returns **True** or **False**; True means the upnumber is a valid hexadecimal number |\r\n| isBase32Number(self) | --- | returns **True** or **False**; True means the upnumber is a valid base32 number |\r\n| isBase64Number(self) | --- | returns **True** or **False**; True means the upnumber is a valid base64 number |\r\n| getBase(self) | --- | returns the original base of the number |\r\n| getAccuracy(self) | --- | returns **True** or **False**; True means the number is correct to the digits, displayed |\r\n| getSign(self) | --- | returns the sign of the upnumber |\r\n| getBase(self) | --- | returns the base of the upnumber |\r\n| getBase10Part(self) | --- | returns the dictionary with key 'base10' from self.__parseddict |\r\n| getBase10Precision(self) | --- | returns the denary precision (base10_prec) from from self.__parseddict |\r\n| forceResetPrecision(self) | --- | sets number precision forcefully |\r\n| getBase10frPart(self) | --- | returns the dictionary with key 'base10fr' from self.__parseddict |\r\n| displayInFPMode(self) | --- | displays upnumber in floating point mode |\r\n| denaryFPtoFRMode(self) | --- | denary floating point number is converted to fractional form |\r\n| createNewNumber(self,prec,is_accurate) | --- | returns a new upnumber with the given precision and accuracy |\r\n| limitFloatingDigits(self,newprec,is_accurate) | --- | limits the floating digits into the given precision |\r\n| denaryInteger(self) | --- | returns equivalent denary integer |\r\n| setMaxPrecision(self,prec) | --- | sets new maximum precision value of the upnumber |\r\n| getBinaryForm(self) | --- | returns the string version of equivalent binary |\r\n| getOctalForm(self) | --- | returns the string version of equivalent octal |\r\n| getHexadecimalForm(self) | --- | returns the string version of equivalent hexadecimal |\r\n| getBase32Form(self) | --- | returns the string version of equivalent base32 number |\r\n| getBase64Form(self) | --- | returns the string version of equivalent base64 number |\r\n| getDenaryForm(self) | --- | returns the string version of equivalent denary |\r\n| getInputMode(self) | --- | returns the input ('fp','fr') mode of the upnumber |\r\n| getIntegerPart(self) | --- | returns the the integer part of the upnumber |\r\n| getFloatingPart(self) | --- | returns the floating part of the upnumber |\r\n| getNormalizedPart(self) | --- | returns the normalized part of the number dictionary |\r\n| getNumerator(self) | --- | returns the numerator of the fractional upnumber |\r\n| getDenominator(self) | --- | returns the denominator of the fractional upnumber |\r\n| getDict(self) | --- | returns the number dictionary |\r\n| getExponent(self) | --- | returns the exponent part of the number dictionary |\r\n| getNormalizedForm(self) | --- | returns the string representation of the normalized part of the upnumber |\r\n| getScientificForm(self) | --- | returns the scientific form of the upnumber |\r\n| getPrecision(self) | --- | returns the precision of the upnumber set by the user |\r\n| getNormalPrecision(self) | --- | returns the precision of the normalized part of the upnumber |\r\n| getMaxPrecision(self) | --- | returns the maximum precision of the upnumber |\r\n| getOriginal(self) | --- | returns the original upnumber given by the user |\r\n\r\n\r\n---\r\n---\r\n# Precisional Standard Mathematical Functions (PSMF) in Tabular Presentation\r\n### **(Short descriptions of Precisional Standard Math Functions)**\r\n<!-- table -->\r\n| Function | Arguments | Domain and Return |\r\n| --- | --- | --- |\r\n| fact(n) | n=positive integer or zero; | factorial of n |\r\n| nCr(n=None,r=None) | n=positive integer;r=positive integer;n>=r | integer; No of combinations |\r\n| nPr(n=None,r=None) | n=positive integer;r=positive integer;n>=r | integer; No of permutations |\r\n| ln(x=None,prec=36) | x={R:x>=0};prec=positive integer | natural logarithm of x |\r\n| logE(x=None,prec=36) | x={R:x>=0};prec=positive integer | natural logarithm of x |\r\n| lg(x=None,prec=36) | x={R:x>=0};prec=positive integer | 10-based logarithm of x |\r\n| log10(x=None,prec=36) | x={R:x>=0};prec=positive integer | 10-based logarithm of x |\r\n| exp(x=None,prec=36) | x={R};prec=positive integer | exponential of x, e**x |\r\n| sqrt(x=None,prec=36) | x={R:x>=0};prec=positive integer | square root of x (real number) |\r\n| power(x=None,y=None,prec=36) | x=base {R:x>=0};y=power;prec=positive integer | x**y is returned |\r\n| sin(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -1 <=sin(x) <=1 |\r\n| cos(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -1<= cos(x) <=1 |\r\n| tan(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -INF <= tan(x) <= INF |\r\n| cot(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -INF <= cot(x) <= INF |\r\n| sec(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | sec(x)>=1 or sec(x)<=-1 |\r\n| csc(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | cosec(x)>=1 or cosec(x)<=-1 |\r\n| cosec(x=None,unit='d',prec=36) | x=angle{R};unit=unit of angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | cosec(x)>=1 or cosec(x)<=-1 |\r\n| asin(x=None,unit='d',prec=36) | x={R:-1<=x<=1};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=asin(x)<=PI/2 |\r\n| acos(x=None,unit='d',prec=36) | x={R:-1<=x<=1};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=acos(x)<=PI/2 |\r\n| atan(x=None,unit='d',prec=36) | x={R};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=atan(x)<=PI/2 |\r\n| acot(x=None,unit='d',prec=36) | x={R};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=acot(x)<=PI/2 |\r\n| asec(x=None,unit='d',prec=36) | x={R:-1>=x>=1};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | 0<=asec(x)<=PI |\r\n| acosec(x=None,unit='d',prec=36) | x={R:-1>=x>=1};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=acosec(x)<=PI/2 |\r\n| acsc(x=None,unit='d',prec=36) | x={R:-1>=x>=1};unit=unit of output angle ('d','D','deg','Deg','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer | -PI/2<=acosec(x)<=PI/2 |\r\n| sinh(x=None,prec=36) | x={R};prec=positive integer | hyperbolic sin of x is returned;Range:{R} |\r\n| cosh(x=None,prec=36) | x={R};prec=positive integer | hyperbolic cos of x is returned;Range:{R:y>=1} |\r\n| tanh(x=None,prec=36) | x={R};prec=positive integer | hyperbolic tan of x is returned;Range:{R:-1<=f(x)<=1} |\r\n| coth(x=None,prec=36) | x={R};prec=positive integer | hyperbolic cot of x is returned;Range:{R:-1>=f(x)>=1} |\r\n| sech(x=None,prec=36) | x={R};prec=positive integer | hyperbolic sec of x is returned;Range:{R:1>=y>=0} |\r\n| cosech(x=None,prec=36) | x={R:x!=0};prec=positive integer | hyperbolic cosec of x is returned;Range:{R} |\r\n| csch(x=None,prec=36) | x={R:x!=0};prec=positive integer | hyperbolic cosec of x is returned;Range:{R} |\r\n| asinh(x=None,prec=36) | x={R};prec=positive integer | hyperbolic sin inverse of x is returned;Range:{R} |\r\n| acosh(x=None,prec=36) | x={R:x>=1};prec=positive integer | hyperbolic cos inverse of x is returned;Range:{R:y.=0} |\r\n| atanh(x=None,prec=36) | x={R:-1<=x<=1};prec=positive integer | hyperbolic tan inverse of x is returned;Range:{R} |\r\n| acoth(x=None,prec=36) | x={R:-1>=x>=1};prec=positive integer | hyperbolic cot inverse of x is returned;Range:{R} |\r\n| asech(x=None,prec=36) | x={R:1>=x>0};prec=positive integer | hyperbolic sec inverse of x is returned;Range:{R:y>=0} |\r\n| acosech(x=None,prec=36) | x={R:x>0};prec=positive integer | hyperbolic cosec inverse  of x is returned;Range:{R:y>0} |\r\n| acsch(x=None,prec=36) | x={R:x>0};prec=positive integer | hyperbolic cosec inverse  of x is returned;Range:{R:y>0} |\r\n| gamma(x=None,prec=36) | x={R:x>0};prec=positive integer | gamma of x is returned;Range:{R:f(x)>0} |\r\n| beta(x=None,y=None,prec=36) | x={R:x>0};y={R:y>0};prec=positive integer | beta of x and y is returned;Range:{R:1>=f(x)>=0} |\r\n| erf(x=None,prec=36) | x={R};prec=positive integer| | rror-function of x is returned;Range:{R:-1=<f(x)<=1} |\r\n| erfc(x=None,prec=36) | x={R};prec=positive integer | complementary error-function of x is returned;Range:{R:0=<f(x)<=2} |\r\n| eulerNumber(r=None) | r=positive integer | if r is odd, 0(zero) is returned;otherwise integer returned|\r\n| bernoulliNumber(r=None) | r=positive integer | if r is odd, 0(zero) is returned;otherwise fraction is returned |\r\n| tangentNumber(r=None) | r=positive integer | if r is odd, 0(zero) is returned;otherwise integer returned |\r\n\r\n---\r\n## The Author and Maintainer of upmath library\r\n#### For any issue on this library, please feel free to mail me: aminul71bd@gmail.com\r\n![ author's photo ](author_photo_w250.jpg)\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "NEWTONIA FREEWARE LICENSE",
    "maintainer": "A K M Aminul Islam",
    "maintainer_email": "aminul71bd@gmail.com",
    "name": "upmath",
    "package_url": "https://pypi.org/project/upmath/",
    "platform": null,
    "project_url": "https://pypi.org/project/upmath/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/upmath/2.0.0/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "This package creates upnumber (universal precisional number) which can create   flaoting and fractional numbers of bases 2, 8, 10, 16, 32, and 64. That is why, they are   called universal numbers. This number system can create accurate number with any level of   precision set by the user. There are 42 standard math functions for scientific calculations.   So, this package is named as  upmath (universal precision mathematics).",
    "version": "2.0.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16708829,
  "releases": {
    "1.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1a2e65393800f66285f8f220921475197c675c1be2ce6b5095db2049b1b8e6b2",
          "md5": "30d28ba510c80c319298652b4e11b6e9",
          "sha256": "486bd659aee68aaca7d773712769f8c46254daa20b0e7abd80ed958023016c6a"
        },
        "downloads": -1,
        "filename": "upmath-1.0-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "30d28ba510c80c319298652b4e11b6e9",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": null,
        "size": 3421,
        "upload_time": "2020-07-15T08:44:11",
        "upload_time_iso_8601": "2020-07-15T08:44:11.907541Z",
        "url": "https://files.pythonhosted.org/packages/1a/2e/65393800f66285f8f220921475197c675c1be2ce6b5095db2049b1b8e6b2/upmath-1.0-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7f25259d4dfb586ebd8c195a5821e78d461b38058c2c5d5fcfb75b5c1b575432",
          "md5": "b4ebe34a5d677f66782ef512012bec52",
          "sha256": "a0b04a99515476e1820f2452f11c2ca920a0acbf063599e8eb2b81c9af7318f2"
        },
        "downloads": -1,
        "filename": "upmath-1.2-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b4ebe34a5d677f66782ef512012bec52",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": null,
        "size": 59488,
        "upload_time": "2020-07-15T09:57:58",
        "upload_time_iso_8601": "2020-07-15T09:57:58.630779Z",
        "url": "https://files.pythonhosted.org/packages/7f/25/259d4dfb586ebd8c195a5821e78d461b38058c2c5d5fcfb75b5c1b575432/upmath-1.2-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c87bd6b1f3b0f08a7770a8fd2eb24e5f1f550454a8d52e79bd856037f22d862",
          "md5": "83c96ee27cfae7d157e246c0ab1ca675",
          "sha256": "22baa094e6eee2cab1e3b4e05256078e04f2c53dbc93c0fd76bd99154a4a17ad"
        },
        "downloads": -1,
        "filename": "upmath-1.2.tar.gz",
        "has_sig": false,
        "md5_digest": "83c96ee27cfae7d157e246c0ab1ca675",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 63380,
        "upload_time": "2020-07-15T09:58:01",
        "upload_time_iso_8601": "2020-07-15T09:58:01.295559Z",
        "url": "https://files.pythonhosted.org/packages/8c/87/bd6b1f3b0f08a7770a8fd2eb24e5f1f550454a8d52e79bd856037f22d862/upmath-1.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8c059311c65688874cd7dc7043a51c9392651228e09ea1af6edb98ef2c8d0945",
          "md5": "07034d69e422d4f6dc475e3d9edb8ece",
          "sha256": "2320c0b018594727a39f836617c445e02d1cac7b78be8e2fae623e2bc8354be2"
        },
        "downloads": -1,
        "filename": "upmath-1.3-py2.py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "07034d69e422d4f6dc475e3d9edb8ece",
        "packagetype": "bdist_wheel",
        "python_version": "py2.py3",
        "requires_python": null,
        "size": 59485,
        "upload_time": "2020-07-15T10:09:36",
        "upload_time_iso_8601": "2020-07-15T10:09:36.565360Z",
        "url": "https://files.pythonhosted.org/packages/8c/05/9311c65688874cd7dc7043a51c9392651228e09ea1af6edb98ef2c8d0945/upmath-1.3-py2.py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "7df6a46cb680a57c9c4de527a28a7deb0eee35ba785f4c71c238aa48387ec855",
          "md5": "81c52e11b420e2e6da1521888122e98f",
          "sha256": "96785b8f2abceb44d4d2893091616959c88da23d70f9ce6125d41f0c77725b46"
        },
        "downloads": -1,
        "filename": "upmath-1.3.tar.gz",
        "has_sig": false,
        "md5_digest": "81c52e11b420e2e6da1521888122e98f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 63397,
        "upload_time": "2020-07-15T10:09:39",
        "upload_time_iso_8601": "2020-07-15T10:09:39.489105Z",
        "url": "https://files.pythonhosted.org/packages/7d/f6/a46cb680a57c9c4de527a28a7deb0eee35ba785f4c71c238aa48387ec855/upmath-1.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "206fb9ec7570879e9b38c5d062f68baf911407a57a61675308a38f0bdd8050e4",
          "md5": "81648e1779b260b7b87079e38d808c83",
          "sha256": "7d0da9235df39c925df3edd143b5786c207bf8222112691b6490f90bb7366079"
        },
        "downloads": -1,
        "filename": "upmath-2.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "81648e1779b260b7b87079e38d808c83",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": null,
        "size": 72876,
        "upload_time": "2023-02-06T07:33:40",
        "upload_time_iso_8601": "2023-02-06T07:33:40.136968Z",
        "url": "https://files.pythonhosted.org/packages/20/6f/b9ec7570879e9b38c5d062f68baf911407a57a61675308a38f0bdd8050e4/upmath-2.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5b2f9acd746d11c2205a537a0a437b3fdd032315d74a78bb8489816046fd58ec",
          "md5": "0343638adf5df52846fdbf509418ad90",
          "sha256": "b07f8476f8dc42351719dc2ddba7495afefbd25d21f15243ee55c40e798834d2"
        },
        "downloads": -1,
        "filename": "upmath-2.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "0343638adf5df52846fdbf509418ad90",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 129948,
        "upload_time": "2023-02-06T07:33:54",
        "upload_time_iso_8601": "2023-02-06T07:33:54.945948Z",
        "url": "https://files.pythonhosted.org/packages/5b/2f/9acd746d11c2205a537a0a437b3fdd032315d74a78bb8489816046fd58ec/upmath-2.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "206fb9ec7570879e9b38c5d062f68baf911407a57a61675308a38f0bdd8050e4",
        "md5": "81648e1779b260b7b87079e38d808c83",
        "sha256": "7d0da9235df39c925df3edd143b5786c207bf8222112691b6490f90bb7366079"
      },
      "downloads": -1,
      "filename": "upmath-2.0.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "81648e1779b260b7b87079e38d808c83",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": null,
      "size": 72876,
      "upload_time": "2023-02-06T07:33:40",
      "upload_time_iso_8601": "2023-02-06T07:33:40.136968Z",
      "url": "https://files.pythonhosted.org/packages/20/6f/b9ec7570879e9b38c5d062f68baf911407a57a61675308a38f0bdd8050e4/upmath-2.0.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5b2f9acd746d11c2205a537a0a437b3fdd032315d74a78bb8489816046fd58ec",
        "md5": "0343638adf5df52846fdbf509418ad90",
        "sha256": "b07f8476f8dc42351719dc2ddba7495afefbd25d21f15243ee55c40e798834d2"
      },
      "downloads": -1,
      "filename": "upmath-2.0.0.tar.gz",
      "has_sig": false,
      "md5_digest": "0343638adf5df52846fdbf509418ad90",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 129948,
      "upload_time": "2023-02-06T07:33:54",
      "upload_time_iso_8601": "2023-02-06T07:33:54.945948Z",
      "url": "https://files.pythonhosted.org/packages/5b/2f/9acd746d11c2205a537a0a437b3fdd032315d74a78bb8489816046fd58ec/upmath-2.0.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}