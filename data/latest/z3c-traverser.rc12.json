{
  "info": {
    "author": "Zope Foundation and Contributors",
    "author_email": "zope-dev@zope.dev",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 5 - Production/Stable",
      "Environment :: Web Environment",
      "Framework :: Zope :: 3",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Zope Public License",
      "Natural Language :: English",
      "Operating System :: OS Independent",
      "Programming Language :: Python",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.11",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Programming Language :: Python :: Implementation :: CPython",
      "Topic :: Internet :: WWW/HTTP"
    ],
    "description": "This package provides the pluggable traverser mechanism allowing developers\nto add new traversers to an object without altering the original traversal\nimplementation.\n\nIn addition to the pluggable traversers, this package contains two more\nsubpackages:\n\n * viewlet - provides a way to traverse to viewlets using namespaces\n \n * stackinfo - provides a way to consume parts of url and store them\n   as attributes of the \"consumer\" object. Useful for urls like:\n   /blog/2009/02/02/hello-world\n\n\n.. contents::\n\n=======\nCHANGES\n=======\n\n2.0 (2023-02-09)\n----------------\n\n- Drop support for Python 2.7, 3.3, 3.4.\n\n- Add support for Python 3.7, 3.8, 3.9, 3.10, 3.11.\n\n- Drop support to run the tests using ``python setup.py test``.\n\n\n1.0.0 (2015-11-09)\n------------------\n\n- Standardize namespace __init__.\n\n- Claim support for Python 3.4.\n\n\n1.0.0a2 (2013-03-03)\n--------------------\n\n- Added Trove classifiers to specify supported Python versions.\n\n\n1.0.0a1 (2013-03-03)\n--------------------\n\n- Added support for Python 3.3.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n- Switched from ``zope.testbrowser`` to ``WebTest`` for browser testing, since\n  testbrowser is not yet ported.\n\n- Modernized API to use latest packages and component paths.\n\n- Reduced test dependencies to the smallest set possible.\n\n\n0.3.0 (2010-11-01)\n------------------\n\n- Updated test set up to run with ZTK 1.0.\n\n- Using Python's ``doctest`` module instead of depreacted\n  ``zope.testing.doctest[unit]``.\n\n\n0.2.5 (2009-03-13)\n------------------\n\n- Adapt to the move of IDefaultViewName from zope.component to zope.publisher.\n\n0.2.4 (2009-02-02)\n------------------\n\n- Make ``PluggableBrowserTraverser`` implement ``IBrowserPublisher``\n  interface.\n- Fix tests and deprecation warnings.\n- Improve test coverage.\n- Get rid of zope.app.zapi dependency by replacing its uses with direct\n  calls.\n- Change package's mailing list address to zope-dev at zope.org,\n  because zope3-dev at zope.org is now retired.\n- Change \"cheeseshop\" to \"pypi\" in the package's url.\n\n0.2.3 (2008-07-14)\n------------------\n\n- Bugfix: In z3c.traverser.stackinfo the traversal stack got messed up\n  when using the VirtualHost namespace with more than one thread.\n\n0.2.2 (2008-03-06)\n------------------\n\n- Restructuring: Separated pluggable traverser functionality into two classes\n  for better code reuse.\n\n\n0.2.1 (2007-11-92)\n------------------\n\n- Bugfix: if viewlet and managers get nested a viewlet was not found if\n  the depth reaches 3 because the context was set to the page and not\n  to the context object.\n\n- Bugfix: replaced call to ``_getContextName`` because it has been removed\n  from ``absoluteURL``.\n\n\n0.2.0 (2007-10-31)\n------------------\n\n- Update package meta-data.\n\n- Resolve ``ZopeSecurityPolicy`` deprecation warning.\n\n\n0.2.0b2 (2007-10-26)\n--------------------\n\n- Use only ``absolute_url`` adapters in unconsumed URL caclulations, to\n  make it work for traversable viewlets or other special cases too.\n\n\n0.2.0b1 (2007-09-21)\n--------------------\n\n- added a generic stack consumer handler which can be registered for\n  BeforeTraverse events.\n\n\n0.1.3 (2007-06-03)\n------------------\n\n- Added principal namespace, see ``namespace.rst``\n\n- Fire ``BeforeUpdateEvent`` in viewlet view\n\n\n0.1.1 (2007-03-22)\n------------------\n\n- First egg release\n\n\n\n\n====================\nPluggable Traversers\n====================\n\nTraversers are Zope's mechanism to convert URI paths to an object of the\napplication. They provide an extremly flexible mechanism to make decisions\nbased on the policies of the application. Unfortunately the default traverser\nimplementation is not flexible enough to deal with arbitrary extensions (via\nadapters) of objects that also wish to participate in the traversal decision\nprocess.\n\nThe pluggable traverser allows developers, especially third-party developers,\nto add new traversers to an object without altering the original traversal\nimplementation.\n\n    >>> from z3c.traverser.traverser import PluggableTraverser\n\nLet's say that we have an object\n\n    >>> from zope.interface import Interface, implementer\n    >>> class IContent(Interface):\n    ...     pass\n\n    >>> @implementer(IContent)\n    ... class Content(object):\n    ...     var = True\n\n    >>> content = Content()\n\nthat we wish to traverse to. Since traversers are presentation-type specific,\nthey are implemented as views and must thus be initiated using a request:\n\n    >>> from zope.publisher.base import TestRequest\n    >>> request = TestRequest('')\n    >>> traverser = PluggableTraverser(content, request)\n\nWe can now try to lookup the variable:\n\n    >>> traverser.publishTraverse(request, 'var')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'var'\n\nBut it failed. Why? Because we have not registered a plugin traverser yet that\nknows how to lookup attributes. This package provides such a traverser\nalready, so we just have to register it:\n\n    >>> from zope.component import provideSubscriptionAdapter\n    >>> from zope.publisher.interfaces import IPublisherRequest\n    >>> from z3c.traverser.traverser import AttributeTraverserPlugin\n\n    >>> provideSubscriptionAdapter(AttributeTraverserPlugin,\n    ...                            (IContent, IPublisherRequest))\n\nIf we now try to lookup the attribute, we the value:\n\n    >>> traverser.publishTraverse(request, 'var')\n    True\n\nHowever, an incorrect variable name will still return a ``NotFound`` error:\n\n    >>> traverser.publishTraverse(request, 'bad')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'bad'\n\nEvery traverser should also make sure that the passed in name is not a\nview. (This allows us to not specify the ``@@`` in front of a view.) So let's\nregister one:\n\n    >>> class View(object):\n    ...     def __init__(self, context, request):\n    ...         pass\n\n    >>> from zope.component import provideAdapter\n    >>> from zope.publisher.interfaces import IPublisherRequest\n    >>> provideAdapter(View,\n    ...                adapts=(IContent, IPublisherRequest),\n    ...                provides=Interface,\n    ...                name='view.html')\n\nNow we can lookup the view as well:\n\n    >>> traverser.publishTraverse(request, 'view.html')\n    <View object at ...>\n\n\nAdvanced Uses\n-------------\n\nA more interesting case to consider is a traverser for a container. If you\nreally dislike the Zope 3 traversal namespace notation ``++namespace++`` and\nyou can control the names in the container, then the pluggable traverser will\nalso provide a viable solution. Let's say we have a container\n\n    >>> from zope.container.interfaces import IContainer\n    >>> class IMyContainer(IContainer):\n    ...     pass\n\n    >>> from zope.container.btree import BTreeContainer\n    >>> @implementer(IMyContainer)\n    ... class MyContainer(BTreeContainer):\n    ...     foo = True\n    ...     bar = False\n\n    >>> myContainer = MyContainer()\n    >>> myContainer['blah'] = 123\n\nand we would like to be able to traverse\n\n  * all items of the container, as well as\n\n    >>> from z3c.traverser.traverser import ContainerTraverserPlugin\n    >>> from z3c.traverser.interfaces import ITraverserPlugin\n\n    >>> provideSubscriptionAdapter(ContainerTraverserPlugin,\n    ...                            (IMyContainer, IPublisherRequest),\n    ...                            ITraverserPlugin)\n\n  * the ``foo`` attribute. Luckily we also have a predeveloped traverser for\n    this:\n\n    >>> from z3c.traverser.traverser import \\\n    ...     SingleAttributeTraverserPlugin\n    >>> provideSubscriptionAdapter(SingleAttributeTraverserPlugin('foo'),\n    ...                            (IMyContainer, IPublisherRequest))\n\nWe can now use the pluggable traverser\n\n    >>> traverser = PluggableTraverser(myContainer, request)\n\nto look up items\n\n    >>> traverser.publishTraverse(request, 'blah')\n    123\n\nand the ``foo`` attribute:\n\n    >>> traverser.publishTraverse(request, 'foo')\n    True\n\nHowever, we cannot lookup the ``bar`` attribute or any other non-existent\nitem:\n\n    >>> traverser.publishTraverse(request, 'bar')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'bar'\n\n    >>> traverser.publishTraverse(request, 'bad')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'bad'\n\nYou can also add traversers that return an adapted object. For example, let's\ntake the following adapter:\n\n    >>> class ISomeAdapter(Interface):\n    ...     pass\n\n    >>> from zope.component import adapts\n    >>> @implementer(ISomeAdapter)\n    ... class SomeAdapter(object):\n    ...     adapts(IMyContainer)\n    ...\n    ...     def __init__(self, context):\n    ...         pass\n\n    >>> from zope.component import adapts, provideAdapter\n    >>> provideAdapter(SomeAdapter)\n\nNow we register this adapter under the traversal name ``some``:\n\n    >>> from z3c.traverser.traverser import AdapterTraverserPlugin\n    >>> provideSubscriptionAdapter(\n    ...     AdapterTraverserPlugin('some', ISomeAdapter),\n    ...     (IMyContainer, IPublisherRequest))\n\nSo here is the result:\n\n    >>> traverser.publishTraverse(request, 'some')\n    <SomeAdapter object at ...>\n\nIf the object is not adaptable, we'll get NotFound. Let's register a\nplugin that tries to query a named adapter for ISomeAdapter. The third\nargument for AdapterTraverserPlugin is used to specify the adapter name.\n\n    >>> provideSubscriptionAdapter(\n    ...     AdapterTraverserPlugin('badadapter', ISomeAdapter, 'other'),\n    ...     (IMyContainer, IPublisherRequest))\n\n    >>> traverser.publishTraverse(request, 'badadapter')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'badadapter'\n\nTraverser Plugins\n-----------------\n\nThe `traverser` package comes with several default traverser plugins; three of\nthem were already introduced above: `SingleAttributeTraverserPlugin`,\n`AdapterTraverserPlugin`, and `ContainerTraverserPlugin`. Another plugin is\nthe the `NullTraverserPlugin`, which always just returns the object itself:\n\n    >>> from z3c.traverser.traverser import NullTraverserPlugin\n    >>> SomethingPlugin = NullTraverserPlugin('something')\n\n    >>> plugin = SomethingPlugin(content, request)\n    >>> plugin.publishTraverse(request, 'something')\n    <Content object at ...>\n\n    >>> plugin.publishTraverse(request, 'something else')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'something else'\n\nAll of the above traversers with exception of the `ContainerTraverserPlugin`\nare implementation of the abstract `NameTraverserPlugin` class. Name traversers\nare traversers that can resolve one particular name. By using the abstract\n`NameTraverserPlugin` class, all of the traverser boilerplate can be\navoided. Here is a simple example that always returns a specific value for a\ntraversed name:\n\n    >>> from z3c.traverser.traverser import NameTraverserPlugin\n    >>> class TrueTraverserPlugin(NameTraverserPlugin):\n    ...     traversalName = 'true'\n    ...     def _traverse(self, request, name):\n    ...         return True\n\nAs you can see realized name traversers must implement the ``_traverse()``\nmethod, which is only responsible for returning the result. Of course it can\nalso raise the `NotFound` error if something goes wrong during the\ncomputation. LEt's check it out:\n\n    >>> plugin = TrueTraverserPlugin(content, request)\n    >>> plugin.publishTraverse(request, 'true')\n    True\n\n    >>> plugin.publishTraverse(request, 'false')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'false'\n\nA final traverser that is offered by the package is the\n`AttributeTraverserPlugin``, which simply allows one to traverse all\naccessible attributes of an object:\n\n    >>> from z3c.traverser.traverser import AttributeTraverserPlugin\n\n    >>> plugin = AttributeTraverserPlugin(myContainer, request)\n    >>> plugin.publishTraverse(request, 'foo')\n    True\n    >>> plugin.publishTraverse(request, 'bar')\n    False\n    >>> plugin.publishTraverse(request, 'blah')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'blah'\n    >>> plugin.publishTraverse(request, 'some')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'some'\n\n\nBrowser traverser\n-----------------\n\nThere's also a special subclass of the PluggableTraverser that\nimplements the ``IBrowserPublisher`` interface, thus providing the\n``browserDefault`` method that returns a default object and a view\nname to traverse and use if there's no more steps to traverse.\n\nLet's provide a view name registered as an IDefaultView adapter. This\nis usually done by zope.publisher's browser:defaultView directive.\n\n    >>> from zope.publisher.interfaces import IDefaultViewName\n    >>> provideAdapter('view.html', (IContent, Interface), IDefaultViewName)\n\n    >>> from z3c.traverser.browser import PluggableBrowserTraverser\n    >>> traverser = PluggableBrowserTraverser(content, request)\n    >>> traverser.browserDefault(request)\n    (<Content object at 0x...>, ('@@view.html',))\n\n\n=====================\nAdditional Namespaces\n=====================\n\nPrincipal\n---------\n\nThe ``principal`` namespace allows to differentiate between usernames\nin the url. This is usefull for caching on a per principal basis. The\nnamespace itself doesn't change anything. It just checks if the\nprincipal is the one that is logged in.\n\n    >>> from z3c.traverser import namespace\n    >>> from zope.publisher.browser import TestRequest\n    >>> class Request(TestRequest):\n    ...     principal = None\n    ...\n    ...     def shiftNameToApplication(self):\n    ...         pass\n\n    >>> class Principal(object):\n    ...     def __init__(self, id):\n    ...         self.id = id\n\n    >>> pid = 'something'\n    >>> r = Request()\n    >>> r.principal = Principal('anonymous')\n\nIf we have the wrong principal we get an Unauthorized exception.\n\n    >>> ns = namespace.principal(object(), r)\n    >>> ns.traverse('another', None) # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    Unauthorized: ++principal++another\n\nOtherwise not\n\n    >>> ns.traverse('anonymous', None)\n    <object object at ...>\n\n\n===================\nTraversing Viewlets\n===================\n\nThis package allows to traverse viewlets and viewletmanagers. It also\nprovides absolute url views for those objects which are described in\nthis file, for traversers see BROWSER.rst.\n\n  >>> from z3c.traverser.viewlet import browser\n\nLet us define some test classes.\n\n  >>> import zope.component\n  >>> from zope.viewlet import manager\n  >>> from zope.viewlet import interfaces\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> import zope.interface\n  >>> class ILeftColumn(interfaces.IViewletManager):\n  ...     \"\"\"Viewlet manager located in the left column.\"\"\"\n  >>> LeftColumn = manager.ViewletManager('left', ILeftColumn)\n  >>> zope.component.provideAdapter(\n  ...     LeftColumn,\n  ...     (zope.interface.Interface,\n  ...     IDefaultBrowserLayer, zope.interface.Interface),\n  ...     interfaces.IViewletManager, name='left')\n\nYou can then create a viewlet manager using this interface now:\n\n\n  >>> from zope.viewlet import viewlet\n  >>> from zope.container.contained import Contained\n\n  >>> class Content(Contained):\n  ...     pass\n  >>> root['content'] = Content()\n  >>> content = root['content']\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> from zope.publisher.browser import BrowserView\n  >>> class View(BrowserView):\n  ...     pass\n\nWe have to set the name, this is normally done in zcml.\n\n  >>> view = View(content, request)\n  >>> view.__name__ = 'test.html'\n  >>> leftColumn = LeftColumn(content, request, view)\n\nLet us create a simple viewlet. Note that we need a __name__ attribute\nin order to make the viewlet traversable. Normally you don't have to\ntake care of this, because the zcml directive sets the name upon\nregistration.\n\n  >>> class MyViewlet(viewlet.ViewletBase):\n  ...     __name__ = 'myViewlet'\n  ...     def render(self):\n  ...         return u'<div>My Viewlet</div>'\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MyViewlet, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     MyViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, ILeftColumn),\n  ...     interfaces.IViewlet, name='myViewlet')\n\nWe should now be able to get the absolute url of the viewlet and the\nmanager. We have to register the adapter for the test.\n\n  >>> from zope.traversing.browser.interfaces import IAbsoluteURL\n  >>> from zope.traversing.browser import absoluteurl\n\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletAbsoluteURL,\n  ...     (interfaces.IViewlet, IDefaultBrowserLayer),\n  ...     IAbsoluteURL)\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletManagerAbsoluteURL,\n  ...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n  ...     IAbsoluteURL, name=\"absolute_url\")\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletManagerAbsoluteURL,\n  ...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n  ...     IAbsoluteURL)\n  >>> myViewlet = MyViewlet(content, request, view, leftColumn)\n  >>> absoluteurl.absoluteURL(leftColumn, request)\n  'http://127.0.0.1/content/test.html/++manager++left'\n  >>> absoluteurl.absoluteURL(myViewlet, request)\n  '.../content/test.html/++manager++left/++viewlet++myViewlet'\n\n\n\n====================\n Viewlet Traversing\n====================\n\nTraversing to viewlets is done via namespaces.\n\n  >>> from webtest.app import TestApp\n  >>> browser = TestApp(wsgi_app)\n  >>> res = browser.get('http://localhost/@@test.html')\n\nWe have a test page registered that contains our viewlet. The viewlet\nitself just renders a link to its location (this is just for testing).\n\n  >>> print(res.html)\n  <html>\n    <body>\n       <div><div><a\n       href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\">My\n       Viewlet</a></div></div>\n    </body>\n  </html>\n\nLet's follow the link to traverse the viewlet directly.\n\n  >>> res = res.click('My Viewlet')\n  >>> res.request.url\n  'http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet'\n  >>> print(res.body.decode())\n  <div><a href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\">My Viewlet</a></div>\n\nWhat happens if a viewlet managers is nested into another viewlet? To test\nthis we will create another manager and another viewlet::\n\n  >>> res = browser.get('http://localhost/@@nested.html')\n  >>> print(res.html)\n  <html>\n    <body>\n      <div><div><a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\">Most inner viewlet</a></div></div>\n    </body>\n  </html>\n\nLet's follow the link to traverse the viewlet directly.\n\n  >>> res = res.click('Most inner viewlet')\n  >>> res.request.url\n  'http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet'\n\n  >>> print(res.body.decode())\n  <div><a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\">Most inner viewlet</a></div>\n\n\nCaveats\n-------\n\nUpdate of the manager is not called, because this may be too expensive\nand normally the managers update just collects viewlets.\n\n\n===============================================\nExtracting Information from the Traversal Stack\n===============================================\n\nThis package allows to define virtual traversal paths for collecting\narbitrary information from the traversal stack instead of, for\nexample, query strings.\n\nIn contrast to the common way of defining custom Traversers, this\nimplementation does not require to go through the whole traversal\nprocess step by step. The traversal information needed is taken from\nthe traversalstack directly and the used parts of the stack are\nconsumed. This way one don't have to define proxy classes just for\ntraversal.\n\nThis implementation does not work in tales because it requires the\ntraversalstack of the request.\n\nFor each name in the traversal stack a named multiadapter is looked up\nfor ITraversalStackConsumer, if found the item gets removed from the\nstack and the adapter is added to the request annotation.\n\n  >>> from z3c.traverser.stackinfo import traversing\n  >>> from z3c.traverser.stackinfo import interfaces\n\nIf there are no adapters defined, the traversalstack is kept as is. To\nshow this behaviour we define some sample classes.\n\n  >>> from zope import interface\n  >>> class IContent(interface.Interface):\n  ...     pass\n\n  >>> from zope.site.folder import Folder\n  >>> @interface.implementer(IContent)\n  ... class Content(Folder):\n  ...     pass\n\nThere is a convinience function which returns an iterator which\niterates over tuples of adapterName, adapter. Additionally the\ntraversal stack of the request is consumed if needed.\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n  >>> request = TestRequest()\n\nWe set the traversal stack manually for testing here.\n\n  >>> request.setTraversalStack(['index.html', 'path', 'some'])\n  >>> content = Content()\n\nSo if no ITraversalStackConsumer adapters are found the stack is left\nuntouched.\n\n  >>> list(traversing.getStackConsumers(content, request))\n  []\n  >>> request.getTraversalStack()\n  ['index.html', 'path', 'some']\n\nThere is a base class for consumer implementations which implements\nthe ITraversalStackConsumer interface.\n\n  >>> from z3c.traverser.stackinfo import consumer\n  >>> from zope.interface.verify import verifyObject\n  >>> o = consumer.BaseConsumer(None, None)\n  >>> verifyObject(interfaces.ITraversalStackConsumer,o)\n  True\n\nLet us define a custom consumer.\n\n  >>> from zope import component\n  >>> class DummyConsumer(consumer.BaseConsumer):\n  ...     component.adapts(IContent, IBrowserRequest)\n  >>> component.provideAdapter(DummyConsumer, name='some')\n\nNow we will find the newly registered consumer and the 'some' part of\nthe stack is consumed.\n\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [('some', <DummyConsumer named 'some'>)]\n  >>> request.getTraversalStack()\n  ['index.html', 'path']\n\nEach consumer at least has to consume one element, which is always\nthe name under which the adapter was registered under.\n\n  >>> name, cons = consumers[0]\n  >>> cons.__name__\n  'some'\n\nLet us provide another adapter, to demonstrate that the adpaters\nalways have the reverse order of the traversal stack. This is actually\nthe order in the url.\n\n  >>> component.provideAdapter(DummyConsumer, name='other')\n  >>> stack = ['index.html', 'path', 'some', 'other']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [('other', <DummyConsumer named 'other'>),\n   ('some', <DummyConsumer named 'some'>)]\n\n  >>> [c.__name__ for name, c in consumers]\n  ['other', 'some']\n\nThe arguments attribute of the consumer class defines how many\narguments are consumed/needed from the stack. Let us create a KeyValue\nconsumer, that should extract key value pairs from the stack.\n\n  >>> class KeyValueConsumer(DummyConsumer):\n  ...     arguments=('key', 'value')\n  >>> component.provideAdapter(KeyValueConsumer, name='kv')\n  >>> stack = ['index.html', 'value', 'key', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [('kv', <KeyValueConsumer named 'kv'>)]\n  >>> request.getTraversalStack()\n  ['index.html']\n  >>> name, cons = consumers[0]\n  >>> cons.key\n  'key'\n  >>> cons.value\n  'value'\n\nWe can of course use multiple consumers of the same type.\n\n  >>> stack = ['index.html', 'v2', 'k2', 'kv', 'v1', 'k1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> [(c.__name__, c.key, c.value) for name, c in consumers]\n  [('kv', 'k1', 'v1'), ('kv', 'k2', 'v2')]\n\nIf we have too less arguments a NotFound exception.\n\n  >>> stack = ['k2', 'kv', 'v1', 'k1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  Traceback (most recent call last):\n    ...\n  NotFound: Object: <Content object at ...>, name: 'kv'\n\n\nIn order to actually use the stack consumers to retrieve information,\nthere is another convinience function which stores the consumers in\nthe requests annotations. This should noramlly be called on\nBeforeTraverseEvents.\n\n  >>> stack = ['index.html', 'v2', 'k2', 'kv', 'v1', 'k1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(content, request)\n  >>> request.annotations[traversing.CONSUMERS_ANNOTATION_KEY]\n  [<KeyValueConsumer named 'kv'>,\n   <KeyValueConsumer named 'kv'>]\n\nInstead of messing with the annotations one just can adapt the request\nto ITraversalStackInfo.\n\n  >>> component.provideAdapter(consumer.requestTraversalStackInfo)\n  >>> ti = interfaces.ITraversalStackInfo(request)\n  >>> ti\n  (<KeyValueConsumer named 'kv'>, <KeyValueConsumer named 'kv'>)\n\n  >>> len(ti)\n  2\n\nThe adapter always returs an empty TraversalStackInfoObject if there\nis no traversalstack information.\n\n  >>> request = TestRequest()\n  >>> ti = interfaces.ITraversalStackInfo(request)\n  >>> len(ti)\n  0\n\n\nVirtual Host\n------------\n\nIf virtual hosts are used the traversal stack contains aditional information\nfor the virtual host which will interfere which the stack consumer.\n\n  >>> stack = ['index.html', 'value', 'key',\n  ...          'kv', '++', 'inside vh', '++vh++something']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [('kv', <KeyValueConsumer named 'kv'>)]\n  >>> request.getTraversalStack()\n  ['index.html', '++', 'inside vh', '++vh++something']\n\n\nURL Handling\n------------\n\nLet us try these things with a real url, in our test the root is the site.\n\n  >>> from zope.traversing.browser.absoluteurl import absoluteURL\n  >>> absoluteURL(root, request)\n  'http://127.0.0.1'\n\nThere is an unconsumedURL function which returns the url of an object\nwith the traversal information, which is normally omitted.\n\n  >>> request = TestRequest()\n  >>> root['content'] = content\n  >>> absoluteURL(root['content'], request)\n  'http://127.0.0.1/content'\n  >>> stack = ['index.html', 'v2 space', 'k2', 'kv', 'v1', 'k1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/k1/v1/kv/k2/v2%20space'\n\nLet us have more than one content object\n\n  >>> under = content['under'] = Content()\n  >>> request = TestRequest()\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/under'\n\nWe add some consumers to the above object\n\n  >>> request = TestRequest()\n  >>> stack = ['index.html', 'value1', 'key1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/key1/value1'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/kv/key1/value1/under'\n\nAnd now to the object below too.\n\n  >>> request = TestRequest()\n  >>> stack = ['index.html', 'value1', 'key1', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> stack = ['index.html', 'value2', 'key2', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(under, request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/key1/value1'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/kv/key1/value1/under/kv/key2/value2'\n\nOr only the object below.\n\n  >>> request = TestRequest()\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> stack = ['index.html', 'value2', 'key2', 'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(under, request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\nThe unconsumedURL function is also available as a view, named\n``unconsumed_url``, similar to ``absolute_url`` one.\n\n  >>> from zope.component import getMultiAdapter\n  >>> url = getMultiAdapter((under, request), name='unconsumed_url')\n\n  >>> str(url)\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\n  >>> url()\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\n\n===============================================\nExtracting Information from the Traversal Stack\n===============================================\n\nThis is a simple example to demonstrate the usage of this\npackage. Please take a look into the testing directory to see how\nthings should be set up.\n\n  >>> from webtest.app import TestApp\n  >>> browser = TestApp(wsgi_app,\n  ...     extra_environ={'wsgi.handleErrors': False,\n  ...                    'paste.throw_errors': True,\n  ...                    'x-wsgiorg.throw_errors': True})\n  >>> res = browser.get('http://localhost/@@stackinfo.html')\n\nSo basically we have no stack info.\n\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n\nLet us try to set foo to bar.\n\n  >>> res = browser.get('http://localhost/kv/foo/bar/@@stackinfo.html')\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n  consumer kv:\n  key = 'foo'\n  value = 'bar'\n\nTwo consumers.\n\n  >>> res = browser.get(\n  ...     'http://localhost/kv/foo/bar/kv/time/late/@@stackinfo.html')\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n  consumer kv:\n  key = 'foo'\n  value = 'bar'\n  consumer kv:\n  key = 'time'\n  value = 'late'\n\nInvalid url:\n\n  >>> browser.get('http://localhost/kv/foo/bar/kv/@@stackinfo.html') \\\n  ...     # doctes: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: <...Folder object at ...>, name: 'kv'\n\n\n",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/zopefoundation/z3c.traverser",
    "keywords": "zope3 traverser pluggable plugin viewlet",
    "license": "ZPL 2.1",
    "maintainer": "",
    "maintainer_email": "",
    "name": "z3c.traverser",
    "package_url": "https://pypi.org/project/z3c.traverser/",
    "platform": null,
    "project_url": "https://pypi.org/project/z3c.traverser/",
    "project_urls": {
      "Homepage": "https://github.com/zopefoundation/z3c.traverser"
    },
    "release_url": "https://pypi.org/project/z3c.traverser/2.0/",
    "requires_dist": [
      "setuptools",
      "zope.component",
      "zope.contentprovider",
      "zope.interface",
      "zope.publisher",
      "zope.traversing",
      "zope.viewlet",
      "zope.testrunner",
      "WebTest ; extra == 'test'",
      "zope.app.appsetup ; extra == 'test'",
      "zope.app.publication ; extra == 'test'",
      "zope.app.wsgi (>=4.0.0a4) ; extra == 'test'",
      "zope.authentication ; extra == 'test'",
      "zope.browserpage ; extra == 'test'",
      "zope.container ; extra == 'test'",
      "zope.error ; extra == 'test'",
      "zope.principalregistry ; extra == 'test'",
      "zope.security ; extra == 'test'",
      "zope.site ; extra == 'test'",
      "zope.testbrowser ; extra == 'test'",
      "zope.testing ; extra == 'test'",
      "zope.testrunner (>=4.3.1) ; extra == 'test'"
    ],
    "requires_python": ">=3.7",
    "summary": "Pluggable Traversers And URL handling utilities",
    "version": "2.0",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16767001,
  "releases": {
    "0.1.1-r74198": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3855a40bae8d2c2620900b908b1c92a5f94188bc1e404cd1708aaf4b67dbba94",
          "md5": "24c488e0739c227574b9d7daab369d47",
          "sha256": "2d88655f3c590fe4843315432d36c89febc9d58376668b4df3a4610f5aa153cf"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.1.1-r74198.tar.gz",
        "has_sig": false,
        "md5_digest": "24c488e0739c227574b9d7daab369d47",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 14605,
        "upload_time": "2007-04-18T06:44:08",
        "upload_time_iso_8601": "2007-04-18T06:44:08Z",
        "url": "https://files.pythonhosted.org/packages/38/55/a40bae8d2c2620900b908b1c92a5f94188bc1e404cd1708aaf4b67dbba94/z3c.traverser-0.1.1-r74198.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "87abf5e11d6a3b887fc25bdceef6fefe5bc4ceb6361bb14ede12fa38292be251",
          "md5": "bec6a794ab527a726f0f430e465bdce3",
          "sha256": "c07838893cfbfcdea8c7360793178f00691baf6d0becb8a5720e6babad7821b6"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "bec6a794ab527a726f0f430e465bdce3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 27630,
        "upload_time": "2007-11-01T09:12:52",
        "upload_time_iso_8601": "2007-11-01T09:12:52Z",
        "url": "https://files.pythonhosted.org/packages/87/ab/f5e11d6a3b887fc25bdceef6fefe5bc4ceb6361bb14ede12fa38292be251/z3c.traverser-0.2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f8ac2a350dfd21612cdcdcb56b9b0fdaef3220c0dc52d0cf1ea13948f294baa4",
          "md5": "b20985c73b99b17bf710aa96b16c0a2b",
          "sha256": "dccfe1c7691f52262e132d64d31836157bdf6dd56652753f6cdd1db91a81d863"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.1.tar.gz",
        "has_sig": false,
        "md5_digest": "b20985c73b99b17bf710aa96b16c0a2b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 31355,
        "upload_time": "2007-11-29T14:34:59",
        "upload_time_iso_8601": "2007-11-29T14:34:59Z",
        "url": "https://files.pythonhosted.org/packages/f8/ac/2a350dfd21612cdcdcb56b9b0fdaef3220c0dc52d0cf1ea13948f294baa4/z3c.traverser-0.2.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1027c333ba4f51132b4ec0412e681356ec110200d6698fe0bdf3def49ff1016f",
          "md5": "614185659b20c120b3a1f5e5754b5911",
          "sha256": "3be3b24f123a5ab67e975e6e988f3f0c9ed2672b25f3b151f74310c929f817f9"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.2.tar.gz",
        "has_sig": false,
        "md5_digest": "614185659b20c120b3a1f5e5754b5911",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 29413,
        "upload_time": "2008-03-06T07:49:27",
        "upload_time_iso_8601": "2008-03-06T07:49:27Z",
        "url": "https://files.pythonhosted.org/packages/10/27/c333ba4f51132b4ec0412e681356ec110200d6698fe0bdf3def49ff1016f/z3c.traverser-0.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "868fd501c96ed8bef1b57299870c0bebafc42ac8272a3abf4e2c3408e3240d07",
          "md5": "63dbf1f3fae95101ad6b0fbb290fa6f3",
          "sha256": "0195a1cdb8ebab5f0da3ebc180ddb5568935de695769d9af2e5cecfe06318b5d"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.3.tar.gz",
        "has_sig": false,
        "md5_digest": "63dbf1f3fae95101ad6b0fbb290fa6f3",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 31847,
        "upload_time": "2008-07-14T08:47:37",
        "upload_time_iso_8601": "2008-07-14T08:47:37Z",
        "url": "https://files.pythonhosted.org/packages/86/8f/d501c96ed8bef1b57299870c0bebafc42ac8272a3abf4e2c3408e3240d07/z3c.traverser-0.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "8b07304f5887e3d2c63a6f009705c991dfaf4029ee919608c2f1ee536acbaf20",
          "md5": "f4fc9647bc39858686f059a13d4c2cf8",
          "sha256": "ceb4ca28ab365f75a316befb5f09833aa44d85b05028c996bda23c1d420c81f3"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.4.tar.gz",
        "has_sig": false,
        "md5_digest": "f4fc9647bc39858686f059a13d4c2cf8",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 33137,
        "upload_time": "2009-02-02T15:46:45",
        "upload_time_iso_8601": "2009-02-02T15:46:45Z",
        "url": "https://files.pythonhosted.org/packages/8b/07/304f5887e3d2c63a6f009705c991dfaf4029ee919608c2f1ee536acbaf20/z3c.traverser-0.2.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.2.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "984135cd96bddabd1d26ac87f6179632a4758198b6072c765709c308618b6ab5",
          "md5": "73a63c0171a509ccd5c8e64cff29ff9d",
          "sha256": "5df6882c7b163e4b251d3305412bcbbd7085d8d612f07dc990f536ef3d66179b"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.2.5.tar.gz",
        "has_sig": false,
        "md5_digest": "73a63c0171a509ccd5c8e64cff29ff9d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 33189,
        "upload_time": "2009-03-13T07:58:36",
        "upload_time_iso_8601": "2009-03-13T07:58:36.851905Z",
        "url": "https://files.pythonhosted.org/packages/98/41/35cd96bddabd1d26ac87f6179632a4758198b6072c765709c308618b6ab5/z3c.traverser-0.2.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c9e0fa53f7a545abcb6ee74b59632012460fc0c4152af4ebb4ca41e41e6b7354",
          "md5": "095381a8de6ad4547b98fecb929e3885",
          "sha256": "51fb7fb07d6791d2fc20eb77803b6171b9e282870956f33d2934a8dd747c4653"
        },
        "downloads": -1,
        "filename": "z3c.traverser-0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "095381a8de6ad4547b98fecb929e3885",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 33707,
        "upload_time": "2010-11-01T08:26:49",
        "upload_time_iso_8601": "2010-11-01T08:26:49.591949Z",
        "url": "https://files.pythonhosted.org/packages/c9/e0/fa53f7a545abcb6ee74b59632012460fc0c4152af4ebb4ca41e41e6b7354/z3c.traverser-0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9a5d2a571de911eed0786389fbd9c75d35930e907b08e5e82b98b6be4728fb6a",
          "md5": "3a6f0b07a1dbc12c6763707f2ad1e762",
          "sha256": "445bda7eb89f2359ca6d9d1315ec51169a1923e106e89d65a9674880e0998657"
        },
        "downloads": -1,
        "filename": "z3c.traverser-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "3a6f0b07a1dbc12c6763707f2ad1e762",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 37239,
        "upload_time": "2015-11-09T14:13:45",
        "upload_time_iso_8601": "2015-11-09T14:13:45.822432Z",
        "url": "https://files.pythonhosted.org/packages/9a/5d/2a571de911eed0786389fbd9c75d35930e907b08e5e82b98b6be4728fb6a/z3c.traverser-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0a1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5f25507a44d804965bac1526d6bd148c069adba160445fe478839d0823311da8",
          "md5": "fb2e7c31d0bca5bd11ddbe694357ae77",
          "sha256": "a82f194d743a3ca66b6268e8c02bc460853cd832a4c069f40408f7c0a62624d0"
        },
        "downloads": -1,
        "filename": "z3c.traverser-1.0.0a1.zip",
        "has_sig": false,
        "md5_digest": "fb2e7c31d0bca5bd11ddbe694357ae77",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 58465,
        "upload_time": "2013-03-03T10:15:22",
        "upload_time_iso_8601": "2013-03-03T10:15:22.756181Z",
        "url": "https://files.pythonhosted.org/packages/5f/25/507a44d804965bac1526d6bd148c069adba160445fe478839d0823311da8/z3c.traverser-1.0.0a1.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.0a2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "fa505fd7416603d603858c9011c19ff0c93808249e971724f03b3e6e33cbf39c",
          "md5": "413a6209ae299351ac7368d4fc6ff320",
          "sha256": "051f1bf54bbe7a34f51994274748071667661b9a97659647ae4d32fee211f7b1"
        },
        "downloads": -1,
        "filename": "z3c.traverser-1.0.0a2.zip",
        "has_sig": false,
        "md5_digest": "413a6209ae299351ac7368d4fc6ff320",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 58662,
        "upload_time": "2013-03-03T14:45:33",
        "upload_time_iso_8601": "2013-03-03T14:45:33.723812Z",
        "url": "https://files.pythonhosted.org/packages/fa/50/5fd7416603d603858c9011c19ff0c93808249e971724f03b3e6e33cbf39c/z3c.traverser-1.0.0a2.zip",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "2.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ebafc61c7edd5169ad42884cf9ec0b0d0507612151695a1e1d229c76137bc6e4",
          "md5": "750b68f49287ee200def101d850ba48b",
          "sha256": "990348bbdf948a502211a7f217e021d16b856f9ad4c8586bc9feddc947a52960"
        },
        "downloads": -1,
        "filename": "z3c.traverser-2.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "750b68f49287ee200def101d850ba48b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.7",
        "size": 40287,
        "upload_time": "2023-02-09T11:10:56",
        "upload_time_iso_8601": "2023-02-09T11:10:56.923474Z",
        "url": "https://files.pythonhosted.org/packages/eb/af/c61c7edd5169ad42884cf9ec0b0d0507612151695a1e1d229c76137bc6e4/z3c.traverser-2.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "48059aff783cfe80678ee8c736b0438c689ac90f2c7e0ba588667db30a95b10d",
          "md5": "5a22aaa10d8268699d04cd702f6204a6",
          "sha256": "1ef5a0ee392ccb8c5da199a7cc0a5bacf7624bd04606afe354742f0659722809"
        },
        "downloads": -1,
        "filename": "z3c.traverser-2.0.tar.gz",
        "has_sig": false,
        "md5_digest": "5a22aaa10d8268699d04cd702f6204a6",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 36654,
        "upload_time": "2023-02-09T11:10:59",
        "upload_time_iso_8601": "2023-02-09T11:10:59.483298Z",
        "url": "https://files.pythonhosted.org/packages/48/05/9aff783cfe80678ee8c736b0438c689ac90f2c7e0ba588667db30a95b10d/z3c.traverser-2.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "ebafc61c7edd5169ad42884cf9ec0b0d0507612151695a1e1d229c76137bc6e4",
        "md5": "750b68f49287ee200def101d850ba48b",
        "sha256": "990348bbdf948a502211a7f217e021d16b856f9ad4c8586bc9feddc947a52960"
      },
      "downloads": -1,
      "filename": "z3c.traverser-2.0-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "750b68f49287ee200def101d850ba48b",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.7",
      "size": 40287,
      "upload_time": "2023-02-09T11:10:56",
      "upload_time_iso_8601": "2023-02-09T11:10:56.923474Z",
      "url": "https://files.pythonhosted.org/packages/eb/af/c61c7edd5169ad42884cf9ec0b0d0507612151695a1e1d229c76137bc6e4/z3c.traverser-2.0-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "48059aff783cfe80678ee8c736b0438c689ac90f2c7e0ba588667db30a95b10d",
        "md5": "5a22aaa10d8268699d04cd702f6204a6",
        "sha256": "1ef5a0ee392ccb8c5da199a7cc0a5bacf7624bd04606afe354742f0659722809"
      },
      "downloads": -1,
      "filename": "z3c.traverser-2.0.tar.gz",
      "has_sig": false,
      "md5_digest": "5a22aaa10d8268699d04cd702f6204a6",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 36654,
      "upload_time": "2023-02-09T11:10:59",
      "upload_time_iso_8601": "2023-02-09T11:10:59.483298Z",
      "url": "https://files.pythonhosted.org/packages/48/05/9aff783cfe80678ee8c736b0438c689ac90f2c7e0ba588667db30a95b10d/z3c.traverser-2.0.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}