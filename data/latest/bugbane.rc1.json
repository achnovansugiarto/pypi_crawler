{
  "info": {
    "author": "Valery Korolyov",
    "author_email": "fuzzah@tuta.io",
    "bugtrack_url": null,
    "classifiers": [
      "Framework :: Pytest",
      "Framework :: tox",
      "License :: OSI Approved :: Apache Software License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3",
      "Topic :: Security",
      "Topic :: Software Development :: Bug Tracking",
      "Topic :: Software Development :: Build Tools",
      "Topic :: Software Development :: Quality Assurance",
      "Topic :: Software Development :: Testing",
      "Topic :: Utilities",
      "Typing :: Typed"
    ],
    "description": "# BugBane\n\nНабор утилит для аудита безопасности приложений.<br>\n\nОсновные принципы и особенности:\n1. BugBane образует пайплайн безопасной разработки, этапы которого описаны в виде кода. Без BugBane пайплайн сильно фрагментирован: часть низкоуровневых инструкций описана в Makefile, часть - в shell-скриптах, что-то - в файлах используемого решения для CI/CD, а что-то - в Dockerfile. При подобной фрагментации гораздо проще допустить ошибки.\n2. BugBane - вариант стандартизации структуры рабочей директории, структуры и формата отчётных материалов, а также пайплайна безопасной разработки как последовательности определённых действий.\n3. BugBane - это набор инструментов, которые могут использоваться как совместно, так и по отдельности.\n4. BugBane позволяет выполнить тестирование и подготовить отчётные материалы: в процессе тестирования собираются свидетельства выполняемых операций в виде команд, журналов работы, скриншотов и отчётов. Все материалы соответствуют фактически выполненным действиям и запущенным командам, что защищает пользователя от ошибок при ручном вводе и сборе этих сведений.\n5. BugBane является решением, открытым для улучшений с учётом пожеланий сообщества.\n\n\nВозможности BugBane на текущий момент:\n1. Сборка целей для фаззинг-тестирования, в том числе с санитайзерами и сбором покрытия: AFL++, libFuzzer.\n2. Фаззинг сборок с использованием [AFL++](https://github.com/AFLplusplus/AFLplusplus), [libFuzzer](https://www.llvm.org/docs/LibFuzzer.html), [dvyukov/go-fuzz](https://github.com/dvyukov/go-fuzz) на заданном количестве ядер до заданного условия остановки.\n3. Синхронизация (импорт и экспорт) тестовых примеров между рабочей директорией фаззера и хранилищем (папкой). Включает отсеивание дубликатов (для всех фаззеров) и минимизацию на основе инструментов фаззера (пока только AFL++).\n4. Сбор покрытия тестируемого приложения на семплах, полученных в процессе фаззинг-тестирования, а также генерация HTML-отчётов о покрытии (lcov, lcov-llvm, go-tool-cover).\n5. Воспроизведение падений и зависаний, обнаруженных фаззером. Извлечение места возникновения ошибки (имя функции, путь к файлу исходного кода, номер строки в файле).\n6. Отправка сведений о воспроизводимых багах в систему управления уязвимостями: [Defect Dojo](https://github.com/DefectDojo/django-DefectDojo).\n7. Получение скриншотов работы фаззера (tmux + ansifilter + pango-view) и главной страницы отчёта о покрытии исходного кода (WeasyPrint, Selenium).\n8. Генерация отчётов на основе шаблонов Jinja2.\n\n# Установка\n\n## Зависимости\nUNIX-подобная ОС<br>\nPython >= 3.6<br><br>\nЗависимости, используемые утилитами BugBane:<br>\n**bb-build**: компиляторы используемого фаззера в PATH (afl-g++-fast, clang, ...).<br>\n**bb-corpus**: утилита минимизации в соответствии с используемым фаззером в PATH (afl-cmin, ...).<br>\n**bb-fuzz**: используемый фаззер в PATH (afl-fuzz, go-fuzz, ...).<br>\n**bb-coverage**: используемые средства сбора покрытия в PATH (lcov, genhtml, go, ...).<br>\n**bb-reproduce**: утилита `timeout`, отладчик `gdb`.<br>\n**bb-send**: python-библиотека `defectdojo_api`.<br>\n**bb-screenshot**, **bb-report**: python-библиотеки `Jinja2`, `WeasyPrint`, `Selenium`, приложения `ansifilter` и `pango-view` в PATH, приложение `geckodriver` в PATH и браузер Firefox (необязательно, только для Selenium), шрифты `mono` (могут отсутствовать в базовых докер-образах).<br>\nПримечания:\n- Python-библиотеки устанавливается автоматически при выполнении дальнейших инструкций;\n- в настоящий момент Selenium + geckodriver + Firefox *необходимо* использовать только для отчётов о покрытии, построенных утилитой `go tool cover`, для остальных отчётов достаточно использовать WeasyPrint; при этом скриншоты, сделанные с помощью Selenium, выглядят лучше. Недостаток: размер этих пакетов в некоторых дистрибутивах может занять ~700 мегабайт;\n- для просмотра отчётов непосредственно в образе Docker с помощью утилит типа less может потребоваться установка локали с поддержкой UTF-8 и указание переменной LANG.\n\n## Установка и удаление пакета\nУстановить пакет можно локально с помощью pip:\n```\ngit clone https://github.com/gardatech/bugbane\ncd bugbane\npip install .[all]\n```\nПроверить выполнение тестов:\n```\npytest\n```\nДоступна установка только необходимых Python-зависимостей:\n| Группа pip install | Фаззинг* | Заведение багов в Defect Dojo | Отчёты и скриншоты | Тестирование BugBane | Разработка BugBane |\n|-|-|-|-|-|-|\n| - | + | - | - | - | - |\n| dd | + | + | - | - | - |\n| reporting | + | - | + | - | - |\n| test | + | - | - | + | - |\n| all | + | + | + | + | - |\n| dev | + | + | + | + | + |\n\n\\* Выполнение сборок, фаззинг, работа с семплами, сбор покрытия и воспроизведение багов.\n\nТаким образом, можно разделить тестирование и работу с его результатами на разные хосты worker и reporter:\n```shell\npip install .                  # worker\npip install .[dd,reporting]    # reporter\n```\nРезультат: на хосте worker не требуются зависимости для генерации отчётов, на хосте reporter не требуются окружение для запуска тестируемых приложений и фаззеров.\n\nДля удаления использовать следующую команду:\n```\npip uninstall bugbane\n```\n\n# Запуск\nРекомендуется использовать BugBane в среде Docker.<br>\nПодразумевается последовательный запуск инструментов в определённом порядке, например:\n1. bb-build\n2. bb-corpus (import)\n3. bb-fuzz\n4. bb-coverage\n5. bb-reproduce\n6. bb-corpus (export)\n7. bb-send\n8. bb-report\n\nПри этом этап №1 является опциональным (сборки могут быть выполнены другими способами), а этапы 7 и 8 могут выполняться в отдельном образе Docker или на отдельной машине.\n\n**Большинство инструментов BugBane работают с конфигурационным файлом bugbane.json**: получают входные переменные, обновляют их значения, добавляют новые переменные и дописывают в существующий файл конфигурации.<br>\nПример исходного файла конфигурации, достаточного для последовательного запуска всех инструментов BugBane:\n```json\n{\n    \"fuzzing\": {\n        \"os_name\": \"Arch Linux\",\n        \"os_version\": \"Rolling\",\n\n        \"product_name\": \"RE2\",\n        \"product_version\": \"2022-02-01\",\n        \"module_name\": \"BugBane RE2 Example\",\n        \"application_name\": \"re2\",\n\n        \"is_library\": true,\n        \"is_open_source\": true,\n        \"language\": [\n            \"C++\"\n        ],\n        \"parse_format\": [\n            \"RegExp\"\n        ],\n        \"tested_source_file\": \"re2_fuzzer.cc\",\n        \"tested_source_function\": \"TestOneInput\",\n\n        \"build_cmd\": \"./build.sh\",\n        \"build_root\": \"./build\",\n        \"tested_binary_path\": \"$BUILD_ROOT/re2_fuzzer\",\n        \"sanitizers\": [\n            \"ASAN\", \"UBSAN\"\n        ],\n        \"builder_type\": \"AFL++LLVM\",\n        \"fuzzer_type\": \"AFL++\",\n\n        \"run_args\": null,\n        \"run_env\": null,\n\n        \"fuzz_cores\": 16\n    }\n}\n```\n\n\n## bb-build\nВыполняет сборку C/C++ приложения с использованием компиляторов фаззера.<br>\nНа вход приложению подаются:\n1. Исходный код, подлежащий сборке\n2. Файл с переменными bugbane.json\n\nВ файле bugbane.json должны быть заданы переменные: `builder_type`, `build_cmd`, `build_root`, `sanitizers`.<br>\n\nКоманда, указанная в переменной `build_cmd`, должна учитывать значения переменных окружения CC, CXX, CFLAGS, CXXFLAGS и при запуске выполнять сборку тестируемого компонента в режиме фаззинг-тестирования. После выполнения одного запуска команды `build_cmd` в папке `build_root` должна оказаться сборка тестируемого приложения. Переменная `sanitizers` должна содержать список санитайзеров, с которыми требуется выполнить сборки. Для каждого санитайзера будет выполнена отдельная сборка.<br>\n\nПриложение последовательно выполняет несколько сборок (с различными санитайзерами + для сбора покрытия + дополнительные сборки для фаззинга) и после каждой сборки сохраняет результаты сборки из папки `build_root` в папку, указанную аргументом запуска `-o`. При этом обновляются некоторые переменные в файле bugbane.json (в частности, `sanitizers` - заполняется названиями санитайзеров, для которых удалось выполнить сборку).<br>\n\nПример скрипта, путь к которому может быть указан в команде сборки `build_cmd`:\n```bash\n#!/bin/bash\nexport CXX=\"${CXX:=afl-clang-fast++}\" &&\nmkdir -p build &&\nmake clean &&\nmake -j obj/libre2.a &&\n$CXX $CXXFLAGS --std=c++11 -I. re2/fuzzing/re2_fuzzer.cc /AFLplusplus/libAFLDriver.a obj/libre2.a -lpthread -o build/re2_fuzzer\n```\nТаким образом флагами компиляции можно управлять извне и получать сборки с любыми санитайзерами, с инструментацией для сбора покрытия, с отладочной информацией и т.д.\n\nПример запуска:\n```shell\nbb-build -i /src -o /fuzz\n```\nПри этом директория /src должна содержать файл bugbane.json.<br>\nВ результате в пути /fuzz появятся папки с полученными сборками, например: /fuzz/basic, /fuzz/asan, /fuzz/coverage. Также в папке /fuzz сохранится журнал выполнения всех сборок с указанием команд запуска и использованных переменных окружения.\n\n### Соответствие сборок и папок\n| Имя папки | Описание | builder_type |\n|-|-|-|\n| basic | Сборка для фаззинга. Это должна быть наиболее производительная сборка: без санитайзеров, без покрытия | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer |\n| gofuzz | Сборка для фаззинга с использованием dvyukov/go-fuzz (zip-архив). Не поддерживается bb-build, поддерживается остальными утилитами | - |\n| laf | Сборка для фаззинга, скомпилированная с переменной окружения AFL_LLVM_LAF_ALL | AFL++LLVM, AFL++LLVM-LTO |\n| cmplog | Сборка для фаззинга, скомпилированная с переменной окружения AFL_USE_CMPLOG | AFL++LLVM, AFL++LLVM-LTO |\n| asan | Сборка для фаззинга с адресным санитайзером (Address Sanitizer) | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer \n| ubsan | Сборка для фаззинга с санитайзером неопределённого поведения (Undefined Behavior Sanitizer) | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n| cfisan | Сборка для фаззинга с санитайзером целостности потока выполнения (Control Flow Integrity Sanitizer) | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n| tsan * | Сборка для фаззинга с санитайзером потоков (Thread Sanitizer) | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n| lsan * | Сборка для фаззинга с санитайзером утечек памяти (Leak Sanitizer). Этот функционал поддерживается адресным санитайзером, но также может использоваться отдельно | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n| msan * | Сборка для фаззинга с санитайзером памяти (Memory Sanitizer) | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n| coverage | Сборка для получения информации о покрытии | AFL++GCC, AFL++GCC-PLUGIN, AFL++LLVM, AFL++LLVM-LTO, libFuzzer\n\n\\* Работоспособность не тестировалась.<br>\n\n## Выполнение сборок без инструмента bb-build\nВсе сборки рекомендуется выполнять компиляторами фаззера, в том числе сборку для получения информации о покрытии.<br>\nВсе сборки должны выполняться с отладочной информацией, содержащей сведения о строках исходного кода (`-g` для gcc, `-g` или `-gline-tables-only` - для clang).<br>\nВсе сборки должны выполняться с флагом `-fno-omit-frame-pointer` для получения более точных стеков вызовов в случае обнаружения багов или при отладке.<br>\nЕсли фаззер поддерживает переменные окружения для включения санитайзеров (AFL_USE_ASAN и т.д.), то использование этих переменных предпочтительнее ручного указания флагов компиляции.<br>\nСборки следует размещать в папках под соответствующими названиями. Например, если фаззинг будет запущен из директории /fuzz, то сборка с ASAN должна быть сохранена в папке /fuzz/asan. Сборку, в которой одновременно присутствуют несколько санитайзеров, следует разместить в одном экземпляре в любой одной папке для сборки с санитайзером. То есть сборку с ASAN, UBSAN и CFISAN можно разместить в любой из папок: asan, ubsan, cfisan, lsan, tsan или msan - это не имеет значения.<br>\nЕсли сборка coverage выполнялась компиляторами фаззера, то возможно использование сборки coverage для фаззинга в качестве сборки basic (для этого достаточно скопировать папку coverage в basic), но это неэффективно по скорости, а также создаёт дополнительную нагрузку на диск.\n\n\n## bb-corpus\nСинхронизирует тестовые примеры в рабочей директории фаззера с хранилищем.<br>\nПоддерживает импорт из хранилища в папку фаззера и экспорт из папки фаззера в хранилище.<br>\nИнструмент не создаёт никаких подключений, не взаимодействует с какими-либо базами данных и не выполняет архивацию, вместо этого он работает с хранилищем как с простой папкой в файловой системе. В свою очередь хранилище может быть примонтированным каталогом Samba, NFS и т.д.<br>\n\nСинхронизация происходит в два этапа:\n1. Копирование (в случае импорта) или перемещение (в случае экспорта) из папки-источника во временную папку без создания дубликатов по содержимому (проверка sha1).\n2. Минимизация семплов из временной папки в конечную папку с использованием инструмента фаззера (afl-cmin, ...).\n\nВ конфигурационном файле bugbane.json должна быть объявлена переменная `fuzzer_type`.<br>\nДля минимизации с использованием afl-cmin на диске должны присутствовать сборки тестируемого приложения. Наиболее предпочтительной сборкой для минимизации семплов является сборка в папке laf, т.к. она \"различает\" больше путей выполнения, но если она не будет обнаружена, для минимизации будут использованы другие сборки.\n\nПример импорта тестовых примеров из хранилища (перед фаззинг-тестированием):\n```shell\nbb-corpus suite /fuzz import-from /storage\n```\nПример экспорта тестовых примеров в хранилище (после фаззинг-тестирования):\n```shell\nbb-corpus suite /fuzz export-to /storage\n```\n\nИмена результирующих файлов будут соответствовать хеш-сумме sha1 их содержимого.\n\n## bb-fuzz\nЗапускает фаззинг сборок тестируемого приложения на указанном количестве ядер до наступления указанного условия остановки.<br>\nbb-fuzz обнаруживает сборки на диске и распределяет их по разным ядрам процессора:\n* сборкам с санитайзерами выделяется по одному ядру;\n* вспомогательные сборки (AFL_LLVM_LAF_ALL, AFL_USE_CMPLOG) назначаются на некоторое процентное соотношение от указанного количества ядер;\n* сборка basic (без санитайзеров) занимает остальные ядра;\n* сборки для определения покрытия исходного кода в фаззинг-тестировании участие не принимают.\n\nВ конфигурационном файле bugbane.json должны быть определены переменные `fuzzer_type`, `tested_binary_path`, `fuzz_cores`, `src_root`, `run_args` и `run_env`.<br>\nНа диске должны присутствовать сборки приложения, размещённые в папках, соответствующих названию сборки, точно так же, как их размещает инструмент bb-build.\n\nДоступные значения переменной `fuzzer_type`: AFL++, libFuzzer, go-fuzz.<br>\nПеременная `tested_binary_path` содержит путь к тестируемому приложению относительно `build_root` и относительно входной папки (где будет осуществлён поиск сборок).<br>\nПеременная `src_root` не используется напрямую, но без её указания потерпят неудачу утилиты, подлежащие запуску после bb-fuzz.<br>\n`run_args` - аргументы запуска тестируемого приложения в режиме фаззинг-тестирования. Переменная может включать последовательность \"@@\", вместо которой фаззер подставит путь к файлу.<br>\n`run_env`* - переменные окружения, которые необходимо установить для запуска тестируемого приложения (LD_PRELOAD и т.д.).<br>\n\n\\* Пока не все инструменты используют эту переменную.\n\nДоступные условия остановки:\n* реальная продолжительность фаззинга достигла X секунд (затраченное время независимо от количества ядер / экземпляров фаззера);\n* суммарная продолжительность фаззинга достигла X секунд* (реальная продолжительность, умноженная на количество задействованных в тестировании ядер процессора);\n* новые пути выполнения не обнаруживались в течение последних X секунд среди всех экземпляров фаззера.\n\n\\* Пока нет способа задать это условие.\n\nУсловие остановки задаётся с помощью переменных окружения:<br>\n* CERT_FUZZ_DURATION=X - наивысший приоритет, если установлены другие переменные; X определяет количество секунд, в течение которых не должны обнаруживаться новые пути выполнения;\n* CERT_FUZZ_LEVEL=X - средний приоритет; X определяет уровень контроля, что в свою очередь определяет время, в течение которого не должны обнаруживаться новые пути выполнения; допустимые значения X: 2, 3, 4.\n* FUZZ_DURATION=X - наименьший приоритет; X определяет реальную продолжительность тестирования.\n\nПеременные CERT_FUZZ_* подходят для сертификационных испытаний, FUZZ_* - для использования в CI/CD.<br>\nЕсли не объявлена ни одна из указанных переменных, используется FUZZ_DURATION=600.<br>\n\nКоличество ядер определяется минимальным значением среди перечисленных:\n1. Количество доступных в системе ядер.\n2. Значение переменной `fuzz_cores` в файле конфигурации. Если значение не указано, будет выбрано 8 ядер.\n3. Аргумент запуска `--max-cpus` (значение по умолчанию: 16).\n\nПример запуска:\n```shell\nFUZZ_DURATION=1800 bb-fuzz --suite /fuzz\n```\nВ результате выполнения команды будет запущено несколько экземпляров фаззера в сессии tmux. Инструмент bb-fuzz будет периодически печатать статистику работы фаззера, пока не обнаружит наступление условия остановки, в данном случае, пока не накопится время работы 1800 секунд = 30 минут. Затем с использованием команд tmux capture-pane в папку /fuzz/screens будут сохранены дампы панелей tmux с возможно присутствующими ANSI-последовательностями (цвета, выделение текста жирным шрифтом и т.д.). Эти сохранённые дампы используются на слеующих этапах приложениями bb-report или bb-screenshot.<br>\n**Внимание: в настоящий момент после сохранения дампов завершаются ВСЕ процессы фаззера и tmux в пределах операционной системы.**\n\n**Примечание: в настоящий момент не поддерживается использование словарей для фаззинга.**\n\n\n## bb-coverage\nСобирает покрытие тестируемого приложения на семплах, сгенерированных фаззером:\n1. Запускает тестируемое приложение на семплах в директории синхронизации фаззера *\n2. Строит отчёт о покрытии\n\n\\* Для dvyukov/go-fuzz этап пропускается: подразумевается фаззинг с использованием ключа `-dumpcover` (bb-fuzz использует этот ключ).\n\nВ конфигурационном файле bugbane.json должны быть объявлены переменные `tested_binary_path`, `run_args`, `run_env`, `coverage_type`, `fuzzer_type`, `fuzz_sync_dir`, `src_root`.<br>\nПеременная `coverage_type` заполняется приложением bb-build и соответствует типу сборки.<br>\n`src_root` - путь к исходному коду тестируемого приложения на момент выполнения сборок; не обязан реально существовать в файловой системе: если директория не существует, отчёт о покрытии будет содержать проценты, но не исходный код.\n\nВозможные значения `coverage_type`\n| coverage_type | Описание |\n|-|-|\n| lcov | Для целей, собранных компиляторами GCC с флагом `--coverage` |\n| lcov-llvm | Для целей, собранных компиляторами LLVM с флагом `--coverage` |\n| go-tool-cover | Для целей golang |\n\nПример запуска:\n```shell\nbb-coverage suite /fuzz\n```\n\nРезультат: в папке /fuzz/coverage_report должны появиться файлы отчёта о покрытии, в том числе /fuzz/coverage_report/index.html - главная страница отчёта о покрытии.\n\n\n## bb-reproduce\nВоспроизводит баги и обобщает результаты работы фаззера:<br>\n1. Получает общую статистику работы фаззеров\n2. Минимизирует падения и зависания путём их воспроизведения (получает информацию о типе ошибки и месте в коде: функция, файл, номер строки)\n3. Формирует JSON-файл с перечисленными выше сведениями\n\nВ конфигурационном файле bugbane.json должны быть определены переменные `src_root`, `fuzz_sync_dir`, `fuzzer_type`, `reproduce_specs`, `run_args`, `run_env`. Переменные `fuzz_sync_dir` и `reproduce_specs` добавляются инструментом bb-fuzz.<br>\n`fuzz_sync_dir` - директория синхронизации фаззера; bb-fuzz использует директорию \"out\".<br>\n`src_root` - путь к исходному коду тестируемого приложения на момент выполнения сборок; не обязан реально существовать в файловой системе, используется для более точного определения места падений/зависаний в исходном коде.<br>\n`reproduce_specs` - словарь, определяющий тип фаззера, и задающий соответствие между сборками приложения и папками, на которых требуется выполнить воспроизведение:\n```json\n\"fuzz_sync_dir\": \"/fuzz/out\",\n\"reproduce_specs\": {\n    \"AFL++\": {\n        \"/fuzz/basic/re2_fuzzer\": \"re2_fuzzer2\",\n        \"/fuzz/ubsan/re2_fuzzer\": \"re2_fuzzer6\"\n    }\n}\n```\nВ данном случае сборка basic будет запущена на семплах `/fuzz/out/re2_fuzzer2/{crashes,hangs}/id*`, а сборка ubsan - на семплах `/fuzz/out/re2_fuzzer6/{crashes,hangs}/id*`.<br>\nПри каждом запуске анализируется вывод приложения в терминал, в том числе сообщения об ошибках от санитайзеров. Каждый баг воспроизводится до успешного воспроизведения, но не более N раз. Число N определяется аргументом запуска bb-fuzz `--num-reruns`, значение по умолчанию: 3. Если при воспроизведении падения не обнаруживается стек вызовов, приложение запускается под отладчиком gdb. Зависания воспроизводятся сразу под отладчиком gdb.<br>\n\nПример запуска:\n```shell\nbb-reproduce --hang-timeout 3000 suite /fuzz\n```\n\nВ результате формируется файл /fuzz/bb_results.json, содержащий статистику работы фаззера и сведения об обнаруженных и воспроизведённых багах, в том числе для каждого бага сохраняются: заголовок issue/бага, место возникновения бага в исходном коде, команда запуска с конкретным семплом, stdout+stderr приложения, переменные окружения.\n\n\n## bb-send\nОтправляет полученные скриптом bb-reproduce данные в формате JSON в систему управления уязвимостями Defect Dojo.<br>\nОдин запуск инструмента соответствует созданию одного теста в нужном engagement. В пределах этого теста создаются экземпляры finding на каждый уникальный баг.<br>\nЗдесь и далее в качестве адреса сервера Defect Dojo используется https://dojo.local:8080.<br>\n\nПриложение bb-send не использует файл конфигурации BugBane. Входные данные берутся из файла bb_results.json.\n\nПример запуска:\n```\nbb-send --results-file bb_results.json --host https://dojo.local:8080 \\\n    --user-name ci_fuzz_user --user-id 2 --token TOKEN \\\n    --engagement 1 --test-type 141\n```\nОписание некоторых аргументов запуска bb-send:<br>\n`--user-id`: id указанного в `--user-name` пользователя; можно посмотреть в адресной строке Defect Dojo, выбрав нужного пользователя на странице https://dojo.local:8080/user.<br>\n`--engagement`: engagement id; также можно посмотреть в адресной строке в браузере (выбрать нужный engagement на странице https://dojo.local:8080/engagement).<br>\n`--test-type`: id вида теста; брать также из адресной строки (выбрать нужный тест на странице https://dojo.local:8080/test_type).<br>\n`--token`: ключ API; берётся из Defect Dojo по ссылке: https://dojo.local:8080/api/key-v2 (нужно быть авторизованным от имени, указанного в `--user-name`, ключ нужен из раздела \"Your current API key is ....\").<br>\n\nЕсли подлинность сертификата сервера Defect Dojo не может быть проверена, то следует добавить аргумент запуска `--no-ssl` и использовать http вместо https.\n\n\n# bb-report\nСоздаёт отчёт в формате md на основе указанного Jinja2-шаблона. По умолчанию используется шаблон, подобный протоколу сертификационных испытаний.<br>\nСоздаёт скриншоты экранов фаззера (из дампов tmux, сохранённых ранее на этапе фаззинг-тестирования) и главной страницы HTML-отчёта о покрытии кода. Скриншоты сохраняются в папку screenshots и вставляются в отчёт в виде ссылок.<br>\n\nВ файле конфигурации bugbane.json должны быть объявлены переменные `fuzzer_type`, `coverage_type` и `fuzz_sync_dir`.<br>\n\nПример запуска:\n```shell\nbb-report --name fuzzing_re2 suite /fuzz\n```\nЗапуск с использованием Selenum:\n```shell\nbb-report --html-screener selenium --name fuzzing_re2 suite /fuzz\n```\n\nРезультат: в папке /fuzz появится папка screenshots и файл с отчётом fuzzing_re2.md. \n\n# bb-screenshot\nУтилита для ручного создания скриншотов. Скриншоты создаются так же, как в приложении bb-report, но пользователь может указать имена входного и выходного файлов.\n\nПримеры запуска:\n```shell\nbb-screenshot -S pango -i tmux_dump.txt -o tmux_screenshot.png\nbb-screenshot -S weasyprint -i index.html -o coverage.png\nbb-screenshot -S selenium -i index.html -o coverage2.png\n```\n\n# Развитие\nПланы по улучшению BugBane:\n1. Поддержка работы со словарями\n2. Поддержка тестирования разных целей в пределах одной сборки\n3. Поддержка других фаззеров\n4. Добавление других утилит\n5. Генерация отчётов в других форматах и по другим шаблонам\n\n# Для разработчиков\nУстановка в режиме editable в виртуальное окружение:\n```\npython -m venv .venv\n. .venv/bin/activate\npip install -e .[dev]\n```\n\nЗапуск тестов:\n```\npytest\n```\n\nЗапуск тестов в среде tox (при этом собирается покрытие кода тестами):\n```\ntox\n```\n\n# Благодарности\nСпасибо всем участникам проекта!\n\nОтдельные благодарности:\n- [Илья Уразбахтин](https://github.com/donyshow): идеи, консультации, менторство.\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/gardatech/bugbane",
    "keywords": "",
    "license": "Apache-2.0",
    "maintainer": "",
    "maintainer_email": "",
    "name": "bugbane",
    "package_url": "https://pypi.org/project/bugbane/",
    "platform": "",
    "project_url": "https://pypi.org/project/bugbane/",
    "project_urls": {
      "Homepage": "https://github.com/gardatech/bugbane"
    },
    "release_url": "https://pypi.org/project/bugbane/0.0.1/",
    "requires_dist": [
      "beautifulsoup4",
      "lxml",
      "defectdojo-api",
      "typing ; python_version < \"3.6\"",
      "dataclasses ; python_version < \"3.7\"",
      "requests ; extra == 'all'",
      "Jinja2 ; extra == 'all'",
      "selenium ; extra == 'all'",
      "WeasyPrint (==52.5) ; extra == 'all'",
      "pytest ; extra == 'all'",
      "pytest-mock ; extra == 'all'",
      "requests ; extra == 'dd'",
      "requests ; extra == 'dev'",
      "Jinja2 ; extra == 'dev'",
      "selenium ; extra == 'dev'",
      "WeasyPrint (==52.5) ; extra == 'dev'",
      "pytest ; extra == 'dev'",
      "pytest-mock ; extra == 'dev'",
      "black ; extra == 'dev'",
      "build ; extra == 'dev'",
      "coverage ; extra == 'dev'",
      "pylint ; extra == 'dev'",
      "tox ; extra == 'dev'",
      "rope ; extra == 'dev'",
      "wheel ; extra == 'dev'",
      "Jinja2 ; extra == 'reporting'",
      "selenium ; extra == 'reporting'",
      "WeasyPrint (==52.5) ; extra == 'reporting'",
      "pytest ; extra == 'test'",
      "pytest-mock ; extra == 'test'"
    ],
    "requires_python": ">=3.6",
    "summary": "application security tools for DAST",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 12884584,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e05d93dba5821de40fb42bd1fa9801c10eab27e4e5f1d98ed84e6fe0c6b493f0",
          "md5": "dc25a1330984e34f3059fec8df0ae095",
          "sha256": "37ba4b916fdac005dc96d3801be9f3aa30abb2e5e4641089dd321f237d04f828"
        },
        "downloads": -1,
        "filename": "bugbane-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "dc25a1330984e34f3059fec8df0ae095",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 187691,
        "upload_time": "2022-02-14T13:31:43",
        "upload_time_iso_8601": "2022-02-14T13:31:43.325231Z",
        "url": "https://files.pythonhosted.org/packages/e0/5d/93dba5821de40fb42bd1fa9801c10eab27e4e5f1d98ed84e6fe0c6b493f0/bugbane-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "9580a9f9f5817d7118a4681101ab705b36eb2fb7be71efab0e2e23750ab8dea4",
          "md5": "3708a00c50e770a29e13a7d4ba243b66",
          "sha256": "c539f3c8ce19eb32b148e993262394fa1500fb0ac46364d71b858da218b8a9d9"
        },
        "downloads": -1,
        "filename": "bugbane-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "3708a00c50e770a29e13a7d4ba243b66",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 123100,
        "upload_time": "2022-02-14T13:31:45",
        "upload_time_iso_8601": "2022-02-14T13:31:45.271356Z",
        "url": "https://files.pythonhosted.org/packages/95/80/a9f9f5817d7118a4681101ab705b36eb2fb7be71efab0e2e23750ab8dea4/bugbane-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "e05d93dba5821de40fb42bd1fa9801c10eab27e4e5f1d98ed84e6fe0c6b493f0",
        "md5": "dc25a1330984e34f3059fec8df0ae095",
        "sha256": "37ba4b916fdac005dc96d3801be9f3aa30abb2e5e4641089dd321f237d04f828"
      },
      "downloads": -1,
      "filename": "bugbane-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "dc25a1330984e34f3059fec8df0ae095",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 187691,
      "upload_time": "2022-02-14T13:31:43",
      "upload_time_iso_8601": "2022-02-14T13:31:43.325231Z",
      "url": "https://files.pythonhosted.org/packages/e0/5d/93dba5821de40fb42bd1fa9801c10eab27e4e5f1d98ed84e6fe0c6b493f0/bugbane-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "9580a9f9f5817d7118a4681101ab705b36eb2fb7be71efab0e2e23750ab8dea4",
        "md5": "3708a00c50e770a29e13a7d4ba243b66",
        "sha256": "c539f3c8ce19eb32b148e993262394fa1500fb0ac46364d71b858da218b8a9d9"
      },
      "downloads": -1,
      "filename": "bugbane-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "3708a00c50e770a29e13a7d4ba243b66",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 123100,
      "upload_time": "2022-02-14T13:31:45",
      "upload_time_iso_8601": "2022-02-14T13:31:45.271356Z",
      "url": "https://files.pythonhosted.org/packages/95/80/a9f9f5817d7118a4681101ab705b36eb2fb7be71efab0e2e23750ab8dea4/bugbane-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}