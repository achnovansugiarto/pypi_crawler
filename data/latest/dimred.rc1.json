{
  "info": {
    "author": "Fabrice Guillaume",
    "author_email": "fabrice.guillaume@email.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# DimRed - Dimension Reduction Package\n\n\n### DimRed Introduction\n<img align=\"right\" src=\"https://github.com/FabG/dimred/raw/master/images/Dimred_s3.png\" style=\"vertical-align:left;margin:0px 10px\">\n\n\n**DimRed** is a python package that enables **Dimension Reduction** leveraging various algorithms with the default being\n  **PCA** (Principal Component Analysis). The algorithms supported so far are:\n   - numpy `EVD`, `SVD`\n   - sklearn `PCA`, `SparsePCA` and `TruncatedSVD`.\n\nThis package also offers some **visualization** capabilities to explore the principal components (up to 2 or 3 PC, in 2D or 3D).\n\n\nDimRed has some built-in functions written in `numpy` and others leveraging the well known `sklearn` built-in functions:\n - internally built SVD and EVD methods with `numpy`:\n  - `dimred_svd` - Dimension reduction using the Singular Value Decomposition: `X . V = U . S ==> X = U.S.Vt`\n  This should return the same results as `sklearn_pca` and it uses `np.linalg.svd`\n  - `dimred_evd`- Dimension reduction using the Eigen Value Decomposition, based on `C` being the covariance matrix of X `C = XT x X / (n -1)` and `C = Q Λ QT` where `Λ` is a diagonal matrix with eigenvalues in decreasing order on the diagonal. It uses `np.linalg.eig`\n - `sklearn.decomposition` algorithms:\n   - `sklearn_pca` - leverages sklearn [PCA()](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html) that is a Linear dimension reduction function that uses SVD.\n   This should return the same results as numpy based internal implementation of SVD: `dimred_svd`\n   - `sklearn_sparse_pca` - using sklearn [SparsePCA()](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.SparsePCA.html) also great for Sparse matrices that are *not* of type `scipy.sparse`\n   - `sklearn_truncated_svd` - leverages sklearn [TruncatedSVD()](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html) - great for handling sparse matrices (with lots of 0), that *are* type `scipy.sparse` (`X.sp_issparse` is True).\n\nHere is an example with `PCA` (Principal Component Analysis) that is using a Linear Dimension reduction algorithm to project your data to a lower dimensional space. It is an **unsupervised** technique for `feature extraction` by combining input variables in a specific way so that the output \"new\" variables (or components) are all `independent of one another`.\n\nPCA aims to find linearly uncorrelated orthogonal axes, which are also known as principal components (PCs) in the m dimensional space to project the data points onto those PCs. The first PC captures the largest variance in the data. Let’s intuitively understand PCA by fitting it on a 2-D data matrix, which can be conveniently represented by a 2-D scatter plot:\n\n   <p align=\"center\" width=\"100%\">\n       <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/pca_animation.gif\">\n       <br><i>Making sense of PCA by fitting on a 2-D dataset<a href=\"https://stats.stackexchange.com/questions/2691/making-sense-of-principal-component-analysis-eigenvectors-eigenvalues/140579#140579\"> (source)</a></i>\n   </p>\nSince all the PCs (Principal Components) are orthogonal to each other, we can use a pair of perpendicular lines in the 2-D space as the two PCs. To make the first PC capture the largest variance, we rotate our pair of PCs to make one of them optimally align with the spread of the data points. Next, all the data points can be projected onto the PCs, and their projections (red dots on PC1) are essentially the resultant dimensionality-reduced representation of the dataset. Viola, we just reduced the matrix from 2-D to 1-D while retaining the largest variance!\n\nAnd here is an example of dimension reduction on the famous [iris dataset](https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html) and using the `DimRed` package:\n```python\n# Load the data\nimport matplotlib.pyplot as plt\niris = datasets.load_iris()\nfeatures = iris.data\ntarget = iris.target\n```\n\n\nDimension Reduction Example - 2D plot / 2 Components:\n```python\n# Reduce it to 2 principal components\ndimred = DimRed(algo='dimred_svd', n_components=2)\nX_transf = dimred.fit_transform(X)\n\n# Plot with DimRed - 2d\nfig, ax = dimred.draw_scatterplot(X_transf2, y=target,\n                                  PC=2,\n                                  title='Reduced Iris Dataset with DimRed - 2 principal components',\n                                  figsize=(8, 6),\n                                  legend=True)\nplt.show()\n```\n<p align=\"center\" width=\"100%\">\n    <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/dimred_iris_scatterplot_2PC_2d.png\">\n    <br><i> Scatter Plot pf Iris Dataset reduced to 2 components with DimRed</a></i>\n</p>\n\nDimension Reduction Example - 2D plot / 3 Components (using the 3rd component as bubble size):\n```python\n# Reduce it to 3 principal components\ndimred = DimRed(algo='dimred_svd', n_components=3)\nX_transf = dimred.fit_transform(X)\n\n# Plot with DimRed - 2d\nfig, ax = dimred.draw_scatterplot(X_transf, y=target,\n                                  PC=3,\n                                  title='Reduced Iris Dataset with DimRed - 3 principal components',\n                                  figsize=(8, 6),\n                                  legend=True)\nplt.show()\n```\n<p align=\"center\" width=\"100%\">\n    <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/dimred_iris_scatterplot_3PC_2d.png\">\n    <br><i> Scatter Plot of Iris Dataset reduced to 2 components with DimRed</a></i>\n</p>\n\nDimension Reduction Example - Cumulative Variance:\n\nBelow we will reduce the `MNIST` dataset to retain 60% of the variance from the original 64 dimensions (8 x 8 pixels)\n\n```python\ndigits = load_digits(as_frame=True)\n  X = digits.data\n  scaler = StandardScaler()\n  scaler.fit(X)\n\n  dimred = DimRed(algo='dimred_svd', n_components = .60)\n  X_pca = dimred.fit_transform(X)\n\n  fig, ax = dimred.draw_varianceplot('MNIST Data')\n  plt.show()\n```\n<p align=\"center\" width=\"100%\">\n    <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/dimred_mnist_cumvarianceplot_60.png\">\n    <br><i> Cumulative Variance Plot of MNIST Dataset based on 60% Variance retained with DimRed</a></i>\n</p>\n\n\nDimension Reduction Example - 3D plot:\n\n```python\n# Reduce it to 3 principal components\ndimred = DimRed(algo='dimred_svd', n_components=3)\nX_transf = dimred.fit_transform(X)\n\n# Plot with DimRed - 3d\n# give larger values for bubble plot from [1-10] range to [100-1000]\nfig, ax = dimred.draw_scatterplot(X_transf, y=target,\n                                  PC=3,\n                                  title='Reduced Iris Dataset with DimRed - 3 principal components ',\n                                  figsize=(8, 6),\n                                  legend=True,\n                                  dim3=True)\nplt.show()\n```\n<p align=\"center\" width=\"100%\">\n    <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/dimred_iris_scatterplot_3PC_3d.png\">\n    <br><i> Scatter Plot pf Iris Dataset reduced to 2 components with DimRed</a></i>\n</p>\n\n\n### Table of contents\n* [Refresher on Dimension Reduction](#refresher-dimred)\n* [DimRed Installation](#dimred-installation)\n* [DimRed Examples](#dimred-examples)\n* [Dimension Reduction Notebooks](#dimred-notebooks)\n* [Dimension Reduction Algorithms - Intuition and Mathematics](#dimred-intuition)\n* [Resources](#resources)\n\n\n\n### <a name=\"dimred-installation\"></a> 1. DimRed Installation\n\n`DimRed` is built as a python package.\nYou can install it from [Pypi](https://pypi.org) as a pip installable package.\nOr you can also download the code and do a local install.\n\n#### 1.1 Pip Install\nYou need to run Python 3.X.\nAnd you should set up a virtual environment with `conda` or `virtualenv`\n\nRun:\n```bash\npip install -i https://pypi.org/simple/ dimred\n```\n\n\n#### 1.2 Local Install\nYou need to run Python 3.X.\nAnd you should set up a virtual environment with `conda` or `virtualenv`\n\nGo to: [dimred pypi](https://pypi.org/project/dimred/)\n\nClick on [Download files](https://pypi.org/project/dimred/#files) link\n\nAnd download either the Wheel or the Source code.\n\nTo locally install from Source code, run:\n```bash\n> pip install -r requirements\n```\n\nFinally, don't forget to set you `$PYTHONPATH` variable to the root of your projects if you want to run the tests.\n```bash\n> export PYTHONPATH=/to/root/of/your/project\n```\nIt should map to: `/your/path/dimred/dimred`\n\n##### Tests\nFor Unit Tests, run:  \n```bash\n> pytest\n```\nDon't forget to set your `$PYTHONPATH` to the root of your project\n\nIf you also want to see the print output to stdout, run:  \n```bash\n> pytest --capture=tee-sys\n```\n\nFor Unit Tests Coverage, run:  \n```bash\n> pytest --cov=dimred tests/\n```\n\nOr:  \n```bash\n> pytest --capture=tee-sys --cov=dimred tests/\n```\n\nTo run a particular test, run:\n```bash\n> pytest --capture=tee-sys --cov=dimred tests/ -k '<your test>'\n```\n\nWe should aim at having a **minimum of 90% code coverage**, and preferably closer or equal to 100%.\n\n\n##### Packaging and uploading to PiPy\nSee [dimred-packaging](dimred-packaging.md)\n\n\n### <a name=\"dimred-examples\"></a> 2. DimRed Examples\n\n#### 2.1 DimRed on Iris dataset (automatic selection)\nReducing the (150x4) iris matrix to (150x2) with `DimRed` letting the algorithm pick the right algorithm (in that case `sklearn_pca` which is the default algorithm):\n\n```python\nfrom dimred import DimRed\nfrom sklearn.datasets import load_iris\n\niris = load_iris()\nX = iris.data\n\ndimred = DimRed(n_components=2)\nX_pca = dimred.fit_transform(X)\n\n# Algorithm selected for Dimension Reduction\ndimred.algo\n> 'sklearn_pca'\n\n# Matrices shape of both Input matrix and Reduced matrix\nX.shape\n> (150, 4)\nX_pca.shape\n> (150, 2)\n\n# Number of components.\n# If not specified (as we did here with 2), it is estimated from input data\ndimred.n_components_\n> 2\n\n# Principal axes in feature space, representing the directions of maximum variance in the data.\n# The components are sorted by `explained_variance_`.\ndimred.components_\n> array([[ 0.36138659, -0.08452251,  0.85667061,  0.3582892 ],\n       [ 0.65658877,  0.73016143, -0.17337266, -0.07548102]])\n\n# Amount of variance explained by each of the selected components.\ndimred.explained_variance_\n> array([4.22824171, 0.24267075])\n\n# Percentage of variance explained by each of the selected components.\ndimred.explained_variance_ratio_\n> array([0.92461872, 0.05306648])\n\n```\n\n#### 2.2a DimRed on Friedman Sparse dataset (automatic selection)\nReducing the (30x30) sparse matrix to (30x5) with `DimRed` letting the algorithm pick the right algorithm (in that case `sklearn_sparse_pca` which is using sklearn `SparsePCA()`).\n\n```python\nfrom dimred import DimRed\nfrom sklearn.datasets import make_sparse_spd_matrix\n\nX = make_sparse_spd_matrix(dim=30, alpha = .95, random_state=10)\n\ndimred = DimRed(n_components=5, random_int=0)\nX_transformed = dimred.fit_transform(X)\n\n# Check the algorithm automatically picked is `SparsePCA`\ndimred.algo\n> 'sklearn_sparse_pca'\n\nX.shape\n> (30, 30)\n\nX_pca.shape\n> (30, 5))\n\n```\n\n\n#### 2.2b DimRed on Friedman Sparse dataset (forced selection)\nReducing the (30x30) sparse matrix to (30x5) with `DimRed` specifying the (in that case `sklearn_pca` which is using Singular Value Decomposition).\n\n```python\nfrom dimred import DimRed\nfrom sklearn.datasets import make_sparse_spd_matrix\n\nX = make_sparse_spd_matrix(dim=30, alpha = .95, random_state=10)\n\ndimred = DimRed(algo = 'sklearn_pca', n_components=5, random_int=0)\n#dimred = DimRed(algo = 'dimred_svd', n_components=5, random_int=0)\nX_pca = dimred.fit_transform(X)\n\n# Check the algorithm automatically picked is `SparsePCA`\ndimred.algo\n> 'sklearn_pca'\n\nX.shape\n> (30, 30)\n\nX_pca.shape\n> (30, 5))\n\n```\n\n\n### <a name=\"refresher-dimred\"></a> 3. Refresher on Dimension Reduction\n**Dimension reduction** (or Dimensionality reduction) refers to techniques for reducing the number of input variables in training data.\n\n*When dealing with high dimensional data, it is often useful to reduce the dimensionality by projecting the data to a lower dimensional subspace which captures the “essence” of the data. This is called **dimensionality reduction**.*\n\n— Page 11, [Machine Learning: A Probabilistic Perspective](https://www.amazon.com/Machine-Learning-Probabilistic-Perspective-Computation/dp/0262018020/ref=as_li_ss_tl?keywords=Machine+Learning:+A+Probabilistic+Perspective&qid=1580679017&sr=8-1&linkCode=sl1&tag=inspiredalgor-20&linkId=e1ce409a189df7eeb214b15424a7379c&language=en_US), 2012.\n\n\nHigh-dimensionality might mean hundreds, thousands, or even millions of input variables.\n\nFewer input dimensions often means correspondingly fewer parameters or a simpler structure in the machine learning model, referred to as degrees of freedom. A model with too many degrees of freedom is likely to **overfit** the training dataset and may not perform well on new data.\n\nIt is **desirable to have simple models that generalize well**, and in turn, input data with few input variables. This is particularly true for linear models where the number of inputs and the degrees of freedom of the model are often closely related.\n\n\n\n#### Why is Dimension Reduction useful?\n- **Reduces training time** — due to smaller dataset\n- **Removes noise** — by keeping only what’s relevant\n- **Makes visualization possible** — in cases where you have a maximum of 3 principal components\n\n\n\n### <a name=\"dimred-notebooks\"></a> 4. Dimension Reduction Notebooks\n - [DimRed Demo notebook](notebooks/dimred_demo.ipynb)\n - [PCA implementation with EVD and SVD](notebooks/pca_evd_svd.ipynb) => provides implementation of PCA with EVD and SVD and shows SVD is a better implementation\n - [PCA vs LDA and PCA visualization on Iris data](notebooks/pca_lda_iris.ipynb)\n\n### <a name=\"dimred-intuition\"></a> 5. Dimension Reduction Algorithms - Intuition and Mathematics\n\n#### 5.1 Dimensionality Reduction Algorithms\n\nThere are many algorithms that can be used for dimensionality reduction.\n\nTwo main classes of methods are those drawn from linear algebra and those drawn from manifold learning:\n\n##### => Linear Algebra Methods\nMatrix factorization methods drawn from the field of linear algebra can be used for dimensionality.\nSome of the more popular methods include:\n- [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis#:~:text=Principal%20component%20analysis%20(PCA)%20is,components%20and%20ignoring%20the%20rest.): Principal Components Analysis => process of computing the principal components and using them to perform a change of basis on the data, sometimes using only the first few principal components and ignoring the rest.\n- [SVD](https://en.wikipedia.org/wiki/Singular_value_decomposition): Singular Value Decomposition\n- [NMF](https://en.wikipedia.org/wiki/Non-negative_matrix_factorization): Non-Negative Matrix Factorization\n\nFor more on matrix factorization, see this [tutorial](https://machinelearningmastery.com/introduction-to-matrix-decompositions-for-machine-learning/)\n\n\n\n##### => Manifold Learning Methods\nManifold learning methods seek a lower-dimensional projection of high dimensional input that captures the salient properties of the input data.\n\nSome of the more popular methods include:\n- [Isomap](https://en.wikipedia.org/wiki/Isomap) Embedding\n- [LLE](https://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction#Locally-linear_embedding): Locally Linear Embedding\n- [MDS](https://en.wikipedia.org/wiki/Multidimensional_scaling): Multidimensional Scaling\n- [Spectral Embedding](https://en.wikipedia.org/wiki/Spectral_clustering)\n- [t-SNE](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding): t-distributed Stochastic Neighbor Embedding\n\nEach algorithm offers a different approach to the challenge of discovering natural relationships in data at lower dimensions.\n\nThere is no best dimensionality reduction algorithm, and no easy way to find the best algorithm for your data without using controlled experiments.\n\n\n\n#### 5.2 DimRed Package - Supported Algorithms\n\n#### PCA\nWhen using `PCA` (Principal Component Analysis), you are using a Linear Dimension reduction algorithm, that will project your data to a lower dimensional space. It is an **unsupervised** technique for `feature extraction` by combining input variables in a specific way so that the output \"new\" variables (or components) are all `independant of one another`. This is a benefit because of the assumptions of a linear model.\n\nPCA aims to find linearly uncorrelated orthogonal axes, which are also known as principal components (PCs) in the m dimensional space to project the data points onto those PCs. The first PC captures the largest variance in the data.\n\nLet’s intuitively understand PCA by fitting it on a 3-D data matrix, which can be conveniently represented by a 3-D scatter plot:\n\n<p align=\"center\" width=\"100%\">\n    <img width=\"70%\" src=\"https://github.com/FabG/dimred/raw/master/images/pca_3d_2d.png\">\n    <br><i>3D to 2D dimension reduction with PCA <a href=\"https://medium.com/@TheDataGyan/dimensionality-reduction-with-pca-and-t-sne-in-r-2715683819\"> (source)</a></i>\n</p>\n\nHere you can see:\n - first image has three dimensional data with `X`,`Y` and `Z` axes.\n - second image is a two dimensional space with `PC1` and `PC2` as axes.\n\nNote these `PC1` and `PC2` are *not* our regular dimensions and we cannot name them with any of the previous attribute names. They represent the orthogonal projections along which the variance of data is high. We will understand more about it while dealing with PCA below.\n\nThe PCs can be determined via eigen decomposition of the covariance matrix C. After all, the geometrical meaning of eigen decomposition is to find a new coordinate system of the eigenvectors for C through rotations.\nImage for post\nEigendecomposition of the covariance matrix C:  \n<p align=\"center\" width=\"100%\">\n    <img width=\"40%\" src=\"https://github.com/FabG/dimred/raw/master/images/eidgen_decomposition_covariance.png\">\n</p>\n\nIn the equation above, the covariance matrix C(m×m) is decomposed to a matrix of eigenvectors W(m×m) and a diagonal matrix of m eigenvalues Λ. The eigenvectors, which are the column vectors in W, are in fact the PCs we are seeking. We can then use matrix multiplication to project the data onto the PC space. For the purpose of dimensionality reduction, we can project the data points onto the first k PCs as the representation of the data:  \n<p align=\"center\" width=\"100%\">\n    <img width=\"30%\" src=\"https://github.com/FabG/dimred/raw/master/images/projected_data.png\">\n</p>\n\nNotes: PCA is an analysis approach. You can do PCA using SVD, or you can do PCA doing the eigen-decomposition, or you can do PCA using many other methods.  In fact, most implementations of PCA actually use performs SVD under the hood rather than doing eigen decomposition on the covariance matrix because SVD can be much more efficient and is able to handle sparse matrices. In addition, there are reduced forms of SVD which are even more economic to compute.\n\nFrom a high-level view PCA using EVD (eigen-decomposition) has three main steps:\n- (1) Compute the covariance matrix of the data\n- (2) Compute the eigen values and vectors of this covariance matrix\n- (3) Use the eigen values and vectors to select only the most important feature vectors and then transform your data onto those vectors for reduced dimensionality!\n\nPCA can be very easily implemented with numpy as the key function performing eigen decomposition `np.linalg.eig` is already built-in:\n```python\ndef pca(X):\n  # Data matrix X, assumes 0-centered\n  n, m = X.shape\n  assert np.allclose(X.mean(axis=0), np.zeros(m))\n  # Compute covariance matrix\n  C = np.dot(X.T, X) / (n-1)\n  # Eigen decomposition\n  eigen_vals, eigen_vecs = np.linalg.eig(C)\n  # Project X onto PC space\n  X_pca = np.dot(X, eigen_vecs)\n  return X_pca\n```\n\n\n#### LDA\nBoth LDA and PCA are linear transformation techniques: LDA is a supervised whereas PCA is unsupervised – PCA ignores class labels.\n\n**LDA** is very useful to find dimensions which aim at **separating cluster**, thus you will have to know clusters before. LDA is not necessarily a classifier, but can be used as one. Thus LDA can only be used in **supervised learning**\n\n=> *LDA is used to carve up multidimensional space.*LDA is for classification, it almost always outperforms Logistic Regression when modeling small data with well separated clusters. It also handles multi-class data and class imbalances.\n\n\nTo contrast with LDA, **PCA** is a general approach for **denoising and dimensionality reduction** and does not require any further information such as class labels in supervised learning. Therefore it can be used in **unsupervised learning**.\n\n=> *PCA is used to collapse multidimensional space*. PCA allows the collapsing of hundreds of spatial dimensions into a handful of lower spatial dimensions while preserving 70% - 90% of the important information. 3D objects cast 2D shadows. We can see the shape of an object from it's shadow. But we can't know everything about the shape from a single shadow. By having a small collection of shadows from different (globally optimal) angles, then we can know most things about the shape of an object. PCA helps reduce the 'Curse of Dimensionality' when modeling.\n\n\n#### EVD and SVD\n##### SVD - Singular Value Decomposition\n\nThe **SVD** allows to describe the effect of a matrix 𝐴 on a vector (via the matrix-vector product), as a three-step process `𝐴=𝑈Σ𝑉†`:\n- 1. A first rotation in the input space (`𝑉`)\n- 2. A simple positive scaling that takes a vector in the input space to the output space (`Σ`)\n- 3. And another rotation in the output space (`𝑈`)\n\n*Note that `𝑉†` denotes the conjugate of `𝑉⊤`, hence the two are equal when 𝑉 is real.*\nNote that the conditions above are mathematically the following constraints:\n\n- `𝑉†𝑉=𝐼`    (i.e. 𝑉 is a rotation matrix)\n- `Σ=diag(𝜎⃗ )` and `𝜎⃗ ≥0⃗` (`diag` just returns a diagonal matrix with the given diagonal)\n- `𝑈†𝑈=𝐼`    (i.e. 𝑈 is a rotation matrix)\n\nThe [fundamental theorem of linear algebra](https://en.wikipedia.org/wiki/Fundamental_theorem_of_linear_algebra) says that such a decomposition always exists.\n\nSVD is another decomposition method for both real and complex matrices. It decomposes a matrix into the product of two unitary matrices (U, V*) and a rectangular diagonal matrix of singular values (Σ):\n\n\nHere is a friendler  way to visualize the **SVD** formula:\n<p align=\"center\" width=\"100%\">\n    <img width=\"40%\" src=\"https://github.com/FabG/dimred/raw/master/images/svd_matrix.png\">\n    <br><i>Illustration of SVD<a href=\"https://towardsdatascience.com/pca-and-svd-explained-with-numpy-5d13b0d2a4d8\"> (source)</a></i>\n</p>\n\nIn most cases, we work with real matrix X, and the resultant unitary matrices U and V will also be real matrices. Hence, the conjugate transpose of the U is simply the regular transpose.\n\nWhat **SVD** it used for?\n\n[Wikipedia has a nice list](https://en.wikipedia.org/wiki/Singular-value_decomposition#Applications_of_the_SVD), but I'll list a couple.\n- One of the most common applications is obtaining a low-rank approximation to a matrix (see **PCA**), which is used for compression, speed-up, and also actual data analysis.\n- The other one is for characterizing the pseudo-inverse for analysis or proofs, since inverting it automatically gives a formula that's the inverse when the matrix is invertible, and the pseudo-inverse when it is not.\n\n\nSVD has also already been implemented in numpy as `np.linalg.svd`. To use SVD to transform your data:\n\n```python\ndef svd(X):\n  # Data matrix X, X doesn't need to be 0-centered\n  n, m = X.shape\n  # Compute full SVD\n  U, Sigma, Vh = np.linalg.svd(X,\n      full_matrices=False, # It's not necessary to compute the full matrix of U or V\n      compute_uv=True)\n  # Transform X with SVD components\n  X_svd = np.dot(U, np.diag(Sigma))\n  return X_svd\n```\n\n##### Relationship between PCA and SVD\nPCA and SVD are closely related approaches and can be both applied to decompose any rectangular matrices. We can look into their relationship by performing SVD on the covariance matrix C:\n<p align=\"center\" width=\"100%\">\n    <img width=\"40%\" src=\"https://github.com/FabG/dimred/raw/master/images/covariance_matrix_pca_svd.png\">\n</p>\n\nFrom the above derivation, we notice that the result is in the same form with eigen decomposition of C, we can easily see the relationship between singular values (Σ) and eigenvalues (Λ):\n<p align=\"center\" width=\"100%\">\n    <img width=\"40%\" src=\"https://github.com/FabG/dimred/raw/master/images/eigen_singular_values_relationship.png\">\n</p>\n\n\nTo confirm that with numpy:\n```python\n# Compute covariance matrix\nC = np.dot(X.T, X) / (n-1)\n# Eigen decomposition\neigen_vals, eigen_vecs = np.linalg.eig(C)\n# SVD\nU, Sigma, Vh = np.linalg.svd(X,\n    full_matrices=False,\n    compute_uv=True)\n# Relationship between singular values and eigen values:\nprint(np.allclose(np.square(Sigma) / (n - 1), eigen_vals)) # True\n```\n\nSo what does this imply?  \nIt suggests that we can actually perform PCA using SVD, or vice versa. In fact, **most implementations of PCA actually use performs SVD under the hood** rather than doing eigen decomposition on the covariance matrix because SVD can be much more efficient and is able to handle sparse matrices. In addition, there are reduced forms of SVD which are even more economic to compute.\n\n\n##### EVD - Eigenvalue (spectral) decomposition\nSimilarly, for the **eigendecomposition** (also known as eigenvalue decomposition, spectral decomposition, or diagonalization):\n\nAn eigendecomposition describes the effect of a matrix 𝐴 on a vector as a different 3-step process `𝐴=𝑄Λ𝑄−1`:\n- 1. An invertible linear transformation `(𝑄−1)`\n- 2. A scaling `(Λ)`\n- 3. The inverse of the initial transformation `(𝑄)`\n\nCorrespondingly, these conditions imply the following constraints:\n- `𝑄` is invertible\n- `Λ=diag(𝜆⃗ )`\n\nThis decomposition doesn't always exist, but the [spectral theorem](https://en.wikipedia.org/wiki/Spectral_theorem) describes the conditions under which such a decomposition exists.\n\nNote the most basic requirement is that `𝐴` be a **square matrix** (but this is not enough).\n\nWhat **EVD** is used for?\n\n- It gives you the ability to efficiently raise a matrix to a large power: 𝐴𝑛=𝑄Λ𝑛𝑄−1. For this reason (and others) it's used heavily in engineering to, say, efficiently analyze and predict the behavior of a linear dynamical system at a future point in time, since this is much faster than manually exponentiating the matrix directly.\n- It's also used to analyze the response of a linear system at different frequencies. (Sinusoids of different frequencies are orthogonal, so you get the orthogonal diagonalizability for free.)\n- Furthermore, it's also a problem that repeatedly comes up when solving differential equations analytically.\n\n\n#### EVD Vs SVD\nConsider the eigendecomposition `𝐴=𝑃𝐷𝑃−1` and SVD `𝐴=𝑈Σ𝑉∗`. Some key differences are as follows,\n\n- The vectors in the eigendecomposition matrix 𝑃 are not necessarily orthogonal, so the change of basis isn't a simple rotation. On the other hand, the vectors in the matrices 𝑈 and 𝑉 in the SVD are orthonormal, so they do represent rotations (and possibly flips).\n- In the SVD, the nondiagonal matrices 𝑈 and 𝑉 are not necessairily the inverse of one another. They are usually not related to each other at all. In the eigendecomposition the nondiagonal matrices 𝑃 and 𝑃−1 are inverses of each other.\n- In the SVD the entries in the diagonal matrix Σ are all real and nonnegative. In the eigendecomposition, the entries of 𝐷 can be any complex number - negative, positive, imaginary, whatever.\n- The SVD always exists for any sort of rectangular or square matrix, whereas the eigendecomposition can only exists for square matrices, and even among square matrices sometimes it doesn't exist.\n\nusing the SVD to perform PCA makes much better sense numerically than forming the covariance matrix (in EVD) to begin with, since the formation of 𝐗𝐗⊤ can cause loss of precision\n\n\n### <a name=\"resources\"></a> 6. Resources\n\n#### Articles\n - [scikit learn PCA](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html)\n - [MIT open source pca packate](https://github.com/erdogant/pca)\n - [PCA and SVD explained with numpy](https://towardsdatascience.com/pca-and-svd-explained-with-numpy-5d13b0d2a4d8)\n - [Mathematical explanation of PCA and SVD](https://math.stackexchange.com/questions/3869/what-is-the-intuitive-relationship-between-svd-and-pca)\n - [Mathematical explanation - how to use SVD to perform PCA](https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca)\n - [Tutorial on Principal Component Analysis - White paper](https://arxiv.org/pdf/1404.1100.pdf)\n - [implement PCA using SVD with sklearn and numpy](https://stackoverflow.com/questions/60508233/python-implement-a-pca-using-svd)\n - [EVD and SVD white paper](https://www.cc.gatech.edu/~dellaert/pubs/svd-note.pdf)\n - [Difference between EVD and SVD](https://math.stackexchange.com/questions/320220/intuitively-what-is-the-difference-between-eigendecomposition-and-singular-valu)\n - [Dimension reduction algorithms in python](https://machinelearningmastery.com/dimensionality-reduction-algorithms-with-python/)\n - [PCA explained on wine data with chart animation](https://stats.stackexchange.com/questions/2691/making-sense-of-principal-component-analysis-eigenvectors-eigenvalues/140579#140579)\n - [Dimensionality Reduction with PCA and t-SNE in R](https://medium.com/@TheDataGyan/dimensionality-reduction-with-pca-and-t-sne-in-r-2715683819)\n - [What are Eigenvalues and eigenvectors](https://medium.com/fintechexplained/what-are-eigenvalues-and-eigenvectors-a-must-know-concept-for-machine-learning-80d0fd330e47)\n - [PCA with numpy](https://towardsdatascience.com/pca-with-numpy-58917c1d0391)\n\n\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/FabG/dimred",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "dimred",
    "package_url": "https://pypi.org/project/dimred/",
    "platform": "",
    "project_url": "https://pypi.org/project/dimred/",
    "project_urls": {
      "Homepage": "https://github.com/FabG/dimred"
    },
    "release_url": "https://pypi.org/project/dimred/0.0.1/",
    "requires_dist": [
      "sklearn",
      "numpy",
      "pandas",
      "matplotlib",
      "scipy",
      "colourmap",
      "pytest",
      "pytest-cov",
      "seaborn",
      "pathlib"
    ],
    "requires_python": ">=3.6",
    "summary": "Dimension Reduction and Visualization with PCA SVD, EVD and more",
    "version": "0.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9210918,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "03a9a99abd679bfe8d0beb1145607a0c977ff21780447f80ef3189fc43032f3e",
          "md5": "6cb9de9885317635af1783b1a3ac192a",
          "sha256": "6653c046d904a28c02b46d77bfce3828cac743b8d736a07486883cfcfd9a5beb"
        },
        "downloads": -1,
        "filename": "dimred-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "6cb9de9885317635af1783b1a3ac192a",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.6",
        "size": 19674,
        "upload_time": "2021-01-23T14:39:20",
        "upload_time_iso_8601": "2021-01-23T14:39:20.466729Z",
        "url": "https://files.pythonhosted.org/packages/03/a9/a99abd679bfe8d0beb1145607a0c977ff21780447f80ef3189fc43032f3e/dimred-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "39d3480ba145a3e522ed830bdcacaf9cfd4552404106270d16c393f9810d4721",
          "md5": "8a4d4caf80506729d51d006877ee553d",
          "sha256": "34ad725f11691ce41c3cd109aed2b6248612676c3707182d0b862a01fe8b1e23"
        },
        "downloads": -1,
        "filename": "dimred-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "8a4d4caf80506729d51d006877ee553d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 35624,
        "upload_time": "2021-01-23T14:39:22",
        "upload_time_iso_8601": "2021-01-23T14:39:22.182505Z",
        "url": "https://files.pythonhosted.org/packages/39/d3/480ba145a3e522ed830bdcacaf9cfd4552404106270d16c393f9810d4721/dimred-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "03a9a99abd679bfe8d0beb1145607a0c977ff21780447f80ef3189fc43032f3e",
        "md5": "6cb9de9885317635af1783b1a3ac192a",
        "sha256": "6653c046d904a28c02b46d77bfce3828cac743b8d736a07486883cfcfd9a5beb"
      },
      "downloads": -1,
      "filename": "dimred-0.0.1-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "6cb9de9885317635af1783b1a3ac192a",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.6",
      "size": 19674,
      "upload_time": "2021-01-23T14:39:20",
      "upload_time_iso_8601": "2021-01-23T14:39:20.466729Z",
      "url": "https://files.pythonhosted.org/packages/03/a9/a99abd679bfe8d0beb1145607a0c977ff21780447f80ef3189fc43032f3e/dimred-0.0.1-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "39d3480ba145a3e522ed830bdcacaf9cfd4552404106270d16c393f9810d4721",
        "md5": "8a4d4caf80506729d51d006877ee553d",
        "sha256": "34ad725f11691ce41c3cd109aed2b6248612676c3707182d0b862a01fe8b1e23"
      },
      "downloads": -1,
      "filename": "dimred-0.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "8a4d4caf80506729d51d006877ee553d",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 35624,
      "upload_time": "2021-01-23T14:39:22",
      "upload_time_iso_8601": "2021-01-23T14:39:22.182505Z",
      "url": "https://files.pythonhosted.org/packages/39/d3/480ba145a3e522ed830bdcacaf9cfd4552404106270d16c393f9810d4721/dimred-0.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}