{
  "info": {
    "author": "Ding Yi",
    "author_email": "dvdface@hotmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Changelist\n* 1.0.1,  update README\n* 1.0.0,  first release\n\n# Feedback\n\ngive your feedback by following ways<br/>\n\n* visit https://github.com/dvdface/vstc (preferred)\n\n* send email to dvdface@gmail.com\n  \n\n# How to install\n\n`pip install vstc`\n\n# Known issues\n\n1.x version, only support call locally. AKA, you can share a physical STC port between many test runers in the same PC. <br/>\n\nIt will support RPC in 2.x version so that you can share a physical STC port between many PCs. <br/>\n\n# Overview\nVSTC means Virtual Spirent TestCenter.<br/>\n\nIt takes Spirent TestCenter and Switch as a Virutal Spirent TestCenter.<br/>\n\n![image](https://github.com/dvdface/vstc/raw/master/res/Virtual%20Spirent%20TestCenter.png)<br/>\n\nIn general, you connect chassis, reserve port, create device under port, then create raw/bound streamblock, start traffic.<br/>\n\nWith VSTC, it takes a STC port and Vlan ID as a virtual STC port so that the \ntraffics generated by a same STC port can be redirect to target port by switch with VLAN ID.<br/>\n\nAka, one STC port can be used as  multiple virutal ports by this way. so, you can save your money to buy Spirent TestCenter<br/>\n\nOf course, you can use VSTC library without vid, so VSTC is just a ordinary STC.<br/>\n\n# Class diagram\n\n![image](https://github.com/dvdface/vstc/raw/master/res/VSTC%20Class%20Diagram.png)<br/>\n\nThe relationship between classes is Just like Spirent TestCenter GUI.<br/>\n\nChassis class provides ability to reserve port, create multicast groups.<br/>\n\nPort class provides ability to create devices, streamblocks.<br/>\n\nMCGroup represents Multicast Group, you can add IGMP type device into it.<br/>\n\nStreamBlock represents streamblock under Port.<br/>\n\nDevice represents Device under Port.<br/>\n\n# Impelmentation explains\n\nUnder the hook, VSTC uses stc:: / sth:: api provided by Spirent TestCenter.\n\nVSTC uses STCObject to wrap object handle in stc::/sth::, so you can access / set object's attributes by PortObject['attribute'] syntax.<br/>\n\nIn STCObject, it provides properties by which you can access attributes more easily.<br/>\n\n# QA Info\n```\nName                 Stmts   Miss  Cover\n----------------------------------------\nvstc\\__init__.py         9      0   100%\nvstc\\testcenter.py     821    116    86%\nvstc\\util.py            70      6    91%\n----------------------------------------\nTOTAL                  900    122    86%\n```\n\n# How to use\n* **Chassis class<br/>**\n   \n   ```\n   # connect testcenter with ip 10.182.32.138 , without reserving any port\n   # creating chassis class will auto connect chassis\n   chassis = Chassis('10.182.32.138')\n\n   # disconnect chassis\n   chassis.disconnect()\n\n   # apply changes ( it will apply automatically)\n   chassis.apply()\n\n   # connect testcenter and reserve port\n   chassis = Chassis('10.182.32.138', [{ 'location' : '//10.182.32.138/1/1', 'vid': None}, { 'location' : '//10.182.32.138/1/2', 'vid': None}])\n\n   # connect testcenter, reserve port and specify a default vlan with specified vid\n   # when you create a device under the port, it will insert a vlan layer with vid 100 for you\n   # when you create a streamblock, it will insert a vlan layer with vid 100 for you too\n   chassis = Chassis('10.182.32.138', [{ 'location' : '//10.182.32.138/1/1', 'vid': 100}])\n\n   # save xml file\n   chassis.save('test_configuration.xml')\n\n   # get chassis serial number\n   chassis.serial\n\n   # get chassis ip\n   chassis.ip\n   ```\n\n* **Port class<br/>**\n   ```\n   # access reserved ports\n   # access all reserved ports\n   # it wil return List[Port]\n   chassis.ports\n\n   # access the first reserved ports\n   port = chassis.ports[0]\n   \n   # start capture \n   port.start_capture()\n   # stop capture\n   port.stop_capture()\n   # save capture\n   port.save_capture('demo.pcap')\n\n   # change DataPathMode\n   # normal: send / receive data to other port \n   port.mode = PortMode.normal\n   # loopback: send data to self\n   port.mode = PortMode.local_loopback\n\n   # get port location\n   # //10.182.32.138/1/1\n   port.location\n   # get port vid\n   port.vid\n\n   # get port ownership state\n   # OwnershipState.RESERVED銆丄VAILABLE銆丏ISCONNECTED\n   port.ownership\n\n   # get port owner host\n   port.owner_host == socket.gethostname()\n   \n   # get port onwer user\n   port.owner_user\n   ```\n* **MCGroup class<br/>**\n   ```\n   # access multicast groups under chassis\n   # it will return List[MCGroup]\n   chassis.mcgroups\n\n   # create a multicast group under chassis with name 'ipv4group', and group ip '224.0.0.1'\n   mcgroup = chassis.create_mcgroup('ipv4group', ip='224.0.0.1')\n\n   # remove mcgroup from chassis\n   chassis.remove_mcgroup(mcgroup)\n\n   # get / set group name\n   mcgroup.name\n   mcgroup.name = 'demo name'\n\n   # get / set group ip\n   mcgroup.ip\n   mcgroup.ip = '225.0.0.1'\n\n   # add IGMP device into MCGroup\n   # 1.get a reserved port under chassis\n   port = chassis.ports[0]\n   # 2. create igmp device under port\n   igmpDevice = port.create_device(DeviceType.igmp)\n   # 3. add igmp device into a mcgroup\n   mcgroup.add(igmpDevice)\n   # 4. remove igmp device from mcgroup\n   mcgroup.remove(igmpDevice)\n   \n   # get devices in the mcgroup\n   # it will return List[IGMPDevice]\n   mcgroup.devices\n   ```\n\n* **Device class<br/>**\n   ```\n   # create traffic only device\n   dev = port.create_device(DeviceType.host)\n\n   # set device mac, ip, mask, gateway, gateway mac\n   dev.mac = '00:10:94:00:01:01'\n   dev.ip = '192.168.1.1'\n   dev.mask = 24\n   dev.gateway = '192.168.1.254'\n   dev.gwmac = '00:10:94:00:11:11'\n\n   # get stats for device\n   dev.stats\n\n   # create dhcp devices\n   \n   dhcpv4server = port.create_device(DeviceType.dhcpv4_server, ip_address='192.168.10.1', ipaddress_pool='192.168.10.2')\n   dhcpv4client = port.create_device(DeviceType.dhcpv4_client)\n\n   # create igmp devices\n   igmp = port.create_device(DeviceType.igmp)\n\n   # create pppox devices\n   pppoxserver = port.create_device(DeviceType.pppox_server)\n   pppoxclient = port.create_device(DeviceType.pppox_client)\n\n   # set pppox auth mode, username, password and so on\n   pppoxserver.auth = PPPoXAuthMode.auto\n   pppoxserver.username = 'test'\n   pppoxserver.password = 'testpassword'\n   ```\n\n* **Streamblock class<br/>**\n   ```\n   # raw streamblock\n   streamblock = port.create_streamblock(StreamType.raw)\n\n   # bound streamblock\n   client = port.create_device(DeviceType.dhcpv4_client)\n   server = port.create_device(DeviceType.dhcpv4_server, ip_address='192.168.1.254', ipaddress_pool='192.168.1.1')\n\n   streamblock = port.create_streamblock(StreamType.bound, src_handle=client.handle, dst_handle=server.handle)\n\n   # start / stop streamblock\n   streamblock.start()\n\n   wait_for_true(lambda : streamblock.state == StreamState.running)\n\n   streamblock.stop()\n   \n   # get / set streamblock speed\n   streamblock.speed\n   streamblock.speed = '10mbps'\n   streamblock.speed = '10pps'\n   streamblock.speed = '10%'\n\n   # get / set frame length\n   streamblock.length_mode\n   streamblock.min_length\n   streamblock.max_length\n   streamblock.length_step\n   streamblock.length_mode = LengthMode.incr\n   streamblock.min_length = 100\n   streamblock.max_length = 1500\n   streamblock.length_step = 64\n\n   # get / set fill type and fill constant\n   streamblock.fill_type\n   streamblock.fill_const\n   streamblock.fill_type = FillType.constant\n   streamblock.fill_const = 0x1234\n   ```\n\n# How to extend\n## Extend Device\n```\nclass NewDevice(Device):\n\n   def _create_device(self, **kwargs) -> STCObject:\n      # create device here by using stc:: or sth:: api\n      dev_ret = SpirentAPI.instance.sth_emulation_device_config(mode='create', port_handle=self.port.handle, **kwargs)\n\n      # wrap device object hanlde with STCObject\n      return STCObject(dev_ret.handle)\n```",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/dvdface/vstc",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "vstc",
    "package_url": "https://pypi.org/project/vstc/",
    "platform": "",
    "project_url": "https://pypi.org/project/vstc/",
    "project_urls": {
      "Homepage": "https://github.com/dvdface/vstc"
    },
    "release_url": "https://pypi.org/project/vstc/1.0.1/",
    "requires_dist": null,
    "requires_python": ">=3.6",
    "summary": "SpirentTestCenter API",
    "version": "1.0.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9726105,
  "releases": {
    "1.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "10556bde72807252f56111ef2cf02370186535769b1c7675b6f3979c4c4c895c",
          "md5": "7ad8b66a574ae9437bd35e137c37e245",
          "sha256": "284b28918b27e49c56f7f7d611c61f5155babf3dec3a5edab443917045ce24ad"
        },
        "downloads": -1,
        "filename": "vstc-1.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "7ad8b66a574ae9437bd35e137c37e245",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 144003,
        "upload_time": "2021-03-10T07:43:50",
        "upload_time_iso_8601": "2021-03-10T07:43:50.247560Z",
        "url": "https://files.pythonhosted.org/packages/10/55/6bde72807252f56111ef2cf02370186535769b1c7675b6f3979c4c4c895c/vstc-1.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3a583c9fe566c35a29a733f64faecdbbd8c184369059f6bdc6eb19e3787bc0b8",
          "md5": "d0e56cab49feccac985756d9b63d8a00",
          "sha256": "05c59ac7dc9a2365a0d555f5cdc6aa83ec5d1e795b2fbb112b61f4353148681a"
        },
        "downloads": -1,
        "filename": "vstc-1.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "d0e56cab49feccac985756d9b63d8a00",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.6",
        "size": 23467,
        "upload_time": "2021-03-10T08:04:01",
        "upload_time_iso_8601": "2021-03-10T08:04:01.137020Z",
        "url": "https://files.pythonhosted.org/packages/3a/58/3c9fe566c35a29a733f64faecdbbd8c184369059f6bdc6eb19e3787bc0b8/vstc-1.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3a583c9fe566c35a29a733f64faecdbbd8c184369059f6bdc6eb19e3787bc0b8",
        "md5": "d0e56cab49feccac985756d9b63d8a00",
        "sha256": "05c59ac7dc9a2365a0d555f5cdc6aa83ec5d1e795b2fbb112b61f4353148681a"
      },
      "downloads": -1,
      "filename": "vstc-1.0.1.tar.gz",
      "has_sig": false,
      "md5_digest": "d0e56cab49feccac985756d9b63d8a00",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.6",
      "size": 23467,
      "upload_time": "2021-03-10T08:04:01",
      "upload_time_iso_8601": "2021-03-10T08:04:01.137020Z",
      "url": "https://files.pythonhosted.org/packages/3a/58/3c9fe566c35a29a733f64faecdbbd8c184369059f6bdc6eb19e3787bc0b8/vstc-1.0.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}