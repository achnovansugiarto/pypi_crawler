{
  "info": {
    "author": "Ilan Schnell",
    "author_email": "ilanschnell@gmail.com",
    "bugtrack_url": null,
    "classifiers": [
      "Development Status :: 6 - Mature",
      "Intended Audience :: Developers",
      "License :: OSI Approved :: Python Software Foundation License",
      "Operating System :: OS Independent",
      "Programming Language :: C",
      "Programming Language :: Python :: 2",
      "Programming Language :: Python :: 2.7",
      "Programming Language :: Python :: 3",
      "Programming Language :: Python :: 3.10",
      "Programming Language :: Python :: 3.5",
      "Programming Language :: Python :: 3.6",
      "Programming Language :: Python :: 3.7",
      "Programming Language :: Python :: 3.8",
      "Programming Language :: Python :: 3.9",
      "Topic :: Utilities"
    ],
    "description": "bitarray: efficient arrays of booleans\n======================================\n\nThis module provides an object type which efficiently represents an array\nof booleans.  Bitarrays are sequence types and behave very much like usual\nlists.  Eight bits are represented by one byte in a contiguous block of\nmemory.  The user can select between two representations: little-endian\nand big-endian.  All of the functionality is implemented in C.\nMethods for accessing the machine representation are provided.\nThis can be useful when bit level access to binary files is required,\nsuch as portable bitmap image files (.pbm).  Also, when dealing with\ncompressed data which uses variable bit length encoding, you may find\nthis module useful.\n\n\nKey features\n------------\n\n  * All functionality implemented in C.\n  * Bitarray objects behave very much like a list object, in particular\n    slicing (including slice assignment and deletion) is supported.\n  * The bit endianness can be specified for each bitarray object, see below.\n  * Fast methods for encoding and decoding variable bit length prefix codes\n  * Bitwise operations: `&`, `|`, `^`, `&=`, `|=`, `^=`, `~`\n  * Sequential search\n  * Packing and unpacking to other binary data formats, e.g. `numpy.ndarray`.\n  * Pickling and unpickling of bitarray objects.\n  * Bitarray objects support the buffer protocol\n  * `frozenbitarray` objects which are hashable\n  * Extensive test suite with about 300 unittests\n  * On 32-bit systems, a bitarray object may contain up to 2 Gbits.\n  * a separate utility module `bitarray.util`:\n      - conversion to hexadecimal string\n      - serialization\n      - pretty printing\n      - conversion to integers\n      - creating Huffman codes\n      - various count functions\n      - other helpful functions\n\n\nInstallation\n------------\n\nBitarray can be installed from source:\n\n    $ tar xzf bitarray-1.8.3.tar.gz\n    $ cd bitarray-1.8.3\n    $ python setup.py install\n\nOn Unix systems, the latter command may have to be executed with root\nprivileges.  You can also pip install bitarray.  Please note that you need\na working C compiler to run the `python setup.py install` command.\nIf you rather want to use precompiled binaries, you can:\n\n* `pip install bitarray-hardbyte` (this PyPI package contains Python\n  wheels for Linux, MaxOSX and Windows and all common Python versions)\n* `conda install bitarray` (both the default Anaconda repository as well\n  as conda-forge support bitarray)\n* download Windows wheels from\n  [Chris Gohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray)\n\nOnce you have installed the package, you may want to test it:\n\n    $ python -c 'import bitarray; bitarray.test()'\n    bitarray is installed in: /Users/ilan/bitarray/bitarray\n    bitarray version: 1.8.3\n    sys.version: 2.7.15 (default, Mar  5 2020, 14:58:04) [GCC Clang 9.0.1]\n    sys.prefix: /Users/ilan/Mini3/envs/py27\n    pointer size: 64 bit\n    .........................................................................\n    .........................................................................\n    ........................................\n    ----------------------------------------------------------------------\n    Ran 291 tests in 0.638s\n\n    OK\n\nYou can always import the function test,\nand `test().wasSuccessful()` will return `True` when the test went well.\n\n\nUsing the module\n----------------\n\nAs mentioned above, bitarray objects behave very much like lists, so\nthere is not too much to learn.  The biggest difference from list\nobjects (except that bitarray are obviously homogeneous) is the ability\nto access the machine representation of the object.\nWhen doing so, the bit endianness is of importance; this issue is\nexplained in detail in the section below.  Here, we demonstrate the\nbasic usage of bitarray objects:\n\n    >>> from bitarray import bitarray\n    >>> a = bitarray()            # create empty bitarray\n    >>> a.append(True)\n    >>> a.extend([False, True, True])\n    >>> a\n    bitarray('1011')\n\nBitarray objects can be instantiated in different ways:\n\n    >>> a = bitarray(2**20)       # bitarray of length 1048576 (uninitialized)\n    >>> bitarray('1001 011')      # from a string (whitespace is ignored)\n    bitarray('1001011')\n    >>> lst = [True, False, False, True, False, True, True]\n    >>> bitarray(lst)             # from list, tuple, iterable\n    bitarray('1001011')\n\nBits can be assigned from any Python object, if the value can be interpreted\nas a truth value.  You can think of this as Python's built-in function bool()\nbeing applied, whenever casting an object:\n\n    >>> a = bitarray([42, '', True, {}, 'foo', None])\n    >>> a\n    bitarray('101010')\n    >>> a.append(a)      # note that bool(a) is True\n    >>> a.count(42)      # counts occurrences of True (not 42)\n    4\n    >>> a.remove('')     # removes first occurrence of False\n    >>> a\n    bitarray('110101')\n\nLike lists, bitarray objects support slice assignment and deletion:\n\n    >>> a = bitarray(50)\n    >>> a.setall(False)\n    >>> a[11:37:3] = 9 * bitarray([True])\n    >>> a\n    bitarray('00000000000100100100100100100100100100000000000000')\n    >>> del a[12::3]\n    >>> a\n    bitarray('0000000000010101010101010101000000000')\n    >>> a[-6:] = bitarray('10011')\n    >>> a\n    bitarray('000000000001010101010101010100010011')\n    >>> a += bitarray('000111')\n    >>> a[9:]\n    bitarray('001010101010101010100010011000111')\n\nIn addition, slices can be assigned to booleans, which is easier (and\nfaster) than assigning to a bitarray in which all values are the same:\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = True\n    >>> a\n    bitarray('01001001001001000000')\n\nThis is easier and faster than:\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = 5 * bitarray('1')\n    >>> a\n    bitarray('01001001001001000000')\n\nNote that in the latter we have to create a temporary bitarray whose length\nmust be known or calculated.\n\n\nBit endianness\n--------------\n\nSince a bitarray allows addressing of individual bits, where the machine\nrepresents 8 bits in one byte, there are two obvious choices for this\nmapping: little-endian and big-endian.\nWhen creating a new bitarray object, the endianness can always be\nspecified explicitly:\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('10000010')\n    >>> b = bitarray('11000010', endian='little')\n    >>> b.tobytes()\n    b'C'\n\nHere, the low-bit comes first because little-endian means that increasing\nnumeric significance corresponds to an increasing address (index).\nSo `a[0]` is the lowest and least significant bit, and `a[7]` is the\nhighest and most significant bit.\n\n    >>> a = bitarray(endian='big')\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('01000001')\n    >>> a[6] = 1\n    >>> a.tobytes()\n    b'C'\n\nHere, the high-bit comes first because big-endian\nmeans \"most-significant first\".\nSo `a[0]` is now the lowest and most significant bit, and `a[7]` is the\nhighest and least significant bit.\n\nThe bit endianness is a property attached to each bitarray object.\nWhen comparing bitarray objects, the endianness (and hence the machine\nrepresentation) is irrelevant; what matters is the mapping from indices\nto bits:\n\n    >>> bitarray('11001', endian='big') == bitarray('11001', endian='little')\n    True\n\nBitwise operations (`&`, `|`, `^`, `&=`, `|=`, `^=`, `~`) are implemented\nefficiently using the corresponding byte operations in C, i.e. the operators\nact on the machine representation of the bitarray objects.\nTherefore, one has to be cautious when applying the operation to bitarrays\nwith different endianness.\n\nWhen converting to and from machine representation, using\nthe `tobytes`, `frombytes`, `tofile` and `fromfile` methods,\nthe endianness matters:\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'\\x01')\n    >>> a\n    bitarray('10000000')\n    >>> b = bitarray(endian='big')\n    >>> b.frombytes(b'\\x80')\n    >>> b\n    bitarray('10000000')\n    >>> a == b\n    True\n    >>> a.tobytes() == b.tobytes()\n    False\n\nThe endianness can not be changed once an object is created.\nHowever, you can create a new bitarray with different endianness:\n\n    >>> a = bitarray('111000', endian='little')\n    >>> b = bitarray(a, endian='big')\n    >>> b\n    bitarray('111000')\n    >>> a == b\n    True\n\nThe default bit endianness is currently big-endian, however this may change\nin the future, and when dealing with the machine representation of bitarray\nobjects, it is recommended to always explicitly specify the endianness.\n\nUnless explicitly converting to machine representation, using\nthe `tobytes`, `frombytes`, `tofile` and `fromfile` methods,\nthe bit endianness will have no effect on any computation, and one\ncan safely ignore setting the endianness, and other details of this section.\n\n\nBuffer protocol\n---------------\n\nPython 2.7 provides memoryview objects, which allow Python code to access\nthe internal data of an object that supports the buffer protocol without\ncopying.  Bitarray objects support this protocol, with the memory being\ninterpreted as simple bytes.\n\n    >>> a = bitarray('01000001 01000010 01000011', endian='big')\n    >>> v = memoryview(a)\n    >>> len(v)\n    3\n    >>> v[-1]\n    67\n    >>> v[:2].tobytes()\n    b'AB'\n    >>> v.readonly  # changing a bitarray's memory is also possible\n    False\n    >>> v[1] = 111\n    >>> a\n    bitarray('010000010110111101000011')\n\n\nVariable bit length prefix codes\n--------------------------------\n\nThe method `encode` takes a dictionary mapping symbols to bitarrays\nand an iterable, and extends the bitarray object with the encoded symbols\nfound while iterating.  For example:\n\n    >>> d = {'H':bitarray('111'), 'e':bitarray('0'),\n    ...      'l':bitarray('110'), 'o':bitarray('10')}\n    ...\n    >>> a = bitarray()\n    >>> a.encode(d, 'Hello')\n    >>> a\n    bitarray('111011011010')\n\nNote that the string `'Hello'` is an iterable, but the symbols are not\nlimited to characters, in fact any immutable Python object can be a symbol.\nTaking the same dictionary, we can apply the `decode` method which will\nreturn a list of the symbols:\n\n    >>> a.decode(d)\n    ['H', 'e', 'l', 'l', 'o']\n    >>> ''.join(a.decode(d))\n    'Hello'\n\nSince symbols are not limited to being characters, it is necessary to return\nthem as elements of a list, rather than simply returning the joined string.\n\nWhen the codes are large, and you have many decode calls, most time will\nbe spent creating the (same) internal decode tree objects.  In this case,\nit will be much faster to create a `decodetree` object (which is initialized\nwith a prefix code dictionary), and can be passed to bitarray's `.decode()`\nand `.iterdecode()` methods, instead of passing the prefix code dictionary\nto those methods itself.\n\nThe above dictionary `d` can be efficiently constructed using the function\n`bitarray.util.huffman_code()`.  I also wrote [Huffman coding in Python using\nbitarray](http://ilan.schnell-web.net/prog/huffman/) for more background\ninformation.\n\n\nReference\n=========\n\nThe bitarray object:\n--------------------\n\n`bitarray(initializer=0, /, endian='big')` -> bitarray\n\nReturn a new bitarray object whose items are bits initialized from\nthe optional initial object, and endianness.\nThe initializer may be of the following types:\n\n`int`: Create a bitarray of given integer length.  The initial values are\narbitrary.  If you want all values to be set, use the .setall() method.\n\n`str`: Create bitarray from a string of `0` and `1`.\n\n`list`, `tuple`, `iterable`: Create bitarray from a sequence, each\nelement in the sequence is converted to a bit using its truth value.\n\n`bitarray`: Create bitarray from another bitarray.  This is done by\ncopying the buffer holding the bitarray data, and is hence very fast.\n\nThe optional keyword arguments `endian` specifies the bit endianness of the\ncreated bitarray object.\nAllowed values are the strings `big` and `little` (default is `big`).\n\nNote that setting the bit endianness only has an effect when accessing the\nmachine representation of the bitarray, i.e. when using the methods: tofile,\nfromfile, tobytes, frombytes.\n\n\n**A bitarray object supports the following methods:**\n\n`all()` -> bool\n\nReturn True when all bits in the array are True.\n\n\n`any()` -> bool\n\nReturn True when any bit in the array is True.\n\n\n`append(item, /)`\n\nAppend the truth value `bool(item)` to the end of the bitarray.\n\n\n`buffer_info()` -> tuple\n\nReturn a tuple (address, size, endianness, unused, allocated) giving the\nmemory address of the bitarray's buffer, the buffer size (in bytes),\nthe bit endianness as a string, the number of unused bits within the last\nbyte, and the allocated memory for the buffer (in bytes).\n\n\n`bytereverse()`\n\nFor all bytes representing the bitarray, reverse the bit order (in-place).\nNote: This method changes the actual machine values representing the\nbitarray; it does not change the endianness of the bitarray object.\n\n\n`clear()`\n\nRemove all items from the bitarray.\n\n\n`copy()` -> bitarray\n\nReturn a copy of the bitarray.\n\n\n`count(value=True, start=0, stop=<end of array>, /)` -> int\n\nCount the number of occurrences of bool(value) in the bitarray.\n\n\n`decode(code, /)` -> list\n\nGiven a prefix code (a dict mapping symbols to bitarrays, or `decodetree`\nobject), decode the content of the bitarray and return it as a list of\nsymbols.\n\n\n`encode(code, iterable, /)`\n\nGiven a prefix code (a dict mapping symbols to bitarrays),\niterate over the iterable object with symbols, and extend the bitarray\nwith the corresponding bitarray for each symbol.\n\n\n`endian()` -> str\n\nReturn the bit endianness of the bitarray as a string (`little` or `big`).\n\n\n`extend(iterable, /)`\n\nExtend bitarray by appending the truth value of each element given\nby iterable.  If a string is provided, each `0` and `1` are appended\nas bits (whitespace is ignored).\n\n\n`fill()` -> int\n\nAdd zeros to the end of the bitarray, such that the length of the bitarray\nwill be a multiple of 8, and return the number of bits added (0..7).\n\n\n`frombytes(bytes, /)`\n\nExtend bitarray with raw bytes.  That is, each append byte will add eight\nbits to the bitarray.\n\n\n`fromfile(f, n=-1, /)`\n\nExtend bitarray with up to n bytes read from the file object f.\nWhen n is omitted or negative, reads all data until EOF.\nWhen n is provided and positive but exceeds the data available,\nEOFError is raised (but the available data is still read and appended.\n\n\n`index(value, start=0, stop=<end of array>, /)` -> int\n\nReturn index of the first occurrence of `bool(value)` in the bitarray.\nRaises `ValueError` if the value is not present.\n\n\n`insert(index, value, /)`\n\nInsert `bool(value)` into the bitarray before index.\n\n\n`invert(index=<all bits>, /)`\n\nInvert all bits in the array (in-place).\nWhen the optional `index` is given, only invert the single bit at index.\n\n\n`iterdecode(code, /)` -> iterator\n\nGiven a prefix code (a dict mapping symbols to bitarrays, or `decodetree`\nobject), decode the content of the bitarray and return an iterator over\nthe symbols.\n\n\n`itersearch(bitarray, /)` -> iterator\n\nSearches for the given a bitarray in self, and return an iterator over\nthe start positions where bitarray matches self.\n\n\n`length()` -> int\n\nReturn the length - a.length() is the same as len(a).\nDeprecated since 1.5.1, use len().\n\n\n`pack(bytes, /)`\n\nExtend the bitarray from bytes, where each byte corresponds to a single\nbit.  The byte `b'\\x00'` maps to bit 0 and all other characters map to\nbit 1.\nThis method, as well as the unpack method, are meant for efficient\ntransfer of data between bitarray objects to other python objects\n(for example NumPy's ndarray object) which have a different memory view.\n\n\n`pop(index=-1, /)` -> item\n\nReturn the i-th (default last) element and delete it from the bitarray.\nRaises `IndexError` if bitarray is empty or index is out of range.\n\n\n`remove(value, /)`\n\nRemove the first occurrence of `bool(value)` in the bitarray.\nRaises `ValueError` if item is not present.\n\n\n`reverse()`\n\nReverse the order of bits in the array (in-place).\n\n\n`search(bitarray, limit=<none>, /)` -> list\n\nSearches for the given bitarray in self, and return the list of start\npositions.\nThe optional argument limits the number of search results to the integer\nspecified.  By default, all search results are returned.\n\n\n`setall(value, /)`\n\nSet all bits in the bitarray to `bool(value)`.\n\n\n`sort(reverse=False)`\n\nSort the bits in the array (in-place).\n\n\n`to01()` -> str\n\nReturn a string containing '0's and '1's, representing the bits in the\nbitarray object.\n\n\n`tobytes()` -> bytes\n\nReturn the byte representation of the bitarray.\nWhen the length of the bitarray is not a multiple of 8, the few remaining\nbits (1..7) are considered to be 0.\n\n\n`tofile(f, /)`\n\nWrite the byte representation of the bitarray to the file object f.\nWhen the length of the bitarray is not a multiple of 8,\nthe remaining bits (1..7) are set to 0.\n\n\n`tolist(as_ints=False, /)` -> list\n\nReturn a list with the items (False or True) in the bitarray.\nThe optional parameter, changes the items in the list to integers (0 or 1).\nNote that the list object being created will require 32 or 64 times more\nmemory (depending on the machine architecture) than the bitarray object,\nwhich may cause a memory error if the bitarray is very large.\n\n\n`unpack(zero=b'\\x00', one=b'\\xff')` -> bytes\n\nReturn bytes containing one character for each bit in the bitarray,\nusing the specified mapping.\n\n\nThe frozenbitarray object:\n--------------------------\n\nThis object is very similar to the bitarray object.  The difference is that\nthis a frozenbitarray is immutable, and hashable:\n\n    >>> from bitarray import frozenbitarray\n    >>> a = frozenbitarray('1100011')\n    >>> a[3] = 1\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"bitarray/__init__.py\", line 40, in __delitem__\n        raise TypeError(\"'frozenbitarray' is immutable\")\n    TypeError: 'frozenbitarray' is immutable\n    >>> {a: 'some value'}\n    {frozenbitarray('1100011'): 'some value'}\n\n`frozenbitarray(initializer=0, /, endian='big')` -> frozenbitarray\n\nReturn a frozenbitarray object, which is initialized the same way a bitarray\nobject is initialized.  A frozenbitarray is immutable and hashable.\nIts contents cannot be altered after it is created; however, it can be used\nas a dictionary key.\n\n\nThe decodetree object:\n----------------------\n\nThis (immutable and unhashable) object stores a binary tree initialized\nfrom a prefix code dictionary.  It's sole purpose is to be passed to\nbitarray's `.decode()` and `.iterdecode()` methods, instead of passing\nthe prefix code dictionary to those methods directly:\n\n    >>> from bitarray import bitarray, decodetree\n    >>> t = decodetree({'a': bitarray('0'), 'b': bitarray('1')})\n    >>> a = bitarray('0110')\n    >>> a.decode(t)\n    ['a', 'b', 'b', 'a']\n    >>> ''.join(a.iterdecode(t))\n    'abba'\n\n`decodetree(code, /)` -> decodetree\n\nGiven a prefix code (a dict mapping symbols to bitarrays),\ncreate a binary tree object to be passed to `.decode()` or `.iterdecode()`.\n\n\nFunctions defined in the `bitarray` module:\n--------------------------------------------\n\n`bits2bytes(n, /)` -> int\n\nReturn the number of bytes necessary to store n bits.\n\n\n`get_default_endian()` -> string\n\nReturn the default endianness for new bitarray objects being created.\nUnder normal circumstances, the return value is `big`.\n\n\n`test(verbosity=1, repeat=1)` -> TextTestResult\n\nRun self-test, and return unittest.runner.TextTestResult object.\n\n\nFunctions defined in `bitarray.util` module:\n--------------------------------------------\n\n`zeros(length, /, endian=None)` -> bitarray\n\nCreate a bitarray of length, with all values 0, and optional\nendianness, which may be 'big', 'little'.\n\n\n`urandom(length, /, endian=None)` -> bitarray\n\nReturn a bitarray of `length` random bits (uses `os.urandom`).\n\n\n`pprint(bitarray, /, stream=None, group=8, indent=4, width=80)`\n\nPrints the formatted representation of object on `stream`, followed by a\nnewline.  If `stream` is `None`, `sys.stdout` is used.  By default, elements\nare grouped in bytes (8 elements), and 8 bytes (64 elements) per line.\nNon-bitarray objects are printed by the standard library\nfunction `pprint.pprint()`.\n\n\n`make_endian(bitarray, endian, /)` -> bitarray\n\nWhen the endianness of the given bitarray is different from `endian`,\nreturn a new bitarray, with endianness `endian` and the same elements\nas the original bitarray.\nOtherwise (endianness is already `endian`) the original bitarray is returned\nunchanged.\n\n\n`rindex(bitarray, value=True, /)` -> int\n\nReturn the rightmost index of `bool(value)` in bitarray.\nRaises `ValueError` if the value is not present.\n\n\n`strip(bitarray, mode='right', /)` -> bitarray\n\nStrip zeros from left, right or both ends.\nAllowed values for mode are the strings: `left`, `right`, `both`\n\n\n`count_n(a, n, /)` -> int\n\nReturn the smallest index `i` for which `a[:i].count() == n`.\nRaises `ValueError`, when n exceeds total count (`a.count()`).\n\n\n`parity(a, /)` -> bool\n\nReturn the parity of bitarray `a`.  This is equivalent\nto `bool(a.count() % 2)` (but more efficient).\n\n\n`count_and(a, b, /)` -> int\n\nReturn `(a & b).count()` in a memory efficient manner,\nas no intermediate bitarray object gets created.\n\n\n`count_or(a, b, /)` -> int\n\nReturn `(a | b).count()` in a memory efficient manner,\nas no intermediate bitarray object gets created.\n\n\n`count_xor(a, b, /)` -> int\n\nReturn `(a ^ b).count()` in a memory efficient manner,\nas no intermediate bitarray object gets created.\n\n\n`subset(a, b, /)` -> bool\n\nReturn True if bitarray `a` is a subset of bitarray `b` (False otherwise).\n`subset(a, b)` is equivalent to `(a & b).count() == a.count()` but is more\nefficient since we can stop as soon as one mismatch is found, and no\nintermediate bitarray object gets created.\n\n\n`ba2hex(bitarray, /)` -> hexstr\n\nReturn a string containing the hexadecimal representation of\nthe bitarray (which has to be multiple of 4 in length).\n\n\n`hex2ba(hexstr, /, endian=None)` -> bitarray\n\nBitarray of hexadecimal representation.  hexstr may contain any number\n(including odd numbers) of hex digits (upper or lower case).\n\n\n`ba2int(bitarray, /, signed=False)` -> int\n\nConvert the given bitarray into an integer.\nThe bit-endianness of the bitarray is respected.\n`signed` indicates whether two's complement is used to represent the integer.\n\n\n`int2ba(int, /, length=None, endian=None, signed=False)` -> bitarray\n\nConvert the given integer to a bitarray (with given endianness,\nand no leading (big-endian) / trailing (little-endian) zeros), unless\nthe `length` of the bitarray is provided.  An `OverflowError` is raised\nif the integer is not representable with the given number of bits.\n`signed` determines whether two's complement is used to represent the integer,\nand requires `length` to be provided.\nIf signed is False and a negative integer is given, an OverflowError\nis raised.\n\n\n`serialize(bitarray, /)` -> bytes\n\nReturn a serialized representation of the bitarray, which may be passed to\n`deserialize()`.  It efficiently represents the bitarray object (including\nits endianness) and is guaranteed not to change in future releases.\n\n\n`deserialize(bytes, /)` -> bitarray\n\nReturn a bitarray given the bytes representation returned by `serialize()`.\n\n\n`huffman_code(dict, /, endian=None)` -> dict\n\nGiven a frequency map, a dictionary mapping symbols to their frequency,\ncalculate the Huffman code, i.e. a dict mapping those symbols to\nbitarrays (with given endianness).  Note that the symbols may be any\nhashable object (including `None`).\n\n\nChange log\n----------\n\n2021-04-XX   1.8.3:\n\n  * documentation and tests\n\n\n*1.8.2* (2021-03-31):\n\n  * fix crash caused by unsupported types in binary operations, #116\n  * speedup initializing or extending a bitarray from another with different\n    bit endianness\n  * add formatting options to `bitarray.util.pprint()`\n  * add documentation on [bitarray representations](examples/represent.md)\n  * add and improve tests (all 291 tests run in less than half a second on\n    a modern machine)\n\n\n*1.8.1* (2021-03-25):\n\n  * moved implementation of and `hex2ba()` and `ba2hex()` to C-level\n  * add `bitarray.util.parity()`\n\n\n*1.8.0* (2021-03-21):\n\n  * add `bitarray.util.serialize()` and `bitarray.util.deserialize()`\n  * allow whitespace (ignore space and `\\n\\r\\t\\v`) in input strings,\n    e.g. `bitarray('01 11')` or `a += '10 00'`\n  * add `bitarray.util.pprint()`\n  * When initializing a bitarray from another with different bit endianness,\n    e.g. `a = bitarray('110', 'little')` and `b = bitarray(a, 'big')`,\n    the buffer used to be simply copied, with consequence that `a == b` would\n    result in `False`.  This is fixed now, that is `a == b` will always\n    evaluate to `True`.\n  * add example showing how to [jsonize bitarrays](examples/extend_json.py)\n  * add tests\n\n\n*1.7.1* (2021-03-12):\n\n  * fix issue #114, raise TypeError when incorrect index is used during\n    assignment, e.g. `a[1.5] = 1`\n  * raise TypeError (not IndexError) when assigning slice to incorrect type,\n    e.g. `a[1:4] = 1.2`\n  * improve some docstrings and tests\n\n\n*1.7.0* (2021-02-27):\n\n  * add `bitarray.util.urandom()`\n  * raise TypeError when trying to extend bitarrays from bytes on Python 3,\n    ie. `bitarray(b'011')` and `.extend(b'110')`.  (Deprecated since 1.4.1)\n\n\n*1.6.3* (2021-01-20):\n\n  * add missing .h files to sdist tarball, #113\n\n\n*1.6.2* (2021-01-20):\n\n  * use `Py_SET_TYPE()` and `Py_SET_SIZE()` for Python 3.10, #109\n  * add official Python 3.10 support\n  * fix slice assignment to same object,\n    e.g. `a[2::] = a` or `a[::-1] = a`, #112\n  * add bitarray.h, #110\n\n\n*1.6.1* (2020-11-05):\n\n  * use PyType_Ready for all types: bitarray, bitarrayiterator,\n    decodeiterator, decodetree, searchiterator\n\n\n*1.6.0* (2020-10-17):\n\n  * add `decodetree` object, for speeding up consecutive calls\n    to `.decode()` and `.iterdecode()`, in particular when dealing\n    with large prefix codes, see #103\n  * add optional parameter to `.tolist()` which changes the items in the\n    returned list to integers (0 or 1), as opposed to Booleans\n  * remove deprecated `bitdiff()`, which has been deprecated since version\n    1.2.0, use `bitarray.util.count_xor()` instead\n  * drop Python 2.6 support\n  * update license file, #104\n\n\n*1.5.3* (2020-08-24):\n\n  * add optional index parameter to `.index()` to invert single bit\n  * fix `sys.getsizeof(bitarray)` by adding `.__sizeof__()`, see issue #100\n\n\n*1.5.2* (2020-08-16):\n\n  * add PyType_Ready usage, issue #66\n  * speedup search() for bitarrays with length 1 in sparse bitarrays,\n    see issue #67\n  * add tests\n\n\n*1.5.1* (2020-08-10):\n\n  * support signed integers in `util.ba2int()` and `util.int2ba()`,\n    see issue #85\n  * deprecate `.length()` in favor of `len()`\n\n\n*1.5.0* (2020-08-05):\n\n  * Use `Py_ssize_t` for bitarray index.  This means that on 32bit\n    systems, the maximum number of elements in a bitarray is 2 GBits.\n    We used to have a special 64bit index type for all architectures, but\n    this prevented us from using Python's sequence, mapping and number\n    methods, and made those method lookups slow.\n  * speedup slice operations when step size = 1 (if alignment allows\n    copying whole bytes)\n  * Require equal endianness for operations: `&`, `|`, `^`, `&=`, `|=`, `^=`.\n    This should have always been the case but was overlooked in the past.\n  * raise TypeError when trying to create bitarray from boolean\n  * This will be last release to still support Python 2.6 (which was retired\n    in 2013).  We do NOT plan to stop support for Python 2.7 anytime soon.\n\n\nPlease find the complete change log [here](https://github.com/ilanschnell/bitarray/blob/master/CHANGE_LOG).",
    "description_content_type": "",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://github.com/ph4r05/bitarray",
    "keywords": "",
    "license": "PSF",
    "maintainer": "Dusan Klinec (ph4r05)",
    "maintainer_email": "dusan.klinec@gmail.com",
    "name": "bitarray-ph4",
    "package_url": "https://pypi.org/project/bitarray-ph4/",
    "platform": "",
    "project_url": "https://pypi.org/project/bitarray-ph4/",
    "project_urls": {
      "Homepage": "https://github.com/ph4r05/bitarray"
    },
    "release_url": "https://pypi.org/project/bitarray-ph4/1.9.1/",
    "requires_dist": null,
    "requires_python": "",
    "summary": "efficient arrays of booleans -- C extension",
    "version": "1.9.1",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 9946043,
  "releases": {
    "0.8.10": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "e7816355fe58e711742c0e736a93f869676bd2602d04749b53f07a6da3865849",
          "md5": "03d9e73616e095bbf8617ec2a4ae267d",
          "sha256": "c0b43f397d95f73770c12ea636d8dd11a63bd6a9edbc6ea167867ac34a04fa75"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.10.tar.gz",
        "has_sig": false,
        "md5_digest": "03d9e73616e095bbf8617ec2a4ae267d",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49913,
        "upload_time": "2017-03-14T22:50:47",
        "upload_time_iso_8601": "2017-03-14T22:50:47.093590Z",
        "url": "https://files.pythonhosted.org/packages/e7/81/6355fe58e711742c0e736a93f869676bd2602d04749b53f07a6da3865849/bitarray_ph4-0.8.10.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.11": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "b96aaab98a2cfbec402dff1610aa392552a2742b25903428c1a57534e70c8d41",
          "md5": "a2708f3cfab1241b332ed670dc9bb9b4",
          "sha256": "2e0acd76655978b91d8dc7bd69a959b37c065311d0f498f177b6142b90f7b75e"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.11.tar.gz",
        "has_sig": false,
        "md5_digest": "a2708f3cfab1241b332ed670dc9bb9b4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49945,
        "upload_time": "2017-03-14T22:58:46",
        "upload_time_iso_8601": "2017-03-14T22:58:46.347766Z",
        "url": "https://files.pythonhosted.org/packages/b9/6a/aab98a2cfbec402dff1610aa392552a2742b25903428c1a57534e70c8d41/bitarray_ph4-0.8.11.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.12": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "be67c85beff2094ca8d64899e25cc73381000f4965f6af4445dfb61b768106db",
          "md5": "fbb9229eee84b707ef85527914fcaac7",
          "sha256": "8b44e3bd79566aa554f901dedfc31e94ad1f1923e200900647468b84f09f4284"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.12.tar.gz",
        "has_sig": true,
        "md5_digest": "fbb9229eee84b707ef85527914fcaac7",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49380,
        "upload_time": "2019-11-26T09:41:37",
        "upload_time_iso_8601": "2019-11-26T09:41:37.948466Z",
        "url": "https://files.pythonhosted.org/packages/be/67/c85beff2094ca8d64899e25cc73381000f4965f6af4445dfb61b768106db/bitarray_ph4-0.8.12.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.13": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "67202b19f9275f6fa5b470062d614c0b1f7180d0edf091b26a260c02340da5f2",
          "md5": "ae7829283eae78d763e7c4e7d8d4fa76",
          "sha256": "5f1ae9160e487674e2322bf075e84a0b1d9d808c343f6a4e17e1a459b6986d41"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.13.tar.gz",
        "has_sig": true,
        "md5_digest": "ae7829283eae78d763e7c4e7d8d4fa76",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 49361,
        "upload_time": "2019-11-26T09:47:05",
        "upload_time_iso_8601": "2019-11-26T09:47:05.937036Z",
        "url": "https://files.pythonhosted.org/packages/67/20/2b19f9275f6fa5b470062d614c0b1f7180d0edf091b26a260c02340da5f2/bitarray_ph4-0.8.13.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "1f678cbd6624574d5683a6f7899175028b24d9068f8ec893216356d7d582a104",
          "md5": "85191965a3a61c295697119c85161960",
          "sha256": "f1f4dbc63fe3b329bb194a2ada23993d5217452fbcf73ee5ce24cc9b56acd130"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.3.tar.gz",
        "has_sig": false,
        "md5_digest": "85191965a3a61c295697119c85161960",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 36927,
        "upload_time": "2017-01-16T23:14:00",
        "upload_time_iso_8601": "2017-01-16T23:14:00.313435Z",
        "url": "https://files.pythonhosted.org/packages/1f/67/8cbd6624574d5683a6f7899175028b24d9068f8ec893216356d7d582a104/bitarray_ph4-0.8.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "79b34d2a4631f92e96b35028e979f49bdef5ef0de49909df607399970ad97f45",
          "md5": "2c97e0b4f12d912507a9065bf7856220",
          "sha256": "61833f5306f28e3bfe4601b9c6bd4f1d5ce70000d88800f3446e90eae279b42f"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.4.tar.gz",
        "has_sig": false,
        "md5_digest": "2c97e0b4f12d912507a9065bf7856220",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 38314,
        "upload_time": "2017-01-17T14:03:33",
        "upload_time_iso_8601": "2017-01-17T14:03:33.353292Z",
        "url": "https://files.pythonhosted.org/packages/79/b3/4d2a4631f92e96b35028e979f49bdef5ef0de49909df607399970ad97f45/bitarray_ph4-0.8.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.5": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6bbe8f73ea5d34f1b1da7e52ddb1086703489f76cbf12c81098243c64f8f2d36",
          "md5": "5a018a5cb0a98a04c1a222d409586794",
          "sha256": "3042dd0706a8878766778b3b222c0c6a3fbdc36393b4ba65f9bf1d13146077c8"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.5.tar.gz",
        "has_sig": false,
        "md5_digest": "5a018a5cb0a98a04c1a222d409586794",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 40548,
        "upload_time": "2017-01-22T15:32:34",
        "upload_time_iso_8601": "2017-01-22T15:32:34.488729Z",
        "url": "https://files.pythonhosted.org/packages/6b/be/8f73ea5d34f1b1da7e52ddb1086703489f76cbf12c81098243c64f8f2d36/bitarray_ph4-0.8.5.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.6": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ab909b3e9a7900d327d1e9da03f0b3f542aa6e13ed7da2b629f485eeca7e90af",
          "md5": "89c331533483eb0c5904b230ede64e7b",
          "sha256": "1b4e1374f6a9ec3d1df0b9da3579f43565be70770e512d42e78cb6ce02eb85c2"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.6.tar.gz",
        "has_sig": false,
        "md5_digest": "89c331533483eb0c5904b230ede64e7b",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 40971,
        "upload_time": "2017-01-22T16:19:24",
        "upload_time_iso_8601": "2017-01-22T16:19:24.239259Z",
        "url": "https://files.pythonhosted.org/packages/ab/90/9b3e9a7900d327d1e9da03f0b3f542aa6e13ed7da2b629f485eeca7e90af/bitarray_ph4-0.8.6.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.8.7": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "082e18470481f87f6d280f912c30bb272e440e2ea87c14bfc49d9a8205c878d4",
          "md5": "19b4e473405fe88f165e3fa5c7f7dcb5",
          "sha256": "ba0b6b910bce30ceb3de56b1c8f419b8d50fe91024530d4624651d9b1cd359a2"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-0.8.7.tar.gz",
        "has_sig": false,
        "md5_digest": "19b4e473405fe88f165e3fa5c7f7dcb5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 47069,
        "upload_time": "2017-02-21T21:10:25",
        "upload_time_iso_8601": "2017-02-21T21:10:25.176952Z",
        "url": "https://files.pythonhosted.org/packages/08/2e/18470481f87f6d280f912c30bb272e440e2ea87c14bfc49d9a8205c878d4/bitarray_ph4-0.8.7.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "370e385a37d6c58d47b6ee4be5ec68f05964d8a901901a789b00f996a8b04b6d",
          "md5": "4b70971e212bc5f6a505145fa80f6f88",
          "sha256": "782cfe014c1b458b82880da77c36008d6541225cf55280b3d5683226353e29af"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.2.2.tar.gz",
        "has_sig": true,
        "md5_digest": "4b70971e212bc5f6a505145fa80f6f88",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 59554,
        "upload_time": "2020-01-15T09:11:39",
        "upload_time_iso_8601": "2020-01-15T09:11:39.087160Z",
        "url": "https://files.pythonhosted.org/packages/37/0e/385a37d6c58d47b6ee4be5ec68f05964d8a901901a789b00f996a8b04b6d/bitarray_ph4-1.2.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.2.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "79b0cd29b14210d620a5665bbfc1782067a5335fd8c70f235754c7654990c637",
          "md5": "59a15ec9850d8fd099f8200e95f5852f",
          "sha256": "3fe256b0abfcaa58a0dc3171eba923db438dfc6152d691e2355f3220cd0cde5e"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.2.3.tar.gz",
        "has_sig": true,
        "md5_digest": "59a15ec9850d8fd099f8200e95f5852f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 63644,
        "upload_time": "2020-01-22T22:41:32",
        "upload_time_iso_8601": "2020-01-22T22:41:32.790178Z",
        "url": "https://files.pythonhosted.org/packages/79/b0/cd29b14210d620a5665bbfc1782067a5335fd8c70f235754c7654990c637/bitarray_ph4-1.2.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a780acbb67369cb1c48a2a4b13ce7613c758b2ed845265538a86c10481e62998",
          "md5": "e7d66d3d5f635d91fdeaa609bdfa949a",
          "sha256": "3e2815dbd039845387369819cec7cb154e1691e80e92f9494d02b8adc9006b4e"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.6.2-cp37-cp37m-macosx_10_14_x86_64.whl",
        "has_sig": true,
        "md5_digest": "e7d66d3d5f635d91fdeaa609bdfa949a",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 74075,
        "upload_time": "2021-01-20T13:14:44",
        "upload_time_iso_8601": "2021-01-20T13:14:44.774882Z",
        "url": "https://files.pythonhosted.org/packages/a7/80/acbb67369cb1c48a2a4b13ce7613c758b2ed845265538a86c10481e62998/bitarray_ph4-1.6.2-cp37-cp37m-macosx_10_14_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "0bbbac31b699eb45700ae1707f094b42d66e7642fc424792c243904542e7d461",
          "md5": "40c428d6673114dc606143432b3653f5",
          "sha256": "a61af6cbc1d8e96e64788583f7b897451bbd3f5708cce6c60ba7708c19bb65be"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.6.2.tar.gz",
        "has_sig": true,
        "md5_digest": "40c428d6673114dc606143432b3653f5",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 74422,
        "upload_time": "2021-01-20T13:14:46",
        "upload_time_iso_8601": "2021-01-20T13:14:46.743364Z",
        "url": "https://files.pythonhosted.org/packages/0b/bb/ac31b699eb45700ae1707f094b42d66e7642fc424792c243904542e7d461/bitarray_ph4-1.6.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6a9c78f27eb4cf5b5d904d71a7f8c8707160c3ec0f1eb084b954a4a7ba9b8c21",
          "md5": "6e212c8a20a0e5c2b462304de77efcd8",
          "sha256": "20073569fa99fe1cc001ddfcaa4881828549486a846a6c55635bd11d062bbcb2"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.6.3-cp37-cp37m-macosx_10_14_x86_64.whl",
        "has_sig": true,
        "md5_digest": "6e212c8a20a0e5c2b462304de77efcd8",
        "packagetype": "bdist_wheel",
        "python_version": "cp37",
        "requires_python": null,
        "size": 74077,
        "upload_time": "2021-01-21T15:15:24",
        "upload_time_iso_8601": "2021-01-21T15:15:24.736061Z",
        "url": "https://files.pythonhosted.org/packages/6a/9c/78f27eb4cf5b5d904d71a7f8c8707160c3ec0f1eb084b954a4a7ba9b8c21/bitarray_ph4-1.6.3-cp37-cp37m-macosx_10_14_x86_64.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "118baa9dfeac69d319be91af8e37009b072cf755a5ac3dd3a8326695da8f63dc",
          "md5": "2ff324925b2a25d8f1841b6a935ef228",
          "sha256": "73b54e814389f9736dd27ffdc9ca25b9262bcf1f426b4396be04562de913f9b8"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.6.3.tar.gz",
        "has_sig": true,
        "md5_digest": "2ff324925b2a25d8f1841b6a935ef228",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 86087,
        "upload_time": "2021-01-21T15:15:27",
        "upload_time_iso_8601": "2021-01-21T15:15:27.137078Z",
        "url": "https://files.pythonhosted.org/packages/11/8b/aa9dfeac69d319be91af8e37009b072cf755a5ac3dd3a8326695da8f63dc/bitarray_ph4-1.6.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.6.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "331b823e0a5c8bb3b1024b007bd462181e4c31605b992b2ea5ca17e75ada1a32",
          "md5": "e27f0c6086330c3e8e9fa89101e94632",
          "sha256": "1487924c56cd591c1c856dfa983cadc102e73410c4ea65d05a275b2df896bd6f"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.6.4.tar.gz",
        "has_sig": true,
        "md5_digest": "e27f0c6086330c3e8e9fa89101e94632",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 86133,
        "upload_time": "2021-01-21T15:23:59",
        "upload_time_iso_8601": "2021-01-21T15:23:59.868594Z",
        "url": "https://files.pythonhosted.org/packages/33/1b/823e0a5c8bb3b1024b007bd462181e4c31605b992b2ea5ca17e75ada1a32/bitarray_ph4-1.6.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.9.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "11eff1a0b9b55d490281fdef387c139bad4438f950de0b9c7e2d1bdbe2431fe8",
          "md5": "d7eb3790792de01dd202fbb132b612d4",
          "sha256": "ffb836c4805d3e2eba0bb6a478b6878f669b94871a3f21a18c83b9399dbd9fe2"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.9.0.tar.gz",
        "has_sig": true,
        "md5_digest": "d7eb3790792de01dd202fbb132b612d4",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 98339,
        "upload_time": "2021-03-29T13:49:42",
        "upload_time_iso_8601": "2021-03-29T13:49:42.477057Z",
        "url": "https://files.pythonhosted.org/packages/11/ef/f1a0b9b55d490281fdef387c139bad4438f950de0b9c7e2d1bdbe2431fe8/bitarray_ph4-1.9.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.9.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3b521ef292d46351cac9a46405f093481e05c578d24617126bb50d0bff781dd4",
          "md5": "74d5aa35a08e2d7c6a210b30bfa18c0a",
          "sha256": "dbd46f6c476fe5eb2b819e4b6b02f08eed6d21aa9e70113ede3ad33d96dfccda"
        },
        "downloads": -1,
        "filename": "bitarray_ph4-1.9.1.tar.gz",
        "has_sig": true,
        "md5_digest": "74d5aa35a08e2d7c6a210b30bfa18c0a",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": null,
        "size": 96939,
        "upload_time": "2021-04-01T11:53:14",
        "upload_time_iso_8601": "2021-04-01T11:53:14.630813Z",
        "url": "https://files.pythonhosted.org/packages/3b/52/1ef292d46351cac9a46405f093481e05c578d24617126bb50d0bff781dd4/bitarray_ph4-1.9.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3b521ef292d46351cac9a46405f093481e05c578d24617126bb50d0bff781dd4",
        "md5": "74d5aa35a08e2d7c6a210b30bfa18c0a",
        "sha256": "dbd46f6c476fe5eb2b819e4b6b02f08eed6d21aa9e70113ede3ad33d96dfccda"
      },
      "downloads": -1,
      "filename": "bitarray_ph4-1.9.1.tar.gz",
      "has_sig": true,
      "md5_digest": "74d5aa35a08e2d7c6a210b30bfa18c0a",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": null,
      "size": 96939,
      "upload_time": "2021-04-01T11:53:14",
      "upload_time_iso_8601": "2021-04-01T11:53:14.630813Z",
      "url": "https://files.pythonhosted.org/packages/3b/52/1ef292d46351cac9a46405f093481e05c578d24617126bb50d0bff781dd4/bitarray_ph4-1.9.1.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}