{
  "info": {
    "author": "Noga Mudrik",
    "author_email": "<nmudrik1@jhmi.edu>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "Help on module basic_functions:\r\n\r\n**FUNCTIONS**\r\n\r\n    add_arrow(ax, start, end, arrowprops={'facecolor': 'black', 'width': 1.8, 'alpha': 0.5})\r\n        Add an arrow to the `ax` axis.\r\n        \r\n        Parameters\r\n        ----------\r\n        ax : matplotlib.axes._subplots.AxesSubplot\r\n            The axis to add the arrow to.\r\n        start : tuple of floats\r\n            The starting coordinates of the arrow in (x, y) format.\r\n        end : tuple of floats\r\n            The ending coordinates of the arrow in (x, y) format.\r\n        arrowprops : dict, optional\r\n            A dictionary of properties for the arrow, by default \r\n            {'facecolor': 'black', 'width': 1.8, 'alpha': 0.5}.\r\n            \r\n        Returns\r\n        -------\r\n        None\r\n    \r\n    \r\n    ------------------------------------------------------------------------------------------\r\n    add_dummy_sub_legend(ax, colors, lenf, label_base='f')\r\n        Add a sub-legend to the plot for the specified colors.\r\n        \r\n        Parameters:\r\n        - ax (matplotlib.axes.Axes): The matplotlib axes to add the sub-legend to.\r\n        - colors (list): A list of colors to add to the sub-legend.\r\n        - lenf (int): The number of colors to include in the sub-legend.\r\n        - label_base (str): The base string for the label of each color. (default: 'f')\r\n        \r\n        Returns: None\r\n    \r\n    ------------------------------------------------------------------------------------------\r\n    add_labels(ax, xlabel='X', ylabel='Y', zlabel='', title='', xlim=None, ylim=None, zlim=None, xticklabels=array([None], dtype=object), yticklabels=array([None], dtype=object), xticks=[], yticks=[], legend=[], ylabel_params={}, zlabel_params={}, xlabel_params={}, title_params={})\r\n        Add labels, titles, limits, etc. to a figure.\r\n        \r\n        Parameters:\r\n        ax (subplot): The subplot to be edited.\r\n        xlabel (str, optional): The label for the x-axis. Defaults to 'X'.\r\n        ylabel (str, optional): The label for the y-axis. Defaults to 'Y'.\r\n        zlabel (str, optional): The label for the z-axis. Defaults to ''.\r\n        title (str, optional): The title for the plot. Defaults to ''.\r\n        xlim (list or tuple, optional): The limits for the x-axis. Defaults to None.\r\n        ylim (list or tuple, optional): The limits for the y-axis. Defaults to None.\r\n        zlim (list or tuple, optional): The limits for the z-axis. Defaults to None.\r\n        xticklabels (array, optional): The labels for the x-axis tick marks. Defaults to np.array([None]).\r\n        yticklabels (array, optional): The labels for the y-axis tick marks. Defaults to np.array([None]).\r\n        xticks (list, optional): The positions for the x-axis tick marks. Defaults to [].\r\n        yticks (list, optional): The positions for the y-axis tick marks. Defaults to [].\r\n        legend (list, optional): The legend for the plot. Defaults to [].\r\n        ylabel_params (dict, optional): Additional parameters for the y-axis label. Defaults to {}.\r\n        zlabel_params (dict, optional): Additional parameters for the z-axis label. Defaults to {}.\r\n        xlabel_params (dict, optional): Additional parameters for the x-axis label. Defaults to {}.\r\n        title_params (dict, optional): Additional parameters for the title. Defaults to {}.\r\n    \r\n    ------------------------------------------------------------------------------------------\r\n    cal_next_FHN(v, w, dt=0.01, max_t=300, I_ext=0.5, b=0.7, a=0.8, tau=20)\r\n        Calculate next v and w values for FitzHugh-Nagumo dynamics\r\n        Inputs:\r\n            v: current v value\r\n            w: current w value\r\n            dt: time step\r\n            max_t: maximum time\r\n            I_ext: external current\r\n            b: model parameter\r\n            a: model parameter\r\n            tau: model parameter\r\n        Returns:\r\n            v_next: next v value\r\n            w_next: next w value\r\n    \r\n    ------------------------------------------------------------------------------------------\r\n    checkEmptyList(obj)\r\n        Parameters\r\n        ----------\r\n        obj : any type\r\n        \r\n        Returns\r\n        -------\r\n        Boolean variable (whether obj is a list)\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    check_save_name(save_name, invalid_signs='!@#$%^&*.,:;', addi_path=[], sep='\\\\')\r\n        Check if the given file name is valid and returns the final file name.\r\n        The function replaces invalid characters in the file name with underscores ('_').\r\n        \r\n        Parameters:\r\n        save_name (str): The name of the file to be saved.\r\n        invalid_signs (str, optional): A string of invalid characters. Defaults to '!@#$%^&*.,:;'.\r\n        addi_path (list, optional): A list of additional paths to be appended to the file name. Defaults to [].\r\n        sep (str, optional): The separator used between different elements of the path. Defaults to the system separator.\r\n        \r\n        Returns:\r\n        str: The final file name with invalid characters replaced and with additional path appended if provided.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    claculate_percent_close(reco, real, epsilon_close=0.1, return_quantiles=False, quantiles=[0.05, 0.95])\r\n        Calculate the ratio of close (within a specific distance) points among all dynamics' points.\r\n        \r\n        Parameters:\r\n        -----------\r\n        reco: k x T numpy array\r\n            The reconstructed dynamics matrix.\r\n        real: k x T numpy array\r\n            The real dynamics matrix (ground truth).\r\n        epsilon_close: float, optional (default: 0.1)\r\n            The threshold for distance.\r\n        return_quantiles: bool, optional (default: False)\r\n            Whether to return confidence interval values.\r\n        quantiles: list of float, optional (default: [0.05, 0.95])\r\n            The lower and higher limits for the quantiles.\r\n        \r\n        Returns:\r\n        --------\r\n        mean_close: float\r\n            The mean of the close enough points.\r\n        q1: float\r\n            The first quantile (only returned if `return_quantiles` is True).\r\n        q2: float\r\n            The second quantile (only returned if `return_quantiles` is True).\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    create_FHN(dt=0.01, max_t=100, I_ext=0.5, b=0.7, a=0.8, tau=20, v0=-0.5, w0=0, params={'exp_power': 0.9, 'change_speed': False})\r\n        Create the FitzHugh-Nagumo dynamics\r\n        Inputs:\r\n            dt: time step\r\n            max_t: maximum time\r\n            I_ext: external current\r\n            b: model parameter\r\n            a: model parameter\r\n            tau: model parameter\r\n            v0: initial condition for v\r\n            w0: initial condition for w\r\n            params: dictionary of additional parameters\r\n                exp_power: power to raise time to for non-uniform time\r\n                change_speed: Boolean to determine whether to change time speed\r\n        Returns:\r\n            v_full: list of v values at each time step\r\n            w_full: list of w values at each time step\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    create_ax(ax, nums=(1, 1), size=(10, 10), proj='d2', return_fig=False, sharey=False, sharex=False, fig=[])\r\n        Create axes in the figure for plotting.\r\n        \r\n        Parameters:\r\n        ax (list or Axes): List of Axes objects or a single Axes object\r\n        nums (tuple): Number of rows and columns for the subplots (default (1,1))\r\n        size (tuple): Size of the figure (default (10,10))\r\n        proj (str): Projection type ('d2' for 2D or 'd3' for 3D) (default 'd2')\r\n        return_fig (bool): Return the figure object in addition to the Axes object (default False)\r\n        sharey (bool): Share y axis between subplots (default False)\r\n        sharex (bool): Share x axis between subplots (default False)\r\n        fig (Figure): Figure object\r\n        \r\n        Returns:\r\n        Axes or tuple: The Axes object(s) for plotting\r\n    \r\n    create_colors(len_colors, perm=[0, 1, 2])\r\n        Create a set of discrete colors with a one-directional order\r\n        Input: \r\n            len_colors = number of different colors needed\r\n        Output:\r\n            3 X len_colors matrix decpiting the colors in the cols\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    create_dynamics(type_dyn='cyl', max_time=1000, dt=0.01, change_speed=False, t_speed=<ufunc 'exp'>, axis_speed=[], t_speed_params={}, to_cent=False, return_3d=False, return_additional=False, params_ex={})\r\n        Create ground truth dynamics\r\n        dyn_type options:\r\n            cyl\r\n            f_spiral\r\n            df_spiral\r\n    ------------------------------------------------------------------------------------------    \r\n    create_lorenz_mat(t=[], initial_conds=(0.0, 1.0, 1.05), txy=[])\r\n        Create the lorenz dynamics\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    create_orth_F(num_subdyns, num_neurons, evals=[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], seed_f=0, dist_type='random')\r\n        Create orthogonal matrices.\r\n        \r\n        Parameters:\r\n        num_subdyns (int): Number of sub-dynamics\r\n        num_neurons (int): Number of neurons\r\n        evals (list): List of eigenvalues.\r\n        seed_f (int): Seed for the random number generator (default 0)\r\n        dist_type (str): Distribution type ('random')\r\n        \r\n        Returns:\r\n        list: List of orthogonal matrices\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    create_rotation_mat(theta=0, axes='x', dims=3)\r\n        Create a rotation matrix based on the given parameters.\r\n        \r\n        Parameters:\r\n        theta (float, optional): Angle in radians for rotation. Default is 0.\r\n        axes (str, optional): Axis for rotation. Must be one of 'x', 'y' or 'z'. Default is 'x'.\r\n        dims (int, optional): Dimension of the rotation. Must be either 2 or 3. Default is 3.\r\n        \r\n        Returns:\r\n        numpy.ndarray: Rotation matrix of shape (dims, dims).\r\n        \r\n        Raises:\r\n        ValueError: If dims is not 2 or 3.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    find_closest(vec1, vec2, metric='mse')\r\n        Find the closest elements in vec2 for each element in vec1.\r\n        \r\n        Parameters:\r\n        vec1 (ndarray): 1-D numpy array\r\n        vec2 (ndarray): 1-D numpy array\r\n        metric (str): Metric to use for comparison, 'mse' by default\r\n        \r\n        Returns:\r\n        tuple:\r\n            - ndarray: closest elements in vec2 for each element in vec1\r\n            - ndarray: indices of closest elements in vec2 for each element in vec1\r\n        \r\n        Example:\r\n            find_closest([1, 2, 3], [0, 4, 5]) -> ([0, 4, 5], [0, 1, 2])\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    find_dominant_row(coefficients)\r\n        This function returns the row index of the largest absolute value of each column in the input 2D numpy array \"coefficients\".\r\n        \r\n        Inputs:\r\n            coefficients - a 2D numpy array of shape (m, n) where m is the number of rows and n is the number of columns.\r\n            \r\n        Outputs:\r\n            domi - a 1D numpy array of shape (n,) where each element is an integer representing the row index of the largest absolute value of each column.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    \r\n    find_perpendicular(d1, d2, perp_length=1, prev_v=[], next_v=[], ref_point=[], choose_meth='intersection', initial_point='mid', direction_initial='low', return_unchose=False, layer_num=0)\r\n        IT IS AN INTER FUNCTION - DO NOT USE IT BY ITSELF\r\n        This function find the 2 point of the orthogonal vector to a vector defined by points d1,d2\r\n        d1 =                first data point\r\n        d2 =                second data point\r\n        perp_length =       desired width\r\n        prev_v =            previous value of v. Needed only if choose_meth == 'prev'\r\n        next_v =            next value of v. Needed only if choose_meth == 'prev'\r\n        ref_point =         reference point for the 'smooth' case, or for 2nd+ layers\r\n        choose_meth =       'intersection' (eliminate intersections) OR 'smooth' (smoothing with previous prediction) OR 'prev' (eliminate convexity)\r\n        direction_initial = to which direction take the first perp point  \r\n        return_unchose =    whether to return unchosen directions\r\n    \r\n    ------------------------------------------------------------------------------------------    \r\n    flip_power(x1, x2)\r\n        This function takes two arguments, x1 and x2, and returns the result of x2 raised to the power of x1 using the numpy.power function.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    init_mat(size_mat, r_seed=0, dist_type='norm', init_params={'loc': 0, 'scale': 1}, normalize=False)\r\n        This is an initialization function to initialize matrices. \r\n        Inputs:\r\n          size_mat    = 2-element tuple or list, describing the shape of the mat\r\n          r_seed      = random seed (should be integer)\r\n          dist_type   = distribution type for initialization; can be 'norm' (normal dist), 'uni' (uniform dist),'inti', 'sparse', 'regional', 'zeros'\r\n          init_params = a dictionary with params for initialization. The keys depends on 'dist_type'.\r\n                        keys for norm -> ['loc','scale']\r\n                        keys for inti and uni -> ['low','high']\r\n                        keys for sparse -> ['k'] -> number of non-zeros in each row\r\n                        keys for regional -> ['k'] -> repeats of the sub-dynamics allocations\r\n          normalize   = whether to normalize the matrix\r\n        Output:\r\n            the random matrix with size 'size_mat'\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    lists2list(xss)\r\n        Flatten a list of lists into a single list.\r\n        \r\n        Parameters\r\n        ----------\r\n        xss : list of lists\r\n            The list of lists to be flattened.\r\n        \r\n        Returns\r\n        -------\r\n        list\r\n            The flattened list.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    load_mat_file(mat_name, mat_path='', sep='\\\\')\r\n        Load a MATLAB `.mat` file. Useful for uploading the C. elegans data.\r\n        \r\n        Parameters:\r\n        -----------\r\n        mat_name: str\r\n            The name of the MATLAB file.\r\n        mat_path: str, optional (default: '')\r\n            The path to the MATLAB file.\r\n        sep: str, optional (default: the system separator)\r\n            The separator to use in the file path.\r\n        \r\n        Returns:\r\n        --------\r\n        data_dict: dict\r\n            A dictionary containing the contents of the MATLAB file.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    load_pickle(path)\r\n        Load a pickled object from disk.\r\n        \r\n        Parameters:\r\n        path (str): The path to the pickled object.\r\n        \r\n        Returns:\r\n        dct (obj): The loaded object.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    load_vars(folders_names, save_name, sep='\\\\', ending='.pkl', full_name=False)\r\n        Load results previously saved.\r\n        \r\n        Parameters:\r\n        folders_names (str/list): List of folders to form the path or a string representation of the path\r\n        save_name (str): Name of the saved file\r\n        sep (str): Separator to join the folders\r\n        ending (str): File extension of the saved file\r\n        full_name (bool): If True, folders_names and sep are ignored\r\n        \r\n        Example:\r\n            load_vars('' ,  'save_c.pkl' ,sep=sep , ending = '.pkl',full_name = False)\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    lorenz(x, y, z, s=10, r=25, b=2.667)\r\n        Given:\r\n           x, y, z: a point of interest in three dimensional space\r\n           s, r, b: parameters defining the lorenz attractor\r\n        Returns:\r\n           x_dot, y_dot, z_dot: values of the lorenz attractor's partial\r\n               derivatives at the point x, y, z\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    mean_change(signal, axis=0)\r\n        Calculate the mean change of the signal along the specified axis.\r\n        \r\n        Parameters\r\n        ----------\r\n        signal : numpy.ndarray\r\n            The signal data.\r\n        axis : int, optional\r\n            The axis along which the mean change is calculated, by default 0.\r\n        \r\n        Returns\r\n        -------\r\n        numpy.ndarray\r\n            The mean change of the signal.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    min_dist(dotA1, dotA2, dotB1, dotB2, num_sects=500)\r\n        Calculates the minimum euclidean distance between two discrete lines (e.g. where they intersect?).\r\n        Inputs:\r\n            dotA1: Tuple of x,y coordinate of first point on line A\r\n            dotA2: Tuple of x,y coordinate of second point on line A\r\n            dotB1: Tuple of x,y coordinate of first point on line B\r\n            dotB2: Tuple of x,y coordinate of second point on line B\r\n            num_sects: Number of sections the lines should be divided into to calculate distance\r\n            \r\n        Returns:\r\n            List of minimum distances between two lines.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    movmfunc(func, mat, window=3, direction=0, dist='uni')\r\n        moving window with applying the function func on the matrix 'mat' towrads the direction 'direction'\r\n        dist: can be 'uni' (uniform) or 'gaus' (Gaussian)\r\n        \r\n        Calculates the moving window with the application of the given function `func` on the matrix `mat` in the direction `direction`.\r\n        \r\n        Parameters:\r\n        - func (callable): The function to apply.\r\n        - mat (numpy.ndarray): The matrix to apply the function to.\r\n        - window (int): The size of the moving window. (default: 3)\r\n        - direction (int): The direction to apply the moving window. 0 for row-wise and 1 for column-wise. (default: 0)\r\n        - dist (str): The distribution to use for weighting. Can be 'uni' for uniform or 'gaus' for Gaussian. (default: 'uni')\r\n        \r\n        Returns:\r\n        numpy.ndarray: The result of applying the moving window to `mat`.\r\n        \r\n        Example:\r\n        >>> import numpy as np\r\n        >>> def myfunc(arr, axis=None):\r\n        ...     return np.sum(arr, axis=axis)\r\n        >>> mat = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\r\n        >>> movmfunc(myfunc, mat, window=3, direction=0, dist='uni')\r\n        array([[ 6.,  9., 12.],\r\n               [15., 18., 21.],\r\n               [ 9., 12., 15.]])\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    norm_coeffs(coefficients, type_norm, same_width=True, width_des=0.7, factor_power=0.9, min_width=0.01)\r\n        Normalize the coefficients according to the specified type of normalization.\r\n        \r\n        Parameters\r\n        ----------\r\n        coefficients : numpy.ndarray\r\n            The coefficients to be normalized.\r\n        type_norm : str\r\n            The type of normalization to be applied. Can be 'sum_abs', 'norm', 'abs' or 'no_norm'.\r\n        same_width : bool, optional\r\n            Whether to enforce the same width for all coefficients, by default True.\r\n        width_des : float, optional\r\n            The desired width, by default 0.7.\r\n        factor_power : float, optional\r\n            The power factor to apply, by default 0.9.\r\n        min_width : float, optional\r\n            The minimum width allowed, by default 0.01.\r\n        \r\n        Returns\r\n        -------\r\n        numpy.ndarray\r\n            The normalized coefficients.\r\n        \r\n        Raises\r\n        ------\r\n        NameError\r\n            If the `type_norm` value is not one of the allowed values ('sum_abs', 'norm', 'abs' or 'no_norm').\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    norm_mat(mat, type_norm='evals', to_norm=True)\r\n        This function comes to norm matrices by the highest eigen-value\r\n        Inputs:\r\n            mat       = the matrix to norm\r\n            type_norm = what type of normalization to apply. Can be 'evals' (divide by max eval), 'max' (divide by max value), 'exp' (matrix exponential)\r\n            to_norm   = whether to norm or not to.\r\n        Output:  \r\n            the normalized matrix\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    norm_over_time(coefficients, type_norm='normal')\r\n        Normalize coefficients over time\r\n        Inputs:\r\n            coefficients: array of coefficients\r\n            type_norm: type of normalization\r\n                'normal': standard normalization\r\n        Returns:\r\n            coefficients_norm: normalized coefficients\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    nullify_part(f, axis='both', percent0=80)\r\n        Nullify a part of a matrix.\r\n        \r\n        Parameters:\r\n        f (numpy array): The input matrix\r\n        axis (str or int): The axis along which to perform the operation ('0', '1', or 'both') (default 'both')\r\n        percent0 (int): The percentile value used to determine which values to nullify (default 80)\r\n        \r\n        Returns:\r\n        numpy array: The input matrix with the specified values set to 0\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    plot_3d_color_scatter(latent_dyn, coefficients, ax=[], figsize=(15, 10), delta=0.4, colors=[])\r\n        Plot a 3D color scatter plot.\r\n        \r\n        Parameters\r\n        ----------\r\n        latent_dyn : numpy.ndarray\r\n            A 3xN numpy array representing the latent dynamics.\r\n        coefficients : numpy.ndarray\r\n            A KxN numpy array representing the coefficients.\r\n        ax : matplotlib.axes._subplots.AxesSubplot, optional\r\n            A 3D axis to plot on, by default []\r\n        figsize : tuple, optional\r\n            The size of the figure, by default (15, 10)\r\n        delta : float, optional\r\n            The delta between each row, by default 0.4\r\n        colors : list of str, optional\r\n            The colors for each row, by default []\r\n        \r\n        Returns\r\n        -------\r\n        None\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    plot_multi_colors(store_dict, min_time_plot=0, max_time_plot=-100, colors=['green', 'red', 'blue'], ax=[], fig=[], alpha=0.99, smooth_window=3, factor_power=0.9, coefficients_n=[], to_scatter=False, to_scatter_only_one=False, choose_meth='intersection', title='')\r\n        store_dict is a dictionary with the high estimation results. \r\n        example:        \r\n            store_dict , coefficients_n = calculate_high_for_all(coefficients,choose_meth = 'intersection',width_des = width_des, latent_dyn = latent_dyn, direction_initial = direction_initial,factor_power = factor_power, return_unchose=True)\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    quiver_plot(sub_dyn=[], xmin=-5, xmax=5, ymin=-5, ymax=5, ax=[], chosen_color='red', alpha=0.4, w=0.02, type_plot='quiver', zmin=-5, zmax=5, cons_color=False, return_artist=False, xlabel='x', ylabel='y', quiver_3d=False, inter=2, projection=[0, 1])\r\n        Plots a quiver or stream plot on the specified axis.\r\n        \r\n        Parameters\r\n        ----------\r\n        sub_dyn: numpy.ndarray, default: []\r\n            The matrix whose eigenvectors need to be plotted. If an empty list is provided, the default sub_dyn will be set to [[0,-1],[1,0]]\r\n        xmin: float, default: -5\r\n            The minimum value for x-axis.\r\n        xmax: float, default: 5\r\n            The maximum value for x-axis.\r\n        ymin: float, default: -5\r\n            The minimum value for y-axis.\r\n        ymax: float, default: 5\r\n            The maximum value for y-axis.\r\n        ax: matplotlib.axes._subplots.AxesSubplot or list, default: []\r\n            The axis on which the quiver or stream plot will be plotted. If a list is provided, a new figure will be created.\r\n        chosen_color: str or list, default: 'red'\r\n            The color of the quiver or stream plot. \r\n        alpha: float, default: 0.4\r\n            The alpha/transparency value of the quiver or stream plot.\r\n        w: float, default: 0.02\r\n            The width of the arrows in quiver plot.\r\n        type_plot: str, default: 'quiver'\r\n            The type of plot. Can either be 'quiver' or 'streamplot'.\r\n        zmin: float, default: -5\r\n            The minimum value for z-axis (for 3D plots).\r\n        zmax: float, default: 5\r\n            The maximum value for z-axis (for 3D plots).\r\n        cons_color: bool, default: False\r\n            If True, a constant color will be used for the stream plot. If False, the color will be proportional to the magnitude of the matrix.\r\n        return_artist: bool, default: False\r\n            If True, the artist instance is returned.\r\n        xlabel: str, default: 'x'\r\n            Label for x-axis.\r\n        ylabel: str, default: 'y'\r\n            Label for y-axis.\r\n        quiver_3d: bool, default: False\r\n            If True, a 3D quiver plot will be generated.\r\n        inter: float, default: 2\r\n            The step size for the grids in 3D plots.\r\n        projection: list, default: [0,1]\r\n            The indices of the columns in sub_dyn that will be used for plotting.\r\n            \r\n        Returns\r\n        -------\r\n        h: matplotlib.quiver.Quiver or matplotlib.streamplot.Streamplot\r\n            The artist instance, if return_artist is True.\r\n    \r\n    ------------------------------------------------------------------------------------------    \r\n    red_mean(mat, axis=1)\r\n        Subtract the mean of each row or column in a matrix.\r\n        \r\n        Parameters:\r\n        mat (np.ndarray): The input matrix.\r\n        axis (int, optional): The axis along which the mean should be computed. Default is 1 (mean of each row).\r\n        \r\n        Returns:\r\n        np.ndarray: The matrix with each row or column mean subtracted.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    relative_eror(reco, real, return_mean=True, func=<function nanmean at 0x000001AADA09DA20>)\r\n        Calculate the relative reconstruction error\r\n        Inputs:\r\n            reco: k X T reconstructed dynamics matrix\r\n            real: k X T real dynamics matrix (ground truth)\r\n            return_mean: reaturn the average of the reconstruction error over time\r\n            func: the function to apply on the relative error of each point\r\n        Output:\r\n            the relative error (or the mean relative error over time if return_mean)\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    remove_background(ax, grid=False, axis_off=True)\r\n        Remove the background of a figure.\r\n        \r\n        Parameters:\r\n        ax (subplot): The subplot to be edited.\r\n        grid (bool, optional): Whether to display grid lines. Defaults to False.\r\n        axis_off (bool, optional): Whether to display axis lines. Defaults to True.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    remove_edges(ax, include_ticks=False, top=False, right=False, bottom=False, left=False)\r\n        Remove the specified edges (spines) of the plot and optionally the ticks of the plot.\r\n        \r\n        Parameters\r\n        ----------\r\n        ax : matplotlib.axes.Axes\r\n            The matplotlib axes object of the plot.\r\n        include_ticks : bool, optional\r\n            Whether to include the ticks, by default False.\r\n        top : bool, optional\r\n            Whether to remove the top edge, by default False.\r\n        right : bool, optional\r\n            Whether to remove the right edge, by default False.\r\n        bottom : bool, optional\r\n            Whether to remove the bottom edge, by default False.\r\n        left : bool, optional\r\n            Whether to remove the left edge, by default False.\r\n        \r\n        Returns\r\n        -------\r\n        None\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    rgb_to_hex(rgb_vec)\r\n        Convert a RGB vector to a hexadecimal color code.\r\n        \r\n        Parameters:\r\n        rgb_vec (list): A 3-element list of floats representing the red, green, and blue components of the color. The values should be between 0 and 1.\r\n        \r\n        Returns:\r\n        str: The hexadecimal color code as a string.\r\n        \r\n        Example:\r\n        >>> rgb_to_hex([0.5, 0.2, 0.8])\r\n        '#8033CC'\r\n    ------------------------------------------------------------------------------------------    \r\n    saveLoad(opt, filename)\r\n        Save or load a global variable 'calc'\r\n        \r\n        Parameters\r\n        ----------\r\n        opt : str\r\n            the option, either \"save\" or \"load\"\r\n        filename : str\r\n            the name of the file to save or load from\r\n            \r\n        Returns\r\n        -------\r\n        None\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    save_file_dynamics(save_name, folders_names, to_save=[], invalid_signs='!@#$%^&*.,:;', sep='\\\\', type_save='.npy')\r\n        Save dynamics & model results to disk.\r\n        \r\n        Parameters:\r\n        save_name (str): The name of the file to save.\r\n        folders_names (List[str]): List of folder names where the file should be saved.\r\n        to_save (List, optional): List of values to save. Defaults to [].\r\n        invalid_signs (str, optional): String of invalid characters to be removed from the save name. Defaults to '!@#$%^&*.,:;'.\r\n        sep (str, optional): Separator to use when joining `folders_names`. Defaults to `os.sep`.\r\n        type_save (str, optional): The file format to save the data in. Valid options are '.npy' and '.pkl'. Defaults to '.npy'.\r\n        \r\n        Returns:\r\n        None\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    sigmoid(x, std=1)\r\n        This function computes the sigmoid function of a given input x, with a standard deviation \"std\". \r\n        Parameters\r\n        ----------\r\n        x : np.array / list\r\n        std :  The default is 1.\r\n        \r\n        Returns\r\n        -------\r\n        np.array\r\n            The sigmoid function maps any input value to the range of 0 and 1, making it useful for binary classification problems and as an activation function in neural networks.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    spec_corr(v1, v2, to_abs=True)\r\n        Compute the absolute value of the correlation between two arrays.\r\n        \r\n        Parameters:\r\n        - v1 (numpy.ndarray): The first array to compute the correlation between.\r\n        - v2 (numpy.ndarray): The second array to compute the correlation between.\r\n        - to_abs (bool): Whether to compute the absolute value of the correlation (default: True).\r\n        \r\n        Returns:\r\n        - float: The absolute value of the correlation between `v1` and `v2`.\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    str2bool(str_to_change)\r\n        Transform a string representation of a boolean value to a boolean variable.\r\n        \r\n        Parameters:\r\n        str_to_change (str): String representation of a boolean value\r\n        \r\n        Returns:\r\n        bool: Boolean representation of the input string\r\n        \r\n        Example:\r\n            str2bool('true') -> True\r\n\r\n    ------------------------------------------------------------------------------------------\r\n    visualize_dyn(dyn, ax=[], params_plot={}, turn_off_back=False, marker_size=10, include_line=False, color_sig=[], cmap='cool', return_fig=False, color_by_dominant=False, coefficients=[], figsize=(5, 5), colorbar=False, colors=[], vmin=None, vmax=None, color_mix=False, alpha=0.4, colors_dyns=array(['r', 'g', 'b', 'yellow'], dtype='<U6'), add_text='t ', text_points=[], fontsize_times=18, marker='o', delta_text=0.5, color_for_0=None, legend=[], fig=[], return_mappable=False, remove_back=True, edgecolors='none')\r\n        Plot the multi-dimensional dynamics\r\n        Inputs:\r\n            dyn          = dynamics to plot. Should be a np.array with size k X T\r\n            ax           = the subplot to plot in (optional)\r\n            params_plot  = additional parameters for the plotting (optional). Can include plotting-related keys like xlabel, ylabel, title, etc.\r\n            turn_off_back= disable backgroud of the plot? (optional). Boolean\r\n            marker_size  = marker size of the plot (optional). Integer\r\n            include_line = add a curve to the plot (in addition to the scatter plot). Boolean\r\n            color_sig    = the color signal. if empty and color_by_dominant - color by the dominant dynamics. If empty and not color_by_dominant - color by time.\r\n            cmap         = cmap\r\n            colors       = if not empty -> pre-defined colors for the different sub-dynamics. Otherwise - colors are according to the cmap.\r\n            color_mix    = relevant only if  color_by_dominant. In this case the colors need to be in the form of [r,g,b]\r\n        Output:\r\n            (only if return_fig) -> returns the figure\r\n\r\n\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "basic-functions",
    "package_url": "https://pypi.org/project/basic-functions/",
    "platform": null,
    "project_url": "https://pypi.org/project/basic-functions/",
    "project_urls": null,
    "release_url": "https://pypi.org/project/basic-functions/0.0.4/",
    "requires_dist": [
      "numpy",
      "matplotlib",
      "scipy",
      "pandas",
      "webcolors",
      "qpsolvers",
      "seaborn",
      "colormap",
      "sklearn",
      "dill",
      "mat73",
      "easydev"
    ],
    "requires_python": ">=3.8",
    "summary": "very basic functions for data pre-processing and visualization",
    "version": "0.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 16652661,
  "releases": {
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f8acf355fdebca371de096ed6c1830bde1706e882b6bfcdcb75496e19bb25292",
          "md5": "5dc77b344cdb17d72431b741b12116a0",
          "sha256": "f68007048c2f84ffb8abf7dc9cecd6de7aea0f347d947ece442c599d1ad64bf7"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "5dc77b344cdb17d72431b741b12116a0",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 30503,
        "upload_time": "2023-02-01T14:28:08",
        "upload_time_iso_8601": "2023-02-01T14:28:08.948949Z",
        "url": "https://files.pythonhosted.org/packages/f8/ac/f355fdebca371de096ed6c1830bde1706e882b6bfcdcb75496e19bb25292/basic_functions-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5a3041b902e8b56ea108cdc443f0b4d0326a2b8164cc01fb8369ea602b81154d",
          "md5": "daff6a04bd1782ce6f194064413cbd54",
          "sha256": "e80b4a3155c646441ba4cb80b71e332a654af19f899e3c80172d16bb8b2b4274"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "daff6a04bd1782ce6f194064413cbd54",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 44199,
        "upload_time": "2023-02-01T14:28:10",
        "upload_time_iso_8601": "2023-02-01T14:28:10.889644Z",
        "url": "https://files.pythonhosted.org/packages/5a/30/41b902e8b56ea108cdc443f0b4d0326a2b8164cc01fb8369ea602b81154d/basic_functions-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6ab6324c71fbf7d0f2e4b381ed90e43e4bbde869008e0159c437a731ea9c185b",
          "md5": "306c3524b7474d54d6a367b0f67d748b",
          "sha256": "af8ca126b2249c7f581fe9ceebfad665d8912a1f3aba15c1ea653cc5546c6436"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "306c3524b7474d54d6a367b0f67d748b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 30433,
        "upload_time": "2023-02-01T14:33:35",
        "upload_time_iso_8601": "2023-02-01T14:33:35.084002Z",
        "url": "https://files.pythonhosted.org/packages/6a/b6/324c71fbf7d0f2e4b381ed90e43e4bbde869008e0159c437a731ea9c185b/basic_functions-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "6c0d99a45247341dc95e4ce63c37d73d710371d78059935e224e6ef5c476f793",
          "md5": "f1c9c7edc83f0cbabd1d03e15fc54303",
          "sha256": "1833e290fa24bc0ce93d723f0f0ab909cff5870ec1c4391e05ef92b159947ea3"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f1c9c7edc83f0cbabd1d03e15fc54303",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 44761,
        "upload_time": "2023-02-01T14:33:36",
        "upload_time_iso_8601": "2023-02-01T14:33:36.691873Z",
        "url": "https://files.pythonhosted.org/packages/6c/0d/99a45247341dc95e4ce63c37d73d710371d78059935e224e6ef5c476f793/basic_functions-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "c4e2bd6cb5e60472fe90c090ae1bfff0d1183577be788962bbd1e830f6460251",
          "md5": "c43d19e73f23376e6214eafb53876e5b",
          "sha256": "9bd64178c8311301ed7264b49c72c26f4f048a38f4dad3b51a89c40dea9d5e49"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "c43d19e73f23376e6214eafb53876e5b",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 30432,
        "upload_time": "2023-02-01T15:57:55",
        "upload_time_iso_8601": "2023-02-01T15:57:55.497102Z",
        "url": "https://files.pythonhosted.org/packages/c4/e2/bd6cb5e60472fe90c090ae1bfff0d1183577be788962bbd1e830f6460251/basic_functions-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "cb516a44b2e39aa1352fccb32a45cacd2ec47c5120262a7ec05862a797baef62",
          "md5": "aa5eaa8da538a5d321d4b997f2da3556",
          "sha256": "654aa9705c152ad456517922b6b42f793a04127ef0daeb1f5da0f7594c7b0bbb"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "aa5eaa8da538a5d321d4b997f2da3556",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 44758,
        "upload_time": "2023-02-01T15:57:56",
        "upload_time_iso_8601": "2023-02-01T15:57:56.995728Z",
        "url": "https://files.pythonhosted.org/packages/cb/51/6a44b2e39aa1352fccb32a45cacd2ec47c5120262a7ec05862a797baef62/basic_functions-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "995f88b80f49dfbf5da5dd6e859b99dd21b1fb804a24d9eb9d87ad4afc49c7e4",
          "md5": "861d7634c9aa7f440c3ad5d8939954a4",
          "sha256": "42d8ec565ec8364868ce0a8bedf399946fd204b0041dab7f13c8c61de6659a66"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "861d7634c9aa7f440c3ad5d8939954a4",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 30060,
        "upload_time": "2023-02-01T16:09:36",
        "upload_time_iso_8601": "2023-02-01T16:09:36.479228Z",
        "url": "https://files.pythonhosted.org/packages/99/5f/88b80f49dfbf5da5dd6e859b99dd21b1fb804a24d9eb9d87ad4afc49c7e4/basic_functions-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "3605f01a45817d9683dfaae5de5f3c8b1f9b46802811fd2fb3a8fa52b6215b2a",
          "md5": "8e4bd1ce51054821ff8f98f331b1430f",
          "sha256": "e465909200635674bf20e33ddd14381d366456ae6975ff94534d3f5035c4f3cc"
        },
        "downloads": -1,
        "filename": "basic_functions-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "8e4bd1ce51054821ff8f98f331b1430f",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 44366,
        "upload_time": "2023-02-01T16:09:37",
        "upload_time_iso_8601": "2023-02-01T16:09:37.994858Z",
        "url": "https://files.pythonhosted.org/packages/36/05/f01a45817d9683dfaae5de5f3c8b1f9b46802811fd2fb3a8fa52b6215b2a/basic_functions-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "995f88b80f49dfbf5da5dd6e859b99dd21b1fb804a24d9eb9d87ad4afc49c7e4",
        "md5": "861d7634c9aa7f440c3ad5d8939954a4",
        "sha256": "42d8ec565ec8364868ce0a8bedf399946fd204b0041dab7f13c8c61de6659a66"
      },
      "downloads": -1,
      "filename": "basic_functions-0.0.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "861d7634c9aa7f440c3ad5d8939954a4",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 30060,
      "upload_time": "2023-02-01T16:09:36",
      "upload_time_iso_8601": "2023-02-01T16:09:36.479228Z",
      "url": "https://files.pythonhosted.org/packages/99/5f/88b80f49dfbf5da5dd6e859b99dd21b1fb804a24d9eb9d87ad4afc49c7e4/basic_functions-0.0.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "3605f01a45817d9683dfaae5de5f3c8b1f9b46802811fd2fb3a8fa52b6215b2a",
        "md5": "8e4bd1ce51054821ff8f98f331b1430f",
        "sha256": "e465909200635674bf20e33ddd14381d366456ae6975ff94534d3f5035c4f3cc"
      },
      "downloads": -1,
      "filename": "basic_functions-0.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "8e4bd1ce51054821ff8f98f331b1430f",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 44366,
      "upload_time": "2023-02-01T16:09:37",
      "upload_time_iso_8601": "2023-02-01T16:09:37.994858Z",
      "url": "https://files.pythonhosted.org/packages/36/05/f01a45817d9683dfaae5de5f3c8b1f9b46802811fd2fb3a8fa52b6215b2a/basic_functions-0.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}