{
  "info": {
    "author": "",
    "author_email": "Rashid Harvey <rashid.harvey@fu-berlin.de>",
    "bugtrack_url": null,
    "classifiers": [
      "License :: OSI Approved :: MIT License",
      "Operating System :: OS Independent",
      "Programming Language :: Python :: 3"
    ],
    "description": "# A Simple PyGame ScreenRecorder\r\n\r\n## Why you should use this module?\r\n\r\n1. Relatively high accuracy\r\n2. No (noticable) performance issues\r\n3. Recording FPS is not bound to game FPS\r\n3. Straightforward usage\r\n4. Codebase is well commented and typed\r\n\r\n## Why you shouldn't use this module?\r\n\r\n1. The library is written in pure Python and therefore cannot compare with any lower level library.\r\n1. Everything is still in develompment.\r\n\r\n## Dependencies\r\n\r\nApart from pygame and python >=3.8\r\n\r\n1. opencv-python (includes numpy)\r\n2. FFmpeg if you want to save videos\r\n\r\n## Install\r\n\r\n`pip install pygame-screen-record`\r\n\r\n## FAQ\r\n\r\nSee the FAQ [in the wiki](https://github.com/theRealProHacker/PyGameRecorder/wiki/FAQ)\r\n\r\n## To-Dos\r\n\r\n2. Event recording (mouse, key, quit, etc.) ✔️\r\n3. Sound recording (Either event based with function hooking or as numpy arrays)\r\n4. A proper video player\r\n5. Add a wiki\r\n\r\n## Contributing\r\n\r\nFile any bugs or feature requests as GitHub issues. After your idea was approved, we can start working on a solution and make a pull request. The codebase is pretty simple and easy to get ahold of.\r\n\r\n# How To Use\r\n\r\nMost users just want to make a recording of their game and save it in a video file. Here comes how.\r\n\r\n> Note: I am using `pg` as an alias for `pygame` in the following code snippets and I `import ScreenRecorder` instead of `pygame_screen_record.ScreenRecorder`. \r\n\r\nA typical game script might look like this:\r\n\r\n```python\r\nimport pygame as pg\r\npg.init()\r\n\r\ninit_code()\r\n\r\ntry:\r\n    while True:\r\n        event_handling()\r\n        updating()\r\n        drawing()\r\nfinally:\r\n    clean_up()\r\n    pg.quit()\r\n```\r\n\r\nThe `try - finally - statement` is very important to catch any exceptions and clean up whether the game ended naturely or not.\r\n\r\nAdding a recorder is very simple:\r\n\r\n```python\r\nimport pygame as pg\r\nfrom ScreenRecorder import ScreenRecorder, save_recording\r\n\r\npg.init()\r\n\r\ninit_code()\r\n\r\nrecorder = ScreenRecorder(60) # Pass your desired fps\r\nrecorder.start_rec() # Start recording\r\n\r\ntry:\r\n    while True:\r\n        event_handling()\r\n        updating()\r\n        drawing()\r\nfinally:\r\n    recorder.stop_rec()\t# stop recording\r\n    recording = recorder.get_single_recording() # returns a Recording\r\n    save_recording(recording,(\"my_recording\",\"mp4\")) # save the recording as mp4\r\n    clean_up()\r\n    pg.quit()\r\n```\r\n\r\nThis code will record your screen the whole game and then save it in the current working directory as `my_recording.mp4`.\r\nTypical values for the frames per second (fps) are 24 (for slow games), 30, 60 and 120 (Most displays only refresh at 60 Hertz, so most users won't see a difference upwards of 60 fps). Don't forget that the fps value is (at least in theory) proportional to the memory consumption of your recording.\r\n\r\nOne cool thing of many is that you can chain functions:\r\n\r\n```python\r\nrecorder = ScreenRecorder(60)\r\nrecorder.start_rec()\r\n```\r\nis equivalent to\r\n\r\n```python\r\nrecorder = ScreenRecorder(60).start_rec()\r\n```\r\n\r\nAnd\r\n\r\n```python\r\nrecorder.stop_rec()\r\nrecording = recorder.get_single_recording()\r\nsave_recording(recording,(\"my_recording\",\"mp4\"))\r\n```\r\n\r\nis equivalent to\r\n\r\n```python\r\nrecorder.stop_rec().get_single_recording().save(\"my_recording\",\"mp4\")\r\n```\r\n\r\n## Short word on types\r\n\r\n1. The whole codebase is typed -> If you want to contribute use types too\r\n1. AnyPath means any type that can be a file or directory  `str | int | bytes` normally.\r\n2. For me, `pg.Surface` is equivalent to `pg.surface.Surface`. (mypy thinks differently)\r\n\r\n# Advanced Recording Options\r\n\r\nSome of the options available:\r\n\r\n1. Record any surface\r\n2. Compress `ScreenRecorders`\r\n3. Stream recordings (maybe add frame streaming too?)\r\n4. Apply effects on recordings\r\n\r\n## Record any Surface\r\n\r\nIn most cases you want to record the whole screen. But, you can also pass an optional argument `surf` to a `ScreenRecorder`.\r\n\r\n```python\r\nmy_surface = pg.surface.Surface((900,600))\r\nrecorder = ScreenRecorder(60,my_surface)\r\n```\r\n\r\n## Compress recordings\r\n\r\nYou can choose to compress your recordings like this\r\n\r\n```python\r\nrecorder = ScreenRecorder(compress=2) # fps defaults to 60 \r\n```\r\n\r\nWhat does that mean? It means that every frame will be scaled down `2`-times by two. This reduces the total memory consumption by `2^(2^2) = 16`! But normally you will only compress by one or not compress at all. The recordings will automatically be decompressed when played or saved. So don't worry about that. Just try out whether the loss in resolution is okay for your needs.\r\n\r\n## Stream recordings\r\n\r\nA stream in this sense is any object that implements a `send` function that can take a recording. To set a stream pass it to the `ScreenRecorder` constructor.\r\n\r\n```python\r\nclass Stream:\r\n    def send(self,rec):\r\n        print(f\"Recording received with {rec.frame_number} frames, a size of {rec.size} and a total length of {rec.length} s\")\r\n\r\nmy_stream = Stream()\r\nrecorder = ScreenRecorder(stream=my_stream)\r\n```\r\n\r\nNow `recorder.stop_rec()` will send to that stream and also save the recording internally. With `recorder.stop_rec_to_stream(stream = None)` you send to the stream without saving and can optionally specify a stream that will override the recorders default stream.\r\n\r\n## Set individual recordings fps\r\n\r\n```python\r\nScreenRecorder(60).start_rec(30)\r\n```\r\n\r\nwill record at 30 fps for this one recording.\r\n\r\n## Abort a running recording\r\n\r\n`recorder.abort_rec()`\r\n\r\n## Get all recordings of a recorder\r\n\r\n```python\r\nall_recordings = recorder.get_recordings()\r\n```\r\n\r\n## Attributes of a recorder\r\n\r\nThese are the attributes of a `ScreenRecorder` instance. Don't change any of these if you don't have a reason! Create a new recorder instead.\r\n\r\n`fps: float`  \r\nselfexp.\r\n\r\n`surf: pg.Surface`  \r\nselfexp.\r\n\r\n`compress: int`  \r\nselfexp.\r\n\r\n`size`: Tuple[int,int]  \r\nThe size (width, height) of the recorded surface. Change this attribute only if you are also manually changing the surface at the same time.\r\n\r\n`dt: float`  \r\nThe time between (delta time) two frames in ms.  \r\n`dt = 1000/fps`\r\n\r\n`recordings: List[Recording]`  \r\nselfexp. Same as `get_recordings()`\r\n\r\n## Post-Processing a Recording\r\n\r\n1. Add frames\r\n2. Resize\r\n3. Apply effects\r\n\r\n## Adding frames\r\n\r\nYou can always append frames to a recording:\r\n\r\n`recording.add_frame(frame: pg.Surface)`\r\n\r\n## Resize a Recording\r\n\r\nYou might need to rescale a whole recording to a specific size:\r\n\r\n`recording.resize(size: Tuple[int,int])`\r\n\r\n## Apply effects\r\n\r\nIf there is more to do than just resizing:\r\n\r\n`recording.apply(effect: Callable[[pg.Surface], pg.Surface])`\r\n\r\nWill apply the effect on every frame of the recording.\r\n\r\n## Attributes of a recording\r\n\r\nThese are pretty much the same as the attributes of a ScreenRecorder\r\n\r\n`fps: float`  \r\nselfexp.\r\n\r\n`surf: pg.Surface`  \r\nselfexp.\r\n\r\n`compress: int`  \r\nselfexp.\r\n\r\n`size`: Tuple[int,int]  \r\nselfexp. Change this attribute only if you are also manually changing the frames at the same time (e.g. Applying a resizing filter).\r\n\r\n`dt: float`  \r\nselfexp.\r\n\r\n`frames: List[pg.Surface]`  \r\nselfexp.\r\n\r\n# Advanced Saving Options\r\n\r\nIntroducing the RecordingSaver\r\n\r\n`RecordingSaver(recordings: List[Recording], key: str | SupportsIndex | Callable[[int], Optional[Tuple[str,str]]], save_dir: AnyPath = None, blocking: bool = True)`\r\n\r\n```python\r\nrecordings = recorder.get_recordings()\r\nsaver = RecordingSaver(recordings, \"mp4\", \"saved_files\")\r\nsaver.save()\r\n```\r\n\r\nSaves the given recordings as `mp4` files in `./saved_files`  \r\nWe learned that there is a convenient way to do anything. Just call \r\n\r\n```python\r\nsaved_recordings = recorder.save_recordings(\"mp4\", \"saved_files\")\r\n```\r\n\r\n## Explanation\r\n\r\n- key   \r\n    You can either give a str, a list or a function  \r\n    If key is a str that determines the format of the recordings and they will be saved as `recording_0.{key}`,`recording_1.{key}`, etc. \r\n    \r\n    Valid formats are listed if you import `available_formats` from `ScreenRecorder.py`. You can add/update FFmpeg-supported formats by calling `add_codec(format:str, codec: int | str)`.  \r\n\r\n    An interesting option to mention is the `npz` file format. It is not a classical video format but actually a way to save numpy arrays (npz = NumPy Zipped). If you don't need to share the recording in the internet or so, this is an efficient alternative. This library has built-in support for replaying these files.    \r\n\r\n    If key is a list then the ith recording will be saved as the ith element of the recording. This should be a `(filename,format)` tuple. If an element is `None` the recording will be skipped.   \r\n\r\n    It is a very similar case if you give a function. The function gets an int passed and should return `None` or a `(filename,format)` tuple.  \r\n    An example for such a key is\r\n\r\n    ```python\r\n    key = lambda x: if x%2 == 0 then None else (\"recording_{x}\",\"mp4\")\r\n    ```\r\n\r\n    This will return `None` (and skip the save) for every recording with an even index. \r\n- save_dir  \r\nThe directory where the recordings will be saved. Defaults to the current working directory\r\n- blocking  \r\nWhether the save should block. Defaults to True\r\n\r\nThe save returns a list of paths to the recordings in the given directory. This list will not **always** be the same length as the recordings in the `Recorder` but will only return a list of recordings that were actually saved. \r\n\r\nHowever, if you set `block = False` the function will return another function that returns the list of paths and must be called before the script ends! Now you might ask yourself why that makes any sense. Here is an example\r\n\r\n```python\r\n# At this point we have a recorder that recorded some recordings\r\n# Now we want to save the recordings as `mp4` and also as `npz`\r\nimport time #to measure how long the saves took\r\n\r\n# A naive approach is this\r\nstart = time.time()\r\nrecorder.save_recordings(\"mp4\",\"saved_files1\")\r\nrecorder.save_recordings(\"npz\",\"saved_files1\")\r\nprint(\"First save took:\",time.time() - start)\r\n\r\n# Now we use non-blocking (asynchronous) code\r\nstart = time.time()\r\njoin1 = recorder.save_recordings(\"mp4\",\"saved_files2\",False)\r\njoin2 = recorder.save_recordings(\"npz\",\"saved_files2\",False)\r\nprint(\"This message doen't have to wait for the save. Instead it comes almost instantly\")\r\n\r\ntime.sleep(2) #We add some more virtual io with time.sleep\r\n\r\n# Finally we join the save\r\njoin1()\r\njoin2()\r\nprint(\"Second save took:\",time.time() - start)\r\n```\r\n\r\nThe second option is favorable because it takes less time than the first. Unfortunately, I haven't yet implemented a contextmanager for this so you will have to manually join or write your own and contribute to the project. \r\n\r\n## Memory Management\r\n\r\nWe talked about how to efficiently save your recordings (from a time aspect). But now we talk about how you can reduce memory consumption. Generally all video recordings will be automatically compressed by FFmpeg/numpy. However, there are three ways you can reduce memory consumption:  \r\n1. Reduce fps. One cool thing about this ScreenRecorder is that you can record at a different framerate than you play the game. For example you can have a game frame rate of 60 fps but only record at 30 fps. This would halve the memory usage in comparison to if you recorded at 60 fps. \r\n1. Resize the recording. We already established that you can halve the recording size as often as you like. But this will only reduce memory usage while the program runs. The result will still be saved in the original size. However, you can save the recording in a smaller size by using  \r\n    `recording.resize(pg.Vector2(recording.size)/your_scale_factor)`  \r\n    This will actually save and play the recording in that size, which might look very weird. \r\n    So you might not actually want to do that. \r\n1. Shorten the recording length. You can cut out parts of a recording like this. Lets say you only want the first 300 frames.\r\n\r\n    ```python\r\n    recording[0:300]\r\n    #This will actually mutate the recording. If you have issues with this then just share your concerns\r\n    ``` \r\n1. Lastly, you can reduce the depth of the recording by reducing the depth of the recorded screen `pg.display.set_mode((900,600),depth=your_depth)`. This will definitely reduce the memory usage while the program is running and it might also reduce the memory usage on the disk. However, decreasing the depth of the screen will also decrease the variety in color. But in most amateur applications this might just not matter anyway because you are not using very nuanced colors.   \r\n\r\n# Replay recordings\r\n\r\n## First note\r\nI had already implemented a VideoPlayer that could play a Full HD video (1920x816) pretty well (Thats over 6 MB per frame at 24 fps). However, there were several issues (without much detail):\r\n1. Missing sound\r\n1. Memory\r\n1. Lags/Preloading (combined with Memory)\r\n\r\nFinally, I came to the conclusion that it makes no sense to write a VideoPlayer in pure Python. \r\n\r\n## Easiest way to replay a recording\r\n\r\n```py\r\n#easiest\r\nplayer = RecordingPlayer(recording).play()\r\n# with an on_stop callback\r\ndef on_stop(): \r\n    print(\"Playing finished\")\r\nplayer = RecordingPlayer(recording, on_stop).play()\r\n# with a different surface\r\nmy_surface = pg.Surface((900,600))\r\nplayer = RecordingPlayer(recording, None, my_surface).play()\r\n```\r\nMake sure that you are not blitting anything else to the surface. You still have to do the flipping/updating yourself (I figured it would be weird if the player did that for you). \r\n\r\nVery important is that you always `stop` a player in your `finally-clause` even if you normally wait for the player to end. Here a contextmanager might make sense too but I'm tending to rather no. \r\n\r\n## Advanced `RecordingPlayer` Options\r\n\r\n## Pausing\r\nYou already know how to start a player. You can also pause the player with `pause`. Playing is also unpausing.\r\n\r\n```python\r\nplayer.pause() \r\n```\r\n\r\n## Stopping\r\nThis stops the player. As said above, always stop the player if in doubt. However, don't even try to reuse a manually stopped player. As with other objects just make a new player. It's really simple.\r\n\r\n```python\r\nplayer.stop()\r\n```\r\n\r\n## Seeking\r\nSeeking is known from files and means going to a certain position. \r\n\r\n```python\r\nplayer.seek(300) # goes to frame 300 / the 301th frame\r\nplayer.seekms(3000.0) # goes to second 3 of the recording\r\n```\r\n\r\n## Telling\r\nSimilarly telling is also known from files and means getting the current position. \r\n\r\n```python\r\nplayer.tell() # Gets the current position\r\nplayer.tellms() # Gets the current position in milliseconds\r\n```\r\n\r\n## Restarting\r\nThis method is a mixture between reviving the player after it stopped and just seeking the very first frame and playing.\r\n\r\n```python\r\nplayer.restart()\r\n```\r\n\r\nIn the future, restart might take a new recording to play. But that is only a thought. \r\n## Getting state information\r\nThe player has a `is_` function. There are two reasons for the name\r\n1. It resolves the conflict with the python keyword `is`\r\n1. It might make the code more readable, reading `player.is_(\"playing\")` is easy to understand and nicer to implement than making individual function for every possible state\r\n\r\n```python\r\nplayer.is_(\"started\") \r\nplayer.is_(\"stopped\")  \r\nplayer.is_(\"playing\")\r\nplayer.is_(\"paused\")\r\n```\r\n\r\nThey are all pretty self explanatory. But remember two things:\r\n1. `player.is_(\"stopped\")` might be the most important state because you shouldn't call any other function when the player is stopped (Except restart and stop).\r\n1. `is_(\"paused\")` is **not** equal to `not is_(\"playing\")`\r\n\r\n## Making use of the `on_stop`\r\nThe `on_stop` is a very powerful tool because callbacks are always cool. Optionally, `on_stop` will be passed the player object itself. So, you can really do anything you want. I wrote three example callbacks which are very likely to be useful to the API user. Don't forget to import them before you use them (They are not included in `*`). \r\n1. `play_indefinite` will restart the player indefinitely as long as the player is not stopped manually (Stopping the player manually will overwrite the on_stop).\r\n\r\n    ```python\r\n    player = RecordingPlayer(recording,play_indefinite).play()\r\n    ``` \r\n1. `play_n_times` plays the player `n` times.\r\n\r\n    ```python\r\n    player = RecordingPlayer(recording,play_n_times(5)).play() # plays 5 times\r\n    ```\r\n1. `play_n_wrapper` plays the player `n` times but it wraps another function to call each time.  \r\nTo come back to our very first `on_stop`. \r\n\r\n    ```python\r\n    @play_n_wrapper(5)\r\n    def on_stop(): \r\n        print(\"Playing finished\")\r\n    player = RecordingPlayer(recording,on_stop).play()\r\n    ```\r\n\r\n## Playing saved npz files\r\n\r\nI showed you how to save your recordings as `npz` files. However, you also need to know how to play them back. \r\nFor this there is a `NPZPlayer` class. It takes a path to a file and extra parameters just like the `RecordingPlayer`\r\n\r\n```python\r\nplayer = NPZPlayer(\"my_npz_file.npz\", on_stop=my_on_stop).play()\r\n```\r\nIt implements all the methods a `RecordingPlayer` implements too\r\n\r\n# Event Register\r\nOne of my to-dos was an event register. This task is accomplished. Here comes the tutorial for this. \r\n\r\nLet's suppose you are using events and have a deterministic game (No randomness/randomness with a seed). You just need to do four things to record your game. \r\n1. `import EventRegister from EventRegister`\r\n1. Create a new `EventRegister` object\r\n1. Get your events from the object\r\n1. Finally, save the registered events.\r\n\r\n## Example\r\n\r\n```python\r\nimport EventRegister from EventRegister\r\n\r\npg.init()\r\n\r\nreg = EventRegister(\"in\",\"events.json\") # save as json\r\n\r\ntry:\r\n    running = True\r\n    while running:\r\n        time.sleep(0.0099) # 100 fps\r\n        for event in reg.get_events(): # instead of pg.event.get()\r\n            if event.type == pg.QUIT:\r\n                running = False\r\n            elif event.type == pg.MOUSEBUTTONDOWN:\r\n                print(event.button,event.pos)\r\nfinally:\r\n    pg.quit()\r\n    reg.save()\r\n```\r\n\r\nNow to replay that exact recorded game. Just swap `in` with `out` when instanciating the `reg` object and everything should work exactly as expected.\r\n\r\n## Random Seeds\r\n\r\nIf your game uses randomness - which most games should - it's very simple. \r\nThis will automatically load or save the seed depending on the mode.  \r\n\r\n```python\r\nreg = EventRegister(\"in\",\"events.json\").seed()\r\n```\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "",
    "keywords": "",
    "license": "",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pygame-screen-record",
    "package_url": "https://pypi.org/project/pygame-screen-record/",
    "platform": null,
    "project_url": "https://pypi.org/project/pygame-screen-record/",
    "project_urls": {
      "Bug Tracker": "https://github.com/theRealProHacker/PyGameRecorder/issues",
      "Homepage": "https://github.com/theRealProHacker/PyGameRecorder"
    },
    "release_url": "https://pypi.org/project/pygame-screen-record/0.0.4/",
    "requires_dist": [
      "opencv-python (>=4.7.0.68)",
      "pygame (>=2.1.3)"
    ],
    "requires_python": ">=3.8",
    "summary": "A package that allows you to record your pygame game",
    "version": "0.0.4",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 17272174,
  "releases": {
    "0.0.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "ec127fdd43b3028c18dc25e9fa3061afbd946de1902198d5b954dc1192a25cbd",
          "md5": "b436f350163c7e378629ee315823285e",
          "sha256": "adc7d52a5a27c537a83dae286bf9f9c2cccdb84c269dd0ec5c82bf84e4708950"
        },
        "downloads": -1,
        "filename": "pygame_screen_record-0.0.0-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "b436f350163c7e378629ee315823285e",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 27818,
        "upload_time": "2023-02-18T18:50:03",
        "upload_time_iso_8601": "2023-02-18T18:50:03.113239Z",
        "url": "https://files.pythonhosted.org/packages/ec/12/7fdd43b3028c18dc25e9fa3061afbd946de1902198d5b954dc1192a25cbd/pygame_screen_record-0.0.0-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "394d282f776fa3f597f21b425a270f7ccfef2d6abf29aaac3ece8b837c81f779",
          "md5": "b04746e8818c96859f2f2311d0f80dbd",
          "sha256": "6765e51320545a66e2f392b2b9bf9aa029bbdcf11e0139a9197db40aa59d79ec"
        },
        "downloads": -1,
        "filename": "pygame-screen-record-0.0.0.tar.gz",
        "has_sig": false,
        "md5_digest": "b04746e8818c96859f2f2311d0f80dbd",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 32082,
        "upload_time": "2023-02-18T18:50:06",
        "upload_time_iso_8601": "2023-02-18T18:50:06.203722Z",
        "url": "https://files.pythonhosted.org/packages/39/4d/282f776fa3f597f21b425a270f7ccfef2d6abf29aaac3ece8b837c81f779/pygame-screen-record-0.0.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "217cc227f57458d21fbeeab82973afec53f5ba287142e21e526079e239c4f7e7",
          "md5": "4c50adbd6eae30b322d81314b215926c",
          "sha256": "c8ca6bf861a678e95473ad50e45c7171fe939e6474313c764108bbe78038416d"
        },
        "downloads": -1,
        "filename": "pygame_screen_record-0.0.1-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4c50adbd6eae30b322d81314b215926c",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 27557,
        "upload_time": "2023-02-18T18:57:41",
        "upload_time_iso_8601": "2023-02-18T18:57:41.184871Z",
        "url": "https://files.pythonhosted.org/packages/21/7c/c227f57458d21fbeeab82973afec53f5ba287142e21e526079e239c4f7e7/pygame_screen_record-0.0.1-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "20c641945e85efb26d66e0ffdaa51b44ccf7668cf6bae37927f077ceff51bec6",
          "md5": "811569f486182c35793c329125103cc1",
          "sha256": "b5ec227a1df2c81ad8425562217496b7a14296ee5627056b544f0636243d8292"
        },
        "downloads": -1,
        "filename": "pygame-screen-record-0.0.1.tar.gz",
        "has_sig": false,
        "md5_digest": "811569f486182c35793c329125103cc1",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 31598,
        "upload_time": "2023-02-18T18:57:43",
        "upload_time_iso_8601": "2023-02-18T18:57:43.436849Z",
        "url": "https://files.pythonhosted.org/packages/20/c6/41945e85efb26d66e0ffdaa51b44ccf7668cf6bae37927f077ceff51bec6/pygame-screen-record-0.0.1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "075c57cbffdfd847066a24b3ac6c10e958e26f38aacb9aee2954b25f6d4c78e3",
          "md5": "4d0334e59bc9772b4d086efd4cc59582",
          "sha256": "a56b49eab5e53d8a995517f0954e1e8649365211a9ddb214b60da54af183d450"
        },
        "downloads": -1,
        "filename": "pygame_screen_record-0.0.2-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "4d0334e59bc9772b4d086efd4cc59582",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.10",
        "size": 19452,
        "upload_time": "2023-02-18T22:13:03",
        "upload_time_iso_8601": "2023-02-18T22:13:03.404399Z",
        "url": "https://files.pythonhosted.org/packages/07/5c/57cbffdfd847066a24b3ac6c10e958e26f38aacb9aee2954b25f6d4c78e3/pygame_screen_record-0.0.2-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "a4b390be6c7cac10e53b3b82b2b727c33e354eef5f0b218d324eb7724a9ced6d",
          "md5": "f3b888659be73856b4fe44037523dd65",
          "sha256": "44a78a00315e47cae3c29c0dd6cd8f882201c53a19c478f6e782d0602f5befbb"
        },
        "downloads": -1,
        "filename": "pygame-screen-record-0.0.2.tar.gz",
        "has_sig": false,
        "md5_digest": "f3b888659be73856b4fe44037523dd65",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.10",
        "size": 25715,
        "upload_time": "2023-02-18T22:13:06",
        "upload_time_iso_8601": "2023-02-18T22:13:06.473607Z",
        "url": "https://files.pythonhosted.org/packages/a4/b3/90be6c7cac10e53b3b82b2b727c33e354eef5f0b218d324eb7724a9ced6d/pygame-screen-record-0.0.2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "f196bdc360d6d4a38ca69dc8a1d362bf82f88fec84e23967511c05b89f813e45",
          "md5": "3bc53474ae36c7f6ea59709c9f5207cd",
          "sha256": "070cf3103aada0cfd7c145fd23dda2a4bbf0a6b47169812c234fccfad5807621"
        },
        "downloads": -1,
        "filename": "pygame_screen_record-0.0.3-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "3bc53474ae36c7f6ea59709c9f5207cd",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 19532,
        "upload_time": "2023-03-08T10:05:54",
        "upload_time_iso_8601": "2023-03-08T10:05:54.324313Z",
        "url": "https://files.pythonhosted.org/packages/f1/96/bdc360d6d4a38ca69dc8a1d362bf82f88fec84e23967511c05b89f813e45/pygame_screen_record-0.0.3-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "2f4ea27d72b16945aea617ac799cd3a00981cd3204633f5ed27c56a887b4368b",
          "md5": "0bffe30dba1c008c508c00899092a104",
          "sha256": "e747c13a2ac02afbb6722a41bbad14a26580fe65642d22bd99e9999a18a4196d"
        },
        "downloads": -1,
        "filename": "pygame-screen-record-0.0.3.tar.gz",
        "has_sig": false,
        "md5_digest": "0bffe30dba1c008c508c00899092a104",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 25798,
        "upload_time": "2023-03-08T10:05:56",
        "upload_time_iso_8601": "2023-03-08T10:05:56.557071Z",
        "url": "https://files.pythonhosted.org/packages/2f/4e/a27d72b16945aea617ac799cd3a00981cd3204633f5ed27c56a887b4368b/pygame-screen-record-0.0.3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "0.0.4": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "43b6498c1ca932d23cda42f92a0c73bfcb7608bc5ee20f88fa37b78a8fbde0ba",
          "md5": "463e4ea0fe37daad7720dfb4f0ddbcf3",
          "sha256": "fbc8be5557521e6a77c6d443c65868976eb19890d145eebc3b80a6cf5a337be7"
        },
        "downloads": -1,
        "filename": "pygame_screen_record-0.0.4-py3-none-any.whl",
        "has_sig": false,
        "md5_digest": "463e4ea0fe37daad7720dfb4f0ddbcf3",
        "packagetype": "bdist_wheel",
        "python_version": "py3",
        "requires_python": ">=3.8",
        "size": 19574,
        "upload_time": "2023-03-13T14:24:02",
        "upload_time_iso_8601": "2023-03-13T14:24:02.050104Z",
        "url": "https://files.pythonhosted.org/packages/43/b6/498c1ca932d23cda42f92a0c73bfcb7608bc5ee20f88fa37b78a8fbde0ba/pygame_screen_record-0.0.4-py3-none-any.whl",
        "yanked": false,
        "yanked_reason": null
      },
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "aecc749867082053144af7c3d5e367c29d8ce55797d69aa1c1f53e145ef266fd",
          "md5": "a1b07aaedd60edd1fcedc9a1e617e05e",
          "sha256": "b47bb427a9d7054e7dd17a392bc163ecd35e696620f7465690a4acfbc8fe1d60"
        },
        "downloads": -1,
        "filename": "pygame-screen-record-0.0.4.tar.gz",
        "has_sig": false,
        "md5_digest": "a1b07aaedd60edd1fcedc9a1e617e05e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.8",
        "size": 25908,
        "upload_time": "2023-03-13T14:24:05",
        "upload_time_iso_8601": "2023-03-13T14:24:05.775674Z",
        "url": "https://files.pythonhosted.org/packages/ae/cc/749867082053144af7c3d5e367c29d8ce55797d69aa1c1f53e145ef266fd/pygame-screen-record-0.0.4.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "43b6498c1ca932d23cda42f92a0c73bfcb7608bc5ee20f88fa37b78a8fbde0ba",
        "md5": "463e4ea0fe37daad7720dfb4f0ddbcf3",
        "sha256": "fbc8be5557521e6a77c6d443c65868976eb19890d145eebc3b80a6cf5a337be7"
      },
      "downloads": -1,
      "filename": "pygame_screen_record-0.0.4-py3-none-any.whl",
      "has_sig": false,
      "md5_digest": "463e4ea0fe37daad7720dfb4f0ddbcf3",
      "packagetype": "bdist_wheel",
      "python_version": "py3",
      "requires_python": ">=3.8",
      "size": 19574,
      "upload_time": "2023-03-13T14:24:02",
      "upload_time_iso_8601": "2023-03-13T14:24:02.050104Z",
      "url": "https://files.pythonhosted.org/packages/43/b6/498c1ca932d23cda42f92a0c73bfcb7608bc5ee20f88fa37b78a8fbde0ba/pygame_screen_record-0.0.4-py3-none-any.whl",
      "yanked": false,
      "yanked_reason": null
    },
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "aecc749867082053144af7c3d5e367c29d8ce55797d69aa1c1f53e145ef266fd",
        "md5": "a1b07aaedd60edd1fcedc9a1e617e05e",
        "sha256": "b47bb427a9d7054e7dd17a392bc163ecd35e696620f7465690a4acfbc8fe1d60"
      },
      "downloads": -1,
      "filename": "pygame-screen-record-0.0.4.tar.gz",
      "has_sig": false,
      "md5_digest": "a1b07aaedd60edd1fcedc9a1e617e05e",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.8",
      "size": 25908,
      "upload_time": "2023-03-13T14:24:05",
      "upload_time_iso_8601": "2023-03-13T14:24:05.775674Z",
      "url": "https://files.pythonhosted.org/packages/ae/cc/749867082053144af7c3d5e367c29d8ce55797d69aa1c1f53e145ef266fd/pygame-screen-record-0.0.4.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}