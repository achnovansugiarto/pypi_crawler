{
  "info": {
    "author": "Brainbit Inc.",
    "author_email": "support@brainbit.com",
    "bugtrack_url": null,
    "classifiers": [
      "Intended Audience :: Developers",
      "License :: OSI Approved :: MIT License",
      "Operating System :: Microsoft :: Windows",
      "Programming Language :: Python :: 3"
    ],
    "description": "# Python NeuroSDK 2\r\n\r\nWelcome to the Python NeuroSDK 2. The Neurosdk library is designed to work with BrainBit, BrainBitBlack, Callibri and Kolibri devices. The library is intended for python version 3.7 and higher, Windows version 10 and higher.\r\n\r\n## Documentation\r\n\r\n- [Installing](#installing)\r\n- [Description](#description)\r\n- [Searching device](#searching-device)\r\n- [Connection](#connection)\r\n- [Parameters](#paramaters)\r\n- [Receiving signal](#receiving-signal)\r\n- [Receiving resistance](#receiving-resistance)\r\n- [Electrodes connection](#electrodes-connection)\r\n- [Clean up](#clean_up)\r\n\r\n## Installing\r\n\r\n```\r\npip install pyneurosdk2\r\n```\r\n\r\n## Description\r\n\r\nThe package has the following structure:\r\n - neurosdk - the main package with the implementation of methods\r\n - sample - is into the neurosdk package, file `sample.py`\r\n - libs - also into neurosdk package, contain dll library files\r\n\r\nThe library provides three main modules:\r\n\r\n- scanner - to search for devices\r\n\r\n```python\r\nfrom neurosdk.scanner import Scanner\r\n```\r\n\r\n- sensor - methods of interaction with the device\r\n\r\n```python\r\nfrom neurosdk.sensor import Sensor\r\n```\r\n\r\n- types - implementation of all types of the library, you can either connect everything or only those necessary for a specific task\r\n\r\n```python\r\nfrom neurosdk.cmn_types import *\r\n```\r\n\r\nHere is a description of how to work with a BrainBit device.\r\n\r\n## Searching device\r\n\r\nThe `Scanner` class is used to search for a device. For a correct search, you must specify the list of device types. You can search for one or more device types at the same time. For example, to search for BrainBit and Callibri, you need to create a scanner as follows:\r\n\r\n```python\r\nscanner = Scanner([SensorFamily.SensorLEBrainBit, SensorFamily.SensorLECallibri])\r\n```\r\n\r\nSearch start:\r\n\r\n```python\r\nscanner.Start()\r\n```\r\n\r\nStop search:\r\n\r\n```python\r\nscanner.Stop()\r\n```\r\n\r\nAll found devices can be obtained using the method:\r\n\r\n```python\r\nsensors = scanner.Sensors()\r\n```\r\n\r\nDuring the search, an `sensorsChanged` callback will be called, which will display a list of found devices. If the device leaves the scanner's field of view for any reason, the device will disappear from the list after 12 seconds.\r\n\r\n```python\r\ndef sensorFound(scanner, sensors):\r\n   for i in range(len(sensors)):\r\n       print('Sensor %s' % sensors[i])\r\n\r\nscanner.sensorsChanged = sensorFound\r\n```\r\n\r\nThe sensor's list will contain records of the SensorInfo type with fields:\r\n\r\n- SensFamily: SensorFamily\r\n- SensModel: int\r\n- Name: str\r\n- Address: str\r\n- SerialNumber: str\r\n- PairingRequired: bool\r\n\r\n> Important!\r\n> The serial number of the Callibri and Kolibri does not appear in the SensorInfo recieving during the search. To get this value, you need to connect to the device and request the serial number manually:\r\n>\r\n> ```python\r\n> sn = sensor.SerialNumber\r\n> ```\r\n\r\n\r\n## Connection\r\n\r\nNext, you can create any device from the list using the method:\r\n\r\n```python\r\nsensor = scanner.CreateSensor(sensInfo)\r\n```\r\nWhen created, the device will connect automatically. This is a blocking function, so it is desirable to call it from an separate thread. Upon successful connection, a sensor instance will be returned. If unsuccessful, an exception is thrown. On subsequent connections and disconnections, a callback will be called indicating the state of the device.\r\n\r\nTo disconnect from the device, use the following method:\r\n\r\n```python\r\nsensor.Disconnect()\r\n```\r\n\r\nTo connect to a device created but not connected for any reason, the method:\r\n\r\n```python\r\nsensor.Connect()\r\n```\r\n\r\nIt is blocking too.\r\n\r\n## Parameters\r\n\r\nSDK allows you to get information about the connected device:\r\n\r\n```python\r\nprint(sensor.SensFamily) # SensorFamily.SensorLEBrainBit\r\nprint(sensor.Features) # [<SensorFeature.FeatureSignal: 0>, ...]\r\nprint(sensor.Commands) # [<SensorCommand.CommandStartSignal: 0>,...]\r\nprint(sensor.Parameters)\r\nprint(sensor.Name) # BrainBit\r\nprint(sensor.State) # SensorState.StateInRange\r\nprint(sensor.Address) # AA:BB:CC:DD:EE:FF\r\nprint(sensor.SerialNumber) # 123456\r\nprint(sensor.BattPower) # 50\r\nprint(sensor.SamplingFrequency) # SensorSamplingFrequency.FrequencyHz250\r\nprint(sensor.Gain) # SensorGain.SensorGain6\r\nprint(sensor.DataOffset) # SensorDataOffset.DataOffset0\r\nprint(sensor.Version) # SensorVersion(FwMajor=50, FwMinor=0, FwPatch=0, HwMajor=1, HwMinor=0, HwPatch=0, ExtMajor=65)\r\n```\r\n\r\n>  You can distinguish BrainBit device from Flex by the firmware version number: if the `SensorVersion.FwMajor` is more than 100 - it's Flex, if it's less than BrainBit.\r\n\r\nIf you need to change any property, you first need to check if it is writable. This can be done by reading the list of device parameters, where each parameter will have an access level:\r\n\r\n```\r\n[ParameterInfo(Param=<SensorParameter.ParameterOffset: 8>, ParamAccess=<SensorParamAccess.ParamAccessRead: 0>),  \r\n ParameterInfo(Param=<SensorParameter.ParameterState: 1>,  ParamAccess=<SensorParamAccess.ParamAccessReadNotify: 2>)\r\n ...]\r\n```\r\n\r\nAnd also check the support of certain modules:\r\n\r\n```python\r\nsensor.IsSupportedFeature(sensor_future)\r\nsensor.IsSupportedCommand(sensor_command)\r\nsensor.IsSupportedParameter(sensor_parameter)\r\n```\r\n\r\n## Receiving signal\r\n\r\nFor any device that supports recieving signal, you can run the following commands for starting:\r\n\r\n```python\r\nsensor.ExecCommand(SensorCommand.CommandStartSignal)\r\n```\r\n\r\nStop:\r\n\r\n```python\r\nsensor.ExecCommand(SensorCommand.CommandStopSignal)\r\n```\r\n\r\n### BrainBit, BrainBitBlack, Flex\r\n\r\nYou can get the signal value using the callback:\r\n\r\n```python\r\ndef onBrainBitSignalDataReceived(sensor, data):\r\n   print(data)\r\n\r\nsensor.brainBitSignalDataReceived = onBrainBitSignalDataReceived\r\n```\r\n\r\nAfter you have finished working with the signal, you can unsubscribe from the callback as follows:\r\n\r\n```python\r\nsensor.brainBitSignalDataReceived = None\r\n```\r\n\r\nIt gives a list of packages. Each package contains:\r\n- PackNum: int\r\n- Marker: int\r\n- O1: float\r\n- O2: float\r\n- T3: float\r\n- T4: float\r\n\r\nIt is values from 4 channels in volts, a number for each packet and a marker if it was sent and this feature is supported by the device.\r\n\r\n### Callibri, Kolibri\r\n\r\nYou can get the signal value using the callback:\r\n\r\n```python\r\ndef onCallibriSignalDataReceived(sensor, data):\r\n   print(data)\r\n\r\nsensor.callibriSignalDataReceived = onCallibriSignalDataReceived\r\n```\r\n\r\nAfter you have finished working with the signal, you can unsubscribe from the callback as follows:\r\n\r\n```python\r\nsensor.callibriSignalDataReceived = None\r\n```\r\n\r\nIt gives a list of packages. Each package contains:\r\n - PackNum: int\r\n - Samples: [float]\r\n\r\nIt is values in volts and a number for each packet.\r\n\r\n## Receiving resistance\r\n\r\nResistance is only supported by BrainBit, BrainBitBlack and Flex. You can also check the availability of these features using the method `sensor.IsSupportedFeature(SensorFeature.FeatureResist)`.\r\n\r\nTo get resistance values:\r\n\r\n```python\r\ndef onBrainBitResistDataReceived(sensor, data):\r\n   print(data)\r\n\r\nsensor.brainBitResistDataReceived = onBrainBitResistDataReceived\r\n\r\nsensor.ExecCommand(SensorCommand.CommandStartResist)\r\nsensor.ExecCommand(SensorCommand.CommandStopResist)\r\n```\r\n\r\nThe callback returns one packet of samples, each packet contains the resistance values in volts:\r\n- O1: float\r\n- O2: float\r\n- T3: float\r\n- T4: float\r\n\r\nAfter you have finished working with the resistance, you can unsubscribe from the callback as follows:\r\n\r\n```python\r\nsensor.brainBitResistDataReceived = None\r\n```\r\n\r\n> BrainBit cannot be in the resistance and signal readout mode at the same time, so you must first get the resistance values, but only after this signal, or vice versa. For example:\r\n> ```python\r\n> sensor.ExecCommand(SensorCommand.CommandStartResist)\r\n> sleep(10)\r\n> sensor.ExecCommand(SensorCommand.CommandStopResist)\r\n> ...\r\n> sensor.ExecCommand(SensorCommand.CommandStartSignal)\r\n> sleep(10)\r\n> sensor.ExecCommand(SensorCommand.CommandStopSignal)\r\n> ```\r\n\r\n## Electrodes connection\r\n\r\nElectrode placement check is available for Callibri and Kolibri devices. This data shows whether the electrodes are attached to the skin.\r\n\r\n```python\r\ndef onCallibriElectrodeStateChanged(sensor, data):\r\n   print(data)\r\n\r\nsensor.callibriElectrodeStateChanged = onCallibriElectrodeStateChanged\r\n```\r\n\r\nFor unsubscribe from callback:\r\n\r\n```python\r\nsensor.callibriElectrodeStateChanged = None\r\n```\r\n\r\nElectrodes state can be one of values of enum:\r\n- ElStNormal = 0\r\n- ElStHighResistance = 1\r\n- ElStDetached = 2\r\n\r\nTo get the state of the electrodes, you need to start a signal from the device.You can receive electrode and signal values at the same time.\r\n\r\n## Clean up\r\n\r\nAfter you finish working with the device, you need to clean up the resources used. This happens in the destructor of the scanner and sensor, so if they were not called by the system, you must call them manually.\r\n\r\n```python\r\ndel sensor\r\ndel scanner\r\n```\r\n\r\n## License\r\n\r\nCopyright (c) Brainbit Inc. All rights reserved.\r\n\r\nLicensed under the [MIT license](LICENSE).\r\n",
    "description_content_type": "text/markdown",
    "docs_url": null,
    "download_url": "",
    "downloads": {
      "last_day": -1,
      "last_month": -1,
      "last_week": -1
    },
    "home_page": "https://gitlab.com/brainbit-inc/brainbit-sdk",
    "keywords": "",
    "license": "MIT",
    "maintainer": "",
    "maintainer_email": "",
    "name": "pyneurosdk2",
    "package_url": "https://pypi.org/project/pyneurosdk2/",
    "platform": null,
    "project_url": "https://pypi.org/project/pyneurosdk2/",
    "project_urls": {
      "Homepage": "https://gitlab.com/brainbit-inc/brainbit-sdk"
    },
    "release_url": "https://pypi.org/project/pyneurosdk2/1.0.3.0.post3/",
    "requires_dist": null,
    "requires_python": ">=3.7",
    "summary": "Python wrapper for NeuroSDK2",
    "version": "1.0.3.0.post3",
    "yanked": false,
    "yanked_reason": null
  },
  "last_serial": 15995020,
  "releases": {
    "1.0.3.0": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "bca97f58821274e9c3ed5cd761e4e713f346be84573150d3aa6d08c518126071",
          "md5": "e811ccdf3a85889c96ccd2d982516e1e",
          "sha256": "4e0ef986761637f14161a90e7ff195ee1507dae80ce2de2dcd5dba2f07542f73"
        },
        "downloads": -1,
        "filename": "pyneurosdk2-1.0.3.0.tar.gz",
        "has_sig": false,
        "md5_digest": "e811ccdf3a85889c96ccd2d982516e1e",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 1545115,
        "upload_time": "2022-11-24T14:36:01",
        "upload_time_iso_8601": "2022-11-24T14:36:01.022311Z",
        "url": "https://files.pythonhosted.org/packages/bc/a9/7f58821274e9c3ed5cd761e4e713f346be84573150d3aa6d08c518126071/pyneurosdk2-1.0.3.0.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3.0.post1": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "d19ed07cab76bb98b55b4c2d0d160c314bf8aa11d8dce92b777ae24bf1e55baf",
          "md5": "1607487adda129954a7c29934666e9ed",
          "sha256": "7e2147e205aec0f228875cb1ba7d9d4d00bf9a3b3cb1af78073bf6003ed186a8"
        },
        "downloads": -1,
        "filename": "pyneurosdk2-1.0.3.0.post1.tar.gz",
        "has_sig": false,
        "md5_digest": "1607487adda129954a7c29934666e9ed",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 1545123,
        "upload_time": "2022-11-24T15:04:53",
        "upload_time_iso_8601": "2022-11-24T15:04:53.366925Z",
        "url": "https://files.pythonhosted.org/packages/d1/9e/d07cab76bb98b55b4c2d0d160c314bf8aa11d8dce92b777ae24bf1e55baf/pyneurosdk2-1.0.3.0.post1.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3.0.post2": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "80ef147c7ba4c2cfb26ab06d00022d3db72aa1eef9b7ee1201f9a16836fd6b07",
          "md5": "83d1662a6d04ec480f3b646f27281d52",
          "sha256": "5e834f0587c601e39dc2ecd7d09dc137fbadbe0295474ee3d34d1d3ba3ad1e41"
        },
        "downloads": -1,
        "filename": "pyneurosdk2-1.0.3.0.post2.tar.gz",
        "has_sig": false,
        "md5_digest": "83d1662a6d04ec480f3b646f27281d52",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 1545701,
        "upload_time": "2022-11-25T13:04:27",
        "upload_time_iso_8601": "2022-11-25T13:04:27.439622Z",
        "url": "https://files.pythonhosted.org/packages/80/ef/147c7ba4c2cfb26ab06d00022d3db72aa1eef9b7ee1201f9a16836fd6b07/pyneurosdk2-1.0.3.0.post2.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ],
    "1.0.3.0.post3": [
      {
        "comment_text": "",
        "digests": {
          "blake2b_256": "5d8482228040347cf794440287526f5ce7e167b7eda8e965bfc4d2093aaf3b06",
          "md5": "deb70f893429f736c1b074ef44e22826",
          "sha256": "2f956795a2c71a73002b18335bb1629cf950f76a72abec85b4818ee006c79ef8"
        },
        "downloads": -1,
        "filename": "pyneurosdk2-1.0.3.0.post3.tar.gz",
        "has_sig": false,
        "md5_digest": "deb70f893429f736c1b074ef44e22826",
        "packagetype": "sdist",
        "python_version": "source",
        "requires_python": ">=3.7",
        "size": 1547221,
        "upload_time": "2022-12-05T12:43:03",
        "upload_time_iso_8601": "2022-12-05T12:43:03.580075Z",
        "url": "https://files.pythonhosted.org/packages/5d/84/82228040347cf794440287526f5ce7e167b7eda8e965bfc4d2093aaf3b06/pyneurosdk2-1.0.3.0.post3.tar.gz",
        "yanked": false,
        "yanked_reason": null
      }
    ]
  },
  "urls": [
    {
      "comment_text": "",
      "digests": {
        "blake2b_256": "5d8482228040347cf794440287526f5ce7e167b7eda8e965bfc4d2093aaf3b06",
        "md5": "deb70f893429f736c1b074ef44e22826",
        "sha256": "2f956795a2c71a73002b18335bb1629cf950f76a72abec85b4818ee006c79ef8"
      },
      "downloads": -1,
      "filename": "pyneurosdk2-1.0.3.0.post3.tar.gz",
      "has_sig": false,
      "md5_digest": "deb70f893429f736c1b074ef44e22826",
      "packagetype": "sdist",
      "python_version": "source",
      "requires_python": ">=3.7",
      "size": 1547221,
      "upload_time": "2022-12-05T12:43:03",
      "upload_time_iso_8601": "2022-12-05T12:43:03.580075Z",
      "url": "https://files.pythonhosted.org/packages/5d/84/82228040347cf794440287526f5ce7e167b7eda8e965bfc4d2093aaf3b06/pyneurosdk2-1.0.3.0.post3.tar.gz",
      "yanked": false,
      "yanked_reason": null
    }
  ],
  "vulnerabilities": []
}